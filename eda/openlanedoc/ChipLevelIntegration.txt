Chip Level Integration#
Using OpenLane, you can produce a GDSII from a chip RTL.
The Current Methodology#
The current methodology views the chip using the following hierarchy:
Chip Core
The hard macros
The rest of the design
Chip IO
IO Pads
Power Pads
Corner Pads
The current methodology goes as follows:
Hardening the hard macros.
Hardening the core with the hard macros inside it.
Hardening the padframe
Hardening the full chip with the padframe.
Hardening Macros#
This is discussed in more detail here.
Hardening The Core#
The chip core would usually have other macros inside it.
You need to set the following environment variables in your configuration file for the chip core:
Key
Description
VERILOG_FILES
Whitespace-delimited list of Verilog files*.
VERILOG_FILES_BLACKBOX
Black-box, Verilog files where the implementation is ignored. Useful for pre-hardened macros you incorporate into your design.
EXTRA_LEFS
LEF files for pre-hardened macros you incorporate into your design.
EXTRA_LIBS
Specifies LIB files of pre-hardened macros used in the current design, used to improve timing analysis. (Optional)
EXTRA_GDS_FILES
GDS files for pre-hardened macros you incorporate into your design.
SYNTH_READ_BLACKBOX_LIB
1/0 (Tcl), true/false (JSON): Should be set to true if you are using any standard cells directly in your design, i.e., your design does not function purely at the register transfer level.
MACRO_PLACEMENT_CFG
A path to a file containing a line-break delimited list of instances and positions if you want to manually place the macros in specific locations, in the format instance_name X_pos Y_pos Orientation. The manual_macro_placement_test example under designs should be a good example.
* The `include directive is not supported.
You can follow the same instructions provided here for the rest of the hardenning steps.
Here you can find a list of all the available OpenLane configuration variables.
Hardening The Full Chip#
The full chip requires an interactive script to harden. You could take this full chip as an example.
First you need to harden the padframe as a separate macro, check this flow as an example on how to do so.
You need to set all environment variables mentioned in Hardening the Core, but also:
Key
Description
SYNTH_FLAT_TOP
1/0 (Tcl), true/false (JSON): Flattens the padframe if true (and presented in a chip_io module). Otherwise, you can harden it separately as indicated in this flow.
The following inputs are provided to produce the final GDSII:
Padframe cfg file (provided by the user or generated by padring). Here is an example. Or a hardened chip_io.gds and chip_io.lef following this.
Hardened lef & GDSII for the core module, generated here
Top level netlist instantiating pads and core module (Could be provided by the user or generated by topModuleGen)
The interactive script for the IOs does the following:
Sources configurations.
Elaborates the verilog.
Runs floorplan.
Uses odbpy/padringer.py to generate the padframe.
Adds the obstructions to the core area, and removes core nets and pins.
Routes.
Streams out the GDSII and the LEFv view.
Given these inputs the following interactive script script. Mainly, it does the following steps:
Runs the top level netlist through yosys.
Runs floorplan.
Performs manual placement of the core macros, this sample has many cores, however for full automation you should have only a single core.
Legalize the placement.
Removes Nets and Pins to a different file.
This stages is skipped because the design has many cores and so fully automated power routing is not possible. However if you only have a single core, you can perform automatic power routing by adding power_routing at this stage in your interactive script.
Route the design.
Perform power routing.
Generate a GDSII file of the routed design.
Run DRC and LVS checks here.
Power_routing#
Macros#
This is discussed in detail here.
Core#
It should have an stdcell section that includes a core_ring on met4 and met5. It should use met5 and met4 for the straps, and met1 for the rails. Thus, make sure to add these to your config file:
JSONTcl
    "DESIGN_IS_CORE": true,
    "FP_PDN_CORE_RING": true
    set ::env(DESIGN_IS_CORE) 1
    set ::env(FP_PDN_CORE_RING) 1
You can automate the power routing process in the core and macro level by reading this documentation. Otherwise, refer to this for more details about the syntax. In case you needed to create your own pdn.tcl then point to it using FP_PDN_CFG.
When you use the power_routing command in the chip interactive script, the power pads will be connected to the core ring, and thus the whole chip would be powered.
General Notes#
This includes more guidance on how to create an interactive script.
This documents all OpenLane configurations.
This has a description for all OpenLane commands.
