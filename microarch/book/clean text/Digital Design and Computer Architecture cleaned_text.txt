Authors David Money Harris associate professor engineering Harvey Mudd College. received Ph.D. electrical engineering Stanford University M.Eng. electrical engineering com- puter science MIT. attending Stanford, worked Intel logic circuit designer Itanium Pentium II processors. Since then, consulted Sun Microsystems, Hewlett-Packard, Evans & Sutherland, design companies. David’s passions include teaching, building chips, exploring outdoors. work, usually found hiking, mountaineering, rock climbing. particularly enjoys hiking son, Abraham, born start book project. David holds dozen patents author three textbooks chip design, well two guidebooks Southern California mountains. Sarah L. Harris assistant professor engineering Harvey Mudd College. received Ph.D. M.S. electrical engineering Stanford University. attending Stanford, received B.S. elec- trical computer engineering Brigham Young University. Sarah also worked Hewlett-Packard, San Diego Supercomputer Center, Nvidia, Microsoft Research Beijing. Sarah loves teaching, exploring developing new technologies, traveling, wind surfing, rock climbing, playing guitar. recent exploits include researching sketching interfaces digital circuit design, acting science correspondent National Public Radio affiliate, learning kite surf. speaks four languages looks for- ward adding list near future.Prelims.qxd 1/31/07 8:22 PM Page ivxviiPreface publish yet another book digital design computer architec- ture? dozens good books print digital design. also several good books computer architecture, especially classic texts Patterson Hennessy. book unique treat- ment presents digital logic design perspective com- puter architecture, starting beginning 1’s 0’s, leading students design MIPS microprocessor. used several editions Patterson Hennessy’s Computer Organization Design (COD ) many years Harvey Mudd College. particularly like coverage MIPS architec- ture microarchitecture MIPS commercially successful microprocessor architecture, yet simple enough clearly explain build introductory class. class prerequi- sites, first half semester dedicated digital design, covered COD . universities indicated need book combines digital design computer architecture. undertaken prepare book. believe building microprocessor special rite passage engineering computer science students. inner workings processor seem almost magical uninitiated, yet prove straightforward carefully explained. Digital design powerful exciting subject. Assembly language programming unveils inner language spoken processor. Microarchitecture link brings together. book suitable rapid-paced, single-semester introduc- tion digital design computer architecture two-quarter two-semester sequence giving time digest material experiment lab. prerequisite basic familiarity high-level programming language C, C++, Java. mate- rial usually taught sophomore- junior-year level, may also accessible bright freshmen programming experience. Prelims.qxd 1/31/07 8:22 PM Page xviiFEATURES book offers number special features. Side-by-Side Coverage Verilog VHDL Hardware description languages (HDLs) center modern dig- ital design practices. Unfortunately, designers evenly split two dominant languages, Verilog VHDL. book introduces HDLs Chapter 4 soon combinational sequential logic design covered. HDLs used Chapters 5 7 design larger building blocks entire processors. Nevertheless, Chapter 4 skipped later chapters still accessible courses choose cover HDLs. book unique side-by-side presentation Verilog VHDL, enabling reader quickly compare contrast two languages. Chapter 4 describes principles applying HDLs, provides language-specific syntax examples adjacent columns. side-by-side treatment makes easy instructor choose either HDL, reader transition one other, either class professional practice. Classic MIPS Architecture Microarchitecture Chapters 6 7 focus MIPS architecture adapted treat- ment Patterson Hennessy. MIPS ideal architecture real architecture shipped millions products yearly, yet streamlined easy learn. Moreover, hundreds universities around world developed pedagogy, labs, tools around MIPS architecture. Real-World Perspectives Chapters 6, 7, 8 illustrate architecture, microarchitecture, memory hierarchy Intel IA-32 processors. real-world perspec- tive chapters show concepts chapter relate chips found PCs. Accessible Overview Advanced Microarchitecture Chapter 7 includes overview modern high-performance microar- chitectural features including branch prediction, superscalar out-of- order operation, multithreading, multicore processors. treatment accessible student first course shows microarchitectures book extended modern processors. End-of-Chapter Exercises Interview Questions best way learn digital design it. chapter ends numerous exercises practice material. exercises followed set interview questions industrial colleagues asked students applying work field. questions provide helpfulxviii PREFACEPrelims.qxd 1/31/07 8:22 PM Page xviiiglimpse types problems job applicants typically encounter interview process. (Exercise solutions available via book’s companion instructor Web pages. details, see next section, Online Supplements.) ONLINE SUPPLEMENTS Supplementary materials available online textbooks.elsevier.com/ 9780123704979 . companion site (accessible readers) includes: /L50776Solutions odd-numbered exercises /L50776Links professional-strength computer-aided design (CAD) tools Xilinx®and Synplicity® /L50776Link PCSPIM, Windows-based MIPS simulator /L50776Hardware description language (HDL) code MIPS processor /L50776Xilinx Project Navigator helpful hints /L50776Lecture slides PowerPoint (PPT) format /L50776Sample course lab materials /L50776List errata instructor site (linked companion site accessible adopters register textbooks.elsevier.com ) includes: /L50776Solutions even-numbered exercises /L50776Links professional-strength computer-aided design (CAD) tools Xilinx®and Synplicity®. (Instructors qualified universi- ties access freeSynplicity tools use classroom laboratories. details available instructor site.) /L50776Figures text JPG PPT formats Additional details using Xilinx, Synplicity, PCSPIM tools course provided next section. Details sample lab materials also provided here. USE SOFTWARE TOOLS COURSE Xilinx ISE WebPACK Xilinx ISE WebPACK free version professional-strength Xilinx ISE Foundation FPGA design tools. allows students enter digi- tal designs schematic using either Verilog VHDL hardware description language (HDL). entering design, students canPREFACE xixPrelims.qxd 1/31/07 8:22 PM Page xixsimulate circuits using ModelSim MXE III Starter, included Xilinx WebPACK. Xilinx WebPACK also includes XST, logic synthesis tool supporting Verilog VHDL. difference WebPACK Foundation WebPACK supports subset common Xilinx FPGAs. difference ModelSim MXE III Starter ModelSim commercial versions Starter degrades performance simulations 10,000 lines HDL. Synplify Pro Synplify Pro®is high-performance, sophisticated logic synthesis engine FPGA CPLD designs. Synplify Pro also contains HDL Analyst, graphical interface tool generates schematic views HDL source code. found immensely useful learning debugging process. Synplicity generously agreed donate Synplify Pro quali- fied universities provide many licenses needed fill university labs. Instructors visit instructor Web page text information request Synplify Pro licenses. additional information Synplicity software, visit www.synplicity.com/university . PCSPIM PCSPIM, also called simply SPIM, Windows-based MIPS simulator runs MIPS assembly code. Students enter MIPS assembly code text file run using PCSPIM. PCSPIM displays instruc- tions, memory, register values. Links user’s manual example file available companion site (textbooks.elsevier.com/ 9780123704979). LABS companion site includes links series labs cover topics digital design computer architecture. labs teach stu- dents use Xilinx WebPACK Foundation tools enter, simulate, synthesize, implement designs. labs also include topics assembly language programming using PCSPIM simulator. synthesis, students implement designs using Digilent Spartan 3 Starter Board XUP-Virtex 2 Pro (V2Pro) Board. powerful competitively priced boards available www.digilentinc.com . boards contain FPGAs programmed implement student designs. provide labs describe imple- ment selection designs using Digilent’s Spartan 3 Board usingxx PREFACEPrelims.qxd 1/31/07 8:22 PM Page xxPREFACE xxi WebPACK. Unfortunately, Xilinx WebPACK support huge FPGA V2Pro board. Qualified universities may contact Xilinx University Program request donation full Foundation tools. run labs, students need download install Xilinx WebPACK, PCSPIM, possibly Synplify Pro. Instructors may also choose install tools lab machines. labs include instruc- tions implement projects Digilent’s Spartan 3 Starter Board. implementation step may skipped, found great value. labs also work XST synthesis tool, recommend using Synplify Pro schematics produces give students invaluable feedback. tested labs Windows, tools also available Linux. BUGS experienced programmers know, program significant com- plexity undoubtedly contains bugs. books. taken great care find squash bugs book. However, errors undoubtedly remain. maintain list errata book’s Web page. Please send bug reports ddcabugs@onehotlogic.com . first person report substantive bug fix use future print- ing rewarded $1 bounty! (Be sure include mailing address.) ACKNOWLEDGMENTS First foremost, thank David Patterson John Hennessy pioneering MIPS microarchitectures described Computer Organization Design textbook. taught various editions book many years. appreciate gracious support book permission build microarchitectures. Duane Bibby, favorite cartoonist, labored long hard illus- trate fun adventure digital design. also appreciate enthu- siasm Denise Penrose, Nate McFadden, rest team Morgan Kaufmann made book happen. Jeff Somers Graphic World Publishing Services ably guided book production. Numerous reviewers substantially improved book. include John Barr (Ithaca College), Jack V. Briner (Charleston Southern University), Andrew C. Brown (SK Communications), Carl Baumgaertner (Harvey Mudd College), A. Utku Diril (Nvidia Corporation), Jim Frenzel (University Idaho), Jaeha Kim (Rambus, Inc.), Phillip KingPrelims.qxd 1/31/07 8:22 PM Page xxixxii PREFACE (ShotSpotter, Inc.), James Pinter-Lucke (Claremont McKenna College), Amir Roth, Z. Jerry Shi (University Connecticut), James E. Stine (Oklahoma State University), Luke Teyssier, Peiyi Zhao (Chapman University), anonymous reviewer. Simon Moore wonderful host David’s sabbatical visit Cambridge University, major sections book written. also appreciate students course Harvey Mudd College given us helpful feedback drafts textbook. special note Casey Schilling, Alice Clifton, Chris Acon, Stephen Brawner. I, David, particularly thank wife, Jennifer, gave birth son Abraham beginning project. appreciate patience loving support yet another project busy time lives.Prelims.qxd 1/31/07 8:22 PM Page xxii1 1.1 Game Plan 1.2 Art Managing Complexity 1.3 Digital Abstraction 1.4 Number Systems 1.5 Logic Gates 1.6 Beneath Digital Abstraction 1.7 CMOS Transistors* 1.8 Power Consumption* 1.9 Summary Look Ahead Exercises Interview QuestionsFrom Zero One 1.1THE GAME PLAN Microprocessors revolutionized world past three decades. laptop computer today far capability room-sized mainframe yesteryear. luxury automobile contains 50 microprocessors. Advances microprocessors made cell phones Internet possible, vastly improved medicine, transformed war waged. Worldwide semiconductor industry sales grown US $21 billion 1985 $227 billion 2005, microprocessors major segment sales. believe microprocessors technically, economi- cally, socially important, also intrinsically fascinating human invention. time finish reading book, know design build microprocessor. skills learn along way prepare design many digital systems. assume basic familiarity electricity, prior programming experience, genuine interest understanding goes hood computer. book focuses design digital systems, operate 1’s 0’s. begin digital logic gates accept 1’s 0’s inputs produce 1’s 0’s outputs. explore combine logic gates complicated modules adders memories. shift gears programming assembly language, native tongue micro- processor. Finally, put gates together build microprocessor runs assembly language programs. great advantage digital systems building blocks quite simple: 1’s 0’s. require grungy mathematics profound knowledge physics. Instead, designer’s challenge combine simple blocks complicated systems. microprocessor may first system build complex fit 3Chapter 01.qxd 1/27/07 10:20 Page 3head once. One major themes weaved book manage complexity. 1.2 ART MANAGING COMPLEXITY One characteristics separates engineer computer scientist layperson systematic approach managing complexity. Modern digital systems built millions billions transistors. human could understand systems writing equations describing movement electrons transistor solving equations simultaneously. need learn manage complex- ity understand build microprocessor without getting mired morass detail. 1.2.1 Abstraction critical technique managing complexity abstraction : hiding details important. system viewed many different levels abstraction. example, American politicians abstract world cities, counties, states, countries. county contains multiple cities state contains many counties. politician running president, politician mostly interested state whole vote, rather county votes, state useful level abstraction. hand, Census Bureau measures population every city, agency must consider details lower level abstraction. Figure 1.1 illustrates levels abstraction electronic computer system along typical building blocks level. lowest level abstraction physics, motion electrons. behavior electrons described quantum mechanics Maxwell’s equa- tions. system constructed electronic devices transis- tors (or vacuum tubes, upon time). devices well-defined connection points called terminals modeled relationship voltage current measured termi- nal. abstracting device level, ignore individual elec- trons. next level abstraction analog circuits , devices assembled create components amplifiers. Analog circuits input output continuous range voltages. Digital circuits logic gates restrict voltages discrete ranges, use indicate 0 1. logic design, build complex structures, adders memories, digital circuits. Microarchitecture links logic architecture levels abstraction. architecture level abstraction describes computer pro- grammer’s perspective. example, Intel IA-32 architecture used microprocessors personal computers (PCs) defined set of4 CHAPTER ONE Zero One PhysicsDevicesAnalog CircuitsDigital CircuitsLogicMicro- architectureArchitectureOperating SystemsApplication Software ElectronsTransistors DiodesAmplifiers FiltersAND gates gatesAdders MemoriesDatapaths ControllersInstructions RegistersDevice DriversPrograms Figure 1.1 Levels abstraction electronic computing systemChapter 01.qxd 1/27/07 10:20 Page 4instructions registers (memory temporarily storing variables) programmer allowed use. Microarchitecture involves combining logic elements execute instructions defined architecture. particular architecture implemented one many different microarchitectures different price/performance/power trade-offs. example, Intel Core 2 Duo, Intel 80486, AMD Athlon implement IA-32 architecture different microarchitectures. Moving software realm, operating system handles low- level details accessing hard drive managing memory. Finally, application software uses facilities provided operating sys- tem solve problem user. Thanks power abstraction, grandmother surf Web without regard quantum vibrations electrons organization memory computer. book focuses levels abstraction digital circuits computer architecture. working one level abstraction, good know something levels abstraction immediately working. example, computer scientist cannot fully optimize code without understanding architecture program written. device engineer cannot make wise trade-offs transistor design without understanding circuits transistors used. hope time finish reading book, pick level abstraction appropriate solving problem evaluate impact design choices levels abstraction. 1.2.2 Discipline Discipline act intentionally restricting design choices work productively higher level abstraction. Using interchangeable parts familiar application discipline. One first examples interchangeable parts flintlock rifle manu- facturing. early 19th century, rifles individually crafted hand. Components purchased many different craftsmen care- fully filed fit together highly skilled gunmaker. discipline interchangeable parts revolutionized industry. limiting compo- nents standardized set well-defined tolerances, rifles could assembled repaired much faster less skill. gunmaker longer concerned lower levels abstraction specific shape individual barrel gunstock. context book, digital discipline impor- tant. Digital circuits use discrete voltages, whereas analog circuits use con- tinuous voltages. Therefore, digital circuits subset analog circuits sense must capable less broader class analog circuits. However, digital circuits much simpler design. limiting1.2 Art Managing Complexity 5Chapter 01.qxd 1/27/07 10:20 Page 5ourselves digital circuits, easily combine components sophisticated systems ultimately outperform built analog components many applications. example, digital televisions, com- pact disks (CDs), cell phones replacing analog predecessors. 1.2.3 Three -Y’s addition abstraction discipline, designers use three “-y’s” manage complexity: hierarchy, modularity, regularity. princi- ples apply software hardware systems. /L50776Hierarchy involves dividing system modules, subdi- viding modules pieces easy understand. /L50776Modularity states modules well-defined functions interfaces, connect together easily without unanticipated side effects. /L50776Regularity seeks uniformity among modules. Common modules reused many times, reducing number distinct modules must designed. illustrate “-y’s” return example rifle manufac- turing. flintlock rifle one intricate objects common use early 19th century. Using principle hierarchy, break components shown Figure 1.2: lock, stock, barrel. barrel long metal tube bullet fired. lock firing mechanism. stock wooden body holds parts together provides secure grip user. turn, lock contains trigger, hammer, flint, frizzen, pan. components could hierarchically described detail. Modularity teaches component well-defined function interface. function stock mount barrel lock. interface consists length location mount- ing pins. modular rifle design, stocks many different manufac- turers used particular barrel long stock barrel correct length proper mounting mechanism. function barrel impart spin bullet travels accurately. Modularity dictates side effects: design stock impede function barrel. Regularity teaches interchangeable parts good idea. regularity, damaged barrel replaced identical part. barrels efficiently built assembly line, instead painstakingly hand-crafted. return principles hierarchy, modularity, regu- larity throughout book.6 CHAPTER ONE Zero One Captain Meriwether Lewis Lewis Clark Expedition one early advocates inter- changeable parts rifles. 1806, explained: guns Drewyer Sergt. Pryor order. first repared new lock, old one become unfit use; second cock screw broken replaced duplicate prepared lock Harpers Ferry manufac- tured. precaution taken bringing extra locks, parts locks, addition ingenuity John Shields, guns would moment entirely unfit use; fortunately us power record good order. See Elliott Coues, ed., History Lewis Clark Expedition ... (4 vols), New York: Harper, 1893; reprint, 3 vols, New York: Dover, 3:817.Chapter 01.qxd 1/27/07 10:20 Page 61.3 DIGITAL ABSTRACTION physical variables continuous. example, voltage wire, frequency oscillation, position mass continuous quantities. Digital systems, hand, represent information discrete-valued variables —that is, variables finite number distinct values. early digital system using variables ten discrete values Charles Babbage’s Analytical Engine. Babbage labored 1834 1871,1designing attempting build mechanical computer. Analytical Engine used gears ten positions labeled 0 9, much like mechanical odometer car. Figure 1.3 shows prototype1.3 Digital Abstraction 7 Barrel StocLock Expanded view Lockk Flint Cock PanSpringStringFigure 1.2 Flintlock rifle close-up view lock (Image Euroams Italia. www.euroarms.net © 2006). 1And thought graduate school long!Charles Babbage, 1791–1871. Attended Cambridge Univer- sity married Georgiana Whitmore 1814. Invented Analytical Engine, world’s first mechanical computer. Also invented cowcatcher universal postage rate. Interested lock-picking, abhorred street musicians (image courtesy Fourmilab Switzerland, www. fourmilab.ch). Chapter 01.qxd 1/27/07 10:20 Page 7of Analytical Engine, row processes one digit. Babbage chose 25 rows gears, machine 25-digit precision. Unlike Babbage’s machine, electronic computers use binary (two-valued) representation high voltage indicates ‘1’ low voltage indicates ‘0,’ easier distinguish two voltages ten. amount information discrete valued variable N distinct states measured units bitsas D/H11005log2N bits (1.1) binary variable conveys log 22/H110051 bit information. Indeed, word bit short binary dig it. Babbage’s gears carried log 210/H11005 3.322 bits information could one 23.322/H1100510 unique positions. continuous signal theoretically contains infinite amount information take infinite number values. prac- tice, noise measurement error limit information 10 16 bits continuous signals. measurement must made rapidly, information content lower (e.g., 8 bits). book focuses digital circuits using binary variables: 1’s 0’s. George Boole developed system logic operating binary vari- ables known Boolean logic . Boole’s variables could TRUE FALSE. Electronic computers commonly use posi- tive voltage represent ‘1’ zero volts represent ‘0’. book, use terms ‘1,’ TRUE, HIGH synonymously. Similarly, use ‘0,’ FALSE, LOW interchangeably. beauty digital abstraction digital designers focus 1’s 0’s, ignoring whether Boolean variables physi- cally represented specific voltages, rotating gears, even hydraulic8 CHAPTER ONE Zero One Figure 1.3 Babbage’s Analytical Engine, construction time death 1871 (image courtesy Science Museum/Science Society Picture Library). George Boole, 1815–1864. Born working-class parents unable afford formal edu- cation, Boole taught mathematics joined faculty Queen’s College Ireland. wrote Investigation Laws Thought (1854), intro- duced binary variables three fundamental logic opera- tions: AND, OR, (image courtesy xxx). Chapter 01.qxd 1/27/07 10:20 Page 8fluid levels. computer programmer work without needing know intimate details computer hardware. hand, understanding details hardware allows programmer optimize software better specific computer. individual bit doesn’t carry much information. next sec- tion, examine groups bits used represent numbers. later chapters, also use groups bits represent letters programs. 1.4 NUMBER SYSTEMS accustomed working decimal numbers. digital sys- tems consisting 1’s 0’s, binary hexadecimal numbers often convenient. section introduces various number systems used throughout rest book. 1.4.1 Decimal Numbers elementary school, learned count arithmetic decimal . (probably) ten fingers, ten decimal digits, 0, 1, 2, ..., 9. Decimal digits joined together form longer decimal num- bers. column decimal number ten times weight previous column. right left, column weights 1, 10, 100, 1000, on. Decimal numbers referred base 10 . base indicated subscript number prevent confusion working one base. example, Figure 1.4 shows decimal number 9742 10is written sum digits multi- plied weight corresponding column. N-digit decimal number represents one 10Npossibilities: 0, 1, 2, 3, ..., 10N/H110021. called range number. example, three-digit decimal number represents one 1000 possibilities range 0 999. 1.4.2 Binary Numbers Bits represent one two values, 0 1, joined together form binary numbers . column binary number twice weight1.4 Number Systems 9 9742 10= 9 × 103+ 7 × 102+ 4 × 101+ 2 × 100 nine thousands 10's column 100's column 1000's column seven hundredsfour tenstwo ones 1's column Figure 1.4 Representation decimal numberChapter 01.qxd 1/27/07 10:20 Page 9of previous column, binary numbers base 2 . binary, col- umn weights (again right left) 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, on. work binary numbers often, you’ll save time remember powers two 216. N-bit binary number represents one 2Npossibilities: 0, 1, 2, 3, ..., 2N/H110021. Table 1.1 shows 1, 2, 3, 4-bit binary numbers decimal equivalents. Example 1.1 BINARY DECIMAL CONVERSION Convert binary number 10110 2to decimal. Solution: Figure 1.5 shows conversion.10 CHAPTER ONE Zero One 1-Bit 2-Bit 3-Bit 4-Bit Binary Binnary Binary Binary Decimal Numbers Numbers Numbers Numbers Equivalents 0 00 000 0000 0 1 01 001 0001 1 10 010 0010 2 11 011 0011 3 100 0100 4 101 0101 5 110 0110 6 111 0111 7 1000 8 1001 9 1010 10 1011 11 1100 12 1101 13 1110 14 1111 15Table 1.1 Binary numbers decimal equivalentChapter 01.qxd 1/27/07 10:20 Page 10Example 1.2 DECIMAL BINARY CONVERSION Convert decimal number 84 10to binary. Solution: Determine whether column binary result 1 0. starting either left right column. Working left, start largest power 2 less number (in case, 64). 84 /H1135064, 1 64’s column, leaving 84 /H1100264/H1100520. 20/H1102132, 0 32’s column. 20 /H1135016, 1 16’s column, leaving 20 /H1100216/H110054. 4 /H110218, 0 8’s column. 4 /H113504, 1 4’s column, leaving 4 /H110024/H110050. Thus must 0’s 2’s 1’s column. Putting together, 84 10/H110051010100 2. Working right, repeatedly divide number 2. remainder goes column. 84/2 /H1100542, 0 goes 1’s column. 42/2 /H1100521, 0 goes 2’s column. 21/2 /H1100510 remainder 1 going 4’s column. 10/2 /H11005 5, 0 goes 8’s column. 5/2 /H110052 remainder 1 going 16’s column. 2/2 /H110051, 0 goes 32’s column. Finally 1/2 /H110050 remainder 1 going 64’s column. Again, 84 10/H110051010100 2 1.4.3 Hexadecimal Numbers Writing long binary numbers becomes tedious prone error. group four bits represents one 24/H1100516 possibilities. Hence, sometimes convenient work base 16 , called hexadecimal . Hexadecimal numbers use digits 0 9 along letters F, shown Table 1.2. Columns base 16 weights 1, 16, 162 (or 256), 163(or 4096), on. Example 1.3 HEXADECIMAL BINARY DECIMAL CONVERSION Convert hexadecimal number 2ED 16to binary decimal. Solution: Conversion hexadecimal binary easy hexa- decimal digit directly corresponds four binary digits. 2 16/H110050010 2, E16/H110051110 2 16/H110051101 2, 2ED 16/H11005001011101101 2. Conversion decimal requires arithmetic shown Figure 1.6.1.4 Number Systems 11 10110 2= 1 × 24+ 0 × 23+ 1 × 22+ 1 × 21+ 0 × 20 = 22 10 one sixteen 1's column eightone fourone twono one 2's column 4's column 8's column 16's column Figure 1.5 Conversion binary number decimal “Hexadecimal,” term coined IBM 1963, derives Greek hexi (six) Latin decem (ten). proper term would use Latin sexa (six), sex- idecimal sounded risqué.Chapter 01.qxd 1/27/07 10:20 Page 11Example 1.4 BINARY HEXADECIMAL CONVERSION Convert binary number 1111010 2to hexadecimal. Solution: Again, conversion easy. Start reading right. four least significant bits 1010 2/H11005A16. next bits 111 2/H11005716. Hence 1111010 2 /H110057A16.12 CHAPTER ONE Zero One Table 1.2 Hexadecimal number system Hexadecimal Digit Decimal Equivalent Binary Equivalent 0 0 0000 1 1 0001 2 2 0010 3 3 0011 4 4 0100 5 5 0101 6 6 0110 7 7 0111 8 8 1000 9 9 1001 10 1010 B 11 1011 C 12 1100 13 1101 E 14 1110 F 15 1111 2ED 16= 2 × 162+ E × 161+ × 160= 749 10 two two hundred fifty six's 1's column fourteen sixteensthirteen ones 16's column 256's column Figure 1.6 Conversion hexadecimal number decimalChapter 01.qxd 1/27/07 10:20 Page 12Example 1.5 DECIMAL HEXADECIMAL BINARY CONVERSION Convert decimal number 333 10to hexadecimal binary. Solution: Like decimal binary conversion, decimal hexadecimal conversion done left right. Working left, start largest power 16 less number (in case, 256). 256 goes 333 once, 1 256’s column, leaving 333 /H11002256 /H1100577. 16 goes 77 four times, 4 16’s column, leaving 77 /H1100216/H110034/H1100513. 13 10/H11005D16, 1’s column. sum- mary, 333 10/H1100514D 16. easy convert hexadecimal binary, Example 1.3. 14D 16/H11005101001101 2. Working right, repeatedly divide number 16. remainder goes column. 333/16 /H1100520 remainder 13 10/H11005D16going 1’s column. 20/16 /H110051 remainder 4 going 16’s column. 1/16 /H110050 remainder 1 going 256’s column. Again, result 14D 16. 1.4.4 Bytes, Nibbles, Jazz group eight bits called byte. represents one 28/H11005256 possi- bilities. size objects stored computer memories customarily measured bytes rather bits. group four bits, half byte, called nibble . represents one 24/H1100516 possibilities. One hexadecimal digit stores one nibble two hexadecimal digits store one full byte. Nibbles longer com- monly used unit, term cute. Microprocessors handle data chunks called words . size word depends architecture microprocessor. chapter written 2006, computers 32-bit processors, indicating operate 32-bit words. time, computers handling 64-bit words verge becoming widely available. Simpler microprocessors, especially used gadgets toast- ers, use 8- 16-bit words. Within group bits, bit 1’s column called least significant bit (lsb), bit end called significant bit (msb), shown Figure 1.7(a) 6-bit binary number. Similarly, within word, bytes identified least significant byte (LSB) significant byte (MSB ), shown Figure 1.7(b) four-byte number written eight hexadeci- mal digits.1.4 Number Systems 13 microprocessor proces- sor built single chip. 1970’s, processors complicated fit one chip, mainframe processors built boards containing many chips. Intel introduced first 4-bit microprocessor, called 4004, 1971. Now, even sophisticated supercom- puters built using micro- processors. use terms microprocessor processor interchangeably throughout book.Chapter 01.qxd 1/27/07 10:20 Page 13By handy coincidence, 210/H110051024 /H11015103. Hence, term kilo (Greek thousand) indicates 210. example, 210bytes one kilo- byte (1 KB). Similarly, mega (million) indicates 220/H11015106, giga (billion) indicates 230/H11015109. know 210/H110151 thousand, 220/H110151 million, 230/H110151 billion, remember powers two 29, easy estimate power two head. Example 1.6 ESTIMATING POWERS TWO Find approximate value 224without using calculator. Solution: Split exponent multiple ten remainder. 224/H11005220 /H1100324. 220/H110151 million. 24/H1100516. 224/H1101516 million. Technically, 224/H11005 16,777,216, 16 million close enough marketing purposes. 1024 bytes called kilobyte (KB). 1024 bits called kilobit (Kb Kbit). Similarly, MB, Mb, GB, Gb used millions bil- lions bytes bits. Memory capacity usually measured bytes. Communication speed usually measured bits/sec. example, maximum speed dial-up modem usually 56 Kbits/sec. 1.4.5 Binary Addition Binary addition much like decimal addition, easier, shown Figure 1.8. decimal addition, sum two numbers greater fits single digit, carry 1 next column. Figure 1.8 compares addition decimal binary numbers. right-most column Figure 1.8(a), 7 /H110019/H1100516, cannot fit single digit greater 9. record 1’s digit, 6, carry 10’s digit, 1, next column. Likewise, binary, sum two numbers greater 1, carry 2’s digit next col- umn. example, right-most column Figure 1.8(b), sum14 CHAPTER ONE Zero One 101100 least significant bitmost significant bit (a) (b)DEAFDAD8 least significant bytemost significant byte 1011 0011+ 111011 carries 4277 5499+ 977611 (a) (b)Figure 1.7 Least significant bits bytes Figure 1.8 Addition examples showing carries: (a) decimal (b) binaryChapter 01.qxd 1/27/07 10:20 Page 141/H110011/H11005210/H11005102cannot fit single binary digit. record 1’s digit (0) carry 2’s digit (1) result next column. second column, sum 1 /H110011/H110011/H11005310/H11005112. Again, record 1’s digit (1) carry 2’s digit (1) next column. obvi- ous reasons, bit carried neighboring column called carry bit . Example 1.7 BINARY ADDITION Compute 0111 2/H110010101 2. Solution: Figure 1.9 shows sum 1100 2. carries indicated blue. check work repeating computation decimal. 0111 2/H11005 710. 0101 2/H11005510. sum 12 10/H110051100 2. Digital systems usually operate fixed number digits. Addition said overflow result big fit available digits. 4-bit number, example, range [0, 15]. 4-bit binary addition overflows result exceeds 15. fifth bit discarded, producing incorrect result remaining four bits. Overflow detected checking carry significant column. Example 1.8 ADDITION OVERFLOW Compute 1101 2/H110010101 2. overflow occur? Solution: Figure 1.10 shows sum 10010 2. result overflows range 4-bit binary number. must stored four bits, significant bit discarded, leaving incorrect result 0010 2. computation done using numbers five bits, result 10010 2would correct. 1.4.6 Signed Binary Numbers far, considered unsigned binary numbers represent positive quantities. often want represent positive negative numbers, requiring different binary number system. Several schemes exist represent signed binary numbers; two widely employed called sign/magnitude two’s complement. Sign/Magnitude Numbers Sign/magnitude numbers intuitively appealing match custom writing negative numbers minus sign followed magnitude. N-bit sign/magnitude number uses significant bit1.4 Number Systems 15 0111 0101+ 1100111 1101 0101+ 1001011 1Figure 1.9 Binary addition example Figure 1.10 Binary addition example overflowChapter 01.qxd 1/27/07 10:20 Page 15as sign remaining N/H110021 bits magnitude (absolute value). sign bit 0 indicates positive sign bit 1 indicates negative. Example 1.9 SIGN/MAGNITUDE NUMBERS Write 5 /H110025 4-bit sign/magnitude numbers Solution: numbers magnitude 5 10/H11005101 2. Thus, 5 10/H110050101 2and /H11002510/H110051101 2. Unfortunately, ordinary binary addition work sign/mag- nitude numbers. example, using ordinary addition /H11002510/H11001510 gives 1101 2/H110010101 2/H1100510010 2, nonsense. N-bit sign/magnitude number spans range [ /H110022N/H110021/H110011, 2N/H110021 /H110021]. Sign/magnitude numbers slightly odd /H110010 /H110020 exist. indicate zero. may expect, troublesome two different representations number. Two’s Complement Numbers Two’s complement numbers identical unsigned binary numbers except significant bit position weight /H110022N/H110021 instead 2N/H110021. overcome shortcomings sign/magnitude numbers: zero single representation, ordinary addition works. two’s complement representation, zero written zeros: 00...000 2. positive number 0 significant posi- tion 1’s elsewhere: 01...111 2/H110052N/H110021/H110021. negative number 1 significant position 0’s elsewhere: 10...000 2/H11005 /H110022N/H110021. /H110021 written ones: 11...111 2. Notice positive numbers 0 significant posi- tion negative numbers 1 position, signifi- cant bit viewed sign bit. However, remaining bits interpreted differently two’s complement numbers sign/ magnitude numbers. sign two’s complement number reversed process called taking two’s complement . process consists inverting bits number, adding 1 least significant bit position. useful find representation negative number determine magnitude negative number. Example 1.10 TWO’S COMPLEMENT REPRESENTATION NEGATIVE NUMBER Find representation /H11002210as 4-bit two’s complement number.16 CHAPTER ONE Zero One $7 billion Ariane 5 rocket, launched June 4, 1996, veered course 40 seconds launch, broke up, exploded. failure caused com- puter controlling rocket overflowed 16-bit range crashed. code exten- sively tested Ariane 4 rocket. However, Ariane 5 faster engine pro- duced larger values control computer, leading overflow. (Photograph courtesy ESA/CNES/ ARIANESPACE- Service Optique CS6.)Chapter 01.qxd 1/27/07 10:20 Page 16Solution: Start /H11001210/H110050010 2. get /H11002210, invert bits add 1. Inverting 0010 2produces 1101 2. 1101 2/H110011/H110051110 2. /H11002210is 1110 2. Example 1.11 VALUE NEGATIVE TWO’S COMPLEMENT NUMBERS Find decimal value two’s complement number 1001 2. Solution: 1001 2has leading 1, must negative. find magnitude, invert bits add 1. Inverting 1001 2/H110050110 2. 0110 2/H110011/H110050111 2/H11005710. Hence, 1001 2/H11005/H11002710. Two’s complement numbers compelling advantage addition works properly positive negative numbers. Recall adding N-bit numbers, carry Nth bit (i.e., N/H110011thresult bit), discarded. Example 1.12 ADDING TWO’S COMPLEMENT NUMBERS Compute (a) /H11002210/H11001110and (b) /H11002710/H11001710using two’s complement numbers. Solution: (a) /H11002210/H11001110/H110051110 2/H110010001 2/H110051111 2/H11005/H11002110. (b) /H11002710/H11001710 /H110051001 2/H110010111 2/H1100510000 2. fifth bit discarded, leaving correct 4-bit result 0000 2. Subtraction performed taking two’s complement sec- ond number, adding. Example 1.13 SUBTRACTING TWO’S COMPLEMENT NUMBERS Compute (a) 5 10/H11002310and (b) 3 10/H11002510using 4-bit two’s complement numbers. Solution: (a) 3 10/H110050011 2. Take two’s complement obtain /H11002310/H110051101 2. add 5 10/H11001(/H11002310)/H110050101 2/H110011101 2/H110050010 2/H11005210. Note carry significant position discarded result stored four bits. (b) Take two’s complement 5 10to obtain /H11002510/H110051011. add 3 10/H11001(/H11002510)/H110050011 2/H110011011 2/H110051110 2/H11005/H11002210. two’s complement 0 found inverting bits (pro- ducing 11...111 2) adding 1, produces 0’s, disregarding carry significant bit position. Hence, zero always represented 0’s. Unlike sign/magnitude system, two’s complement system separate /H110020. Zero considered positive sign bit 0.1.4 Number Systems 17Chapter 01.qxd 1/27/07 10:20 Page 17Like unsigned numbers, N-bit two’s complement numbers repre- sent one 2Npossible values. However values split positive negative numbers. example, 4-bit unsigned number represents 16 values: 0 15. 4-bit two’s complement number also represents 16 values: /H110028 7. general, range N-bit two’s complement number spans [ /H110022N/H110021, 2N/H110021/H110021]. make sense one negative number positive number /H110020. negative number 10...000 2/H11005/H110022N/H110021is sometimes called weird number . two’s complement found inverting bits (producing 01...111 2and adding 1, produces 10...000 2, weird number, again). Hence, negative number positive counterpart. Adding two N-bit positive numbers negative numbers may cause overflow result greater 2N/H110021/H110021 less /H110022N/H110021. Adding positive number negative number never causes overflow. Unlike unsigned numbers, carry significant column indicate overflow. Instead, overflow occurs two numbers added sign bit result opposite sign bit. Example 1.14 ADDING TWO’S COMPLEMENT NUMBERS OVERFLOW Compute (a) 4 10/H11001510using 4-bit two’s complement numbers. result overflow? Solution: (a) 4 10/H11001510/H110050100 2/H110010101 2/H110051001 2/H11005/H11002710. result overflows range 4-bit positive two’s complement numbers, producing incorrect negative result. computation done using five bits, result 01001 2/H11005910would correct. two’s complement number extended bits, sign bit must copied significant bit positions. process called sign extension . example, numbers 3 /H110023 written 4-bit two’s complement numbers 0011 1101, respectively. sign-extended seven bits copying sign bit three new upper bits form 0000011 1111101, respectively. Comparison Number Systems three commonly used binary number systems unsigned, two’s complement, sign/magnitude. Table 1.3 compares range N-bit numbers three systems. Two’s complement num- bers convenient represent positive negative integers ordinary addition works numbers.18 CHAPTER ONE Zero OneChapter 01.qxd 1/27/07 10:20 Page 18Subtraction performed negating second number (i.e., taking two’s complement), adding. Unless stated otherwise, assume signed binary numbers use two’s complement representation. Figure 1.11 shows number line indicating values 4-bit num- bers system. Unsigned numbers span range [0, 15] regular binary order. Two’s complement numbers span range [ /H110028, 7]. nonnegative numbers [0, 7] share encodings unsigned num- bers. negative numbers [ /H110028, /H110021] encoded larger unsigned binary value represents number closer 0. Notice weird number, 1000, represents /H110028 positive counterpart. Sign/magnitude numbers span range [ /H110027, 7]. significant bit sign bit. positive numbers [1, 7] share encodings unsigned numbers. negative numbers symmetric sign bit set. 0 represented 0000 1000. Thus, N-bit sign/magnitude numbers represent 2N/H110021 integers two representations 0. 1.5 LOGIC GATES know use binary variables represent informa- tion, explore digital systems perform operations binary variables. Logic gates simple digital circuits take one binary inputs produce binary output. Logic gates drawn symbol showing input (or inputs) output. Inputs are1.5 Logic Gates 19 –8 1000 1001–7 –6 –5 –4 –3 –2 –1 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1010 1011 1100 1101 1110 1111 0000 0001 0010 0011 0100 0101 0110 0111 Two's Complement 10001001 1010 1011 1100 1101 1110 111100000001 0010 0011 0100 0101 0110 01111000 1001 1010 1011 1100 1101 1110 1111 0000 0001 0010 0011 0100 0101 0110 0111 Sign / MagnitudeUnsignedTable 1.3 Range N-bit numbers System Range Unsigned [0, 2N/H110021] Sign/Magnitude [ /H110022N/H110021/H110011, 2N/H110021/H110021] Two’s Complement [ /H110022N/H110021, 2N/H110021/H110021] Figure 1.11 Number line 4-bit binary encodingsChapter 01.qxd 1/27/07 10:20 Page 19usually drawn left (or top) outputs right (or bottom). Digital designers typically use letters near beginning alphabet gate inputs letter Yfor gate output. relationship inputs output described truth table Boolean equation. truth table lists inputs left corre- sponding output right. one row possible combina- tion inputs. Boolean equation mathematical expression using binary variables. 1.5.1 Gate gate one input, A, one output, Y, shown Figure 1.12. gate’s output inverse input. Ais FALSE, Yis TRUE. Ais TRUE, Yis FALSE. relationship summarized truth table Boolean equation figure. line Boolean equation pronounced , Y/H11005A_ read “ Yequals A.” gate also called inverter . texts use variety notations NOT, including Y/H11005A/H11032, Y/H11005 A, Y/H11005!Aor Y/H11005~A. use Y/H11005A_ exclusively, don’t puz- zled encounter another notation elsewhere. 1.5.2 Buffer one-input logic gate called buffer shown Figure 1.13. simply copies input output. logical point view, buffer different wire, might seem useless. However, analog point view, buffer might desirable characteristics ability deliver large amounts current motor ability quickly send output many gates. example need consider multiple levels abstraction fully understand system; digital abstraction hides real purpose buffer. triangle symbol indicates buffer. circle output called bubble indicates inversion, seen gate symbol Figure 1.12. 1.5.3 Gate Two-input logic gates interesting. gate shown Figure 1.14 produces TRUE output, Y, B TRUE. Otherwise, output FALSE. convention, inputs listed order 00, 01, 10, 11, counting binary. Boolean equa- tion gate written several ways: Y/H11005A•B, Y/H11005AB, Y/H11005A/H20669B. /H20669symbol pronounced “intersection” preferred logicians. prefer Y/H11005AB, read “ Yequals Aand B,” lazy.20 CHAPTER ONE Zero One = AY 01 10A BUF = AY 00 11AY = AB ABY 000 010 100 111A BYFigure 1.12 gate Figure 1.14 gateFigure 1.13 Buffer According Larry Wall, inventor Perl program- ming language, “the three principal virtues pro- grammer Laziness, Impatience, Hubris.”Chapter 01.qxd 1/27/07 10:20 Page 201.5.4 Gate gate shown Figure 1.15 produces TRUE output, Y,if either Aor B(or both) TRUE. Boolean equation gate written Y/H11005A/H11001Bor Y/H11005A/H20668B. /H20668symbol pronounced union preferred logicians. Digital designers normally use /H11001 notation, Y/H11005A/H11001Bis pronounced “ Yequals Aor B”. 1.5.5 Two-Input Gates Figure 1.16 shows common two-input logic gates. XOR (exclusive OR, pronounced “ex-OR”) TRUE Aor B, both, TRUE. gate followed bubble invert operation. NAND gate performs AND. output TRUE unless inputs TRUE. gate performs OR. output TRUE neither Anor Bis TRUE. Example 1.15 XNOR GATE Figure 1.17 shows symbol Boolean equation two-input XNOR gatethat performs inverse XOR. Complete truth table. Solution: Figure 1.18 shows truth table. XNOR output TRUE inputs FALSE inputs TRUE. two-input XNOR gate some- times called equality gate output TRUE inputs equal. 1.5.6 Multiple-Input Gates Many Boolean functions three inputs exist. common AND, OR, XOR, NAND, NOR, XNOR. N-input gate produces TRUE output Ninputs TRUE. N-input gate produces TRUE output least one input TRUE.1.5 Logic Gates 21 = + B ABY 000 011 101 111A Figure 1.15 gate XOR NAND = + = AB = + B ABY 000 011 101 110ABY 001 011 101 110ABY 001 010 100 110A BYA BYA Figure 1.16 two-input logic gatesA silly way remember symbol it’s input side curved like Pacman’s mouth, gate hungry willing eat TRUE inputs find! Figure 1.17 XNOR gateXNOR = + B ABY 00 01 10 11A BYChapter 01.qxd 1/27/07 10:20 Page 21AnN-input XOR gate sometimes called parity gate produces TRUE output odd number inputs TRUE. two-input gates, input combinations truth table listed counting order. Example 1.16 THREE-INPUT GATE Figure 1.19 shows symbol Boolean equation three-input gate. Complete truth table. Solution: Figure 1.20 shows truth table. output TRUE none inputs TRUE. Example 1.17 FOUR-INPUT GATE Figure 1.21 shows symbol Boolean equation four-input gate. Create truth table. Solution: Figure 1.22 shows truth table. output TRUE inputs TRUE. 1.6 BENEATH DIGITAL ABSTRACTION digital system uses discrete-valued variables. However, variables represented continuous physical quantities voltage wire, position gear, level fluid cylinder. Hence, designer must choose way relate continuous value discrete value. example, consider representing binary signal Awith voltage wire. Let 0 volts (V) indicate A/H110050 5 V indicate A/H110051. real sys- tem must tolerate noise, 4.97 V probably ought interpreted A/H110051 well. 4.3 V? 2.8 V? 2.500000 V? 1.6.1 Supply Voltage Suppose lowest voltage system 0 V, also called ground GND. highest voltage system comes power supply usually called VDD. 1970’s 1980’s technology, VDDwas generally 5 V. chips progressed smaller transistors, VDDhas dropped 3.3 V, 2.5 V, 1.8 V, 1.5 V, 1.2 V, even lower save power avoid overloading transistors. 1.6.2 Logic Levels mapping continuous variable onto discrete binary variable done defining logic levels , shown Figure 1.23. first gate called driver second gate called receiver . output of22 CHAPTER ONE Zero One Figure 1.19 Three-input gate Figure 1.20 Three-input truth table Figure 1.21 Four-input gateNOR3 = + B + C BCY 00 01 10 11A C 0 0 0 0 00 01 10 111 1 1 1 BCY 001 010 100 110A 0 0 0 0 000 010 100 1101 1 1 1 AND4 = ABCD BYC DFigure 1.18 XNOR truth tableABY 00 01 10 111 0 0 1Chapter 01.qxd 1/27/07 10:20 Page 22the driver connected input receiver. driver produces LOW (0) output range 0 VOLor HIGH (1) output range VOHto VDD. receiver gets input range 0 VIL, consider input LOW. receiver gets input range VIHto VDD, consider input HIGH. If, reason noise faulty components, receiver’s input fall forbidden zone VILand VIH, behavior gate unpredictable. VOH, VOL, VIH, VILare called output input high low logic levels. 1.6.3 Noise Margins output driver correctly interpreted input receiver, must choose VOL/H11021VILand VOH/H11022VIH. Thus, even output driver contaminated noise, input receiver still detect correct logic level. noise margin amount noise could added worst-case output signal still interpreted valid input. seen Figure 1.23, low high noise margins are, respectively NM L/H11005VIL/H11002VOL (1.2) NM H/H11005VOH/H11002VIH (1.3) Example 1.18 Consider inverter circuit Figure 1.24. VO1is output voltage inverter I1, VI2is input voltage inverter I2. inverters following characteristics: VDD/H110055V , VIL/H110051.35 V, VIH/H110053.15 V, VOL/H110050.33 V, VOH/H110053.84 V. inverter low high noise margins? cir- cuit tolerate 1 V noise VO1and VI2? Solution: inverter noise margins are: NM L/H11005VIL/H11002VOL/H11005(1.35 V /H110020.33 V) /H110051.02 V, NM H/H11005VOH/H11002VIH/H11005(3.84 V /H110023.15 V) /H110050.69 V. circuit tol- erate 1 V noise output LOW ( NM L/H110051.02 V) output HIGH ( NM H/H110050.69 V). example, suppose driver, I1, outputs worst-case HIGH value, VO1/H11005VOH/H110053.84 V. noise causes voltage droop 1 V reaching input receiver, VI2/H11005(3.84 V /H110021V ) /H11005 2.84 V. less acceptable input HIGH value, VIH/H110053.15 V, receiver may sense proper HIGH input. 1.6.4 DC Transfer Characteristics understand limits digital abstraction, must delve analog behavior gate. DC transfer characteristics gate describe output voltage function input voltage the1.6 Beneath Digital Abstraction 23 Figure 1.22 Four-input truth tableBDY 000 010 100 110C 0 0 0 0 000 010 100 1101 1 1 1A 000 010 100 1100 0 0 0 000 010 100 1111 1 1 10 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 VDDstands voltage drain metal-oxide- semiconductor transistor, used build modern chips. power supply voltage also sometimes called VCC, standing voltage collector bipolar tran- sistor used build chips older technology. Ground sometimes called VSS voltage source metal-oxide- semiconductor transistor. See Section 1.7 informa- tion transistors.Chapter 01.qxd 1/27/07 10:20 Page 23input changed slowly enough output keep up. called transfer characteristics describe relationship input output voltages. ideal inverter would abrupt switching threshold VDD/2, shown Figure 1.25(a). V(A)/H11021VDD/2, V(Y)/H11005VDD. V(A)/H11022VDD/2, V(Y)/H110050. case, V IH/H11005VIL/H11005VDD/2. V OH/H11005 VDDand V OL/H110050. real inverter changes gradually extremes, shown Figure 1.25(b). input voltage V(A) 0, output voltage V(Y)/H11005VDD. V(A)/H11005VDD, V(Y)/H110050. However, tran- sition endpoints smooth may centered exactly VDD/2. raises question define logic levels. reasonable place choose logic levels slope transfer characteristic V(Y)/dV(A) /H110021. two points called unity gain points . Choosing logic levels unity gain points usually maximizes noise margins. VILwere reduced, VOH would increase small amount. VILwere increased, VOH would drop precipitously. 1.6.5 Static Discipline avoid inputs falling forbidden zone, digital logic gates designed conform static discipline . static discipline requires that, given logically valid inputs, every circuit element produce logi- cally valid outputs. conforming static discipline, digital designers sacrifice freedom using arbitrary analog circuit elements return the24 CHAPTER ONE Zero One I1 I2Noise VO1 VI2Figure 1.24 Inverter circuit DCindicates behavior input voltage held con- stant changes slowly enough rest sys- tem keep up. term’s historical root comes direct current , method transmitting power across line constant voltage. contrast, transient response circuit behavior input volt- age changes rapidly. Section 2.9 explores transient response further.Forbidden Zone NM LNM HInput Characteristics Output Characteristics VOHVDD VOL GNDVIH VILLogic High Input Range Logic Low Input RangeLogic High Output Range Logic Low Output RangeDriver Receiver Figure 1.23 Logic levels noise marginsChapter 01.qxd 1/27/07 10:20 Page 24simplicity robustness digital circuits. raise level abstraction analog digital, increasing design productivity hiding needless detail. choice VDDand logic levels arbitrary, gates communicate must compatible logic levels. Therefore, gates grouped logic families gates logic family obey static discipline used gates family. Logic gates logic family snap together like Legos use consistent power supply voltages logic levels. Four major logic families predominated 1970’s 1990’s Transistor-Transistor Logic (TTL), Complementary Metal- Oxide-Semiconductor Logic (CMOS , pronounced sea-moss ), Low Voltage TTL Logic (LVTTL ), Low Voltage CMOS Logic (LVCMOS ). logic levels compared Table 1.4. Since then, logic families balkanized proliferation even lower power supply voltages. Appendix A.6 revisits popular logic families detail.1.6 Beneath Digital Abstraction 25 VDDV(A)V(Y) VOHVDD VOL VIL,VIH0AY VDDV(A)V(Y) VOHVDD VOL VILVIHUnity Gain Points Slope = –1 0 (a) (b)VDD/ 2 Figure 1.25 DC transfer characteristics logic levels Table 1.4 Logic levels 5 V 3.3 V logic families Logic Family VDD VIL VIH VOL VOH TTL 5 (4.75–5.25) 0.8 2.0 0.4 2.4 CMOS 5 (4.5–6) 1.35 3.15 0.33 3.84 LVTTL 3.3 (3–3.6) 0.8 2.0 0.4 2.4 LVCMOS 3.3 (3–3.6) 0.9 1.8 0.36 2.7Chapter 01.qxd 1/27/07 10:20 Page 25Example 1.19 LOGIC FAMILY COMPATIBILITY logic families Table 1.4 communicate reliably? Solution: Table 1.5 lists logic families compatible logic levels. Note 5 V logic family TTL CMOS may produce output voltage HIGH 5 V. 5 V signal drives input 3.3 V logic family LVTTL LVCMOS, damage receiver, unless receiver specially designed “5-volt compatible.” 1.7 CMOS TRANSISTORS* section sections marked * optional necessary understand main flow book. Babbage’s Analytical Engine built gears, early electri- cal computers used relays vacuum tubes. Modern computers use tran- sistors cheap, small, reliable. Transistors electrically controlled switches turn voltage current applied control terminal. two main types transis- tors bipolar transistors metal-oxide-semiconductor field effect transistors (MOSFETs MOS transistors, pronounced “moss-fets” “M-O-S”, respectively). 1958, Jack Kilby Texas Instruments built first integrated circuit containing two transistors. 1959, Robert Noyce Fairchild Semiconductor patented method interconnecting multiple transistors single silicon chip. time, transistors cost $10 each. Thanks three decades unprecedented manufacturing advances, engineers pack roughly one billion MOSFETs onto 1c m2chip silicon, transistors cost less 10 microcents apiece. capacity cost continue improve order magni- tude every 8 years so. MOSFETs building blocks of26 CHAPTER ONE Zero One Table 1.5 Compatibility logic families Receiver TTL CMOS LVTTL LVCMOS Driver TTL OK NO: VOH/H11021VIH MAYBEaMAYBEa CMOS OK OK MAYBEaMAYBEa LVTTL OK NO: VOH/H11021VIH OK OK LVCMOS OK NO: VOH/H11021VIH OK OK aAs long 5 V HIGH level damage receiver input Robert Noyce, 1927–1990. Born Burlington, Iowa. Received B.A. physics Grinnell College Ph.D. physics MIT. Nick- named “Mayor Silicon Valley” profound influence industry. Cofounded Fairchild Semiconductor 1957 Intel 1968. Coinvented integrated circuit. Many engi- neers teams went found seminal semi- conductor companies (© 2006, Intel Corporation. Reproduced permission). Chapter 01.qxd 1/27/07 10:20 Page 26almost digital systems. section, peer beneath digital abstraction see logic gates built MOSFETs. 1.7.1 Semiconductors MOS transistors built silicon, predominant atom rock sand. Silicon (Si) group IV atom, four electrons valence shell forms bonds four adjacent atoms, resulting crystalline lattice . Figure 1.26(a) shows lattice two dimensions ease drawing, remember lattice actually forms cubic crystal. figure, line represents covalent bond. itself, silicon poor conductor electrons tied covalent bonds. However, becomes better conductor small amounts impuri- ties, called dopant atoms, carefully added. group V dopant arsenic (As) added, dopant atoms extra electron involved bonds. electron easily move lattice, leaving ionized dopant atom (As/H11001) behind, shown Figure 1.26(b). electron carries negative charge, call arsenic n-type dopant. hand, group III dopant boron (B) added, dopant atoms missing electron, shown Figure 1.26(c). missing electron called hole. electron neighboring silicon atom may move fill missing bond, form- ing ionized dopant atom (B/H11002) leaving hole neighboring silicon atom. similar fashion, hole migrate around lattice. hole lack negative charge, acts like positively charged particle. Hence, call boron p-type dopant. conductivity silicon changes many orders magnitude depending concentration dopants, silicon called semiconductor . 1.7.2 Diodes junction p-type n-type silicon called diode . p-type region called anode n-type region called cath- ode, illustrated Figure 1.27. voltage anode rises voltage cathode, diode forward biased, and1.7 CMOS Transistors 27 Si Si SiSi Si Si Si Si Si (a)As Si SiSi Si Si Si Si Si (b)- +Free electron B Si SiSi Si Si Si Si Si (c)+ -Free hole Figure 1.26 Silicon lattice dopant atomsChapter 01.qxd 1/27/07 10:20 Page 27current flows diode anode cathode. anode voltage lower voltage cathode, diode reverse biased, current flows. diode symbol intu- itively shows current flows one direction. 1.7.3 Capacitors capacitor consists two conductors separated insulator. voltage Vis applied one conductors, conductor accumu- lates electric charge Q conductor accumulates opposite charge /H11002Q. capacitance C capacitor ratio charge voltage: C/H11005Q/V. capacitance proportional size con- ductors inversely proportional distance them. sym- bol capacitor shown Figure 1.28. Capacitance important charging discharging conduc- tor takes time energy. capacitance means circuit slower require energy operate. Speed energy dis- cussed throughout book. 1.7.4 nMOS pMOS Transistors MOSFET sandwich several layers conducting insulating materials. MOSFETs built thin flat wafers silicon 15 30 cm diameter. manufacturing process begins bare wafer. process involves sequence steps dopants implanted silicon, thin films silicon dioxide silicon grown, metal deposited. step, wafer patterned materials appear desired. transis- tors fraction micron2in length entire wafer processed once, inexpensive manufacture billions transistors time. processing complete, wafer cut rectangles called chips dicethat contain thousands, millions, even billions transistors. chip tested, placed plastic ceramic pack- agewith metal pins connect circuit board. MOSFET sandwich consists conducting layer called gate top insulating layer silicon dioxide (SiO 2) top silicon wafer, called substrate . Historically, gate constructed metal, hence name metal-oxide-semiconductor. Modern manu- facturing processes use polycrystalline silicon gate, melt subsequent high-temperature processing steps. Silicon dioxide better known glass often simply called oxide semiconductor industry .The metal-oxide-semiconductor sand- wich forms capacitor, thin layer insulating oxide called dielectric separates metal semiconductor plates.28 CHAPTER ONE Zero One p-type n-type anode cathode Figure 1.27 p-n junction diode structure symbol C Figure 1.28 Capacitor symbol Technicians Intel clean room wear Gore-Tex bunny suits prevent particulates hair, skin, clothing contaminating microscopic transistors silicon wafers (© 2006, Intel Corporation. Reproduced permission). 40-pin dual-inline package (DIP) contains small chip (scarcely visible) center connected 40 metal pins, 20 side, gold wires thinner strand hair (photograph Kevin Mapp. © Harvey Mudd College). 21/H9262m/H110051 micron /H1100510/H110026m.Chapter 01.qxd 1/27/07 10:20 Page 28There two flavors MOSFETs: nMOS pMOS (pronounced “n-moss” “p-moss”). Figure 1.29 shows cross-sections type, made sawing wafer looking side. n-type transistors, called nMOS , regions n-type dopants adjacent gate called source drain built p-type semiconductor substrate. pMOS transistors opposite, consisting p-type source drain regions n-type substrate . MOSFET behaves voltage-controlled switch gate voltage creates electric field turns connection source drain. term field effect transistor comes principle operation. Let us start exploring operation nMOS transistor. substrate nMOS transistor normally tied GND, lowest voltage system. First, consider situation gate also 0 V, shown Figure 1.30(a). diodes source drain substrate reverse biased source drain voltage nonnegative. Hence, path current flow source drain, transistor OFF. Now, consider gate raised VDD, shown Figure 1.30(b). positive voltage applied top plate capacitor, establishes electric field attracts positive charge top plate negative charge bottom plate. voltage sufficiently large, much negative charge attracted underside gate region inverts p-type effectively become n-type. inverted region called channel . transistor continuous path n-type source n-type channel n-type drain, electrons flow source drain. transistor ON. gate voltage required turn transis- tor called threshold voltage , Vt, typically 0.3 0.7 V.1.7 CMOS Transistors 29 n pgate source drain substrateSiO2 ngate source drain Polysilicon np p gate source draingate source drainsubstrate (a) nMOS (b) pMOS Figure 1.29 nMOS pMOS transistorsThe source drain termi- nals physically symmetric. However, say charge flows source drain. nMOS transistor, charge carried elec- trons, flow nega- tive voltage positive voltage. pMOS transistor, charge carried holes, flow positive volt- age negative voltage. draw schematics positive voltage top negative bottom, source (negative) charges nMOS transistor bottom terminal source (positive) charges pMOS transistor top terminal. technician holds 12-inch wafer containing hundreds microprocessor chips (© 2006, Intel Corporation. Reproduced permission).Chapter 01.qxd 1/27/07 10:20 Page 29pMOS transistors work opposite fashion, might guessed bubble symbol. substrate tied VDD. gate also VDD, pMOS transistor OFF. gate GND, channel inverts p-type pMOS transistor ON. Unfortunately, MOSFETs perfect switches. particular, nMOS transistors pass 0’s well pass 1’s poorly. Specifically, gate nMOS transistor VDD, drain swing 0 VDD/H11002Vt. Similarly, pMOS transistors pass 1’s well 0’s poorly. However, see possible build logic gates use transistors good mode. nMOS transistors need p-type substrate, pMOS transistors need n-type substrate. build flavors transistors chip, manufacturing processes typically start p-type wafer, implant n-type regions called wells pMOS transistors go. processes provide flavors transistors called Complementary MOS CMOS . CMOS processes used build vast majority transistors fabricated today. summary, CMOS processes give us two types electrically controlled switches, shown Figure 1.31. voltage gate (g) regulates flow current source (s) drain (d). nMOS transistors gate 0 gate 1.30 CHAPTER ONE Zero One n pgatesource drain substraten (a)GNDGND n pgate source drain substraten (b)VDD GND------- channel+++++++ Figure 1.30 nMOS transistor operation Figure 1.31 Switch models MOSFETsg sd g dsnMOS pMOSg = 0 sd dsOFF ONg= 1 sd dsON OFFGordon Moore, 1929– . Born San Francisco. Received B.S. chemistry UC Berkeley Ph.D. chem- istry physics Caltech. Cofounded Intel 1968 Robert Noyce. Observed 1965 number transistors computer chip doubles every year. trend become known Moore’s Law . Since 1975, transistor counts doubled every two years. corollary Moore’s Law microprocessor performance doubles every 18 24 months. Semicon- ductor sales also increased exponentially. Unfortunately, power con- sumption increased exponentially well (© 2006, Intel Corporation. Reproduced permission). Chapter 01.qxd 1/27/07 10:20 Page 30pMOS transistors opposite: gate 0 gate 1. 1.7.5 CMOS Gate Figure 1.32 shows schematic gate built CMOS transis- tors. triangle indicates GND, flat bar indicates VDD; labels omitted future schematics. nMOS transistor, N1, connected GND Youtput. pMOS transistor, P1, connected VDDand Youtput. transistor gates controlled input, A. A/H110050, N1is P1is ON. Hence, Yis connected VDD GND, pulled logic 1. P1passes good 1. A/H110051, N1is P1is OFF, Yis pulled logic 0. N1 passes good 0. Checking truth table Figure 1.12, see circuit indeed gate. 1.7.6 CMOS Logic Gates Figure 1.33 shows schematic two-input NAND gate. schematic diagrams, wires always joined three-way junctions. joined four-way junctions dot shown. nMOS transis- tors N1and N2are connected series; nMOS transistors must pull output GND. pMOS transistors P1and P2 parallel; one pMOS transistor must pull output VDD. Table 1.6 lists operation pull-down pull-up networks state output, demonstrating gate function NAND. example, A/H110051 B/H110050, N1is ON, N2is OFF, blocking path Yto GND. P1is OFF, P2is ON, creating path VDDto Y. Therefore, Yis pulled 1. Figure 1.34 shows general form used construct inverting logic gate, NOT, NAND, NOR. nMOS transistors good passing 0’s, pull-down network nMOS transistors placed output GND pull output 0. pMOS transistors are1.7 CMOS Transistors 31 Figure 1.32 gate schematic Figure 1.33 Two-input NAND gate schematicVDD GNDN1P1 N2N1P2 P1 Table 1.6 NAND gate operation AB Pull-Down Network Pull-Up Network 0 0 1 0 1 1 1 0 1 1 1 0pMOS pull-up network outputinputs nMOS pull-down network Figure 1.34 General form inverting logic gateChapter 01.qxd 1/27/07 10:20 Page 31good passing 1’s, pull-up network pMOS transistors placed output VDDto pull output 1. networks may consist transistors series parallel. transistors paral- lel, network either transistor ON. transistors series, network transistors ON. slash across input wire indicates gate may receive multiple inputs. pull-up pull-down networks simultane- ously, short circuit would exist VDDand GND. output gate might forbidden zone transistors would con- sume large amounts power, possibly enough burn out. hand, pull-up pull-down networks simultane- ously, output would connected neither VDDnor GND. say output floats . value undefined. Floating outputs usually undesirable, Section 2.6 see occa- sionally used designer’s advantage. properly functioning logic gate, one networks given time, output pulled HIGH LOW shorted floating. guarantee using rule conduction complements . nMOS transistors series, pMOS transistors must parallel. nMOS transis- tors parallel, pMOS transistors must series. Example 1.20 THREE-INPUT NAND SCHEMATIC Draw schematic three-input NAND gate using CMOS transistors. Solution: NAND gate produce 0 output three inputs 1. Hence, pull-down network three nMOS transistors series. conduction complements rule, pMOS transistors must parallel. gate shown Figure 1.35; verify function checking correct truth table. Example 1.21 TWO-INPUT SCHEMATIC Draw schematic two-input gate using CMOS transistors. Solution: gate produce 0 output either input 1. Hence, pull-down network two nMOS transistors parallel. conduction complements rule, pMOS transistors must series. gate shown Figure 1.36. Example 1.22 TWO-INPUT SCHEMATIC Draw schematic two-input gate.32 CHAPTER ONE Zero One C B YFigure 1.35 Three-input NAND gate schematic Figure 1.36 Two-input gate schematicExperienced designers claim electronic devices operate contain magic smoke . confirm the- ory observation magic smoke ever let device, ceases work. Chapter 01.qxd 1/27/07 10:20 Page 32Solution: impossible build gate single CMOS gate. However, building NAND gates easy. Thus, best way build gate using CMOS transistors use NAND followed NOT, shown Figure 1.37. 1.7.7 Transmission Gates times, designers find convenient use ideal switch pass 0 1 well. Recall nMOS transistors good passing 0 pMOS transistors good passing 1, parallel combination two passes values well. Figure 1.38 shows circuit, called transmission gate pass gate. two sides switch called Aand Bbecause switch bidirectional preferred input output side. control signals called enable s, ENand EN__ _ . EN/H110050 EN__ _ /H110051, transistors OFF. Hence, trans- mission gate disabled, Aand Bare connected. EN /H110051 EN__ _ /H110050, transmission gate enabled, logic value flow Aand B. 1.7.8 Pseudo-nMOS Logic N-input CMOS gate uses NnMOS transistors parallel NpMOS transistors series. Transistors series slower transistors parallel, resistors series resistance resistors parallel. Moreover, pMOS transistors slower nMOS transistors holes cannot move around silicon lattice fast electrons. Therefore parallel nMOS transistors fast series pMOS transistors slow, especially many series. Pseudo-nMOS logic replaces slow stack pMOS transistors single weak pMOS transistor always ON, shown Figure 1.39. pMOS transistor often called weak pull-up . physical dimensions pMOS transistor selected pMOS transistor pull output, Y, HIGH weakly—that is, none nMOS transistors ON. nMOS transistor ON, overpowers weak pull-up pulls Ydown close enough GND produce logic 0. advantage pseudo-nMOS logic used build fast gates many inputs. example, Figure 1.40 shows pseudo-nMOS four-input NOR. Pseudo-nMOS gates useful certain memory logic arrays discussed Chapter 5. disadvantage short circuit exists VDDand GND output LOW; weak pMOS nMOS transistors ON. short circuit draws continuous power, pseudo-nMOS logic must used sparingly.1.7 CMOS Transistors 33 Figure 1.40 Pseudo-nMOS four- input gateFigure 1.37 Two-input gate schematic Figure 1.38 Transmission gate Figure 1.39 Generic pseudo- nMOS gateA BEN EN inputs nMOS pull-down network weak ABYweak C DChapter 01.qxd 1/27/07 10:20 Page 33Pseudo-nMOS gates got name 1970’s, manufac- turing processes nMOS transistors. weak nMOS transistor used pull output HIGH pMOS transistors available. 1.8 POWER CONSUMPTION* Power consumption amount energy used per unit time. Power consumption great importance digital systems. battery life portable systems cell phones laptop computers limited power consumption. Power also significant systems plugged in, electricity costs money system overheat draws much power. Digital systems draw dynamic static power. Dynamic power power used charge capacitance signals change 0 1. Static power power used even signals change system idle. Logic gates wires connect capacitance. energy drawn power supply charge capacitance Cto volt- age VDDis CVDD2. voltage capacitor switches frequency f(i.e., ftimes per second), charges capacitor f/2 times dis- charges f/2 times per second. Discharging draw energy power supply, dynamic power consumption Pdynamic /H11005CV2DDf (1.4) Electrical systems draw current even idle. transistors OFF, leak small amount current. circuits, pseudo-nMOS gate discussed Section 1.7.8, path VDDto GND current flows continuously. total static current, IDD, also called leakage current quiescent supply current flowing VDDand GND. static power con- sumption proportional static current: Pstatic /H11005IDDVDD (1.5) Example 1.23 POWER CONSUMPTION particular cell phone 6 watt-hour (W-hr) battery operates 1.2 V. Suppose that, use, cell phone operates 300 MHz average amount capacitance chip switching given time 10 nF (10/H110028Farads). use, also broadcasts 3 W power antenna. phone use, dynamic power drops almost zero signal processing turned off. phone also draws 40 quiescent current whether use not. Determine battery life phone (a) used, (b) used continuously.1 234 CHAPTER ONE Zero OneChapter 01.qxd 1/27/07 10:20 Page 34Solution: static power Pstatic /H11005(0.040 A)(1.2 V) /H1100548 mW. phone used, power consumption, battery life (6 W- hr)/(0.048 W) /H11005125 hours (about 5 days). phone used, dynamic power Pdynamic /H11005(0.5)(10/H110028F)(1.2 V)2(3/H11003108Hz) /H110052.16 W. Together static broadcast power, total active power 2.16 W /H11001 0.048 W /H110013W /H110055.2 W, battery life 6 W-hr/5.2 W /H110051.15 hours. example somewhat oversimplifies actual operation cell phone, illustrates key ideas power consumption. 1.9 SUMMARY LOOK AHEAD 10 kinds people world: count binary can’t. chapter introduced principles understanding designing complex systems. Although real world analog, digital designers discipline use discrete subset possible signals. par- ticular, binary variables two states: 0 1, also called FALSE TRUE LOW HIGH. Logic gates compute binary output one binary inputs. common logic gates are: /L50776NOT : TRUE input FALSE /L50776AND : TRUE inputs TRUE /L50776OR: TRUE inputs TRUE /L50776XOR : TRUE odd number inputs TRUE Logic gates commonly built CMOS transistors, behave electrically controlled switches. nMOS transistors turn gate 1. pMOS transistors turn gate 0. Chapters 2 5, continue study digital logic. Chapter 2 addresses combinational logic , outputs depend current inputs. logic gates introduced already exam- ples combinational logic. learn design circuits involving multiple gates implement relationship inputs outputs specified truth table Boolean equation. Chapter 3 addresses sequential logic, outputs depend current past inputs. Registers common sequential elements remember previous input. Finite state machines , built registers combina- tional logic, powerful way build complicated systems sys- tematic fashion. also study timing digital systems analyze fast systems operate. Chapter 4 describes hardware description languages (HDLs). HDLs related conventional programming languages used simulate build hardware rather software. digital systems today designed HDLs. Verilog1.9 Summary Look Ahead 35Chapter 01.qxd 1/27/07 10:20 Page 35and VHDL two prevalent languages, covered side- by-side book. Chapter 5 studies combinational sequen- tial building blocks adders, multipliers, memories. Chapter 6 shifts computer architecture. describes MIPS processor, industry-standard microprocessor used consumer elec- tronics, Silicon Graphics workstations, many communications systems televisions, networking hardware wireless links. MIPS architecture defined registers assembly language instruction set. learn write programs assembly language MIPS processor communicate processor native language. Chapters 7 8 bridge gap digital logic computer architecture. Chapter 7 investigates microarchitecture, arrangement digital building blocks, adders registers, needed con- struct processor. chapter, learn build MIPS processor. Indeed, learn three microarchitectures illustrating different trade-offs performance cost. Processor performance increased exponentially, requiring ever sophisticated memory systems feed insatiable demand data. Chapter 8 delves memory system architecture also describes computers communicate periph- eral devices keyboards printers.36 CHAPTER ONE Zero OneChapter 01.qxd 1/27/07 10:20 Page 36Exercises 37 Exercises Exercise 1.1 Explain one paragraph least three levels abstraction used a) biologists studying operation cells. b) chemists studying composition matter. Exercise 1.2 Explain one paragraph techniques hierarchy, modularity, regularity may used a) automobile designers. b) businesses manage operations. Exercise 1.3 Ben Bitdiddle building house. Explain use principles hierarchy, modularity, regularity save time money construction. Exercise 1.4 analog voltage range 0–5 V. measured accuracy /H1100650 mV, many bits information convey? Exercise 1.5 classroom old clock wall whose minute hand broke off. a) read hour hand nearest 15 minutes, many bits information clock convey time? b) know whether noon, many additional bits information know time? Exercise 1.6 Babylonians developed sexagesimal (base 60) number sys- tem 4000 years ago. many bits information conveyed one sexagesimal digit? write number 4000 10in sexagesimal? Exercise 1.7 many different numbers represented 16 bits? Exercise 1.8 largest unsigned 32-bit binary number? Exercise 1.9 largest 16-bit binary number represented a) unsigned numbers? b) two’s complement numbers? c) sign/magnitude numbers?Chapter 01.qxd 1/27/07 10:20 Page 3738 CHAPTER ONE Zero One Exercise 1.10 smallest (most negative) 16-bit binary number represented a) unsigned numbers? b) two’s complement numbers? c) sign/magnitude numbers? Exercise 1.11 Convert following unsigned binary numbers decimal. a) 1010 2 b) 110110 2 c) 11110000 2 d) 0001100010100111 2 Exercise 1.12 Repeat Exercise 1.11, convert hexadecimal. Exercise 1.13 Convert following hexadecimal numbers decimal. a) A5 16 b) 3B 16 c) FFFF 16 d) D0000000 16 Exercise 1.14 Repeat Exercise 1.13, convert unsigned binary. Exercise 1.15 Convert following two’s complement binary numbers decimal. a) 1010 2 b) 110110 2 c) 01110000 2 d) 10011111 2 Exercise 1.16 Repeat Exercise 1.15, assuming binary numbers sign/magnitude form rather two’s complement representation. Exercise 1.17 Convert following decimal numbers unsigned binary numbers. a) 42 10 b) 63 10Chapter 01.qxd 1/27/07 10:20 Page 38c) 229 10 d) 845 10 Exercise 1.18 Repeat Exercise 1.17, convert hexadecimal. Exercise 1.19 Convert following decimal numbers 8-bit two’s complement numbers indicate decimal number would overflow range. a) 42 10 b) /H110026310 c) 124 10 d) /H11002128 10 e) 133 10 Exercise 1.20 Repeat Exercise 1.19, convert 8-bit sign/magnitude numbers. Exercise 1.21 Convert following 4-bit two’s complement numbers 8-bit two’s complement numbers. a) 0101 2 b) 1010 2 Exercise 1.22 Repeat Exercise 1.21 numbers unsigned rather two’s complement. Exercise 1.23 Base 8 referred octal . Convert numbers Exercise 1.17 octal. Exercise 1.24 Convert following octal numbers binary, hexadecimal, decimal. a) 42 8 b) 63 8 c) 255 8 d) 3047 8 Exercise 1.25 many 5-bit two’s complement numbers greater 0? many less 0? would answers differ sign/magnitude numbers?Exercises 39Chapter 01.qxd 1/27/07 10:20 Page 39Exercise 1.26 many bytes 32-bit word? many nibbles word? Exercise 1.27 many bytes 64-bit word? Exercise 1.28 particular DSL modem operates 768 kbits/sec. many bytes receive 1 minute? Exercise 1.29 Hard disk manufacturers use term “megabyte” mean 106 bytes “gigabyte” mean 109bytes. many real GBs music store 50 GB hard disk? Exercise 1.30 Estimate value 231without using calculator. Exercise 1.31 memory Pentium II microprocessor organized rec- tangular array bits 28rows 29columns. Estimate many bits without using calculator. Exercise 1.32 Draw number line analogous Figure 1.11 3-bit unsigned, two’s complement, sign/magnitude numbers. Exercise 1.33 Perform following additions unsigned binary numbers. Indicate whether sum overflows 4-bit result. a) 1001 2/H110010100 2 b) 1101 2/H110011011 2 Exercise 1.34 Perform following additions unsigned binary numbers. Indicate whether sum overflows 8-bit result. a) 10011001 2/H1100101000100 2 b) 11010010 2/H1100110110110 2 Exercise 1.35 Repeat Exercise 1.34, assuming binary numbers two’s complement form. Exercise 1.36 Convert following decimal numbers 6-bit two’s complement binary numbers add them. Indicate whether sum overflows 6-bit result. a) 16 10/H11001910 b) 27 10/H110013110 c) /H11002410/H11001191040 CHAPTER ONE Zero OneChapter 01.qxd 1/27/07 10:20 Page 40d) 3 10/H11001/H110023210 e) /H110021610/H11001/H11002910 f) /H110022710/H11001/H110023110 Exercise 1.37 Perform following additions unsigned hexadecimal numbers. Indicate whether sum overflows 8-bit (two hex digit) result. a) 7 16/H11001916 b) 13 16/H110012816 c) AB 16/H110013E16 d) 8F 16/H11001AD16 Exercise 1.38 Convert following decimal numbers 5-bit two’s complement binary numbers subtract them. Indicate whether difference over- flows 5-bit result. a) 9 10/H11002710 b) 12 10/H110021510 c) /H11002610/H110021110 d) 4 10/H11002/H11002810 Exercise 1.39 biased N -bit binary number system bias B, positive negative numbers represented value plus bias B. example, 5-bit numbers bias 15, number 0 represented 01111, 1 10000, forth. Biased number systems sometimes used floating point mathematics, discussed Chapter 5. Consider biased 8-bit binary number system bias 127 10. a) decimal value binary number 10000010 2represent? b) binary number represents value 0? c) representation value negative number? d) representation value positive number? Exercise 1.40 Draw number line analogous Figure 1.11 3-bit biased numbers bias 3 (see Exercise 1.39 definition biased numbers). Exercise 1.41 binary coded decimal (BCD) system, 4 bits used repre- sent decimal digit 0 9. example, 37 10is written 00110111 BCD.Exercises 41Chapter 01.qxd 1/27/07 10:20 Page 41a) Write 289 10in BCD. b) Convert 100101010001 BCDto decimal. c) Convert 01101001 BCDto binary. d) Explain BCD might useful way represent numbers. Exercise 1.42 flying saucer crashes Nebraska cornfield. FBI investi- gates wreckage finds engineering manual containing equation Martian number system: 325 /H1100142/H11005411. equation correct, many fingers would expect Martians have? Exercise 1.43 Ben Bitdiddle Alyssa P. Hacker argument. Ben says, “All integers greater zero exactly divisible six exactly two 1’s binary representation.” Alyssa disagrees. says, “No, numbers even number 1’s representation.” agree Ben Alyssa neither? Explain. Exercise 1.44 Ben Bitdiddle Alyssa P. Hacker another argument. Ben says, “I get two’s complement number subtracting 1, inverting bits result.” Alyssa says, “No, examining bit number, starting least significant bit. first 1 found, invert subsequent bit.” agree Ben Alyssa neither? Explain. Exercise 1.45 Write program favorite language (e.g., C, Java, Perl) convert numbers binary decimal. user type unsigned binary number. program print decimal equivalent. Exercise 1.46 Repeat Exercise 1.45 convert decimal hexadecimal. Exercise 1.47 Repeat Exercise 1.45 convert arbitrary base b 1to another base b 2, specified user. Support bases 16, using letters alphabet digits greater 9. user enter b 1, b2, number convert base b 1. program print equivalent num- ber base b 2. Exercise 1.48 Draw symbol, Boolean equation, truth table a) three-input gate. b) three-input exclusive (XOR) gate. c) four-input XNOR gate42 CHAPTER ONE Zero OneChapter 01.qxd 1/27/07 10:20 Page 42Exercise 1.49 majority gate produces TRUE output half inputs TRUE. Complete truth table three-input majority gate shown Figure 1.41. Exercise 1.50 three-input AND-OR (AO) gateshown Figure 1.42 produces TRUE output Aand Bare TRUE, Cis TRUE. Complete truth table gate. Exercise 1.51 three-input OR-AND-INVERT (OAI) gateshown Figure 1.43 produces FALSE input Cis TRUE Aor Bis TRUE. Otherwise produces TRUE output. Complete truth table gate. Exercise 1.52 16 different truth tables Boolean functions two variables. List truth table. Give one short descriptive name (such OR, NAND, on). Exercise 1.53 many different truth tables exist Boolean functions N variables? Exercise 1.54 possible assign logic levels device trans- fer characteristics shown Figure 1.44 would serve inverter? so, input output low high levels ( VIL, VOL, VIH, VOH) noise margins (NM Land NM H)? not, explain not.Exercises 43 B CMAJ BYC BYCFigure 1.41 Three-input majority gate Figure 1.42 Three-input AND-OR gate Figure 1.43 Three-input OR-AND-INVERT gateChapter 01.qxd 1/27/07 10:20 Page 43Exercise 1.55 Repeat Exercise 1.54 transfer characteristics shown Figure 1.45. Exercise 1.56 possible assign logic levels device trans- fer characteristics shown Figure 1.46 would serve buffer? so, input output low high levels ( VIL, VOL, VIH, VOH) noise margins (NM Land NM H)? not, explain not.44 CHAPTER ONE Zero One Figure 1.45 DC transfer characteristicsVinVout 012345012345Figure 1.44 DC transfer characteristicsVinVout 012345012345Chapter 01.qxd 1/27/07 10:20 Page 44Exercise 1.57 Ben Bitdiddle invented circuit transfer characteris- tics shown Figure 1.47 would like use buffer. work? not? would like advertise compatible LVCMOS LVTTL logic. Ben’s buffer correctly receive inputs logic families? output properly drive logic families? Explain. Exercise 1.58 walking dark alley, Ben Bitdiddle encounters two- input gate transfer function shown Figure 1.48. inputs Aand Band output Y. a) kind logic gate find? b) approximate high low logic levels?Exercises 45 VinVout 012345012345 VinVout 000.61.21.82.43.03.3 3.3 0.6 1.2 1.8 2.4 3.0Figure 1.46 DC transfer characteristics Figure 1.47 Ben’s buffer DC transfer characteristicsChapter 01.qxd 1/27/07 10:20 Page 45Exercise 1.59 Repeat Exercise 1.58 Figure 1.49. Exercise 1.60 Sketch transistor-level circuit following CMOS gates. Use minimum number transistors. a) four-input NAND gate. b) three-input OR-AND-INVERT gate (see Exercise 1.51). c) three-input AND-OR gate (see Exercise 1.50). Exercise 1.61 minority gate produces TRUE output fewer half inputs TRUE. Otherwise produces FALSE output. Sketch transistor-level circuit CMOS minority gate. Use minimum number transistors.46 CHAPTER ONE Zero One Figure 1.48 Two-input DC transfer characteristics Figure 1.49 Two-input DC transfer characteristics0123 01230123 ABY 0123 01230123 ABYChapter 01.qxd 1/27/07 10:20 Page 46Exercise 1.62 Write truth table function performed gate Figure 1.50. truth table two inputs, Aand B. name function? Exercise 1.63 Write truth table function performed gate Figure 1.51. truth table three inputs, A, B, C. Exercise 1.64 Implement following three-input gates using pseudo- nMOS logic gates. gates receive three inputs, A, B, C. Use minimum number transistors. a) three-input gate b) three-input NAND gate a) three-input gate Exercise 1.65 Resistor-Transistor Logic (RTL) uses nMOS transistors pull gate output LOW weak resistor pull output HIGH none paths ground active. gate built using RTL shown Figure 1.52. Sketch three-input RTL gate. Use minimum number transistors.Exercises 47 BA BAA BB BCCAB AYweakFigure 1.50 Mystery schematic Figure 1.51 Mystery schematic Figure 1.52 RTL gateChapter 01.qxd 1/27/07 10:20 Page 47Interview Questions questions asked interviews digital design jobs. Question 1.1 Sketch transistor-level circuit CMOS four-input gate. Question 1.2 king receives 64 gold coins taxes reason believe one counterfeit. summons identify fake coin. balance hold coins side. many times need use balance find lighter, fake coin? Question 1.3 professor, teaching assistant, digital design student, freshman track star need cross rickety bridge dark night. bridge shakey two people cross time. one flashlight among span long throw flashlight, some- body must carry back people. freshman track star cross bridge 1 minute. digital design student cross bridge 2 min- utes. teaching assistant cross bridge 5 minutes. professor always gets distracted takes 10 minutes cross bridge. fastest time get everyone across bridge?48 CHAPTER ONE Zero OneChapter 01.qxd 1/27/07 10:20 Page 482 2.1 Introduction 2.2 Boolean Equations 2.3 Boolean Algebra 2.4 Logic Gates 2.5 Multilevel Combinational Logic 2.6 X’s Z’s, Oh 2.7 Karnaugh Maps 2.8 Combinational Building Blocks 2.9 Timing 2.10 Summary Exercises Interview QuestionsCombinational Logic Design 2.1 INTRODUCTION digital electronics, circuit network processes discrete- valued variables. circuit viewed black box, shown Figure 2.1, /L50776one discrete-valued input terminals /L50776one discrete-valued output terminals /L50776a functional specification describing relationship inputs outputs /L50776a timing specification describing delay inputs changing outputs responding. Peering inside black box, circuits composed nodes ele- ments. element circuit inputs, outputs, specifica- tion. node wire, whose voltage conveys discrete-valued variable. Nodes classified input, output, internal. Inputs receive values external world. Outputs deliver values external world. Wires inputs outputs called internal nodes. Figure 2.2 51inputs outputsfunctional spec timing specFigure 2.1 Circuit black box inputs, outputs, specifications Figure 2.2 Elements nodesA E1 E2E3 B Cn1 ZChapter 02.qxd 1/31/07 9:55 PM Page 51illustrates circuit three elements, E1, E2, E3, six nodes. Nodes A, B, Care inputs. Yand Z outputs. n1 internal node E1 E3. Digital circuits classified combinational sequential. com- binational circuit’s outputs depend current values inputs; words, combines current input values compute output. example, logic gate combinational circuit. sequential circuit’s outputs depend current previous values inputs; words, depends input sequence. combi- national circuit memoryless, sequential circuit memory. chapter focuses combinational circuits, Chapter 3 examines sequential circuits. functional specification combinational circuit expresses output values terms current input values. timing specification combinational circuit consists lower upper bounds delay input output. initially concentrate functional specification, return timing specification later chapter. Figure 2.3 shows combinational circuit two inputs one output. left figure inputs, Aand B,and right output, Y.The symbol CL inside box indicates imple- mented using combinational logic. example, function, F, specified OR: Y/H11005F(A, B )/H11005A/H11001B.In words, say output, Y,is function two inputs, Aand B,namely Y/H11005AOR B. Figure 2.4 shows two possible implementations combina- tional logic circuit Figure 2.3. see repeatedly throughout book, often many implementations single function. choose use given building blocks disposal design constraints. constraints often include area, speed, power, design time. Figure 2.5 shows combinational circuit multiple outputs. particular combinational circuit called full adder revisit Section 5.2.1. two equations specify function out- puts, Sand Cout, terms inputs, A, B, Cin. simplify drawings, often use single line slash number next indicate bus, bundle multiple signals. number specifies many signals bus. example, Figure 2.6(a) represents block combinational logic three inputs two outputs. number bits unimportant obvious context, slash may shown without number. Figure 2.6(b) indicates two blocks combinational logic arbitrary number outputs one block serving inputs second block. rules combinational composition tell us build large combinational circuit smaller combinational circuit52 CHAPTER TWO Combinational Logic Design Figure 2.3 Combinational logic circuit Figure 2.4 Two implementationsA = F(A, B) = + BCL (a) (b)A B Figure 2.5 Multiple-output combinational circuit Figure 2.6 Slash notation multiple signalsAS = ⊕ B ⊕ Cin Cout = AB + ACin + BCinB CinCLCout CL3 (a) CL CL (b)2Chapter 02.qxd 1/31/07 9:55 PM Page 52elements. circuit combinational consists interconnected circuit elements /L50776Every circuit element combinational. /L50776Every node circuit either designated input circuit connects exactly one output terminal circuit element. /L50776The circuit contains cyclic paths: every path circuit visits circuit node once. Example 2.1 COMBINATIONAL CIRCUITS circuits Figure 2.7 combinational circuits according rules combinational composition? Solution: Circuit (a) combinational. constructed two combinational circuit elements (inverters I1 I2). three nodes: n1, n2, n3. n1 input circuit I1; n2 internal node, output I1 input I2; n3 output circuit I2. (b) combina- tional, cyclic path: output XOR feeds back one inputs. Hence, cyclic path starting n4 passes XOR n5, returns n4. (c) combinational. (d) combinational, node n6 connects output terminals I3 I4. (e) combinational, illustrating two combinational circuits connected form larger combinational circuit. (f) obey rules combinational composition cyclic path two elements. Depending functions elements, may may combinational circuit. Large circuits microprocessors complicated, use principles Chapter 1 manage complexity. Viewing circuit black box well-defined interface function an2.1 Introduction 53 rules combinational composition sufficient strictly necessary. Certain circuits disobey rules still combinational, long outputs depend current values inputs. However, deter- mining whether oddball cir- cuits combinational difficult, usu- ally restrict com- binational composition way build combinational circuits. Figure 2.7 Example circuits(a)n1 n2 n3I1 I2 (c) CL CL (e)n4n5 (b) n6I3 I4 (d)CL CL (f)Chapter 02.qxd 1/31/07 9:55 PM Page 53application abstraction modularity. Building circuit smaller circuit elements application hierarchy. rules combinational composition application discipline. functional specification combinational circuit usually expressed truth table Boolean equation. next sections, describe derive Boolean equation truth table use Boolean algebra Karnaugh maps simplify equations. show implement equations using logic gates analyze speed circuits. 2.2 BOOLEAN EQUATIONS Boolean equations deal variables either TRUE FALSE, perfect describing digital logic. section defines terminology commonly used Boolean equations, shows write Boolean equation logic function given truth table. 2.2.1 Terminology complement variable, A,is inverse, . variable complement called literal. example, A,, B,and literals. call Athe true form variable complementary form; “true form” mean Ais TRUE, merely Adoes line it. one literals called product implicant. , , Bare implicants function three variables. Aminterm product involving inputs function. minterm function three variables A, B, C,but not, involve C.Similarly, one literals called sum. maxterm sum involving inputs function. maxterm function three variables A, B, C. order operations important interpreting Boolean equations. Y/H11005A/H11001BCmean Y/H11005(AOR B) Cor Y/H11005A ( BAND C)? Boolean equations, highest precedence, followed AND, OR. ordinary equations, products performed sums. Therefore, equation read Y/H11005AOR (BAND C). Equation 2.1 gives another example order operations. (2.1) 2.2.2 Sum-of-Products Form truth table Ninputs contains 2Nrows, one possible value inputs. row truth table associated mintermAB/H11001BCD /H11005((A)B)/H11001(BC(D))A/H11001B/H11001CABAB CAB C ABAB AA54 CHAPTER TWO Combinational Logic DesignChapter 02.qxd 1/31/07 9:55 PM Page 54that TRUE row. Figure 2.8 shows truth table two inputs, Aand B.Each row shows corresponding minterm. exam- ple, minterm first row TRUE A/H110050, B/H110050. write Boolean equation truth table summing minterms output, Y,is TRUE. example, Figure 2.8, one row (or minterm) output Yis TRUE, shown circled blue. Thus, . Figure 2.9 shows truth table one row output TRUE. Taking sum circled minterms gives . called sum-of-products canonical form function sum (OR) products (ANDs forming minterms). Although many ways write function, , sort minterms order appear truth table, always write Boolean expression truth table. Example 2.2 SUM-OF-PRODUCTS FORM Ben Bitdiddle picnic. won’t enjoy rains ants. Design circuit output TRUE Ben enjoys picnic. Solution: First define inputs outputs. inputs Aand R,which indicate ants rains. Ais TRUE ants FALSE ants. Likewise, Ris TRUE rains FALSE sun smiles Ben. output E,Ben’s enjoyment picnic. Eis TRUE Ben enjoys picnic FALSE suffers. Figure 2.10 shows truth table Ben’s picnic experience. Using sum-of-products form, write equation as: . build equation using two inverters two-input gate, shown Figure 2.11(a). may recognize truth table function Section 1.5.5: E/H11005A . Figure 2.11(b) shows implementation. Section 2.3, show two equations, , equivalent. sum-of-products form provides Boolean equation truth table number variables. Figure 2.12 shows random three- input truth table. sum-of-products form logic function (2.2) Unfortunately, sum-of-products form necessarily generate simplest equation. Section 2.3 show write function using fewer terms.Y /H11005A B C/H11001AB C/H11001ABCA/H11001R RR/H11005A/H11001RE/H11005A RY/H11005BA/H11001BAY/H11005AB/H11001ABY/H11005ABA B B2.2 Boolean Equations 55 Figure 2.8 Truth table minterms Figure 2.9 Truth table multiple TRUE minterms0ABY 00 01 10 110 1 0minterm AB AB ABAB ABY 00 01 10 110 1 0 1minterm AB AB ABAB Canonical form fancy word standard form. use term impress friends scare enemies.Chapter 02.qxd 1/31/07 9:55 PM Page 552.2.3 Product-of-Sums Form alternative way expressing Boolean functions product-of- sums canonical form . row truth table corresponds max- term FALSE row. example, maxterm first row two-input truth table ( A/H11001B) ( A/H11001B) FALSE A/H110050, B/H110050. write Boolean equation circuit directly truth table max- terms output FALSE. Example 2.3 PRODUCT-OF-SUMS FORM Write equation product-of-sums form truth table Figure 2.13. Solution: truth table two rows output FALSE. Hence, function written product-of-sums form . first maxterm, ( A/H11001B), guarantees Y/H110050 A/H110050, B/H110050, value 0 0. Likewise, second maxterm, , guarantees Y/H110050 A/H110051, B/H110050. Figure 2.13 truth table Figure 2.9, showing function written one way. Similarly, Boolean equation Ben’s picnic Figure 2.10 written product-of-sums form circling three rows 0’s obtain . uglier sum- of-products equation, , two equations logically equivalent. Sum-of-products produces shortest equations output TRUE rows truth table; product-of-sums simpler output FALSE rows truth table. 2.3 BOOLEAN ALGEBRA previous section, learned write Boolean expression given truth table. However, expression necessarily lead simplest set logic gates. use algebra simplify mathe- matical equations, use Boolean algebra simplify Boolean equations. rules Boolean algebra much like ordinary algebra cases simpler, variables two possible values: 0 1. Boolean algebra based set axioms assume cor- rect. Axioms unprovable sense definition cannot proved. axioms, prove theorems Boolean alge- bra. theorems great practical significance, teach us simplify logic produce smaller less costly circuits.E/H11005A RE/H11005(A/H11001R)(A/H11001R)(A/H11001R)(A/H11001B)Y/H11005(A/H11001B)(A/H11001B)56 CHAPTER TWO Combinational Logic Design Figure 2.13 Truth table multiple FALSE maxtermsA + BABY 00 01 10 110 1 0 1maxterm + B + B + BFigure 2.12 Random three-input truth tableBCY 00 01 10 111 0 0 0A 0 0 0 0 00 01 10 111 1 1 11 1 0 0Figure 2.11 Ben’s circuitA (a) (b)Figure 2.10 Ben’s truth tableARE 00 01 10 111 0 0 0Chapter 02.qxd 1/31/07 9:55 PM Page 56Axioms theorems Boolean algebra obey principle dual- ity.If symbols 0 1 operators • (AND) /H11001(OR) interchanged, statement still correct. use prime ( /H11032) symbol denote dual statement. 2.3.1 Axioms Table 2.1 states axioms Boolean algebra. five axioms duals define Boolean variables meanings NOT, AND, OR. Axiom A1 states Boolean variable Bis 0 1. axiom’s dual, A1 /H11032, states variable 1 0. Together, A1 A1 /H11032tell us working Boolean binary field 0’s 1’s. Axioms A2 A2 /H11032define operation. Axioms A3 A5 define AND; duals, A3 /H11032to A5 /H11032define OR. 2.3.2 Theorems One Variable Theorems T1 T5 Table 2.2 describe simplify equations involving one variable. identity theorem, T1, states Boolean variable B, B 1 /H11005B.Its dual states BOR 0 /H11005B.In hardware, shown Figure 2.14, T1 means one input two-input gate always 1, remove gate replace wire con- nected variable input ( B). Likewise, T1 /H11032means one input two-input gate always 0, replace gate wire connected B.In general, gates cost money, power, delay, replacing gate wire beneficial. null element theorem, T2, says BAND 0 always equal 0. Therefore, 0 called null element operation, nullifies effect input. dual states B 1 always equal 1. Hence, 1 null element operation. hardware, shown Figure 2.15, one input gate 0, replace gate wire tied2.3 Boolean Algebra 57 Axiom Dual Name A1 B/H110050 B/HS110051A 1 /H11032 B/H110051 B/HS110050 Binary field A2 A2 /H11032 A3 0 • 0 /H110050A 3 /H11032 1/H110011/H110051 AND/OR A4 1 • 1 /H110051A 4 /H11032 0/H110010/H110050 AND/OR A5 0 • 1 /H110051 • 0 /H110050A 5 /H11032 1/H110010/H110050/H110011/H110051 AND/OR1/H110050 0/H110051Table 2.1 Axioms Boolean algebra null element theorem leads outlandish state- ments actually true! particularly dangerous left hands advertisers: GET MILLION DOLLARS we’ll send toothbrush mail. (You’ll likely receiving toothbrush mail.)Figure 2.14 Identity theorem hardware: (a) T1, (b) T1 /H110321= (a)BB =0BB (b)Chapter 02.qxd 1/31/07 9:55 PM Page 57LOW (to 0). Likewise, one input gate 1, replace gate wire tied HIGH (to 1). Idempotency, T3, says variable equal itself. Likewise, variable equal itself. theorem gets name Latin roots: idem (same) potent (power). operations return thing put them. Figure 2.16 shows idempotency permits replacing gate wire. Involution, T4, fancy way saying complementing vari- able twice results original variable. digital electronics, two wrongs make right. Two inverters series logically cancel logically equivalent wire, shown Figure 2.17. dual T4 itself. complement theorem, T5 (Figure 2.18), states variable complement 0 (because one 0). And, dua- lity, variable complement 1 (because one 1). 2.3.3 Theorems Several Variables Theorems T6 T12 Table 2.3 describe simplify equations involving one Boolean variable. Commutativity associativity, T6 T7, work traditional algebra. commutativity, order inputs function affect value output. associativity, specific groupings inputs affect value output. distributivity theorem, T8, traditional algebra, dual, T8 /H11032, not. T8, distributes OR, T8 /H11032, distributes AND. traditional algebra, multiplication distributes addition addition distribute multiplication, (B/H11001C)/H11003(B/H11001D)/HS11005B/H11001(C/H11003D). covering, combining, consensus theorems, T9 T11, per- mit us eliminate redundant variables. thought, able convince theorems correct.58 CHAPTER TWO Combinational Logic Design Theorem Dual Name T1 B• 1/H11005B T1/H11032 B/H110010/H11005B Identity T2 B• 0/H110050T 2 /H11032 B/H110011/H110051 Null Element T3 B• B/H11005B T3/H11032 B/H11001B/H11005B Idempotency T4 B=/H11005B Involution T5 T5 /H11032 Complements B/H11001B/H110051 B • B/H110050Table 2.2 Boolean theorems one variable Figure 2.16 Idempotency theorem hardware: (a) T3, (b) T3 /H11032B= (a)BB =BBB (b) Figure 2.17 Involution theorem hardware: T4 Figure 2.18 Complement theorem hardware: (a) T5, (b) T5 /H11032=B B B= (a)B 0 =BB1 (b)Figure 2.15 Null element theorem hardware: (a) T2, (b) T2 /H110320= (a)B0 =1B1 (b)Chapter 02.qxd 1/31/07 9:55 PM Page 58De Morgan’s Theorem, T12, particularly powerful tool digital design. theorem explains complement product terms equal sum complement term. Likewise, complement sum terms equal product complement term. According De Morgan’s theorem, NAND gate equivalent gate inverted inputs. Similarly, gate equivalent gate inverted inputs. Figure 2.19 shows De Morgan equivalent gates NAND gates. two symbols shown function called duals. logically equivalent used interchangeably.2.3 Boolean Algebra 59 Theorem Dual Name T6 B• C/H11005C• B T6/H11032 B/H11001C/H11005C/H11001B Commutativity T7 ( B• C) • D/H11005B• (C• D)T 7 /H11032 (B/H11001C)/H11001D/H11005B/H11001(C/H11001D) Associativity T8 ( B• C)/H11001(B• D)/H11005B• (C/H11001D)T 8 /H11032 (B/H11001C) • (B/H11001D)/H11005B/H11001(C• D) Distributivity T9 B• (B/H11001C)/H11005B T9/H11032 B/H11001(B• C)/H11005B Covering T10 T10 /H11032 Combining T11 T11 /H11032 Consensus T12 T12 /H11032 De Morgan’s Theorem /H11005(B0 • B1 • B2) /H11005(B0/H11001B1/H11001B2 ...)B0 /H11001 B1 /H11001 B2... B0 • B1 • B2.../H11005(B/H11001C) • (B/H11001D) /H11005B • C/H11001B • D(B/H11001C) • (B/H11001D) • (C/H11001D) (B • C)/H11001(B • D)/H11001(C • D)(B/H11001C) • (B/H11001C)/H11005B (B • C)/H11001(B • C)/H11005BTable 2.3 Boolean theorems several variables Augustus De Morgan, died 1871. British mathematician, born India. Blind one eye. father died 10. Attended Trinity College, Cambridge, age 16, appointed Professor Mathematics newly founded London University age 22. Wrote widely many mathematical subjects, includ- ing logic, algebra, para- doxes. De Morgan’s crater moon named him. proposed riddle year birth: “I x years age year x2.” Figure 2.19 De Morgan equivalent gatesABY 001 011 101 110NAND BYNOR ABY 001 010 100 110Y = + B = B = AB = + BChapter 02.qxd 1/31/07 9:55 PM Page 59The inversion circle called bubble. Intuitively, imagine “pushing” bubble gate causes come side flips body gate vice versa. example, NAND gate Figure 2.19 consists body bubble output. Pushing bubble left results body bubbles inputs. underlying rules bubble pushing /L50776Pushing bubbles backward (from output) forward (from inputs) changes body gate vice versa. /L50776Pushing bubble output back inputs puts bubbles gate inputs. /L50776Pushing bubbles allgate inputs forward toward output puts bubble output. Section 2.5.2 uses bubble pushing help analyze circuits. Example 2.4 DERIVE PRODUCT-OF-SUMS FORM Figure 2.20 shows truth table Boolean function, Y,and complement, . Using De Morgan’s Theorem, derive product-of-sums canonical form sum-of-products form . Solution: Figure 2.21 shows minterms (circled) contained . sum-of- products canonical form (2.3) Taking complement sides applying De Morgan’s Theorem twice, get: (2.4) 2.3.4 Truth Behind curious reader might wonder prove theorem true. Boolean algebra, proofs theorems finite number variables easy: show theorem holds possible values variables. method called perfect induction done truth table. Example 2.5 PROVING CONSENSUS THEOREM Prove consensus theorem, T11, Table 2.3. Solution: Check sides equation eight combinations B, C, D.The truth table Figure 2.22 illustrates combinations. cases, theorem proved. BC/H11001BD/H11001CD/H11005BC/H11001BDY/H11005Y/H11005A B/H11001AB/H11005(A B)(AB)/H11005(A/H11001B)(A/H11001B)Y /H11005A B /H11001ABYYYY60 CHAPTER TWO Combinational Logic Design FIGURE 2.20 Truth table showing Yand Y– Figure 2.21 Truth table showing minterms Y–ABY 00 01 10 110 0 1 1Y 1 1 0 0 ABY 00 01 10 110 0 1 1Y 1 1 0 0minterm AB AB ABABChapter 02.qxd 1/31/07 9:55 PM Page 602.3.5 Simplifying Equations theorems Boolean algebra help us simplify Boolean equations. example, consider sum-of-products expression truth table Figure 2.9: . Theorem T10, equation sim- plifies . may obvious looking truth table. general, multiple steps may necessary simplify complex equations. basic principle simplifying sum-of-products equations combine terms using relationship , Pmay implicant. far equation simplified? define equation sum-of-products form minimized uses fewest possible implicants. several equations number implicants, minimal one one fewest literals. implicant called prime implicant cannot combined implicants form new implicant fewer literals. implicants minimal equation must prime implicants. Otherwise, could combined reduce number literals. Example 2.6 EQUATION MINIMIZATION Minimize Equation 2.2: . Solution: start original equation apply Boolean theorems step step, shown Table 2.4. simplified equation completely point? Let’s take closer look. original equation, minterms differ variable A.So combined minterms form . However, look original equation, note last two minterms also differ single literal ( Cand ). Thus, using method, could combined two minterms form minterm . say implicants share minterm . So, stuck simplifying one minterm pairs, simplify both? Using idempotency theorem, duplicate terms many times want: B/H11005B/H11001B/H11001B/H11001B… . Using principle, simplify equation com- pletely two prime implicants, , shown Table 2.5. B C/H11001ABAB C AB B CABCABC AB CB CAB C B CA B C/H11001AB C/H11001AB C PA/H11001PA/H11005PY/H11005BY/H11005A B/H11001AB2.3 Boolean Algebra 61 Figure 2.22 Truth table proving T1100 01 10 11BCD 0 0 0 0 00 01 10 111 1 1 1BC + BD BC + BD + CD 0 1 0 1 0 0 1 10 1 0 1 0 0 1 1Chapter 02.qxd 1/31/07 9:55 PM Page 61Although bit counterintuitive, expanding implicant (for example, turning ABinto ) sometimes useful minimiz- ing equations. this, repeat one expanded minterms combined (shared) another minterm. may noticed completely simplifying Boolean equa- tion theorems Boolean algebra take trial error. Section 2.7 describes methodical technique called Karnaugh maps makes process easier. bother simplifying Boolean equation remains logically equivalent? Simplifying reduces number gates used physically implement function, thus making smaller, cheaper, possibly faster. next section describes implement Boolean equations logic gates. 2.4 LOGIC GATES schematic diagram digital circuit showing elements wires connect together. example, schematic Figure 2.23 shows possible hardware implementation favorite logic function, Equation 2.2: /H11005A B C/H11001AB C/H11001ABC.ABC /H11001ABC62 CHAPTER TWO Combinational Logic Design Step Equation Justification 1 T3: Idempotency 2 T8: Distributivity 3 T5: Complements 4 T1: Identity B C/H11001ABB C(1)/H11001AB(1)B C(A/H11001A)/H11001AB(C/H11001C)A B C/H11001AB C/H11001AB C /H11001ABCA B C/H11001AB C/H11001AB C Table 2.5 Improved equation minimizationStep Equation Justification 1 T8: Distributivity 2 T5: Complements 3 T1: Identity B C/H11001ABCB C (1)/H11001ABCB C (A/H11001A)/H11001ABC B C/H11001AB C/H11001AB C Table 2.4 Equation minimizationChapter 02.qxd 1/31/07 9:55 PM Page 62By drawing schematics consistent fashion, make easier read debug. generally obey following guidelines: /L50776Inputs left (or top) side schematic. /L50776Outputs right (or bottom) side schematic. /L50776Whenever possible, gates flow left right. /L50776Straight wires better use wires multiple corners (jagged wires waste mental effort following wire rather thinking circuit does). /L50776Wires always connect junction. /L50776A dot wires cross indicates connection wires. /L50776Wires crossing without dot make connection. last three guidelines illustrated Figure 2.24. Boolean equation sum-of-products form drawn schematic systematic way similar Figure 2.23. First, draw columns inputs. Place inverters adjacent columns provide complementary inputs necessary. Draw rows gates minterms. Then, output, draw gate connected minterms related output. style called aprogrammable logic array (PLA) inverters, gates, gates arrayed systematic fashion. PLAs discussed Section 5.6. Figure 2.25 shows implementation simplified equation found using Boolean algebra Example 2.6. Notice simplified circuit significantly less hardware Figure 2.23. may also faster, uses gates fewer inputs. reduce number gates even (albeit single inverter) taking advantage inverting gates. Observe B C2.4 Logic Gates 63 Figure 2.23 Schematic /H11549A–B–C–/H11545 AB–C–/H11545AB–CB AC Yminterm: ABC minterm: ABC minterm: ABCABC Figure 2.24 Wire connectionswires connect junction wires connect dot wires crossing without dot connect AB C Figure 2.25 Schematic /H11549B–C–/H11545AB–Chapter 02.qxd 1/31/07 9:55 PM Page 631Black light, twinkies, beer.AND inverted inputs. Figure 2.26 shows schematic using optimization eliminate inverter C.Recall De Morgan’s theorem inverted inputs equivalent gate. Depending implementation technology, may cheaper use fewest gates use certain types gates preference others. example, NANDs NORs preferred ANDs ORs CMOS implementations. Many circuits multiple outputs, computes sep- arate Boolean function inputs. write separate truth table output, often convenient write outputs single truth table sketch one schematic outputs. Example 2.7 MULTIPLE-OUTPUT CIRCUITS dean, department chair, teaching assistant, dorm social chair use auditorium time time. Unfortunately, occasion- ally conflict, leading disasters one occurred dean’s fundraising meeting crusty trustees happened time dorm’s BTB1party. Alyssa P. Hacker called design room reser- vation system. system four inputs, A3,..., A0, four outputs, Y3,..., Y0. signals also written A3:0and Y3:0. user asserts input requests auditorium next day. system asserts one output, granting auditorium highest priority user. dean, paying system, demands highest priority (3). department chair, teaching assis- tant, dorm social chair decreasing priority. Write truth table Boolean equations system. Sketch circuit performs function. Solution: function called four-input priority circuit. symbol truth table shown Figure 2.27. could write output sum-of-products form reduce equations using Boolean algebra. However, simplified equations clear inspec- tion functional description (and truth table): Y3is TRUE when- ever A3is asserted, Y3/H11005A3. Y2is TRUE A2is asserted A3is asserted, . Y1is TRUE A1is asserted neither higher priority inputs asserted: . Y0is TRUE whenever A0and input asserted: . schematic shown Figure 2.28. experienced designer often implement logic circuit inspec- tion. Given clear specification, simply turn words equations equations gates.Y0/H11005A3A2A1 A0Y1/H11005A3A2 A1Y2/H11005A3A264 CHAPTER TWO Combinational Logic Design YA C B Figure 2.26 Schematic using fewer gatesChapter 02.qxd 1/31/07 9:55 PM Page 64Notice A3is asserted priority circuit, outputs don’t care inputs are. use symbol X describe inputs output doesn’t care about. Figure 2.29 shows four-input priority circuit truth table becomes much smaller don’t cares. truth table, easily read Boolean equations sum-of- products form ignoring inputs X’s. Don’t cares also appear truth table outputs, see Section 2.7.3. 2.5 MULTILEVEL COMBINATIONAL LOGIC Logic sum-of-products form called two-level logic con- sists literals connected level gates connected level of2.5 Multilevel Combinational Logic 65 A0A1 Priority CircuitA2A3 00 01 10 110 0 0 00 0 0 00 0 1 10 1 0 0Y0Y1Y2Y3 00 00 00 00 000 100 01 01 10 11 0001 01 01 10 01 10 10 11 00 0110 10 11 11 10 11 11 110 0 0 11 1 1 00 0 0 00 0 0 0 1000 1 1 1 10 0 0 00 0 0 00 0 0 0 1000 1000A1A0 A3A2 Y2Y1Y0 Y3 Figure 2.27 Priority circuit Figure 2.28 Priority circuit schematicA3A2A1A0Y3 Y2 Y1 Y0 Figure 2.29 Priority circuit truth table don’t cares (X’s)A1A0 00 01 1X XX0 0 0 00 0 0 10 0 1 00 1 0 0A3A2 00 00 00 01 XX 1000 1XY1Y0 Y3Y2 X overloaded symbol means “don’t care” truth tables “contention” logic simulation (see Section 2.6.1). Think context don’t mix meanings. authors use ? instead “don’t care” avoid ambiguity.Chapter 02.qxd 1/31/07 9:55 PM Page 65OR gates. Designers often build circuits two levels logic gates. multilevel combinational circuits may use less hard- ware two-level counterparts. Bubble pushing especially helpful analyzing designing multilevel circuits. 2.5.1 Hardware Reduction logic functions require enormous amount hardware built using two-level logic. notable example XOR function multiple variables. example consider building three-input XOR using two-level techniques studied far. Recall N-input XOR produces TRUE output odd number inputs TRUE. Figure 2.30 shows truth table three-input XOR rows circled produce TRUE outputs. truth table, read Boolean equation sum-of-products form Equation 2.5. Unfortunately, way simplify equation fewer implicants. (2.5) hand, A/H20003B/H20003C/H11005(A/H20003B)/H20003C(prove your- self perfect induction doubt). Therefore, three-input XOR built cascade two-input XORs, shown Figure 2.31. Similarly, eight-input XOR would require 128 eight-input gates one 128-input gate two-level sum-of-products imple- mentation. much better option use tree two-input XOR gates, shown Figure 2.32.Y /H11005A BC/H11001ABC/H11001AB C/H11001ABC66 CHAPTER TWO Combinational Logic Design Figure 2.30 Three-input XOR: (a) functional specification (b) two-level logic implementationBC 00 01 10 11A 0 0 0 0 00 01 10 111 1 1 10 1 1 0 1 0 0 1YXOR3 = ⊕ B ⊕ CA CB C (b) (a)Chapter 02.qxd 1/31/07 9:55 PM Page 66Selecting best multilevel implementation specific logic func- tion simple process. Moreover, “best” many meanings: fewest gates, fastest, shortest design time, least cost, least power consumption. Chapter 5, see “best” circuit one technology necessarily best another. example, using ANDs ORs, CMOS, NANDs NORs efficient. experience, find create good multilevel design inspection circuits. develop experience study circuit examples rest book. learning, explore various design options think trade-offs. Computer-aided design (CAD) tools also available search vast space possible multilevel designs seek one best fits constraints given available building blocks. 2.5.2 Bubble Pushing may recall Section 1.7.6 CMOS circuits prefer NANDs NORs ANDs ORs. reading equation inspection multilevel circuit NANDs NORs get pretty hairy. Figure 2.33 shows multilevel circuit whose function immedi- ately clear inspection. Bubble pushing helpful way redraw circuits bubbles cancel function easily determined. Building principles Section 2.3.3, guidelines bubble pushing follows: /L50776Begin output circuit work toward inputs. /L50776Push bubbles final output back toward inputs read equation terms output (for example, Y) instead complement output . /L50776Working backward, draw gate form bubbles cancel. current gate input bubble, draw preceding gate output bubble. current gate input bubble, draw preceding gate without output bubble. Figure 2.34 shows redraw Figure 2.33 according bubble pushing guidelines. Starting output, Y,the NAND gate bubble output wish eliminate. push output bubble back form inverted inputs, shown in(Y)2.5 Multilevel Combinational Logic 67 Figure 2.31 Three-input XOR using two two-input XORsA B YC Figure 2.32 Eight-input XOR using seven two-input XORs Figure 2.33 Multilevel circuit using NANDs NORsA B C DYChapter 02.qxd 1/31/07 9:55 PM Page 67Figure 2.34(a). Working left, rightmost gate input bubble cancels output bubble middle NAND gate, change necessary, shown Figure 2.34(b). middle gate input bubble, transform leftmost gate output bubble, shown Figure 2.34(c). bubbles circuit cancel except inputs, function read inspection terms ANDs ORs true complementary inputs: . emphasis last point, Figure 2.35 shows circuit logi- cally equivalent one Figure 2.34. functions internal nodes labeled blue. bubbles series cancel, ignore bubble output middle gate input rightmost gate produce logically equivalent circuit Figure 2.35.Y/H11005A BC/H11001D68 CHAPTER TWO Combinational Logic Design B C (a)no output bubble bubble input output B C DY (b) B C DY (c)Y = ABC + Dno bubble input outputFigure 2.34 Bubble-pushed circuit Figure 2.35 Logically equivalent bubble-pushed circuitA B C DYAB ABC = ABC + DChapter 02.qxd 1/31/07 9:55 PM Page 68Example 2.8 BUBBLE PUSHING CMOS LOGIC designers think terms gates, suppose would like implement circuit Figure 2.36 CMOS logic, favors NAND gates. Use bubble pushing convert circuit NANDs, NORs, inverters. Solution: brute force solution replace gate NAND inverter, gate inverter, shown Figure 2.37. requires eight gates. Notice inverter drawn bubble front rather back, emphasize bubble cancel preceding inverting gate. better solution, observe bubbles added output gate input next gate without changing function, shown Figure 2.38(a). final converted NAND inverter, shown Figure 2.38(b). solution requires five gates. 2.6 X’S Z’S, OH Boolean algebra limited 0’s 1’s. However, real circuits also illegal floating values, represented symbolically X Z. 2.6.1 Illegal Value: X symbol X indicates circuit node unknown illegal value. commonly happens driven 0 1 time. Figure 2.39 shows case node Yis driven HIGH LOW. situation, called contention, considered error2.6 X’s Z’s, Oh 69 Figure 2.36 Circuit using ANDs ORs Figure 2.37 Poor circuit using NANDs NORs (a) (b)Figure 2.38 Better circuit using NANDs NORs Figure 2.39 Circuit contentionA = 1 = X B = 0Chapter 02.qxd 1/31/07 9:55 PM Page 69and must avoided. actual voltage node contention may somewhere 0 VDD, depending relative strengths gates driving HIGH LOW. often, always, forbidden zone. Contention also cause large amounts power flow fighting gates, resulting circuit getting hot possibly damaged. X values also sometimes used circuit simulators indicate uninitialized value. example, forget specify value input, simulator may assume X warn problem. mentioned Section 2.4, digital designers also use symbol X indicate “don’t care” values truth tables. sure mix two meanings. X appears truth table, indicates value variable truth table unimportant. X appears circuit, means circuit node unknown illegal value. 2.6.2 Floating Value: Z symbol Z indicates node driven neither HIGH LOW. node said floating, high impedance, high Z. typical misconception floating undriven node logic 0. reality, floating node might 0, might 1, might volt- age between, depending history system. floating node always mean error circuit, long circuit element drive node valid logic level value node relevant circuit operation. One common way produce floating node forget connect voltage circuit input, assume unconnected input input value 0. mistake may cause circuit behave erratically floating input randomly changes 0 1. Indeed, touching circuit may enough trigger change means static electricity body. seen circuits operate correctly long student keeps finger pressed chip. tristate buffer, shown Figure 2.40, three possible out- put states: HIGH (1), LOW (0), floating (Z). tristate buffer input, A,an output, Y,and enable, E. enable TRUE, tristate buffer acts simple buffer, transferring input value output. enable FALSE, output allowed float (Z). tristate buffer Figure 2.40 active high enable. is, enable HIGH (1), buffer enabled. Figure 2.41 shows tristate buffer active low enable. enable LOW (0),70 CHAPTER TWO Combinational Logic Design Figure 2.40 Tristate buffer Figure 2.41 Tristate buffer active low enableEAY 00Z 01Z 100 111AE EAY 000 011 10Z 11ZAE YChapter 02.qxd 1/31/07 9:55 PM Page 70the buffer enabled. show signal active low putting bubble input wire. often indicate active low input draw- ing bar name, , appending word “bar” name, Ebar. Tristate buffers commonly used busses connect multi- ple chips. example, microprocessor, video controller, Ethernet controller might need communicate memory system personal computer. chip connect shared memory bus using tristate buffers, shown Figure 2.42. one chip time allowed assert enable signal drive value onto bus. chips must produce floating outputs cause contention chip talking memory. chip read information shared bus time. tristate busses common. However, mod- ern computers, higher speeds possible point-to-point links, chips connected directly rather shared bus. 2.7 KARNAUGH MAPS working several minimizations Boolean equations using Boolean algebra, realize that, you’re careful, some- times end completely different equation instead simplified equation. Karnaugh maps (K-maps ) graphical method simplify- ing Boolean equations. invented 1953 Maurice Karnaugh, telecommunications engineer Bell Labs. K-maps work well problems four variables. important, give insight manipulating Boolean equations.E2.7 Karnaugh Maps 71 Figure 2.42 Tristate bus connecting multiple chipsen1 bus bus en2 bus bus en3 bus bus en4 bus busProcessor Video Ethernetshared bus Memory Maurice Karnaugh, 1924–. Graduated bachelor’s degree physics City College New York 1948 earned Ph.D. physics Yale 1952. Worked Bell Labs IBM 1952 1993 computer science professor Polytechnic University New York 1980 1999.Chapter 02.qxd 1/31/07 9:55 PM Page 71Recall logic minimization involves combining terms. Two terms containing implicant, P,and true complementary forms variable, A,are combined eliminate A: . Karnaugh maps make combinable terms easy see putting next grid. Figure 2.43 shows truth table K-map three-input function. top row K-map gives four possible values Aand Binputs. left column gives two possible values Cinput. square K-map corresponds row truth table contains value output, Y, row. example, top left square corresponds first row truth table indicates output value Y/H110051 ABC /H11005 000. like row truth table, square K-map represents single minterm. purpose explanation, Figure 2.43(c) shows minterm corresponding square K-map. square, minterm, differs adjacent square change single variable. means adjacent squares share literals except one, appears true form one square complementary form other. example, squares representing minterms adjacent differ variable C.You may noticed Aand Bcombinations top row peculiar order: 00, 01, 11, 10. order called Gray code. differs ordinary binary order (00, 01, 10, 11) adjacent entries differ single variable. example, 01 : 11 changes Afrom 0 1, 01 : 10 would change Afrom 1 0 Bfrom 0 1. Hence, writing combinations binary order would produced desired property adjacent squares differing one variable. K-map also “wraps around.” squares far right effectively adjacent squares far left, differ one variable, A.In words, could take map roll cylinder, join ends cylinder form torus (i.e., donut), still guarantee adjacent squares would differ one variable. 2.7.1 Circular Thinking K-map Figure 2.43, two minterms present equation, , indicated 1’s left column. Reading minterms K-map exactly equivalent reading equations sum-of-products form directly truth table.A BC B CA BC B CPA/H11001PA/H11005P72 CHAPTER TWO Combinational Logic Design Gray codes patented (U.S. Patent 2,632,058) Frank Gray, Bell Labs researcher, 1953. especially useful mechani- cal encoders slight misalignment causes error one bit. Gray codes generalize number bits. example, 3-bit Gray code sequence is: 000, 001, 011, 010, 110, 111, 101, 100 Lewis Carroll posed related puzzle Vanity Fair 1879. “The rules Puzzle simple enough. Two words proposed, length; puzzle consists linking together interposing words, shall differ next word one letter only. say, one letter may changed one given words, one letter word obtained, on, till arrive given word.” example, SHIP DOCK: SHIP,SLIP, SLOP, SLOT, SOOT, LOOT, LOOK, LOCK, DOCK. find shorter sequence?Chapter 02.qxd 1/31/07 9:55 PM Page 72As before, use Boolean algebra minimize equations sum-of- products form. (2.6) K-maps help us simplification graphically circling 1’s adjacent squares, shown Figure 2.44. circle, write corresponding implicant. Remember Section 2.2 implicant product one literals. Variables whose true andcomplemen- tary forms circle excluded implicant. case, variable Chas true form (1) complementary form (0) circle, include implicant. words, TRUE A/H11005B/H110050, independent C.So implicant . K-map gives answer reached using Boolean algebra. 2.7.2 Logic Minimization K-Maps K-maps provide easy visual way minimize logic. Simply circle rectangular blocks 1’s map, using fewest possible number circles. circle large possible. read implicants circled. formally, recall Boolean equation minimized written sum fewest number prime implicants. circle K-map represents implicant. largest possible circles prime implicants.A /H11005A B C /H11001A BC/H11005A B(C/H11001C)/H11005A B2.7 Karnaugh Maps 73 Figure 2.43 Three-input function: (a) truth table, (b) K-map, (c) K-map showing mintermsBC 00 01 10 11A 0 0 0 0 00 01 10 111 1 1 11 1 0 0 0 0 0 0Y (a)C00 01 0 1Y 11 10AB 1 10 00 00 0 (b)C00 01 0 1Y 11 10AB ABC ABCABC ABCABC ABCABC ABC (c) C00 01 0 1Y 11 10AB 10 00 00 01 Figure 2.44 K-map minimizationChapter 02.qxd 1/31/07 9:55 PM Page 73For example, K-map Figure 2.44, implicants, notprime implicants. prime implicant K-map. Rules finding minimized equation K-map follows: /L50776Use fewest circles necessary cover 1’s. /L50776All squares circle must contain 1’s. /L50776Each circle must span rectangular block power 2 (i.e., 1, 2, 4) squares direction. /L50776Each circle large possible. /L50776A circle may wrap around edges K-map. /L50776A 1 K-map may circled multiple times allows fewer circles used. Example 2.9 MINIMIZATION THREE-VARIABLE FUNCTION USING K-MAP Suppose function Y/H11005F(A, B, C ) K-map shown Figure 2.45. Minimize equation using K-map. Solution: Circle 1’s K-map using circles possible, shown Figure 2.46. circle K-map represents prime implicant, dimen- sion circle power two (2 /H110031 2 /H110032). form prime impli- cant circle writing variables appear circle true complementary form. example, 2 /H110031 circle, true complementary forms Bare included circle, include Bin prime implicant. However, true form A(A) complementary form C circle, include variables prime implicant . Similarly, 2 /H110032 circle covers squares B/H110050, prime implicant . Notice top-right square (minterm) covered twice make prime implicant circles large possible. saw Boolean algebra techniques, equivalent sharing minterm reduce size theBAC(C)A BA BC B C74 CHAPTER TWO Combinational Logic Design Figure 2.45 K-map Example 2.900 01Y 11 10AB 1 10 01 01 10 1CChapter 02.qxd 1/31/07 9:55 PM Page 74implicant. Also notice circle covering four squares wraps around sides K-map. Example 2.10 SEVEN-SEGMENT DISPLA DECODER seven-segment display decoder takes 4-bit data input, D3:0, produces seven outputs control light-emitting diodes display digit 0 9. seven outputs often called segments athrough g,or Sa–Sg, defined Figure 2.47. digits shown Figure 2.48. Write truth table out- puts, use K-maps find Boolean equations outputs Saand Sb. Assume illegal input values (10–15) produce blank readout. Solution: truth table given Table 2.6. example, input 0000 turn segments except Sg. seven outputs independent function four variables. K-maps outputs Saand Sbare shown Figure 2.49. Remember adjacent squares may differ single variable, label rows columns Gray code order: 00, 01, 11, 10. careful also remember ordering entering output values squares. Next, circle prime implicants. Use fewest number circles necessary cover 1’s. circle wrap around edges (vertical andhorizontal), 1 may circled once. Figure 2.50 shows prime implicants simplified Boolean equations. Note minimal set prime implicants unique. example, 0000 entry SaK-map circled along 1000 entry produce minterm. circle could included 0010 entry instead, producing minterm, shown dashed lines Figure 2.51. Figure 2.52 illustrates (see page 78) common error nonprime impli- cant chosen cover 1 upper left corner. minterm, , gives sum-of-products equation notminimal. minterm could combined either adjacent ones form larger cir- cle, done previous two figures.D3D2D1D0D3D2D0D2D1D02.7 Karnaugh Maps 75 Figure 2.46 Solution Example 2.9 Figure 2.47 Seven-segment display decoder icon00 01Y 11 10AB 1 10 01 01 10 1CAC = AC + B B 477-segment display decoder b c dg efDSChapter 02.qxd 1/31/07 9:55 PM Page 7576 CHAPTER TWO Combinational Logic Design Figure 2.49 Karnaugh maps Saand Sb01 11 1 00 10 01 1 01 1 11 10 00 011 10D3:200 0010 01 11 1 11 00 01 1 01 1 11 00 00 011 1000 0010D1:0D3:2 D1:0Sa SbD3:0 Sa Sb Sc Sd Se Sf Sg 0000 1 1 1 1 1 1 0 0001 0 1 1 0 0 0 0 0010 1 1 0 1 1 0 1 0011 1 1 1 1 0 0 1 0100 0 1 1 0 0 1 1 0101 1 0 1 1 0 1 1 0110 1 0 1 1 1 1 1 0111 1 1 1 0 0 0 0 1000 1 1 1 1 1 1 1 1001 1 1 1 0 0 1 1 others 0 0 0 0 0 0 0Table 2.6 Seven-segment display decoder truth tableFigure 2.48 Seven-segment display digits 0123456789Chapter 02.qxd 1/31/07 9:55 PM Page 762.7.3 Don’t Cares Recall “don’t care” entries truth table inputs introduced Section 2.4 reduce number rows table variables affect output. indicated symbol X, means entry either 0 1. Don’t cares also appear truth table outputs output value unimportant corresponding input combination never happen. outputs treated either 0’s 1’s designer’s discretion.2.7 Karnaugh Maps 77 Figure 2.50 K-map solution Example 2.1001 11 1 00 10 01 1 01 1 11 10 00 011 1000 0010D3:2 D1:0 Sa = D3D1 + D3D2D0 + D3D2D1 + D2D1D0D3D1D3D2D0D2D1D0Sa D3D2D101 11 1 11 00 01 1 01 1 11 00 00 011 1000 0010D3:2 D1:0 Sb = D3D2 + D2D1 + D3D1D0 + D3D1D0D3D2D2D1Sb D3D1D0 D3D1D0 Figure 2.51 Alternative K-map Sashowing different set prime implicants01 11 1 00 10 01 1 01 1 11 10 00 011 1000 0010D3:2 D1:0 Sa = D3D1 + D3D2D0 + D3D2D1 + D3D2D0D3D1D3D2D0D3D2D1D3D2D0SaChapter 02.qxd 1/31/07 9:55 PM Page 77In K-map, X’s allow even logic minimization. circled help cover 1’s fewer larger circles, circled helpful. Example 2.11 SEVEN-SEGMENT DISPLA DECODER DON’T CARES Repeat Example 2.10 don’t care output values illegal input values 10 15. Solution: K-map shown Figure 2.53 X entries representing don’t care. don’t cares 0 1, circle don’t care allows us cover 1’s fewer bigger circles. Circled don’t cares treated 1’s, whereas uncircled don’t cares 0’s. Observe 2 /H110032 square wrapping around four corners circled segment Sa. Use don’t cares simplifies logic substantially. 2.7.4 Big Picture Boolean algebra Karnaugh maps two methods logic simplifi- cation. Ultimately, goal find low-cost method implementing particular logic function. modern engineering practice, computer programs called logic synthesizers produce simplified circuits description logic function, see Chapter 4. large problems, logic synthe- sizers much efficient humans. small problems, human bit experience find good solution inspection. Neither authors ever used Karnaugh map real life to78 CHAPTER TWO Combinational Logic Design 01 11 1 00 10 01 1 01 1 11 10 00 011 1000 0010D3:2 D1:0Sa D3D1D3D2D0D3D2D1D3D2D1D0 Sa = D3D1 + D3D2D0 + D3D2D1 + D3D2D1D0Figure 2.52 Alternative K-map Sashowing incorrect nonprime implicantChapter 02.qxd 1/31/07 9:55 PM Page 78solve practical problem. insight gained principles underlying Karnaugh maps valuable. Karnaugh maps often appear job interviews! 2.8 COMBINATIONAL BUILDING BLOCKS Combinational logic often grouped larger building blocks build complex systems. application principle abstraction, hiding unnecessary gate-level details emphasize function building block. already studied three building blocks: full adders (from Section 2.1), priority circuits (from Section 2.4), seven-segment display decoders (from Section 2.7). section introduces two commonly used building blocks: multiplexers decoders. Chapter 5 covers combinational building blocks. 2.8.1 Multiplexers Multiplexers among commonly used combinational cir- cuits. choose output among several possible inputs based value select signal. multiplexer sometimes affectionately called mux. 2:1 Multiplexer Figure 2.54 shows schematic truth table 2:1 multiplexer two data inputs, D0and D1, select input, S,and one output, Y. multiplexer chooses two data inputs based select: S/H110050, Y/H11005D0, S/H110051, Y/H11005D1. Sis also called control signal controls multiplexer does.2.8 Combinational Building Blocks 79 Figure 2.53 K-map solution don’t cares01 11 1 00 1X X1 1 01 1 11 1X XX X11 1000 0010 01 11 1 11 0X X1 1 01 1 11 0X XX X11 1000 0010D3:2 D1:0SaD3:2 D1:0Sb Sb = D3 + D3D2 + D1D0 + D1D0 Sa = D1 + D3 + D2D0 + D2D0 Figure 2.54 2:1 multiplexer symbol truth tableY 00 01 10 110 1 0 10 0 0 0 00 01 10 111 1 1 10 0 1 10 1S D0 D1 D1D0 SChapter 02.qxd 1/31/07 9:55 PM Page 79A 2:1 multiplexer built sum-of-products logic shown Figure 2.55. Boolean equation multiplexer may derived Karnaugh map read inspection ( Yis 1 S/H110050 D0 1 S/H110051 D1is 1). Alternatively, multiplexers built tristate buffers, shown Figure 2.56. tristate enables arranged that, times, exactly one tristate buffer active. S/H110050, tristate T0 enabled, allowing D0to flow Y.When S/H110051, tristate T1 enabled, allowing D1to flow Y. Wider Multiplexers 4:1 multiplexer four data inputs one output, shown Figure 2.57. Two select signals needed choose among four data inputs. 4:1 multiplexer built using sum-of-products logic, tristates, multiple 2:1 multiplexers, shown Figure 2.58. product terms enabling tristates formed using gates inverters. also formed using decoder, introduce Section 2.8.2. Wider multiplexers, 8:1 16:1 multiplexers, built expanding methods shown Figure 2.58. general, N:1 multiplexer needs log 2Nselect lines. Again, best implementation choice depends target technology. Multiplexer Logic Multiplexers used lookup tables perform logic functions. Figure 2.59 shows 4:1 multiplexer used implement two-input80 CHAPTER TWO Combinational Logic Design D1 YD0 SS00 01 0 1Y 11 10D1:0 0 01 01 10 1 = D0S + D1SFigure 2.55 2:1 multiplexer implementation using two-level logic Figure 2.56 Multiplexer using tristate buffers Figure 2.57 4:1 multiplexerYD0S T0 T1 = D0S + D1SD1 00S1:0 D0 D1Y01 10 11D2 D32Shorting together outputs multiple gates technically violates rules combina- tional circuits given Section 2.1. exactly one outputs driven time, exception allowed.Chapter 02.qxd 1/31/07 9:55 PM Page 80AND gate. inputs, Aand B,serve select lines. multiplexer data inputs connected 0 1 according corresponding row truth table. general, 2N-input multiplexer pro- grammed perform N-input logic function applying 0’s 1’s appropriate data inputs. Indeed, changing data inputs, multiplexer reprogrammed perform different function. little cleverness, cut multiplexer size half, using 2N/H110021-input multiplexer perform N-input logic function. strategy provide one literals, well 0’s 1’s, multiplexer data inputs. illustrate principle, Figure 2.60 shows two-input XOR functions implemented 2:1 multiplexers. start ordinary truth table, combine pairs rows eliminate rightmost input variable expressing output terms variable. example, case AND, A/H110050, Y/H110050, regard- less B.When A/H110051, Y/H110050 B/H110050 Y/H110051 B/H110051, Y/H11005B. use multiplexer lookup table according new, smaller truth table. Example 2.12 LOGIC MULTIPLEXERS Alyssa P. Hacker needs implement function fin- ish senior project, looks lab kit, part left 8:1 multiplexer. implement function? Solution: Figure 2.61 shows Alyssa’s implementation using single 8:1 multi- plexer. multiplexer acts lookup table row truth table corresponds multiplexer input.Y/H11005AB/H11001B C/H11001ABC2.8 Combinational Building Blocks 81 Figure 2.58 4:1 multiplexer implementations: (a) two- level logic, (b) tristates, (c) hierarchical (a)YD0 D1 D2 D3 (b) (c)S0 0 10 10 1S1 D0 D1 D2 D3YS1S0 S1S0 S1S0 S1S0D0 D2 D3D1S1S0 ABY 000 010 100 11 1 = AB 00 Y01 10 11AB Figure 2.59 4:1 multiplexer implementation two-input functionChapter 02.qxd 1/31/07 9:55 PM Page 81Example 2.13 LOGIC MULTIPLEXERS, REPRISED Alyssa turns circuit one time final presentation blows 8:1 multiplexer. (She accidently powered 20 V instead 5 V sleeping night.) begs friends spare parts give 4:1 multiplexer inverter. build circuit parts? Solution: Alyssa reduces truth table four rows letting output depend C.(She could also chosen rearrange columns truth table let output depend Aor B.) Figure 2.62 shows new design. 2.8.2 Decoders decoder Ninputs 2Noutputs. asserts exactly one outputs depending input combination. Figure 2.63 shows 2:4 decoder. A1:0/H1100500, Y0is 1. A1:0/H1100501, Y1is 1. forth. outputs called one-hot, exactly one “hot” (HIGH) given time.82 CHAPTER TWO Combinational Logic Design Figure 2.61 Alyssa’s circuit: (a) truth table, (b) 8:1 multiplexer implementationAB 00 1 010 100 11 10 0 0 0 00 01 10 111 1 1 11 1 0 0C (a)Y = AB + BC + ABCC AB (b)000 001 010 011 100 101 110 111YFigure 2.60 Multiplexer logic using variable inputs ABY 000 011 101 110AY 0 1A 1 = ⊕ BB0 B (b)ABY 000 010 100 111Y = AB AY 00 0 1A 1 B (a)Chapter 02.qxd 1/31/07 9:55 PM Page 82Example 2.14 DECODER IMPLEMENTATION Implement 2:4 decoder AND, OR, gates. Solution: Figure 2.64 shows implementation 2:4 decoder using four gates. gate depends either true complementary form input. general, N:2Ndecoder constructed 2NN-input gates accept various combinations true complementary inputs. output decoder represents single minterm. example, Y0represents minterm . fact handy using decoders digital building blocks.A1A0 Decoder Logic Decoders combined gates build logic functions. Figure 2.65 shows two-input XNOR function using 2:4 decoder single gate. output decoder represents single minterm, function built minterms function. Figure 2.65, . Y/H11005A B/H11001AB/H11005A/H17053B 2.8 Combinational Building Blocks 83 AB 001 010 100 1110 0 0 0 00 01 10 111 1 1 11 1 0 0C (a)AY 00 01 101 110B C C 00 Y01 10 11AB C (b) (c)Figure 2.62 Alyssa’s new circuit Figure 2.63 2:4 decoder2:4 Decoder A1 A0Y3 Y2 Y1 Y0 00011011 00 01 10 110 0 0 1Y3Y2Y1Y0 A0 A1 0 0 1 00 1 0 01 0 0 0 Figure 2.64 2:4 decoder implementationA1 A0 Y3 Y2 Y1 Y0 Figure 2.65 Logic function using decoder2:4 Decoder B 00011011 = B YAB AB AB ABMinterm ⊕Chapter 02.qxd 1/31/07 9:55 PM Page 83When using decoders build logic, easiest express functions truth table canonical sum-of-products form. N-input func- tion M1’s truth table built N:2Ndecoder M-input gate attached minterms containing 1’s truth table. concept applied building Read Memories (ROMs) Section 5.5.6. 2.9 TIMING previous sections, concerned primarily whether circuit works—ideally, using fewest gates. However, seasoned circuit designer attest, one challenging issues circuit design timing: making circuit run fast. output takes time change response input change. Figure 2.66 shows delay input change subsequent output change buffer. figure called timing diagram; portrays transient response buffer circuit input changes. transition LOW HIGH called rising edge. Similarly, transition HIGH LOW (not shown figure) called falling edge. blue arrow indicates rising edge Yis caused rising edge A.We measure delay 50% point input signal, A,to 50% point output signal, Y.The 50% point point signal half-way (50%) LOW HIGH values transitions. 2.9.1 Propagation Contamination Delay Combinational logic characterized propagation delay contamination delay. propagation delay, tpd, maximum time input changes output outputs reach final value. contamination delay, tcd, minimum time input changes output starts change value.84 CHAPTER TWO Combinational Logic Design Figure 2.66 Circuit delayA TimedelayAYWhen designers speak cal- culating delay circuit, generally referring worst-case value (the propagation delay), unless clear otherwise context.Chapter 02.qxd 1/31/07 9:55 PM Page 84Figure 2.67 illustrates buffer’s propagation delay contami- nation delay blue gray, respectively. figure shows Ais initially either HIGH LOW changes state par- ticular time; interested fact changes, value has. response, Ychanges time later. arcs indicate Ymay start change tcdafter Atransitions definitely settles new value within tpd. underlying causes delay circuits include time required charge capacitance circuit speed light. tpdand tcd may different many reasons, including /L50776different rising falling delays /L50776multiple inputs outputs, faster others /L50776circuits slowing hot speeding cold Calculating tpdand tcdrequires delving lower levels abstraction beyond scope book. However, manufacturers nor- mally supply data sheets specifying delays gate. Along factors already listed, propagation contamina- tion delays also determined path signal takes input output. Figure 2.68 shows four-input logic circuit. critical path, shown blue, path input Aor Bto output Y.It longest, therefore slowest, path, input travels2.9 Timing 85 Figure 2.67 Propagation contamination delayAY Timetpd tcd B C DYCritical Path Short Pathn1 n2 Figure 2.68 Short path critical pathCircuit delays ordinarily order picoseconds (1 ps /H1100510/H1100212seconds) nanoseconds (1 ns /H1100510/H110029 seconds). Trillions picosec- onds elapsed time spent reading sidebar.Chapter 02.qxd 1/31/07 9:55 PM Page 85through three gates output. path critical limits speed circuit operates. short path cir- cuit, shown gray, input Dto output Y.This shortest, therefore fastest, path circuit, input travels single gate output. propagation delay combinational circuit sum propagation delays element critical path. contamination delay sum contamination delays element short path. delays illustrated Figure 2.69 described following equations: (2.7) (2.8) Example 2.15 FINDING DELA YS Ben Bitdiddle needs find propagation delay contamination delay circuit shown Figure 2.70. According data book, gate propagation delay 100 picoseconds (ps) contamination delay 60 ps. Solution: Ben begins finding critical path shortest path circuit. critical path, highlighted blue Figure 2.71, input Atcd/H11005tcd/H11002ANDtpd/H110052tpd/H11002AND /H11001tpd/H11002OR86 CHAPTER TWO Combinational Logic Design A= 1 0 = 1 0 YdelayTimeA Ydelay A= 1 B= 1 C= 0 D= 1 0Y= 1 0Short PathCritical Path Timen1 n2 n1 n2n1 n2B= 1 C= 0 D= 1 Figure 2.69 Critical short path waveforms Although ignoring wire delay analysis, digital circuits fast delay long wires important delay gates. speed light delay wires covered Appendix A.Chapter 02.qxd 1/31/07 9:55 PM Page 86or Bthrough three gates output, Y.Hence, tpdis three times propaga- tion delay single gate, 300 ps. shortest path, shown gray Figure 2.72, input C, D, E two gates output, Y.There two gates shortest path, tcdis 120 ps. Example 2.16 MULTIPLEXER TIMING: CONTROL-CRITICAL VS. DATA-CRITICAL Compare worst-case timing three four-input multiplexer designs shown Figure 2.58 Section 2.8.1. Table 2.7 lists propagation delays components. critical path design? Given timing analysis, might choose one design other? Solution: One critical paths three design options highlighted blue Figures 2.73 2.74. tpd_sy indicates propagation delay input Sto output Y; pd_dy indicates propagation delay input Dto output Y; tpdis worst two: max( tpd_sy, tpd_dy). two-level logic tristate implementations Figure 2.73, critical path one control signals, S,to output, Y: tpd/H11005tpd_sy. circuits control critical, critical path control signals output. additional delay control signals add directly worst-case delay. delay Dto Yin Figure 2.73(b) 50 ps, compared delay Sto Yof 125 ps.2.9 Timing 87 B C EY Figure 2.70 Ben’s circuit Figure 2.71 Ben’s critical pathA B C EY Figure 2.72 Ben’s shortest pathA B C EYChapter 02.qxd 1/31/07 9:55 PM Page 87Figure 2.74 shows hierarchical implementation 4:1 multiplexer using two stages 2:1 multiplexers. critical path Dinputs output. circuit data critical, critical path data input output: ( tpd/H11005tpd_dy). data inputs arrive well control inputs, would prefer design shortest control-to-output delay (the hierarchical design Figure 2.74). Similarly, control inputs arrive well data inputs, would prefer design shortest data-to-output delay (the tristate design Figure 2.73(b)). best choice depends critical path circuit input arrival times, also power, cost, availability parts. 2.9.2 Glitches far discussed case single input transition causes single output transition. However, possible single input transi- tion cause multiple output transitions. called glitches hazards. Although glitches usually don’t cause problems, important realize exist recognize looking timing dia- grams. Figure 2.75 shows circuit glitch Karnaugh map circuit. Boolean equation correctly minimized, let’s look happens A/H110050, C/H110051, Btransitions 1 0. Figure 2.76 (see page 90) illustrates scenario. short path (shown gray) goes two gates, gates. critical path (shown blue) goes inverter two gates, gates.88 CHAPTER TWO Combinational Logic Design Gate tpd(ps) 30 2-input 60 3-input 80 4-input 90 tristate ( Ato Y)5 0 tristate (enable Y)3 5Table 2.7 Timing specifications multiplexer circuit elements Hazards another mean- ing related microarchitec- ture Chapter 7, stick term glitches multiple output transitions avoid confusion.Chapter 02.qxd 1/31/07 9:55 PM Page 882.9 Timing 89 Figure 2.73 4:1 multiplexer propagation delays: (a) two-level logic, (b) tristate tpd_sy = tpd_INV + tpd_AND3 + tpd_OR4 = 30 ps + 80 ps + 90 ps = 200 ps S1 D0 D1 D2 D3 OutS0 (a) tpd_dy = tpd_AND3 + tpd_OR4 = 170 ps D2 D3OutS1S0 tpd_sy = tpd_INV + tpd_AND2 + tpd_TRI_SY = 30 ps + 60 ps + 35 ps = 125 ps(b) tpd_dy = tpd_TRI_AY = 50 psD0 D1 S0 D0 D1 D2 D3S1 pd_s0y = pd_TRLSY + pd_TRI_AY = 85 ns2:1 mux 2:1 mux2:1 mux pd_dy = 2 pd_TRI_AY = 100 ns Figure 2.74 4:1 multiplexer propagation delays: hierarchical using 2:1 multiplexers Btransitions 1 0, n2 (on short path) falls n1 (on critical path) rise. n1 rises, two inputs gate 0, output Ydrops 0. n1 eventually rises, returns 1. shown timing diagram Figure 2.76, Ystarts 1 ends 1 momentarily glitches 0.A B CY 00 01 1Y 11 10AB 1 10 10 10 0C 0 = AB + BC Figure 2.75 Circuit glitchChapter 02.qxd 1/31/07 9:55 PM Page 8990 CHAPTER TWO Combinational Logic Design Figure 2.77 Input change crosses implicant boundary00 01 1Y 11 10AB 1 10 10 10 0C 0 = AB + BCFigure 2.76 Timing glitchA = 0 C = 1B = 1 0 = 101 Short PathCritical Path B Time1 00 1 glitchn1 n2 n2 n1 long wait propagation delay elapse depend output, glitches problem, output eventually settles right answer. choose to, avoid glitch adding another gate implementation. easiest understand terms K-map. Figure 2.77 shows input transition Bfrom ABC /H11005001 ABC /H11005011 moves one prime implicant circle another. tran- sition across boundary two prime implicants K-map indicates possible glitch. saw timing diagram Figure 2.76, circuitry implementing one prime implicants turns offbefore circuitry prime implicant turn on,there glitch. fix this, add another circle covers prime implicant boundary, shown Figure 2.78. might recognize consensus theorem, added term, , consensus redundant term.A CChapter 02.qxd 1/31/07 9:55 PM Page 902.10 Summary 91 00 01 1Y 11 10AB 1 10 10 10 0C 0 = AB + BC + AC AC B = 1 0 = 1A = 0 C = 1Figure 2.78 K-map without glitch Figure 2.79 Circuit without glitch Figure 2.79 shows glitch-proof circuit. added gate highlighted blue. transition Bwhen A/H110050 C/H110051 cause glitch output, blue gate outputs 1 throughout transition. general, glitch occur change single variable crosses boundary two prime implicants K-map. eliminate glitch adding redundant implicants K-map cover boundaries. course comes cost extra hardware. However, simultaneous transitions multiple variables also cause glitches. glitches cannot fixed adding hardware. vast majority interesting systems simultaneous (or near-simultaneous) transitions multiple variables, glitches fact life circuits. Although shown eliminate one kind glitch, point discussing glitches eliminate aware exist. especially important look- ing timing diagrams simulator oscilloscope. 2.10 SUMMARY digital circuit module discrete-valued inputs outputs specification describing function timing module. chapter focused combinational circuits, circuits whose outputs depend current values inputs.Chapter 02.qxd 1/31/07 9:55 PM Page 91The function combinational circuit given truth table Boolean equation. Boolean equation truth table obtained systematically using sum-of-products product-of- sums form. sum-of-products form, function written sum (OR) one implicants. Implicants product (AND) literals. Literals true complementary forms input variables. Boolean equations simplified using rules Boolean alge- bra. particular, simplified minimal sum-of-products form combining implicants differ true comple- mentary forms one literals: . Karnaugh maps visual tool minimizing functions four variables. prac- tice, designers usually simplify functions variables inspection. Computer-aided design tools used complicated functions; methods tools discussed Chapter 4. Logic gates connected create combinational circuits per- form desired function. function sum-of-products form built using two-level logic literals inputs: gates form complementary literals, gates form products, gates form sum. Depending function building blocks avail- able, multilevel logic implementations various types gates may efficient. example, CMOS circuits favor NAND gates gates built directly CMOS transistors without requiring extra gates. using NAND gates, bubble pushing helpful keep track inversions. Logic gates combined produce larger circuits multiplex- ers, decoders, priority circuits. multiplexer chooses one data inputs based select input. decoder sets one outputs HIGH according input. priority circuit produces output indicating highest priority input. circuits examples combinational building blocks. Chapter 5 introduce building blocks, including arithmetic circuits. building blocks used extensively build microprocessor Chapter 7. timing specification combinational circuit consists propagation contamination delays circuit. indi- cate longest shortest times input change consequent output change. Calculating propagation delay circuit involves identifying critical path circuit, adding propagation delays element along path. many different ways implement complicated combinational circuits; ways offer trade-offs speed cost. next chapter move sequential circuits, whose outputs depend previous well current values inputs. words, sequential circuits memory past.PA/H11001PA/H11005P92 CHAPTER TWO Combinational Logic DesignChapter 02.qxd 1/31/07 9:55 PM Page 92Exercises 93 Exercises Exercise 2.1 Write Boolean equation sum-of-products canonical form truth tables Figure 2.80. Exercise 2.2 Write Boolean equation product-of-sums canonical form truth tables Figure 2.80. Exercise 2.3 Minimize Boolean equations Exercise 2.1. Exercise 2.4 Sketch reasonably simple combinational circuit implementing functions Exercise 2.3. Reasonably simple means wasteful gates, don’t waste vast amounts time checking every possible implementation circuit either. Exercise 2.5 Repeat Exercise 2.4 using gates gates. Exercise 2.6 Repeat Exercise 2.4 using gates NAND gates. Exercise 2.7 Simplify following Boolean equations using Boolean theorems. Check correctness using truth table K-map. (a) (b) (c)Y/H11005A B C D/H11001AB C/H11001ABCD/H11001ABD /H11001A BCD/H11001BCD/H11001AY/H11005A B/H11001A B C/H11001(A/H11001C)Y/H11005AC/H11001A BCBCY 00 01 10 111 0 1 0A 0 0 0 0 00 01 10 111 1 1 11 1 0 1BCY 00 01 10 111 0 0 0A 0 0 0 0 00 01 10 111 1 1 10 0 0 1ABY 00 01 10 111 0 1 1CDY 00 01 10 111 1 1 1B 0 0 0 0 00 01 10 111 1 1 10 0 0 0A 00 01 10 110 0 0 0 00 01 10 111 1 1 10 0 0 0 0 0 0 0 1 1 1 1 1 1 1 11 0 1 0 0 0 1 0CDY 00 01 10 111 0 0 1B 0 0 0 0 00 01 10 111 1 1 10 1 1 0A 00 01 10 110 0 0 0 00 01 10 111 1 1 10 0 0 0 0 0 0 0 1 1 1 1 1 1 1 10 1 1 0 1 0 0 1(a) (b) (c) (d) (e) Figure 2.80 Truth tablesChapter 02.qxd 1/31/07 9:55 PM Page 9394 CHAPTER TWO Combinational Logic Design Exercise 2.8 Sketch reasonably simple combinational circuit implementing functions Exercise 2.7. Exercise 2.9 Simplify following Boolean equations. Sketch reason- ably simple combinational circuit implementing simplified equation. (a) (b) (c)Y/H11005ABC /H11001ABD /H11001ABE /H11001ACD /H11001ACE /H11001/H11001 /H11001/H11001 /H11001 Exercise 2.10 Give example truth table requiring 3 billion 5 billion rows constructed using fewer 40 (but least 1) two-input gates. Exercise 2.11 Give example circuit cyclic path nevertheless combinational. Exercise 2.12 Alyssa P. Hacker says Boolean function written minimal sum-of-products form sum prime implicants function. Ben Bitdiddle says functions whose minimal equa- tion involve prime implicants. Explain Alyssa right provide counterexample demonstrating Ben’s point. Exercise 2.13 Prove following theorems true using perfect induction. need prove duals. (a) idempotency theorem (T3) (b) distributivity theorem (T8) (c) combining theorem (T10) Exercise 2.14 Prove De Morgan’s Theorem (T12) three variables, B 2, B1, B0, using perfect induction. Exercise 2.15 Write Boolean equations circuit Figure 2.81. need minimize equations.C E B E B CEB C (A/H11001D/H11001E)Y/H11005A/H11001A B/H11001A B /H11001A/H11001BY/H11005BC/H11001A B C/H11001BCChapter 02.qxd 1/31/07 9:55 PM Page 94Exercises 95 Exercise 2.16 Minimize Boolean equations Exercise 2.15 sketch improved circuit function. Exercise 2.17 Using De Morgan equivalent gates bubble pushing methods, redraw circuit Figure 2.82 find Boolean equation inspection. Write Boolean equation. Exercise 2.18 Repeat Exercise 2.17 circuit Figure 2.83.A B C YZ B C EYFigure 2.81 Circuit schematic Figure 2.82 Circuit schematicChapter 02.qxd 1/31/07 9:55 PM Page 9596 CHAPTER TWO Combinational Logic Design Exercise 2.19 Find minimal Boolean equation function Figure 2.84. Remember take advantage don’t care entries. Exercise 2.20 Sketch circuit function Exercise 2.19. Exercise 2.21 circuit Exercise 2.20 potential glitches one inputs changes? not, explain not. so, show modify circuit eliminate glitches. Exercise 2.22 Ben Bitdiddle enjoy picnic sunny days ants. also enjoy picnic day sees hummingbird, well days ants ladybugs. Write Boolean equation enjoy- ment ( E) terms sun ( S), ants ( A), hummingbirds ( H), ladybugs ( L).CDY 00X 01X 10X 110B 00 01 10 110 X 0 X0 0 0 0 1 1 1 1A 0 0 0 0 0 0 0 0 001 010 10X 111 00 01 10 111 1 X 10 0 0 0 1 1 1 11 1 1 1 1 1 1 1 Figure 2.84 Truth tableA B C E F GY Figure 2.83 Circuit schematicChapter 02.qxd 1/31/07 9:55 PM Page 96Exercises 97 Exercise 2.23 Complete design seven-segment decoder segments Sc Sg(see Example 2.10): (a) Derive Boolean equations outputs Scthrough Sgassuming inputs greater 9 must produce blank (0) outputs. (b) Derive Boolean equations outputs Scthrough Sgassuming inputs greater 9 don’t cares. (c) Sketch reasonably simple gate-level implementation part (b). Multiple outputs share gates appropriate. Exercise 2.24 circuit four inputs two outputs. inputs, A3:0, repre- sent number 0 15. Output Pshould TRUE number prime (0 1 prime, 2, 3, 5, on, prime). Output Dshould TRUE number divisible 3. Give simplified Boolean equations output sketch circuit. Exercise 2.25 priority encoder 2Ninputs. produces N-bit binary out- put indicating significant bit input TRUE, 0 none inputs TRUE. also produces output NONE TRUE none input bits TRUE. Design eight-input priority encoder inputs A7:0 outputs Y2:0and NONE . example, input 00100000, output Yshould 101 NONE 0. Give simplified Boolean equation output, sketch schematic. Exercise 2.26 Design modified priority encoder (see Exercise 2.25) receives 8-bit input, A7:0, produces two 3-bit outputs, Y2:0and Z2:0. Yindicates significant bit input TRUE. Zindicates second significant bit input TRUE. Yshould 0 none inputs TRUE. Zshould 0 one inputs TRUE. Give simplified Boolean equation output, sketch schematic. Exercise 2.27 M-bit thermometer code number kconsists k1’s least significant bit positions M/H11002k0’s significant bit positions. binary-to-thermometer code converter Ninputs 2N/H110021 outputs. produces 2N/H110021 bit thermometer code number specified input. example, input 110, output 0111111. Design 3:7 binary-to-thermometer code converter. Give simplified Boolean equation output, sketch schematic. Exercise 2.28 Write minimized Boolean equation function performed circuit Figure 2.85.Chapter 02.qxd 1/31/07 9:55 PM Page 9798 CHAPTER TWO Combinational Logic Design Exercise 2.30 Implement function Figure 2.80(b) using (a) 8:1 multiplexer (b) 4:1 multiplexer one inverter (c) 2:1 multiplexer two logic gates Exercise 2.31 Implement function Exercise 2.9(a) using (a) 8:1 multiplexer (b) 4:1 multiplexer gates (c) 2:1 multiplexer, one gate, inverter Exercise 2.32 Determine propagation delay contamination delay circuit Figure 2.83. Use gate delays given Table 2.8.Exercise 2.29 Write minimized Boolean equation function performed circuit Figure 2.86.Figure 2.85 Multiplexer circuit0 100C, 01 10 11A Figure 2.86 Multiplexer circuit00C, 01 10 11Y00A, B 01 10 11Chapter 02.qxd 1/31/07 9:55 PM Page 98Exercises 99 Exercise 2.33 Sketch schematic fast 3:8 decoder. Suppose gate delays given Table 2.8 (and gates table available). Design decoder shortest possible critical path, indicate path is. propagation delay contamination delay? Exercise 2.34 Redesign circuit Exercise 2.24 fast possible. Use gates Table 2.8. Sketch new circuit indicate critical path. propagation delay contamination delay? Exercise 2.35 Redesign priority encoder Exercise 2.25 fast possible. may use gates Table 2.8. Sketch new circuit indicate critical path. propagation delay contamination delay? Exercise 2.36 Design 8:1 multiplexer shortest possible delay data inputs output. may use gates Table 2.7 page 88. Sketch schematic. Using gate delays table, determine delay.Gate tpd(ps) tcd(ps) 15 10 2-input NAND 20 15 3-input NAND 30 25 2-input 30 25 3-input 45 35 2-input 30 25 3-input 40 30 2-input 40 30 3-input 55 45 2-input XOR 60 40Table 2.8 Gate delays Exercises 2.32–2.35Chapter 02.qxd 1/31/07 9:55 PM Page 99100 CHAPTER TWO Combinational Logic Design Interview Questions following exercises present questions asked interviews digital design jobs. Question 2.1 Sketch schematic two-input XOR function using NAND gates. use? Question 2.2 Design circuit tell whether given month 31 days it. month specified 4-bit input, A3:0. example, inputs 0001, month January, inputs 1100, month December. circuit output, Y, HIGH month speci- fied inputs 31 days it. Write simplified equation, draw circuit diagram using minimum number gates. (Hint: Remember take advantage don’t cares.) Question 2.3 tristate buffer? used? Question 2.4 gate set gates universal used construct Boolean function. example, set {AND, OR, NOT} universal. (a) gate universal? not? (b) set {OR, NOT} universal? not? (c) NAND gate universal? not? Question 2.5 Explain circuit’s contamination delay might less (instead equal to) propagation delay.Chapter 02.qxd 1/31/07 9:55 PM Page 1003 3.1 Introduction 3.2 Latches Flip-Flops 3.3 Synchronous Logic Design 3.4 Finite State Machines 3.5 Timing Sequential Logic 3.6 Parallelism 3.7 Summary Exercises Interview QuestionsSequential Logic Design 3.1 INTRODUCTION last chapter, showed analyze design combinational logic. output combinational logic depends current input values. Given specification form truth table Boolean equation, create optimized circuit meet specification. chapter, analyze design sequential logic. out- puts sequential logic depend current prior input values. Hence, sequential logic memory. Sequential logic might explicitly remember certain previous inputs, might distill prior inputs smaller amount information called state system. state digital sequential circuit set bits called state variables contain information past necessary explain future behavior circuit. chapter begins studying latches flip-flops, simple sequential circuits store one bit state. general, sequential circuits complicated analyze. simplify design, discipline build synchronous sequential circuits consisting com- binational logic banks flip-flops containing state circuit. chapter describes finite state machines, easy way design sequential circuits. Finally, analyze speed sequential circuits discuss parallelism way increase clock speed. 3.2 LATCHES FLIP-FLOPS fundamental building block memory bistable element, element two stable states. Figure 3.1(a) shows simple bistable element consisting pair inverters connected loop. Figure 3.1(b) shows circuit redrawn emphasize symmetry. inverters cross-coupled, meaning input I1 output I2 vice versa. circuit inputs, two outputs, 103Chapter 03.qxd 1/27/07 10:24 Page 103Qand . Analyzing circuit different analyzing combina- tional circuit cyclic: Qdepends , depends Q. Consider two cases, Qis 0 Qis 1. Working consequences case, have: /L50776Case I: Q /H110050 shown Figure 3.2(a), I2 receives FALSE input, Q,so pro- duces TRUE output . I1 receives TRUE input, , produces FALSE output Q.This consistent original assumption Q/H110050, case said stable. /L50776Case II: Q /H110051 shown Figure 3.2(b), I2 receives TRUE input produces FALSE output . I1 receives FALSE input produces TRUE output Q.This stable. cross-coupled inverters two stable states, Q/H110050 Q/H110051, circuit said bistable. subtle point circuit third possible state outputs approximately halfway 0 1. called metastable state discussed Section 3.5.4. element Nstable states conveys log 2Nbits information, bistable element stores one bit. state cross-coupled inverters contained one binary state variable, Q.The value Q tells us everything past necessary explain future behavior circuit. Specifically, Q/H110050, remain 0 forever, Q/H110051, remain 1 forever. circuit another node, , contain additional information Qis known, also known. hand, also accept- able choice state variable.Q QQ QQQ QQ QQ104 CHAPTER THREE Sequential Logic Design (b)Q QI1 I2Q Q (a)I2 I1Figure 3.1 Cross-coupled inverter pair (b)Q QI1 I21 00 1 (a)Q I1 I20 1Q1 0Figure 3.2 Bistable operation cross-coupled invertersJust Yis commonly used output combina- tional logic, Qis commonly used output sequen- tial logic.Chapter 03.qxd 1/27/07 10:24 Page 104When power first applied sequential circuit, initial state unknown usually unpredictable. may differ time circuit turned on. Although cross-coupled inverters store bit information, practical user inputs control state. However, bistable elements, latches flip-flops, provide inputs control value state variable. remainder section considers circuits. 3.2.1 SR Latch One simplest sequential circuits SR latch, composed two cross-coupled gates, shown Figure 3.3. latch two inputs, Sand R,and two outputs, Qand . SR latch similar cross-coupled inverters, state controlled Sand Rinputs, setand reset output Q. good way understand unfamiliar circuit work truth table, begin. Recall gate produces FALSE output either input TRUE. Consider four possible combinations Rand S. /L50776Case I: R /H110051, S/H110050 N1 sees least one TRUE input, R,so produces FALSE output Q.N2 sees Qand SFALSE, produces TRUE output . /L50776Case II: R /H110050, S/H110051 N1 receives inputs 0 . don’t yet know , can’t determine output Q.N2 receives least one TRUE input, S,so produces FALSE output . revisit N1, knowing inputs FALSE, output Qis TRUE. /L50776Case III: R /H110051, S/H110051 N1 N2 see least one TRUE input ( Ror S), produces FALSE output. Hence Qand FALSE. /L50776Case IV: R /H110050, S/H110050 N1 receives inputs 0 . don’t yet know , can’t determine output. N2 receives inputs 0 Q.Because don’t yet know Q,we can’t determine output. stuck. reminiscent cross-coupled inverters. know Qmust either 0 1. solve problem checking happens subcases.Q QQQQ QQQ3.2 Latches Flip-Flops 105 R SQ N1 N2 Q Figure 3.3 SR latch schematicChapter 03.qxd 1/27/07 10:24 Page 105/L50776Case IVa: Q /H110050 Sand Qare FALSE, N2 produces TRUE output , shown Figure 3.4(a). N1 receives one TRUE input, , output, Q,is FALSE, assumed. /L50776Case IVb: Q /H110051 Qis TRUE, N2 produces FALSE output , shown Figure 3.4(b). N1 receives two FALSE inputs, Rand , output, Q,is TRUE, assumed. Putting together, suppose Qhas known prior value, call Qprev, enter Case IV. Qprevis either 0 1, represents state system. Rand Sare 0, Qwill remember old value, Qprev, complement, . circuit memory. truth table Figure 3.5 summarizes four cases. inputs Sand Rstand Setand Reset. seta bit means make TRUE. reset bit means make FALSE. outputs, Qand , normally complementary. Ris asserted, Qis reset 0 opposite. Sis asserted, Qis set 1 opposite. neither input asserted, Qremembers old value, Qprev. Asserting Sand Rsimultaneously doesn’t make much sense means latch set reset time, impossible. poor confused circuit responds making outputs 0. SR latch represented symbol Figure 3.6. Using symbol application abstraction modularity. vari- ous ways build SR latch, using different logic gates tran- sistors. Nevertheless, circuit element relationship specified truth table Figure 3.5 symbol Figure 3.6 called SR latch. Like cross-coupled inverters, SR latch bistable element one bit state stored Q.However, state controlled Sand Rinputs. Ris asserted, state reset 0. Sis asserted, state set 1. neither asserted, state retains old value. Notice entire history inputs beQQQQprev QQQQQ106 CHAPTER THREE Sequential Logic Design R SQ N1 N20 0 (b)1 010 QR SQ N1 N20 0 (a)0 101 QFigure 3.4 Bistable states SR latch SRQ 00 Qprev 010 101 1101 0 0Case IV II IIIQ Qprev Figure 3.5 SR latch truth table SR Q Q Figure 3.6 SR latch symbolChapter 03.qxd 1/27/07 10:24 Page 106accounted single state variable Q.No matter pattern setting resetting occurred past, needed predict future behavior SR latch whether recently set reset. 3.2.2 Latch SR latch awkward behaves strangely Sand Rare simultaneously asserted. Moreover, Sand Rinputs conflate issues when. Asserting one inputs determines state also change. Designing circuits becomes easier questions separated. latch Figure 3.7(a) solves problems. two inputs. data input, D,controls next state be. clock input, CLK, controls state change. Again, analyze latch writing truth table, given Figure 3.7(b). convenience, first consider internal nodes , S, R.If CLK /H110050, Sand Rare FALSE, regardless value ofD.If CLK /H110051, one gate produce TRUE FALSE, depending value D.Given Sand R, Q deter- mined using Figure 3.5. Observe CLK /H110050, Qremembers old value, Qprev. CLK /H110051, Q/H11005D.In cases, comple- ment Q,as would seem logical. latch avoids strange case simultaneously asserted Rand Sinputs. Putting together, see clock controls data flows latch. CLK /H110051, latch transparent. data Dflows Qas latch buffer. CLK /H110050, latch opaque. blocks new data flowing Q,and Qretains old value. Hence, latch some- times called transparent latch level-sensitive latch. latch symbol given Figure 3.7(c). latch updates state continuously CLK /H110051. shall see later chapter useful update state spe- cific instant time. flip-flop described next section that.QQD3.2 Latches Flip-Flops 107 SRQ Q DCLK DR (a)QQCLK DQ (c)QSR Q 00 Qprev 01 0 10 11 0CLK 0X 10 11D X 1 0 (b)QprevQ Figure 3.7 latch: (a) schematic, (b) truth table, (c) symbolSome people call latch open closed rather trans- parent opaque. However, think terms ambiguous—does open mean transparent like open door, opaque, like open circuit?Chapter 03.qxd 1/27/07 10:24 Page 1073.2.3 Flip-Flop flip-flop built two back-to-back latches controlled complementary clocks, shown Figure 3.8(a). first latch, L1, called master. second latch, L2, called slave. node named N1. symbol flip-flop given Figure 3.8(b). output needed, symbol often condensed Figure 3.8(c). CLK /H110050, master latch transparent slave opaque. Therefore, whatever value Dpropagates N1. CLK /H110051, master goes opaque slave becomes trans- parent. value N1 propagates Q,but N1 cut D.Hence, whatever value Dimmediately clock rises 0 1 gets copied Qimmediately clock rises. times, Qretains old value, always opaque latch blocking path Dand Q. words, flip-flop copies Q rising edge clock, remembers state times. Reread definition memorized; one common problems beginning digital designers forget flip-flop does. rising edge clock often called clock edge brevity. input specifies new state be. clock edge indicates state updated. flip-flop also known master-slave flip-flop, edge-triggered flip-flop, positive edge-triggered flip-flop. triangle symbols denotes edge-triggered clock input. output often omitted needed. Example 3.1 FLIP-FLOP TRANSISTOR COUNT many transistors needed build flip-flop described section? Solution: NAND gate uses four transistors. gate uses two transistors. gate built NAND NOT, uses six transistors. SR latch uses two gates, eight transistors. latch uses SR latch, two gates, gate, 22 transistors. flip-flop uses two latches gate, 46 transistors. Section 3.2.7 describes efficient CMOS implementation using transmission gates. 3.2.4 Register N-bit register bank Nflip-flops share common CLK input, bits register updated time.QQ108 CHAPTER THREE Sequential Logic Design (a)CLK DQCLK DQ Q DN1CLK L1 L2 master slave (b)DQ (c)QQ Q Q Figure 3.8 flip-flop: (a) schematic, (b) symbol, (c) condensed symbol precise distinction flip-flops latches somewhat muddled evolved time. common industry usage, flip-flop edge-triggered. words, bistable element clock input. state flip-flop changes response clock edge, clock rises 0 1. Bistable elements without edge-triggered clock commonly called latches. term flip-flop latch usually refers flip-flop latch, respec- tively, types commonly used practice.Chapter 03.qxd 1/27/07 10:24 Page 108Registers key building block sequential circuits. Figure 3.9 shows schematic symbol four-bit register inputs D3:0and outputs Q3:0. D3:0and Q3:0are 4-bit busses. 3.2.5 Enabled Flip-Flop enabled flip-flop adds another input called ENor ENABLE determine whether data loaded clock edge. ENis TRUE, enabled flip-flop behaves like ordinary flip-flop. EN FALSE, enabled flip-flop ignores clock retains state. Enabled flip-flops useful wish load new value flip-flop time, rather every clock edge. Figure 3.10 shows two ways construct enabled flip-flop flip-flop extra gate. Figure 3.10(a), input multiplexer chooses whether pass value D,if ENis TRUE, recycle old state Q,if ENis FALSE. Figure 3.10(b), clock gated.3.2 Latches Flip-Flops 109 CLK DQ DQ DQ DQD3 D2 D1 D0Q3 Q2 Q1 Q0 (a)D3:0 Q3:044CLK (b)Figure 3.9 4-bit register: (a) schematic (b) symbol (b)DQCLK EN DQ DQ EN (c) (a)DQCLK EN DQ0 1Figure 3.10 Enabled flip-flop: (a, b) schematics, (c) symbolChapter 03.qxd 1/27/07 10:24 Page 109IfENis TRUE, CLK input flip-flop toggles normally. ENis FALSE, CLK input also FALSE flip-flop retains old value. Notice ENmust change CLK /H110051, lest flip-flop see clock glitch (switch incorrect time). Generally, performing logic clock bad idea. Clock gating delays clock cause timing errors, see Section 3.5.3, sure know doing. symbol enabled flip- flop given Figure 3.10(c). 3.2.6 Resettable Flip-Flop resettable flip-flop adds another input called RESET. RESET FALSE, resettable flip-flop behaves like ordinary flip-flop. RESET TRUE, resettable flip-flop ignores Dand resets output 0. Resettable flip-flops useful want force known state (i.e., 0) flip-flops system first turn on. flip-flops may synchronously asynchronously resettable. Synchronously resettable flip-flops reset rising edge CLK. Asynchronously resettable flip-flops reset soon RESET becomes TRUE, independent CLK. Figure 3.11(a) shows construct synchronously resettable flip-flop ordinary flip-flop gate. FALSE, gate forces 0 input flip-flop. TRUE, gate passes Dto flip-flop. example, active low signal, meaning reset signal performs function 0, 1. adding inverter, circuit could accepted active high RESET signal instead. Figures 3.11(b) 3.11(c) show symbols resettable flip-flop active high RESET. Asynchronously resettable flip-flops require modifying internal structure flip-flop left design Exercise 3.10; however, frequently available designer standard component. might imagine, settable flip-flops also occasionally used. load 1 flip-flop SET asserted, come synchronous asynchronous flavors. Resettable settable flip-flops may also enable input may grouped N-bit registers. 3.2.7 Transistor-Level Latch Flip-Flop Designs* Example 3.1 showed latches flip-flops require large number transistors built logic gates. fundamental role aRESETRESETRESET110 CHAPTER THREE Sequential Logic Design (a)DQCLK DQRESET DQ RESET (b) (c)r Figure 3.11 Synchronously resettable flip-flop: (a) schematic, (b, c) symbolsChapter 03.qxd 1/27/07 10:24 Page 110latch transparent opaque, much like switch. Recall Section 1.7.7 transmission gate efficient way build CMOS switch, might expect could take advantage transmission gates reduce transistor count. compact latch constructed single transmission gate, shown Figure 3.12(a). CLK /H110051 , transmis- sion gate ON, Dflows Qand latch transparent. CLK /H110050 , transmission gate OFF, Qis isolated latch opaque. latch suffers two major limitations: /L50776Floating output node: latch opaque, Qis held value gates. Thus Qis called floating dynamic node. time, noise charge leakage may disturb value Q. /L50776No buffers: lack buffers caused malfunctions sev- eral commercial chips. spike noise pulls Dto negative voltage turn nMOS transistor, making latch trans- parent, even CLK /H110050. Likewise, spike Dabove VDD turn pMOS transistor even CLK /H110050. transmission gate symmetric, could driven backward noise Qaffecting input D.The general rule neither input transmission gate state node sequential circuit ever exposed outside world, noise likely. Figure 3.12(b) shows robust 12-transistor latch used modern commercial chips. still built around clocked transmission gate, adds inverters I1 I2 buffer input output. state latch held node N1. Inverter I3 tristate buffer, T1, provide feedback turn N1 static node. small amount noise occurs N1 CLK /H110050, T1 drive N1 back valid logic value. Figure 3.13 shows flip-flop constructed two static latches controlled CLK. redundant internal inverters removed, flip-flop requires 20 transistors.CLKCLK /H110051CLK /H1100503.2 Latches Flip-Flops 111 (a)CLK Q CLK CLKDQ N1 (b)CLK CLK CLKI1I2 I3 T1 Figure 3.12 latch schematic circuit assumes CLK available. not, two transistors needed CLK inverter.CLK CLKDN1CLK CLK CLKI1 I2 T1I3 CLK CLKT2CLKCLK I4 QN2 Figure 3.13 flip-flop schematicChapter 03.qxd 1/27/07 10:24 Page 1113.2.8 Putting Together Latches flip-flops fundamental building blocks sequential circuits. Remember latch level-sensitive, whereas flip-flop edge-triggered. latch transparent CLK /H110051, allowing input Dto flow output Q.The flip-flop copies Dto Qon rising edge CLK. times, latches flip-flops retain old state. register bank several flip-flops share common CLK signal. Example 3.2 FLIP-FLOP LATCH COMPARISON Ben Bitdiddle applies Dand CLK inputs shown Figure 3.14 latch flip-flop. Help determine output, Q,of device. Solution: Figure 3.15 shows output waveforms, assuming small delay Qto respond input changes. arrows indicate cause output change. initial value Qis unknown could 0 1, indicated pair horizontal lines. First consider latch. first rising edge CLK, /H110050, Qdefinitely becomes 0. time Dchanges CLK /H110051, Qalso follows. Dchanges CLK /H110050, ignored. consider flip-flop. rising edge CLK, copied Q.At times, Qretains state.112 CHAPTER THREE Sequential Logic Design CLK Q(latch) Q(flop) Figure 3.14 Example waveforms CLK Q(latch) Q(flop) Figure 3.15 Solution waveformsChapter 03.qxd 1/27/07 10:24 Page 1123.3 SYNCHRONOUS LOGIC DESIGN general, sequential circuits include circuits combina- tional—that is, whose output cannot determined simply look- ing current inputs. sequential circuits plain kooky. section begins examining curious circuits. intro- duces notion synchronous sequential circuits dynamic disci- pline. disciplining synchronous sequential circuits, develop easy, systematic ways analyze design sequential systems. 3.3.1 Problematic Circuits Example 3.3 ASTABLE CIRCUITS Alyssa P. Hacker encounters three misbegotten inverters tied them- selves loop, shown Figure 3.16. output third inverter fed back first inverter. inverter propagation delay 1 ns. Determine circuit does. Solution: Suppose node Xis initially 0. Y/H110051, Z/H110050, hence X/H110051, inconsistent original assumption. circuit stable states said unstable astable. Figure 3.17 shows behavior circuit. Xrises time 0, Ywill fall 1 ns, Zwill rise 2 ns, Xwill fall 3 ns. turn, Ywill rise 4 ns, Zwill fall 5 ns, Xwill rise 6 ns, pattern repeat. node oscillates 0 1 period (repetition time) 6 ns. circuit called ring oscillator. period ring oscillator depends propagation delay inverter. delay depends inverter manufactured, power supply voltage, even temperature. Therefore, ring oscillator period difficult accurately predict. short, ring oscillator sequential circuit zero inputs one output changes periodically.3.3 Synchronous Logic Design 113 X YZ Figure 3.16 Three-inverter loop X Z time (ns) 012345678Figure 3.17 Ring oscillator waveforms Example 3.4 RACE CONDITIONS Ben Bitdiddle designed new latch claims better one Figure 3.17 uses fewer gates. written truth table findChapter 03.qxd 1/27/07 10:24 Page 113the output, Q,given two inputs, Dand CLK, old state latch, Qprev. Based truth table, derived Boolean equations. obtains Qprevby feeding back output, Q.His design shown Figure 3.18. latch work correctly, independent delays gate? Solution: Figure 3.19 shows circuit race condition causes fail certain gates slower others. Suppose CLK /H11005D/H110051. latch transparent passes Dthrough make Q/H110051. Now, CLK falls. latch remember old value, keeping Q/H110051. However, sup- pose delay inverter CLK rather long com- pared delays gates. nodes N1 Qmay fall rises. case, N2 never rise, Qbecomes stuck 0. example asynchronous circuit design outputs directly fed back inputs. Asynchronous circuits infamous race condi- tions behavior circuit depends two paths logic gates fastest. One circuit may work, seemingly identical one built gates slightly different delays may work. circuit may work certain temperatures voltages delays right. mistakes extremely difficult track down. 3.3.2 Synchronous Sequential Circuits previous two examples contain loops called cyclic paths, outputs fed directly back inputs. sequential rather combinational circuits. Combinational logic cyclic paths races. inputs applied combinational logic, outputs always settle correct value within propagation delay. However, sequential circuits cyclic paths undesirable races unstable behavior. Analyzing circuits problems time-consuming, many bright people made mistakes.CLKCLK114 CHAPTER THREE Sequential Logic Design CLK N1 N2QCLK Figure 3.19 Latch waveforms illustrating race conditionQ 0 1 0CLK 00 00 01Qprev 0 1 0 1 0 001 10 101 0 1 1 111 110 1CLKD CLK QprevQN1 = CLK·D N2 = CLK·Q prevQ = CLK·D + CLK·Q prev Figure 3.18 improved (?) latchChapter 03.qxd 1/27/07 10:24 Page 114To avoid problems, designers break cyclic paths insert- ing registers somewhere path. transforms circuit collection combinational logic registers. registers contain state system, changes clock edge, say state synchronized clock. clock sufficiently slow, inputs registers settle next clock edge, races eliminated. Adopting discipline always using registers feedback path leads us formal definition synchronous sequential circuit. Recall circuit defined input output terminals functional timing specifications. sequential circuit finite set discrete states {S0, S1,..., k/H110021}. synchronous sequential circuit clock input, whose rising edges indicate sequence times state transitions occur. often use terms current state next state distinguish state system present state enter next clock edge. functional specifi- cation details next state value output possi- ble combination current state input values. timing specification consists upper bound, tpcq, lower bound, tccq, time rising edge clock output changes, well setup hold times, tsetup thold, indicate inputs must stable relative rising edge clock. rules ynchronous sequential circuit composition teach us circuit synchronous sequential circuit consists intercon- nected circuit elements /L50776Every circuit element either register combinational circuit /L50776At least one circuit element register /L50776All registers receive clock signal /L50776Every cyclic path contains least one register. Sequential circuits synchronous called asynchronous. flip-flop simplest synchronous sequential circuit. one input, D,one clock, CLK, one output, Q,and two states, {0, 1}. functional specification flip-flop next state Dand output, Q,is current state, shown Figure 3.20. often call current state variable Sand next state variable S/H11032. case, prime Sindicates next state, inversion. tim- ing sequential circuits analyzed Section 3.5. Two common types synchronous sequential circuits called finite state machines pipelines. covered later chapter.3.3 Synchronous Logic Design 115 tpcqstands time propagation clock Q, Qindicates output synchronous sequential circuit. tccqstands time contamination clock Q.These analogous tpd tcdin combinational logic. DQ Next StateCurrent StateS ′ SCLK Figure 3.20 Flip-flop current state next stateThis definition synchro- nous sequential circuit sufficient, restrictive necessary. example, high-performance micro- processors, registers may receive delayed gated clocks squeeze last bit performance power. Similarly, microproces- sors use latches instead registers. However, definition adequate synchronous sequential circuits covered book commercial digital systems.Chapter 03.qxd 1/27/07 10:24 Page 115Example 3.5 SYNCHRONOUS SEQUENTIAL CIRCUITS circuits Figure 3.21 synchronous sequential circuits? Solution: Circuit (a) combinational, sequential, regis- ters. (b) simple sequential circuit feedback. (c) neither combi- national circuit synchronous sequential circuit, latch neither register combinational circuit. (d) (e) synchro- nous sequential logic; two forms finite state machines, discussed Section 3.4. (f) neither combinational synchronous sequen- tial, cyclic path output combinational logic back input logic register path. (g) synchro- nous sequential logic form pipeline, study Section 3.6. (h) not, strictly speaking, synchronous sequential circuit, second register receives different clock signal first, delayed two inverter delays. 3.3.3 Synchronous Asynchronous Circuits Asynchronous design theory general synchronous design, timing system limited clocked registers. analog circuits general digital circuits analog circuits use voltage, asynchronous circuits general synchronous circuits use kind feedback. However, synchronous circuits proved easier design use asynchronous circuits, digital easier analog cir- cuits. Despite decades research asynchronous circuits, virtually digital systems essentially synchronous.116 CHAPTER THREE Sequential Logic Design CLCLKCL (a)CL (b)CLK CLCLK (c) (d)CLCLK CL (e) CL (f)CLK (g)CLCLK CLCLKCLKCLK (h)CLFigure 3.21 Example circuitsChapter 03.qxd 1/27/07 10:24 Page 116Of course, asynchronous circuits occasionally necessary com- municating systems different clocks receiving inputs arbitrary times, analog circuits necessary communicat- ing real world continuous voltages. Furthermore, research asynchronous circuits continues generate interesting insights, improve synchronous circuits too. 3.4 FINITE STATE MACHINES Synchronous sequential circuits drawn forms shown Figure 3.22. forms called finite state machines (FSMs ). get name circuit kregisters one finite num- ber (2k) unique states. FSM Minputs, Noutputs, kbits state. also receives clock and, optionally, reset signal. FSM con- sists two blocks combinational logic, next state logic output logic, register stores state. clock edge, FSM advances next state, computed based current state inputs. two general classes finite state machines, charac- terized functional specifications. Moore machines, outputs depend current state machine. Mealy machines, outputs depend current state current inputs. Finite state machines provide systematic way design synchronous sequential circuits given functional specification. method explained remainder section, starting example. 3.4.1 FSM Design Example illustrate design FSMs, consider problem inventing controller traffic light busy intersection campus. Engineering students moseying dorms labs Academic Ave. busy reading FSMs favorite3.4 Finite State Machines 117 CLK N k next state logicoutput logic (a)inputsoutputsstatenext statek (b)CLK MN k next state logicoutput logicinputsoutputsstatenext statekFigure 3.22 Finite state machines: (a) Moore machine, (b) Mealy machineMoore Mealy machines named promot- ers, researchers developed automata theory, mathe- matical underpinnings state machines, Bell Labs. Edward F. Moore (1925–2003), confused Intel founder Gordon Moore, published seminal article, Gedanken- experiments Sequential Machines 1956. subse- quently became professor mathematics computer science University Wisconsin. George H. Mealy published Method Synthesizing Sequential Circuits 1955. subsequently wrote first Bell Labs operating system IBM 704 computer. later joined Harvard University.Chapter 03.qxd 1/27/07 10:24 Page 117textbook aren’t looking going. Football players hustling athletic fields dining hall Bravado Boulevard. tossing ball back forth aren’t looking going either. Several serious injuries already occurred intersection two roads, Dean Students asks Ben Bitdiddle install traffic light fatalities. Ben decides solve problem FSM. installs two traffic sensors, TAand TB, Academic Ave. Bravado Blvd., respectively. sensor indicates TRUE students present FALSE street empty. also installs two traffic lights, LAand LB, control traffic. light receives digital inputs specifying whether green, yellow, red. Hence, FSM two inputs, TAand TB, two out- puts, LAand LB. intersection lights sensors shown Figure 3.23. Ben provides clock 5-second period. clock tick (rising edge), lights may change based traffic sensors. also provides reset button Physical Plant technicians put controller known initial state turn on. Figure 3.24 shows black box view state machine. Ben’s next step sketch state transition diagram , shown Figure 3.25, indicate possible states system transi- tions states. system reset, lights green Academic Ave. red Bravado Blvd. Every 5 seconds, con- troller examines traffic pattern decides next. long118 CHAPTER THREE Sequential Logic Design TA TBLA LBCLK ResetTraffic Light ControllerFigure 3.24 Black box view finite state machineTALA TALB TB TBLA LBAcademic Ave.Bravado Blvd.Dorms FieldsAthleticDining Hall LabsFigure 3.23 Campus mapChapter 03.qxd 1/27/07 10:24 Page 118as traffic present Academic Ave., lights change. longer traffic Academic Ave., light Academic Ave. becomes yellow 5 seconds turns red Bravado Blvd.’s light turns green. Similarly, Bravado Blvd. light remains green long traffic present boulevard, turns yellow eventually red. state transition diagram, circles represent states arcs repre- sent transitions states. transitions take place rising edge clock; bother show clock diagram, always present synchronous sequential circuit. Moreover, clock simply controls transitions occur, whereas diagram indicates transitions occur. arc labeled Reset pointing outer space state S0 indicates system enter state upon reset, regardless previous state in. state multiple arcs leaving it, arcs labeled show input triggers transition. example, state S0, system remain state TAis TRUE move S1 TAis FALSE. state single arc leaving it, transition always occurs regardless inputs. example, state S1, system always move S2. value outputs particular state indicated state. example, state S2, LAis red LBis green. Ben rewrites state transition diagram state transition table (Table 3.1), indicates, state input, next state, S/H11032, be. Note table uses don’t care symbols (X) whenever next state depend particular input. Also note Reset omitted table. Instead, use resettable flip-flops always go state S0 reset, independent inputs. state transition diagram abstract uses states labeled {S0, S1, S2, S3} outputs labeled {red, yellow, green}. build real circuit, states outputs must assigned binary encodings. Ben chooses simple encodings given Tables 3.2 3.3. state output encoded two bits: S1:0, LA1:0, LB1:0.3.4 Finite State Machines 119 S0 LA: green LB: red LA: red LB: yellowLA: yellow LB: red LA: red LB: greenS1 S3 S2TA TA TBTBReset Figure 3.25 State transition diagramChapter 03.qxd 1/27/07 10:24 Page 119Ben updates state transition table use binary encodings, shown Table 3.4. revised state transition table truth table speci- fying next state logic. defines next state, S/H11032, function cur- rent state, S,and inputs. revised output table truth table specifying output logic. defines outputs, LAand LB, functions current state, S. table, straightforward read Boolean equa- tions next state sum-of-products form. (3.1) equations simplified using Karnaugh maps, often inspection easier. example, TBand terms S/H110321equation clearly redundant. Thus S/H110321reduces XOR opera- tion. Equation 3.2 gives next state equations.TB S/H110320/H11005S1S0TA/H11001S1S0TB S/H110321/H11005S1S0/H11001S1S0TB/H11001S1S0 TB120 CHAPTER THREE Sequential Logic Design Table 3.3 Output encoding Output Encoding L1:0 green 00 yellow 01 red 10 Table 3.4 State transition table binary encodings Current State Inputs Next State S1 S0 TA TB S/H110321 S/H110320 00 0X0 1 00 1X0 0 01 XX1 0 10 X01 1 10 X11 0 11 XX0 0Table 3.1 State transition table Current Inputs Next State State ST TB S/H11032 S0 0 X S1 S0 1 X S0 S1 X X S2 S2 X 0 S3 S2 X 1 S2 S3 X X S0Table 3.2 State encoding State Encoding S1:0 S0 00 S1 01 S2 10 S3 11Chapter 03.qxd 1/27/07 10:24 Page 120(3.2) Similarly, Ben writes output table (Table 3.5) indicating, state, output state. Again, straightfor- ward read simplify Boolean equations outputs. example, observe LA1is TRUE rows S1is TRUE. (3.3) Finally, Ben sketches Moore FSM form Figure 3.22(a). First, draws 2-bit state register, shown Figure 3.26(a). clock edge, state register copies next state, S/H110321:0, become state, S1:0. state register receives synchronous asynchronous reset initialize FSM startup. Then, draws next state logic, based Equation 3.2, computes next state, based cur- rent state inputs, shown Figure 3.26(b). Finally, draws output logic, based Equation 3.3, computes outputs based current state, shown Figure 3.26(c). Figure 3.27 shows timing diagram illustrating traffic light con- troller going sequence states. diagram shows CLK, Reset, inputs TAand TB, next state S/H11032, state S,and outputs LAand LB. Arrows indicate causality; example, changing state causes out- puts change, changing inputs causes next state change. Dashed lines indicate rising edge CLK state changes. clock 5-second period, traffic lights change every 5 seconds. finite state machine first turned on, state unknown, indicated question marks. Therefore, sys- tem reset put known state. timing diagram, LB0/H11005 S1 S0 LB1/H11005S1 LA0/H11005S1 S0 LA1/H11005 S1 S/H110320/H11005S1S0TA/H11001S1S0TB S/H110321/H11005S1 ⊕ S03.4 Finite State Machines 121 Table 3.5 Output table Current State Outputs S1 S0 LA1LA0 LB1LB0 00 0 0 10 01 0 1 10 10 1 0 00 11 1 0 01Chapter 03.qxd 1/27/07 10:24 Page 121122 CHAPTER THREE Sequential Logic Design (a)S1 S0S'1 S'0CLK state registerResetrS1 S0S'1 S'0CLK next state logic state registerResetTA TB inputs (b)S1S0r S1 S0S'1 S'0CLK next state logic output logicstate registerResetLA1 LB1 LB0LA0 TA TB inputs outputs (c)S1S0r Figure 3.26 State machine circuit traffic light controller CLK Reset TA TB S'1:0 S1:0 LA1:0 LB1:0Cycle 1 Cycle 2 Cycle 3 Cycle 4 Cycle 5 Cycle 6 Cycle 7 Cycle 8 Cycle 9 Cycle 10 S1(01) S2(10) S3(11) S0(00) (sec)???? S0(00)S0(00) S1(01) S2(10) S3(11) S1(01) ?? ?? 0 5 10 15 20 25 30 35 40 45Green (00) Red (10)S0(00) Yellow (01) Red (10) Green (00) Green (00) Red (10) Yellow (01) Figure 3.27 Timing diagram traffic light controllerThis schematic uses gates bubbles inputs. might constructed gates input inverters, gates inverters non-bubbled inputs, combination gates. best choice depends particular implementation technology.Chapter 03.qxd 1/27/07 10:24 Page 122Simmediately resets S0, indicating asynchronously resettable flip- flops used. state S0, light LAis green light LBis red. example, traffic arrives immediately Academic Ave. Therefore, controller remains state S0, keeping LAgreen even though traffic arrives Bravado Blvd. starts waiting. 15 sec- onds, traffic Academic Ave. passed TAfalls. following clock edge, controller moves state S1, turning LA yellow. another 5 seconds, controller proceeds state S2 LAturns red LBturns green. controller waits state S2 traffic Bravado Blvd. passed through. proceeds state S3, turning LByellow. 5 seconds later, controller enters state S0, turning LBred LAgreen. process repeats. 3.4.2 State Encodings previous example, state output encodings selected arbi- trarily. different choice would resulted different circuit. natu- ral question determine encoding produces circuit fewest logic gates shortest propagation delay. Unfortunately, simple way find best encoding except try possibilities, infeasible number states large. However, often possible choose good encoding inspection, related states outputs share bits. Computer-aided design (CAD) tools also good searching set possible encodings selecting reasonable one. One important decision state encoding choice binary encoding one-hot encoding. binary encoding, used traffic light controller example, state represented binary number. Kbinary numbers represented log 2K bits, system Kstates needs log 2Kbits state. one-hot encoding, separate bit state used state. called one-hot one bit “hot” TRUE time. example, one-hot encoded FSM three states would state encod- ings 001, 010, 100. bit state stored flip-flop, one- hot encoding requires flip-flops binary encoding. However, one-hot encoding, next-state output logic often simpler, fewer gates required. best encoding choice depends specific FSM. Example 3.6 FSM STATE ENCODING divide-by-N counter one output inputs. output Yis HIGH one clock cycle every N.In words, output divides frequency clock N. waveform state transition diagram divide-by-3 counter shown Figure 3.28. Sketch circuit designs counter using binary one-hot state encodings.3.4 Finite State Machines 123 Despite Ben’s best efforts, stu- dents don’t pay attention traffic lights collisions continue occur. Dean Students next asks design catapult throw engineering students directly dorm roofs open windows lab, bypassing troublesome intersection together. sub- ject another textbook. Chapter 03.qxd 1/27/07 10:24 Page 123Solution: Tables 3.6 3.7 show abstract state transition output tables encoding. Table 3.8 compares binary one-hot encodings three states. binary encoding uses two bits state. Using encoding, state transi- tion table shown Table 3.9. Note inputs; next state depends current state. output table left exercise reader. next-state output equations are: (3.4) (3.5) one-hot encoding uses three bits state. state transition table encoding shown Table 3.10 output table left exercise reader. next-state output equations follows: (3.6) (3.7) Figure 3.29 shows schematics designs. Note hardware binary encoded design could optimized share gate Yand S/H110320. Also observe one-hot encoding requires settable ( s) resettable ( r) flip-flops initialize machine S0 reset. best imple- mentation choice depends relative cost gates flip-flops, one-hot design usually preferable specific example. related encoding one-cold encoding, Kstates represented Kbits, exactly one FALSE.Y/H11005S0 S/H110320/H11005S2 S/H110321/H11005 S0 S/H110322/H11005 S1Y/H11005S1S0 S/H110320/H11005S1S0 S/H110321/H11005S1 S0124 CHAPTER THREE Sequential Logic Design CLK (a) S0 Y: 1S1 Y: 0S2 Y: 0Reset (b)Figure 3.28 Divide-by-3 counter (a) waveform (b) state transition diagram Table 3.6 Divide-by-3 counter state transition table Current Next State State S0 S1 S1 S2 S2 S0 Table 3.7 Divide-by-3 counter output table Current State Output S0 1 S1 0 S2 0Chapter 03.qxd 1/27/07 10:24 Page 1243.4 Finite State Machines 125 Table 3.8 Binary one-hot encodings divide-by-3 counter State Binary Encoding One-Hot Encoding S2 S1 S0 S1 S0 S0 0 0 1 0 1 S1 0 1 0 1 0 S2 1 0 0 0 0 Table 3.9 State transition table binary encoding Current State Next State S1 S0 S/H110321 S/H110320 00 0 1 01 1 0 10 0 0 Table 3.10 State transition table one-hot encoding Current State Next State S2 S1 S0 S/H110322 S/H110321 S/H110320 001 0 1 0 010 1 0 0 100 0 0 1 S1 S0S'1 S'0CLK ResetY output logic output state register next state logic (a) ResetCLK rrsS0 S2 S1Y (b)S0 S1r Figure 3.29 Divide-by-3 circuits (a) binary (b) one-hot encodingsChapter 03.qxd 1/27/07 10:24 Page 1253.4.3 Moore Mealy Machines far, shown examples Moore machines, output depends state system. Hence, state transition dia- grams Moore machines, outputs labeled circles. Recall Mealy machines much like Moore machines, outputs depend inputs well current state. Hence, state transition diagrams Mealy machines, outputs labeled arcs instead circles. block combinational logic computes out- puts uses current state inputs, shown Figure 3.22(b). Example 3.7 MOORE VERSUS MEALY MACHINES Alyssa P. Hacker owns pet robotic snail FSM brain. snail crawls left right along paper tape containing sequence 1’s 0’s. clock cycle, snail crawls next bit. snail smiles last four bits crawled are, left right, 1101. Design FSM com- pute snail smile. input Ais bit underneath snail’s antennae. output Yis TRUE snail smiles. Compare Moore Mealy state machine designs. Sketch timing diagram machine showing input, states, output snail crawls along sequence 111011010. Solution: Moore machine requires five states, shown Figure 3.30(a). Convince state transition diagram correct. particular, arc S4 S2 input 1? comparison, Mealy machine requires four states, shown Figure 3.30(b). arc labeled A/Y. value input causes transition, Yis corresponding output. Tables 3.11 3.12 show state transition output tables Moore machine. Moore machine requires least three bits state. Consider using binary state encoding: S0 /H11005000, S1 /H11005001, S2 /H11005010, S3 /H11005011, S4 /H11005100. Tables 3.13 3.14 rewrite state transition output tables encodings (These four tables follow page 128). tables, find next state output equations inspection. Note equations simplified using fact states 101, 110, 111 exist. Thus, corresponding next state output non- existent states don’t cares (not shown tables). use don’t cares minimize equations. (3.8) S/H110320/H11005S2S1S0 A/H11001S1S0AS/H110321/H11005S1 S0A/H11001S1S0/H11001S2AS/H110322/H11005S1 S0A126 CHAPTER THREE Sequential Logic Design easy way remember difference two types finite state machines Moore machine typi- cally states Mealy machine given problem.Chapter 03.qxd 1/27/07 10:24 Page 126(3.9) Table 3.15 shows combined state transition output table Mealy machine. Mealy machine requires least two bits state. Consider using binary state encoding: S0 /H1100500, S1 /H1100501, S2 /H1100510, S3 /H1100511. Table 3.16 rewrites state transition output table encodings. tables, find next state output equations inspection. (3.10) (3.11) Moore Mealy machine schematics shown Figure 3.31(a) 3.31(b), respectively. timing diagrams Moore Mealy machines shown Figure 3.32 (see page 131). two machines follow different sequence states. Moreover, Mealy machine’s output rises cycle sooner responds input rather waiting state change. Mealy output delayed flip-flop, would match Moore output. choosing FSM design style, consider want outputs respond.Y/H11005S1 S0 S0/H11032/H11005S 1S0A/H11001S1 S0 A/H11001S1S0AS/H110321/H11005 S1S0/H11001S1S0AY/H11005S23.4 Finite State Machines 127 Reset (a)S0 0S1 0S2 0S3 0S4 1 0110 11 0 10 0 Reset (b)S0 S1 S2 S3 0/01/0 1/0 0/01/1 0/01/0 0/0Figure 3.30 FSM state transition diagrams: (a) Moore machine, (b) Mealy machineChapter 03.qxd 1/27/07 10:24 Page 127128 CHAPTER THREE Sequential Logic Design Table 3.14 Moore output table state encodings Current State Output S2S1S0 000 0 001 0 010 0 011 0 100 1Table 3.13 Moore state transition table state encodings Current State Input Next State S2 S1 S0 /H110322 S/H110321 S/H110320 000 0 000 000 1 001 001 0 000 001 1 010 010 0 011 010 1 010 011 0 000 011 1 100 100 0 000 100 1 010Table 3.11 Moore state transition table Current State Input Next State SA /H11032 S0 0 S0 S0 1 S1 S1 0 S0 S1 1 S2 S2 0 S3 S2 1 S2 S3 0 S0 S3 1 S4 S4 0 S0 S4 1 S2Table 3.12 Moore output table Current Output State SY S0 0 S1 0 S2 0 S3 0 S4 1Chapter 03.qxd 1/27/07 10:24 Page 1283.4.4 Factoring State Machines Designing complex FSMs often easier broken multiple interacting simpler state machines output machines input others. application hierarchy modu- larity called factoring state machines.3.4 Finite State Machines 129 Table 3.15 Mealy state transition output table Current State Input Next State Output SA /H11032 S0 0 S0 0 S0 1 S1 0 S1 0 S0 0 S1 1 S2 0 S2 0 S3 0 S2 1 S2 0 S3 0 S0 0 S3 1 S1 1 Table 3.16 Mealy state transition output table state encodings Current State Input Next State Output S1 S0 /H110321 S/H110320 00 000 0 00 101 0 01 000 0 01 110 0 10 011 0 10 110 0 11 000 0 11 101 1Chapter 03.qxd 1/27/07 10:24 Page 129130 CHAPTER THREE Sequential Logic Design Example 3.8 UNFACTORED FACTORED STATE MACHINES Modify traffic light controller Section 3.4.1 parade mode, keeps Bravado Boulevard light green spectators band march football games scattered groups. controller receives two inputs: Pand R.Asserting Pfor least one cycle enters parade mode. Asserting Rfor least one cycle leaves parade mode. parade mode, con- troller proceeds usual sequence LBturns green, remains state LBgreen parade mode ends. First, sketch state transition diagram single FSM, shown Figure 3.33(a). Then, sketch state transition diagrams two interacting FSMs, asS2 S1 S0S'2 S'1 S'0YCLK ResetA (a)S2S1S0 (b)S'1 S'0CLK ResetS1 S0A S0 S1Figure 3.31 FSM schematics (a) Moore (b) Mealy machinesChapter 03.qxd 1/27/07 10:24 Page 1303.4 Finite State Machines 131 Mealy MachineMoore MachineCLK Reset YCycle 1 Cycle 2 Cycle 3 Cycle 4 Cycle 5 Cycle 6 Cycle 7 Cycle 8 Cycle 9 Cycle 10 S0 S0S1 S1?? ??S2 S2S3 S3S4 S1S0 S011 11 1 00 0 1 S2 S3 S3S4 S1S2 S2 S2 Figure 3.32 Timing diagrams Moore Mealy machines Controller FSM TA (a)TBLA LB (b)Mode FSM Lights FSMP Controller FSMLA LBTA TBR P RFigure 3.33 (a) single (b) factored designs modified traffic light controller FSMshown Figure 3.33(b). Mode FSM asserts output Mwhen parade mode. Lights FSM controls lights based Mand traffic sensors, TAand TB. Solution: Figure 3.34(a) shows single FSM design. States S0 S3 handle normal mode. States S4 S7 handle parade mode. two halves dia- gram almost identical, parade mode, FSM remains S6 green light Bravado Blvd. Pand Rinputs control movement two halves. FSM messy tedious design. Figure 3.34(b) shows factored FSM design. mode FSM two states track whether lights normal parade mode. Lights FSM modified remain S2 Mis TRUE.Chapter 03.qxd 1/27/07 10:24 Page 1313.4.5 FSM Review Finite state machines powerful way systematically design sequential circuits written specification. Use following proce- dure design FSM: /L50776Identify inputs outputs. /L50776Sketch state transition diagram.132 CHAPTER THREE Sequential Logic Design S0 LA: green LB: red LA: green LB: redLA: yellow LB: red LA: yellow LB: red LA: red LB: green LA: red LB: greenLA: red LB: yellow LA: red LB: yellowS1 S3 S2TATA TB TBReset S4 S5 S7 S6TA TAP PP P PPR R R RRP RPTAPTAP PTAR TAR R TBRTBR (a) LA: green LB: redLA: yellow LB: red LA: red LB: greenLA: red LB: yellowS0 S1 S3 S2TA TA M+ TBMT BReset Lights FSM (b)S0 M: 0S1 M: 1PResetP Mode FSMR RFigure 3.34 State transition diagrams: (a) unfactored, (b) factoredChapter 03.qxd 1/27/07 10:24 Page 132/L50776For Moore machine: – Write state transition table. – Write output table. /L50776For Mealy machine: – Write combined state transition output table. /L50776Select state encodings—your selection affects hardware design. /L50776Write Boolean equations next state output logic. /L50776Sketch circuit schematic. repeatedly use FSMs design complex digital systems through- book. 3.5 TIMING SEQUENTIAL LOGIC Recall flip-flop copies input Dto output Qon rising edge clock. process called sampling clock edge. Dis stable either 0 1 clock rises, behavior clearly defined. happens Dis changing time clock rises? problem similar faced camera snapping picture. Imagine photographing frog jumping lily pad lake. take picture jump, see frog lily pad. take picture jump, see ripples water. take frog jumps, may see blurred image frog stretching lily pad water. camera characterized aperture time, object must remain still sharp image captured. Similarly, sequential element aperture time around clock edge, input must stable flip-flop produce well-defined output. aperture sequential element defined setup time hold time, clock edge, respectively. static discipline limited us using logic levels outside forbidden zone, dynamic discipline limits us using signals change out- side aperture time. taking advantage dynamic discipline, think time discrete units called clock cycles, think signal levels discrete 1’s 0’s. signal may glitch oscillate wildly bounded amount time. dynamic discipline, concerned final value end clock cycle, settled stable value. Hence, simply write A[n], value signal Aat end nthclock cycle, nis integer, rather A(t), value Aat instant t, tis real number. clock period long enough signals settle. sets limit speed system. real systems, clock not3.5 Timing Sequential Logic 133 Chapter 03.qxd 1/27/07 10:24 Page 133reach flip-flops precisely time. variation time, called clock skew ,further increases necessary clock period. Sometimes impossible satisfy dynamic discipline, espe- cially interfacing real world. example, consider cir- cuit input coming button. monkey might press button clock rises. result phenomenon called metastability ,where flip-flop captures value partway 0 1 take unlimited amount time resolve good logic value. solution asynchronous inputs use syn- chronizer, small (but nonzero) probability producing illegal logic value. expand ideas rest section. 3.5.1 Dynamic Discipline far, focused functional specification sequential circuits. Recall synchronous sequential circuit, flip-flop FSM, also timing specification, illustrated Figure 3.35. clock rises, output (or outputs) may start change clock-to- Q contamination delay, ccq, must definitely settle final value within clock-to- Q propagation delay, pcq. repre- sent fastest slowest delays circuit, respectively. circuit sample input correctly, input (or inputs) must stabilized least setup time, setup, rising edge clock must remain stable least hold time, hold, rising edge clock. sum setup hold times called aperture time circuit, total time input must remain stable. dynamic discipline states inputs synchronous sequential circuit must stable setup hold aperture time around clock edge. imposing requirement, guarantee flip-flops sample signals changing. concerned final values inputs time sampled, treat signals discrete time well logic levels.134 CHAPTER THREE Sequential Logic Design CLK tccq tpcqt setupoutput(s) input(s) holdFigure 3.35 Timing specification synchronous sequential circuitChapter 03.qxd 1/27/07 10:24 Page 1343.5.2 System Timing clock period cycle time ,Tc, time rising edges repetitive clock signal. reciprocal, fc/H110051/Tc, clock frequency. else same, increasing clock frequency increases work digital system accomplish per unit time. Frequency measured units Hertz (Hz), cycles per second: 1 megahertz (MHz) /H11005106Hz, 1 gigahertz (GHz) /H11005109Hz. Figure 3.36(a) illustrates generic path synchronous sequential circuit whose clock period wish calculate. rising edge clock, register R1 produces output (or outputs) Q1. signals enter block combinational logic, producing D2, input (or inputs) register R2. timing diagram Figure 3.36(b) shows output signal may start change contamination delay input change settles final value within propagation delay input settles. gray arrows represent contamination delay R1 combinational logic, blue arrows represent prop- agation delay R1 combinational logic. analyze timing constraints respect setup hold time second register, R2. Setup Time Constraint Figure 3.37 timing diagram showing maximum delay path, indicated blue arrows. satisfy setup time R2, D2 must settle later setup time next clock edge.3.5 Timing Sequential Logic 135 CLCLK CLK R1 R2Q1 D2 (a)CLK Q1 D2 (b)Tc Figure 3.36 Path registers timing diagram CLK Q1 D2Tc tpcq tpd setupCLCLK CLK Q1 D2 R1 R2 Figure 3.37 Maximum delay setup time constraintIn three decades one authors’ families bought Apple II /H11001 computer present time writing, microprocessor clock frequencies increased 1 MHz several GHz, factor 1000. speedup partially explains revolu- tionary changes computers made society.Chapter 03.qxd 1/27/07 10:24 Page 135Hence, find equation minimum clock period: (3.12) commercial designs, clock period often dictated Director Engineering marketing department (to ensure competitive product). Moreover, flip-flop clock-to- Qpropagation delay setup time, tpcqand tsetup, specified manufacturer. Hence, rearrange Equation 3.12 solve maximum propagation delay combinational logic, usually variable control individual designer. (3.13) term parentheses, tpcq/H11001tsetup, called sequencing overhead. Ideally, entire cycle time, Tc, would available useful computa- tion combinational logic, tpd. However, sequencing overhead flip-flop cuts time. Equation 3.13 called setup time constraint max-delay constraint, depends setup time limits maximum delay combinational logic. propagation delay combinational logic great, D2 may settled final value time R2 needs stable samples it. Hence, R2 may sample incorrect result even illegal logic level, level forbidden region. case, circuit malfunction. problem solved increasing clock period redesigning combinational logic shorter propagation delay. Hold Time Constraint register R2 Figure 3.36(a) also hold time constraint. input, D2, must change time, thold, rising edge clock. According Figure 3.38, D2 might change soon tccq/H11001 tcdafter rising edge clock.tpd/H11349Tc/H11002(tpcq/H11001tsetup)Tc/H11350tpcq/H11001tpd/H11001tsetup136 CHAPTER THREE Sequential Logic Design CLK Q1 D2 tccqtcd tholdCLCLK CLK Q1 D2 R1 R2 Figure 3.38 Minimum delay hold time constraintChapter 03.qxd 1/27/07 10:24 Page 136Hence, find (3.14) Again, tccqand tholdare characteristics flip-flop usually outside designer’s control. Rearranging, solve mini- mum contamination delay combinational logic: (3.15) Equation 3.15 also called min-delay constraint limits minimum delay combinational logic. assumed logic elements connected without introducing timing problems. particular, would expect two flip-flops may directly cascaded Figure 3.39 without causing hold time problems. case, tcd/H110050 combinational logic flip-flops. Substituting Equation 3.15 yields requirement (3.16) words, reliable flip-flop must hold time shorter contamination delay. Often, flip-flops designed thold/H11005 0, Equation 3.16 always satisfied. Unless noted otherwise, usually make assumption ignore hold time constraint book. Nevertheless, hold time constraints critically important. violated, solution increase contamination delay logic, requires redesigning circuit. Unlike setup time constraints, cannot fixed adjusting clock period. Redesigning integrated circuit manufacturing corrected design takes months millions dollars today’s advanced tech- nologies, hold time violations must taken extremely seriously. Putting Together Sequential circuits setup hold time constraints dictate maximum minimum delays combinational logic flip- flops. Modern flip-flops usually designed minimum delay combinational logic 0—that is, flip-flops placed back-to-back. maximum delay constraint limits number con- secutive gates critical path high-speed circuit, high clock frequency means short clock period. Example 3.9 TIMING ANALYSIS Ben Bitdiddle designed circuit Figure 3.40. According data sheets components using, flip-flops clock-to- Qcontamination delaythold/H11349tccqtcd/H11350thold/H11002tccqtccq /H11001 tcd/H11350thold3.5 Timing Sequential Logic 137 CLK Figure 3.39 Back-to-back flip-flopsChapter 03.qxd 1/27/07 10:24 Page 137of 30 ps propagation delay 80 ps. setup time 50 ps hold time 60 ps. logic gate propagation delay 40 ps con- tamination delay 25 ps. Help Ben determine maximum clock frequency whether hold time violations could occur. process called timing analysis. Solution: Figure 3.41(a) shows waveforms illustrating signals might change. inputs, Ato D,are registered, change shortly CLK rises only. critical path occurs B/H110051, C/H110050, D/H110050, Arises 0 1, triggering n1 rise, X/H11032to rise Y/H11032to fall, shown Figure 3.41(b). path involves three gate delays. critical path, assume gate requires full propagation delay. Y/H11032must setup next rising edge CLK. Hence, minimum cycle time (3.17) maximum clock frequency fc/H110051/Tc/H110054 GHz. short path occurs A/H110050 Crises, causing X/H11032to rise, shown Figure 3.41(c). short path, assume gate switches contamination delay. path involves one gate delay, may occur tccq/H11001tcd/H1100530/H1100125/H1100555 ps. recall flip-flop hold time 60 ps, meaning X/H11032must remain stable 60 ps rising edge CLK flip-flop reliably sample value. case, X/H11032/H110050 first rising edge CLK, want flip-flop capture X/H110050. X/H11032did hold stable long enough, actual value Xis unpredictable. circuit hold time violation may behave errati- cally clock frequency.Tc/H11350tpcq/H110013 tpd/H11001tsetup/H1100580/H110013/H1100340/H1100150/H11005250 ps138 CHAPTER THREE Sequential Logic Design CLK CLK B C Dn1 X ' 'X YFigure 3.40 Sample circuit timing analysisChapter 03.qxd 1/27/07 10:24 Page 138Example 3.10 FIXING HOLD TIME VIOLATIONS Alyssa P. Hacker proposes fix Ben’s circuit adding buffers slow short paths, shown Figure 3.42. buffers delays gates. Determine maximum clock frequency whether hold time problems could occur. Solution: Figure 3.43 shows waveforms illustrating signals might change. critical path Ato Yis unaffected, pass buffers. Therefore, maximum clock frequency still 4 GHz. However, short paths slowed contamination delay buffer. X/H11032will change tccq/H110012tcd/H1100530/H110012/H1100325/H1100580 ps. 60 ps hold time elapsed, circuit operates correctly. example unusually long hold time illustrate point hold time problems. flip-flops designed thold/H11021tccqto avoid problems. However, several high-performance microprocessors, including Pentium 4, use element called pulsed latch place flip-flop. pulsed latch behaves like flip-flop short clock-to Q delay long hold time. general, adding buffers usually, always, solve hold time problems without slowing critical path.3.5 Timing Sequential Logic 139 A–DCLK n1 X' Y'0 50 100 150 200 250 (ps) (a) n1 X' Y'tpcq tpd tpd tpd setup C X'tccq tcd hold(b) (c)Figure 3.41 Timing diagram: (a) general case, (b) critical path, (c) short pathChapter 03.qxd 1/27/07 10:24 Page 1393.5.3 Clock Skew* previous analysis, assumed clock reaches registers exactly time. reality, variation time. variation clock edges called clock skew. example, wires clock source different registers may different lengths, resulting slightly different delays, shown Figure 3.44. Noise also results different delays. Clock gating, described Section 3.2.5, delays clock. clocks gated others not, substantial skew gated ungated clocks. In140 CHAPTER THREE Sequential Logic Design CLK CLK B C Dn1 X' Y'X YBuffers added fix hold time violation n2 n3Figure 3.42 Corrected circuit fix hold time problem A–DCLK n1–n3 X' Y'0 50 100 150 200 250 (ps) Figure 3.43 Timing diagram buffers fix hold time problem tskew CLK1 CLK2CLCLK2 CLK1 R1 R 2Q1 D2CLKdelay CLKFigure 3.44 Clock skew caused wire delayChapter 03.qxd 1/27/07 10:24 Page 140Figure 3.44, CLK 2 early respect CLK 1, clock wire two registers follows scenic route. clock routed differently, CLK 1 might early instead. timing analysis, consider worst-case scenario, guarantee circuit work circumstances. Figure 3.45 adds skew timing diagram Figure 3.36. heavy clock line indicates latest time clock signal might reach register; hashed lines show clock might arrive tskewearlier. First, consider setup time constraint shown Figure 3.46. worst case, R1 receives latest skewed clock R2 receives earli- est skewed clock, leaving little time possible data propagate registers. data propagates register combinational logic must setup R2 samples it. Hence, conclude (3.18) (3.19) Next, consider hold time constraint shown Figure 3.47. worst case, R1 receives early skewed clock, CLK 1, R2 receives late skewed clock, CLK 2. data zips registertpd/H11349Tc/H11002(tpcq/H11001tsetup/H11001tskew)Tc/H11350tpcq/H11001tpd/H11001tsetup/H11001tskew3.5 Timing Sequential Logic 141 CLCLK CLK R1 R 2Q1 D2 (a)CLK Q1 D2 (b)Tct skew Figure 3.45 Timing diagram clock skew CLK1 Q1 D2Tc tpcq tpd setupt skewCLCLK2 CLK1 R1 R2Q1 D2 CLK2Figure 3.46 Setup time constraint clock skewChapter 03.qxd 1/27/07 10:24 Page 141and combinational logic must arrive hold time late clock. Thus, find (3.20) (3.21) summary, clock skew effectively increases setup time hold time. adds sequencing overhead, reducing time available useful work combinational logic. also increases required minimum delay combinational logic. Even thold/H110050, pair back-to-back flip-flops violate Equation 3.21 iftskew /H11022tccq. prevent serious hold time failures, designers must permit much clock skew. Sometimes flip-flops intentionally designed particularly slow (i.e., large tccq), prevent hold time problems even clock skew substantial. Example 3.11 TIMING ANALYSIS CLOCK SKEW Revisit Example 3.9 assume system 50 ps clock skew. Solution: critical path remains same, setup time effectively increased skew. Hence, minimum cycle time (3.22) maximum clock frequency fc/H110051/Tc/H110053.33 GHz. short path also remains 55 ps. hold time effectively increased skew 60 /H1100150/H11005110 ps, much greater 55 ps. Hence, circuit violate hold time malfunction frequency. circuit violated hold time constraint even without skew. Skew system makes violation worse./H11005 80 /H11001 3/H1100340 /H11001 50 /H11001 50 /H11005 300 psTc/H11350tpcq/H110013tpd/H11001tsetup/H11001tskew tcd/H11350thold/H11001tskew/H11002tccqtccq/H11001tcd/H11350thold/H11001tskew142 CHAPTER THREE Sequential Logic Design tcd holdQ1 D2 skewCLCLK2 CLK1 R1 R 2Q1 D2 CLK2CLK1 tccqFigure 3.47 Hold time constraint clock skewChapter 03.qxd 1/27/07 10:24 Page 142Example 3.12 FIXING HOLD TIME VIOLATIONS Revisit Example 3.10 assume system 50 ps clock skew. Solution: critical path unaffected, maximum clock frequency remains 3.33 GHz. short path increases 80 ps. still less thold/H11001tskew /H11005110 ps, circuit still violates hold time constraint. fix problem, even buffers could inserted. Buffers would need added critical path well, reducing clock frequency. Alternatively, better flip-flop shorter hold time might used. 3.5.4 Metastability noted earlier, always possible guarantee input sequential circuit stable aperture time, especially input arrives external world. Consider button connected input flip-flop, shown Figure 3.48. button pressed, D/H110050. button pressed, D/H110051. monkey presses button random time relative rising edge CLK. want know output Qafter rising edge CLK. Case I, button pressed much CLK, Q /H110051. Case II, button pressed long CLK, Q /H110050. Case III, button pressed sometime tsetupbefore CLK tholdafter CLK, input violates dynamic discipline output undefined. Metastable State reality, flip-flop samples input changing aperture, output Qmay momentarily take voltage 0 VDDthat forbidden zone. called metastable state. Eventually, flip-flop resolve output stable state either 0 1. However, resolution time required reach stable state unbounded. metastable state flip-flop analogous ball sum- mit hill two valleys, shown Figure 3.49. two val- leys stable states, ball valley remain long disturbed. top hill called metastable ball would remain perfectly balanced. nothing perfect, ball eventually roll one side other. time required change occur depends nearly well balanced ball originally was. Every bistable device metastable state two stable states.3.5 Timing Sequential Logic 143 DQCLKbutton CLKtsetup thold aperture Q Q Q??? Case Case II Case III Figure 3.48 Input changing before, , aperture Chapter 03.qxd 1/27/07 10:24 Page 143Resolution Time flip-flop input changes random time clock cycle, resolution time, tres, required resolve stable state also random variable. input changes outside aperture, tres/H11005tpcq. input happens change within aperture, trescan substantially longer. Theoretical experimental analyses (see Section 3.5.6) shown probability resolution time, tres, exceeds arbitrary time, t,decreases exponentially t: (3.23) Tcis clock period, T0and /H9270are characteristic flip- flop. equation valid tsubstantially longer tpcq. Intuitively, T0/Tcdescribes probability input changes bad time (i.e., aperture time); probability decreases cycle time, Tc. /H9270is time constant indicating fast flip-flop moves away metastable state; related delay cross-coupled gates flip-flop. summary, input bistable device flip-flop changes aperture time, output may take metastable value time resolving stable 0 1. amount time required resolve unbounded, finite time, t,the probability flip-flop still metastable nonzero. However, probability drops exponentially tincreases. Therefore, wait long enough, much longer tpcq, expect exceedingly high probability flip-flop reach valid logic level. 3.5.5 Synchronizers Asynchronous inputs digital systems real world inevitable. Human input asynchronous, example. handled care- lessly, asynchronous inputs lead metastable voltages within system, causing erratic system failures extremely difficult track correct. goal digital system designer ensure that, given asynchronous inputs, prob- ability encountering metastable voltage sufficiently small. “Sufficiently” depends context. digital cell phone, perhaps one failure 10 years acceptable, user always turn phone back locks up. medical device, one fail- ure expected life universe (1010years) better target. guarantee good logic levels, asynchronous inputs passed synchronizers.P(tres/H11022t) /H11005T0 Tc e/H11002t /H9270144 CHAPTER THREE Sequential Logic Design metastable stable stable Figure 3.49 Stable metastable statesChapter 03.qxd 1/27/07 10:24 Page 144A synchronizer, shown Figure 3.50, device receives asynchronous input, D,and clock, CLK. produces output, Q, within bounded amount time; output valid logic level extremely high probability. Dis stable aperture, Qshould take value D.If Dchanges aperture, Qmay take either HIGH LOW value must metastable. Figure 3.51 shows simple way build synchronizer two flip-flops. F1 samples rising edge CLK. Dis changing time, output D2 may momentarily metastable. clock period long enough, D2 will, high probability, resolve valid logic level end period. F2 samples D2, stable, producing good output Q. say synchronizer failsif Q,the output synchronizer, becomes metastable. may happen D2 resolved valid level time must setup F2—that is, tres/H11022Tc/H11002tsetup. According Equation 3.23, probability failure single input change random time (3.24) probability failure, P(failure), probability output, Q,will metastable upon single change D.If Dchanges per second, probability failure per second P(failure). However, Dchanges Ntimes per second, probability failure per second Ntimes great: (3.25) P(failure)/sec /H11005N T0 Tc e/H11002Tc/H11002tsetup /H9270P(failure) /H11005T0 Tc e/H11002Tc/H11002tsetup /H92703.5 Timing Sequential Logic 145 QCLKSYNC Figure 3.50 Synchronizer symbol QD2Q D2Tc setup pcqCLK CLK CLK resmetastableF1 F2 Figure 3.51 Simple synchronizerChapter 03.qxd 1/27/07 10:24 Page 145System reliability usually measured mean time failures (MTBF ). name might suggest, MTBF average amount time failures system. reciprocal probability system fail given second (3.26) Equation 3.26 shows MTBF improves exponentially synchronizer waits longer time, Tc. systems, synchro- nizer waits one clock cycle provides safe MTBF. exception- ally high-speed systems, waiting cycles may necessary. Example 3.13 SYNCHRONIZER FSM INPUT traffic light controller FSM Section 3.4.1 receives asynchronous inputs traffic sensors. Suppose synchronizer used guarantee stable inputs controller. Traffic arrives average 0.2 times per second. flip- flops synchronizer following characteristics: /H9270/H11005200 ps, T0/H11005 150 ps, tsetup /H11005500 ps. long must synchronizer clock period MTBF exceed 1 year? Solution: 1 year /H11015/H9266/H11003107seconds. Solve Equation 3.26. (3.27) equation closed form solution. However, easy enough solve guess check. spreadsheet, try values Tcand calculate MTBF discovering value Tcthat gives MTBF 1 year: Tc/H110053.036 ns. 3.5.6 Derivation Resolution Time* Equation 3.23 derived using basic knowledge circuit theory, differential equations, probability. section skipped interested derivation unfamiliar mathematics. flip-flop output metastable time, t,if flip- flop samples changing input (causing metastable condition) output resolve valid level within time clock edge. Symbolically, expressed (3.28) P(tres/H11022t)/H11005P(samples changing input) /H11003P(unresolved)/H9266/H11003107/H11005Tce Tc/H11002500/H1100310/H1100212 200/H1100310/H1100212 (0.2)(150 /H1100310/H1154612)MTBF /H110051 P(failure)/sec /H11005Tc eTc /H11002 tsetup /H9270 NT0146 CHAPTER THREE Sequential Logic DesignChapter 03.qxd 1/27/07 10:24 Page 146We consider probability term individually. asynchronous input signal switches 0 1 time, tswitch, shown Figure 3.52. probability input changes aperture around clock edge (3.29) flip-flop enter metastability—that is, probability P(samples changing input)—the time resolve metastability depends inner workings circuit. resolution time deter- mines P(unresolved), probability flip-flop yet resolved valid logic level time t.The remainder section analyzes simple model bistable device estimate probability. bistable device uses storage positive feedback. Figure 3.53(a) shows feedback implemented pair inverters; circuit’s behavior representative bistable elements. pair inverters behaves like buffer. Let us model symmetric DC transfer characteristics shown Figure 3.53(b), slope G.The buffer deliver finite amount output current; model output resistance, R.All real circuits also capacitance, C,that must charged up. Charging capacitor resistor causes RC delay, preventing buffer switching instantaneously. Hence, complete circuit model shown Figure 3.53(c), vout(t) voltage interest conveying state bistable device. metastable point circuit vout(t)/H11005vin(t)/H11005VDD/2; circuit began exactly point, would remain indefinitely theP(samples changing input) /H11005tswitch /H11001tsetup/H11001thold Tc3.5 Timing Sequential Logic 147 CLK DTc tswitchtsetuptholdFigure 3.52 Input timing (a)v(t)vout(t) R C (c)v in(t) i(t ) G (b)vinvout slope = G VDD0VDD VDD/2VDD/2ΔV Figure 3.53 Circuit model bistable deviceChapter 03.qxd 1/27/07 10:24 Page 147absence noise. voltages continuous variables, chance circuit begin exactly metastable point vanishingly small. However, circuit might begin time 0 near metastability vout(0)/H11005 VDD/2/H11001/H9004Vfor small offset /H9004V.In case, positive feedback eventually drive vout(t) VDDif /H9004V/H110220 0 /H9004V/H110210. time required reach VDDor 0 resolution time bistable device. DC transfer characteristic nonlinear, appears linear near metastable point, region interest us. Specifically, vin(t)/H11005VDD/2/H11001/H9004V/G,then vout(t)/H11005VDD/2/H11001/H9004Vfor small /H9004V.The current resistor i(t)/H11005(vout(t)/H11002vin(t))/R.The capacitor charges rate vin(t)/dt/H11005i(t)/C.Putting facts together, find governing equation output voltage. (3.30) linear first-order differential equation. Solving initial condition vout(0)/H11005VDD/2/H11001/H9004Vgives (3.31) Figure 3.54 plots trajectories vout(t) given various starting points. vout(t) moves exponentially away metastable point VDD/2 saturates VDDor 0. output voltage eventually resolves 1 0. amount time takes depends initial voltage offset ( /H9004V) metastable point ( VDD/2). Solving Equation 3.31 resolution time tres, vout(tres) /H11005VDDor 0, gives (3.32) (3.33) tres/H11005RC G/H110021lnVDD 2|/H9004V||/H9004V|e (G/H110021)tres RC/H11005VDD 2vout (t)/H11005VDD 2/H11001/H9004Ve (G/H110021)t RCdvout(t) dt /H11005(G/H110021) RC /H20900 vout(t)/H11002VDD 2 /H20901148 CHAPTER THREE Sequential Logic Design 0VDD/2VDD tvout(t) Figure 3.54 Resolution trajectoriesChapter 03.qxd 1/27/07 10:24 Page 148In summary, resolution time increases bistable device high resistance capacitance causes output change slowly. decreases bistable device high gain, G.The resolution time also increases logarithmically circuit starts closer metastable point ( /H9004V→0). Define /H9270as . Solving Equation 3.33 /H9004Vfinds initial offset, /H9004Vres, gives particular resolution time, tres: (3.34) Suppose bistable device samples input chang- ing. measures voltage, vin(0), assume uniformly dis- tributed 0 VDD. probability output resolved legal value time tresdepends probability initial offset sufficiently small. Specifically, initial offset vout must less /H9004Vres, initial offset vinmust less /H9004Vres/G.Then probability bistable device samples input time obtain sufficiently small initial offset (3.35) Putting together, probability resolution time exceeds time, t,is given following equation: (3.36) Observe Equation 3.36 form Equation 3.23, T0/H11005(tswitch /H11001tsetup /H11001thold)/Gand /H9270/H11005RC/(G/H110021). summary, derived Equation 3.23 shown T0and /H9270depend physi- cal properties bistable device. 3.6 PARALLELISM speed system measured latency throughput tokens moving system. define token group inputs processed produce group outputs. term conjures notion placing subway tokens circuit diagram moving around visualize data moving circuit. latency sys- tem time required one token pass system start end. throughput number tokens pro- duced per unit time.P/H20898tres/H11022t/H20899/H11005tswitch /H11001tsetup /H11001thold GTce/H11002t /H9270P(unresolved) /H11005P/H20898/H20919vin(0)/H11002VDD 2/H20919/H11021 /H9004Vres G/H20899/H110052/H9004Vres GVDD/H9004Vres/H11005VDD 2e/H11002tres//H9270RC G/H1100213.6 Parallelism 149Chapter 03.qxd 1/27/07 10:24 Page 149Example 3.14 COOKIE THROUGHPUT LATENCY Ben Bitdiddle throwing milk cookies party celebrate installation traffic light controller. takes 5 minutes roll cookies place tray. takes 15 minutes cookies bake oven. cookies baked, starts another tray. Ben’s throughput latency tray cookies? Solution: example, tray cookies token. latency 1/3 hour per tray. throughput 3 trays/hour. might imagine, throughput improved processing several tokens time. called parallelism, comes two forms: spatial temporal. spatial parallelism, multiple copies hardware provided multiple tasks done time. temporal parallelism, task broken stages, like assembly line. Multiple tasks spread across stages. Although task must pass stages, different task stage given time multiple tasks overlap. Temporal paral- lelism commonly called pipelining. Spatial parallelism sometimes called parallelism, avoid naming convention ambiguous. Example 3.15 COOKIE PARALLELISM Ben Bitdiddle hundreds friends coming party needs bake cookies faster. considering using spatial and/or temporal parallelism. Spatial Parallelism : Ben asks Alyssa P. Hacker help out. cookie tray oven. Temporal Parallelism : Ben gets second cookie tray. puts one cookie tray oven, starts rolling cookies tray rather waiting first tray bake. throughput latency using spatial parallelism? Using temporal parallelism? Using both? Solution: latency time required complete one task start finish. cases, latency 1/3 hour. Ben starts cookies, latency time needed produce first cookie tray. throughput number cookie trays per hour. spatial parallelism, Ben Alyssa complete one tray every 20 minutes. Hence, throughput doubles, 6 trays/hour. temporal parallelism, Ben puts new tray oven every 15 minutes, throughput 4 trays/hour. illustrated Figure 3.55. Ben Alyssa use techniques, bake 8 trays/hour.150 CHAPTER THREE Sequential Logic Design Chapter 03.qxd 1/27/07 10:24 Page 150Consider task latency L.In system parallelism, throughput 1/ L.In spatially parallel system Ncopies hardware, throughput N/L.In temporally parallel system, task ideally broken Nsteps, stages, equal length. case, throughput also N/L,and one copy hardware required. However, cookie example showed, finding Nsteps equal length often impractical. longest step latency L1, pipelined throughput 1/ L1. Pipelining (temporal parallelism) particularly attractive speeds circuit without duplicating hardware. Instead, registers placed blocks combinational logic divide logic shorter stages run faster clock. registers prevent token one pipeline stage catching corrupting token next stage. Figure 3.56 shows example circuit pipelining. con- tains four blocks logic registers. critical path passes blocks 2, 3, 4. Assume register clock-to- Q propagation delay 0.3 ns setup time 0.2 ns. cycle time Tc/H110050.3/H110013/H110012/H110014/H110010.2/H110059.5 ns. circuit latency 9.5 ns throughput 1/9.5 ns /H11005105 MHz. Figure 3.57 shows circuit partitioned two-stage pipeline adding register blocks 3 4. first stage minimum clock period 0.3 /H110013/H110012/H110010.2/H110055.5 ns. second3.6 Parallelism 151 Spatial Parallelism Temporal Parallelism Ben 1 Ben 1Roll Bake Ben 2 Ben 2 Ben 3 Ben 3Ben 1 Ben 1 Alyssa 1 Alyssa 1 Ben 2 Ben 2 Alyssa 2 Alyssa 2Time0 5 10 15 20 25 30 35 40 45 50 Tray 1 Tray 2 Tray 3 Tray 4Latency: time first tray Legend Tray 1 Tray 2 Tray 3 Figure 3.55 Spatial temporal parallelism cookie kitchenChapter 03.qxd 1/27/07 10:24 Page 151stage minimum clock period 0.3 /H110014/H110010.2/H110054.5 ns. clock must slow enough stages work. Hence, Tc/H110055.5 ns. latency two clock cycles, 11 ns. throughput 1/5.5 ns /H11005182 MHz. example shows that, real circuit, pipelining two stages almost doubles throughput slightly increases latency. comparison, ideal pipelining would exactly double throughput penalty latency. discrepancy comes circuit cannot divided two exactly equal halves registers introduce sequencing overhead. Figure 3.58 shows circuit partitioned three-stage pipeline. Note two registers needed store results blocks 1 2 end first pipeline stage. cycle time limited third stage 4.5 ns. latency three cycles, 13.5 ns. throughput 1/4.5 ns /H11005222 MHz. Again, adding pipeline stage improves throughput expense latency. Although techniques powerful, apply situations. bane parallelism dependencies. current task is152 CHAPTER THREE Sequential Logic Design CL CL CL CLCLK CLK pd 1 = 2.4 ns pd 2 = 3 nst pd 3 = 2 ns pd 4 = 4 ns1 234 Stage 1: 5.5 ns Stage 2: 4.5 nsCLK Figure 3.57 Circuit two- stage pipeline CL CL CL CLCLK CLK tpd 1 = 2.4 ns tpd 2 = 3 nstpd 3 = 2 ns tpd 4 = 4 ns1 234 Stage 1: 3.5 ns Stage 3: 4.5 nsCLK CLK Stage 2: 2.5 nsFigure 3.58 Circuit three- stage pipelineCL CL CL CLCLK CLK tpd1= 2.4 ns tpd2= 3 nstpd3= 2 ns tpd4= 4 ns1 234 Tc= 9.5 nsFigure 3.56 Circuit pipeliningChapter 03.qxd 1/27/07 10:24 Page 152dependent result prior task, rather prior steps current task, task cannot start prior task com- pleted. example, Ben wants check first tray cookies tastes good starts preparing second, dependency prevents pipelining parallel operation. Parallelism one important techniques designing high-performance micro- processors. Chapter 7 discusses pipelining shows examples handling dependencies. 3.7 SUMMARY chapter described analysis design sequential logic. contrast combinational logic, whose outputs depend cur- rent inputs, sequential logic outputs depend current prior inputs. words, sequential logic remembers information prior inputs. memory called state logic. Sequential circuits difficult analyze easy design incorrectly, limit small set carefully designed building blocks. important element purposes flip-flop, receives clock input, D,and produces out- put,Q.The flip-flop copies Dto Qon rising edge clock otherwise remembers old state Q.A group flip-flops sharing common clock called register. Flip-flops may also receive reset enable control signals. Although many forms sequential logic exist, discipline our- selves use synchronous sequential circuits easy design. Synchronous sequential circuits consist blocks combina- tional logic separated clocked registers. state circuit stored registers updated clock edges. Finite state machines powerful technique designing sequen- tial circuits. design FSM, first identify inputs outputs machine sketch state transition diagram, indicating states transitions them. Select encoding states, rewrite diagram state transition table output table, indicat- ing next state output given current state input. tables, design combinational logic compute next state output, sketch circuit. Synchronous sequential circuits timing specification including clock-to- Qpropagation contamination delays, tpcqand tccq, setup hold times, tsetup thold. correct operation, inputs must stable aperture time starts setup time rising edge clock ends hold time rising edge clock. minimum cycle time, Tc, system equal propagation delay, tpd, combinational logic plus3.7 Summary 153 Anyone could invent logic whose outputs depend future inputs would fabulously wealthy!Chapter 03.qxd 1/27/07 10:24 Page 153154 CHAPTER THREE Sequential Logic Design tpcq/H11001tsetup register. correct operation, contamination delay register combinational logic must greater thold. Despite common misconception contrary, hold time affect cycle time. Overall system performance measured latency throughput. latency time required token pass start end. throughput number tokens system process per unit time. Parallelism improves system throughput.Chapter 03.qxd 1/27/07 10:24 Page 154Exercises 155 Exercises Exercise 3.1 Given input waveforms shown Figure 3.59, sketch out- put, Q,of SR latch. R Figure 3.59 Input waveform SR latch Exercise 3.2 Given input waveforms shown Figure 3.60, sketch out- put, Q,of latch. Exercise 3.3 Given input waveforms shown Figure 3.60, sketch out- put, Q,of flip-flop. Exercise 3.4 circuit Figure 3.61 combinational logic sequential logic? Explain simple fashion relationship inputs outputs. would call circuit? Exercise 3.5 circuit Figure 3.62 combinational logic sequential logic? Explain simple fashion relationship inputs outputs. would call circuit?CLK Figure 3.60 Input waveform latch flip-flop RQ Q Figure 3.61 Mystery circuitChapter 03.qxd 1/27/07 10:24 Page 155156 CHAPTER THREE Sequential Logic Design Exercise 3.6 toggle (T) flip-flop one input, CLK, one output, Q. rising edge CLK, Q toggles complement previous value. Draw schematic flip-flop using flip-flop inverter. Exercise 3.7 JK flip-flop receives clock two inputs, Jand K. rising edge clock, updates output, Q.If Jand Kare 0, Qretains old value. Jis 1, Qbecomes 1. Kis 1, Qbecomes 0. Jand Kare 1, Qbecomes opposite present state. (a) Construct JK flip-flop using flip-flop combinational logic. (b) Construct flip-flop using JK flip-flop combinational logic. (c) Construct flip-flop (see Exercise 3.6) using JK flip-flop. Exercise 3.8 circuit Figure 3.63 called Muller C-element. Explain simple fashion relationship inputs output.Q QS RS R DRCLK Figure 3.62 Mystery circuit ABA B Cweak Figure 3.63 Muller C-element Exercise 3.9 Design asynchronously resettable latch using logic gates. Exercise 3.10 Design asynchronously resettable flip-flop using logic gates. Exercise 3.11 Design synchronously settable flip-flop using logic gates.Chapter 03.qxd 1/27/07 10:24 Page 156Exercises 157 Exercise 3.12 Design asynchronously settable flip-flop using logic gates. Exercise 3.13 Suppose ring oscillator built Ninverters connected loop. inverter minimum delay tcdand maximum delay tpd. Nis odd, determine range frequencies oscillator might operate. Exercise 3.14 must Nbe odd Exercise 3.13? Exercise 3.15 circuits Figure 3.64 synchronous sequential circuits? Explain. Exercise 3.16 designing elevator controller building 25 floors. controller two inputs: UPand . produces output indicating floor elevator on. floor 13. min- imum number bits state controller? Exercise 3.17 designing FSM keep track mood four stu- dents working digital design lab. student’s mood either HAPPY (the circuit works), SAD (the circuit blew up), BUSY (working circuit), CLUELESS (confused circuit), ASLEEP (face circuit board). many states FSM have? minimum number bits necessary represent states? Exercise 3.18 would factor FSM Exercise 3.17 multiple simpler machines? many states simpler machine have? minimum total number bits necessary factored design?(a)CL CL CLK CL CLCL CLCLKCL (b) (c) (d)CL CLCLK Figure 3.64 CircuitsChapter 03.qxd 1/27/07 10:24 Page 157Exercise 3.19 Describe words state machine Figure 3.65 does. Using binary state encodings, complete state transition table output table FSM. Write Boolean equations next state output sketch schematic FSM. Exercise 3.20 Describe words state machine Figure 3.66 does. Using binary state encodings, complete state transition table output table FSM. Write Boolean equations next state output sketch schematic FSM. Exercise 3.21 Accidents still occurring intersection Academic Avenue Bravado Boulevard. football team rushing intersec- tion moment light Bturns green. colliding sleep-deprived CS majors stagger intersection light Aturns red. Extend traffic light controller Section 3.4.1 lights red 5 seconds either light turns green again. Sketch improved Moore machine state transition diagram, state encodings, state transition table, output table, next state output equations, FSM schematic. Exercise 3.22 Alyssa P. Hacker’s snail Section 3.4.3 daughter Mealy machine FSM brain. daughter snail smiles whenever slides pattern 1101 pattern 1110. Sketch state transition diagram happy snail using states possible. Choose state encodings write a158 CHAPTER THREE Sequential Logic Design S0 Q : 0S1 Q : 0S2 Q : 1Reset AB AB Figure 3.65 State transition diagram S0 S1 S2Reset /0 B /0 /0B /0AB/1 + B/0 Figure 3.66 State transition diagramChapter 03.qxd 1/27/07 10:24 Page 158Exercises 159 combined state transition output table using encodings. Write next state output equations sketch FSM schematic. Exercise 3.23 enlisted design soda machine dispenser department lounge. Sodas partially subsidized student chapter IEEE, cost 25 cents. machine accepts nickels, dimes, quarters. enough coins inserted, dispenses soda returns necessary change. Design FSM controller soda machine. FSM inputs Nickel , Dime , Quarter , indicating coin inserted. Assume exactly one coin inserted cycle. outputs Dispense , ReturnNickel , ReturnDime , ReturnTwoDimes . FSM reaches 25 cents, asserts Dispense necessary Return outputs required deliver appropriate change. ready start accepting coins another soda. Exercise 3.24 Gray codes useful property consecutive numbers differ single bit position. Table 3.17 lists 3-bit Gray code representing numbers 0 7. Design 3-bit modulo 8 Gray code counter FSM inputs three outputs. (A modulo Ncounter counts 0 N/H110021, repeats. example, watch uses modulo 60 counter minutes sec- onds counts 0 59.) reset, output 000. clock edge, output advance next Gray code. reaching 100, repeat 000. Table 3.17 3-bit Gray code Number Gray code 00 0 0 10 0 1 20 1 1 30 1 0 41 1 0 51 1 1 61 0 1 71 0 0 Exercise 3.25 Extend modulo 8 Gray code counter Exercise 3.24 UP/DOWN counter adding UPinput. UP/H110051, counter advances next number. UP/H110050, counter retreats previous number.Chapter 03.qxd 1/27/07 10:24 Page 159Exercise 3.26 company, Detect-o-rama, would like design FSM takes two inputs, Aand B,and generates one output, Z.The output cycle n, Zn, either Boolean corresponding input Anand pre- vious input An/H110021, depending input, Bn: (a) Sketch waveform Zgiven inputs shown Figure 3.67. (b) FSM Moore Mealy machine? (c) Design FSM. Show state transition diagram, encoded state transi- tion table, next state output equations, schematic. Zn/H11005 An/H11001An/H110021 Bn/H110051 Zn/H11005 An/H110021 Bn /H11005 0160 CHAPTER THREE Sequential Logic Design CLK B Figure 3.67 FSM input waveforms Exercise 3.27 Design FSM one input, A,and two outputs, Xand Y. X 1 Ahas 1 least three cycles altogether (not necessarily consecutively). Yshould 1 Ahas 1 least two consecutive cycles. Show state transition diagram, encoded state transition table, next state output equations, schematic. Exercise 3.28 Analyze FSM shown Figure 3.68. Write state transition output tables sketch state transition diagram. Describe words FSM does. CLK CLKX Q Figure 3.68 FSM schematicChapter 03.qxd 1/27/07 10:24 Page 160Exercises 161 Exercise 3.29 Repeat Exercise 3.28 FSM shown Figure 3.69. Recall rand sregister inputs indicate set reset, respectively. Exercise 3.30 Ben Bitdiddle designed circuit Figure 3.70 compute registered four-input XOR function. two-input XOR gate propaga- tion delay 100 ps contamination delay 55 ps. flip-flop setup time 60 ps, hold time 20 ps, clock-to- Qmaximum delay 70 ps, clock-to- Qminimum delay 50 ps. (a) clock skew, maximum operating frequency circuit? (b) much clock skew circuit tolerate must operate 2 GHz? (c) much clock skew circuit tolerate might experience hold time violation? (d) Alyssa P. Hacker points redesign combinational logic registers faster andtolerate clock skew. improved circuit also uses three two-input XORs, arranged differently. circuit? maximum frequency clock skew? much clock skew circuit tolerate might experience hold time violation?CLK ACLK CLK Q resetr rs Figure 3.69 FSM schematic CLK CLK Figure 3.70 Registered four-input XOR circuit Exercise 3.31 designing adder blindingly fast 2-bit RePentium Processor. adder built two full adders carry first adder carry second adder, shown Figure 3.71. adder input output registers must complete theChapter 03.qxd 1/27/07 10:24 Page 161addition one clock cycle. full adder following propagation delays: 20 ps Cinto Coutor Sum (S),25 ps Aor Bto Cout, 30 ps Aor Bto S.The adder contamination delay 15 ps Cinto either output 22 ps Aor Bto either output. flip-flop setup time 30 ps, hold time 10 ps, clock-to- Qpropagation delay 35 ps, clock-to- Qcontamination delay 21 ps. (a) clock skew, maximum operating frequency circuit? (b) much clock skew circuit tolerate must operate 8 GHz? (c) much clock skew circuit tolerate might experience hold time violation? Exercise 3.32 field programmable gate array (FPGA ) uses configurable logic blocks (CLBs ) rather logic gates implement combinational logic. Xilinx Spartan 3 FPGA propagation contamination delays 0.61 0.30 ns, respectively CLB. also contains flip-flops propagation contamination delays 0.72 0.50 ns, setup hold times 0.53 0 ns, respectively. (a) building system needs run 40 MHz, many consecutive CLBs use two flip-flops? Assume clock skew delay wires CLBs. (b) Suppose paths flip-flops pass least one CLB. much clock skew FPGA without violating hold time? Exercise 3.33 synchronizer built pair flip-flops tsetup /H1100550 ps, T0/H1100520 ps, /H9270/H1100530 ps. samples asynchronous input changes 108 times per second. minimum clock period synchronizer achieve mean time failures (MTBF) 100 years?162 CHAPTER THREE Sequential Logic Design BC CoutS BC CoutSCLK C A0 B0 A1 B1S0 S1CLK Figure 3.71 2-bit adder schematicChapter 03.qxd 1/27/07 10:24 Page 162Exercises 163 Exercise 3.34 would like build synchronizer receive asynchronous inputs MTBF 50 years. system running 1 GHz, use sampling flip-flops /H9270/H11005100 ps, T0/H11005110 ps, tsetup /H1100570 ps. synchronizer receives new asynchronous input average 0.5 times per second (i.e., every 2 seconds). required probability failure satisfy MTBF? many clock cycles would wait reading sampled input signal give probability error? Exercise 3.35 walking hallway run lab partner walking direction. two first step one way still other’s way. step way still other’s way. wait bit, hoping person step aside. model situation metastable point apply theory applied synchronizers flip-flops. Suppose create mathematical model lab partner. start unfortunate encounter metastable state. probability remain state tseconds . /H9270indicates response rate; today, brain blurred lack sleep /H9270/H1100520 seconds. (a) long 99% certainty resolved metastability (i.e., figured pass one another)? (b) sleepy, also ravenously hungry. fact, starve death don’t get going cafeteria within 3 minutes. probability lab partner drag morgue? Exercise 3.36 built synchronizer using flip-flops T0/H1100520 ps /H9270/H1100530 ps. boss tells need increase MTBF fac- tor 10. much need increase clock period? Exercise 3.37 Ben Bitdiddle invents new improved synchronizer Figure 3.72 claims eliminates metastability single cycle. explains circuit box Mis analog “metastability detector” produces HIGH output input voltage forbidden zone VILand VIH. metastability detector checks determinee/H11002t /H9270 CLK DrCLK Q MD2 Figure 3.72 “New improved” synchronizerChapter 03.qxd 1/27/07 10:24 Page 163164 CHAPTER THREE Sequential Logic Design whether first flip-flop produced metastable output D2. so, asynchronously resets flip-flop produce good 0 D2. second flip-flop samples D2, always producing valid logic level Q. Alyssa P. Hacker tells Ben must bug circuit, eliminating metastability impossible building perpetual motion machine. right? Explain, showing Ben’s error showing Alyssa wrong.Chapter 03.qxd 1/27/07 10:24 Page 164Interview Questions following exercises present questions asked interviews digital design jobs. Question 3.1 Draw state machine detect received serial input sequence 01010. Question 3.2 Design serial (one bit time) two’s complementer FSM two inputs, Start A,and one output, Q.A binary number arbitrary length provided input A,starting least significant bit. corresponding bit output appears Qon cycle. Start asserted one cycle initialize FSM least significant bit provided. Question 3.3 difference latch flip-flop? circumstances one preferable? Question 3.4 Design 5-bit counter finite state machine. Question 3.5 Design edge detector circuit. output go HIGH one cycle input makes 0 →1 transition. Question 3.6 Describe concept pipelining used. Question 3.7 Describe means flip-flop negative hold time. Question 3.8 Given signal A,shown Figure 3.73, design circuit produces signal B.Interview Questions 165 B Figure 3.73 Signal waveforms Question 3.9 Consider block logic two registers. Explain timing constraints. add buffer clock input receiver (the second flip-flop), setup time constraint get better worse?Chapter 03.qxd 1/27/07 10:24 Page 1654 4.1 Introduction 4.2 Combinational Logic 4.3 Structural Modeling 4.4 Sequential Logic 4.5 Combinational Logic 4.6 Finite State Machines 4.7 Parameterized Modules* 4.8 Testbenches 4.9 Summary Exercises Interview QuestionsHardware Description Languages 4.1 INTRODUCTION Thus far, focused designing combinational sequential digital circuits schematic level. process finding efficient set logic gates perform given function labor intensive error prone, requiring manual simplification truth tables Boolean equa- tions manual translation finite state machines (FSMs) gates. 1990’s, designers discovered far productive worked higher level abstraction, specifying logical function allowing computer-aided design (CAD ) tool produce optimized gates. specifications generally given hardware description language (HDL ). two leading hardware description lan- guages Verilog VHDL. Verilog VHDL built similar principles different syntax. Discussion languages chapter divided two columns literal side-by-side comparison, Verilog left VHDL right. read chapter first time, focus one language other. know one, you’ll quickly master need it. Subsequent chapters show hardware schematic HDL form. choose skip chapter learn one HDLs, still able master principles computer organization schematics. However, vast majority commercial systems built using HDLs rather schematics. expect digital design point professional life, urge learn one HDLs. 4.1.1 Modules block hardware inputs outputs called module. gate, multiplexer, priority circuit examples hardware modules. two general styles describing module functionality 167Chapter 04.qxd 1/31/07 8:17 PM Page 167behavioral structural. Behavioral models describe module does. Structural models describe module built simpler pieces; application hierarchy. Verilog VHDL code HDL Example 4.1 illustrate behavioral descriptions module computes Boolean function Example 2.6, languages, module named sillyfunction three inputs, a, b,and c,and one output, y.y/H11005abc/H11001abc/H11001abc.168 CHAPTER FOUR Hardware Description Languages Verilog module sillyfunction(input a, b, c, output y); assign /H11005~a & ~b & ~c | & ~b & ~c | & ~b & c; endmodule Verilog module begins module name listing inputs outputs. assign statement describes combinational logic. ~indicates NOT, &indicates AND, |indicates OR. Verilog signals inputs outputs Boolean variables (0 1). may also floating undefined values, discussed Section 4.2.8.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity sillyfunction port(a, b, c: STD_LOGIC; y: STD_LOGIC); end; architecture synth sillyfunction begin /H11021/H11005((not a) (not b) (not c)) (a (not b) (not c)) (a (not b) c); end; VHDL code three parts: library use clause, entity declaration, architecture body. library use clause required discussed Section 4.2.11. entity declaration lists module name inputs outputs. architecture body defines module does. VHDL signals, inputs outputs, must type declaration. Digital signals declared STD_LOGIC type. STD_LOGIC signals value ‘0’ ‘1’, well floating undefined values described Section 4.2.8. STD_LOGIC type defined IEEE.STD_LOGIC_1164 library, library must used. VHDL lacks good default order operations, Boolean equations parenthesized.HDL Example 4.1 COMBINATIONAL LOGIC module, might expect, good application modularity. well defined interface, consisting inputs outputs, performs specific function. particular way coded unimportant others might use module, long performs function. 4.1.2 Language Origins Universities almost evenly split languages taught first course, industry similarly split language pre- ferred. Compared Verilog, VHDL verbose cumbersome,Chapter 04.qxd 1/31/07 8:17 PM Page 168as might expect language developed committee. U.S. military contractors, European Space Agency, telecommunications compa- nies use VHDL extensively. languages fully capable describing hardware system, quirks. best language use one already used site one customers demand. CAD tools today allow two languages mixed, dif- ferent modules described different languages. 4.1.3 Simulation Synthesis two major purposes HDLs logic simulation synthesis. simulation, inputs applied module, outputs checked verify module operates correctly. synthesis, textual description module transformed logic gates. Simulation Humans routinely make mistakes. errors hardware designs called bugs. Eliminating bugs digital system obviously impor- tant, especially customers paying money lives depend correct operation. Testing system laboratory time-consuming. Discovering cause errors lab extremely difficult, signals routed chip pins observed. way directly observe happening inside chip. Correcting errors system built devastatingly expensive. example, correcting mistake cutting-edge integrated circuit costs million dollars takes several months. Intel’s infamous FDIV (floating point division) bug Pentium processor forced company recall chips shipped, total cost $475 million. Logic simula- tion essential test system built.4.1 Introduction 169 term “bug” predates invention computer. Thomas Edison called “lit- tle faults difficulties” inventions “bugs” 1878. first real computer bug moth, got caught relays Harvard Mark II electro- mechanical computer 1947. found Grace Hopper, logged incident, along moth comment “first actual case bug found.” Source : Notebook entry cour- tesy Naval Historical Center, US Navy; photo No. NII 96566-KN 1The Institute Electrical Electronics Engineers (IEEE) professional society responsible many computing standards including WiFi (802.11), Ethernet (802.3), floating-point numbers (754) (see Chapter 5).VHDL VHDL acronym VHSIC Hardware Description Language. VHSIC turn acronym High Speed Integrated Circuits program US Department Defense. VHDL originally developed 1981 Depart- ment Defense describe structure function hardware. roots draw Ada programming lan- guage. IEEE standardized 1987 (IEEE STD 1076) updated standard several times since. lan- guage first envisioned documentation quickly adopted simulation synthesis.Verilog Verilog developed Gateway Design Automation proprietary language logic simulation 1984. Gateway acquired Cadence 1989 Verilog made open standard 1990 control Open Verilog International. language became IEEE standard1in 1995 (IEEE STD 1364) updated 2001. Chapter 04.qxd 1/31/07 8:17 PM Page 169Figure 4.1 shows waveforms simulation2of previous sillyfunction module demonstrating module works correctly. yis TRUE a, b,and care 000, 100, 101, specified Boolean equation. Synthesis Logic synthesis transforms HDL code netlist describing hard- ware (e.g., logic gates wires connecting them). logic syn- thesizer might perform optimizations reduce amount hardware required. netlist may text file, may drawn schematic help visualize circuit. Figure 4.2 shows results synthesizing sillyfunction module.3Notice three three- input gates simplified two two-input gates, discovered Example 2.6 using Boolean algebra. Circuit descriptions HDL resemble code programming language. However, must remember code intended represent hardware. Verilog VHDL rich languages many commands. commands synthesized hard- ware. example, command print results screen sim- ulation translate hardware. primary interest is170 CHAPTER FOUR Hardware Description Languages 0 ns 00 aNow: 800 ns b c y00320 ns 480 800 640 ns 160 Figure 4.1 Simulation waveforms un5_y un8_yyy cb aFigure 4.2 Synthesized circuit 2The simulation performed Xilinx ISE Simulator, part Xilinx ISE 8.2 software. simulator selected used commercially, yet freely available universities. 3Synthesis performed Synplify Pro Synplicity. tool selected leading commercial tool synthesizing HDL field-programmable gate arrays (see Section 5.6.2) available inexpensively universities.Chapter 04.qxd 1/31/07 8:17 PM Page 170to build hardware, emphasize synthesizable subset lan- guages. Specifically, divide HDL code synthesizable modules testbench. synthesizable modules describe hardware. testbench contains code apply inputs module, check whether output results correct, print discrepancies expected actual outputs. Testbench code intended simulation cannot synthesized. One common mistakes beginners think HDL computer program rather shorthand describing digital hardware. don’t know approximately hardware HDL synthesize into, probably won’t like get. might create far hardware necessary, might write code simulates correctly cannot implemented hardware. Instead, think system terms blocks combinational logic, registers, finite state machines. Sketch blocks paper show connected start writing code. experience, best way learn HDL example. HDLs specific ways describing various classes logic; ways called idioms. chapter teach write proper HDL idioms type block put blocks together produce working system. need describe particular kind hardware, look similar example adapt purpose. attempt rigorously define syntax HDLs, deathly boring tends encourage thinking HDLs programming languages, shorthand hardware. IEEE Verilog VHDL specifications, numerous dry exhaustive textbooks, contain details, find needing infor- mation particular topic. (See Readings section back book.) 4.2 COMBINATIONAL LOGIC Recall disciplining design synchronous sequen- tial circuits, consist combinational logic registers. out- puts combinational logic depend current inputs. section describes write behavioral models combinational logic HDLs. 4.2.1 Bitwise Operators Bitwise operators act single-bit signals multi-bit busses. example, invmodule HDL Example 4.2 describes four inverters connected 4-bit busses.4.2 Combinational Logic 171Chapter 04.qxd 1/31/07 8:17 PM Page 171The endianness bus purely arbitrary. (See sidebar Section 6.2.2 origin term.) Indeed, endianness also irrelevant example, bank inverters doesn’t care order bits are. Endianness matters operators, addition, sum one column carries next. Either ordering acceptable, long used consistently. consistently use little-endian order, [N/H110021:0] Verilog (N/H110021 downto 0) VHDL, N-bit bus. code example chapter schematic produced Verilog code Synplify Pro synthesis tool. Figure 4.3 shows inv module synthesizes bank four inverters, indicated inverter symbol labeled y[3:0] . bank inverters connects 4-bit input output busses. Similar hardware produced synthesized VHDL code. gates module HDL Example 4.3 demonstrates bitwise oper- ations acting 4-bit busses basic logic functions.172 CHAPTER FOUR Hardware Description Languages [3:0]y [3:0] a[3:0][3:0] [3:0] Figure 4.3 inv synthesized circuitVerilog module inv(input [3:0] a, output [3:0] y); assign /H11005~a; endmodule a[3:0] represents 4-bit bus. bits, significant least significant, a[3], a[2], a[1], a[0]. called little-endian order, least significant bit smallest bit number. could named bus a[4:1] , case a[4] would signifi- cant. could used a[0:3] , case bits, significant least significant, would a[0], a[1], a[2], a[3]. called big-endian order.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity inv port(a: STD_LOGIC_VECTOR(3 downto 0); y: STD_LOGIC_VECTOR(3 downto 0)); end; architecture synth inv begin /H11021/H11005not a; end; VHDL uses STD_LOGIC_VECTOR , indicate busses STD_LOGIC. STD_LOGIC_VECTOR (3 downto 0) represents 4-bit bus. bits, significant least significant, 3, 2, 1, 0. called little-endian order, least significant bit smallest bit number. could declared bus STD_LOGIC_VECTOR (4 downto 1) , case bit 4 would significant. could written STD_LOGIC_VECTOR (0 3) , case bits, significant least significant, would 0, 1, 2, 3. called big-endian order.HDL Example 4.2 INVERTERSChapter 04.qxd 1/31/07 8:17 PM Page 1724.2 Combinational Logic 173 y1[3:0] y2[3:0]y3[3:0] y4[3:0] y5[3:0]y5[3:0][3:0]y4[3:0][3:0]y3[3:0][3:0] y2[3:0][3:0]y1[3:0][3:0]b[3:0][3:0]a[3:0][3:0] [3:0][3:0][3:0] [3:0][3:0] [3:0][3:0] [3:0] Figure 4.4 gates synthesized circuitVerilog module gates(input [3:0] a, b, output [3:0] y1, y2, y3, y4, y5); /* Five different two-input logic gates acting 4 bit busses */ assign y1 /H11005a & b; // assign y2 /H11005a | b; // assign y3 /H11005a /H11625b; // XOR assign y4 /H11005~(a & b); // NAND assign y5 /H11005~(a | b); // endmodule ~,/H11625, |are examples Verilog operators, whereas a,b, y1are operands. combination operators operands, & b , ~(a | b) , called expression. complete command assign y4 /H11005~(a & b); called statement. assign /H11005in1 op in2; called continuous assign- ment statement. Continuous assignment statements end semicolon. Anytime inputs right side /H11005in continuous assignment statement change, output left side recomputed. Thus, continuous assignment statements describe combinational logic.HDL Example 4.3 LOGIC GATES VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity gates port(a, b: STD_LOGIC_VECTOR(3 downto 0); y1, y2, y3, y4, y5: STD_LOGIC_VECTOR(3 downto 0)); end; architecture synth gates begin — — Five different two-input logic gates — —acting 4 bit busses y1 /H11021/H11005a b; y2 /H11021/H11005a b; y3 /H11021/H11005a xor b; y4 /H11021/H11005a nand b; y5 /H11021/H11005a b; end; not,xor, orare examples VHDL operators, whereas a, b, y1are operands. combination operators operands, b , b , called expression. complete command y4 /H11021/H11005a nand b; called statement. /H11021/H11005in1 op in2; called concurrent signal assign- ment statement. VHDL assignment statements end semicolon. Anytime inputs right side /H11021/H11005in concurrent signal assignment statement change, output left side recomputed. Thus, concurrent signal assignment statements describe combinational logic.Chapter 04.qxd 1/31/07 8:17 PM Page 1734.2.3 Reduction Operators Reduction operators imply multiple-input gate acting single bus. HDL Example 4.4 describes eight-input gate inputs a7, a6, . . . ,a0.174 CHAPTER FOUR Hardware Description Languages Verilog Verilog comments like C Java. Comments beginning /* continue, possibly across multiple lines, next */. Comments beginning // continue end line. Verilog case-sensitive. y1and Y1are different signals Verilog.VHDL VHDL comments begin ——and continue end line. Comments spanning multiple lines must use ——at beginning line. VHDL case-sensitive. y1and Y1are sig- nal VHDL. However, tools may read file might case sensitive, leading nasty bugs blithely mix upper lower case.4.2.2 Comments White Space gates example showed format comments. Verilog VHDL picky use white space (i.e., spaces, tabs, line breaks). Nevertheless, proper indenting use blank lines helpful make nontrivial designs readable. consistent use capitalization underscores signal module names. Module signal names must begin digit. Verilog module and8(input [7:0] a, output y); assign /H11005&a; // &a much easier write // assign /H11005a[7] & a[6] & a[5] & a[4] & // a[3] & a[2] & a[1] & a[0]; endmodule one would expect, |, /H11625, ~&, ~|reduction operators available OR, XOR, NAND, well. Recall multi-input XOR performs parity, returning TRUE odd number inputs TRUE.VHDL VHDL reduction operators. Instead, pro- vides generate command (see Section 4.7). Alternatively, operation written explicitly, shown below. library IEEE; use IEEE.STD_LOGIC_1164.all; entity and8 port(a: STD_LOGIC_VECTOR(7 downto 0); y: STD_LOGIC); end; architecture synth and8 begin /H11021/H11005a(7) a(6) a(5) a(4) a(3) a(2) a(1) a(0); end;HDL Example 4.4 EIGHT-INPUT ANDChapter 04.qxd 1/31/07 8:17 PM Page 1744.2.4 Conditional Assignment Conditional assignments select output among alternatives based input called condition. HDL Example 4.5 illustrates 2:1 multiplexer using conditional assignment.4.2 Combinational Logic 175 yy a[7:0][7:0][0] [1] [2] [3] [4] [5] [6] [7] Figure 4.5 and8 synthesized circuit Verilog conditional operator ?: chooses, based first expres- sion, second third expression. first expression called condition. condition 1, operator chooses second expression. condition 0, operator chooses third expression. ?: especially useful describing multiplexer because, based first input, selects two others. fol- lowing code demonstrates idiom 2:1 multiplexer 4-bit inputs outputs using conditional operator. module mux2(input [3:0] d0, d1, input s, output [3:0] y); assign /H11005s ? d1 : d0; endmodule sis 1, y/H11005d1. sis 0, y/H11005d0. ?: also called ternary operator, takes three inputs. used purpose C Java programming languages.VHDL Conditional signal assignments perform different operations depending condition. especially useful describing multiplexer. example, 2:1 multiplexer use conditional signal assignment select one two 4-bit inputs. library IEEE; use IEEE.STD_LOGIC_1164.all; entity mux2 port(d0, d1: STD_LOGIC_VECTOR(3 downto 0); s: STD_LOGIC; y: STD_LOGIC_VECTOR(3 downto 0)); end; architecture synth mux2 begin /H11021/H11005d0 /H11005‘0’ else d1; end; conditional signal assignment sets yto d0if sis 0. Otherwise sets yto d1.HDL Example 4.5 2:1 MULTIPLEXER y[3:0]0 1y[3:0]s d1[3:0]d0[3:0][3:0] [3:0] [3:0] Figure 4.6 mux2 synthesized circuitChapter 04.qxd 1/31/07 8:17 PM Page 175HDL Example 4.6 shows 4:1 multiplexer based principle 2:1 multiplexer HDL Example 4.5. Figure 4.7 shows schematic 4:1 multiplexer produced Synplify Pro. software uses different multiplexer symbol text shown far. multiplexer multiple data ( d) one-hot enable (e) inputs. one enables asserted, associated data passed output. example, s[1] /H11005s[0] /H110050, bottom gate, un1_s_5 , produces 1, enabling bottom input multiplexer causing select d0[3:0] . 4.2.5 Internal Variables Often convenient break complex function intermediate steps. example, full adder, described Section 5.2.1,176 CHAPTER FOUR Hardware Description Languages Verilog 4:1 multiplexer select one four inputs using nested conditional operators. module mux4(input [3:0] d0, d1, d2, d3, input [1:0] s, output [3:0] y); assign /H11005s[1] ? (s[0] ? d3 : d2) : (s[0] ? d1 : d0); endmodule s[1] 1, multiplexer chooses first expression, (s[0] ? d3 : d2) . expression turn chooses either d3 d2based s[0] (y /H11005d3if s[0] 1 d2if s[0] 0). s[1] 0, multiplexer similarly chooses second expression, gives either d1or d0based s[0].VHDL 4:1 multiplexer select one four inputs using multiple else clauses conditional signal assignment. library IEEE; use IEEE.STD_LOGIC_1164.all; entity mux4 port(d0, d1, d2, d3: STD_LOGIC_VECTOR(3 downto 0); s: STD_LOGIC_VECTOR(1 downto 0); y: STD_LOGIC_VECTOR(3 downto 0)); end; architecture synthl mux4 begin /H11021/H11005d0 /H11005“00” else d1 /H11005“01” else d2 /H11005“10” else d3; end; VHDL also supports selected signal assignment statements provide shorthand selecting one several possibilities. analogous using case statement place multiple if/else statements programming languages. 4:1 multiplexer rewritten selected signal assignment follows: architecture synth2 mux4 begin select /H11021/H11005 d0 “00”, d1 “01”, d2 “10”, d3 others; end;HDL Example 4.6 4:1 MULTIPLEXERChapter 04.qxd 1/31/07 8:17 PM Page 176is circuit three inputs two outputs defined following equations: (4.1) define intermediate signals, Pand G, (4.2) rewrite full adder follows: (4.3) Pand Gare called internal variables, neither inputs outputs used internal module. similar local variables programming languages. HDL Example 4.7 shows used HDLs. HDL assignment statements ( assign Verilog /H11021/H11005in VHDL) take place concurrently. different conventional program- ming languages C Java, statements evaluated order written. conventional language, isCout/H11005G/H11001PCinS/H11005P ⊕ CinG/H11005ABP/H11005A ⊕ BCout/H11005AB/H11001ACin/H11001BCinS/H11005A ⊕ B ⊕ Cin4.2 Combinational Logic 177 un1_s_2 un1_s_3 un1_s_4 un1_s_5y[3:0]e e e e dy[3:0]s[1:0][1:0] d3[3:0] d2[3:0]d1[3:0] d0[3:0][0] [1] [1] [0] [0] [1] [0] [1][3:0] [3:0][3:0] [3:0] [3:0]Figure 4.7 mux4 synthesized circuit Check filling truth table convince correct.Chapter 04.qxd 1/31/07 8:17 PM Page 177important S/H11005P/H20003Cincomes P/H11005A/H20003B,because state- ments executed sequentially. HDL, order matter. Like hardware, HDL assignment statements evaluated time inputs, signals right hand side, change value, regardless order assignment statements appear module. 4.2.6 Precedence Notice parenthesized cout computation HDL Example 4.7 define order operations Cout/H11005G/H11001(P/H11080Cin), rather Cout /H11005(G/H11001P) /H11080Cin. used parentheses, default operation order defined language. HDL Example 4.8 specifies operator precedence highest lowest language. tables include arithmetic, shift, comparison operators defined Chapter 5.178 CHAPTER FOUR Hardware Description Languages pgs un1_coutcoutcouts cin ba Figure 4.8 fulladder synthesized circuitVerilog Verilog, wires used represent internal variables whose values defined assign statements assign p /H11005a /H11625b;Wires technically declared multibit busses, good practice include internal variables; declaration could omitted example. module fulladder(input a, b, cin, output s, cout); wire p, g; assign p /H11005a /H11625b; assign g /H11005a & b; assign /H11005p /H11625cin; assign cout /H11005g | (p & cin); endmoduleVHDL VHDL, signals used represent internal variables whose values defined concurrent signal assignment statements p/H11021/H11005a xor b; library IEEE; use IEEE.STD_LOGIC_1164.all; entity fulladder port(a, b, cin: STD_LOGIC; s, cout: STD_LOGIC); end; architecture synth fulladder signal p, g: STD_LOGIC; begin p/H11021/H11005a xor b; g/H11021/H11005a b; s/H11021/H11005p xor cin; cout /H11021/H11005g (p cin); end;HDL Example 4.7 FULL ADDERChapter 04.qxd 1/31/07 8:17 PM Page 1784.2 Combinational Logic 179 Verilog VHDLHDL Example 4.8 OPERATOR PRECEDENCE Table 4.2 VHDL operator precedence Op Meaning *,/,mod,rem MUL, DIV, MOD, REM /H11001,/H11002, PLUS, MINUS, & CONCATENATE rol,ror, Rotate, srl, sll, Shift logical, sra,sla Shift arithmetic /H11005,//H11005,/H11021, Comparison /H11021/H11005,/H11022,/H11022/H11005 and,or,nand , Logical Operations nor,xorH g h e L w e operator precedence Verilog much like would expect programming languages. particular, precedence OR. could take advantage precedence eliminate parentheses. assign cout /H11005g | p & cin;Multiplication precedence addition VHDL, would expect. However, unlike Verilog, logical operations ( and, or, etc.) equal precedence, unlike one might expect Boolean algebra. Thus, parentheses necessary; otherwise cout /H11021/H11005g p cin would interpreted left right cout /H11021/H11005(g p) cin . 4.2.7 Numbers Numbers specified variety bases. Underscores numbers ignored helpful breaking long numbers read- able chunks. HDL Example 4.9 explains numbers written language. 4.2.8 Z’s X’s HDLs use zto indicate floating value. zis particularly useful describ- ing tristate buffer, whose output floats enable 0. Recall Section 2.6 bus driven several tristate buffers, exactly one enabled. HDL Example 4.10 shows idiom tristate buffer. buffer enabled, output input. buffer disabled, output assigned floating value ( z).Table 4.1 Verilog operator precedence Op Meaning ~ *, /, % MUL, DIV, MOD /H11001,/H11002 PLUS, MINUS /H11021/H11021, /H11022/H11022 Logical Left/Right Shift /H11021/H11021/H11021 ,/H11022/H11022/H11022 Arithmetic Left/Right Shift /H11021,/H11021/H11005,/H11022,/H11022/H11005 Relative Comparison /H11005/H11005,!/H11005 Equality Comparison &, ~& AND, NAND /H11625,~/H11625XOR, XNOR |, ~| OR, ?: ConditionalH g h e L w e tChapter 04.qxd 1/31/07 8:17 PM Page 179180 CHAPTER FOUR Hardware Description Languages Verilog Verilog numbers specify base size (the number bits used represent them). format declaring constants N/H11032Bvalue , Nis size bits, Bis base, value gives value. example 9/H11032h25indicates 9-bit number value 25 16/H110053710/H11005000100101 2. Verilog supports /H11032bfor binary (base 2), /H11032ofor octal (base 8), /H11032dfor decimal (base 10), /H11032hfor hexadecimal (base 16). base omitted, base defaults decimal. size given, number assumed many bits expression used. Zeros automatically padded front number bring full size. example, wis 6-bit bus, assign w/H11005/H11032b11gives wthe value 000011. better practice explicitly give size.VHDL VHDL, STD_LOGIC numbers written binary enclosed single quotes: ‘0’ ‘1’ indicate logic 0 1. STD_LOGIC_VECTOR numbers written binary hexadecimal enclosed double quotation marks. base binary default explicitly defined prefix Xfor hexadecimal Bfor binary.HDL Example 4.9 NUMBERS Table 4.3 Verilog numbers Numbers Bits Base Val Stored 3/H11032b101 3 2 5 101 /H11032b11 ? 2 3 000...0011 8/H11032b11 8 2 3 00000011 8/H11032b1010_1011 8 2 171 10101011 3/H11032d6 3 10 6 110 6/H11032o42 6 8 34 100010 8/H11032hAB 8 16 171 10101011 42 ? 10 42 00...0101010Table 4.4 VHDL numbers Numbers Bits Base Val Stored “101” 3 2 5 101 B“101” 3 2 5 101 X“AB” 8 16 161 10101011 Verilog module tristate(input [3:0] a, input en, output [3:0] y); assign /H11005en ? : 4 /H11032bz; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity tristate port(a: STD_LOGIC_VECTOR(3 downto 0); en: STD_LOGIC; y: STD_LOGIC_VECTOR(3 downto 0)); end; architecture synth tristate begin y/H11021/H11005“ZZZZ” en /H11005‘0’ else a; end;HDL Example 4.10 TRISTATE BUFFERChapter 04.qxd 1/31/07 8:17 PM Page 1804.2 Combinational Logic 181 y_1[3:0]y[3:0]en a[3:0][3:0] [3:0] Figure 4.9 tristate synthesized circuit Similarly, HDLs use xto indicate invalid logic level. bus simultaneously driven 0 1 two enabled tristate buffers (or gates), result x, indicating contention. tristate buffers driv- ing bus simultaneously OFF, bus float, indicated z. start simulation, state nodes flip-flop outputs initialized unknown state ( xin Verilog uin VHDL). helpful track errors caused forgetting reset flip-flop output used. gate receives floating input, may produce xoutput can’t determine correct output value. Similarly, receives illegal uninitialized input, may produce xoutput. HDL Example 4.11 shows Verilog VHDL combine different signal values logic gates. Verilog Verilog signal values 0,1,z, x. Verilog constants starting zor xare padded leading z’s x’s (instead 0’s) reach full length necessary. Table 4.5 shows truth table gate using four possible signal values. Note gate sometimes determine output despite inputs unknown. example 0&z returns 0because output gate always 0 either input 0. Otherwise, floating invalid inputs cause invalid outputs, displayed xin Verilog.VHDL VHDL STD_LOGIC signals ‘ 0’, ‘1’, ‘z’, ‘x’, ‘u’. Table 4.6 shows truth table gate using five possible signal values. Notice gate some- times determine output despite inputs unknown. example, ‘ 0’ and‘z’ returns ‘ 0’ output gate always ‘ 0’ either input ‘ 0.’ Otherwise, floating invalid inputs cause invalid outputs, displayed ‘ x’ VHDL. Uninitialized inputs cause unini- tialized outputs, displayed ‘ u’ VHDL.HDL Example 4.11 TRUTH TABLES UNDEFINED FLOATING INPUTS Table 4.5 Verilog gate truth table zand x & 01zx 0 0000 B 1 01xx z 0xxx x 0xxxTable 4.6 VHDL gate truth table z, x, u 01zxu 000000 101xxu B z0xxxu x0xxxu u0uuuuChapter 04.qxd 1/31/07 8:17 PM Page 181Seeing xor uvalues simulation almost always indication bug bad coding practice. synthesized circuit, corresponds floating gate input, uninitialized state, contention. xor u may interpreted randomly circuit 0 1, leading unpre- dictable behavior. 4.2.9 Bit Swizzling Often necessary operate subset bus concatenate (join together) signals form busses. operations collectively known bit swizzling. HDL Example 4.12, yis given 9-bit value c2c1d0d0d0c0101using bit swizzling operations. 4.2.10 Delays HDL statements may associated delays specified arbitrary units. helpful simulation predict fast circuit work (if specify meaningful delays) also debugging purposes understand cause effect (deducing source bad output tricky signals change simultaneously simulation results). delays ignored synthesis; delay gate produced synthesizer depends tpdand tcdspecifications, numbers HDL code. HDL Example 4.13 adds delays original function HDL Example 4.1, assumes inverters delay 1 ns, three-input gates delay 2 ns, three-input gates delay 4 ns. Figure 4.10 shows simulation waveforms, ylagging 7 ns inputs. Note yis initially unknown beginning simulation.y/H11005abc/H11001abc/H11001abc.182 CHAPTER FOUR Hardware Description Languages Verilog assign /H11005{c[2:1], {3{d[0]}}, c[0], 3’b101}; {}operator used concatenate busses. {3{d[0]}} indicates three copies d[0]. Don’t confuse 3-bit binary constant 3’b101 bus named b. Note critical specify length 3 bits constant; otherwise, would unknown number leading zeros might appear middle y. ywere wider 9 bits, zeros would placed significant bits.VHDL /H11021/H11005c(2 downto 1) & d(0) & d(0) & d(0) & c(0) & “101”; &operator used concatenate busses. ymust 9-bit STD_LOGIC_VECTOR . confuse &with andopera- tor VHDL.HDL Example 4.12 BIT SWIZZLINGChapter 04.qxd 1/31/07 8:17 PM Page 1824.2 Combinational Logic 183 4.2.11 VHDL Libraries Types* (This section may skipped Verilog users.) Unlike Verilog, VHDL enforces strict data typing system protect user errors also clumsy times. Despite fundamental importance, STD_LOGIC type built VHDL. Instead, part IEEE.STD_LOGIC_1164 library. Thus, every file must contain library statements shown previ- ous examples.Verilog ‘timescale 1ns/1ps module example(input a, b, c, output y); wire ab, bb, cb, n1, n2, n3; assign #1 {ab, bb, cb} /H11005~ {a, b, c}; assign #2 n1 /H11005ab & bb & cb; assign #2 n2 /H11005a & bb & cb; assign #2 n3 /H11005a & bb & c; assign #4 /H11005n1 | n2 | n3; endmodule Verilog files include timescale directive indicates value time unit. statement form ‘timescale unit/precision . file, unit 1 ns, simulation 1 ps precision. timescale directive given file, default unit precision (usually 1 ns both) used. Verilog, #symbol used indicate number units delay. placed assign state- ments, well non-blocking ( /H11021/H11005) blocking ( /H11005) assign- ments, discussed Section 4.5.4.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity example port(a, b, c: STD_LOGIC; y: STD_LOGIC); end; architecture synth example signal ab, bb, cb, n1, n2, n3: STD_LOGIC; begin ab /H11021/H11005not 1 ns; bb /H11021/H11005not b 1 ns; cb /H11021/H11005not c 1 ns; n1 /H11021/H11005ab bb cb 2 ns; n2 /H11021/H11005a bb cb 2 ns; n3 /H11021/H11005a bb c 2 ns; /H11021/H11005n1 n2 n3 4 ns; end; VHDL, clause used indicate delay. units, case, specified nanoseconds.HDL Example 4.13 LOGIC GATES DELA YS Figure 4.10 Example simulation waveforms delays (from ModelSim simulator)Chapter 04.qxd 1/31/07 8:17 PM Page 183Moreover, IEEE.STD_LOGIC_1164 lacks basic operations addition, comparison, shifts, conversion integers STD_LOGIC_VECTOR data. CAD vendors adopted yet libraries containing functions: IEEE.STD_LOGIC_UNSIGNED IEEE.STD_LOGIC_SIGNED . See Section 1.4 discussion unsigned signed numbers examples operations. VHDL also BOOLEAN type two values: true false . BOOLEAN values returned comparisons (such equality com- parison, /H11005‘0’) used conditional statements . Despite temptation believe BOOLEAN true value equivalent STD_LOGIC ‘1’ BOOLEAN false mean STD_LOGIC ‘0’ , types interchangeable. Thus, following code illegal: /H11021/H11005d1 else d0; q /H11021/H11005(state /H11005S2); Instead, must write /H11021/H11005d1 (s /H11005‘1’) else d0; q /H11021/H11005‘1’ (state /H11005S2) else ‘0’; Although declare signals BOOLEAN , automatically implied comparisons used conditional statements. Similarly, VHDL INTEGER type represents positive negative integers. Signals type INTEGER span least values /H11002231to 231/H110021. Integer values used indices busses. exam- ple, statement /H11021/H11005a(3) a(2) a(1) a(0); 0, 1, 2, 3 integers serving index choose bits signal. cannot directly index bus STD_LOGIC STD_LOGIC_VECTOR signal. Instead, must convert signal INTEGER . demonstrated HDL Example 4.14 8:1 multi- plexer selects one bit vector using 3-bit index. CONV_INTEGER function defined IEEE.STD_LOGIC_UNSIGNED library performs conversion STD_LOGIC_VECTOR INTEGER positive (unsigned) values. VHDL also strict outports exclusively output. example, following code two three-input gates illegal VHDL vis output also used compute w. library IEEE; use IEEE.STD_LOGIC_1164.all; entity and23 port(a, b, c: STD_LOGIC; v, w: STD_LOGIC); end;184 CHAPTER FOUR Hardware Description LanguagesChapter 04.qxd 1/31/07 8:17 PM Page 184architecture synth and23 begin v /H11021/H11005a b; w /H11021/H11005v c; end; VHDL defines special port type, buffer , solve problem. signal connected buffer port behaves output may also used within module. corrected entity definition follows. Verilog limitation require buffer ports. entity and23 port(a, b, c: STD_LOGIC; v: buffer STD_LOGIC; w: STD_LOGIC); end; VHDL supports enumeration types abstract way represent- ing information without assigning specific binary encodings. exam- ple, divide-by-3 FSM described Section 3.4.2 uses three states. give states names using enumeration type rather refer- ring binary values. powerful allows VHDL search best state encoding synthesis, rather depending arbitrary encoding specified user. type statetype (S0, S1, S2) ; signal state, nextstate: statetype ; 4.3 STRUCTURAL MODELING previous section discussed behavioral modeling, describing module terms relationships inputs outputs. section4.3 Structural Modeling 185 library IEEE; use IEEE.STD_LOGIC_1164.all; use IEEE.STD_LOGIC_UNSIGNED.all; entity mux8 port(d: STD_LOGIC_VECTOR(7 downto 0); s: STD_LOGIC_VECTOR(2 downto 0); y: STD_LOGIC); end; architecture synth mux8 begin /H11021/H11005d(CONV_INTEGER(s)); end;HDL Example 4.14 8:1 MULTIPLEXER TYPE CONVERSION Figure follows next page.Chapter 04.qxd 1/31/07 8:17 PM Page 185186 CHAPTER FOUR Hardware Description Languages un1_s_3un1_s_4 un1_s_5 un1_s_6 un1_s_7 un1_s_8 un1_s_9 un1_s_10ye e e e e e e e dys[2:0][2:0] d[7:0][7:0] [0] [1] [2][0] [1] [2] [0] [1] [2] [1] [0] [2] [0] [1] [2] [2] [0] [1] [0] [2] [1] [1] [2] [0][0] [1] [2] [3] [4] [5] [6] [7]Figure 4.11 mux8 synthesized circuitChapter 04.qxd 1/31/07 8:17 PM Page 186examines structural modeling, describing module terms composed simpler modules. example, HDL Example 4.15 shows assemble 4:1 multiplexer three 2:1 multiplexers. copy 2:1 multiplexer4.3 Structural Modeling 187 vww vc ba Figure 4.12 and23 synthesized circuit Verilog module mux4(input [3:0] d0, d1, d2, d3, input [1:0] s, output [3:0] y); wire [3:0] low, high; mux2 lowmux(d0, d1, s[0], low); mux2 highmux(d2, d3, s[0], high); mux2 finalmux(low, high, s[1], y); endmodule three mux2 instances called lowmux ,highmux , finalmux . mux2 module must defined elsewhere Verilog code.HDL Example 4.15 STRUCTURAL MODEL 4:1 MULTIPLEXER VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity mux4 port(d0, d1, d2, d3: STD_LOGIC_VECTOR(3 downto 0); s: STD_LOGIC_VECTOR(1 downto 0); y: STD_LOGIC_VECTOR(3 downto 0)); end; architecture struct mux4 component mux2 port (d0, d1: STD_LOGIC_VECTOR(3 downto 0); s: STD_LOGIC; y: STD_LOGIC_VECTOR(3 downto 0)); end component; signal low, high: STD_LOGIC_VECTOR(3 downto 0); begin lowmux: mux2 port map(d0, d1, s(0), low); highmux: mux2 port map(d2, d3, s(0), high); finalmux: mux2 port map(low, high, s(1), y); end; architecture must first declare mux2 ports using component declaration statement. allows VHDL tools check component wish use ports entity declared somewhere else another entity statement, preventing errors caused changing entity instance. However, component declaration makes VHDL code rather cumbersome. Note architecture mux4 named struct , whereas architectures modules behavioral descrip- tions Section 4.2 named synth.VHDL allows multiple architectures (implementations) entity; architectures distinguished name. names significance CAD tools, struct synth common. Synthesizable VHDL code generally contains one architecture entity, discuss VHDL syntax configure architecture used multiple architectures defined.Chapter 04.qxd 1/31/07 8:17 PM Page 187188 CHAPTER FOUR Hardware Description Languages mux2 lowmux mux2 highmuxmux2 finalmuxy[3:0]s[1:0][1:0] d3[3:0]d2[3:0]d1[3:0]d0[3:0][0]s d0[3:0] d1[3:0]y[3:0] [0]s [3:0]d0[3:0] [3:0]d1[3:0]y[3:0][1]s [3:0]d0[3:0] [3:0]d1[3:0][3:0]y[3:0] Figure 4.13 mux4 synthesized circuit Verilog module mux2(input [3:0] d0, d1, input s, output [3:0] y); tristate t0(d0, ~s, y); tristate t1(d1, s, y); endmodule Verilog, expressions ~sare permitted port list instance. Arbitrarily complicated expressions legal discouraged make code difficult read.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity mux2 port(d0, d1: STD_LOGIC_VECTOR(3 downto 0); s: STD_LOGIC; y: STD_LOGIC_VECTOR(3 downto 0)); end; architecture struct mux2 component tristate port(a: STD_LOGIC_VECTOR(3 downto 0); en: STD_LOGIC; y: STD_LOGIC_VECTOR(3 downto 0)); end component; signal sbar: STD_LOGIC; begin sbar /H11021/H11005not s; t0: tristate port map(d0, sbar, y); t1: tristate port map(d1, s, y); end; VHDL, expressions permitted port map instance. Thus, sbar must defined separate signal.HDL Example 4.16 STRUCTURAL MODEL 2:1 MULTIPLEXERis called instance. Multiple instances module distin- guished distinct names, case lowmux , highmux , finalmux . example regularity, 2:1 multiplexer reused many times. HDL Example 4.16 uses structural modeling construct 2:1 multiplexer pair tristate buffers.Chapter 04.qxd 1/31/07 8:17 PM Page 1884.3 Structural Modeling 189 HDL Example 4.17 shows modules access part bus. 8-bit wide 2:1 multiplexer built using two 4-bit 2:1 multiplexers already defined, operating low high nibbles byte. general, complex systems designed hierarchically. overall system described structurally instantiating major components. components described structurally building blocks, forth recursively pieces simple enough describe behaviorally. good style avoid (or least minimize) mixing structural behavioral descriptions within single module.tristate t0 tristate t1y[3:0]s d1[3:0]d0[3:0]en [3:0] a[3:0][3:0] y[3:0] en [3:0]a[3:0][3:0]y[3:0] Figure 4.14 mux2 synthesized circuit Verilog module mux2_8(input [7:0] d0, d1, input s, output [7:0] y); mux2 lsbmux(d0[3:0], d1[3:0], s, y[3:0]); mux2 msbmux(d0[7:4], d1[7:4], s, y[7:4]); endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity mux2_8 port(d0, d1: STD_LOGIC_VECTOR(7 downto 0); s: STD_LOGIC; y: STD_LOGIC_VECTOR(7 downto 0)); end; architecture struct mux2_8 component mux2 port(d0, d1: STD_LOGIC_VECTOR(3 downto 0); s: STD_LOGIC; y: STD_LOGIC_VECTOR(3 downto 0)); end component; begin lsbmux: mux2 port map(d0(3 downto 0), d1(3 downto 0), s, y(3 downto 0)); msbhmux: mux2 port map(d0(7 downto 4), d1(7 downto 4), s, y(7 downto 4)); end;HDL Example 4.17 ACCESSING PARTS BUSSESChapter 04.qxd 1/31/07 8:17 PM Page 1894.4 SEQUENTIAL LOGIC HDL synthesizers recognize certain idioms turn specific sequential circuits. coding styles may simulate correctly syn- thesize circuits blatant subtle errors. section presents proper idioms describe registers latches. 4.4.1 Registers vast majority modern commercial systems built registers using positive edge-triggered flip-flops. HDL Example 4.18 shows idiom flip-flops. Verilog always statements VHDL process statements, sig- nals keep old value event sensitivity list takes place explicitly causes change. Hence, code, appropri- ate sensitivity lists, used describe sequential circuits mem- ory. example, flip-flop includes clkin sensitive list. remembers old value quntil next rising edge clk, even dchanges interim. contrast, Verilog continuous assignment statements ( assign ) VHDL concurrent assignment statements ( /H11021/H11005) reevaluated anytime inputs right hand side changes. Therefore, code necessarily describes combinational logic.190 CHAPTER FOUR Hardware Description Languages mux2 lsbmux mux2 msbmuxy[7:0][7:0]s d1[7:0][7:0]d0[7:0][7:0]s [3:0] d0[3:0] [3:0] d1[3:0][3:0] y[3:0] [7:4] d0[3:0] [7:4] d1[3:0][7:4] y[3:0] Figure 4.15 mux2_8 synthesized circuitChapter 04.qxd 1/31/07 8:17 PM Page 1904.4 Sequential Logic 191 q[3:0] d[3:0]clk[3:0] [3:0] Q[3:0] D[3:0] Figure 4.16 flop synthesized circuitVerilog module flop(input clk, input [3:0] d, output reg [3:0] q); always @ (posedge clk) q /H11021/H11005d; endmodule Verilog always statement written form always @ (sensitivity list) statement; Thestatement executed event specified sensitivity list occurs. example, statement q/H11021/H11005d(pronounced “q gets ”). Hence, flip-flop copies qon positive edge clock otherwise remem- bers old state q. /H11021/H11005is called nonblocking assignment. Think regular /H11005sign now; we’ll return subtle points Section 4.5.4. Note /H11021/H11005is used instead assign inside always statement. signals left hand side /H11021/H11005or /H11005in always statement must declared reg. example, qis output reg, declared output reg [3:0] q . Declaring signal regdoes mean signal actually output register! means signal appears left hand side assignment always statement. see later examples always statements describing combinational logic output declared regbut come flip-flop.HDL Example 4.18 REGISTER 4.4.2 Resettable Registers simulation begins power first applied circuit, output flop register unknown. indicated xin Verilog ‘ u’ VHDL. Generally, good practice use resettable registers powerup put system known state. reset may beVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity flop port(clk: STD_LOGIC; d: STD_LOGIC_VECTOR(3 downto 0); q: STD_LOGIC_VECTOR(3 downto 0)); end; architecture synth flop begin process(clk) begin clk’event clk /H11005‘1’ q /H11021/H11005d; end if; end process; end; VHDL process written form process(sensitivity list) begin statement; end process; statement executed variables sensitivity list change. example, ifstatement executed clkchanges, indicated clk’event . change rising edge (clk /H11005‘1’after event), q/H11021/H11005d (pronounced “q gets ”). Hence, flip-flop copies qon positive edge clock otherwise remem- bers old state q. alternative VHDL idiom flip-flop process(clk) begin RISING_EDGE(clk) q /H11021/H11005d; end if; end process; RISING_EDGE(clk) synonymous clk’event clk /H110051.Chapter 04.qxd 1/31/07 8:17 PM Page 191either asynchronous synchronous. Recall asynchronous reset occurs immediately, whereas synchronous reset clears output next rising edge clock. HDL Example 4.19 demonstrates idioms flip-flops asynchronous synchronous resets. Note distinguishing synchronous asynchronous reset schematic difficult. schematic produced Synplify Pro places asynchronous reset bottom flip-flop synchronous reset left side.192 CHAPTER FOUR Hardware Description Languages Verilog module flopr(input clk, input reset, input [3:0] d, output reg [3:0] q); // asynchronous reset always @ (posedge clk, posedge reset) if(reset) q /H11021/H110054’b0; else q /H11021/H11005d; endmodule module flopr (input clk, input reset, input [3:0] d, output reg [3:0] q); // synchronous reset always @ (posedge clk) (reset)q /H11021/H110054’b0; else q /H11021/H11005d; endmodule Multiple signals always statement sensitivity list separated comma word or. Notice posedge reset sensitivity list asynchronously reset- table flop, synchronously resettable flop. Thus, asynchronously resettable flop immediately responds rising edge reset , synchronously resettable flop responds reset rising edge clock. modules name, flopr , may include one design.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity flopr port(clk, reset: STD_LOGIC; d: STD_LOGIC_VECTOR(3 downto 0); q: STD_LOGIC_VECTOR(3 downto 0)); end; architecture asynchronous flopr begin process(clk, reset)begin reset /H11005‘1’ q /H11021/H11005“0000”; elsif clk’ event clk /H11005‘1’ q /H11021/H11005d; end if; end process; end; architecture synchronous flopr begin process(clk)begin clk’event clk /H11005‘1’ reset /H11005‘1’ q /H11021/H11005“0000”; else q /H11021/H11005d; end if; end if; end process; end; Multiple signals process sensitivity list separated comma. Notice reset sensitivity list asyn- chronously resettable flop, synchronously reset- table flop. Thus, asynchronously resettable flop immediately responds rising edge reset , synchronously reset- table flop responds reset rising edge clock. Recall state flop initialized ‘ u’ startup VHDL simulation. mentioned earlier, name architecture (asynchronous synchronous , example) ignored VHDL tools may helpful human reading code. architectures describe entity flopr , may include one design.HDL Example 4.19 RESETTABLE REGISTERChapter 04.qxd 1/31/07 8:17 PM Page 1924.4 Sequential Logic 193 4.4.3 Enabled Registers Enabled registers respond clock enable asserted. HDL Example 4.20 shows asynchronously resettable enabled register retains old value reset enare FALSE.Rq[3:0] d[3:0] resetclk[3:0]Q[3:0][3:0]D[3:0] (a) q[3:0] d[3:0] resetclk[3:0] Q[3:0][3:0] D[3:0] R (b) Figure 4.17 flopr synthesized circuit (a) asynchronous reset, (b) synchronous reset Verilog module flopenr(input clk, input reset, input en, input [3:0] d, output reg [3:0] q); // asynchronous reset always @ (posedge clk, posedge reset) if(reset)q /H11021/H110054’b0; else if(en)q /H11021/H11005d; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity flopenr port(clk, reset, en: STD_LOGIC; d: STD_LOGIC_VECTOR(3 downto 0); q: STD_LOGIC_VECTOR(3 downto 0)); end; architecture asynchronous flopenr —— asynchronous reset begin process(clk, reset)begin reset /H11005‘1’ q /H11021/H11005“0000”; elsif clk’event clk /H11005‘1’ en /H11005‘1’ q /H11021/H11005d; end if; end if; end process; end;HDL Example 4.20 RESETTABLE ENABLED REGISTERChapter 04.qxd 1/31/07 8:17 PM Page 1934.4.4 Multiple Registers single always/process statement used describe multiple pieces hardware. example, consider synchronizer Section 3.5.5 made two back-to-back flip-flops, shown Figure 4.19. HDL Example 4.21 describes synchronizer. rising edge clk,dis copied n1.At time, n1is copied q.194 CHAPTER FOUR Hardware Description Languages Rq[3:0] d[3:0] en resetclk [3:0] [3:0]Q[3:0] D[3:0] E Figure 4.18 flopenr synthesized circuit CLK CLK DN1 Q Figure 4.19 Synchronizer circuit Verilog module sync(input clk, input d, output reg q); reg n1; always @ (posedge clk) begin n1 /H11021/H11005d; q /H11021/H11005n1; end endmodule n1must declared regbecause internal signal used left hand side /H11021/H11005in always statement. Also notice begin/end construct necessary multiple statements appear always statement. analogous { } C Java. begin/end needed flopr example if/else counts single statement.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity sync port(clk: STD_LOGIC; d: STD_LOGIC; q: STD_LOGIC); end; architecture good sync signal n1: STD_LOGIC; begin process(clk)begin clk’event clk /H11005‘1’ n1 /H11021/H11005d; q /H11021/H11005n1; end if; end process; end; n1must declared signal internal signal used module.HDL Example 4.21 SYNCHRONIZER n1 qq dclk QD QD Figure 4.20 sync synthesized circuitChapter 04.qxd 1/31/07 8:17 PM Page 1944.5 Combinational Logic 195 4.4.5 Latches Recall Section 3.2.2 latch transparent clock HIGH, allowing data flow input output. latch becomes opaque clock LOW, retaining old state. HDL Example 4.22 shows idiom latch. synthesis tools support latches well. Unless know tool support latches good reason use them, avoid use edge-triggered flip-flops instead. Furthermore, take care HDL imply unintended latches, something easy aren’t attentive. Many synthesis tools warn latch created; didn’t expect one, track bug HDL. 4.5 COMBINATIONAL LOGIC Section 4.2, used assignment statements describe combinational logic behaviorally. Verilog always statements VHDL process state- ments used describe sequential circuits, remember old state new state prescribed. However, always/process lat q[3:0]q[3:0]d[3:0] clk[3:0] D[3:0][3:0] Q [3:0]C Figure 4.21 latch synthesized circuitVerilog module latch(input clk, input [3:0] d, output reg [3:0] q); always @ (clk, d) (clk) q /H11021/H11005d; endmodule sensitivity list contains clkand d, always statement evaluates time clk dchanges. clk HIGH, dflows q. qmust declared regbecause appears left hand side /H11021/H11005in always statement. always mean qis output register.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity latch port(clk: STD_LOGIC; d: STD_LOGIC_VECTOR(3 downto 0); q: STD_LOGIC_VECTOR(3 downto 0)); end; architecture synth latch begin process(clk, d)begin clk /H11005‘1’ q /H11021/H11005d; end if; end process; end; sensitivity list contains clkand d, process evaluates anytime clkor dchanges. clkis HIGH, dflows q.HDL Example 4.22 LATCHChapter 04.qxd 1/31/07 8:17 PM Page 195statements also used describe combinational logic behaviorally sensitivity list written respond changes inputs body prescribes output value every possible input combi- nation. HDL Example 4.23 uses always/process statements describe bank four inverters (see Figure 4.3 synthesized circuit). HDLs support blocking nonblocking assignments always/process statement. group blocking assignments evalu- ated order appear code, one would expect standard programming language. group nonblocking assignments evaluated concurrently; statements evalu- ated signals left hand sides updated. HDL Example 4.24 defines full adder using intermediate signals pand gto compute sand cout . produces circuit Figure 4.8, uses always/process statements place assignment statements. two examples poor applications always/process state- ments modeling combinational logic require lines equivalent approach assignment statements Section 4.2.1. Moreover, pose risk inadvertently implying sequential logic inputs left sensitivity list. However, case ifstatements convenient modeling complicated combina- tional logic. case ifstatements must appear within always/process statements examined next sections.196 CHAPTER FOUR Hardware Description Languages Verilog module inv(input [3:0] a, output reg [3:0] y); always @ (*) /H11005~a; endmodule always @ (*) reevaluates statements inside always statement time signals right hand side /H11021/H11005or /H11005inside always statement change. Thus, @ (*) safe way model combinational logic. particular example, @ (a) would also sufficed. /H11005in always statement called blocking assign- ment, contrast /H11021/H11005nonblocking assignment. Verilog, good practice use blocking assignments combinational logic nonblocking assignments sequen- tial logic. discussed Section 4.5.4. Note ymust declared regbecause appears left hand side /H11021/H11005or /H11005sign always state- ment. Nevertheless, yis output combinational logic, register.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity inv port(a: STD_LOGIC_VECTOR(3 downto 0); y: STD_LOGIC_VECTOR(3 downto 0)); end; architecture proc inv begin process(a) begin /H11021/H11005not a; end process; end; begin end process statements required VHDL even though process contains one assignment.HDL Example 4.23 INVERTER USING always /processChapter 04.qxd 1/31/07 8:17 PM Page 1964.5 Combinational Logic 197 Verilog Verilog always statement, /H11005indicates blocking assign- ment /H11021/H11005indicates nonblocking assignment (also called concurrent assignment). confuse either type continuous assignment using assign statement. assign statements must used outside always statements also evaluated concurrently.VHDL VHDL process statement, : /H11005indicates blocking assignment /H11021/H11005indicates nonblocking assignment (also called concurrent assignment). first section : /H11005is introduced. Nonblocking assignments made outputs signals. Blocking assignments made variables, declared process statements (see HDL Example 4.24). /H11021/H11005can also appear outside process statements, also evaluated concurrently. Verilog module fulladder(input a, b, cin, output reg s, cout); reg p, g; always @ (*) begin p /H11005a /H11625b; // blocking g /H11005a & b; // blocking /H11005p /H11625cin; // blocking cout /H11005g | (p & cin); // blocking end endmodule case, @( a, b, cin) would equivalent @ (*) . However, @ (*) better avoids common mistakes missing signals stimulus list. reasons discussed Section 4.5.4, best use blocking assignments combinational logic. example uses blocking assignments, first computing p, theng, s, finally cout. pand gappear left hand side assignment always statement, must declared reg.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity fulladder port(a, b, cin: STD_LOGIC; s, cout: STD_LOGIC); end; architecture synth fulladder begin process(a, b, cin) variable p, g: STD_LOGIC; begin p :/H11005a xor b; — — blocking g :/H11005a b; — — blocking /H11021/H11005p xor cin; cout /H11021/H11005g (p cin); end process; end; process sensitivity list must include a,b, cinbecause combinational logic respond changes input. reasons discussed Section 4.5.4, best use blocking assignments intermediate variables combinational logic. example uses blocking assignments pand gso get new values used compute sand cout depend them. pand gappear left hand side blocking assignment ( :/H11005) process statement, must declared variable rather signal . variable declaration appears begin process variable used.HDL Example 4.24 FULL ADDER USING always/processChapter 04.qxd 1/31/07 8:17 PM Page 1974.5.1 Case Statements better application using always/process statement combina- tional logic seven-segment display decoder takes advantage case statement must appear inside always/process statement. might noticed Example 2.10, design process large blocks combinational logic tedious prone error. HDLs offer great improvement, allowing specify function higher level abstraction, automatically synthesize func- tion gates. HDL Example 4.25 uses case statements describe seven-segment display decoder based truth table. (See Example 2.10 description seven-segment display decoder.) case198 CHAPTER FOUR Hardware Description Languages Verilog module sevenseg(input [3:0] data, output reg [6:0] segments); always @ (*) case(data) // abc_defg 0: segments /H110057’b111_1110; 1: segments /H110057’b011_0000; 2: segments /H110057’b110_1101; 3: segments /H110057’b111_1001; 4: segments /H110057’b011_0011; 5: segments /H110057’b101_1011; 6: segments /H110057’b101_1111; 7: segments /H110057’b111_0000; 8: segments /H110057’b111_1111; 9: segments /H110057’b111_1011; default: segments /H110057’b000_0000; endcase endmodule case statement checks value data. data 0, statement performs action colon, setting segments 1111110. case statement similarly checks data values 9 (note use default base, base 10). default clause convenient way define output cases explicitly listed, guaranteeing combi- national logic. Verilog, case statements must appear inside always statements.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity seven_seg_decoder port(data: STD_LOGIC_VECTOR(3 downto 0); segments: STD_LOGIC_VECTOR(6 downto 0)); end; architecture synth seven_seg_decoder begin process(data)begin case data — — abcdefg X“0” /H11005/H11022segments /H11021/H11005“1111110”; X“1” /H11005/H11022segments /H11021/H11005“0110000”; X“2” /H11005/H11022segments /H11021/H11005“1101101”; X“3” /H11005/H11022segments /H11021/H11005“1111001”; X“4” /H11005/H11022segments /H11021/H11005“0110011”; X“5” /H11005/H11022segments /H11021/H11005“1011011”; X“6” /H11005/H11022segments /H11021/H11005“1011111”; X“7” /H11005/H11022segments /H11021/H11005“1110000”; X“8” /H11005/H11022segments /H11021/H11005“1111111”; X“9” /H11005/H11022segments /H11021/H11005“1111011”; others /H11005/H11022segments /H11021/H11005“0000000”; end case; end process; end; case statement checks value data. data 0, statement performs action /H11005/H11022, setting segments 1111110. case statement similarly checks data values 9 (note use Xfor hexadecimal numbers). others clause convenient way define output cases explicitly listed, guaranteeing combinational logic. Unlike Verilog, VHDL supports selected signal assign- ment statements (see HDL Example 4.6), much like case statements appear outside processes. Thus, less reason use processes describe combinational logic.HDL Example 4.25 SEVEN-SEGMENT DISPLA DECODERChapter 04.qxd 1/31/07 8:17 PM Page 1984.5 Combinational Logic 199 statement performs different actions depending value input. case statement implies combinational logic possible input combinations defined; otherwise implies sequential logic, output keep old value undefined cases. Synplify Pro synthesizes seven-segment display decoder read-only memory (ROM ) containing 7 outputs 16 possible inputs. ROMs discussed Section 5.5.6. default others clause left case statement, decoder would remembered previous output anytime data range 10–15. strange behavior hardware. Ordinary decoders also commonly written case statements. HDL Example 4.26 describes 3:8 decoder. 4.5.2 Statements always/process statements may also contain ifstatements. statement may followed else statement. possible inputrom segments_1[6:0]segments[6:0] data[3:0][6:0] DOUT[6:0][3:0] A[3:0] Figure 4.22 sevenseg synthesized circuit Verilog module decoder3_8(input [2:0] a, output reg [7:0] y); always @ (*) case (a) 3’b000: /H110058’b00000001; 3’b001: /H110058’b00000010; 3’b010: /H110058’b00000100; 3’b011: /H110058’b00001000; 3’b100: /H110058’b00010000; 3’b101: /H110058’b00100000; 3’b110: /H110058’b01000000; 3’b111: /H110058’b10000000; endcase endmodule default statement needed cases covered.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity decoder3_8 port(a: STD_LOGIC_VECTOR(2 downto 0); y: STD_LOGIC_VECTOR(7 downto 0)); end; architecture synth decoder3_8 begin process(a)begin case “000” /H11005/H11022y /H11021/H11005“00000001”; “001” /H11005/H11022y /H11021/H11005“00000010”; “010” /H11005/H11022y /H11021/H11005“00000100”; “011” /H11005/H11022y /H11021/H11005“00001000”; “100” /H11005/H11022y /H11021/H11005“00010000”; “101” /H11005/H11022y /H11021/H11005“00100000”; “110” /H11005/H11022y /H11021/H11005“01000000”; “111” /H11005/H11022y /H11021/H11005“10000000”; end case; end process; end; others clause needed cases covered.HDL Example 4.26 3:8 DECODERChapter 04.qxd 1/31/07 8:17 PM Page 199200 CHAPTER FOUR Hardware Description Languages y41 y34y35y36y37y38y39y40y[7:0] a[2:0][2:0][0] [1] [2] [0] [1] [2][2] [0] [1][0] [2] [1][1] [2] [0] [1] [0] [2] [0] [1] [2] [0] [1] [2] Figure 4.23 decoder3_8 synthesized circuitChapter 04.qxd 1/31/07 8:17 PM Page 2004.5 Combinational Logic 201 combinations handled, statement implies combinational logic; otherwise, produces sequential logic (like latch Section 4.4.5). HDL Example 4.27 uses ifstatements describe priority circuit, defined Section 2.4. Recall N-input priority circuit sets output TRUE corresponds significant input TRUE. 4.5.3 Verilog casez * (This section may skipped VHDL users.) Verilog also provides casez statement describe truth tables don’t cares (indicated ?in casez statement). HDL Example 4.28 shows describe priority circuit casez . Synplify Pro synthesizes slightly different circuit module, shown Figure 4.25, priority circuit Figure 4.24. However, circuits logically equivalent. 4.5.4 Blocking Nonblocking Assignments guidelines page 203 explain use type assignment. guidelines followed, possible writeVerilog module priority(input [3:0] a, output reg [3:0] y); always @ (*) (a[3]) /H110054’b1000; else (a[2]) /H110054’b0100; else (a[1]) /H110054’b0010; else (a[0]) /H110054’b0001; else /H110054’b0000; endmodule Verilog, ifstatements must appear inside always statements.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity priority port(a: STD_LOGIC_VECTOR(3 downto 0); y: STD_LOGIC_VECTOR(3 downto 0)); end; architecture synth priority begin process(a)begin a(3) /H11005‘1’ /H11021/H11005“1000”; elsif a(2) /H11005‘1’ /H11021/H11005“0100”; elsif a(1) /H11005‘1’ /H11021/H11005“0010”; elsif a(0) /H11005‘1’ /H11021/H11005“0001”; else /H11021/H11005“0000”; end if; end process; end; Unlike Verilog, VHDL supports conditional signal assign- ment statements (see HDL Example 4.6), much like ifstatements appear outside processes. Thus, less reason use processes describe combina- tional logic. (Figure follows next page.)HDL Example 4.27 PRIORITY CIRCUITChapter 04.qxd 1/31/07 8:17 PM Page 201code appears work simulation synthesizes incorrect hardware. optional remainder section explains principles behind guidelines. Combinational Logic* full adder HDL Example 4.24 correctly modeled using blocking assignments. section explores operates would differ nonblocking assignments used. Imagine a,b, cinare initially 0. p,g,s, cout thus 0 well. time, achanges 1, triggering always/process statement. four blocking assignments evaluate in202 CHAPTER FOUR Hardware Description Languages module priority_casez(input [3:0] a, output reg [3:0] y); always @ (*) casez (a) 4’b1???: /H110054’b1000; 4’b01??: /H110054’b0100; 4’b001?: /H110054’b0010; 4’b0001: /H110054’b0001; default: /H110054’b0000; endcase endmoduleHDL Example 4.28 PRIORITY CIRCUIT USING casezy_1[2] un13_y un21_yy_1[1] y_1[0]y[3:0] a[3:0][3:0][3] [2:0] [2] [2][3] [2] [3] [1] [2] [3][1][1] [0][0]Figure 4.24 priority synthesized circuit (See figure 4.25.)Chapter 04.qxd 1/31/07 8:17 PM Page 2024.5 Combinational Logic 203 y23[0] y24[0] y25y[3:0] a[3:0][3:0] [3] [2][2] [1] [0] [3] [1] [2] [3] [0] [1] [2] [3]Figure 4.25 priority_casez synthesized circuit Verilog 1. Use always @ (posedge clk) nonblocking assignments model synchronous sequential logic. always @ (posedge clk) begin nl /H11021/H11005d; // nonblocking q /H11021/H11005nl; // nonblocking end 2. Use continuous assignments model simple combina- tional logic. assign /H11005s ? d1 : d0; 3. Use always @ (*) blocking assignments model complicated combinational logic always statement helpful. always @ (*) begin p /H11005a /H11625b; // blocking g /H11005a & b; // blocking /H11005p /H11625cin; cout /H11005g | (p & cin); end 4. make assignments signal one always statement continuous assignment statement.VHDL 1. Use process(clk) nonblocking assignments model synchronous sequential logic. process(clk)begin clk’event clk /H11005‘1’ nl /H11021/H11005d; — — nonblocking q /H11021/H11005nl; — — nonblocking end if; end process; 2. Use concurrent assignments outside process statements model simple combinational logic. /H11021/H11005d0 /H11005‘0’ else d1; 3. Use process(in1, in2, ... ) model complicated combinational logic process helpful. Use blocking assignments internal variables. process (a, b, cin) variable p, g: STD_LOGIC; begin p :/H11005a xor b; —— blocking g :/H11005a b; —— blocking /H11021/H11005p xor cin; cout /H11021/H11005g (p cin); end process; 4. make assignments variable one process concurrent assignment statement.BLOCKING NONBLOCKING ASSIGNMENT GUIDELINESChapter 04.qxd 1/31/07 8:17 PM Page 203the order shown here. (In VHDL code, sand cout assigned con- currently.) Note pand gget new values sand cout computed blocking assignments. important want compute sand cout using new values pand g. 1.p 1 /H200030/H110051 2.g 1 • 0 /H110050 3.s 1 /H200030/H110051 4.cout 0/H110011 • 0 /H110050 contrast, HDL Example 4.29 illustrates use nonblocking assignments. consider case arising 0 1 band cin 0. four nonblocking assignments evaluate concurrently: p 1/H200030/H110051 g 1• 0 /H110050 0 /H200030/H110050 cout 0/H110010 • 0 /H110050 Observe sis computed concurrently pand hence uses old value p, new value. Therefore, sremains 0 rather than; ; ; ;;;;;204 CHAPTER FOUR Hardware Description Languages Verilog // nonblocking assignments(not recommended) module fulladder (input a, b, cin, output reg s, cout); reg p, g; always @ (*) begin p /H11021/H11005a /H11625b; // nonblocking g /H11021/H11005a & b; // nonblocking /H11021/H11005p /H11625cin; cout /H11021/H11005g | (p & cin); end endmodule pand gappear left hand side assignment always statement, must declared reg.VHDL — — nonblocking assignments(not recommended) library IEEE; use IEEE.STD_LOGIC_1164.all; entity fulladder port(a, b, cin: STD_LOGIC; s, cout: STD_LOGIC); end; architecture nonblocking fulladder signal p, g: STD_LOGIC; begin process(a, b, cin, p, g)begin p /H11021/H11005a xor b; — — nonblocking g /H11021/H11005a b; — — nonblocking /H11021/H11005p xor cin; cout /H11021/H11005g (p cin); end process; end; pand gappear left hand side nonblock- ing assignment process statement, must declared signal rather variable . signal declaration appears begin architecture , process .HDL Example 4.29 FULL ADDER USING NONBLOCKING ASSIGNMENTSChapter 04.qxd 1/31/07 8:17 PM Page 2044.5 Combinational Logic 205 becoming 1. However, pdoes change 0 1. change triggers always/process statement evaluate second time, follows: p 1/H200030/H110051 g 1• 0 /H110050 1/H200030/H110051 cout 0/H110011•0 /H110050 time, pis already 1, scorrectly changes 1. nonblocking assignments eventually reach right answer, always/process statement evaluate twice. makes simulation slower, though synthesizes hardware. Another drawback nonblocking assignments modeling combi- national logic HDL produce wrong result forget include intermediate variables sensitivity list.; ; ; ; Worse yet, synthesis tools synthesize correct hardware even faulty sensitivity list causes incorrect simulation. leads mismatch simulation results hardware actually does. Sequential Logic* synchronizer HDL Example 4.21 correctly modeled using non- blocking assignments. rising edge clock, dis copied n1at time n1is copied q, code properly describes two registers. example, suppose initially d/H110050, n1/H110051, q/H110050. rising edge clock, following two assignments occur concurrently, clock edge, n1/H110050 q/H110051. nl /H110050qn 1 /H110051 HDL Example 4.30 tries describe module using blocking assignments. rising edge clk,dis copied n1. new value n1is copied q, resulting dimproperly appearing n1 q. assignments occur one clock edge, q/H11005n1/H110050. 1.n1 /H110050 2.qn 1 /H110050 ;;; ;Verilog sensitivity list always statement HDL Example 4.29 written always @ (a , b, cin) rather always @ (*) , statement would reevaluate por g changes. previous example, swould incorrectly left 0, 1.VHDL sensitivity list process statement HDL Example 4.29 written process (a , b, cin) rather process (a , b, cin, p, g), statement would reevaluate por gchanges. previous example, swould incorrectly left 0, 1.Chapter 04.qxd 1/31/07 8:17 PM Page 205Because n1is invisible outside world influence behavior q, synthesizer optimizes away entirely, shown Figure 4.26. moral illustration exclusively use nonblocking assignment always statements modeling sequential logic. sufficient cleverness, reversing orders assignments, could make blocking assignments work correctly, blocking assign- ments offer advantages introduce risk unintended behavior. Certain sequential circuits work blocking assign- ments matter order. 4.6 FINITE STATE MACHINES Recall finite state machine (FSM) consists state register two blocks combinational logic compute next state output given current state input, shown Figure 3.22. HDL descriptions state machines correspondingly divided three parts model state register, next state logic, output logic.206 CHAPTER FOUR Hardware Description Languages Verilog // Bad implementation using blocking assignments module syncbad(input clk, input d, output reg q); reg n1; always @ (posedge clk) begin n1 /H11005d; // blocking q/H11005n1; // blocking end endmoduleVHDL — — Bad implementation using blocking assignment library IEEE; use IEEE.STD_LOGIC_1164.all; entity syncbad port(clk: STD_LOGIC; d: STD_LOGIC; q: STD_LOGIC); end; architecture bad syncbad begin process(clk) variable n1: STD_LOGIC; begin clk’event clk /H11005‘1’ n1 : /H11005d; — — blocking q /H11021/H11005n1; end if; end process; end;HDL Example 4.30 BAD SYNCHRONIZER BLOCKING ASSIGNMENTS qq dclk QD Figure 4.26 syncbad synthesized circuitChapter 04.qxd 1/31/07 8:17 PM Page 2064.6 Finite State Machines 207 HDL Example 4.31 describes divide-by-3 FSM Section 3.4.2. provides asynchronous reset initialize FSM. state register uses ordinary idiom flip-flops. next state output logic blocks combinational. Synplify Pro Synthesis tool produces block diagram state transition diagram state machines; show logic gates inputs outputs arcs states. Therefore, careful specified FSM correctly HDL code. state transition diagram Figure 4.27 divide-by-3 FSM analo- gous diagram Figure 3.28(b). double circle indicates thatVerilog module divideby3FSM(input clk, input reset, output y); reg [1:0] state, nextstate; parameter S0 /H110052/H11032b00; parameter S1 /H110052/H11032b01; parameter S2 /H110052/H11032b10; // state register always @ (posedge clk, posedge reset) (reset) state /H11021/H11005S0; else state /H11021/H11005nextstate; // next state logic always @ (*) case (state) S0: nextstate /H11005S1; S1: nextstate /H11005S2; S2: nextstate /H11005S0; default: nextstate /H11005S0; endcase // output logic assign /H11005(state /H11005/H11005S0); endmodule parameter statement used define constants within module. Naming states parameters required, makes changing state encodings much easier makes code readable. Notice case statement used define state transition table. next state logic com- binational, default necessary even though state 2/H11032b11 never arise. output, y, 1 state S0. equality comparison a/H11005/H11005bevaluates 1 aequals band 0 oth- erwise. inequality comparison a!/H11005bdoes inverse, evaluating 1 adoes equal b.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity divideby3FSM port(clk, reset: STD_LOGIC; y: STD_LOGIC); end; architecture synth divideby3FSM type statetype (S0, S1, S2); signal state, nextstate: statetype; begin — — state register process (clk, reset) begin reset /H11005‘1’ state /H11021/H11005S0; elsif clk’event clk /H11005‘1’ state /H11021/H11005nextstate; end if; end process; — — next state logic nextstate /H11021/H11005S1 state /H11005S0 else S2 state /H11005S1 else S0; — — output logic /H11021/H11005‘1’ state /H11005S0 else ‘0’; end; example defines new enumeration data type, statetype , three possibilities: S0,S1, S2.state nextstate statetype signals. using enumeration instead choosing state encoding, VHDL frees synthesizer explore various state encodings choose best one. output, y, 1 state S0. inequality- comparison uses //H11005. produce output 1 state anything S0, change comparison state / /H11005S0.HDL Example 4.31 DIVIDE-BY-3 FINITE STATE MACHINE Notice synthesis tool uses 3-bit encoding ( Q[2:0]) instead 2-bit encoding suggested Verilog code.Chapter 04.qxd 1/31/07 8:17 PM Page 207S0 reset state. Gate-level implementations divide-by-3 FSM shown Section 3.4.2. If, reason, wanted output HIGH states S0 S1, output logic would modified follows. next two examples describe snail pattern recognizer FSM Section 3.4.3. code shows use case ifstate- ments handle next state output logic depend inputs well current state. show Moore Mealy mod- ules. Moore machine (HDL Example 4.32), output depends current state, whereas Mealy machine (HDL Example 4.33), output logic depends current state inputs.208 CHAPTER FOUR Hardware Description Languages S0 S1S2statemachine state[2:0]y[0] resetclk C [2:0]Q[2:0]R Figure 4.27 divideby3fsm synthesized circuit Verilog // Output Logic assign /H11005(state /H11005/H11005S0 | state /H11005/H11005S1);VHDL — — output logic /H11021/H11005‘1’ (state /H11005S0 state /H11005S1) else ‘0’;Chapter 04.qxd 1/31/07 8:17 PM Page 208Verilog module patternMoore(input clk, input reset, input a, output y); reg [2:0] state, nextstate; parameter S0 /H110053/H11032b000; parameter S1 /H110053/H11032b001; parameter S2 /H110053/H11032b010; parameter S3 /H110053/H11032b011; parameter S4 /H110053/H11032b100; // state register always @ (posedge clk, posedge reset) (reset) state /H11021/H11005S0; else state /H11021/H11005nextstate; // next state logic always @ (*) case(state) S0: (a) nextstate /H11005S1; else nextstate /H11005S0; S1: (a) nextstate /H11005S2; else nextstate /H11005S0; S2: (a) nextstate /H11005S2; else nextstate /H11005S3; S3: (a) nextstate /H11005S4; else nextstate /H11005S0; S4: (a) nextstate /H11005S2; else nextstate /H11005S0; default: nextstate /H11005S0; endcase // output logic assign /H11005(state /H11005/H11005S4); endmodule Note nonblocking assignments ( /H11021/H11005) used state register describe sequential logic, whereas blocking assignments ( /H11005) used next state logic describe combinational logic.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity patternMoore port(clk, reset: STD_LOGIC; a: STD_LOGIC; y: STD_LOGIC); end; architecture synth patternMoore type statetype (S0, S1, S2, S3, S4); signal state, nextstate: statetype; begin — — state register process(clk, reset)begin reset /H11005‘1’ state /H11021/H11005S0; elsif clk’event clk /H11005‘1’ state /H11021/H11005nextstate; end if; end process; — — next state logic process(state, a)begin case state S0 /H11005/H11022if /H11005‘1’ nextstate /H11021/H11005S1; else nextstate /H11021/H11005S0; end if; S1 /H11005/H11022if /H11005‘1’ nextstate /H11021/H11005S2; else nextstate /H11021/H11005S0; end if; S2 /H11005/H11022if /H11005‘1’ nextstate /H11021/H11005S2; else nextstate /H11021/H11005S3; end if; S3 /H11005/H11022if /H11005‘1’ nextstate /H11021/H11005S4; else nextstate /H11021/H11005S0; end if; S4 /H11005/H11022if /H11005‘1’ nextstate /H11021/H11005S2; else nextstate /H11021/H11005S0; end if; others /H11005/H11022nextstate /H11021/H11005S0; end case; end process; — — output logic /H11021/H11005‘1’ state /H11005S4 else ‘0’; end;HDL Example 4.32 PATTERN RECOGNIZER MOORE FSM S0 S1 S2S3S4statemachine state[4:0]y[4]a resetclkI[0] [4:0]Q[4:0] C R Figure 4.28 patternMoore synthesized circuitChapter 04.qxd 1/31/07 8:17 PM Page 209210 CHAPTER FOUR Hardware Description Languages S0S1 S2 S3statemachine state[3:0]yya resetclkI[0] [3:0]Q[3:0] C R[3] Figure 4.29 patternMealy synthesized circuitVerilog module patternMealy(input clk, input reset, input a, output y); reg [1:0] state, nextstate; parameter S0 /H110052/H11032b00; parameter S1 /H110052/H11032b01; parameter S2 /H110052/H11032b10; parameter S3 /H110052/H11032b11; // state register always @ (posedge clk, posedge reset) if(reset)state /H11021/H11005S0; else state /H11021/H11005nextstate; // next state logic always @ (*) case (state) S0: (a) nextstate /H11005S1; else nextstate /H11005S0; S1: (a) nextstate /H11005S2; else nextstate /H11005S0; S2: (a) nextstate /H11005S2; else nextstate /H11005S3; S3: (a) nextstate /H11005S1; else nextstate /H11005S0; default: nextstate /H11005S0; endcase // output logic assign /H11005(a & state /H11005/H11005S3); endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity patternMealy port(clk, reset: STD_LOGIC; a: STD_LOGIC; y: STD_LOGIC); end; architecture synth patternMealy type statetype is(S0, S1, S2, S3); signal state, nextstate: statetype; begin — — state register process(clk, reset)begin reset /H11005‘1’ state /H11021/H11005S0; elsif clk’event clk /H11005‘1’ state /H11021/H11005nextstate; end if; end process; — — next state logic process(state, a) begin case state S0 /H11005/H11022if /H11005‘1’ nextstate /H11021/H11005S1; else nextstate /H11021/H11005S0; end if; S1 /H11005/H11022if /H11005‘1’ nextstate /H11021/H11005S2; else nextstate /H11021/H11005S0; end if; S2 /H11005/H11022if /H11005‘1’ nextstate /H11021/H11005S2; else nextstate /H11021/H11005S3; end if; S3 /H11005/H11022if /H11005‘1’ nextstate /H11021/H11005S1; else nextstate /H11021/H11005S0; end if; others /H11005/H11022 nextstate /H11021/H11005S0; end case; end process; — — output logic /H11021/H11005‘1’ (a /H11005‘1’ state /H11005S3) else ‘0’; end;HDL Example 4.33 PATTERN RECOGNIZER MEALY FSMChapter 04.qxd 1/31/07 8:17 PM Page 2104.7 Parameterized Modules 211 Verilog module mux2 # (parameter width /H110058) (input [width /H110021:0] d0, d1, input s, output [width /H110021:0] y); assign /H11005s ? d1 : d0; endmodule Verilog allows # (parameter ... ) statement inputs outputs define parameters. parameter statement includes default value (8) parameter, width . number bits inputs outputs depend parameter. module mux4_8(input [7:0] d0, d1, d2, d3, input [1:0] s, output [7:0] y); wire [7:0] low, hi; mux2 lowmux(d0, d1, s[0], low); mux2 himux(d2, d3, s[1], hi); mux2 outmux(low, hi, s[1], y); endmodule 8-bit 4:1 multiplexer instantiates three 2:1 multiplexers using default widths. contrast, 12-bit 4:1 multiplexer, mux4_12 , would need override default width using #()before instance name, shown below. module mux4_12(input [11:0] d0, d1, d2, d3, input [1:0] s, output [11:0] y); wire [11:0] low, hi; mux2 #(12) lowmux(d0, d1, s[0], low); mux2 #(12) himux(d2, d3, s[1], hi); mux2 #(12) outmux(low, hi, s[1], y); endmodule confuse use #sign indicating delays use #(...) defining overriding parameters.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity mux2 generic(width: integer : /H110058); port(d0, d1: STD_LOGIC_VECTOR(width /H110021 downto 0); s: STD_LOGIC; y: STD_LOGIC_VECTOR(width /H110021 downto 0)); end; architecture synth mux2 begin /H11021/H11005d0 /H11005‘0’ else d1; end; generic statement includes default value (8) width . value integer. entity mux4_8 port(d0, d1, d2, d3: STD_LOGIC_VECTOR(7 downto 0); s: STD_LOGIC_VECTOR(1 downto 0); y: STD_LOGIC_VECTOR(7 downto 0)); end; architecture struct mux4_8 component mux2 generic(width: integer); port(d0, d1: STD_LOGIC_VECTOR(width /H110021 downto 0) ; s: STD_LOGIC; y: STD_LOGIC_VECTOR(width /H110021 downto 0)); end component; signal low, hi: STD_LOGIC_VECTOR(7 downto 0); begin lowmux: mux2 port map(d0, d1, s(0), low); himux: mux2 port map(d2, d3, s(0), hi); outmux: mux2 port map(low, hi, s(1), y); end; 8-bit 4:1 multiplexer, mux4_8 , instantiates three 2:1 multiplexers using default widths. contrast, 12-bit 4:1 multiplexer, mux4_12 , would need override default width using generic map , shown below. lowmux: mux2 generic map(12) port map(d0, d1, s(0), low); himux: mux2 generic map(12) port map(d2, d3, s(0), hi); outmux: mux2 generic map(12) port map(low, hi, s(1), y);HDL Example 4.34 PARAMETERIZED N-BIT MULTIPLEXERS4.7 PARAMETERIZED MODULES* far modules fixed-width inputs outputs. example, define separate modules 4- 8-bit wide 2:1 mul- tiplexers. HDLs permit variable bit widths using parameterized modules.Chapter 04.qxd 1/31/07 8:17 PM Page 211HDL Example 4.34 declares parameterized 2:1 multiplexer default width 8, uses create 8- 12-bit 4:1 multiplexers. HDL Example 4.35 shows decoder, even better applica- tion parameterized modules. large N:2Ndecoder cumbersome to212 CHAPTER FOUR Hardware Description Languages mux2_12 lowmux mux2_12 himuxmux2_12 outmuxy[11:0]s[1:0][1:0] d3[11:0]d2[11:0]d1[11:0]d0[11:0][0]s [11:0]d0[11:0] [11:0]d1[11:0]y[11:0] [1]s [11:0]d0[11:0] [11:0]d1[11:0]y[11:0][1]s [11:0]d0[11:0] [11:0]d1[11:0][11:0]y[11:0] Figure 4.30 mux4_12 synthesized circuit Verilog module decoder #(parameter N /H110053) (input [N /H110021:0] a, output reg [2**N /H110021:0] y); always @ (*) begin /H110050; y[a] /H110051; end endmodule 2**N indicates 2N.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; use IEEE.STD_LOGIC_UNSIGNED.all; use IEEE.STD_LOGIC_ARITH.all; entity decoder generic(N: integer : /H110053); port(a: STD_LOGIC_VECTOR(N /H110021 downto 0); y: STD_LOGIC_VECTOR(2**N /H110021 downto 0)); end; architecture synth decoder begin process(a) variable tmp: STD_LOGIC_VECTOR(2**N /H110021 downto 0); begin tmp : /H11005CONV_STD_LOGIC_VECTOR(0, 2**N); tmp(CONV_INTEGER(a)): /H11005‘1’; /H11021/H11005tmp; end process; end; 2**N indicates 2N. CONV_STD_LOGIC_VECTOR(0, 2**N) produces STD_LOGIC_VECTOR length 2Ncontaining 0’s. requires STD_LOGIC_ARITH library. function useful parameterized functions, resettable flip-flops need able produce constants parameterized number bits. bit index VHDL must integer, CONV_INTEGER function used convert afrom STD_LOGIC_VECTOR integer.HDL Example 4.35 PARAMETERIZED N:2NDECODERChapter 04.qxd 1/31/07 8:17 PM Page 2124.7 Parameterized Modules 213 specify case statements, easy using parameterized code sim- ply sets appropriate output bit 1. Specifically, decoder uses blocking assignments set bits 0, changes appropriate bit 1. HDLs also provide generate statements produce variable amount hardware depending value parameter. generate supports forloops ifstatements determine many types hardware produce. HDL Example 4.36 demonstrates use generate statements produce N-input function cascade two-input gates. Use generate statements caution; easy produce large amount hardware unintentionally! Verilog module andN #(parameter width /H110058) (input [width /H110021:0] a, output y); genvar i; wire[width /H110021:1] x; generate for(i /H110051; /H11021width; /H11005i/H110011) begin:forloop if(i /H11005/H110051) assign x[1] /H11005a[0] & a[1]; else assign x[i] /H11005a[i] & x[i /H110021]; end endgenerate assign /H11005x[width /H110021]; endmodule forstatement loops i/H110051, 2, . . . , width /H110021to produce many consecutive gates. begin generate loop must followed : arbitrary label (forloop , case). course, writing assign /H11005&awould much easier!VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity andN generic(width: integer : /H110058); port(a: STD_LOGIC_VECTOR(width /H110021 downto 0); y: STD_LOGIC); end; architecture synth andN signal i: integer; signal x: STD_LOGIC_VECTOR(width /H110021 downto 1); begin AllBits: 1 width /H110021 generate LowBit: /H110051 generate A1: x(1) /H11021/H11005a(0) a(1); end generate; OtherBits: / /H110051 generate Ai: x(i) /H11021/H11005a(i) x(i /H110021); end generate; end generate; /H11021/H11005x(width /H110021); end;HDL Example 4.36 PARAMETERIZED N-INPUT GATE x[1]x[2]x[3]x[4]x[5]x[6]x[7]y[7] a[7:0][7:0][0][1][1][2][2] [1][3][3][2][4][4][3][5][5][4][6][6][5][7][7] [6] Figure 4.31 andN synthesized circuitChapter 04.qxd 1/31/07 8:17 PM Page 2134.8 TESTBENCHES testbench HDL module used test another module, called device test (DUT ). testbench contains statements apply inputs DUT and, ideally, check correct outputs pro- duced. input desired output patterns called test vectors. Consider testing sillyfunction module Section 4.1.1 computes . simple module, perform exhaustive testing applying eight possible test vectors. HDL Example 4.37 demonstrates simple testbench. instantiates DUT, applies inputs. Blocking assignments delays used apply inputs appropriate order. user must view results simulation verify inspection correct outputs produced. Testbenches simulated HDL modules. However, synthesizeable.y/H11005a b c/H11001ab c/H11001abc214 CHAPTER FOUR Hardware Description Languages Verilog module testbench1(); reg a, b, c; wire y; // instantiate device test sillyfunction dut(a, b, c, y); // apply inputs one time initial begin /H110050; b /H110050; c /H110050; #10; c /H110051; #10; b /H110051; c /H110050; #10; c /H110051; #10; /H110051; b /H110050; c /H110050; #10; c /H110051; #10; b /H110051; c /H110050; #10; c /H110051; #10; end endmodule initial statement executes statements body start simulation. case, first applies input pattern 000 waits 10 time units. applies 001 waits 10 units, forth eight possible inputs applied. initial statements used testbenches simulation, modules intended synthesized actual hardware. Hardware way magically executing sequence special steps first turned on. Like signals always statements, signals initial statements must declared reg.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity testbench1 — — inputs outputs end; architecture sim testbench1 component sillyfunction port(a, b, c: STD_LOGIC; y: STD_LOGIC); end component; signal a, b, c, y: STD_LOGIC; begin — — instantiate device test dut: sillyfunction port map(a, b, c, y); — — apply inputs one time process begin /H11021/H11005‘0’; b /H11021/H11005‘0’; c /H11021/H11005‘0’; wait 10 ns; c /H11021/H11005‘1’; wait 10 ns; b /H11021/H11005‘1’; c /H11021/H11005‘0’; wait 10 ns; c /H11021/H11005‘1’; wait 10 ns; /H11021/H11005‘1’; b /H11021/H11005‘0’; c /H11021/H11005‘0’; wait 10 ns; c /H11021/H11005‘1’; wait 10 ns; b /H11021/H11005‘1’; c /H11021/H11005‘0’; wait 10 ns; c /H11021/H11005‘1’; wait 10 ns; wait; — — wait forever end process; end; process statement first applies input pattern 000 waits 10 ns. applies 001 waits 10 ns, forth eight possible inputs applied. end, process waits indefinitely; otherwise, process would begin again, repeatedly applying pattern test vectors.HDL Example 4.37 TESTBENCHSome tools also call module tested unit test (UUT ).Chapter 04.qxd 1/31/07 8:17 PM Page 2144.8 Testbenches 215 Checking correct outputs tedious error-prone. Moreover, determining correct outputs much easier design fresh mind; make minor changes need retest weeks later, determining correct outputs becomes hassle. much better approach write self-checking testbench, shown HDL Example 4.38. Writing code test vector also becomes tedious, especially modules require large number vectors. even better approach place test vectors separate file. testbench simply reads test vectors file, applies input test vector DUT, waits, checks output values DUT match output vector, repeats reaching end test vectors file.Verilog module testbench2(); reg a, b, c; wire y; // instantiate device test sillyfunction dut(a, b, c, y); // apply inputs one time // checking results initial begin /H110050; b /H110050; c /H110050; #10; if(y ! /H11005/H110051)$display(“000 failed.”); c /H110051; #10; if(y ! /H11005/H110050)$display(“001 failed.”); b /H110051; c /H110050; #10; if(y ! /H11005/H110050)$display(“010 failed.”); c /H110051; #10; if(y ! /H11005/H110050)$display(“011 failed.”); /H110051; b /H110050; c /H110050; #10; if(y ! /H11005/H110051)$display(“100 failed.”); c /H110051; #10; if(y ! /H11005/H110051)$display(“101 failed.”); b /H110051; c /H110050; #10; if(y ! /H11005/H110050)$display(“110 failed.”); c /H110051; #10; if(y ! /H11005/H110050)$display(“111 failed.”); end endmodule module checks yagainst expectations input test vector applied. Verilog, comparison using /H11005/H11005or !/H11005 effective signals take values xand z. Testbenches use /H11005/H11005/H11005 !/H11005/H11005operators comparisons equality inequality, respectively, operators work correctly operands could x z. uses $display system task print message simulator console error occurs. $display meaning- ful simulation, synthesis.VHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity testbench2 — — inputs outputs end; architecture sim testbench2 component sillyfunction port(a, b, c: STD_LOGIC; y: STD_LOGIC); end component; signal a, b, c, y: STD_LOGIC; begin — — instantiate device test dut: sillyfunction port map(a, b, c, y); — — apply inputs one time — — checking results process begin /H11021/H11005‘0’; b /H11021/H11005‘0’; c /H11021/H11005‘0’; wait 10 ns; assert /H11005‘1’ report “000 failed.”; c /H11021/H11005‘1’; wait 10 ns; assert /H11005‘0’ report “001 failed.”; b /H11021/H11005‘1’; c /H11021/H11005‘0’; wait 10 ns; assert /H11005‘0’ report “010 failed.”; c /H11021/H11005‘1’; wait 10 ns; assert /H11005‘0’ report “011 failed.”; /H11021/H11005‘1’; b /H11021/H11005‘0’; c /H11021/H11005‘0’; wait 10 ns; assert /H11005‘1’ report “100 failed.”; c /H11021/H11005‘1’; wait 10 ns; assert /H11005‘1’ report “101 failed.”; b /H11021/H11005‘1’; c /H11021/H11005‘0’; wait 10 ns; assert /H11005‘0’ report “110 failed.”; c /H11021/H11005‘1’; wait 10 ns; assert /H11005‘0’ report “111 failed.”; wait; — — wait forever end process; end; assert statement checks condition prints message given report clause condition satisfied. assert meaningful simulation, synthesis.HDL Example 4.38 SELF-CHECKING TESTBENCHChapter 04.qxd 1/31/07 8:17 PM Page 215HDL Example 4.39 demonstrates testbench. testbench gen- erates clock using always/process statement stimulus list, continuously reevaluated. beginning simulation, reads test vectors text file pulses reset two cycles. example.tv text file containing inputs expected output written binary: 000_1 001_0 010_0 011_0 100_1 101_1 110_0 111_0216 CHAPTER FOUR Hardware Description Languages Verilog module testbench3(); reg clk, reset; reg a, b, c, yexpected; wire y; reg[31:0] vectornum, errors; reg[3:0] testvectors[10000:0]; // instantiate device test sillyfunction dut(a, b, c, y); // generate clock always begin clk /H110051; #5; clk /H110050; #5; end // start test, load vectors // pulse reset initial begin $readmemb(“example.tv”, testvectors); vectornum /H110050; errors /H110050; reset /H110051; #27; reset /H110050; end // apply test vectors rising edge clk always @ (posedge clk) begin #1; {a, b, c, yexpected} /H11005 testvectors[vectornum]; end // check results falling edge clk always @ (negedge clk) if(~reset)begin // skip reset if(y ! /H11005/H11005yexpected)beginVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; use STD.TEXTIO.all; entity testbench3 — — inputs outputs end; architecture sim testbench3 component sillyfunction port(a, b, c: STD_LOGIC; y: STD_LOGIC); end component; signal a, b, c, y: STD_LOGIC; signal clk, reset: STD_LOGIC; signal yexpected: STD_LOGIC; constant MEMSIZE: integer : /H1100510000; type tvarray array(MEMSIZE downto 0)of STD_LOGIC_VECTOR(3 downto 0); signal testvectors: tvarray; shared variable vectornum, errors: integer; begin — — instantiate device test dut: sillyfunction port map(a, b, c, y); — — generate clock process begin clk /H11021/H11005‘1’; wait 5 ns; clk /H11021/H11005‘0’; wait 5 ns; end process; — — start test, load vectors — — pulse reset process file tv: TEXT; variable i, j: integer; variable L: line; variable ch: character;HDL Example 4.39 TESTBENCH TEST VECTOR FILEChapter 04.qxd 1/31/07 8:17 PM Page 2164.8 Testbenches 217 $display (“Error: inputs /H11005%b”, {a, b, c}); $display(“ outputs /H11005%b(%b expected)”, y, yexpected); errors /H11005errors /H110011; end vectornum /H11005vectornum /H110011; if(testvectors[vectornum] /H11005/H11005/H110054’bx)begin $display(“%d tests completed %d errors”, vectornum, errors); $finish; end end endmodule $readmemb reads file binary numbers testvectors array. $readmemh similar reads file hexadecimal numbers. next block code waits one time unit rising edge clock (to avoid confusion clock data change simultaneously), sets three inputs expected output based four bits current test vector. next block code checks output DUT negative edge clock, inputs time propagate DUT produce output, y. testbench compares generated output, y, expected output, yexpected , prints error don’t match. %band %dindicate print values binary decimal, respectively. example, $display (“%b %b” , y, yexpected); prints two values, yand yexpected , binary. %hprints value hexadecimal. process repeats valid test vectors testvectors array. $finish terminates simulation. Note even though Verilog module supports 10,001 test vectors, terminate simulation executing eight vectors file.begin — — read file test vectors :/H110050; FILE_OPEN(tv, “example.tv”, READ_MODE); endfile(tv) loop readline(tv, L); j 0 3 loop read(L, ch); if(ch /H11005‘_’) read(L, ch); end if; if(ch /H11005‘0’) testvectors(i)(j) /H11021/H11005‘0’; else testvectors(i)(j) /H11021/H11005‘1’; end if; end loop; :/H11005i /H110011; end loop; vectornum : /H110050; errors : /H110050; reset /H11021/H11005‘1’; wait 27 ns; reset /H11021/H11005‘0’; wait; end process; — — apply test vectors rising edge clk process(clk)begin if(clk’event clk /H11005‘1’)then /H11021/H11005testvectors(vectornum)(0)after 1 ns; b /H11021/H11005testvectors(vectornum)(1)after 1 ns; c /H11021/H11005testvectors(vectornum)(2)after 1 ns; yexpected /H11021/H11005testvectors(vectornum)(3) 1 ns; end if; end process; — — check results falling edge clk process(clk)begin if(clk’event clk /H11005‘0’ reset /H11005‘0’)then assert /H11005yexpected report “Error: /H11005” & STD_LOGIC’image(y); if(y / /H11005yexpected)then errors : /H11005errors /H110011; end if; vectornum : /H11005vectornum /H110011; if(is_x(testvectors(vector num)))then if(errors /H110050)then report “Just kidding — —” & integer’image(vectornum)& “tests completed successfully.” severity failure; else report integer’image(vectornum)& “tests completed, errors /H11005” & integer’image(errors) severity failure; end if; end if; end if; end process; end; VHDL code rather ungainly uses file reading com- mands beyond scope chapter, gives sense self-checking testbench looks like.Chapter 04.qxd 1/31/07 8:17 PM Page 217218 CHAPTER FOUR Hardware Description Languages New inputs applied rising edge clock, output checked falling edge clock. clock (and reset ) would also provided DUT sequential logic tested. Errors reported occur. end simulation, testbench prints total number test vectors applied number errors detected. testbench HDL Example 4.39 overkill simple circuit. However, easily modified test complex circuits changing example.tv file, instantiating new DUT, chang- ing lines code set inputs check outputs. 4.9 SUMMARY Hardware description languages (HDLs) extremely important tools modern digital designers. learned Verilog VHDL, able specify digital systems much faster draw complete schematics. debug cycle also often much faster, modifications require code changes instead tedious schematic rewiring. However, debug cycle much longer using HDLs don’t good idea hardware code implies. HDLs used simulation synthesis. Logic simulation powerful way test system computer turned hardware. Simulators let check values signals inside sys- tem might impossible measure physical piece hard- ware. Logic synthesis converts HDL code digital logic circuits. important thing remember writing HDL code describing real hardware, writing computer program. common beginner’s mistake write HDL code without thinking hardware intend produce. don’t know hardware implying, almost certain get want. Instead, begin sketching block diagram system, identifying portions combinational logic, portions sequential circuits finite state machines, forth. write HDL code portion, using correct idioms imply kind hardware need.Chapter 04.qxd 1/31/07 8:17 PM Page 218Exercises 219 Exercises following exercises may done using favorite HDL. simu- lator available, test design. Print waveforms explain prove works. synthesizer available, synthesize code. Print generated circuit diagram, explain matches expectations. Exercise 4.1 Sketch schematic circuit described following HDL code. Simplify schematic shows minimum number gates. Exercise 4.2 Sketch schematic circuit described following HDL code. Simplify schematic shows minimum number gates. Exercise 4.3 Write HDL module computes four-input XOR function. input a3:0, output y.Verilog module exercise1(input a, b, c, output y, z); assign /H11005a & b & c | & b & ~c | & ~b & c; assign z /H11005a & b | ~a & ~b; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity exercise1 port(a, b, c: STD_LOGIC; y, z: STD_LOGIC); end; architecture synth exercisel begin /H11021/H11005(a b c)or(a b (not c))or (a and(not b)and c); z /H11021/H11005(a b)or((not a) and(not b)); end; Verilog module exercise2(input [3:0] a, output reg [1:0] y); always @(*) (a[0]) /H110052’b11; else if(a[1]) /H110052’b10; else if(a[2]) /H110052’b01; else if(a[3]) /H110052’b00; else /H11005a[1:0]; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity exercise2 port(a: STD_LOGIC_VECTOR(3 downto 0); y: STD_LOGIC_VECTOR(1 downto 0)); end; architecture synth exercise2 begin process(a)begin a(0) /H11005‘1’ /H11021/H11005“11”; elsif a(1) /H11005‘1’ /H11021/H11005“10”; elsif a(2) /H11005‘1’ /H11021/H11005“01”; elsif a(3) /H11005‘1’ /H11021/H11005“00”; else /H11021/H11005a(1 downto 0); end if; end process; end;Chapter 04.qxd 1/31/07 8:17 PM Page 219220 CHAPTER FOUR Hardware Description Languages Exercise 4.4 Write self-checking testbench Exercise 4.3. Create test vector file containing 16 test cases. Simulate circuit show works. Intro- duce error test vector file show testbench reports mismatch. Exercise 4.5 Write HDL module called minority . receives three inputs, a,b,and c.It produces one output, y, TRUE least two inputs FALSE. Exercise 4.6 Write HDL module hexadecimal seven-segment display decoder. decoder handle digits A, B, C, D, E, F well 0–9. Exercise 4.7 Write self-checking testbench Exercise 4.6. Create test vector file containing 16 test cases. Simulate circuit show works. Introduce error test vector file show testbench reports mismatch. Exercise 4.8 Write 8:1 multiplexer module called mux8 inputs s2:0, d0, d1, d2, d3, d4, d5, d6, d7, output y. Exercise 4.9 Write structural module compute logic function, , using multiplexer logic. Use 8:1 multiplexer Exercise 4.8. Exercise 4.10 Repeat Exercise 4.9 using 4:1 multiplexer many gates need. Exercise 4.11 Section 4.5.4 pointed synchronizer could correctly described blocking assignments assignments given proper order. Think simple sequential circuit cannot correctly described blocking assignments, regardless order. Exercise 4.12 Write HDL module eight-input priority circuit. Exercise 4.13 Write HDL module 2:4 decoder. Exercise 4.14 Write HDL module 6:64 decoder using three instances 2:4 decoders Exercise 4.13 bunch three-input gates. Exercise 4.15 Write HDL modules implement Boolean equations Exercise 2.7. Exercise 4.16 Write HDL module implements circuit Exercise 2.18. Exercise 4.17 Write HDL module implements logic function Exercise 2.19. Pay careful attention handle don’t cares.y/H11005ab/H11001b c/H11001a bcChapter 04.qxd 1/31/07 8:17 PM Page 220Exercises 221 Exercise 4.18 Write HDL module implements functions Exercise 2.24. Exercise 4.19 Write HDL module implements priority encoder Exercise 2.25. Exercise 4.20 Write HDL module implements binary-to-thermometer code converter Exercise 2.27. Exercise 4.21 Write HDL module implementing days-in-month function Question 2.2. Exercise 4.22 Sketch state transition diagram FSM described following HDL code. Verilog module fsm2(input clk, reset, input a, b, output y); reg [1:0] state, nextstate; parameter S0 /H110052’b00; parameter S1 /H110052’b01; parameter S2 /H110052’b10; parameter S3 /H110052’b11; always @ (posedge clk, posedge reset) if(reset)state /H11021/H11005S0; else state /H11021/H11005nextstate; always @ (*) case(state) S0: if(a /H11625b) nextstate /H11005S1; else nextstate /H11005S0; S1: if(a & b) nextstate /H11005S2; else nextstate /H11005S0; S2: if(a | b) nextstate /H11005S3; else nextstate /H11005S0; S3: if(a | b) nextstate /H11005S3; else nextstate /H11005S0; endcase assign /H11005(state /H11005/H11005S1) | (state /H11005/H11005S2); endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity fsm2 port(clk, reset: STD_LOGIC; a, b: STD_LOGIC; y: STD_LOGIC); end; architecture synth fsm2 type statetype is(S0, S1, S2, S3); signal state, nextstate: statetype; begin process(clk, reset)begin reset /H11005‘1’ state /H11021/H11005S0; elsif clk’event clk /H11005‘1’ state /H11021/H11005nextstate; end if; end process; process(state, a, b)begin case state S0 /H11005/H11022if(a xor b) /H11005‘1’ nextstate /H11021/H11005S1; else nextstate /H11021/H11005S0; end if; S1 /H11005/H11022if(a b) /H11005‘1’ nextstate /H11021/H11005S2; else nextstate /H11021/H11005S0; end if; S2 /H11005/H11022if(a b) /H11005‘1’ nextstate /H11021/H11005S3; else nextstate /H11021/H11005S0; end if; S3 /H11005/H11022if(a b) /H11005‘1’ nextstate /H11021/H11005S3; else nextstate /H11021/H11005S0; end if; end case; end process; /H11021/H11005‘1’ when((state /H11005S1)or(state /H11005S2)) else ‘0’; end;Chapter 04.qxd 1/31/07 8:17 PM Page 221222 CHAPTER FOUR Hardware Description Languages Exercise 4.23 Sketch state transition diagram FSM described following HDL code. FSM nature used branch predictor microprocessors. Verilog module fsm1(input clk, reset, input taken, back, output predicttaken); reg [4:0] state, nextstate; parameter S0 /H110055’b00001; parameter S1 /H110055’b00010; parameter S2 /H110055’b00100; parameter S3 /H110055’b01000; parameter S4 /H110055’b10000; always @ (posedge clk, posedge reset) if(reset)state /H11021/H11005S2; else state /H11021/H11005nextstate; always @ (*) case(state) S0: if(taken)nextstate /H11005S1; else nextstate /H11005S0; S1: if(taken)nextstate /H11005S2; else nextstate /H11005S0; S2: if(taken)nextstate /H11005S3; else nextstate /H11005S1; S3: if(taken)nextstate /H11005S4; else nextstate /H11005S2; S4: if(taken)nextstate /H11005S4; else nextstate /H11005S3; default: nextstate /H11005S2; endcase assign predicttaken /H11005(state /H11005/H11005S4) | | (state /H11005/H11005S3) | | (state /H11005/H11005S2 && back); endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity fsm1 port(clk, reset: STD_LOGIC; taken, back: STD_LOGIC; predicttaken: STD_LOGIC); end; architecture synth fsm1 type statetype is(S0, S1, S2, S3, S4); signal state, nextstate: statetype; begin process(clk, reset)begin reset /H11005‘1’ state /H11021/H11005S2; elsif clk’event clk /H11005‘1’ state /H11021/H11005nextstate; end if; end process; process(state, taken)begin case state S0 /H11005/H11022if taken /H11005‘1’ nextstate /H11021/H11005S1; else nextstate /H11021/H11005S0; end if; S1 /H11005/H11022if taken /H11005‘1’ nextstate /H11021/H11005S2; else nextstate /H11021/H11005S0; end if; S2 /H11005/H11022if taken /H11005‘1’ nextstate /H11021/H11005S3; else nextstate /H11021/H11005S1; end if; S3 /H11005/H11022if taken /H11005‘1’ nextstate /H11021/H11005S4; else nextstate /H11021/H11005S2; end if; S4 /H11005/H11022if taken /H11005‘1’ nextstate /H11021/H11005S4; else nextstate /H11021/H11005S3; end if; others /H11005/H11022nextstate /H11021/H11005S2; end case; end process; — — output logic predicttaken /H11021/H11005‘1’ ((state /H11005S4)or(state /H11005S3)or (state /H11005S2 back /H11005‘1’)) else ‘0’; end;Chapter 04.qxd 1/31/07 8:17 PM Page 222Exercises 223 Exercise 4.24 Write HDL module SR latch. Exercise 4.25 Write HDL module JK flip-flop. flip-flop inputs, clk, J , K, output Q. rising edge clock, Qkeeps old value J/H11005K/H110050. sets Qto 1 J/H110051, resets Qto 0 K/H110051, inverts Qif J/H11005K/H110051. Exercise 4.26 Write HDL module latch Figure 3.18. Use one assignment statement gate. Specify delays 1 unit 1 ns gate. Simulate latch show operates correctly. increase inverter delay. long delay race condition causes latch malfunction? Exercise 4.27 Write HDL module traffic light controller Section 3.4.1. Exercise 4.28 Write three HDL modules factored parade mode traffic light controller Example 3.8. modules called controller , mode,and lights ,and inputs outputs shown Figure 3.33(b). Exercise 4.29 Write HDL module describing circuit Figure 3.40. Exercise 4.30 Write HDL module FSM state transition diagram given Figure 3.65 Exercise 3.19. Exercise 4.31 Write HDL module FSM state transition diagram given Figure 3.66 Exercise 3.20. Exercise 4.32 Write HDL module improved traffic light controller Exercise 3.21. Exercise 4.33 Write HDL module daughter snail Exercise 3.22. Exercise 4.34 Write HDL module soda machine dispenser Exercise 3.23. Exercise 4.35 Write HDL module Gray code counter Exercise 3.24. Exercise 4.36 Write HDL module UP/DOWN Gray code counter Exercise 3.25. Exercise 4.37 Write HDL module FSM Exercise 3.26.Chapter 04.qxd 1/31/07 8:17 PM Page 223224 CHAPTER FOUR Hardware Description Languages Exercise 4.38 Write HDL module FSM Exercise 3.27. Exercise 4.39 Write HDL module serial two’s complementer Question 3.2. Exercise 4.40 Write HDL module circuit Exercise 3.28. Exercise 4.41 Write HDL module circuit Exercise 3.29. Exercise 4.42 Write HDL module circuit Exercise 3.30. Exercise 4.43 Write HDL module circuit Exercise 3.31. may use full adder Section 4.2.5. Verilog Exercises following exercises specific Verilog. Exercise 4.44 mean signal declared regin Verilog? Exercise 4.45 Rewrite syncbad module HDL Example 4.30. Use nonblocking assignments, change code produce correct synchronizer two flip-flops. Exercise 4.46 Consider following two Verilog modules. function? Sketch hardware one implies. module code1(input clk, a, b, c, output reg y); reg x; always @ (posedge clk) begin x /H11021/H11005a & b; /H11021/H11005x | c; end endmodule module code2(input a, b, c, clk, output reg y); reg x; always @ (posedge clk) begin /H11021/H11005x | c; x /H11021/H11005a & b; end endmodule Exercise 4.47 Repeat Exercise 4.46 /H11021/H11005is replaced /H11005in every assignment.Chapter 04.qxd 1/31/07 8:17 PM Page 224Exercises 225 Exercise 4.48 following Verilog modules show errors authors seen students make laboratory. Explain error module show fix it. (a)module latch(input clk, input [3:0] d, output reg [3:0] q); always @ (clk) if(clk)q /H11021/H11005d; endmodule (b)module gates(input [3:0] a, b, output reg [3:0] y1, y2, y3, y4, y5); always @ (a) begin y1 /H11005a & b; y2 /H11005a | b; y3 /H11005a /H11625b; y4 /H11005~(a & b); y5 /H11005~(a | b); end endmodule (c)module mux2(input [3:0] d0, d1, input s, output reg [3:0] y); always @ (posedge s) if(s)y /H11021/H11005d1; else /H11021/H11005d0; endmodule (d)module twoflops(input clk, input d0, d1, output reg q0, q1); always @ (posedge clk) q1 /H11005d1; q0 /H11005d0; endmoduleChapter 04.qxd 1/31/07 8:17 PM Page 225226 CHAPTER FOUR Hardware Description Languages (e)module FSM(input clk, input a, output reg out1, out2); reg state; // next state logic register (sequential) always @ (posedge clk) if(state /H11005/H110050)begin if(a) state /H11021/H110051; end else begin if(~a) state /H11021/H110050; end always @ (*)// output logic (combinational) if(state /H11005/H110050)out1 /H110051; else out2 /H110051; endmodule (f)module priority(input [3:0] a, output reg [3:0] y); always @ (*) (a[3])y /H110054’b1000; else if(a[2])y /H110054’b0100; else if(a[1])y /H110054/H11032b0010; else if(a[0])y /H110054/H11032b0001; endmodule (g)module divideby3FSM(input clk, input reset, output out); reg [1:0] state, nextstate; parameter S0 /H110052/H11032b00; parameter S1 /H110052/H11032b01; parameter S2 /H110052/H11032b10; // State Register always @ (posedge clk, posedge reset) if(reset) state /H11021/H11005S0; else state /H11021/H11005nextstate; // Next State Logic always @ (state) case(state) S0: nextstate /H11005S1; S1: nextstate /H11005S2; 2: nextstate /H11005S0; endcase // Output Logic assign /H11005(state /H11005/H11005S2); endmoduleChapter 04.qxd 1/31/07 8:17 PM Page 226Exercises 227 (h)module mux2tri(input [3:0] d0, d1, input s, output [3:0] y); tristate t0(d0, s, y); tristate t1(d1, s, y); endmodule (i)module floprsen(input clk, input reset, input set, input [3:0] d, output reg [3:0] q); always @ (posedge clk, posedge reset) if(reset)q /H11021/H110050; else q /H11021/H11005d; always @ (set) if(set) q /H11021/H110051; endmodule (j)module and3(input a, b, c, output reg y); reg tmp; always @ (a, b, c) begin tmp /H11021/H11005a & b; /H11021/H11005tmp & c; end endmodule VHDL Exercises following exercises specific VHDL. Exercise 4.49 VHDL, necessary write q /H11021/H11005‘1’ state /H11005S0 else ‘0’; rather simply q /H11021/H11005(state /H11005S0);Chapter 04.qxd 1/31/07 8:17 PM Page 227228 CHAPTER FOUR Hardware Description Languages Exercise 4.50 following VHDL modules contains error. brevity, architecture shown; assume library use clause entity declaration correct. Explain error show fix it. (a)architecture synth latch begin process(clk)begin clk /H11005‘1’ q /H11021/H11005d; end if; end process; end; (b)architecture proc gates begin process(a)begin y1 /H11021/H11005a b; y2 /H11021/H11005a b; y3 /H11021/H11005a xor b; y4 /H11021/H11005a nand b; y5 /H11021/H11005a b; end process; end; (c)architecture synth flop begin process(clk) clk’event clk /H11005‘1’ q /H11021/H11005d; end; (d)architecture synth priority begin process(a)begin a(3) /H11005‘1’ /H11021/H11005“1000”; elsif a(2) /H11005‘1’ /H11021/H11005“0100”; elsif a(1) /H11005‘1’ /H11021/H11005“0010”; elsif a(0) /H11005‘1’ /H11021/H11005“0001”; end if; end process; end; (e)architecture synth divideby3FSM type statetype is(S0, S1, S2); signal state, nextstate: statetype; begin process(clk, reset)begin reset /H11005‘1’ state /H11021/H11005S0; elsif clk’event clk /H11005‘1’ state /H11021/H11005nextstate; end if; end process;Chapter 04.qxd 1/31/07 8:17 PM Page 228Exercises 229 process(state)begin case state S0 /H11005/H11022nextstate /H11021/H11005S1; S1 /H11005/H11022nextstate /H11021/H11005S2; S2 /H11005/H11022nextstate /H11021/H11005S0; end case; end process; q /H11021/H11005‘1’ state /H11005S0 else ‘0’; end; (f)architecture struct mux2 component tristate port(a: STD_LOGIC_VECTOR(3 downto 0); en: STD_LOGIC; y: STD_LOGIC_VECTOR(3 downto 0)); end component; begin t0: tristate port map(d0, s, y); t1: tristate port map(d1, s, y); end; (g)architecture asynchronous flopr begin process(clk, reset)begin reset /H11005‘1’ q /H11021/H11005‘0’; elsif clk’event clk /H11005‘1’ q /H11021/H11005d; end if; end process; process(set)begin set /H11005‘1’ q /H11021/H11005‘1’; end if; end process; end; (h)architecture synth mux3 begin /H11021/H11005d2 s(1)else d1 s(0)else d0; end;Chapter 04.qxd 1/31/07 8:17 PM Page 229Interview Questions following exercises present questions asked interviews digital design jobs. Question 4.1 Write line HDL code gates 32-bit bus called data another signal called selto produce 32-bit result . selis TRUE, result /H11005data. Otherwise, result 0’s. Question 4.2 Explain difference blocking nonblocking assignments Verilog. Give examples. Question 4.3 following Verilog statement do? result /H11005| (data[15:0] & 16 /H11032hC820);230 CHAPTER FOUR Hardware Description LanguagesChapter 04.qxd 1/31/07 8:17 PM Page 2305 5.1 Introduction 5.2 Arithmetic Circuits 5.3 Number Systems 5.4 Sequential Building Blocks 5.5 Memory Arrays 5.6 Logic Arrays 5.7 Summary Exercises Interview QuestionsDigital Building Blocks 5.1 INTRODUCTION point, examined design combinational sequential circuits using Boolean equations, schematics, HDLs. chapter introduces elaborate combinational sequential building blocks used digital systems. blocks include arithmetic circuits, counters, shift registers, memory arrays, logic arrays. building blocks useful right, also demonstrate principles hierarchy, modularity, regularity. building blocks hierarchically assembled simpler components logic gates, mul- tiplexers, decoders. building block well-defined interface treated black box underlying implementation unimportant. regular structure building block easily extended different sizes. Chapter 7, use many building blocks build microprocessor. 5.2 ARITHMETIC CIRCUITS Arithmetic circuits central building blocks computers. Computers digital logic perform many arithmetic functions: addi- tion, subtraction, comparisons, shifts, multiplication, division. section describes hardware implementations operations. 5.2.1 Addition Addition one common operations digital systems. first consider add two 1-bit binary numbers. extend N-bit binary numbers. Adders also illustrate trade-offs speed complexity. Half Adder begin building 1-bit half adder. shown Figure 5.1, half adder two inputs, Aand B,and two outputs, Sand Cout. Sis 233AB 0 0 1 10 1 1 0S Cout 0 0 0 10 1 0 1 = ⊕ B Cout = ABHalf Adder AB SCout+ FIGURE 5.1 1-bit half adderChapter 05.qxd 1/27/07 10:27 Page 233234 CHAPTER FIVE Digital Building Blocks 0001 +0101 01101 Figure 5.2 Carry bit AB 0 0 1 10 1 1 0S Cout 0 0 0 1 = ⊕ B ⊕ C Cout = AB + AC + BC inFull Adder C 0 0 1 10 1 0 1 0 1 0 10 0 0 0 1 1 1 11 0 0 10 1 1 1AB SCoutC in+ FIGURE 5.3 1-bit full adder AB SCout C in+ NN N Figure 5.4 Carry propagate addersum Aand B.If Aand Bare 1, Sis 2, cannot repre- sented single binary digit. Instead, indicated carry out, Cout, next column. half adder built XOR gate gate. multi-bit adder, Coutis added carried next sig- nificant bit. example, Figure 5.2, carry bit shown blue output, Cout, first column 1-bit addition input, Cin, second column addition. However, half adder lacks Cininput accept Coutof previous column. full adder, described next section, solves problem. Full Adder full adder, introduced Section 2.1, accepts carry in, Cin, shown Figure 5.3. figure also shows output equations Sand Cout. Carry Propagate Adder N-bit adder sums two N-bit inputs, Aand B,and carry in, Cin, produce N-bit result, S,and carry out, Cout. commonly called carry propagate adder (CPA) carry one bit propagates next bit. symbol CPA shown Figure 5.4; drawn like full adder except A, B, Sare busses rather single bits. Three common CPA implementations called ripple- carry adders, carry-lookahead adders, prefix adders. Ripple-Carry Adder simplest way build N-bit carry propagate adder chain together Nfull adders. Coutof one stage acts Cinof next stage, shown Figure 5.5 32-bit addition. called ripple- carry adder. good application modularity regularity: full adder module reused many times form larger system. ripple- carry adder disadvantage slow Nis large. S31 depends C30, depends C29, depends C28, forth way back Cin, shown blue Figure 5.5. say carry ripples carry chain. delay adder, tripple, grows directly number bits, given Equation 5.1, tFAis delay full adder. (5.1) tripple /H11005NtFA S31A30 B30 S30A1 B1 S1A0 B0 S0 C30 C 29 C1 C0Cout+ + + +A31 B31 C Figure 5.5 32-bit ripple-carry adderSchematics typically show signals flowing left right. Arithmetic circuits break rule carries flow right left (from least signifi- cant column significant column).Chapter 05.qxd 1/27/07 10:27 Page 234Carry-Lookahead Adder fundamental reason large ripple-carry adders slow carry signals must propagate every bit adder. carry- lookahead adder another type carry propagate adder solves problem dividing adder blocks providing circuitry quickly determine carry block soon carry known. Thus said look ahead across blocks rather waiting ripple full adders inside block. example, 32-bit adder may divided eight 4-bit blocks. Carry-lookahead adders use generate (G) propagate (P) signals describe column block determines carry out. ith column adder said generate carry produces carry independent carry in. ith column adder guaranteed generate carry, Ci, Aiand Biare 1. Hence Gi, generate sig- nal column i,is calculated Gi/H11005AiBi. column said propa- gate carry produces carry whenever carry in. ith column propagate carry in, Ci/H110021,if either Aior Biis 1. Thus, Pi/H11005Ai/H11001Bi. Using definitions, rewrite carry logic particular column adder. ith column adder generate carryout, Ci, either generates carry, Gi, propagates carry in, PiCi/H110021.In equation form, (5.2) generate propagate definitions extend multiple-bit blocks. block said generate carry produces carry independent carry block. block said propagate carry produces carry whenever carry block. define Gi:jand Pi:jas generate propagate signals blocks span- ning columns ithrough j. block generates carry significant column generates carry, significant column propagates carry previ- ous column generated carry, forth. example, generate logic block spanning columns 3 0 (5.3) block propagates carry columns block propagate carry. example, propagate logic block spanning columns 3 0 (5.4) Using block generate propagate signals, quickly compute carry block, Ci, using carry block, Cj. (5.5) Ci/H11005Gi:j/H11001Pi:j CjP3:0/H11005P3 P2 P1 P0G3:0/H11005G3/H11001P3 (G2/H11001P2 (G1/H11001P1 G0))Ci/H11005Ai Bi/H11001(Ai/H11001Bi) Ci/H110021/H11005Gi/H11001Pi Ci/H1100215.2 Arithmetic Circuits 235 Throughout ages, people used many devices perform arithmetic. Toddlers count fingers (and adults stealthily too). Chinese Babylonians invented abacus early 2400 BC. Slide rules, invented 1630, use 1970’s, scientific hand calculators became prevalent. Computers digital calcula- tors ubiquitous today. next? Chapter 05.qxd 1/27/07 10:27 Page 235Figure 5.6(a) shows 32-bit carry-lookahead adder composed eight 4-bit blocks. block contains 4-bit ripple-carry adder lookahead logic compute carry block given carry in, shown Figure 5.6(b). gates needed compute single-bit generate propagate signals, Giand Pi, Aiand Biare left brevity. Again, carry-lookahead adder demonstrates modularity regularity. CLA blocks compute single-bit block generate propagate signals simultaneously. critical path starts comput- ing G0and G3:0in first CLA block. Cinthen advances directly Coutthrough AND/OR gate block last. large adder, much faster waiting carries ripple consecutive bit adder. Finally, critical path last block contains short ripple-carry adder. Thus, N-bit adder divided k-bit blocks delay (5.6) tCLA /H11005tpg/H11001tpg/H11002block /H11001/H20898N k/H110021 /H20899 tAND /H11002OR/H11001ktFA236 CHAPTER FIVE Digital Building Blocks B0 + + + + P3:0G3 P3 G2 P2 G1 P1 G0 P3 P2 P1 P0G3:0 C inCoutA0 S0C0B1 A1 S1C1B2 A2 S2C2B3 A3 S3Cin (b)(a)A 3:0 B 3:0 S3:0C inA 7:4 B 7:4 S7:4C3 C7A 27:24 B27:24 S27:24C 23A 31:28 B31:28 S31:284-bit CLA Block4-bit CLA Block4-bit CLA Block4-bit CLA BlockC27Cout Figure 5.6 (a) 32-bit carry- lookahead adder (CLA), (b) 4-bit CLA blockChapter 05.qxd 1/27/07 10:27 Page 236where tpgis delay individual generate/propagate gates (a single gate) generate Pand G, pg_block delay find gen- erate/propagate signals Pi:jand Gi:jfor k-bit block, tAND_OR delay Cinto Coutthrough AND/OR logic k-bit CLA block. N/H1102216, carry-lookahead adder generally much faster ripple-carry adder. However, adder delay still increases linearly N. Example 5.1 RIPPLE-CARRY ADDER CARRY-LOOKAHEAD ADDER DELA Compare delays 32-bit ripple-carry adder 32-bit carry-lookahead adder 4-bit blocks. Assume two-input gate delay 100 ps full adder delay 300 ps. Solution: According Equation 5.1, propagation delay 32-bit ripple- carry adder 32 /H11003 300 ps /H110059.6 ns. CLA tpg/H11005100 ps, tpg_block /H110056/H11003100 ps /H11005600 ps, tAND_OR /H110052/H11003 100 ps /H11005200 ps. According Equation 5.6, propagation delay 32-bit carry-lookahead adder 4-bit blocks thus 100 ps /H11001600 ps /H11001(32/4 /H110021)/H11003 200 ps /H11001(4/H11003300 ps) /H110053.3 ns, almost three times faster ripple-carry adder. Prefix Adder* Prefix adders extend generate propagate logic carry- lookahead adder perform addition even faster. first compute G Pfor pairs columns, blocks 4, blocks 8, 16, forth generate signal every column known. sums computed generate signals. words, strategy prefix adder compute carry in, Ci/H110021,for column, i,as quickly possible, compute sum, using Si/H11005 (Ai /H20003 Bi) /H20003 Ci/H110021 (5.7) Define column i/H11005/H110021 hold Cin, G/H110021/H11005Cinand P/H110021/H110050. Ci/H110021/H11005Gi/H110021:/H110021because carry column i/H110021 block spanning columns i/H110021 /H110021 generates carry. generated carry either generated column i/H110021 generated previous column propagated. Thus, rewrite Equation 5.7 Si/H11005 (Ai /H20003 Bi) /H20003 Gi/H110021:/H110021 (5.8) Hence, main challenge rapidly compute block generate signals G/H110021:/H110021, G0:/H110021, G1:/H110021, G2:/H110021,..., GN/H110022:/H110021. signals, along P/H110021:/H110021, P0:/H110021, P1:/H110021, P2:/H110021,..., PN/H110022:/H110021,are called prefixes.5.2 Arithmetic Circuits 237 Early computers used ripple carry adders, components expensive ripple carry adders used least hardware. Virtually modern PCs use prefix adders critical paths, transistors cheap speed great importance.Chapter 05.qxd 1/27/07 10:27 Page 237Figure 5.7 shows N/H1100516-bit prefix adder. adder begins precomputation form Piand Gifor column Aiand Biusing gates. uses log 2N/H110054 levels black cells form prefixes Gi:jand Pi:j. black cell takes inputs upper part block spanning bits i:kand lower part spanning bits k/H110021:j.It combines parts form generate propagate signals entire block spanning bits i:j,using equations. (5.9) (5.10) words, block spanning bits i:jwill generate carry upper part generates carry upper part propagates carry gen- erated lower part. block propagate carry thePi:j /H11005 Pi:k Pk/H110021:jGi:j /H11005 Gi:k /H11001 Pi:k Gk/H110021:j238 CHAPTER FIVE Digital Building Blocks 0:–1–1 2:1 1:–1 2:–10 1 2 4:33 6:5 5:3 6:34 5 6 5:–1 6:–1 3:–1 4:–18:77 10:9 9:7 10:78 9 10 12:1111 14:13 13:11 14:1112 13 14 13:7 14:7 11:7 12:7 14:-1 13:–1 12:-1 11:–1 10:–1 9:–18 : –17 : –115 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 iB Gi :i Pi :iGk –1:j Pk –1:jGi :kPi :k G :j P :jAiB Gi –1:–1 ii :ji LegendFigure 5.7 16-bit prefix adderChapter 05.qxd 1/27/07 10:27 Page 238upper lower parts propagate carry. Finally, prefix adder com- putes sums using Equation 5.8. summary, prefix adder achieves delay grows logarith- mically rather linearly number columns adder. speedup significant, especially adders 32 bits, comes expense hardware simple carry- lookahead adder. network black cells called prefix tree. general principle using prefix trees perform computations time grows logarithmically number inputs power- ful technique. cleverness, applied many types circuits (see, example, Exercise 5.7). critical path N-bit prefix adder involves precomputation Piand Gifollowed log 2Nstages black prefix cells obtain prefixes. Gi/H110021:/H110021then proceeds final XOR gate bottom compute Si. Mathematically, delay N-bit prefix adder (5.11) tpg_prefix delay black prefix cell. Example 5.2 PREFIX ADDER DELA Compute delay 32-bit prefix adder. Assume two-input gate delay 100 ps. Solution: propagation delay black prefix cell, tpg_prefix, 200 ps (i.e., two gate delays). Thus, using Equation 5.11, propagation delay 32-bit prefix adder 100 ps /H11001log2(32) /H11003200 ps /H11001100 ps /H110051.2 ns, three times faster carry-lookahead adder eight times faster ripple-carry adder Example 5.1. practice, benefits quite great, prefix adders still substantially faster alternatives. Putting Together section introduced half adder, full adder, three types carry propagate adders: ripple-carry, carry-lookahead, prefix adders. Faster adders require hardware therefore expensive power-hungry. trade-offs must considered choosing appropriate adder design. Hardware description languages provide /H11001operation specify CPA. Modern synthesis tools select among many possible implementa- tions, choosing cheapest (smallest) design meets speed requirements. greatly simplifies designer’s job. HDL Example 5.1 describes CPA carries out.tPA/H11005tpg/H11001log2N(tpg/H11002prefix )/H11001tXOR5.2 Arithmetic Circuits 239Chapter 05.qxd 1/27/07 10:27 Page 239240 CHAPTER FIVE Digital Building Blocks Verilog module adder #(parameter N /H110058) (input [N /H110021:0] a, b, input cin, output [N /H110021:0] s, output cout); assign {cout, s} /H11005a /H11001b /H11001cin; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL; entity adder generic (N: integer : /H110058); port (a, b: STD_LOGIC_VECTOR(N /H110021 downto 0); cin: STD_LOGIC; s: STD_LOGIC_VECTOR(N /H110021 downto 0); cout: STD_LOGIC); end; architecture synth adder signal result: STD_LOGIC_VECTOR(N downto 0); begin result /H11021/H11005(“0” & a) /H11001(“0” & b) /H11001cin; /H11021/H11005result (N /H110021 downto 0); cout /H11021/H11005result (N); end;HDL Example 5.1 ADDER 5.2.2 Subtraction Recall Section 1.4.6 adders add positive negative numbers using two’s complement number representation. Subtraction almost easy: flip sign second number, add. Flipping sign two’s complement number done inverting bits adding 1. compute Y/H11005A/H11002B,first create two’s complement B: Invert bits Bto obtain add 1 get . Add quantity Ato get . sum per- formed single CPA adding Cin/H110051. Figure 5.9 shows symbol subtractor underlying hardware per- forming Y/H11005A/H11002B.HDL Example 5.2 describes subtractor. 5.2.3 Comparators comparator determines whether two binary numbers equal one greater less other. comparator receives two N-bit binary numbers, Aand B.There two common types comparators.A /H11001BY /H11005 A/H11001B/H110011/H11005A/H11002B/H11002B/H11005B/H110011 BAB – (a)N N N+ YAB (b)N N NN Figure 5.9 Subtractor: (a) symbol, (b) implementation+ cout[8]s[7:0][7:0] cinb[7:0]a[7:0][7:0] [8:0][7:0] [7:0] Figure 5.8 Synthesized adderChapter 05.qxd 1/27/07 10:27 Page 2405.2 Arithmetic Circuits 241 Verilog module subtractor #(parameter N /H110058) (input [N /H110021:0] a, b, output [N /H110021:0] y); assign /H11005a /H11002b; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL; entity subtractor generic (N: integer : /H110058); port (a, b: STD_LOGIC_VECTOR(N /H110021 downto 0); y: STD_LOGIC_VECTOR(N /H110021 downto 0)); end; architecture synth subtractor begin /H11021/H11005a /H11002b; end;HDL Example 5.2 SUBTRACTOR equality comparator produces single output indicating whether Ais equal B(A/H11005/H11005B). magnitude comparator produces one outputs indicating relative values Aand B. equality comparator simpler piece hardware. Figure 5.11 shows symbol implementation 4-bit equality compara- tor. first checks determine whether corresponding bits column Aand Bare equal, using XNOR gates. numbers equal columns equal. Magnitude comparison usually done computing A/H11002Band looking sign (most significant bit) result, shown Figure 5.12. result negative (i.e., sign bit 1), Ais less B. Otherwise Ais greater equal B. HDL Example 5.3 shows use various comparison operations.A 3 B 3 2 B 2 A1 B1 A0 B0Equal (b)Figure 5.11 4-bit equality comparator: (a) symbol, (b) implementation+ y[7:0][7:0]b[7:0]a[7:0][7:0] [7:0] 1 Figure 5.10 Synthesized subtractor (a)=AB Equal4 4 A<B–B [N –1]NNN Figure 5.12 N-bit magnitude comparatorChapter 05.qxd 1/27/07 10:27 Page 241242 CHAPTER FIVE Digital Building Blocks Verilog module comparators # (parameter N /H110058) (input [N /H110021:0] a, b, output eq, neq, output lt, lte, output gt, gte); assign eq /H11005(a /H11005/H11005b); assign neq /H11005(a ! /H11005b); assign lt /H11005(a /H11021b); assign lte /H11005(a /H11021/H11005b); assign gt /H11005(a /H11022b); assign gte /H11005(a /H11022/H11005b); endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.ALL; entity comparators generic (N: integer : /H110058); port (a, b: STD_LOGIC_VECTOR(N /H110021 downto 0); eq, neq, lt, lte, gt, gte: STD_LOGIC); end; architecture synth comparators begin eq /H11021/H11005‘1’ (a /H11005b) else ‘0’; neq /H11021/H11005‘1’ (a / /H11005b) else ‘0’; lt /H11021/H11005‘1’ (a /H11021b) else ‘0’; lte /H11021/H11005‘1’ (a /H11021/H11005b) else ‘0’; gt /H11021/H11005‘1’ (a /H11022b) else ‘0’; gte /H11021/H11005‘1’ (a /H11022/H11005b) else ‘0’; end;HDL Example 5.3 COMPARATORS 5.2.4 ALU Arithmetic/Logical Unit (ALU ) combines variety mathematical logical operations single unit. example, typical ALU might perform addition, subtraction, magnitude comparison, AND, operations. ALU forms heart computer systems. Figure 5.14 shows symbol N-bit ALU N-bit inputs outputs. ALU receives control signal, F,that specifies which= << gtegtlte ltneq eqb[7:0]a[7:0][7:0] [7:0] [7:0] [7:0][7:0] [7:0] Figure 5.13 Synthesized comparators ALUN N N3AB YF Figure 5.14 ALU symbolChapter 05.qxd 1/27/07 10:27 Page 242function perform. Control signals generally shown blue distinguish data. Table 5.1 lists typical functions ALU perform. SLT function used magnitude comparison discussed later section. Figure 5.15 shows implementation ALU. ALU con- tains N-bit adder Ntwo-input gates. also contains inverter multiplexer optionally invert input Bwhen F2control signal asserted. 4:1 multiplexer chooses desired function based F1:0control signals.5.2 Arithmetic Circuits 243 +AB Cout YF2 F1:0[N –1]SN N N N N N N N N2 0 10 1 2 3Zero extendBB Figure 5.15 N-bit ALUTable 5.1 ALU operations F2:0 Function 000 B 001 B 010 /H11001B 011 used 100 101 110 /H11002B 111 SLTBBChapter 05.qxd 1/27/07 10:27 Page 243More specifically, arithmetic logical blocks ALU operate Aand BB. BB either Bor , depending F2. F1:0/H1100500, output multiplexer chooses AAND BB. F1:0/H1100501, ALU computes AOR BB.If F1:0/H1100510, ALU performs addition subtrac- tion. Note F2is also carry adder. Also remember two’s complement arithmetic. F2/H110050, ALU com- putes A/H11001B.If F2/H110051, ALU computes . F2:0/H11005111, ALU performs set less (SLT) opera- tion. A/H11021B, /H110051. Otherwise, Y/H110050. words, Yis set 1 Ais less B. SLT performed computing S/H11005A/H11002B.If Sis negative (i.e., sign bit set), A/H11021B.The zero extend unit produces N-bit output concatenating 1-bit input 0’s significant bits. sign bit (the N/H110021thbit) Sis input zero extend unit. Example 5.3 SET LESS Configure 32-bit ALU SLT operation. Suppose A/H110052510and B/H110053210. Show control signals output, Y. Solution: A/H11021B,we expect Yto 1. SLT, F2:0/H11005111. F2/H110051, configures adder unit subtractor output, S,of 25 10/H110023210/H11005 /H11002710/H110051111 . . . 1001 2. F1:0/H1100511, final multiplexer sets Y/H11005S31/H110051. ALUs produce extra outputs, called flags, indicate infor- mation ALU output. example, overflow flag indicates result adder overflowed. zero flag indicates ALU output 0. HDL N-bit ALU left Exercise 5.9. many variations basic ALU support functions, XOR equality comparison. 5.2.5 Shifters Rotators Shifters rotators move bits multiply divide powers 2. name implies, shifter shifts binary number left right specified number positions. several kinds commonly used shifters: /L50776Logical shifter —shifts number left (LSL) right (LSR) fills empty spots 0’s. Ex: 11001 LSR 2 /H1100500110; 11001 LSL 2 /H1100500100 /L50776Arithmetic shifter —is logical shifter, right shifts fills significant bits copy old significant bit (msb). useful multiplying dividing signed numbersA/H11001B/H110011/H11005A/H11002BB /H110011/H11005/H11002BB244 CHAPTER FIVE Digital Building BlocksChapter 05.qxd 1/27/07 10:27 Page 244(see Sections 5.2.6 5.2.7). Arithmetic shift left (ASL) logical shift left (LSL). Ex: 11001 ASR 2 /H1100511110; 11001 ASL 2 /H1100500100 /L50776Rotator —rotates number circle empty spots filled bits shifted end. Ex: 11001 ROR 2 /H1100501110; 11001 ROL 2 /H1100500111 N-bit shifter built N N: 1 multiplexers. input shifted 0 N/H110021 bits, depending value log 2N-bit select lines. Figure 5.16 shows symbol hardware 4-bit shifters. operators /H11021/H11021, /H11022/H11022, /H11022/H11022/H11022 typically indicate shift left, logical shift right, arithmetic shift right, respectively. Depending value 2-bit shift amount, shamt 1:0, output, Y,receives input, A, shifted 0 3 bits. shifters, shamt 1:0/H1100500, Y/H11005A. Exercise 5.14 covers rotator designs. left shift special case multiplication. left shift Nbits multiplies number 2N. example, 000011 2/H11021/H110214/H11005110000 2is equivalent 3 10/H1100324/H110054810.5.2 Arithmetic Circuits 245 Figure 5.16 4-bit shifters: (a) shift left, (b) logical shift right, (c) arithmetic shift rightshamt1:0 A3A2A1A0 Y3 Y2 Y1 Y0 (a)<< S1:0 S1:0 S1:0 S1:000 01 10 11 00 01 10 11 00 01 10 1100 01 10 112 4 4 2 (b)A3A2A1A0 Y3 Y2 Y1 Y0shamt1:0 00 01 10 11A3:0 Y3:0shamt1:0 >> S1:0 S1:0 S1:0 S1:000 01 10 11 00 01 10 1100 01 10 112 4 4 2 (c)A3A2A1A0 Y3 Y2 Y1 Y0shamt1:0>>> S1:0 S1:0 S1:0 S1:000 01 10 11 00 01 10 11 00 01 10 1100 01 10 112 4 4 2A3:0 Y3:0shamt1:0 A3:0 Y3:0shamt1:0Chapter 05.qxd 1/27/07 10:27 Page 245An arithmetic right shift special case division. arithmetic right shift Nbits divides number 2N. example, 11100 2 /H11022/H11022/H11022 2/H1100511111 2is equivalent /H11002410/22/H11005/H11002110. 5.2.6 Multiplication* Multiplication unsigned binary numbers similar decimal multipli- cation involves 1’s 0’s. Figure 5.17 compares multiplication decimal binary. cases, partial products formed multiplying single digit multiplier entire multiplicand. shifted partial products summed form result. general, N/H11003Nmultiplier multiplies two N-bit numbers produces 2 N-bit result. partial products binary multiplication either multiplicand 0’s. Multiplication 1-bit binary num- bers equivalent operation, gates used form partial products. Figure 5.18 shows symbol, function, implementation 4 /H110034 multiplier. multiplier receives multiplicand multiplier, Aand B,and produces product, P.Figure 5.18(b) shows partial products formed. partial product single multiplier bit ( B3, B2, B1, B0) multiplicand bits ( A3, A2, A1, A0). N-bit246 CHAPTER FIVE Digital Building Blocks Figure 5.17 Multiplication: (a) decimal, (b) binary Figure 5.18 4/H110034 multiplier: (a) symbol, (b) function, (c) implementation230 42 × (a)460 920+ 9660 2 30 × 42 = 9660multipliermultiplicand partial products result0101 0111 5 × 7 = 350101 0101 0101 0000× + 0100011 (b) (a)xAB P4 4 8 (b)× B3 B2 B1B0 A3B0A2B0A1B0A0B0A3A2A1 A0 A3B1A2B1A1B1A0B1 A3B2A2B2A1B2A0B2 A3B3A2B3A1B3A0B3 + P7P6 P5 P4P3P2 P1 P00 P20 0 (c)0 P1 P0 P5 P4 P3 P7P6A3 A2 A1 A0 B0 B1 B2 B3Chapter 05.qxd 1/27/07 10:27 Page 246operands, Npartial products N/H110021 stages 1-bit adders. example, 4 /H110034 multiplier, partial product first row B0AND ( A3, A2, A1, A0). partial product added shifted second partial product, B1AND ( A3, A2, A1, A0). Subsequent rows gates adders form add remaining partial products. HDL multiplier HDL Example 5.4. adders, many different multiplier designs different speed/cost trade-offs exist. Synthesis tools may pick appropriate design given timing constraints.5.2 Arithmetic Circuits 247 Verilog module multiplier # (parameter N /H110058) (input [N /H110021:0] a, b, output [2*N /H110021:0] y); assign /H11005a * b; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL; entity multiplier generic (N: integer : /H110058); port (a, b: STD_LOGIC_VECTOR(N /H110021 downto 0); y: STD_LOGIC_VECTOR(2*N /H110021 downto 0)); end; architecture synth multiplier begin /H11021/H11005a * b; end;HDL Example 5.4 MULTIPLIER 5.2.7 Division* Binary division performed using following algorithm nor- malized unsigned numbers range [2N/H110021, 2N/H110021]: R /H11005A /H11005N/H110021 0 /H11005R /H11002B /H110210 Q i/H110050, R /H11032/H11005R // R /H11021B else Q i/H110051, R /H11032/H11005D // R /H11350B =/ 0 R /H110052R/H11032 partial remainder, R, initialized dividend, A.The divisor, B, repeatedly subtracted partial remainder determine whether fits. difference, D,is negative (i.e., sign bit Dis 1), quotient bit, Qi, 0 difference discarded. Otherwise, Qiis 1,Figure 5.19 Synthesized multiplier* y[15:0][15:0] b[7:0]a[7:0][7:0] [7:0]Chapter 05.qxd 1/27/07 10:27 Page 247and partial remainder updated difference. event, partial remainder doubled (left-shifted one column), process repeats. result satisfies Figure 5.20 shows schematic 4-bit array divider. divider computes A/Band produces quotient, Q,and remainder, R.The leg- end shows symbol schematic block array divider. signal Pindicates whether R/H11002Bis negative. obtained Coutoutput leftmost block row, sign difference. delay N-bit array divider increases proportionally N2 carry must ripple Nstages row sign determined multiplexer selects Ror D.This repeats Nrows. Division slow expensive operation hardware therefore used infrequently possible. 5.2.8 Reading Computer arithmetic could subject entire text. Digital Arithmetic, Ercegovac Lang, excellent overview entire field. CMOS VLSI Design, Weste Harris, covers high- performance circuit designs arithmetic operations.A B/H11005/H20898Q/H11001R B/H208992/H11002(N/H110021).248 CHAPTER FIVE Digital Building Blocks Figure 5.20 Array divider+RB R ′PCin Cout01RB R ′PCoutCin1A0 A1 A2 A3 Q3 10 1 Q2 10 1 Q1 10 1 Q0B0 B1 B2 B3 R0 R1 R2 R3LegendChapter 05.qxd 1/27/07 10:27 Page 2485.3 NUMBER SYSTEMS Computers operate integers fractions. far, considered representing signed unsigned integers, introduced Section 1.4. section introduces fixed- floating-point number systems also represent rational numbers. Fixed-point numbers analogous decimals; bits represent integer part, rest represent fraction. Floating-point numbers analo- gous scientific notation, mantissa exponent. 5.3.1 Fixed-Point Number Systems Fixed-point notation implied binary point integer fraction bits, analogous decimal point integer frac- tion digits ordinary decimal number. example, Figure 5.21(a) shows fixed-point number four integer bits four fraction bits. Figure 5.21(b) shows implied binary point blue, Figure 5.21(c) shows equivalent decimal value. Signed fixed-point numbers use either two’s complement sign/magnitude notations. Figure 5.22 shows fixed-point representa- tion /H110022.375 using notations four integer four fraction bits. implicit binary point shown blue clarity. sign/magni- tude form, significant bit used indicate sign. two’s complement representation formed inverting bits absolute value adding 1 least significant (rightmost) bit. case, least significant bit position 2/H110024column. Like binary number representations, fixed-point numbers collection bits. way knowing existence binary point except agreement people interpreting number. Example 5.4 ARITHMETIC FIXED-POINT NUMBERS Compute 0.75 /H11001/H110020.625 using fixed-point numbers. Solution: First convert 0.625, magnitude second number, fixed- point binary notation. 0.625 /H113502/H110021, 1 2/H110021column, leaving 0.625 /H110020.5/H110050.125. 0.125 /H110212/H110022, 0 2/H110022column. 0.125 /H113502/H110023, 1 2/H110023column, leaving 0.125 /H110020.125 /H110050. Thus, must 0 2/H110024column. Putting together, 0.625 10/H110050000.1010 2 Use two’s complement representation signed numbers addition works correctly. Figure 5.23 shows conversion /H110020.625 fixed-point two’s com- plement notation. Figure 5.24 shows fixed-point binary addition decimal equivalent comparison. Note leading 1 binary fixed-point addition Figure 5.24(a) discarded 8-bit result.5.3 Number Systems 249 Figure 5.21 Fixed-point notation 6.75 four integer bits four fraction bits(a) 01101100 (b) 0110 .1100 (c) 22 + 21 + 2–1 + 2–2 = 6.75 Figure 5.22 Fixed-point representation /H110022.375: (a) absolute value, (b) sign magnitude, (c) two’s complement(a) 0010 .0110 (b) 1010 .0110 (c) 1101 .1010 Fixed-point number systems commonly used bank- ing financial applications require precision large range.Chapter 05.qxd 1/27/07 10:27 Page 249250 CHAPTER FIVE Digital Building Blocks Figure 5.23 Fixed-point two’s complement conversion0000 .1010 1111 .0101 + 1Add 1 1111 .0110 Two's ComplementOne's ComplementBinary Magnitude Figure 5.24 Addition: (a) binary fixed-point (b) decimal equivalent0000 .1100 10000 .0010+ 1111 .01100.75 0.125+ (–0.625) (a) (b) Figure 5.25 Floating-point numbers Figure 5.26 32-bit floating- point version 1± × 0 00000111 111 0010 0000 0000 0000 0000 Sign Exponent Mantissa1 bit 8 bits 23 bits5.3.2 Floating-Point Number Systems* Floating-point numbers analogous scientific notation. cir- cumvent limitation constant number integer frac- tional bits, allowing representation large small numbers. Like scientific notation, floating-point numbers sign, mantissa (M), base (B), exponent (E), shown Figure 5.25. example, number 4.1 /H11003103is decimal scientific notation 4100. mantissa 4.1, base 10, exponent 3. decimal point floats position right significant digit. Floating-point numbers base 2 binary mantissa. 32 bits used represent 1 sign bit, 8 exponent bits, 23 mantissa bits. Example 5.5 32-BIT FLOATING-POINT NUMBERS Show floating-point representation decimal number 228. Solution: First convert decimal number binary: 228 10/H1100511100100 2/H11005 1.11001 2/H1100327. Figure 5.26 shows 32-bit encoding, modified later efficiency. sign bit positive (0), 8 exponent bits give value 7, remaining 23 bits mantissa. binary floating-point, first bit mantissa (to left binary point) always 1 therefore need stored. called implicit leading one. Figure 5.27 shows modified floating- point representation 228 10/H1100511100100 2/H1100320/H110051.11001 2/H1100327. implicit leading one included 23-bit mantissa efficiency. fraction bits stored. frees extra bit useful data.Chapter 05.qxd 1/27/07 10:27 Page 250We make one final modification exponent field. exponent needs represent positive negative exponents. so, float- ing-point uses biased exponent, original exponent plus constant bias. 32-bit floating-point uses bias 127. example, exponent 7, biased exponent 7 /H11001127 /H11005134 /H1100510000110 2. exponent /H110024, biased exponent is: /H110024/H11001127 /H11005123 /H11005 01111011 2. Figure 5.28 shows 1.11001 2/H1100327represented floating- point notation implicit leading one biased exponent 134 (7 /H11001127). notation conforms IEEE 754 floating-point standard. Special Cases: 0, /H11006/H11009, NaN IEEE floating-point standard special cases represent numbers zero, infinity, illegal results. example, representing number zero problematic floating-point notation implicit leading one. Special codes exponents 0’s 1’s reserved special cases. Table 5.2 shows floating-point representations 0, /H11006/H11009, NaN. sign/magnitude numbers, floating-point positive negative 0. NaN used num- bers don’t exist, log 2(/H110025). Single- Double-Precision Formats far, examined 32-bit floating-point numbers. format also called single-precision, single, float. IEEE 754 standard also√/H1100215.3 Number Systems 251 Figure 5.27 Floating-point version 20 00000111 110 0100 0000 0000 0000 0000 Sign Exponent Fraction1 bit 8 bits 23 bits Figure 5.28 IEEE 754 floating- point notation0 10000110 Sign Biased ExponentFraction1 bit 8 bits 23 bits 110 0100 0000 0000 0000 0000 Table 5.2 IEEE 754 floating-point notations 0, /H11550/H11557, NaN Number Sign Exponent Fraction 0 X 00000000 00000000000000000000000 /H11009 0 11111111 00000000000000000000000 /H11002/H11009 1 11111111 00000000000000000000000 NaN X 11111111 non-zeroAs may apparent, many reasonable ways rep- resent floating-point numbers. many years, computer manufacturers used incompat- ible floating-point formats. Results one computer could directly inter- preted another computer. Institute Electrical Electronics Engineers solved problem defin- ing IEEE 754 floating- point standard 1985 defining floating-point num- bers. floating-point for- mat almost universally used one discussed section.Chapter 05.qxd 1/27/07 10:27 Page 251defines 64-bit double-precision (also called double ) numbers pro- vide greater precision greater range. Table 5.3 shows number bits used fields format. Excluding special cases mentioned earlier, normal single-precision numbers span range /H110061.175494 /H1100310/H1100238to /H110063.402824 /H110031038. precision seven significant decimal digits (because 2/H1100224≈10/H110027). Similarly, normal double-precision numbers span range /H110062.22507385850720 /H1100310/H11002308to /H110061.79769313486232 /H1100310308and precision 15 significant decimal digits. Rounding Arithmetic results fall outside available precision must round neighboring number. rounding modes are: (1) round down, (2) round up, (3) round toward zero, (4) round nearest. default rounding mode round nearest. round nearest mode, two numbers equally near, one 0 least significant position fraction chosen. Recall number overflows magnitude large represented. Likewise, number underflows tiny represented. round nearest mode, overflows rounded /H11006/H11009 underflows rounded 0. Floating-Point Addition Addition floating-point numbers simple addition two’s complement numbers. steps adding floating-point numbers sign follows: 1. Extract exponent fraction bits. 2. Prepend leading 1 form mantissa. 3. Compare exponents. 4. Shift smaller mantissa necessary. 5. Add mantissas. 6. Normalize mantissa adjust exponent necessary. 7. Round result. 8. Assemble exponent fraction back floating-point number.252 CHAPTER FIVE Digital Building Blocks Floating-point cannot repre- sent numbers exactly, like 1.7. However, type 1.7 calculator, see exactly 1.7, 1.69999. .. . handle this, applications, calculators financial software, use binary coded decimal (BCD ) numbers formats base 10 expo- nent. BCD numbers encode decimal digit using four bits range 0 9. example BCD fixed- point notation 1.7 four integer bits four fraction bits would 0001.0111. course, nothing free. cost increased complexity arithmetic hardware wasted encodings (A–F encodings used), thus decreased performance. compute-intensive applications, floating-point much faster.Table 5.3 Single- double-precision floating-point formats Format Total Bits Sign Bits Exponent Bits Fraction Bits single 32 1 8 23 double 64 1 11 52Chapter 05.qxd 1/27/07 10:27 Page 252Figure 5.29 shows floating-point addition 7.875 (1.11111 /H1100322) 0.1875 (1.1 /H110032/H110023). result 8.0625 (1.0000001 /H1100323). fraction exponent bits extracted implicit leading 1 prepended steps 1 2, exponents compared subtracting smaller exponent larger exponent. result number bits smaller number shifted right align implied binary point (i.e., make exponents equal) step 4. aligned num- bers added. sum mantissa greater equal 2.0, result normalized shifting right one bit incrementing exponent. example, result exact, rounding necessary. result stored floating-point notation removing implicit leading one mantissa prepending sign bit.5.3 Number Systems 253 Figure 5.29 Floating-point addition111 1100 0000 0000 0000 0000 Step 110000001Exponent 100 0000 0000 0000 0000 0000 01111100 1.111 1100 0000 0000 0000 0000 Step 210000001 1.100 0000 0000 0000 0000 0000 01111100 1.111 1100 0000 0000 0000 0000 Step 310000001 1.100 0000 0000 0000 0000 0000 01111100– 101(shift amount) 1.111 1100 0000 0000 0000 0000 Step 410000001 0.000 0 110 0000 0000 0000 0000 10000001 1.111 1100 0000 0000 0000 0000 Step 510000001 0.000 0110 0000 0000 0000 0000 10000001 + 10.000 0010 0000 0000 0000 0000 Step 6 Step 7Floating-point numbers 1.000 0001 0000 0000 0000 000010000001 110.000 0010 0000 0000 0000 0000 >> 1 1000001000 Step 8 0(No rounding necessary)Fraction111 1100 0000 0000 0000 0000 100 0000 0000 0000 0000 000010000001 01111100 000 0001 0000 0000 0000 0000 1000001000000 +Floating-point arithmetic usually done hardware make fast. hardware, called floating-point unit (FPU), typically distinct central processing unit (CPU ). infamous floating-point division (FDIV ) bug Pentium FPU cost Intel $475 million recall replace defective chips. bug occurred simply lookup table loaded correctly.Chapter 05.qxd 1/27/07 10:27 Page 2535.4 SEQUENTIAL BUILDING BLOCKS section examines sequential building blocks, including counters shift registers. 5.4.1 Counters N-bit binary counter, shown Figure 5.30, sequential arithmetic circuit clock reset inputs N-bit output, Q. Reset initial- izes output 0. counter advances 2Npossible outputs binary order, incrementing rising edge clock. Figure 5.31 shows N-bit counter composed adder reset- table register. cycle, counter adds 1 value stored reg- ister. HDL Example 5.5 describes binary counter asynchronous reset. types counters, Up/Down counters, explored Exercises 5.37 5.40.254 CHAPTER FIVE Digital Building Blocks Figure 5.31 N-bit counterFigure 5.30 Counter symbolQCLK ResetN N 1CLK ResetB ANQ3:0N r Verilog module counter #(parameter N /H110058) (input clk, input reset, output reg [N /H110021:0] q); always @ (posedge clk posedge reset) (reset) q /H11021/H110050; else q /H11021/H11005q /H110011; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL; use IEEE.STD_LOGIC_ARITH.ALL; entity counter generic (N: integer : /H110058); port (clk, reset: STD_LOGIC; q: buffer STD_LOGIC_VECTOR(N /H110021 downto 0)); end; architecture synth counter begin process (clk, reset) begin reset /H11005‘1’ q /H11021/H11005CONV_STD_LOGIC_VECTOR (0, N); elsif clk’event clk /H11005‘1’ q /H11021/H11005q /H110011; end if; end process; end;HDL Example 5.5 COUNTER Figure 5.32 Synthesized counter+ Rq[7:0][7:0] resetclk [7:0] 1Q[7:0][7:0]D[7:0]Chapter 05.qxd 1/27/07 10:27 Page 2545.4.2 Shift Registers shift register clock, serial input, Sin, serial output, Sout, Nparallel outputs, QN-1:0,as shown Figure 5.33. rising edge clock, new bit shifted Sinand subse- quent contents shifted forward. last bit shift register available Sout. Shift registers viewed serial-to-parallel con- verters. input provided serially (one bit time) Sin. Ncycles, past Ninputs available parallel Q. shift register constructed Nflip-flops connected series, shown Figure 5.34. shift registers also reset sig- nal initialize flip-flops. related circuit parallel-to-serial converter loads Nbits parallel, shifts one time. shift register modi- fied perform serial-to-parallel parallel-to-serial operations adding parallel input, DN-1:0,and control signal, Load, shown Figure 5.35. Load asserted, flip-flops loaded paral- lel Dinputs. Otherwise, shift register shifts normally. HDL Example 5.6 describes shift register. Scan Chains* Shift registers often used test sequential circuits using tech- nique called scan chains. Testing combinational circuits relatively straightforward. Known inputs called test vectors applied, outputs checked expected result. Testing sequential cir- cuits difficult, circuits state. Starting known initial condition, large number cycles test vectors may needed put circuit desired state. example, testing significant bit 32-bit counter advances 0 1 requires resetting counter, applying 231(about two billion) clock pulses!5.4 Sequential Building Blocks 255 Don’t confuse shift registers shifters Section 5.2.5. Shift registers sequential logic blocks shift new bit clock edge. Shifters unclocked combinational logic blocks shift input specified amount. Figure 5.33 Shift register symbolNQ inSout Figure 5.34 Shift register schematic Figure 5.35 Shift register parallel loadCLK Q 0Q1 QN –1 Q2 CLK 0 10 10 10 1D0 D1 DN –1 D2 Q0 Q1 QN – 1 Q2S SoutLoadChapter 05.qxd 1/27/07 10:27 Page 255To solve problem, designers like able directly observe control state machine. done adding test mode contents flip-flops read loaded desired values. systems many flip-flops dedicate individual pins read write flip-flop. Instead, flip-flops system connected together shift register called scan chain. normal operation, flip-flops load data Dinput ignore scan chain. test mode, flip-flops serially shift contents shift256 CHAPTER FIVE Digital Building Blocks Verilog module shiftreg # (parameter N /H110058) (input clk, input reset, load, input sin, input [N /H110021:0] d, output reg [N /H110021:0] q, output sout); always @ (posedge clk posedge reset) (reset) q /H11021/H110050; else (load) q /H11021/H11005d; else q /H11021/H11005{q[N /H110022:0], sin}; assign sout /H11005q[N/H110021]; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL; entity shiftreg generic (N: integer : /H110058); port(clk, reset, load: STD_LOGIC; sin: STD_LOGIC; d: STD_LOGIC_VECTOR(N /H110021 downto 0); q: buffer STD_LOGIC_VECTOR(N /H110021 downto 0); sout: STD_LOGIC); end; architecture synth shiftreg begin process (clk, reset) begin reset /H11005‘1’ q /H11021/H11005CONV_STD_LOGIC_VECTOR (0, N); elsif clk’event clk /H11005‘1’ load /H11005‘1’ q /H11021/H11005d; else q /H11021/H11005q(N/H110022 downto 0) & sin; end if; end if; end process; sout /H11021/H11005q(N/H110021); end;HDL Example 5.6 SHIFT REGISTER PARALLEL LOAD Figure 5.36 Synthesized shiftreg0 1Rsout[7] q[7:0] d[7:0]sinload reset clk[6:0] [7:0] [7:0] [7:0]Q[7:0] D[7:0]Chapter 05.qxd 1/27/07 10:27 Page 2565.5 Memory Arrays 257 Figure 5.37 Scannable flip-flop: (a) schematic, (b) symbol, (c) N-bit scannable register0 1Test inQ Sout (a)DQ inSout Test (b)DQ inSout TestDQ inSout TestDQ inSout TestDQ SinSout Test (c)TestCLK CLK CLKD0 Q0D1 Q1D2 Q2DN – 1 QN –1S Sout new contents using Sinand Sout. load multiplexer usually inte- grated flip-flop produce scannable flip-flop. Figure 5.37 shows schematic symbol scannable flip-flop illustrates flops cascaded build N-bit scannable register. example, 32-bit counter could tested shifting pattern 011111 . . . 111 test mode, counting one cycle normal mode, shifting result, 100000 . . . 000. requires 32 /H110011/H1100132/H1100565 cycles. 5.5 MEMORY ARRAYS previous sections introduced arithmetic sequential circuits manipulating data. Digital systems also require memories store data used generated circuits. Registers built flip- flops kind memory stores small amounts data. section describes memory arrays efficiently store large amounts data. section begins overview describing characteristics shared memory arrays. introduces three types memory arrays: dynamic random access memory (DRAM), static random access memory (SRAM), read memory (ROM). memory differs way stores data. section briefly discusses area delay trade-offs shows memory arrays used, store data also perform logic functions. section finishes HDL memory array. 5.5.1 Overview Figure 5.38 shows generic symbol memory array. memory organized two-dimensional array memory cells. memory reads writes contents one rows array. row isAddress DataArrayN Figure 5.38 Generic memory array symbolChapter 05.qxd 1/27/07 10:27 Page 257specified Address. value read written called Data. array N-bit addresses M-bit data 2Nrows columns. row data called word. Thus, array contains 2N M-bit words. Figure 5.39 shows memory array two address bits three data bits. two address bits specify one four rows (data words) array. data word three bits wide. Figure 5.39(b) shows possible contents memory array. depth array number rows, width number columns, also called word size. size array given depth /H11003width. Figure 5.39 4-word /H110033-bit array, simply 4/H110033 array. symbol 1024-word /H1100332-bit array shown Figure 5.40. total size array 32 kilobits (Kb). Bit Cells Memory arrays built array bit cells, stores 1 bit data. Figure 5.41 shows bit cell connected wordline bitline. combination address bits, mem- ory asserts single wordline activates bit cells row. wordline HIGH, stored bit transfers bitline. Otherwise, bitline disconnected bit cell. circuitry store bit varies memory type. read bit cell, bitline initially left floating (Z). wordline turned ON, allowing stored value drive bitline 0 1. write bit cell, bitline strongly driven desired value. wordline turned ON, connecting bitline stored bit. strongly driven bitline overpowers contents bit cell, writ- ing desired value stored bit. Organization Figure 5.42 shows internal organization 4 /H110033 memory array. course, practical memories much larger, behavior larger arrays extrapolated smaller array. example, array stores data Figure 5.39(b). memory read, wordline asserted, corre- sponding row bit cells drives bitlines HIGH LOW. memory write, bitlines driven HIGH LOW first wordline asserted, allowing bitline values stored row bit cells. example, read Address 10, bitlines left floating, decoder asserts wordline 2, data stored row bit cells, 100, reads onto Data bitlines. write value 001 Address 11, bitlines driven value 001, wordline 3is asserted new value (001) stored bit cells.258 CHAPTER FIVE Digital Building Blocks (a)Address DataArray2 3 (b)Address 11 10 01 00depth0 1 1 01 0 1 10 0 0 1 widthData Figure 5.39 4/H110033 memory array: (a) symbol, (b) function Address Data1024-word × 32-bit Array10 32 Figure 5.40 32 Kb array: depth /H11005 210/H110051024 words, width /H1100532 bits stored bitwordlinebitline Figure 5.41 Bit cellChapter 05.qxd 1/27/07 10:27 Page 258Memory Ports memories one ports. port gives read and/or write access one memory address. previous examples single- ported memories. Multiported memories access several addresses simultane- ously. Figure 5.43 shows three-ported memory two read ports one write port. Port 1 reads data address A1onto read data output RD1. Port 2 reads data address A2onto RD2. Port 3 writes data write data input, WD3 , address A3on rising edge clock write enable, WE3 , asserted. Memory Types Memory arrays specified size (depth /H11003width) num- ber type ports. memory arrays store data array bit cells, differ store bits. Memories classified based store bits bit cell. broadest classification random access memory (RAM ) versus read memory (ROM ). RAM volatile, meaning loses data power turned off. ROM nonvolatile, meaning retains data indefinitely, even without power source. RAM ROM received names historical reasons longer meaningful. RAM called random access memory data word accessed delay other. sequential access memory, tape recorder, accesses nearby data quickly faraway data (e.g., end tape).5.5 Memory Arrays 259 wordline311 102:4 Decoder Address 01 00stored bit = 0stored bit = 1stored bit = 0 stored bit = 1stored bit = 0stored bit = 0 stored bit = 1stored bit = 1stored bit = 0 stored bit = 0stored bit = 1stored bit = 1wordline2 wordline1 wordline0bitline2 bitline1 bitline0 Data 2 Data 1 Data 02 Figure 5.42 4/H110033 memory array A1 A3 WD 3WE 3 A2CLK ArrayRD 2RD1M MN N N Figure 5.43 Three-ported memoryChapter 05.qxd 1/27/07 10:27 Page 259ROM called read memory because, historically, could read written. names confusing, ROMs randomly accessed too. Worse yet, modern ROMs written well read! important distinction remember RAMs volatile ROMs nonvolatile. two major types RAMs dynamic RAM (DRAM ) static RAM (SRAM ). Dynamic RAM stores data charge capaci- tor, whereas static RAM stores data using pair cross-coupled inverters. many flavors ROMs vary written erased. various types memories discussed subsequent sections. 5.5.2 Dynamic Random Access Memory Dynamic RAM (DRAM, pronounced “dee-ram”) stores bit presence absence charge capacitor. Figure 5.44 shows DRAM bit cell. bit value stored capacitor. nMOS transistor behaves switch either connects disconnects capacitor bitline. wordline asserted, nMOS transistor turns ON, stored bit value transfers bitline. shown Figure 5.45(a), capacitor charged VDD, stored bit 1; discharged GND (Figure 5.45(b)), stored bit 0. capacitor node dynamic actively driven HIGH LOW transistor tied VDDor GND. Upon read, data values transferred capacitor bitline. Upon write, data values transferred bitline capacitor. Reading destroys bit value stored capacitor, data word must restored (rewritten) read. Even DRAM read, contents must refreshed (read rewritten) every milliseconds, charge capacitor gradually leaks away. 5.5.3 Static Random Access Memory (SRAM) Static RAM (SRAM, pronounced “es-ram”) static stored bits need refreshed. Figure 5.46 shows SRAM bit cell. data bit stored cross-coupled inverters like described Section 3.2. cell two outputs, bitline . wordline asserted, nMOS transistors turn on, data values transferred bitlines. Unlike DRAM, noise degrades value stored bit, cross-coupled inverters restore value.bitline260 CHAPTER FIVE Digital Building Blocks Robert Dennard, 1932–. Invented DRAM 1966 IBM. Although many skeptical idea would work, mid-1970s DRAM virtually computers. claims done little creative work until, arriving IBM, handed patent notebook said, “put ideas there.” Since 1965, received 35 patents semiconductors micro- electronics. (Photo courtesy IBM.) wordlinebitline stored bit Figure 5.44 DRAM bit cellChapter 05.qxd 1/27/07 10:27 Page 2605.5.4 Area Delay Flip-flops, SRAMs, DRAMs volatile memories, different area delay characteristics. Table 5.4 shows comparison three types volatile memory. data bit stored flip-flop available immediately output. flip-flops take least 20 transis- tors build. Generally, transistors device has, area, power, cost requires. DRAM latency longer SRAM bitline actively driven transistor. DRAM must wait charge move (relatively) slowly capacitor bit- line. DRAM also lower throughput SRAM, must refresh data periodically read. Memory latency throughput also depend memory size; larger memories tend slower smaller ones else same. best memory type particular design depends speed, cost, power constraints. 5.5.5 Register Files Digital systems often use number registers store temporary vari- ables. group registers, called register file, usually built small, multiported SRAM array, compact array flip-flops. Figure 5.47 shows 32-register /H1100332-bit three-ported register file built three-ported memory similar Figure 5.43. The5.5 Memory Arrays 261 Figure 5.45 DRAM stored valuesstored bit wordlinebitline bitline Figure 5.46 SRAM bit cell Table 5.4 Memory comparison Memory Transistors per Latency Type Bit Cell flip-flop ~20 fast SRAM 6 medium DRAM 1 slow 5 5 532 32 32CLK A1 A3 WD 3RD 2RD1WE 3 A2 Register File Figure 5.47 32/H1100332 register file two read ports one write portwordlinebitline (a)+ + stored bit = 1wordlinebitline (b)stored bit = 0Chapter 05.qxd 1/27/07 10:27 Page 261register file two read ports ( A1/RD1 A2/RD2 ) one write port ( A3/WD3 ). 5-bit addresses, A1, A2, A3,can access 25/H1100532 registers. So, two registers read one register written simultaneously. 5.5.6 Read Memory Read memory (ROM ) stores bit presence absence transistor. Figure 5.48 shows simple ROM bit cell. read cell, bitline weakly pulled HIGH. wordline turned ON. transistor present, pulls bitline LOW. absent, bitline remains HIGH. Note ROM bit cell combinational circuit state “forget” power turned off. contents ROM indicated using dot notation. Figure 5.49 shows dot notation 4-word /H110033-bit ROM containing data Figure 5.39. dot intersection row (wordline) column (bitline) indicates data bit 1. example, top wordline single dot Data 1, data word stored Address 11 010. Conceptually, ROMs built using two-level logic group gates followed group gates. gates produce possible minterms hence form decoder. Figure 5.50 shows ROM Figure 5.49 built using decoder gates. dotted row Figure 5.49 input gate Figure 5.50. data bits single dot, case Data 0, gate needed. representation ROM interesting shows ROM perform two-level logic function. practice, ROMs built transistors instead logic gates, reduce size cost. Section 5.6.3 explores transistor-level implementa- tion further.262 CHAPTER FIVE Digital Building Blocks wordlinebitline wordlinebitlinebit cell containing 0 bit cell containing 1 Figure 5.48 ROM bit cells containing 0 1 11 102:4 Decoder Address Data 0 Data1 Data 201 002 Figure 5.49 4/H110033 ROM: dot notationChapter 05.qxd 1/27/07 10:27 Page 262The contents ROM bit cell Figure 5.48 specified manufacturing presence absence transistor bit cell. programmable ROM (PROM , pronounced like dance) places transistor every bit cell provides way connect disconnect transistor ground. Figure 5.51 shows bit cell fuse-programmable ROM. user programs ROM applying high voltage selectively blow fuses. fuse present, transistor connected GND cell holds 0. fuse destroyed, transistor discon- nected ground cell holds 1. also called one- time programmable ROM, fuse cannot repaired blown. Reprogrammable ROMs provide reversible mechanism con- necting disconnecting transistor GND. Erasable PROMs (EPROMs, pronounced “e-proms”) replace nMOS transistor fuse floating-gate transistor. floating gate physically attached wires. suitable high voltages applied, electrons tunnel insulator onto floating gate, turning transistor connecting bitline wordline (decoder output). EPROM exposed intense ultraviolet (UV) light half hour, electrons knocked floating gate, turning transistor off. actions called programming erasing, respectively. Electrically erasable PROMs (EEPROMs, pro- nounced “e-e-proms” “double-e proms”) Flash memory use similar principles include circuitry chip erasing well programming, UV light necessary. EEPROM bit cells individually erasable; Flash memory erases larger blocks bits cheaper fewer erasing circuits needed. 2006, Flash5.5 Memory Arrays 263 11 102:4 Decoder 01 00 Data2Data1Data 0Address2 Figure 5.50 4/H110033 ROM implementation using gateswordlinebitline bit cell containing 0intact fuse wordlinebitline bit cell containing 1blown fuse Figure 5.51 Fuse-programmable ROM bit cell Fujio Masuoka, 1944–. Received Ph.D. electrical engineering Tohoku University, Japan. Developed memories high- speed circuits Toshiba 1971 1994. Invented Flash memory unauthorized project pursued nights weekends late 1970s. Flash received name process erasing memory reminds one flash camera. Toshiba slow commercialize idea; Intel first market 1988. Flash grown $25 billion per year market. Dr. Masuoka later joined faculty Tohoku University. Chapter 05.qxd 1/27/07 10:27 Page 263memory costs less $25 per GB, price continues drop 30 40% per year. Flash become extremely popular way store large amounts data portable battery-powered systems cameras music players. summary, modern ROMs really read only; programmed (written) well. difference RAM ROM ROMs take longer time write nonvolatile. 5.5.7 Logic Using Memory Arrays Although used primarily data storage, memory arrays also perform combinational logic functions. example, Data 2 output ROM Figure 5.49 XOR two Address inputs. Likewise Data 0is NAND two inputs. 2N-word /H11003 M-bit memory perform combinational function Ninputs Moutputs. example, ROM Figure 5.49 performs three functions two inputs. Memory arrays used perform logic called lookup tables (LUTs). Figure 5.52 shows 4-word /H110031-bit memory array used lookup table perform function Y/H11005AB.Using memory perform logic, user look output value given input combina- tion (address). address corresponds row truth table, data bit corresponds output value. 5.5.8 Memory HDL HDL Example 5.7 describes 2N-word /H11003M-bit RAM. RAM synchronous enabled write. words, writes occur rising264 CHAPTER FIVE Digital Building Blocks stored bit =1stored bit =000 012:4 Decoder stored bit =0bitline stored bit =0 YB 10 114-word x1-bit Array ABY 00 01 10 110 0 0 1Truth Table A1 A0 Figure 5.52 4-word /H110031-bit memory array used lookup tableProgrammable ROMs configured device programmer like one shown below. device programmer attached computer, specifies type ROM data values program. device programmer blows fuses injects charge onto floating gate ROM. Thus programming process some- times called burning ROM. Flash memory drives Universal Serial Bus (USB) connectors replaced floppy disks CDs sharing files Flash costs dropped dramatically. Chapter 05.qxd 1/27/07 10:27 Page 264edge clock write enable, we,is asserted. Reads occur immediately. power first applied, contents RAM unpredictable. HDL Example 5.8 describes 4-word /H110033-bit ROM. contents ROM specified HDL case statement. ROM small one may synthesized logic gates rather array. Note seven-segment decoder HDL Example 4.25 synthe- sizes ROM Figure 4.22.5.5 Memory Arrays 265 Verilog module ram # (parameter N /H110056, /H1100532) (input clk, input we, input [N /H110021:0] adr, input [M /H110021:0] din, output [M /H110021:0] dout); reg [M /H110021:0] mem [2**N/H110021:0]; always @ (posedge clk) (we) mem [adr] /H11021/H11005din; assign dout /H11005mem[adr]; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.ALL; use IEEE.STD_LOGIC_ARITH.ALL; use IEEE.STD_LOGIC_UNSIGNED.ALL; entity ram_array generic (N_ : integer : /H110056; M: integer : /H1100532); port (clk, we: STD_LOGIC; adr: STD_LOGIC_VECTOR(N /H110021 downto 0); din: STD_LOGIC_VECTOR(M /H110021 downto 0); dout: STD_LOGIC_VECTOR(M /H110021 downto 0)); end; architecture synth ram_array type mem_array array((2**N/H110021) downto 0) STD_LOGIC_VECTOR(M /H110021 downto 0); signal mem: mem_array; begin process (clk) begin clk’ event clk /H11005‘1’ /H11005‘1’ mem (CONV_INTEGER (adr)) /H11021/H11005din; end if; end if; end process; dout /H11021/H11005mem (CONV_INTEGER(adr)); end;HDL Example 5.7 RAM ram1 mem[31:0]dout[31:0][31:0]din[31:0] adr[5:0] clk[5:0] RADDR[5:0] [31:0]DATA[31:0] DOUT[31:0] [5:0] WADDR[5:0] WE[0] CLK Figure 5.53 Synthesized ramChapter 05.qxd 1/27/07 10:27 Page 2655.6 LOGIC ARRAYS Like memory, gates organized regular arrays. connec- tions made programmable, logic arrays configured perform function without user connect wires spe- cific ways. regular structure simplifies design. Logic arrays mass produced large quantities, inexpensive. Software tools allow users map logic designs onto arrays. logic arrays also reconfigurable, allowing designs modified without replacing hardware. Reconfigurability valuable development also useful field, system upgraded simply downloading new configuration. section introduces two types logic arrays: programmable logic arrays (PLAs ), field programmable gate arrays (FPGAs ). PLAs, older technology, perform combinational logic functions. FPGAs perform combinational sequential logic. 5.6.1 Programmable Logic Array Programmable logic arrays (PLAs ) implement two-level combinational logic sum-of-products (SOP) form. PLAs built array followed array, shown Figure 5.54. inputs (in true complementary form) drive array, produces implicants, turn ORed together form outputs. M/H11003N/H11003P-bit PLA Minputs, Nimplicants, Poutputs.266 CHAPTER FIVE Digital Building Blocks Verilog module rom (input [1:0] adr, output reg [2:0] dout); always @ (adr) case (adr) 2/H11032b00: dout /H11021/H110053/H11032b011; 2/H11032b01: dout /H11021/H110053/H11032b110; 2/H11032b10: dout /H11021/H110053/H11032b100; 2/H11032b11: dout /H11021/H110053/H11032b010; endcase endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity rom port (adr: STD_LOGIC_VECTOR(1 downto 0); dout: STD_LOGIC_VECTOR(2 downto 0)); end; architecture synth rom begin process (adr) begin case adr “00” /H11005/H11022dout /H11021/H11005“011”; “01” /H11005/H11022dout /H11021/H11005“110”; “10” /H11005/H11022dout /H11021/H11005“100”; “11” /H11005/H11022dout /H11021/H11005“010”; end case; end process; end;HDL Example 5.8 ROMChapter 05.qxd 1/27/07 10:27 Page 266Figure 5.55 shows dot notation 3 /H110033/H110032-bit PLA per- forming functions . row array forms implicant. Dots row array indi- cate literals comprise implicant. array Figure 5.55 forms three implicants: , . Dots array indicate implicants part output function. Figure 5.56 shows PLAs built using two-level logic. alternative implementation given Section 5.6.3. ROMs viewed special case PLAs. 2M-word /H11003 N-bit ROM simply M/H110032M/H11003N-bit PLA. decoder behaves plane produces 2Mminterms. ROM array behaves plane produces outputs. function depend 2Mminterms, PLA likely smaller ROM. example, 8-word /H110032-bit ROM required perform functions performed 3 /H110033/H110032-bit PLA shown Figures 5.55 5.56.AB BC, ABCY /H11005 AB X/H11005A BC/H11001ABC5.6 Logic Arrays 267 ArrayOR ArrayInputs OutputsImplicants NM PFigure 5.54 M/H11003N/H11003P-bit PLA XYABC ABABCABC ArrayOR Array Figure 5.55 3/H110033/H110032-bit PLA: dot notationChapter 05.qxd 1/27/07 10:27 Page 267Programmable logic devices (PLDs ) souped-up PLAs add registers various features basic AND/OR planes. However, PLDs PLAs largely displaced FPGAs, flexible efficient building large systems. 5.6.2 Field Programmable Gate Array field programmable gate array (FPGA ) array reconfigurable gates. Using software programming tools, user implement designs FPGA using either HDL schematic. FPGAs pow- erful flexible PLAs several reasons. imple- ment combinational sequential logic. also implement multilevel logic functions, whereas PLAs implement two-level logic. Modern FPGAs integrate useful functions built-in multipliers large RAM arrays. FPGAs built array configurable logic blocks (CLBs). Figure 5.57 shows block diagram Spartan FPGA introduced Xilinx 1998. CLB configured perform combinational sequential functions. CLBs surrounded input/output blocks (IOBs) interfacing external devices. IOBs connect CLB inputs outputs pins chip package. CLBs connect CLBs IOBs programmable routing channels. remaining blocks shown figure aid programming device. Figure 5.58 shows single CLB Spartan FPGA. brands FPGAs organized somewhat differently, general prin- ciples apply. CLB contains lookup tables (LUTs), configurable mul- tiplexers, registers. FPGA configured specifying contents lookup tables select signals multiplexers.268 CHAPTER FIVE Digital Building Blocks FPGAs brains many consumer products, including automobiles, medical equip- ment, media devices like MP3 players. Mercedes Benz S-Class series, exam- ple, dozen Xilinx FPGAs PLDs uses rang- ing entertainment navigation cruise control systems. FPGAs allow quick time market make debugging adding features late design process easier. XYABC ARRAYOR ARRAY ABC ABABC Figure 5.56 3/H110033/H110032-bit PLA using two-level logicChapter 05.qxd 1/27/07 10:27 Page 268Each Spartan CLB three LUTs: four-input F- G-LUTs, three-input H-LUT. loading appropriate values lookup tables, F- G-LUTs configured perform function four variables, H-LUT perform func- tion three variables. Configuring FPGA also involves choosing select signals determine multiplexers route data CLB. example, depending multiplexer configuration, H-LUT may receive one inputs either DIN F-LUT. Similarly, receives another input either SR G-LUT. third input always comes H1.5.6 Logic Arrays 269 Figure 5.57 Spartan block diagramChapter 05.qxd 1/27/07 10:27 Page 269The FPGA produces two combinational outputs, Xand Y.Depending multiplexer configuration, Xcomes either F- H-LUT. Ycomes either G- H-LUT. outputs connected CLBs via routing channels CLB also contains two flip-flops. Depending configura- tion, flip-flop inputs may come DIN F-, G-, H-LUT. flip-flop outputs, XQ YQ, also connected CLBs via routing channels. summary, CLB perform two combinational and/or two registered functions. functions involve least four variables, involve nine. designer configures FPGA first creating schematic HDL description design. design synthesized onto FPGA. synthesis tool determines LUTs, multiplexers, routing channels configured perform specified functions. configuration information down- loaded FPGA. Xilinx FPGAs store configuration information SRAM, easily reprogrammed. may download SRAM contents computer laboratory EEPROM chip the270 CHAPTER FIVE Digital Building Blocks Figure 5.58 Spartan CLBChapter 05.qxd 1/27/07 10:28 Page 270system turned on. manufacturers include EEPROM directly FPGA use one-time programmable fuses configure FPGA. Example 5.6 FUNCTIONS BUILT USING CLBS Explain configure CLB perform following functions: (a) ; (b) Y/H11005JKLMPQR; (c) divide-by-3 counter binary state encoding (see Figure 3.29(a)). Solution: (a) Configure F-LUT compute Xand G-LUT compute Y, shown Figure 5.59. Inputs F3, F2, F1are A, B, C,respectively (these connections set routing channels). Inputs G2and G1are B. F4, G4, G3are don’t cares (and may connected 0). Configure final multiplexers select Xfrom F-LUT Yfrom G-LUT. general, CLB compute two functions, four variables each, fashion. (b) Configure F-LUT compute F/H11005JKLM G-LUT compute G/H11005PQR. configure H-LUT compute H/H11005FG. Configure final multiplexer select Yfrom H-LUT. configuration shown Figure 5.60. general, CLB compute certain functions nine variables way. (c) FSM two bits state ( S1:0) one output ( Y). next state depends two bits current state. Use F-LUT G-LUT compute next state current state, shown Figure 5.61. Use two flip- flops hold state. flip-flops dedicated reset input SR signal CLB. registered outputs fed back inputs using routing channels, indicated dashed blue lines. general, another CLB might necessary compute output Y.However, case, /H11005 , come F-LUT used compute . Hence, entire FSM fits single CLB. general, FSM requires least one CLB every two bits state, may require CLBs output next state logic complex fit single LUT.S/H110320S/H110320Y/H11005AB X /H11005A BC/H11001ABC5.6 Logic Arrays 271 F4 F3 F2 F1FF2 F1 F 00 01 10 110 1 0 0F3 0 0 0 0 00 01 10 111 1 1 10 0 1 0X X X X X X X XF4(A)( B)( C)( X) G2 G1 G 00 01 10 110 0 1 0G3 X X X XX X X XG4(A)( B)( Y)G4 G3 G2 G1G0 B0 B C0Y XFigure 5.59 CLB configuration two functions four inputs eachChapter 05.qxd 1/27/07 10:28 Page 271Example 5.7 CLB DELA Alyssa P. Hacker building finite state machine must run 200 MHz. uses Spartan 3 FPGA following specifications: tCLB /H11005 0.61 ns per CLB; tsetup /H110050.53 ns tpcq/H110050.72 ns flip-flops. maximum number CLBs design use? ignore inter- connect delay. Solution: Alyssa uses Equation 3.13 solve maximum propagation delay logic: tpd/H11349Tc/H11002(tpcq/H11001tsetup). Thus, tpd/H113495n /H11002(0.72 ns /H110010.53 ns), tpd/H113493.75 ns. delay CLB, tCLB,is 0.61 ns, maximum number CLBs, N, NtCLB/H113493.75 ns. Thus, N/H110056.272 CHAPTER FIVE Digital Building Blocks F4 F3 F2 F1FF2 F1 F 00 01 10 111 0 0 0F3 X X X XX X X XF4(S0)(S0') G2 G1 G 00 01 10 110 1 0 0G3 X X X XX X X XG4G4 G3 G2 G1G0 S00 00YQ XQ(S1)( S0) (S1)( S1') S1clk clk ResetReset YS1' S0' Figure 5.61 CLB configuration FSM two bits stateF4 F3 F2 F1FF2 F1 F 00 01 10 110 0 0 0F3 0 0 0 0 00 01 10 111 1 1 10 0 0 00 0 0 0 0 0 0 0F4(K)( L)( M) G2 G1 G G3 G4(P)( Q)G4 G3 G2 G1GP Q R0 K L MJ(J)( R) (Y)01 10 110 0 00 0 0 00 01 10 111 1 1 10 0 0 1X X X X X X X0000X 00 01 10 110 0 00 0 0 0 00 01 10 111 1 1 10 0 0 11 1 1 1 1 1 1 10 FGH H1 01 10 110 0 1X X X000XG H1 FH 0Y Figure 5.60 CLB configuration one function four inputsChapter 05.qxd 1/27/07 10:28 Page 2725.6.3 Array Implementations* minimize size cost, ROMs PLAs commonly use pseudo- nMOS dynamic circuits (see Section 1.7.8) instead conventional logic gates. Figure 5.62(a) shows dot notation 4 /H110033-bit ROM per- forms following functions: X/H11005A/H20003B, , Z/H11005 . functions Figure 5.49, address inputs renamed Aand Band data outputs renamed X, Y, Z.The pseudo-nMOS implementation given Figure 5.62(b). decoder output connected gates nMOS transistors row. Remember pseudo-nMOS circuits, weak pMOS transistor pulls output HIGH path GND pull- (nMOS) network. Pull-down transistors placed every junction without dot. dots dot notation diagram Figure 5.62(a) left faintly visible Figure 5.62(b) easy comparison. weak pull-up transis- tors pull output HIGH wordline without pull-down tran- sistor. example, AB/H1100511, 11 wordline HIGH transistors Xand Zturn pull outputs LOW. Yout- put transistor connecting 11 wordline, Yis pulled HIGH weak pull-up. PLAs also built using pseudo-nMOS circuits, shown Figure 5.63 PLA Figure 5.55. Pull-down (nMOS) transis- tors placed complement dotted literals array dotted rows array. columns array sent inverter fed output bits. Again, blue dots dot notation diagram Figure 5.55 left faintly visible Figure 5.63 easy comparison.AB Y/H11005A/H11001B5.6 Logic Arrays 273 11 102:4 Decoder 01 00A1 A0 X (a)A B YZ11 102:4 Decoder 01 00A1 A0A Bweak (b)XYZ Figure 5.62 ROM implementation: (a) dot notation, (b) pseudo-nMOS circuitMany ROMs PLAs use dynamic circuits place pseudo-nMOS circuits. Dynamic gates turn pMOS transistor part time, saving power pMOS result needed. Aside this, dynamic pseudo-nMOS memory arrays similar design behavior.Chapter 05.qxd 1/27/07 10:28 Page 2735.7 SUMMARY chapter introduced digital building blocks used many digital sys- tems. blocks include arithmetic circuits adders, subtrac- tors, comparators, shifters, multipliers, dividers; sequential circuits counters shift registers; arrays memory logic. chapter also explored fixed-point floating-point representations fractional numbers. Chapter 7, use building blocks build microprocessor. Adders form basis arithmetic circuits. half adder adds two 1-bit inputs, Aand B,and produces sum carry out. full adder extends half adder also accept carry in. N full adders cascaded form carry propagate adder (CPA) adds two N-bit numbers. type CPA called ripple-carry adder carry ripples full adders. Faster CPAs con- structed using lookahead prefix techniques. subtractor negates second input adds first. magnitude comparator subtracts one number another determines relative value based sign result. multi- plier forms partial products using gates, sums bits using full adders. divider repeatedly subtracts divisor partial remainder checks sign difference determine quotient bits. counter uses adder register increment running count. Fractional numbers represented using fixed-point floating-point forms. Fixed-point numbers analogous decimals, floating-point numbers analogous scientific notation. Fixed-point numbers use ordi- nary arithmetic circuits, whereas floating-point numbers require elab- orate hardware extract process sign, exponent, mantissa.274 CHAPTER FIVE Digital Building Blocks XYABC ABABCABC ArrayOR Array weakweak Figure 5.63 3/H110033/H110032-bit PLA using pseudo-nMOS circuitsChapter 05.qxd 1/27/07 10:28 Page 274Large memories organized arrays words. memories one ports read and/or write words. Volatile memo- ries, SRAM DRAM, lose state power turned off. SRAM faster DRAM requires transistors. register file small multiported SRAM array. Nonvolatile memo- ries, called ROMs, retain state indefinitely. Despite names, modern ROMs written. Arrays also regular way build logic. Memory arrays used lookup tables perform combinational functions. PLAs composed dedicated connections configurable arrays; implement combinational logic. FPGAs com- posed many small lookup tables registers; implement combinational sequential logic. lookup table contents interconnections configured perform logic function. Modern FPGAs easy reprogram large cheap enough build highly sophisticated digital systems, widely used low- medium-volume commercial products well education.5.7 Summary 275Chapter 05.qxd 1/27/07 10:28 Page 275EXERCISES Exercise 5.1 delay following types 64-bit adders? Assume two-input gate delay 150 ps full adder delay 450 ps. (a) ripple-carry adder (b) carry-lookahead adder 4-bit blocks (c) prefix adder Exercise 5.2 Design two adders: 64-bit ripple-carry adder 64-bit carry- lookahead adder 4-bit blocks. Use two-input gates. two-input gate 15 /H9262m2, 50 ps delay, 20 pF total gate capacitance. may assume static power negligible. (a) Compare area, delay, power adders (operating 100 MHz). (b) Discuss trade-offs power, area, delay. Exercise 5.3 Explain designer might choose use ripple-carry adder instead carry-lookahead adder. Exercise 5.4 Design 16-bit prefix adder Figure 5.7 HDL. Simulate test module prove functions correctly. Exercise 5.5 prefix network shown Figure 5.7 uses black cells com- pute prefixes. block propagate signals actually nec- essary. Design “gray cell” receives Gand Psignals bits i:kand k/H110021:j produces Gi:j, Pi:j. Redraw prefix network, replacing black cells gray cells wherever possible. Exercise 5.6 prefix network shown Figure 5.7 way calcu- late prefixes logarithmic time. Kogge-Stone network another common prefix network performs function using different connec- tion black cells. Research Kogge-Stone adders draw schematic similar Figure 5.7 showing connection black cells Kogge-Stone adder. Exercise 5.7 Recall N-input priority encoder log 2Noutputs encodes Ninputs gets priority (see Exercise 2.25). (a) Design N-input priority encoder delay increases logarithmi- cally N.Sketch design give delay circuit terms delay circuit elements. (b) Code design HDL. Simulate test module prove functions correctly.276 CHAPTER FIVE Digital Building BlocksChapter 05.qxd 1/27/07 10:28 Page 276Exercise 5.8 Design following comparators 32-bit numbers. Sketch schematics. (a) equal (b) greater (c) less equal Exercise 5.9 Design 32-bit ALU shown Figure 5.15 using favorite HDL. make top-level module either behavioral structural. Exercise 5.10 Add Overflow output 32-bit ALU Exercise 5.9. output TRUE result adder overflows. Otherwise, FALSE. (a) Write Boolean equation Overflow output. (b) Sketch Overflow circuit. (c) Design modified ALU HDL. Exercise 5.11 Add Zero output 32-bit ALU Exercise 5.9. out- put TRUE Y/H11005/H110050. Exercise 5.12 Write testbench test 32-bit ALU Exercise 5.9, 5.10, 5.11. use test ALU. Include test vector files necessary. sure test enough corner cases convince reasonable skeptic ALU functions correctly. Exercise 5.13 Design shifter always shifts 32-bit input left 2 bits. input output 32 bits. Explain design words sketch schematic. Implement design favourite HDL. Exercise 5.14 Design 4-bit left right rotators. Sketch schematic design. Implement design favourite HDL. Exercise 5.15 Design 8-bit left shifter using 24 2:1 multiplexers. shifter accepts 8-bit input, A,and 3-bit shift amount, shamt 2:0. produces 8-bit output, Y.Sketch schematic. Exercise 5.16 Explain build N-bit shifter rotator using Nlog2N2:1 multiplexers. Exercise 5.17 funnel shifter Figure 5.64 perform N-bit shift rotate operation. shifts 2 N-bit input right kbits. output, Y,is Nleast significant bits result. significant Nbits input areExercises 277Chapter 05.qxd 1/27/07 10:28 Page 277called Band least significant Nbits called C.By choosing appropriate values B, C, k,the funnel shifter perform type shift rotate. Explain values terms A, shamt, Nfor (a) logical right shift Aby shamt. (b) arithmetic right shift Aby shamt. (c) left shift Aby shamt. (d) right rotate Aby shamt. (e) left rotate Aby shamt.278 CHAPTER FIVE Digital Building Blocks BC k k + N – 10 N – 1 2N – 1 Y0 N – 1 Figure 5.64 Funnel shifter Exercise 5.18 Find critical path 4 /H110034 multiplier Figure 5.18 terms gate delay ( tAND) full adder delay ( tFA). delay N/H11003Nmultiplier built way? Exercise 5.19 Design multiplier handles two’s complement numbers. Exercise 5.20 sign extension unit extends two’s complement number N(N/H11022M) bits copying significant bit input upper bits output (see Section 1.4.6). receives M-bit input, A,and produces N-bit output, Y.Sketch circuit sign extension unit 4-bit input 8-bit output. Write HDL design. Exercise 5.21 zero extension unit extends unsigned number Mto N bits ( N/H11022M) putting zeros upper bits output. Sketch circuit zero extension unit 4-bit input 8-bit output. Write HDL design. Exercise 5.22 Compute 111001.000 2/001100.000 2in binary using standard division algorithm elementary school. Show work.Chapter 05.qxd 1/27/07 10:28 Page 278Exercise 5.23 range numbers represented following number systems? (a) 24-bit unsigned fixed-point numbers 12 integer bits 12 fraction bits (b) 24-bit sign magnitude fixed-point numbers 12 integer bits 12 fraction bits (c) 24-bit two’s complement fixed-point numbers 12 integer bits 12 fraction bits Exercise 5.24 Express following base 10 numbers 16-bit fixed-point sign/magnitude format eight integer bits eight fraction bits. Express answer hexadecimal. (a)/H1100213.5625 (b) 42.3125 (c)/H1100217.15625 Exercise 5.25 Express base 10 numbers Exercise 5.24 16-bit fixed- point two’s complement format eight integer bits eight fraction bits. Express answer hexadecimal. Exercise 5.26 Express base 10 numbers Exercise 5.24 IEEE 754 single-precision floating-point format. Express answer hexadecimal. Exercise 5.27 Convert following two’s complement binary fixed-point numbers base 10. (a) 0101.1000 (b) 1111.1111 (c) 1000.0000 Exercise 5.28 adding two floating-point numbers, number smaller exponent shifted. this? Explain words give example justify explanation. Exercise 5.29 Add following IEEE 754 single-precision floating-point numbers. (a) C0D20004 /H1100172407020 (b) C0D20004 /H1100140DC0004 (c) (5FBE4000 /H110013FF80000) /H11001DFDE4000 (Why result counterintuitive? Explain.)Exercises 279Chapter 05.qxd 1/27/07 10:28 Page 279Exercise 5.30 Expand steps section 5.3.2 performing floating-point addition work negative well positive floating-point numbers. Exercise 5.31 Consider IEEE 754 single-precision floating-point numbers. (a) many numbers represented IEEE 754 single-precision floating-point format? need count /H11006/H11009or NaN. (b) many additional numbers could represented /H11006/H11009and NaN represented? (c) Explain /H11006/H11009and NaN given special representations. Exercise 5.32 Consider following decimal numbers: 245 0.0625. (a) Write two numbers using single-precision floating-point notation. Give answers hexadecimal. (b) Perform magnitude comparison two 32-bit numbers part (a). words, interpret two 32-bit numbers two’s complement numbers compare them. integer comparison give correct result? (c) decide come new single-precision floating-point notation. Everything IEEE 754 single-precision floating-point stan- dard, except represent exponent using two’s complement instead bias. Write two numbers using new standard. Give answers hexadecimal. (e) integer comparison work new floating-point notation part (d)? (f) convenient integer comparison work floating-point numbers? Exercise 5.33 Design single-precision floating-point adder using favorite HDL. coding design HDL, sketch schematic design. Simulate test adder prove skeptic functions cor- rectly. may consider positive numbers use round toward zero (truncate). may also ignore special cases given Table 5.2. Exercise 5.34 problem, explore design 32-bit floating- point multiplier. multiplier two 32-bit floating-point inputs pro- duces 32-bit floating-point output. may consider positive numbers only280 CHAPTER FIVE Digital Building BlocksChapter 05.qxd 1/27/07 10:28 Page 280and use round toward zero (truncate). may also ignore special cases given Table 5.2. (a) Write steps necessary perform 32-bit floating-point multiplication. (b) Sketch schematic 32-bit floating-point multiplier. (c) Design 32-bit floating-point multiplier HDL. Simulate test multiplier prove skeptic functions correctly. Exercise 5.35 problem, explore design 32-bit prefix adder. (a) Sketch schematic design. (b) Design 32-bit prefix adder HDL. Simulate test adder prove functions correctly. (c) delay 32-bit prefix adder part (a)? Assume two-input gate delay 100 ps. (d) Design pipelined version 32-bit prefix adder. Sketch schematic design. fast pipelined prefix adder run? Make design run fast possible. (e) Design pipelined 32-bit prefix adder HDL. Exercise 5.36 incrementer adds 1 N-bit number. Build 8-bit incre- menter using half adders. Exercise 5.37 Build 32-bit synchronous Up/Down counter. inputs Reset Up.When Reset 1, outputs 0. Otherwise, Up/H110051, circuit counts up, Up/H110050, circuit counts down. Exercise 5.38 Design 32-bit counter adds 4 clock edge. counter reset clock inputs. Upon reset, counter output 0. Exercise 5.39 Modify counter Exercise 5.38 counter either increment 4 load new 32-bit value, D,on clock edge, depend- ing control signal, PCSrc. PCSrc /H110051, counter loads new value D. Exercise 5.40 N-bit Johnson counter consists N-bit shift register reset signal. output shift register ( Sout) inverted fed back input ( Sin). counter reset, bits cleared 0. (a) Show sequence outputs, Q3:0, produced 4-bit Johnson counter starting immediately counter reset.Exercises 281Chapter 05.qxd 1/27/07 10:28 Page 281(b) many cycles elapse N-bit Johnson counter repeats sequence? Explain. (c) Design decimal counter using 5-bit Johnson counter, ten gates, inverters. decimal counter clock, reset, ten one-hot outputs, Y9:0. counter reset, Y0is asserted. subsequent cycle, next output asserted. ten cycles, counter repeat. Sketch schematic decimal counter. (d) advantages might Johnson counter conventional counter? Exercise 5.41 Write HDL 4-bit scannable flip-flop like one shown Figure 5.37. Simulate test HDL module prove functions correctly. Exercise 5.42 English language good deal redundancy allows us reconstruct garbled transmissions. Binary data also transmitted redundant form allow error correction. example, number 0 could coded 00000 number 1 could coded 11111. value could sent noisy channel might flip two bits. receiver could reconstruct original data 0 least three five received bits 0’s; similarly 1 least three 1’s. (a) Propose encoding send 00, 01, 10, 11 encoded using five bits information errors corrupt one bit encoded data corrected. Hint: encodings 00000 11111 00 11, respec- tively, work. (b) Design circuit receives five-bit encoded data decodes 00, 01, 10, 11, even one bit transmitted data changed. (c) Suppose wanted change alternative 5-bit encoding. might implement design make easy change encoding without use different hardware? Exercise 5.43 Flash EEPROM, simply called Flash memory, fairly recent invention revolutionized consumer electronics. Research explain Flash memory works. Use diagram illustrating floating gate. Describe bit memory programmed. Properly cite sources. Exercise 5.44 extraterrestrial life project team discovered aliens living bottom Mono Lake. need construct circuit classify aliens potential planet origin based measured features282 CHAPTER FIVE Digital Building BlocksChapter 05.qxd 1/27/07 10:28 Page 282available NASA probe: greenness, brownness, sliminess, ugliness. Careful consultation xenobiologists leads following conclusions: /L50776If alien green slimy ugly, brown, slimy, might Mars. /L50776If critter ugly, brown, slimy, green neither ugly slimy, might Venus. /L50776If beastie brown neither ugly slimy green slimy, might Jupiter. Note inexact science; example, life form mottled green brown slimy ugly might either Mars Jupiter. (a) Program 4 /H110034/H110033 PLA identify alien. may use dot notation. (b) Program 16 /H110033 ROM identify alien. may use dot notation. (c) Implement design HDL. Exercise 5.45 Implement following functions using single 16 /H110033 ROM. Use dot notation indicate ROM contents. (a) (b) (c)Z/H11005A/H11001B/H11001C/H11001D Exercise 5.46 Implement functions Exercise 5.45 using 4 /H110038/H110033 PLA. may use dot notation. Exercise 5.47 Specify size ROM could use program following combinational circuits. using ROM implement func- tions good design choice? Explain not. (a) 16-bit adder/subtractor Cinand Cout (b) 8 /H110038 multiplier (c) 16-bit priority encoder (see Exercise 2.25) Exercise 5.48 Consider ROM circuits Figure 5.65. row, circuit column replaced equivalent circuit column II proper programming latter’s ROM?Y/H11005AB/H11001BDX/H11005AB/H11001BC D/H11001A BExercises 283Chapter 05.qxd 1/27/07 10:28 Page 283284 CHAPTER FIVE Digital Building Blocks K+1 IAR ROM CLKN N K InAR ROMN N AR ROMN AR ROMK+1CLKK AR ROMK+1 K+1CLKK AR ROMK+1 K+1Out CLKK AR ROMK+1 K+N NAR ROMNOutCLKK AR ROMK+1 K+N NOut CLKN AR ROMN+1 N N AR ROMNOutCLKN AR ROMN+1 N NOut II(a) (b) (c) (d) Figure 5.65 ROM circuits Exercise 5.49 Give example nine-input function performed using one Spartan FPGA CLB. Give example eight-input function cannot performed using one CLB. Exercise 5.50 many Spartan FPGA CLBs required perform following functions? Show configure one CLBs perform function. able inspection, without performing logic synthesis. (a) combinational function Exercise 2.7(c). (b) combinational function Exercise 2.9(c). (c) two-output function Exercise 2.15. (d) function Exercise 2.24. (e) four-input priority encoder (see Exercise 2.25). (f) eight-input priority encoder (see Exercise 2.25). (g) 3:8 decoder.Chapter 05.qxd 1/27/07 10:28 Page 284(h) 4-bit carry propagate adder (with carry out). (i) FSM Exercise 3.19. (j) Gray code counter Exercise 3.24. Exercise 5.51 Consider Spartan CLB shown Figure 5.58. follow- ing specifications: tpd/H11005tcd/H110052.7 ns per CLB; tsetup /H110053.9 ns, thold/H110050 ns, tpcq/H110052.8 ns flip-flops. (a) minimum number Spartan CLBs required implement FSM Figure 3.26? (b) Without clock skew, fastest clock frequency FSM run reliably? (c) 5 ns clock skew, fastest frequency FSM run reliably? Exercise 5.52 would like use FPGA implement M&M sorter color sensor motors put red candy one jar green candy another. design implemented FSM using Spartan XC3S200 FPGA, chip Spartan 3 series family. considerably faster original Spartan FPGA. According data sheet, FPGA timing char- acteristics shown Table 5.5. Assume design small enough wire delay negligible.Exercises 285 Table 5.5 Spartan 3 XC3S200 timing Name Value (ns) tpcq 0.72 tsetup 0.53 thold 0 tpd(per CLB) 0.61 tskew 0 would like FSM run 100 MHz. maximum number CLBs critical path? fastest speed FSM run?Chapter 05.qxd 1/27/07 10:28 Page 285Interview Questions following exercises present questions asked interviews digital design jobs. Question 5.1 largest possible result multiplying two unsigned N-bit numbers? Question 5.2 Binary coded decimal (BCD ) representation uses four bits encode decimal digit. example 42 10is represented 01000010 BCD. Explain words processors might use BCD representation. Question 5.3 Design hardware add two 8-bit unsigned BCD numbers (see Question 5.2). Sketch schematic design, write HDL module BCD adder. inputs A, B, Cin, outputs Sand Cout. Cin Coutare 1-bit carries, A, B, Sare 8-bit BCD numbers.286 CHAPTER FIVE Digital Building BlocksChapter 05.qxd 1/27/07 10:28 Page 2866 6.1 Introduction 6.2 Assembly Language 6.3 Machine Language 6.4 Programming 6.5 Addressing Modes 6.6 Lights, Camera, Action: Compiling, Assembling, Loading 6.7 Odds Ends* 6.8 Real World Perspective: IA-32 Architecture* 6.9 Summary Exercises Interview QuestionsArchitecture 6.1 INTRODUCTION previous chapters introduced digital design principles building blocks. chapter, jump levels abstraction define architecture computer (see Figure 1.1). architecture programmer’s view computer. defined instruction set (language), operand locations (registers memory). Many differ- ent architectures exist, IA-32, MIPS, SPARC, PowerPC. first step understanding computer architecture learn language. words computer’s language called instructions . computer’s vocabulary called instruction set. programs running computer use instruction set . Even complex software applications, word processing spread- sheet applications, eventually compiled series simple instructions add, subtract, jump. Computer instructions indicate operation perform operands use. operands may come memory, registers, instruction itself. Computer hardware understands 1’s 0’s, instructions encoded binary numbers format called machine language . use letters encode human language, computers use binary numbers encode machine language. Microprocessors digital sys- tems read execute machine language instructions. However, humans consider reading machine language tedious, prefer represent instructions symbolic format, called assembly language . instruction sets different architectures like different dialects different languages. Almost architectures define basic instructions, add, subtract, jump, operate memory registers. learned one instruction set, understanding others fairly straightforward. 289Chapter 06.qxd 1/31/07 8:21 PM Page 289A computer architecture define underlying hardware implementation. Often, many different hardware implementations single architecture exist. example, Intel Advanced Micro Devices (AMD) sell various microprocessors belonging IA-32 archi- tecture. run programs, use different underlying hardware therefore offer trade-offs performance, price, power. microprocessors optimized high-performance servers, whereas others optimized long battery life laptop com- puters. specific arrangement registers, memories, ALUs, building blocks form microprocessor called microarchitecture subject Chapter 7. Often, many different microarchi- tectures exist single architecture. text, introduce MIPS architecture first devel- oped John Hennessy colleagues Stanford 1980s. MIPS processors used by, among others, Silicon Graphics, Nintendo, Cisco. start introducing basic instructions, operand locations, machine language formats. introduce instructions used common programming constructs, branches, loops, array manipulations, procedure calls. Throughout chapter, motivate design MIPS architec- ture using four principles articulated Patterson Hennessy: (1) sim- plicity favors regularity; (2) make common case fast; (3) smaller faster; (4) good design demands good compromises. 6.2 ASSEMBLY LANGUAGE Assembly language human-readable representation com- puter’s native language. assembly language instruction specifies operation perform operands operate. introduce simple arithmetic instructions show operations written assembly language. define MIPS instruction operands: registers, memory, constants. assume already familiarity high-level programming language C, C /H11001/H11001, Java. (These languages practically identical examples chapter, differ, use C.) 6.2.1 Instructions common operation computers perform addition. Code Example 6.1 shows code adding variables band cand writing result a. program shown left high-level language (using syntax C, C /H11001/H11001, Java), rewritten right MIPS assembly language. Note statements C program end semicolon.290 CHAPTER SIX Architecture best architecture study first learning subject? Commercially successful architectures IA-32 satisfying study use write programs real computers. Unfortunately, many architectures full warts idiosyncrasies accumu- lated years haphazard development different engineering teams, making architectures difficult understand implement. Many textbooks teach imaginary architectures simplified illustrate key concepts. follow lead David Patterson John Hennessy text, Computer Organization Design , focusing MIPS architec- ture. Hundreds millions MIPS microprocessors shipped, architecture commercially important. Yet clean architecture little odd behavior. end chapter, briefly visit IA-32 architecture compare contrast MIPS.Chapter 06.qxd 1/31/07 8:21 PM Page 2906.2 Assembly Language 291 High-Level Code /H11005b /H11001c;MIPS Assembly Code add a, b, cCode Example 6.1 ADDITION High-Level Code /H11005b /H11002c;MIPS Assembly Code sub a, b, cCode Example 6.2 SUBTRACTION High-Level Code /H11005b /H11001c /H11002d; // single-line comment /* multiple-line comment */ MIPS Assembly Code sub t, c, # /H11005c /H11002d add a, b, # /H11005b /H11001tCode Example 6.3 COMPLEX CODEThe first part assembly instruction, add, called mnemonic indicates operation perform. operation performed band c, source operands , result written a, destination operand . Code Example 6.2 shows subtraction similar addition. instruction format addinstruction except oper- ation specification, sub. consistent instruction format example first design principle: Design Principle 1: Simplicity favors regularity. Instructions consistent number operands—in case, two sources one destination—are easier encode handle hard- ware. complex high-level code translates multiple MIPS instructions, shown Code Example 6.3. high-level language examples, single-line comments begin //and continue end line. Multiline comments begin /*and end */. assembly language, single-line comments used. begin #and continue end line. assembly language program Code Example 6.3 requires temporary variable, t, store intermediate result. Using multiple assemblymnemonic (pronounced ni-mon-ik ) comes Greek word /H9262/H9259/H9262/H9263 E/H9268/H9260/H9280/H9268/H9270/H9257/H9251/H9259 , remember. assembly language mnemonic easier remember machine language pattern 0’s 1’s representing operation.Chapter 06.qxd 1/31/07 8:21 PM Page 291language instructions perform complex operations example second design principle computer architecture: Design Principle 2: Make common case fast. MIPS instruction set makes common case fast including simple, commonly used instructions. number instructions kept small hardware required decode instruction operands simple, small, fast. elaborate operations less common performed using sequences multiple simple instructions. Thus, MIPS reduced instruction set computer (RISC ) architecture. Architectures many complex instructions, Intel’s IA-32 architecture, complex instruction set computers (CISC ). example, IA-32 defines “string move” instruction copies string (a series characters) one part memory another. operation requires many, possibly even hundreds, simple instruc- tions RISC machine. However, cost implementing complex instructions CISC architecture added hardware overhead slows simple instructions. RISC architecture minimizes hardware complexity nec- essary instruction encoding keeping set distinct instructions small. example, instruction set 64 simple instructions would need log264 /H110056 bits encode operation. instruction set 256 com- plex instructions would need log 2256 /H110058 bits encoding per instruction. CISC machine, even though complex instructions may used rarely, add overhead instructions, even simple ones. 6.2.2 Operands: Registers, Memory, Constants instruction operates operands . Code Example 6.1 vari- ables a, b, care operands. computers operate 1’s 0’s, variable names. instructions need physical location retrieve binary data. Operands stored registers memory, may constants stored instruction itself. Computers use various locations hold operands, optimize speed data capacity. Operands stored constants registers accessed quickly, hold small amount data. Additional data must accessed memory, large slow. MIPS called 32-bit architecture operates 32-bit data. (The MIPS architecture extended 64 bits commercial products, consider 32-bit form book.) Registers Instructions need access operands quickly run fast. operands stored memory take long time retrieve. Therefore,292 CHAPTER SIX ArchitectureChapter 06.qxd 1/31/07 8:21 PM Page 292most architectures specify small number registers hold com- monly used operands. MIPS architecture uses 32 registers, called register set register file . fewer registers, faster accessed. leads third design principle: Design Principle 3: Smaller faster. Looking information small number relevant books desk lot faster searching information stacks library. Likewise, reading data small set registers (for example, 32) faster reading 1000 registers large memory. small register file typically built small SRAM array (see Section 5.5.3). SRAM array uses small decoder bitlines connected relatively memory cells, shorter critical path large memory does. Code Example 6.4 shows addinstruction register operands. MIPS register names preceded $sign. variables a, b, c arbitrarily placed $s0, $s1, $s2. name $s1is pronounced “register s1” “dollar s1”. instruction adds 32-bit values con- tained $s1(b) $s2(c) writes 32-bit result $s0(a). MIPS generally stores variables 18 32 registers: $s0–$s7, $t0–$t9. Register names beginning $sare called saved regis- ters. Following MIPS convention, registers store variables a, b, c. Saved registers special connotations used procedure calls (see Section 6.4.6). Register names beginning $tare called temporary registers. used storing tempo- rary variables. Code Example 6.5 shows MIPS assembly code using temporary register, $t0, store intermediate calculation c/H11002d.6.2 Assembly Language 293 High-Level Code /H11005b /H11001c;MIPS Assembly Code # $s0 /H11005a, $s1 /H11005b, $s2 = c add $s0, $s1, $s2 # = b + cCode Example 6.4 REGISTER OPERANDS High-Level Code /H11005b /H11001c /H11002d;MIPS Assembly Code # $s0 /H11005a, $s1 /H11005b, $s2 /H11005c, $s3 /H11005d sub $t0, $s2, $s3 # /H11005c /H11002d add $s0, $s1, $t0 # /H11005b /H11001tCode Example 6.5 TEMPORARY REGISTERSChapter 06.qxd 1/31/07 8:21 PM Page 293Example 6.1 TRANSLATING HIGH-LEVEL CODE ASSEMBLY LANGUAGE Translate following high-level code assembly language. Assume variables a–care held registers $s0–$s2 f–jare $s3–$s7 . /H11005b /H11002c; f /H11005(g /H11001h) /H11002(i /H11001j); Solution: program uses four assembly language instructions. # MIPS assembly code # $s0 /H11005a, $s1 /H11005b, $s2 /H11005c, $s3 /H11005f, $s4 /H11005g, $s5 /H11005h, # $s6 /H11005i, $s7 /H11005j sub $s0, $s1, $s2 # /H11005b /H11002c add $t0, $s4, $s5 # $t0 /H11005g /H11001h add $t1, $s6, $s7 # $t1 /H11005i /H11001j sub $s3, $t0, $t1 # f /H11005(g /H11001h) /H11002(i /H11001j) Register Set MIPS architecture defines 32 registers. register name number ranging 0 31. Table 6.1 lists name, number, use register. $0always contains value 0 constant fre- quently used computer programs. also discussed $sand $t registers. remaining registers described throughout chapter.294 CHAPTER SIX Architecture Table 6.1 MIPS register set Name Number Use $0 0 constant value 0 $at 1 assembler temporary $v0–$v1 2–3 procedure return values $a0–$a3 4–7 procedure arguments $t0–$t7 8–15 temporary variables $s0–$s7 16–23 saved variables $t8–$t9 24–25 temporary variables $k0–$k1 26–27 operating system (OS) temporaries $gp 28 global pointer $sp 29 stack pointer $fp 30 frame pointer $ra 31 procedure return addressChapter 06.qxd 1/31/07 8:21 PM Page 294Memory registers storage space operands, would con- fined simple programs 32 variables. However, data also stored memory. compared register file, mem- ory many data locations, accessing takes longer amount time. Whereas register file small fast, memory large slow. reason, commonly used variables kept registers. using combination memory registers, program access large amount data fairly quickly. described Section 5.5, memo- ries organized array data words. MIPS architecture uses 32-bit memory addresses 32-bit data words. MIPS uses byte-addressable memory. is, byte memory unique address. However, explanation purposes only, first introduce word-addressable memory, afterward describe MIPS byte-addressable memory. Figure 6.1 shows memory array word-addressable . is, 32-bit data word unique 32-bit address. 32-bit word address 32-bit data value written hexadecimal Figure 6.1. example, data 0xF2F1AC07 stored memory address 1. Hexadecimal constants written prefix 0x. convention, memory drawn low memory addresses toward bottom high memory addresses toward top. MIPS uses load word instruction, lw, read data word memory register. Code Example 6.6 loads memory word 1 $s3. lwinstruction specifies effective address memory sum base address offset . base address (written parentheses instruction) register. offset constant (written parentheses). Code Example 6.6, base address6.2 Assembly Language 295 Data 00000003 40F30788 01EE2842 F2F 1AC07 ABCDEF 7800000002 00000001 00000000Word Address Word 3 Word 2 Word 1 Word 0Figure 6.1 Word-addressable memory Assembly Code # assembly code (unlike MIPS) assumes word-addressable memory lw $s3, 1($0) # read memory word 1 $s3Code Example 6.6 READING WORD-ADDRESSABLE MEMORYChapter 06.qxd 1/31/07 8:21 PM Page 295is $0, holds value 0, offset 1, lwinstruction reads memory address ( $0+1 ) /H110051. load word instruction (lw) executed, $s3holds value 0xF2F1AC07, data value stored memory address 1 Figure 6.1. Similarly, MIPS uses store word instruction, sw, write data word register memory. Code Example 6.7 writes con- tents register $s7into memory word 5. examples used $0 base address simplicity, remember register used supply base address. previous two code examples shown computer architec- ture word-addressable memory. MIPS memory model, however, byte-addressable, notword-addressable. data byte unique address. 32-bit word consists four 8-bit bytes. word address multiple 4, shown Figure 6.2. Again, 32-bit word address data value given hexadecimal. Code Example 6.8 shows read write words MIPS byte-addressable memory. word address four times word number. MIPS assembly code reads words 0, 2, 3 writes words 1, 8, 100. offset written decimal hexadecimal. MIPS architecture also provides lband sbinstructions load store single bytes memory rather words. similar lwand swand discussed Section 6.4.5. Byte-addressable memories organized big-endian little- endian fashion, shown Figure 6.3. formats, significant byte (MSB ) left least significant byte (LSB) right. big-endian machines, bytes numbered starting 0296 CHAPTER SIX Architecture Assembly Code # assembly code (unlike MIPS) assumes word-addressable memory sw $s7, 5($0) # write $s7 memory word 5Code Example 6.7 WRITING WORD-ADDRESSABLE MEMORY Word Address Data 0000000C 00000008 00000004 00000000 width = 4 bytes40F30788 01EE2842 F2F1 AC07 ABCDEF 78Word 3 Word 2 Word 1 Word 0Figure 6.2 Byte-addressable memory 0123 MSB LSB456789ABCDEFByte Address 3210 07654 4BA98 8FEDC CByte AddressWord AddressBig-Endian Little-Endian MSB LSB Figure 6.3 Big- little- endian memory addressingChapter 06.qxd 1/31/07 8:21 PM Page 296at big (most significant) end. little-endian machines, bytes numbered starting 0 little (least significant) end. Word addresses formats refer four bytes. addresses bytes within word differ. Example 6.2 BIG- LITTLE-ENDIAN MEMORY Suppose $s0initially contains 0x23456789. following program run big-endian system, value $s0contain? little-endian system? lb $s0, 1($0) loads data byte address (1/H11001$0) /H110051into least significant byte $s0. lb discussed detail Section 6.4.5. sw $s0, 0($0) lb $s0, 1($0) Solution: Figure 6.4 shows big- little-endian machines store value 0x23456789 memory word 0. load byte instruction, lb $s0, 1($0), $s0would contain 0x00000045 big-endian system 0x00000067 little-endian system.6.2 Assembly Language 297 MIPS Assembly Code 1w $s0, 0($0) # read data word 0 (0xABCDEF78) $s0 1w $s1, 8($0) # read data word 2 (0x01EE2842) $s1 1w $s2, 0xC($0) # read data word 3 (0x40F30788) $s2 sw $s3, 4($0) # write $s3 data word 1 sw $s4, 0x20($0) # write $s4 data word 8 sw $s5, 400($0) # write $s5 data word 100Code Example 6.8 ACCESSING BYTE-ADDRESSABLE MEMORY terms big-endian little- endian come Jonathan Swift’s Gulliver’s Travels , first published 1726 pseudonym Isaac Bickerstaff. stories Lilliputian king required citizens (the Little- Endians) break eggs little end. Big-Endians rebels broke eggs big end. terms first applied computer architec- tures Danny Cohen paper “On Holy Wars Plea Peace” published April Fools Day, 1980 (USC/ISI IEN 137 ). (Photo courtesy Brotherton Collection, IEEDS University Library.) 1SPIM, MIPS simulator comes text, uses endianness machine run on. example, using SPIM Intel IA-32 machine, memory little-endian. older Macintosh Sun SPARC machine, memory big-endian. 2345 67 890123 2345 67 89 03210Word AddressBig-Endian Little-Endian Byte Address Data ValueByte Address Data Value MSB LSB MSB LSB Figure 6.4 Big-endian little-endian data storage IBM’s PowerPC (formerly found Macintosh computers) uses big-endian addressing. Intel’s IA-32 architecture (found PCs) uses little-endian addressing. MIPS processors little-endian, big-endian.1The choice endianness completely arbitrary leads hassles sharing data big-endian little- endian computers. examples text, use little-endian format whenever byte ordering matters.Chapter 06.qxd 1/31/07 8:21 PM Page 297In MIPS architecture, word addresses lwand swmust word aligned . is, address must divisible 4. Thus, instruction lw $s0,7($0) illegal instruction. architectures, IA-32, allow non-word-aligned data reads writes, MIPS requires strict alignment simplicity. course, byte addresses load byte store byte, lband sb, need word aligned. Constants/Immediates Load word store word, lwand sw, also illustrate use con- stants MIPS instructions. constants called immediates , values immediately available instruction require register memory access. Add immediate, addi , another common MIPS instruction uses immediate operand. addi adds immediate specified instruction value regis- ter, shown Code Example 6.9. immediate specified instruction 16-bit two’s comple- ment number range [ /H1100232768, 32767]. Subtraction equivalent adding negative number, so, interest simplicity, subi instruction MIPS architecture. Recall addand subinstructions use three register operands. lw,sw , addi instructions use two register operands constant. instruction formats differ, lwand swinstructions violate design principle 1: simplicity favors regularity. However, issue allows us introduce last design principle:298 CHAPTER SIX Architecture High-Level Code /H11005a /H110014; b /H11005a /H1100212;MIPS Assembly Code # $s0 /H11005a, $s1 /H11005b addi $s0, $s0, 4 # /H11005a /H110014 addi $s1, $s0, /H1100212 # b /H11005a /H1100212Code Example 6.9 IMMEDIATE OPERANDS Design Principle 4: Good design demands good compromises. single instruction format would simple flexible. MIPS instruction set makes compromise supporting three instruc- tion formats. One format, used instructions addand sub, three register operands. Another, used instructions lwand addi , two register operands 16-bit immediate. third, discussed later, 26-bit immediate registers. next section discusses three MIPS instruction formats shows encoded binary.Chapter 06.qxd 1/31/07 8:21 PM Page 2986.3 MACHINE LANGUAGE Assembly language convenient humans read. However, digital circuits understand 1’s 0’s. Therefore, program written assembly language translated mnemonics representation using 1’s 0’s, called machine language . MIPS uses 32-bit instructions. Again, simplicity favors regularity, regular choice encode instructions words stored memory. Even though instructions may require 32 bits encoding, variable-length instructions would add much complexity. Simplicity would also encourage single instruction format, but, already mentioned, restrictive. MIPS makes compromise defining three instruction formats: R-type , I-type, J-type. small number formats allows regularity among types, thus simpler hardware, also accommodating different instruction needs, need encode large constants instruction. R-type instructions operate three registers. I-type instructions operate two registers 16-bit immediate. J-type (jump) instructions operate one 26-bit immediate. introduce three formats section leave discussion J-type instructions Section 6.4.2. 6.3.1 R-type Instructions name R-type short register-type . R-type instructions use three registers operands: two sources, one destination. Figure 6.5 shows R-type machine instruction format. 32-bit instruction six fields: op, rs, rt, rd, shamt , funct . field five six bits, indicated. operation instruction performs encoded two fields highlighted blue: op(also called opcode operation code) funct (also called function). R-type instructions opcode 0. specific R-type operation determined funct field. example, opcode funct fields addinstruction 0 (000000 2) 32 (100000 2), respectively. Similarly, subinstruc- tion opcode funct field 0 34. operands encoded three fields: rs,rt , rd. first two registers, rsand rt, source registers; rdis destination6.3 Machine Language 299 op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bitsR-type Figure 6.5 R-type machine instruction formatChapter 06.qxd 1/31/07 8:21 PM Page 299register. fields contain register numbers given Table 6.1. example, $s0is register 16. fifth field, shamt , used shift operations. instructions, binary value stored 5-bit shamt field indicates amount shift. R-type instructions, shamt 0. Figure 6.6 shows machine code R-type instructions add sub. Notice destination first register assembly language instruction, third register field ( rd) machine language instruction. example, assembly instruction add $s0, $s1, $s2 rs /H11005$s1(17), rt /H11005$s2(18), rd /H11005$s0(16). Tables B.1 B.2 Appendix B define opcode values MIPS instructions funct field values R-type instructions. Example 6.3 TRANSLATING ASSEMBLY LANGUAGE MACHINE LANGUAGE Translate following assembly language statement machine language. add $t0, $s4, $s5 Solution: According Table 6.1, $t0,$s4, $s5are registers 8, 20, 21. According Tables B.1 B.2, addhas opcode 0 funct code 32. Thus, fields machine code given Figure 6.7. easiest way write machine language hexadecimal first write binary, look consecutive groups four bits, correspond hexadecimal digits (indicated blue). Hence, machine language instruc- tion 0x02954020.300 CHAPTER SIX Architecture 000000 10001 10010 10000 00000 100000 000000add $s0, $s1, $s2 sub $t0, $t3, $t5Machine Code Assembly Code 01 7 18 16 0 32 01 1 1 3 80 3 4Field Values (0 x 02328020) (0 x 016D4022)op rs rt rd shamt funct op rs rt rd shamt funct 01011 01101 01000 00000 100010 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits Figure 6.6 Machine code R-type instructions 000000 10100 10101 01000 00000 100000 add $t0, $s4, $s5Machine Code Assembly Code 20 21 8 0 32 0Field Values (0 x 02954020) 04 0 2 29 5 0op op rs rt rd shamt funct rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits Figure 6.7 Machine code R-type instruction Example 6.3rsis short “register source.” rtcomes rs alphabetically usually indicates second register source.Chapter 06.qxd 1/31/07 8:21 PM Page 3006.3.2 I-Type Instructions name I-type short immediate-type . I-type instructions use two register operands one immediate operand. Figure 6.8 shows I-type machine instruction format. 32-bit instruction four fields: op,rs,rt, imm. first three fields, op,rs, rt, like R-type instructions. immfield holds 16-bit immediate. operation determined solely opcode , highlighted blue. operands specified three fields, rs,rt, imm.rs immare always used source operands. rtis used destination instructions (such addi lw) another source others (such sw). Figure 6.9 shows several examples encoding I-type instructions. Recall negative immediate values represented using 16-bit two’s complement notation. rtis listed first assembly language instruction used destination, second register field machine language instruction.6.3 Machine Language 301 op rs rt imm 6 bits 5 bits 5 bits 16 bitsI-type Figure 6.8 I-type instruction format (0 x 22300005) (0 x 2268FFF4) (0 x 8C0A0020) (0 x AD310004)001000 10001 10000 0000 0000 0000 0101Machine Code Assembly Code 8 17 16 Field Values op rs rt imm op rs rt imm addi $s0, $s1, 5 addi $t0, $s3, –12 lw $t2, 32($0) sw $s1, 4($t1) 8 19 8 –12 35 0 10 32 43 9 17001000 10011 01000 1111 1111 1111 0100 100011 00000 01010 0000 0000 0010 0000 101011 01001 10001 0000 0000 0000 0100 6 bits 5 bits 5 bits 16 bits 6 bits 5 bits 5 bits 16 bits45 Figure 6.9 Machine code I-type instructions Example 6.4 TRANSLATING I-TYPE ASSEMBLY INSTRUCTIONS MACHINE CODE Translate following I-type instruction machine code. lw $s3, /H1100224($s4) Solution: According Table 6.1, $s3and $s4are registers 19 20, respectively. Table B.1 indicates lwhas opcode 35. rsspecifies base address, $s4, rtspecifies destination register, $s3. immediate, imm, encodes 16-bit offset, /H1100224. Thus, fields machine code given Figure 6.10.Chapter 06.qxd 1/31/07 8:21 PM Page 301I-type instructions 16-bit immediate field, immediates used 32-bit operations. example, lwadds 16-bit offset 32-bit base register. go upper half 32 bits? positive immediates, upper half 0’s, negative immediates, upper half 1’s. Recall Section 1.4.6 called sign extension . N-bit two’s complement number sign-extended M-bit number ( M/H11022N) copying sign bit (most significant bit) N-bit number upper bits M-bit number. Sign-extending two’s complement number change value. MIPS instructions sign-extend immediate. example, addi ,lw, swdo sign extension support positive nega- tive immediates. exception rule logical operations (andi ,ori,xori ) place 0’s upper half; called zero exten- sion rather sign extension. Logical operations discussed Section 6.4.1. 6.3.3 J-type Instructions name J-type short jump-type . format used jump instructions (see Section 6.4.2). instruction format uses sin- gle 26-bit address operand, addr , shown Figure 6.11. Like formats, J-type instructions begin 6-bit opcode . remaining bits used specify address, addr . discussion machine code examples J-type instructions given Sections 6.4.2 6.5. 6.3.4 Interpreting Machine Language Code interpret machine language, one must decipher fields 32-bit instruction word. Different instructions use different formats, formats start 6-bit opcode field. Thus, best place begin look opcode . 0, instruction R-type; otherwise I-type J-type.302 CHAPTER SIX Architecture 100011 10100 10011 1111 1111 1110 1000op rs rt imm op rs rt imm lw $s3, –24($s4)Machine Code Assembly Code 35 20 19 –24 Field Values (0x8E93FFE8) 8E93 FFE 8 6 bits 16 bits 5 bits 5 bits Figure 6.10 Machine code I-type instruction op addr 6 bits 26 bitsJ-typeFigure 6.11 J-type instruction formatChapter 06.qxd 1/31/07 8:21 PM Page 302Example 6.5 TRANSLATING MACHINE LANGUAGE ASSEMBLY LANGUAGE Translate following machine language code assembly language. 0x2237FFF1 0x02F34022 Solution: First, represent instruction binary look six significant bits find opcode instruction, shown Figure 6.12. opcode determines interpret rest bits. opcodes 001000 2(810) 000000 2(010), indicating addi R-type instruction, respectively. funct field R-type instruction 100010 2(3410), indicat- ing subinstruction. Figure 6.12 shows assembly code equivalent two machine instructions.6.3 Machine Language 303 addi $s7, $s1, –15Machine Code Assembly Code 8 17 23 –15 Field Values (0x2237FFF1)op rs rt imm op rs rt imm 2237 F FF 1 sub $t0, $s7, $s3 0 23 19 8 0 34 (0x02F34022)op 02F 3 4022001000 000000 10111 10011 01000 00000 10001010001 10111 1111 1111 1111 0001 rs rt rd shamt funct op rs rt rd shamt funct Figure 6.12 Machine code assembly code translation 6.3.5 Power Stored Program program written machine language series 32-bit numbers rep- resenting instructions. Like binary numbers, instructions stored memory. called stored program concept, key reason computers powerful. Running different program require large amounts time effort reconfigure rewire hardware; requires writing new program memory. Instead dedicated hardware, stored program offers general purpose computing. way, computer execute applications ranging calculator word processor video player simply chang- ing stored program. Instructions stored program retrieved, fetched , memory executed processor. Even large, complex programs simplified series memory reads instruction executions. Figure 6.13 shows machine instructions stored memory. MIPS programs, instructions normally stored starting address 0x00400000. Remember MIPS memory byte addressable, 32-bit (4-byte) instruction addresses advance 4 bytes, 1.Chapter 06.qxd 1/31/07 8:21 PM Page 303To run execute stored program, processor fetches instructions memory sequentially. fetched instructions decoded executed digital hardware. address current instruction kept 32-bit register called program counter (PC). PCis separate 32 registers shown previously Table 6.1. execute code Figure 6.13, operating system sets PC address 0x00400000. processor reads instruction memory address executes instruction, 0x8C0A0020. proces- sor increments PCby 4, 0x00400004, fetches executes instruction, repeats. architectural state microprocessor holds state pro- gram. MIPS, architectural state consists register file PC. operating system saves architectural state point program, interrupt program, something else, restore state program continues properly, unaware ever interrupted. architectural state also great impor- tance build microprocessor Chapter 7. 6.4 PROGRAMMING Software languages C Java called high-level programming languages, written abstract level assembly language. Many high-level languages use common software constructs arithmetic logical operations, if/else statements, forand loops, array indexing, procedure calls. section, explore translate high-level constructs MIPS assembly code. 6.4.1 Arithmetic/Logical Instructions MIPS architecture defines variety arithmetic logical instructions. introduce instructions briefly here, necessary implement higher-level constructs.304 CHAPTER SIX Architecture Figure 6.13 Stored programaddi $t0, $s3, –12Machine Code Assembly Code lw $t2, 32($0) add $s0, $s1, $s2 sub $t0, $t3, $t50x8C0A0020 0x02328020 0x2268FFF4 0x016D4022Address Instructions 0040000C 016D4022 226 8FFF4 023 28020 8C0 A002000400008 00400004 00400000Stored Program Main MemoryPC Ada Lovelace, 1815–1852. Wrote first computer pro- gram. calculated Bernoulli numbers using Charles Babbage’s Analytical Engine. legitimate child poet Lord Byron. Chapter 06.qxd 1/31/07 8:21 PM Page 304Logical Instructions MIPS logical operations include and, or, xor, nor. R-type instructions operate bit-by-bit two source registers write result destination register. Figure 6.14 shows examples operations two source values 0xFFFF0000 0x46A1F0B7. figure shows values stored destination register, rd, instruction executes. instruction useful masking bits (i.e., forcing unwanted bits 0). example, Figure 6.14, 0xFFFF0000 0x46A1F0B7 /H110050x46A10000. andinstruction masks bot- tom two bytes places unmasked top two bytes $s2, 0x46A1, $s3. subset register bits masked. orinstruction useful combining bits two registers. example, 0x347A0000 0x000072FC /H110050x347A72FC, combi- nation two values. MIPS provide instruction, $0 /H11005NOT A, instruction substitute. Logical operations also operate immediates. I-type instructions andi , ori, xori .nori provided, functionality easily implemented using instruc- tions, explored Exercise 6.11. Figure 6.15 shows examples andi , ori, xori instructions. figure gives values of6.4 Programming 305 1111 1111 1111 1111 0000 0000 0000 0000 $s1 0100 0110 1010 0001 1111 0000 1011 0111 $s2 0100 0110 1010 0001 0000 0000 0000 0000 $s3 1111 1111 1111 1111 1111 0000 1011 0111 $s4 1011 1001 0101 1110 1111 0000 1011 0111 $s5 0000 0000 0000 0000 0000 1111 0100 1000 $s6Source Registers Result Assembly Code $s3, $s1, $s2 $s4, $s1, $s2 xor $s5, $s1, $s2 $s6, $s1, $s2Figure 6.14 Logical operations 0000 0000 0000 0000 0000 0000 1111 1111 $s1 Assembly Code0000 0000 0000 0000 1111 1010 0011 0100 imm 0000 0000 0000 0000 0000 0000 0011 0100 $s2 0000 0000 0000 0000 1111 1010 1111 1111 $s3 0000 0000 0000 0000 1111 1010 1100 1011 $s4andi $s2, $s1, 0xFA34Source Values Result ori $s3, $s1, 0xFA34 xori $s4, $s1, 0xFA34zero-extended Figure 6.15 Logical operations immediatesChapter 06.qxd 1/31/07 8:21 PM Page 305the source register immediate, value destination regis- ter, rt, instruction executes. instructions operate 32-bit value register 16-bit immediate, first zero- extend immediate 32 bits. Shift Instructions Shift instructions shift value register left right 31 bits. Shift operations multiply divide powers two. MIPS shift operations sll(shift left logical), srl(shift right logical), sra (shift right arithmetic). discussed Section 5.2.5, left shifts always fill least signifi- cant bits 0’s. However, right shifts either logical (0’s shift significant bits) arithmetic (the sign bit shifts significant bits). Figure 6.16 shows machine code R-type instructions sll, srl, sra. rt(i.e., $s1) holds 32-bit value shifted, shamt gives amount shift (4). shifted result placed rd. Figure 6.17 shows register values shift instructions sll, srl, sra. Shifting value left Nis equivalent multiplying 2N. Likewise, arithmetically shifting value right Nis equivalent dividing 2N, discussed Section 5.2.5. MIPS also variable-shift instructions: sllv (shift left logical vari- able), srlv (shift right logical variable), srav (shift right arithmetic variable). Figure 6.18 shows machine code instructions.306 CHAPTER SIX Architecture sll $t0, $s1, 4 srl $s2, $s1, 4 sra $s3, $s1, 4000000 00000 10001 01000 00100 000000op rs rt rd shamt funct op rs rt rd shamt functMachine Code Assembly Code 0 0 17 8 4 0Field Values 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits 0 0 17 18 4 2 0 0 17 19 4 3000000 00000 10001 10010 00100 000010 000000 00000 10001 10011 00100 000011(0x00114100) (0x00119102) (0x00119903) Figure 6.16 Shift instruction machine code 1111 0011 0000 0000 0000 0010 1010 1000 $s1 Assembly Code00100 shamt 0011 0000 0000 0000 0010 1010 1000 0000 $t0 0000 1111 0011 0000 0000 0000 0010 1010 $s2 $s3sll $t0, $s1, 4Source Values Result srl $s2, $s1, 4 sra $s3, $s1, 4 1111 1111 0011 0000 0000 0000 0010 1010Figure 6.17 Shift operationsChapter 06.qxd 1/31/07 8:21 PM Page 306rt(i.e., $s1) holds value shifted, five least significant bits rs(i.e., $s2) give amount shift. shifted result placed rd, before. shamt field ignored 0’s. Figure 6.19 shows register values type variable-shift instruction. Generating Constants addi instruction helpful assigning 16-bit constants, shown Code Example 6.10.6.4 Programming 307 sllv $s3, $s1, $s2 srlv $s4, $s1, $s2 srav $s5, $s1, $s2op rs rt rd shamt functMachine CodeAssembly Code Field Values op rs rt rd shamt funct 6 bits 5 bits 5 bits 5 bits 6 bits 6 bits 5 bits 5 bits 5 bits 5 bits 6 bits 5 bits (0x02519804) (0x0251A006) (0x0251A807)4 0 19 17 18 0 6 0 20 17 18 0 7 0 21 17 18 0000000 10010 10001 10011 00000 000100 000000 10010 10001 10100 00000 000110 000000 10010 10001 10101 00000 000111 Figure 6.18 Variable-shift instruction machine code $s1 0000 0000 $s3 0000 0000 $s4 1111 1111 $s5Assembly Code sllv $s3, $s1, $s2 srlv $s4, $s1, $s2 srav $s5, $s1, $s2Source Values Result$s21111 0011 0000 0100 0000 0010 1010 1000 0000 0000 0000 0000 0000 0000 0000 1000 0000 0100 0000 00101010 1000 1111 0011 0000 0100 0000 0010 1111 0011 0000 0100 0000 0010Figure 6.19 Variable-shift operations High-Level Code int /H110050x4f3c;MIPS Assembly code # $s0 /H11005a addi $s0, $0, 0x4f3c # /H110050x4f3cCode Example 6.10 16-BIT CONSTANT High-Level Code int /H110050x6d5e4f3c;MIPS Assembly Code # $s0 /H11005a lui $s0, 0x6d5e # /H110050x6d5e0000 ori $s0, $s0, 0x4f3c # /H110050x6d5e4f3cCode Example 6.11 32-BIT CONSTANTChapter 06.qxd 1/31/07 8:21 PM Page 307To assign 32-bit constants, use load upper immediate instruction (lui) followed immediate ( ori) instruction, shown Code Example 6.11. luiloads 16-bit immediate upper half reg- ister sets lower half 0. mentioned earlier, orimerges 16- bit immediate lower half. Multiplication Division Instructions* Multiplication division somewhat different arith- metic operations. Multiplying two 32-bit numbers produces 64-bit product. Dividing two 32-bit numbers produces 32-bit quotient 32-bit remainder. MIPS architecture two special-purpose registers, hiand lo, used hold results multiplication division. mult $s0, $s1 multiplies values $s0and $s1. 32 significant bits placed hiand 32 least significant bits placed lo. Similarly, div $s0, $s1 computes $s0/$s1 . quotient placed loand remainder placed hi. 6.4.2 Branching advantage computer calculator ability make deci- sions. computer performs different tasks depending input. example, if/else statements, case statements, loops, loops conditionally execute code depending test. sequentially execute instructions, program counter incre- ments 4 instruction. Branch instructions modify pro- gram counter skip sections code go back repeat previous code. Conditional branch instructions perform test branch test TRUE. Unconditional branch instructions, called jumps , always branch. Conditional Branches MIPS instruction set two conditional branch instructions: branch equal (beq) branch equal ( bne). beqbranches val- ues two registers equal, bnebranches equal. Code Example 6.12 illustrates use beq. Note branches written beq $rs , $rt, imm, $rsis first source register. order reversed I-type instructions. program Code Example 6.12 reaches branch equal instruction ( beq), value $s0is equal value $s1, branch taken . is, next instruction executed add instruction label called target . two instructions directly branch label executed. Assembly code uses labels indicate instruction locations program. assembly code translated machine code, these308 CHAPTER SIX Architecture intdata type C refers word data representing two’s complement integer. MIPS uses 32-bit words, intrepresents number range [ /H11002231, 231/H110021]. hiand loare among usual 32 MIPS registers, special instructions needed access them. mfhi $s2 (move hi) copies value hi $s2. mflo $s3 (move lo) copies value loto $s3. hiand loare technically part architectural state; however, generally ignore registers book.Chapter 06.qxd 1/31/07 8:21 PM Page 3086.4 Programming 309 MIPS Assembly Code addi $s0, $0, 4 # $s0 /H110050 /H110014 /H110054 addi $s1, $0, 1 # $s1 /H110050 /H110011 /H110051 sll $s1, $s1, 2 # $s1 /H110051 /H11021/H110212 /H110054 beq $s0, $s1, target # $s0 /H11005/H11005$s1, branch taken addi $s1, $s1, 1 # executed sub $s1, $s1, $s0 # executed target: add $s1, $s1, $s0 # $s1 /H110054 /H110014 /H110058Code Example 6.12 CONDITIONAL BRANCHING USING beq MIPS Assembly Code addi $s0, $0, 4 # $s0 /H110050 /H110014 /H110054 addi $s1, $0, 1 # $s1 /H110050 /H110011 /H110051 s11 $s1, $s1, 2 # $s1 /H110051 /H11021/H110212 /H110054 bne $s0, $s1, target # $s0 /H11005/H11005$s1, branch taken addi $s1, $s1, 1 # $s1 /H110054 /H110011 /H110055 sub $s1, $s1, $s0 # $s1 /H110055 /H110024 /H110051 target: add $s1, $s1, $s0 # $s1 /H110051 /H110014 /H110055Code Example 6.13 CONDITIONAL BRANCHING USING bnelabels translated instruction addresses (see Section 6.5). MIPS assembly labels followed ( :) cannot use reserved words, instruction mnemonics. programmers indent instruc- tions labels, help make labels stand out. Code Example 6.13 shows example using branch equal instruction ( bne). case, branch taken $s0is equal $s1, code continues execute directly bne instruction. instructions code snippet executed. Jump program unconditionally branch, jump , using three types jump instructions: jump ( j), jump link ( jal), jump register ( jr). Jump (j) jumps directly instruction specified label. Jump link ( jal) similar jbut used procedures save return address, discussed Section 6.4.6. Jump register ( jr) jumps address held register. Code Example 6.14 shows use jump instruction ( j). jtarget instruction, program Code Example 6.14 un- conditionally continues executing addinstruction label target . instructions jump label skipped.jand jalare J-type instruc- tions. jris R-type instruc- tion uses rs operand.Chapter 06.qxd 1/31/07 8:21 PM Page 309310 CHAPTER SIX Architecture MIPS Assembly Code addi $s0, $0, 4 # $s0 /H110054 addi $s1, $0, 1 # $s1 /H110051 j target # jump target addi $s1, $s1, 1 # executed sub $s1, $s1, $s0 # executed target: add $s1, $s1, $s0 # $s1 /H110051 /H110014 /H110055Code Example 6.14 UNCONDITIONAL BRANCHING USING j MIPS Assembly Code 0x00002000 addi $s0, $0, 0x2010 # $s0 /H110050x2010 0x00002004 jr $s0 # jump 0x00002010 0x00002008 addi $s1, $0, 1 # executed 0x0000200c sra $s1, $s1, 2 # executed 0x00002010 lw $s3, 44 ($s1) # executed jr instructionCode Example 6.15 UNCONDITIONAL BRANCHING USING jr Code Example 6.15 shows use jump register instruction (jr). Instruction addresses given left instruction. jr $s0jumps address held $s0, 0x00002010. 6.4.3 Conditional Statements ifstatements, if/else statements, case statements conditional statements commonly used high-level languages. condi- tionally execute block code consisting one instructions. section shows translate high-level constructs MIPS assembly language. Statements ifstatement executes block code, block , condition met. Code Example 6.16 shows translate statement MIPS assembly code. High-Level Code (i /H11005/H11005j) f /H11005g /H11001h; f /H11005f /H11002i;MIPS Assembly Code # $s0 /H11005f, $s1 /H11005g, $s2 /H11005h, $s3 /H11005i, $s4 /H11005j bne $s3, $s4, L1 # ! /H11005j, skip block add $s0, $s1, $s2 # block: f /H11005g /H11001h L1: sub $s0, $s0, $s3 # f /H11005f /H11002iCode Example 6.16 ifSTATEMENTChapter 06.qxd 1/31/07 8:21 PM Page 310The assembly code ifstatement tests opposite condi- tion one high-level code. Code Example 6.16, high-level code tests i/H11005/H11005j, assembly code tests i!/H11005j. bneinstruction branches (skips ifblock) i!/H11005 j. Otherwise, i/H11005/H11005j, branch taken, ifblock executed desired. If/Else Statements if/else statements execute one two blocks code depending condition. condition ifstatement met, block executed. Otherwise, else block executed. Code Example 6.17 shows example if/else statement. Like ifstatements, if/else assembly code tests opposite condi- tion one high-level code. example, Code Example 6.17, high-level code tests i/H11005/H11005j. assembly code tests oppo- site condition ( i!/H11005j). opposite condition TRUE, bneskips ifblock executes else block. Otherwise, ifblock executes finishes jump instruction ( j) jump past else block.6.4 Programming 311 High-Level Code (i /H11005/H11005j) f /H11005g /H11001h; else f /H11005f /H11002i;MIPS Assembly Code # $s0 /H11005f, $s1 /H11005g, $s2 /H11005h, $s3 /H11005i, $s4 /H11005j bne $s3, $s4, else # ! /H11005j, branch else add $s0, $s1, $s2 # block: f /H11005g /H11001h j L2 # skip past else block else: sub $s0, $s0, $s3 # else block: f /H11005f /H11002i L2:Code Example 6.17 if/else STATEMENT Switch/Case Statements* switch/case statements execute one several blocks code depending conditions. conditions met, default block executed. Acase statement equivalent series nestedif/else statements. Code Example 6.18 shows two high-level code snippets functionality: calculate fee ATM (automatic teller machine ) withdrawal $20, $50, $100, defined amount . MIPS assem- bly implementation high-level code snippets. 6.4.4 Getting Loopy Loops repeatedly execute block code depending condition. forloops loops common loop constructs used high- level languages. section shows translate MIPS assembly language.Chapter 06.qxd 1/31/07 8:21 PM Page 311312 CHAPTER SIX Architecture High-Level Code switch (amount) { case 20: fee /H110052; break; case 50: fee /H110053; break; case 100: fee /H110055; break; default: fee /H110050; } // equivalent function using if/else statements (amount /H11005/H1100520) fee /H110052; else (amount /H11005/H1100550) fee /H110053; else (amount /H11005/H11005100) fee /H110055; else fee /H110050;MIPS Assembly Code # $s0 /H11005amount, $s1 /H11005fee case20: addi $t0, $0, 20 # $t0 /H1100520 bne $s0, $t0, case50 # /H11005/H1100520? not, # skip case50 addi $s1, $0, 2 # so, fee /H110052 j done # break case case50: addi $t0, $0, 50 # $t0 /H1100550 bne $s0, $t0, case100 # /H11005/H1100550? not, # skip case100 addi $s1, $0, 3 # so, fee /H110053 j done # break case case100: addi $t0, $0, 100 # $t0 /H11005100 bne $s0, $t0, default # /H11005/H11005100? not, # skip default addi $s1, $0, 5 # so, fee /H110055 j done # break case default: add $s1, $0, $0 # charge /H110050 done:Code Example 6.18 switch/case STATEMENT Loops loops repeatedly execute block code condition met. loop Code Example 6.19 determines value x 2x/H11005128. executes seven times, pow/H11005128. Like if/else statements, assembly code loops tests opposite condition one given high-level code. opposite condition TRUE, loop finished. High-Level Code int pow /H110051; int x /H110050; (pow ! /H11005128) { pow /H11005pow * 2; x /H11005x /H110011; }MIPS Assembly Code # $s0 /H11005pow, $s1 /H11005x addi $s0, $0, 1 # pow /H110051 addi $s1, $0, 0 # x /H110050 addi $t0, $0, 128 # t0 /H11005128 comparison while: beq $s0, $t0, done # pow /H11005/H11005128, exit sll $s0, $s0, 1 # pow /H11005pow * 2 addi $s1, $s1, 1 # x /H11005x /H110011 j done:Code Example 6.19 LOOPChapter 06.qxd 1/31/07 8:21 PM Page 312In Code Example 6.19, loop compares powto 128 exits loop equal. Otherwise doubles pow(using left shift), increments x, jumps back start loop. Loops forloops, like loops, repeatedly execute block code condition notmet. However, forloops add support loop vari- able, typically keeps track number loop executions. general format forloop (initialization; condition; loop operation) initialization code executes forloop begins. condition tested beginning loop. condition met, loop exits. loop operation executes end loop. Code Example 6.20 adds numbers 0 9. loop variable, i, initialized 0 incremented end loop iteration. beginning iteration, forloop executes iis equal 10. Otherwise, loop finished. case, forloop executes 10 times. forloops implemented using awhile loop, forloop often convenient. Magnitude Comparison far, examples used beq bne perform equality inequality comparisons branches. MIPS provides set less instruction, slt, magnitude comparison. sltsets rdto 1 rs/H11021 rt. Otherwise, rdis 0.6.4 Programming 313 High-Level Code int sum /H110050; (i /H110050; ! /H1100510; /H11005i /H110011) { sum /H11005sum /H11001i; } // equivalent following loop int sum /H110050; int /H110050; (i ! /H1100510) { sum /H11005sum /H11001i; /H11005i /H110011; }MIPS Assembly Code # $s0 /H11005i, $s1 /H11005sum add $s1, $0, $0 # sum /H110050 addi $s0, $0, 0 # /H110050 addi $t0, $0, 10 # $t0 /H1100510 for: beq $s0, $t0, done # /H11005/H1100510, branch done add $s1, $s1, $s0 # sum /H11005sum /H11001i addi $s0, $s0, 1 # increment j done:Code Example 6.20 forLOOPChapter 06.qxd 1/31/07 8:21 PM Page 313Example 6.6 LOOPS USING slt following high-level code adds powers 2 1 100. Translate assembly language. // high-level code int sum /H110050; (i /H110051; /H11021101; /H11005i * 2) sum /H11005sum /H11001i; Solution: assembly language code uses set less ( slt) instruction perform less comparison forloop. # MIPS assembly code # $s0 /H11005i, $s1 /H11005sum addi $s1, $0, 0 # sum /H110050 addi $s0, $0, 1 # /H110051 addi $t0, $0, 101 # $t0 /H11005101 loop: slt $t1, $s0, $t0 # (i /H11021101) $t1 /H110051, else $t1 /H110050 beq $t1, $0, done # $t1 /H11005/H110050 (i /H11022/H11005101), branch done add $s1, $s1, $s0 # sum /H11005sum /H11001i sll $s0, $s0, 1 # /H11005i * 2 j loop done : Exercise 6.12 explores use sltfor magnitude compar- isons including greater than, greater equal, less equal. 6.4.5 Arrays Arrays useful accessing large amounts similar data. array organized sequential data addresses memory. array element identified number called index . number elements array called sizeof array. section shows access array elements memory. Array Indexing Figure 6.20 shows array five integers stored memory. index ranges 0 4. case, array stored processor’s main memory starting base address 0x10007000. base address gives address first array element, array[0] . Code Example 6.21 multiplies first two elements array 8 stores back array. first step accessing array element load base address array register. Code Example 6.21 loads base address314 CHAPTER SIX ArchitectureChapter 06.qxd 1/31/07 8:21 PM Page 314into $s0. Recall load upper immediate ( lui) immediate (ori) instructions used load 32-bit constant register. Code Example 6.21 also illustrates lwtakes base address offset. base address points start array. offset used access subsequent elements array. example, array[1] stored memory address 0x10007004 (one word four bytes array[0]) , accessed offset 4 past base address. might noticed code manipulating two array elements Code Example 6.21 essentially except index. Duplicating code problem accessing two array elements, would become terribly inefficient accessing elements large array. Code Example 6.22 uses forloop multiply 8 elements 1000-element array stored base address 0x23B8F000. Figure 6.21 shows 1000-element array memory. index array variable ( i) rather constant, cannot take advantage immediate offset lw. Instead, compute address ith element store $t0. Remember array element word memory byte addressed, offset from6.4 Programming 315 array[4] array[3] array[2] array[1] array[0] 0x100070000x100070040x100070080x1000700C0x10007010 Main MemoryAddress Data Figure 6.20 Five-entry array base address 0x10007000 High-Level Code int array [5]; array[0] /H11005array[0] * 8; array[1] /H11005array[1] * 8;MIPS Assembly Code # $s0 /H11005base address array lui $s0, 0x1000 # $s0 /H110050x10000000 ori $s0, $s0, 0x7000 # $s0 /H110050x10007000 lw $t1, 0($s0) # $t1 /H11005array[0] sll $t1, $t1, 3 # $t1 /H11005$t1 /H11021/H110213 /H11005$t1 * 8 sw $t1, 0($s0) # array[0] /H11005$t1 lw $t1, 4($s0) # $t1 /H11005array[1] sll $t1, $t1, 3 # $t1 /H11005$t1 /H11021/H110213 /H11005$t1 * 8 sw $t1, 4($s0) # array[1] /H11005$t1Code Example 6.21 ACCESSING ARRA YSChapter 06.qxd 1/31/07 8:21 PM Page 315the base address i*4. Shifting left 2 convenient way multi- ply 4 MIPS assembly language. example readily extends array size. Bytes Characters Numbers range [ /H11002128, 127] stored single byte rather entire word. much fewer 256 characters English language keyboard, English characters often represented bytes. C language uses type char represent byte character. Early computers lacked standard mapping bytes English characters, exchanging text computers difficult. 1963, American Standards Association published American Standard Code Information Interchange (ASCII ), assigns text character unique byte value. Table 6.2 shows character encodings printable characters. ASCII values given hexa- decimal. Lower-case upper-case letters differ 0x20 (32).316 CHAPTER SIX Architecture High-Level Code int i; int array[1000]; (i /H110050; /H110211000; /H11005i /H110011) { array[i] /H11005array[i] * 8; }MIPS Assembly Code # $s0 /H11005array base address, $s1 /H11005i # initialization code lui $s0, 0x23B8 # $s0 /H110050x23B80000 ori $s0, $s0, 0xF000 # $s0 /H110050x23B8F000 addi $s1, $0 # /H110050 addi $t2, $0, 1000 # $t2 /H110051000 loop: slt $t0, $s1, $t2 # /H110211000? beq $t0, $0, done # done sll $t0, $s1, 2 # $t0 /H11005i * 4 (byte offset) add $t0, $t0, $s0 # address array[i] lw $t1, 0($t0) # $t1 /H11005array[i] sll $t1, $t1, 3 # $t1 /H11005array[i] * 8 sw $t1, 0($t0) # array[i] /H11005array[i] * 8 addi $s1, $s1, 1 # /H11005i /H110011 j loop # repeat done:Code Example 6.22 ACCESSING ARRA YS USING forLOOP Figure 6.21 Memory holding array[1000] starting base address 0x23B8F000 program languages, Java, use different character encodings, notably Unicode . Unicode uses 16 bits represent character, supports accents, umlauts, Asian languages. informa- tion, see www.unicode.org.23B8FF9C array[999] 23B8FF98 23B8F004 23B8F000array[998] array[1] array[0] Main MemoryAddress DataChapter 06.qxd 1/31/07 8:21 PM Page 316MIPS provides load byte store byte instructions manipulate bytes characters data: load byte unsigned ( lbu), load byte ( lb), store byte ( sb). three illustrated Figure 6.22.6.4 Programming 317 ASCII codes developed earlier forms character encoding. Beginning 1838, telegraph machines used Morse code, series dots (.) dashes ( /H11002), represent characters. example, letters A, B, C, represented . /H11002, /H11002..., /H11002./H11002., /H11002.., respectively. number dots dashes varied letter. efficiency, common letters used shorter codes. 1874, Jean-Maurice- Emile Baudot invented 5-bit code called Baudot code. example, A, B, C, D, represented 00011, 11001, 01110, 01001. However, 32 possible encodings 5-bit code sufficient English characters. 8-bit encoding was. Thus, elec- tronic communication became prevalent, 8-bit ASCII encod- ing emerged standard.Table 6.2 ASCII encodings # Char # Char # Char # Char # Char # Char 20space 300 40@ 50P 60 ′ 70p 21! 311 41A 51Q 61a 71q 22 ″ 322 42B 52R 62b 72r 23# 333 43C 53S 63c 73s 24$ 344 44D 54T 64d 74t 25% 355 45E 55U 65e 75u 26& 366 46F 56V 66f 76v 27 ′ 377 47G 57W 67g 77w 28( 388 48H 58X 68h 78x 29) 399 49I 59Y 69i 79y 2A* 3A: 4AJ 5AZ 6Aj 7Az 2B /H11001 3B; 4BK 5B[ 6Bk 7B{ 2C , 3C /H11021 4CL 5C\ 6Cl 7C| 2D– 3D /H11005 4DM 5D] 6Dm 7D} 2E. 3E /H11022 4EN 5E/H116256En 7E~ 2F/ 3F? 4FO 5F_ 6Fo Byte Address 03428CF7 Data3210 $s1 00 8Clbu $s1, 2($0)Little-Endian Memory 0000Registers $s2 FF 8Clb $s2, 2($0) FFFF $s3 9Bsb $s3, 3($0) XX XX XXFigure 6.22 Instructions loading storing bytesChapter 06.qxd 1/31/07 8:21 PM Page 317Load byte unsigned ( lbu) zero-extends byte, load byte ( lb) sign-extends byte fill entire 32-bit register. Store byte ( sb) stores least significant byte 32-bit register specified byte address memory. Figure 6.22, lbuloads byte memory address 2 least significant byte $s1and fills remaining register bits 0. lbloads sign-extended byte memory address 2 $s2. sb stores least significant byte $s3into memory byte 3; replaces 0xF7 0x9B. significant bytes $s3 ignored. Example 6.7 USING lbAND sbTO ACCESS CHARACTER ARRA following high-level code converts ten-entry array characters lower-case upper-case subtracting 32 array entry. Translate MIPS assembly language. Remember address difference array elements 1 byte, 4 bytes. Assume $s0already holds base address chararray . // high-level code char chararray[10]; int i; (i /H110050; ! /H1100510; /H11005i /H110011) chararray[i] /H11005chararray[i] /H1100232; Solution: # MIPS assembly code # $s0 /H11005base address chararray, $s1 /H11005i addi $s1, $0, 0 #i /H110050 addi $t0, $0, 10 #$t0 /H1100510 loop: beq $t0, $s1, done #if /H11005/H1100510, exit loop add $t1, $s1, $s0 #$t1 /H11005address chararray[i] lb $t2, 0($t1) #$t2 /H11005array[i] addi $t2, $t2, /H1100232 #converttouppercase:$t1 /H11005$t1 /H1100232 sb $t2, 0($t1) #store new value array: #chararray[i] /H11005$t1 addi $s1, $s1, 1 #i /H11005i/H110011 j loop #repeat done: series characters called string . Strings variable length, programming languages must provide way determine length end string. C, null character (0x00) signifies end string. example, Figure 6.23 shows string “Hello!” (0x48 65 6C 6C 6F 21 00) stored memory. string seven bytes long extends address 0x1522FFF0 0x1522FFF6. first character string (H /H110050x48) stored lowest byte address (0x1522FFF0).318 CHAPTER SIX Architecture Figure 6.23 string “Hello!” stored memoryWord Address 1522FFF4 1522FFF0Data 48 65 6C 6C6F 21 00 Little-Endian MemoryByte 3 Byte 0 Chapter 06.qxd 1/31/07 8:21 PM Page 3186.4.6 Procedure Calls High-level languages often use procedures (also called functions ) reuse frequently accessed code make program readable. Procedures inputs, called arguments , output, called return value . Procedures calculate return value cause unintended side effects. one procedure calls another, calling procedure, caller , called procedure, callee , must agree put arguments return value. MIPS, caller conventionally places four arguments registers $a0–$a3 making pro- cedure call, callee places return value registers $v0–$v1 finishing. following convention, procedures know find arguments return value, even caller callee written different people. callee must interfere function caller. Briefly, means callee must know return completes must trample registers memory needed caller. caller stores return address $raat time jumps callee using jump link instruction ( jal). callee must over- write architectural state memory caller depending on. Specifically, callee must leave saved registers, $s0–$s7 , $ra, stack , portion memory used temporary variables, unmodified. section shows call return procedure. shows procedures access input arguments return value use stack store temporary variables. Procedure Calls Returns MIPS uses jump link instruction ( jal) call procedure jump register instruction ( jr) return procedure. Code Example 6.23 shows main procedure calling simple procedure. main caller, simple callee. simple procedure called input arguments generates return value; simply returns caller. Code Example 6.23, instruction addresses given left MIPS instruction hexadecimal.6.4 Programming 319 High-Level Code MIPS Assembly Code int main() { simple(); 0x00400200 main: jal simple # call procedure ... 0x00400204 ... } // void means function returns value void simple() { return; 0x00401020 simple: jr $ra # return }Code Example 6.23 simple PROCEDURE CALLChapter 06.qxd 1/31/07 8:21 PM Page 319Jump link ( jal) jump register ( jr $ra ) two essential instructions needed procedure call. jalperforms two functions: stores address next instruction (the instruction jal) return address register ( $ra), jumps target instruction. Code Example 6.23, main procedure calls simple proce- dure executing jump link ( jal) instruction. jaljumps simple label stores 0x00400204 $ra. simple procedure returns immediately executing instruction jr $ra , jumping instruction address held $ra. main procedure continues exe- cuting address, 0x00400204. Input Arguments Return Values simple procedure Code Example 6.23 useful, receives input calling procedure ( main) returns out- put. MIPS convention, procedures use $a0–$a3 input arguments $v0–$v1 return value. Code Example 6.24, procedure diffofsums called four arguments returns one result. According MIPS convention, calling procedure, main , places procedure arguments, left right, input registers, $a0–$a3 . called procedure, diffofsums , stores return value return register, $v0. procedure returns 64-bit value, double-precision floating point number, uses return registers, $v0and $v1. procedure four arguments called, additional input arguments placed stack, discuss next.320 CHAPTER SIX Architecture High-Level Code MIPS Assembly Code # $s0 /H11005y int main () main: { ... int y; addi $a0, $0, 2 # argument 0 /H110052 addi $a1, $0, 3 # argument 1 /H110053 ... addi $a2, $0, 4 # argument 2 /H110054 addi $a3, $0, 5 # argument 3 /H110055 /H11005diffofsums (2, 3, 4, 5); jal diffofsums # call procedure add $s0, $v0, $0 # /H11005returned value ... ... } # $s0 /H11005result int diffofsums (int f, int g, int h, int i) diffofsums: { add $t0, $a0, $a1 # $t0 /H11005f /H11001g int result; add $t1, $a2, $a3 # $t1 /H11005h /H11001i sub $s0, $t0, $t1 # result /H11005(f /H11001g) /H11002(h /H11001i) result /H11005(f /H11001g) /H11002(h /H11001i); add $v0, $s0, $0 # put return value $v0 return result; jr $ra # return caller }Code Example 6.24 PROCEDURE CALL ARGUMENTS RETURN VALUESCode Example 6.24 subtle errors. Code Examples 6.25 6.26 page 323 show improved versions program.Chapter 06.qxd 1/31/07 8:21 PM Page 3206.4 Programming 321 Stack stack memory used save local variables within procedure. stack expands (uses memory) processor needs scratch space contracts (uses less memory) processor longer needs variables stored there. explaining procedures use stack store temporary variables, explain stack works. stack last-in-first-out (LIFO ) queue . Like stack dishes, last item pushed onto stack (the top dish) first one pulled ( popped ) off. procedure may allocate stack space store local variables must deallocate returning. top stack , recently allocated space. Whereas stack dishes grows space, MIPS stack grows memory. stack expands lower memory addresses program needs scratch space. Figure 6.24 shows picture stack. stack pointer , $sp, special MIPS register points top stack. pointer fancy name memory address. points (gives address of) data. example, Figure 6.24(a) stack pointer, $sp, holds address value 0x7FFFFFFC points data value 0x12345678. $sppoints top stack, lowest accessible memory address stack. Thus, Figure 6.24(a), stack cannot access memory memory word 0x7FFFFFFC. stack pointer ( $sp) starts high memory address decre- ments expand needed. Figure 6.24(b) shows stack expanding allow two data words temporary storage. so, $spdecre- ments 8 become 0x7FFFFFF4. Two additional data words, 0xAABBCCDD 0x11223344, temporarily stored stack. One important uses stack save restore registers used procedure. Recall procedure calculate return value unintended side effects. particular, modify registers besides one containing return value, $v0. diffofsums procedure Code Example 6.24 violates rule modifies $t0,$t1, $s0. main using $t0,$t1, $s0before call diffofsums , contents registers would corrupted procedure call. solve problem, procedure saves registers stack modifies them, restores stack returns. Specifically, performs following steps. 1. Makes space stack store values one registers. 2. Stores values registers stack. 3. Executes procedure using registers. 4. Restores original values registers stack. 5. Deallocates space stack. Data 7FFFFFFC 12345678 7FFFFFF8 7FFFFFF4 7FFFFFF0Address $sp (a) 7FFFFFFC 7FFFFFF8 7FFFFFF4 7FFFFFF0Address (b)Data 12345678 $spAABB CCDD 11223344 Figure 6.24 stackChapter 06.qxd 1/31/07 8:21 PM Page 321Code Example 6.25 shows improved version diffofsums saves restores $t0,$t1, $s0. new lines indicated blue. Figure 6.25 shows stack before, during, call diffofsums procedure Code Example 6.25. diffofsums makes room three words stack decrementing stack pointer ($sp) 12. stores current values $s0,$t0, $t1in newly allocated space. executes rest procedure, chang- ing values three registers. end procedure, diffofsums restores values $s0,$t0, $t1from stack, deallocates stack space, returns. procedure returns, $v0holds result, side effects: $s0,$t0,$t1, $sphave values procedure call. stack space procedure allocates called stack frame . diffofsums ’s stack frame three words deep. principle modularity tells us procedure access stack frame, frames belonging procedures. Preserved Registers Code Example 6.25 assumes temporary registers $t0and $t1must saved restored. calling procedure use regis- ters, effort save restore wasted. avoid waste, MIPS divides registers preserved nonpreserved categories. preserved registers include $s0–$s7 (hence name, saved ). nonpreserved registers include $t0–$t9 (hence name, temporary ). procedure must save restore preserved registers wishes use, change nonpreserved registers freely. Code Example 6.26 shows improved version diffofsums saves $s0on stack. $t0and $t1are nonpreserved registers, need saved. Remember one procedure calls another, former caller latter callee . callee must save restore preserved registers wishes use. callee may change nonpreserved registers. Hence, caller holding active data a322 CHAPTER SIX Architecture Data FC F8 F4 F0Address $sp (a)?Data $sp (c)FC F8 F4 F0Address ?Data FC F8 F4 F0Address $sp (b)$s0 $t0?stack frame $t1Figure 6.25 stack (a) before, (b) during, (c) diffofsums procedure callChapter 06.qxd 1/31/07 8:21 PM Page 322nonpreserved register, caller needs save nonpreserved register making procedure call needs restore afterward. reasons, preserved registers also called callee-save , nonpreserved registers called caller-save . Table 6.3 summarizes registers preserved. $s0–$s7 generally used hold local variables within procedure, must saved. $ramust also saved, procedure knows return. $t0–$t9 used hold temporary results assigned local variables. calculations typically complete procedure call made, preserved, rare caller needs save them. $a0–$a3 often overwritten process calling procedure. Hence, must saved caller caller depends arguments called proce- dure returns. $v0–$v1 certainly preserved, callee returns result registers.6.4 Programming 323 MIPS Assembly Code # $s0 /H11005result diffofsums: addi $sp, $sp, /H1100212 # make space stack store three registers sw $s0, 8($sp) # save $s0 stack sw $t0, 4($sp) # save $t0 stack sw $t1, 0($sp) # save $t1 stack add $t0, $a0, $a1 # $t0 /H11005f /H11001g add $t1, $a2, $a3 # $t1 /H11005h /H11001i sub $s0, $t0, $t1 # result /H11005(f /H11001g) /H11002(h /H11001i) add $v0, $s0, $0 # put return value $v0 lw $t1, 0($sp) # restore $t1 stack lw $t0, 4($sp) # restore $t0 stack lw $s0, 8($sp) # restore $s0 stack addi $sp, $sp, 12 # deallocate stack space jr $ra # return callerCode Example 6.25 PROCEDURE SA VING REGISTERS STACK MIPS Assembly Code # $s0 /H11005result diffofsums: addi $sp, $sp, /H110024 # make space stack store one register sw $s0, 0($sp) # save $s0 stack add $t0, $a0, $a1 # $t0 /H11005f /H11001g add $t1, $a2, $a3 # $t1 /H11005h /H11001i sub $s0, $t0, $t1 # result /H11005(f /H11001g) /H11002(h /H11001i) add $v0, $s0, $0 # put return value $v0 lw $s0, 0($sp) # restore $s0 stack addi $sp, $sp, 4 # deallocate stack space jr $ra # return callerCode Example 6.26 PROCEDURE SA VING PRESERVED REGISTERS STACKChapter 06.qxd 1/31/07 8:21 PM Page 323324 CHAPTER SIX Architecture stack stack pointer automatically preserved long callee write memory addresses $sp. way, modify stack frame procedures. stack pointer preserved, callee deallocates stack frame returning adding back amount subtracted $spat beginning procedure. Recursive Procedure Calls procedure call others called leafprocedure; example diffofsums . procedure call others called nonleaf procedure. mentioned earlier, nonleaf procedures some- complicated may need save nonpreserved registers stack call another procedure, restore registers afterward. Specifically, caller saves non- preserved registers ( $t0–$t9 $a0–$a3 ) needed call. callee saves preserved registers ( $s0–$s7 $ra) intends modify. recursive procedure nonleaf procedure calls itself. fac- torial function written recursive procedure call. Recall factorial (n) /H11005n/H11003(n/H110021) /H11003(n/H110022) /H11003... /H110032 /H110031. factorial func- tion rewritten recursively factorial (n) /H11005n/H11003factorial (n/H110021). factorial 1 simply 1. Code Example 6.27 shows factorial function written recursive procedure. conveniently refer pro- gram addresses, assume program starts address 0x90. factorial procedure might modify $a0and $ra, saves stack. checks whether n/H110212. so, puts return value 1 $v0, restores stack pointer, returns caller. reload $raand $a0in case, never modified. n/H110221, procedure recursively calls factorial(n /H110021). restores value n($a0) return address ( $ra) stack, performs multiplication, returns result. multiply instruction ( mul $v0, $a0, $v0 ) multiplies $a0and $v0and places result $v0. discussed Section 6.7.1.Table 6.3 Preserved nonpreserved registers Preserved Nonpreserved Saved registers: $s0–$s7 Temporary registers: $t0–$t9 Return address: $ra Argument registers: $a0–$a3 Stack pointer: $sp Return value registers: $v0–$v1 Stack stack pointer Stack stack pointerChapter 06.qxd 1/31/07 8:21 PM Page 3246.4 Programming 325 High-Level Code int factorial (int n) { (n /H11021/H110051) return 1; else return (n * factorial (n /H110021)); }MIPS Assembly Code 0x90factorial: addi $sp, $sp, /H110028 # make room stack 0x94 sw $a0, 4($sp) # store $a0 0x98 sw $ra, 0($sp) # store $ra 0x9C addi $t0, $0, 2 # $t0 /H110052 0xA0 slt $t0, $a0, $t0 # /H11021/H110051 ? 0xA4 beq $t0, $0, else # no: goto else 0xA8 addi $v0, $0, 1 # yes: return 1 0xAC addi $sp, $sp, 8 # restore $sp 0xB0 jr $ra # return 0xB4 else: addi $a0, $a0, /H110021# n /H11005n /H110021 0xB8 jal factorial # recursive call 0xBC lw $ra, 0($sp) # restore $ra 0xC0 lw $a0, 4($sp) # restore $a0 0xC4 addi $sp, $sp, 8 # restore $sp 0xC8 mul $v0, $a0, $v0 # n * factorial (n /H110021) 0xCC jr $ra # returnCode Example 6.27 factorial RECURSIVE PROCEDURE CALL Figure 6.26 shows stack executing factorial(3) . assume $sp initially points 0xFC, shown Figure 6.26(a). procedure creates two-word stack frame hold $a0and $ra. first invocation, factorial saves $a0(holding n/H110053) 0xF8 $raat 0xF4, shown Figure 6.26(b). procedure changes $a0 n/H110052 recursively calls factorial(2) , making $ra hold 0xBC. second invocation, saves $a0(holding n/H110052) 0xF0 $raat 0xEC. time, know $racontains 0xBC. pro- cedure changes $a0to n/H110051 recursively calls factorial(1) . third invocation, saves $a0(holding n/H110051) 0xE8 $raat 0xE4. time, $ra contains 0xBC. third invocation Figure 6.26 Stack factorial procedure call n/H115493: (a) call, (b) last recursive call, (c) return$sp (a)FC F8 F4 F0 EC E8 E4 E0 DCData Address FC F8 F4 F0 (b)$ra EC E8 E4 E0 DC$sp$sp$sp$spData Address $a0 (0x3) $ra (0xBC)$a0 (0x2) $ra (0xBC)$a0 (0x1)FC F8 F4 F0 (c)EC E8 E4 E0 DC$sp$sp$sp$sp $a0 = 1 $v0 = 1 x 1$a0 = 2 $v0 = 2 x 1$a0 = 3 $v0 = 3 x 2$v0 = 6Data Address $ra$a0 (0x3) $ra (0xBC)$a0 (0x2) $ra (0xBC)$a0 (0x1)Chapter 06.qxd 1/31/07 8:21 PM Page 325factorial returns value 1 $v0and deallocates stack frame returning second invocation. second invocation restores nto 2, restores $rato 0xBC (it happened already value), deallocates stack frame, returns $v0 /H110052 /H110031 /H110052 first invocation. first invocation restores nto 3, restores $rato return address caller, deallocates stack frame, returns $v0 /H110053 /H110032 /H110056. Figure 6.26(c) shows stack recursively called procedures return. factorial returns caller, stack pointer original position (0xFC), none contents stack pointer changed, preserved regis- ters hold original values. $v0holds return value, 6. Additional Arguments Local Variables* Procedures may four input arguments local vari- ables. stack used store temporary values. MIPS con- vention, procedure four arguments, first four passed argument registers usual. Additional arguments passed stack, $sp. caller must expand stack make room additional arguments. Figure 6.27(a) shows caller’s stack calling procedure four arguments. procedure also declare local variables arrays. Local vari- ables declared within procedure accessed within procedure. Local variables stored $s0–$s7 ; many local variables, also stored procedure’s stack frame. particular, local arrays stored stack. Figure 6.27(b) shows organization callee’s stack frame. frame holds procedure’s arguments (if calls procedures), return address, saved registers procedure will326 CHAPTER SIX Architecture $sp$ra (if needed)additional arguments $a0–$a3 (if needed) $s0–$s7 (if needed) local variables arrays $sp stack frameadditional arguments Figure 6.27 Stack usage: (left) call, (right) callChapter 06.qxd 1/31/07 8:21 PM Page 326modify. also holds local arrays excess local variables. callee four arguments, finds caller’s stack frame. Accessing additional input arguments one exception procedure access stack data stack frame. 6.5 ADDRESSING MODES MIPS uses five addressing modes : register-only, immediate, base, PC- relative, pseudo-direct. first three modes (register-only, imme- diate, base addressing) define modes reading writing operands. last two (PC-relative pseudo-direct addressing) define modes writing program counter, PC. Register-Only Addressing Register-only addressing uses registers source destination operands. R-type instructions use register-only addressing. Immediate Addressing Immediate addressing uses 16-bit immediate along registers operands. I-type instructions, add immediate ( addi ) load upper immediate ( lui), use immediate addressing. Base Addressing Memory access instructions, load word ( lw) store word ( sw), use base addressing . effective address memory operand found adding base address register rsto sign-extended 16-bit offset found immediate field. PC-relative Addressing Conditional branch instructions use PC-relative addressing specify new value PCif branch taken. signed offset imme- diate field added PCto obtain new PC; hence, branch destination address said relative current PC. Code Example 6.28 shows part factorial procedure Code Example 6.27. Figure 6.28 shows machine code beq instruction. branch target address (BTA) address next instruction execute branch taken. beqinstruc- tion Figure 6.28 BTA 0xB4, instruction address else label. 16-bit immediate field gives number instructions BTA instruction branch instruction (the instruction PC/H110014). case, value immediate field beq 3 BTA (0xB4) 3 instructions past PC/H110014 (0xA8). processor calculates BTA instruction sign- extending 16-bit immediate, multiplying 4 (to convert words bytes), adding PC/H110014.6.5 Addressing Modes 327Chapter 06.qxd 1/31/07 8:21 PM Page 327Example 6.8 CALCULATING IMMEDIATE FIELD PC-RELATIVE ADDRESSING Calculate immediate field show machine code branch equal (bne) instruction following program. # MIPS assembly code 0x40loop: add $t1, $a0, $s0 0x44 lb $t1, 0($t1) 0x48 add $t2, $a1, $s0 0x4C sb $t1, 0($t2) 0x50 addi $s0, $s0, 1 0x54 bne $t1, $0, loop 0x58 lw $s0, 0($sp) Solution: Figure 6.29 shows machine code bneinstruction. branch target address, 0x40, 6 instructions behind PC/H110014 (0x58), immediate field /H110026.328 CHAPTER SIX Architecture op rs imm beq $t0, $0, elseMachine CodeAssembly Code 6 bits 5 bits 5 bits 16 bits(0x11000003) 6 bitsField Values op rs rt imm 4 80 3 5 bits 5 bits 16 bits000100 01000 00000 0000 0000 0000 0011rt Figure 6.28 Machine code beqMIPS Assembly Code 0xA4 beq $t0, $0, else 0xA8 addi $v0, $0, 1 0xAC addi $sp, $sp, 8 0xB0 jr $ra 0xB4 else: addi $a0, $a0, /H110021 0xB8 jal factorialCode Example 6.28 CALCULATING BRANCH TARGET ADDRESS 000101 01001 00000 bne $t1, $0, loopMachine Code Assembly Code 59 0 - 6 6 bits 5 bits 5 bits 16 bits(0x1520FFFA) 6 bits 5 bits 5 bits 16 bitsop rs rt imm op rs rt imm 1111 1111 1111 1010Field Values Figure 6.29 bne machine code Pseudo-Direct Addressing direct addressing , address specified instruction. jump instructions, jand jal, ideally would use direct addressing specify aChapter 06.qxd 1/31/07 8:21 PM Page 32832-bit jump target address (JTA) indicate instruction address execute next. Unfortunately, J-type instruction encoding enough bits specify full 32-bit JTA. Six bits instruction used opcode , 26 bits left encode JTA. Fortunately, two least significant bits, JTA 1:0, always 0, instruc- tions word aligned. next 26 bits, JTA 27:2, taken addr field instruction. four significant bits, JTA 31:28, obtained four significant bits PC/H110014. addressing mode called pseudo-direct . Code Example 6.29 illustrates jalinstruction using pseudo-direct addressing. JTA jalinstruction 0x004000A0. Figure 6.30 shows machine code jalinstruction. top four bits bottom two bits JTA discarded. remaining bits stored 26-bit address field ( addr ). processor calculates JTA J-type instruction appending two 0’s prepending four significant bits PC/H110014 26-bit address field ( addr ). four significant bits JTA taken PC/H110014, jump range limited. range limits branch jump instructions explored Exercises 6.23 6.26. J-type instruc- tions, jand jal, use pseudo-direct addressing. Note jump register instruction, jr, nota J-type instruc- tion. R-type instruction jumps 32-bit value held register rs.6.5 Addressing Modes 329 MIPS Assembly Code 0x0040005C jal sum ... 0x004000A0 sum: add $v0, $a0, $a1Code Example 6.29 CALCULATING JUMP TARGET ADDRESS op jal sumMachine Code Assembly Code 3 (0x0C100028)op 6 bits 0000 0000 0100 0000 0000 0000 1010 0000 JTA 26-bit addr (0x0100028)(0x004000A0) 0000 0000 00 0 2 8addr 0x0100028 26 bits 6 bits 26 bits000011 00 0001 0000 0000 0000 0010 1000addr 0000 0100 0000 0000 0000 1010 10Field Values Figure 6.30 jal machine codeChapter 06.qxd 1/31/07 8:21 PM Page 329330 CHAPTER SIX Architecture 6.6 LIGHTS, CAMERA, ACTION: COMPILING, ASSEMBLING, LOADING now, shown translate short high-level code snippets assembly machine code. section describes compile assemble complete high-level program load program memory execution. begin introducing MIPS memory map , defines code, data, stack memory located. show steps code execution sample program. 6.6.1 Memory Map 32-bit addresses, MIPS address space spans 232bytes /H110054 giga- bytes (GB). Word addresses divisible 4 range 0 0xFFFFFFFC. Figure 6.31 shows MIPS memory map. MIPS architecture divides address space four parts segments : text segment, global data segment, dynamic data segment, reserved segments. following sections describes segment. Text Segment text segment stores machine language program. large enough accommodate almost 256 MB code. Note four significant bits address text space 0, j instruction directly jump address program. Global Data Segment global data segment stores global variables that, contrast local variables, seen procedures program. Global variables Segment Address $sp = 0x7FFFFFFC0xFFFFFFFC 0x80000000 0x7FFFFFFC 0x10010000 0x1000FFFC 0x10000000 0x0FFFFFFC 0x00400000 0x003FFFFC 0x00000000Reserved Stack Heap Global Data Text Reserved$gp = 0x10008000 PC = 0x00400000Dynamic Data Figure 6.31 MIPS memory mapChapter 06.qxd 1/31/07 8:21 PM Page 330are defined start-up , program begins executing. vari- ables declared outside main procedure C program accessed procedure. global data segment large enough store 64 KB global variables. Global variables accessed using global pointer ( $gp), initialized 0x100080000. Unlike stack pointer ( $sp), $gpdoes change program execution. global variable accessed 16-bit positive negative offset $gp. offset known assembly time, variables efficiently accessed using base addressing mode constant offsets. Dynamic Data Segment dynamic data segment holds stack heap. data segment known start-up dynamically allocated de- allocated throughout execution program. largest segment memory used program, spanning almost 2 GB address space. discussed Section 6.4.6, stack used save restore registers used procedures hold local variables arrays. stack grows downward top dynamic data segment (0x7FFFFFFC) accessed last-in-first-out (LIFO) order. heap stores data allocated program run- time. C, memory allocations made malloc function; C/H11001/H11001and Java, newis used allocate memory. Like heap clothes dorm room floor, heap data used discarded order. heap grows upward bottom dynamic data segment. stack heap ever grow other, program’s data become corrupted. memory allocator tries ensure never happens returning out-of-memory error insuffi- cient space allocate dynamic data. Reserved Segments reserved segments used operating system cannot directly used program. Part reserved memory used interrupts (see Section 7.7) memory-mapped I/O (see Section 8.5). 6.6.2 Translating Starting Program Figure 6.32 shows steps required translate program high- level language machine language start executing program. First, high-level code compiled assembly code. assembly code assembled machine code object file . linker combines machine code object code libraries files pro- duce entire executable program. practice, compilers perform three steps compiling, assembling, linking. Finally, loader loads6.6 Lights, Camera, Action: Compiling, Assembling, Loading 331 Grace Hopper, 1906–1992. Graduated Yale University Ph.D. mathematics. Developed first compiler working Remington Rand Corporation instru- mental developing COBOL programming lan- guage. naval officer, received many awards, includ- ing World War II Victory Medal National Defence Service Medal. Chapter 06.qxd 1/31/07 8:21 PM Page 331the program memory starts execution. remainder sec- tion walks steps simple program. Step 1: Compilation compiler translates high-level code assembly language. Code Example 6.30 shows simple high-level program three global332 CHAPTER SIX Architecture Assembly CodeHigh Level Code Compiler Object FileAssembler ExecutableLinker MemoryLoaderObject Files Library FilesFigure 6.32 Steps translating starting program High-Level Code int f, g, y; // global variables int main (void) { f /H110052; g /H110053; /H11005sum (f, g); return y; } int sum (int a, int b) { return (a /H11001b); }MIPS Assembly Code .data f: g: y: .text main: addi $sp, $sp, /H110024 # make stack frame sw $ra, 0($sp) # store $ra stack addi $a0, $0, 2 # $a0 /H110052 sw $a0, f # f /H110052 addi $a1, $0, 3 # $a1 /H110053 sw $a1, g # g /H110053 jal sum # call sum procedure sw $v0, # /H11005sum (f, g) lw $ra, 0($sp) # restore $ra stack addi $sp, $sp, 4 # restore stack pointer jr $ra # return operating system sum: add $v0, $a0, $a1 # $v0 /H11005a /H11001b jr $ra # return callerCode Example 6.30 COMPILING HIGH-LEVEL PROGRAMChapter 06.qxd 1/31/07 8:21 PM Page 332variables two procedures, along assembly code produced typical compiler. . data .text keywords assembler directives indicate text data segments begin. Labels used global variables f, g, y. storage location determined assembler; now, left symbols code. Step 2: Assembling assembler turns assembly language code object file con- taining machine language code. assembler makes two passes assembly code. first pass, assembler assigns instruction addresses finds symbols , labels global variable names. code first assembler pass shown here. 0x00400000 main: addi $sp, $sp, /H110024 0x00400004 sw $ra, 0($sp) 0x00400008 addi $a0, $0, 2 0x0040000C sw $a0, f 0x00400010 addi $a1, $0, 3 0x00400014 sw $a1, g 0x00400018 jal sum 0x0040001C sw $v0, 0x00400020 lw $ra, 0($sp) 0x00400024 addi $sp, $sp, 4 0x00400028 jr $ra 0x0040002C sum: add $v0, $a0, $a1 0x00400030 jr $ra names addresses symbols kept symbol table , shown Table 6.4 code. symbol addresses filled first pass, addresses labels known. Global variables assigned storage locations global data segment memory, starting memory address 0x10000000. second pass code, assembler produces machine language code. Addresses global variables labels taken symbol table. machine language code symbol table stored object file.6.6 Lights, Camera, Action: Compiling, Assembling, Loading 333 Table 6.4 Symbol table Symbol Address f 0x10000000 g 0x10000004 0x10000008 main 0x00400000 sum 0x0040002CChapter 06.qxd 1/31/07 8:21 PM Page 333Executable file header Text Size Data Size Text segment Data segmentAddress Address0x00400000 0x00400004 0x00400008 0x0040000C 0x00400010 0x00400014 0x00400018 0x0040001C 0x00400020 0x00400024 0x00400028 0x0040002C 0x00400030addi $sp, $sp, –4 sw $ra, 0 ($sp) addi $a0, $0, 2 sw $a0, 0x8000 ($gp) addi $a1, $0, 3 sw $a1, 0x8004 ($gp) jal 0x0040002C sw $v0, 0x8008 ($gp) lw $ra, 0 ($sp) addi $sp, $sp, –4 jr $ra add $v0, $a0, $a1 jr $ra 0x10000000 0x10000004 0x10000008f g y0xC (12 bytes) 0x34 (52 bytes) 0x23BDFFFC 0xAFBF0000 0x20040002 0xAF848000 0x20050003 0xAF858004 0x0C10000B 0xAF828008 0x8FBF0000 0x23BD0004 0x03E00008 0x00851020 0x03E0008Instruction Data334 CHAPTER SIX Architecture Step 3: Linking large programs contain one file. programmer changes one files, would wasteful recompile reassemble files. particular, programs often call procedures library files; library files almost never change. file high- level code changed, associated object file need updated. job linker combine object files one machine language file called executable . linker relocates data instructions object files top other. uses information symbol tables adjust addresses global variables labels relocated. example, one object file, relocation necessary. Figure 6.33 shows executable file. three sections: executable file header, text segment, data segment. exe- cutable file header reports text size (code size) data size (amount globally declared data). given units bytes. text segment gives instructions addresses stored. figure shows instructions human-readable format next machine code ease interpretation, executable file includes machine instructions. data segment gives address global variable. global variables addressed respect base address given global pointer, $gp. example, Figure 6.33 ExecutableChapter 06.qxd 1/31/07 8:21 PM Page 334y g f 0x03E00008 0x00851020 0x03E00008 0x23BD0004 0x8FBF0000 0xAF828008 0x0C10000B 0xAF858004 0x20050003 0xAF848000 0x20040002 0xAFBF0000 0x23BDFFFCMemory Address $sp = 0x7FFFFFFC 0x7FFFFFFC 0x10010000 0x00400000Stack Heap $gp = 0x10008000 PC = 0x004000000x10000000Reserved Reservedfirst store instruction, sw $a0,0x8000($gp) , stores value 2 global variable f, located memory address 0x10000000. Remember offset, 0x8000, 16-bit signed number sign-extended added base address, $gp. So, $gp /H110010x8000 /H11005 0x10008000 /H110010xFFFF8000 /H110050x10000000, memory address variable f. Step 4: Loading operating system loads program reading text segment executable file storage device (usually hard disk) text segment memory. operating system sets $gpto 0x10008000 (the middle global data segment) $spto 0x7FFFFFFC (the top dynamic data segment), performs jal 0x00400000 jump beginning program. Figure 6.34 shows memory map beginning program execution.6.6 Lights, Camera, Action: Compiling, Assembling, Loading 335 Figure 6.34 Executable loaded memoryChapter 06.qxd 1/31/07 8:21 PM Page 3356.7 ODDS ENDS* section covers optional topics fit naturally elsewhere chapter. topics include pseudoinstructions, exceptions, signed unsigned arithmetic instructions, floating-point instructions. 6.7.1 Pseudoinstructions instruction available MIPS instruction set, proba- bly operation performed using one existing MIPS instructions. Remember MIPS reduced instruc- tion set computer (RISC), instruction size hardware complex- ity minimized keeping number instructions small. However, MIPS defines pseudoinstructions actually part instruction set commonly used programmers compilers. converted machine code, pseudoinstructions translated one MIPS instructions. Table 6.5 gives examples pseudoinstructions MIPS instructions used implement them. example, load immediate pseudoinstruction ( li) loads 32-bit constant using combination luiand oriinstructions. multiply pseudoinstruction ( mul) pro- vides three-operand multiply, multiplying two registers putting 32 least significant bits result third register. opera- tion pseudoinstruction ( nop, pronounced “no op”) performs opera- tion. PCis incremented 4 upon execution. registers memory values altered. machine code nopinstruction 0x00000000. pseudoinstructions require temporary register intermediate calculations. example, pseudoinstruction beq $t2, imm 15:0, Loop compares $t2 16-bit immediate, imm15:0. pseudoinstruction336 CHAPTER SIX Architecture Table 6.5 Pseudoinstructions Corresponding Pseudoinstruction MIPS Instructions li $s0, 0x1234AA77 lui $s0, 0x1234 ori $s0, 0xAA77 mul $s0, $s1, $s2 mult $s1, $s2 mflo $s0 clear $t0 add $t0, $0, $0 move $s1, $s2 add $s2, $s1, $0 nop sll $0, $0, 0Chapter 06.qxd 1/31/07 8:21 PM Page 336requires temporary register store 16-bit immediate. Assemblers use assembler register, $at, purposes. Table 6.6 shows assembler uses $atin converting pseudoinstruction real MIPS instructions. leave Exercise 6.31 implement pseudoinstructions rotate left ( rol) rotate right ( ror). 6.7.2 Exceptions exception like unscheduled procedure call jumps new address. Exceptions may caused hardware software. example, processor may receive notification user pressed key key- board. processor may stop doing, determine key pressed, save future reference, resume program run- ning. hardware exception triggered input/output (I/O) device keyboard often called interrupt . Alternatively, program may encounter error condition undefined instruction. program jumps code operating system (OS), may choose terminate offending program. Software exceptions some- times called traps . causes exceptions include division zero, attempts read nonexistent memory, hardware malfunctions, debugger breakpoints, arithmetic overflow (see Section 6.7.3). processor records cause exception value PC time exception occurs. jumps exception handler pro- cedure. exception handler code (usually OS) examines cause exception responds appropriately (by reading keyboard hardware interrupt, example). returns program executing exception took place. MIPS, exception han- dler always located 0x80000180. exception occurs, processor always jumps instruction address, regardless cause. MIPS architecture uses special-purpose register, called Cause register, record cause exception. Different codes used record different exception causes, given Table 6.7. exception handler code reads Cause register determine handle exception. architectures jump different excep- tion handler different cause instead using Cause register. MIPS uses another special-purpose register called Exception Program Counter ( EPC) store value PCat time exception6.7 Odds Ends 337 Table 6.6 Pseudoinstruction using $at Corresponding Pseudoinstruction MIPS Instructions beq $t2, imm 15:0, Loop addi $at, $0, imm 15:0 beq $t2, $at, LoopChapter 06.qxd 1/31/07 8:21 PM Page 337takes place. processor returns address EPCafter handling exception. analogous using $rato store old value PC jalinstruction. EPCand Cause registers part MIPS register file. mfc0 (move coprocessor 0) instruction copies special-purpose registers one general purpose registers. Coprocessor 0 called MIPS processor control ; handles interrupts processor diagnostics. example, mfc0$t0,Cause copies Cause register $t0. syscall break instructions cause traps perform system calls debugger breakpoints. exception handler uses EPCto look instruction determine nature system call breakpoint looking fields instruction. summary, exception causes processor jump exception handler. exception handler saves registers stack, uses mfc0 look cause respond accordingly. handler finished, restores registers stack, copies return address EPCto $k0using mfc0 , returns using jr$k0 . 6.7.3 Signed Unsigned Instructions Recall binary number may signed unsigned. MIPS archi- tecture uses two’s complement representation signed numbers. MIPS certain instructions come signed unsigned flavors, includ- ing addition subtraction, multiplication division, set less than, partial word loads. Addition Subtraction Addition subtraction performed identically whether number signed unsigned. However, interpretation results dif- ferent. mentioned Section 1.4.6, two large signed numbers added together, result may incorrectly produce opposite sign. exam- ple, adding following two huge positive numbers gives negative338 CHAPTER SIX Architecture Table 6.7 Exception cause codes Exception Cause hardware interrupt 0x00000000 system call 0x00000020 breakpoint/divide 0 0x00000024 undefined instruction 0x00000028 arithmetic overflow 0x00000030 $k0and $k1are included MIPS register set. reserved OS excep- tion handling. need saved restored exceptions.Chapter 06.qxd 1/31/07 8:21 PM Page 338result: 0x7FFFFFFF /H110010x7FFFFFFF /H110050xFFFFFFFE /H11005/H11002 2. Similarly, adding two huge negative numbers gives positive result, 0x80000001 /H11001 0x80000001 /H110050x00000002. called arithmetic overflow . C language ignores arithmetic overflows, languages, Fortran, require program notified. mentioned Section 6.7.2, MIPS processor takes exception arithmetic over- flow. program decide overflow (for exam- ple, might repeat calculation greater precision avoid overflow), return left off. MIPS provides signed unsigned versions addition sub- traction. signed versions add,addi , sub. unsigned ver- sions addu, addiu , subu . two versions identical except signed versions trigger exception overflow, whereas unsigned versions not. C ignores exceptions, C programs technically use unsigned versions instructions. Multiplication Division Multiplication division behave differently signed unsigned numbers. example, unsigned number, 0xFFFFFFFF represents large number, signed number represents /H110021. Hence, 0xFFFFFFFF /H110030xFFFFFFFF would equal 0xFFFFFFFE00000001 numbers unsigned 0x0000000000000001 numbers signed. Therefore, multiplication division come signed unsigned flavors. mult divtreat operands signed numbers. multu divu treat operands unsigned numbers. Set Less Set less instructions compare either two registers ( slt) reg- ister immediate ( slti ). Set less also comes signed ( slt slti ) unsigned ( sltu sltiu ) versions. signed compari- son, 0x80000000 less number, negative two’s complement number. unsigned comparison, 0x80000000 greater 0x7FFFFFFF less 0x80000001, numbers positive. Beware sltiu sign-extends immediate treating unsigned number. example, sltiu $s0, $s1, 0x8042 compares $s1to 0xFFFF8042, treating immediate large positive number. Loads described Section 6.4.5, byte loads come signed ( lb) unsigned ( lbu) versions. lbsign-extends byte, lbuzero-extends byte fill entire 32-bit register. Similarly, MIPS provides signed unsigned half-word loads ( lhand lhu), load two bytes lower half sign- zero-extend upper half word.6.7 Odds Ends 339Chapter 06.qxd 1/31/07 8:21 PM Page 339cop ft fs fd funct 6 bits 5 bits 5 bits 5 bits 5 bits 6 bitsF-type op6.7.4 Floating-Point Instructions MIPS architecture defines optional floating-point coprocessor, known coprocessor 1. early MIPS implementations, floating- point coprocessor separate chip users could purchase needed fast floating-point math. recent MIPS implemen- tations, floating-point coprocessor built alongside main processor. MIPS defines 32 32-bit floating-point registers, $f0–$f31 . separate ordinary registers used far. MIPS supports single- double-precision IEEE floating point arithmetic. Double- precision (64-bit) numbers stored pairs 32-bit registers, 16 even-numbered registers ( $f0,$f2,$f4, ... ,$f30 ) used specify double-precision operations. convention, certain registers reserved certain purposes, given Table 6.8. Floating-point instructions opcode 17 (10001 2). require funct field cop(coprocessor) field indicate type instruction. Hence, MIPS defines F-type instruction format floating-point instructions, shown Figure 6.35. Floating-point instructions come single- double-precision flavors. cop/H1100516 (10000 2) single-precision instructions 17 (10001 2) double- precision instructions. Like R-type instructions, F-type instructions two source operands, fsand ft, one destination, fd. Instruction precision indicated . sand .din mnemonic. Floating-point arithmetic instructions include addition ( add.s, add.d ), subtraction ( sub.sz, sub.d ), multiplication ( mul.s, mul.d ), divi- sion (div.s, div.d ) well negation ( neg.s, neg.d ) absolute value (abs.s,abs.d ).340 CHAPTER SIX Architecture Table 6.8 MIPS floating-point register set Name Number Use $fv0–$fv1 0, 2 procedure return values $ft0–$ft3 4, 6, 8, 10 temporary variables $fa0–$fa1 12, 14 procedure arguments $ft4–$ft5 16, 18 temporary variables $fs0–$fs5 20, 22, 24, 26, 28, 30 saved variables Figure 6.35 F-type machine instruction formatChapter 06.qxd 1/31/07 8:21 PM Page 340Floating-point branches two parts. First, compare instruction used set clear floating-point condition flag (fpcond ). Then, conditional branch checks value flag. compare instruc- tions include equality ( c.seq.s/c.seq.d ), less ( c.lt.s/c.lt.d ), less equal ( c.le.s/c.le.d ). conditional branch instructions bc1f bc1t branch fpcond FALSE TRUE, respectively. Inequality, greater equal to, greater comparisons performed seq,lt, le, followed bc1f . Floating-point registers loaded stored memory using lwc1 swc1 . instructions move 32 bits, two necessary handle double-precision number. 6.8 REAL-WORLD PERSPECTIVE: IA-32 ARCHITECTURE* Almost personal computers today use IA-32 architecture micro- processors. IA-32 32-bit architecture originally developed Intel. AMD also sells IA-32 compatible microprocessors. IA-32 architecture long convoluted history dating back 1978, Intel announced 16-bit 8086 microprocessor. IBM selected 8086 cousin, 8088, IBM’s first personal computers. 1985, Intel introduced 32-bit 80386 microprocessor, backward compatible 8086, could run software developed earlier PCs. Processor architectures compatible 80386 called IA-32 x86 processors. Pentium, Core, Athlon processors well known IA-32 processors. Section 7.9 describes evolution IA-32 microprocessors detail. Various groups Intel AMD many years shoehorned instructions capabilities antiquated architecture. result far less elegant MIPS. Patterson Hennessy explain, “this checkered ancestry led architecture difficult explain impossible love.” However, software compatibility far important technical elegance, IA-32 de facto PC standard two decades. 100 million IA-32 processors sold every year. huge market justifies $5 billion research development annually continue improving processors. IA-32 example Complex Instruction Set Computer (CISC ) architecture. contrast RISC architectures MIPS, CISC instruction work. Programs CISC architectures usually require fewer instructions. instruction encodings selected compact, save memory, RAM far expen- sive today; instructions variable length often less 32 bits. trade-off complicated instructions dif- ficult decode tend execute slowly.6.8 Real-World Perspective: IA-32 Architecture 341Chapter 06.qxd 1/31/07 8:21 PM Page 341This section introduces IA-32 architecture. goal make IA-32 assembly language programmer, rather illustrate similarities differences IA-32 MIPS. think interesting see IA-32 works. However, none material section needed understand rest book. Major differences IA-32 MIPS summarized Table 6.9. 6.8.1 IA-32 Registers 8086 microprocessor provided eight 16-bit registers. could sepa- rately access upper lower eight bits registers. 32-bit 80386 introduced, registers extended 32 bits. registers called EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI. backward compatibility, bottom 16 bits bottom 8-bit portions also usable, shown Figure 6.36. eight registers almost, quite, general purpose. Certain instructions cannot use certain registers. instructions always put results certain registers. Like $spin MIPS,ESPis nor- mally reserved stack pointer. IA-32 program counter called EIP(the extended instruction pointer ). Like MIPS PC, advances one instruction next changed branch, jump, subroutine call instructions. 6.8.2 IA-32 Operands MIPS instructions always act registers immediates. Explicit load store instructions needed move data memory registers. contrast, IA-32 instructions may operate registers, immediates, memory. partially compensates small set registers.342 CHAPTER SIX Architecture Table 6.9 Major differences MIPS IA-32 Feature MIPS IA-32 # registers 32 general purpose 8, restrictions purpose # operands 3 (2 source, 1 destination) 2 (1 source, 1 source/destination) operand location registers immediates registers, immediates, memory operand size 32 bits 8, 16, 32 bits condition codes yes instruction types simple simple complicated instruction encoding fixed, 4 bytes variable, 1–15 bytes Figure 6.36 IA-32 registersEAX 0 AHAX ECX 1 CHCX EDX 2Byte 0 Byte 1 Byte 2 Byte 3 DHDX EBX 3 BHBX ESP SP 4 EBP BP 5 ESI SI 6 EDI DI 7AL CL DL BLChapter 06.qxd 1/31/07 8:21 PM Page 342MIPS instructions generally specify three operands: two sources one destination. IA-32 instructions specify two operands. first source. second source destination. Hence, IA-32 instructions always overwrite one sources result. Table 6.10 lists combinations operand locations IA-32. combinations possible except memory memory. Like MIPS, IA-32 32-bit memory space byte-addressable. However, IA-32 also supports much wider variety memory addressing modes . memory location specified combination base register, displacement , scaled index register . Table 6.11 illustrates combinations. displacement 8-, 16-, 32-bit value. scale multiplying index register 1, 2, 4, 8. base /H11001 displacement mode equivalent MIPS base addressing mode loads stores. scaled index provides easy way access arrays structures 2-, 4-, 8-byte elements without issue sequence instructions generate address.6.8 Real-World Perspective: IA-32 Architecture 343 Table 6.10 Operand locations Source/ Destination Source Example Meaning register register add EAX, EBX EAX /H11021– EAX /H11001EBX register immediate add EAX, 42 EAX /H11021– EAX /H1100142 register memory add EAX, [20] EAX /H11021– EAX /H11001Mem[20] memory register add [20], EAX Mem[20] /H11021– Mem[20] /H11001EAX memory immediate add [20], 42 Mem[20] /H11021– Mem[20] /H1100142 Table 6.11 Memory addressing modes Example Meaning Comment add EAX, [20] EAX /H11021– EAX /H11001Mem[20] displacement add EAX, [ESP] EAX /H11021– EAX /H11001Mem[ESP] base addressing add EAX, [EDX /H1100140] EAX /H11021– EAX /H11001Mem[EDX /H1100140] base /H11001displacement add EAX, [60 /H11001EDI*4] EAX /H11021– EAX /H11001Mem[60 /H11001EDI*4] displacement /H11001scaled index add EAX, [EDX /H1100180/H11001EDI*2] EAX /H11021– EAX /H11001Mem[EDX /H1100180/H11001EDI*2] base /H11001displacement /H11001 scaled indexChapter 06.qxd 1/31/07 8:21 PM Page 343While MIPS always acts 32-bit words, IA-32 instructions operate 8-, 16-, 32-bit data. Table 6.12 illustrates variations. 6.8.3 Status Flags IA-32, like many CISC architectures, uses status flags (also called condi- tion codes ) make decisions branches keep track car- ries arithmetic overflow. IA-32 uses 32-bit register, called EFLAGS , stores status flags. bits EFLAGS register given Table 6.13. bits used operating system. architectural state IA-32 processor includes EFLAGS well eight registers EIP. 6.8.4 IA-32 Instructions IA-32 larger set instructions MIPS. Table 6.14 describes general purpose instructions. IA-32 also instructions floating- point arithmetic arithmetic multiple short data elements packed longer word. Dindicates destination (a register memory loca- tion), Sindicates source (a register, memory location, immediate). Note instructions always act specific registers. example, 32 /H1100332-bit multiplication always takes one sources EAXand always puts 64-bit result EDXand EAX. LOOP always344 CHAPTER SIX Architecture Table 6.12 Instructions acting 8-, 16-, 32-bit data Example Meaning Data Size add AH, BL AH /H11021– AH /H11001BL 8-bit add AX, /H110021 AX /H11021– AX /H110010xFFFF 16-bit add EAX, EDX EAX /H11021– EAX /H11001EDX 32-bit Table 6.13 Selected EFLAGS Name Meaning CF (Carry Flag) Carry generated last arithmetic operation. Indicates overflow unsigned arithmetic. Also used propagating carry words multiple-precision arithmetic. ZF(Zero Flag) Result last operation zero. SF(Sign Flag) Result last operation negative (msb /H110051). OF(Overflow Flag) Overflow two’s complement arithmetic.Chapter 06.qxd 1/31/07 8:21 PM Page 3446.8 Real World Perspective: IA-32 Architecture 345 Table 6.14 Selected IA-32 instructions Instruction Meaning Function ADD/SUB add/subtract /H11005D /H11001S / /H11005D /H11002S ADDC add carry /H11005D /H11001S /H11001CF INC/DEC increment/decrement /H11005D /H110011 / /H11005D /H110021 CMP compare Set flags based /H11002S NEG negate /H11005/H11002D AND/OR/XOR logical AND/OR/XOR /H11005D op logical /H11005D/H11002 IMUL/MUL signed/unsigned multiply EDX:EAX /H11005EAX /H11003D IDIV/DIV signed/unsigned divide EDX:EAX/D EAX/H11005Quotient; EDX/H11005Remainder SAR/SHR arithmetic/logical shift right /H11005D /H11022/H11022/H11022S / /H11005D /H11022/H11022S SAL/SHL left shift /H11005D /H11021/H11021S ROR/ROL rotate right/left Rotate Dby RCR/RCL rotate right/left carry Rotate CFand Dby BT bit test CF /H11005D[S] (the Sthbit D) BTR/BTS bit test reset/set CF /H11005D[S]; D[S] /H110050 / 1 TEST set flags based masked bits Set flags based MOV move /H11005S PUSH push onto stack ESP /H11005ESP /H110024; Mem[ESP] /H11005S POP pop stack /H11005MEM[ESP]; ESP /H11005ESP /H110014 CLC, STC clear/set carry flag CF /H110050 / 1 JMP unconditional jump relative jump: EIP /H11005EIP /H11001S absolute jump: EIP /H11005S Jcc conditional jump (flag) EIP /H11005EIP /H11001S LOOP loop ECX /H11005ECX /H110021 ECX/H11005/H114080 EIP /H11005EIP /H11001imm CALL procedure call ESP /H11005ESP /H110024; MEM[ESP] /H11005EIP; EIP /H11005S RET procedure return EIP /H11005MEM[ESP]; ESP /H11005ESP /H110014Chapter 06.qxd 1/31/07 8:21 PM Page 345346 CHAPTER SIX Architecture 2It possible construct 17-byte instructions optional fields used. However, IA-32 places 15-byte limit length legal instructions.Table 6.15 Selected branch conditions Instruction Meaning Function cmpd,s JZ/JE jump ZF /H110051 jump D/H11005S JNZ/JNE jump ZF /H110050 jump D/HS11005S JGE jump SF /H11005OF jump D/H11091S JG jump SF /H11005OFand ZF /H110050 jump D/H11022S JLE jump SF/HS11005OFor ZF /H110051 jump D/H11088S JL jump SF/HS11005OF jump D/H11021S JC/JB jump CF /H110051 JNC jump CF /H110050 JO jump /H110051 JNO jump /H110050 JS jump SF /H110051 JNS jump SF /H110050 stores loop counter ECX.PUSH,POP,CALL, andRETuse stack pointer, ESP. Conditional jumps check flags branch appropriate condition met. come many flavors. example, JZjumps zero flag ( ZF) 1. JNZjumps zero flag 0. jumps usually follow instruction, compare instruction ( CMP), sets flags. Table 6.15 lists conditional jumps depend flags set prior compare operation. 6.8.5 IA-32 Instruction Encoding IA-32 instruction encodings truly messy, legacy decades piecemeal changes. Unlike MIPS, whose instructions uniformly 32 bits, IA-32 instructions vary 1 15 bytes, shown Figure 6.37.2The opcode may 1, 2, 3 bytes. followed four optional fields: ModR/M, SIB, Displacement , Immediate. ModR/M specifies addressing mode. SIB specifies scale, index, baseChapter 06.qxd 1/31/07 8:21 PM Page 3466.8 Real World Perspective: IA-32 Architecture 347 registers certain addressing modes. Displacement indicates 1-, 2-, 4-byte displacement certain addressing modes. Immediate 1-, 2-, 4-byte constant instructions using immediate source operand. Moreover, instruction preceded four optional byte-long prefixes modify behavior. ModR/M byte uses 2-bit Modand 3-bit R/Mfield specify addressing mode one operands. operand come one eight registers, one 24 memory addressing modes. Due artifacts encodings, ESPand EBPregisters avail- able use base index register certain addressing modes. Regfield specifies register used operand. certain instructions require second operand, Regfield used specify three bits opcode . addressing modes using scaled index register, SIBbyte speci- fies index register scale (1, 2, 4, 8). base index used, SIBbyte also specifies base register. MIPS fully specifies instruction opcode funct fields instruction. IA-32 uses variable number bits specify dif- ferent instructions. uses fewer bits specify common instruc- tions, decreasing average length instructions. instructions even multiple opcodes. example, add AL, imm8 performs 8-bit add immediate AL. represented 1-byte opcode , 0x04, followed 1-byte immediate. Aregister (AL, AX , EAX) called accumulator . hand, add D, imm8 performs 8-bit add immediate arbitrary destina- tion, D(memory register). represented 1-byte opcode , 0x80, followed one bytes specifying D, followed 1-byte immediate. Many instructions shortened encodings des- tination accumulator. original 8086, opcode specified whether instruction acted 8- 16-bit operands. 80386 introduced 32-bit operands, new opcodes available specify 32-bit form.Prefixes ModR/M SIB Displacement Immediate 4 optional prefixes 1 byte each1-, 2-, 3-byte opcode1 byte (for certain addressing modes)1 byte (for certain addressing modes)1, 2, 4 bytes addressing modes displacement1, 2, 4 bytes addressing modes immediate Scale Index Base Mod R/MReg/ OpcodeOpcode 2 bits 3 bits 3 bits 2 bits 3 bits 3 bits Figure 6.37 IA-32 instruction encodingsChapter 06.qxd 1/31/07 8:21 PM Page 347Instead, opcode used 16- 32-bit forms. additional bit code segment descriptor used OS specifies form processor choose. bit set 0 back- ward compatibility 8086 programs, defaulting opcode 16-bit operands. set 1 programs default 32-bit operands. Moreover, programmer specify prefixes change form particular instruction. prefix 0x66 appears opcode , alternative size operand used (16 bits 32-bit mode, 32 bits 16-bit mode). 6.8.6 IA-32 Peculiarities 80286 introduced segmentation divide memory segments 64 KB length. OS enables segmentation, addresses computed relative beginning segment. processor checks addresses go beyond end segment indicates error, thus preventing programs accessing mem- ory outside segment. Segmentation proved hassle programmers used modern versions Windows oper- ating system. IA-32 contains string instructions act entire strings bytes words. operations include moving, comparing, scanning specific value. modern processors, instructions usually slower performing equivalent operation series simpler instructions, best avoided. mentioned earlier, 0x66 prefix used choose 16- 32-bit operand sizes. prefixes include ones used lock bus (to control access shared variables multiprocessor sys- tem), predict whether branch taken not, repeat instruction string move. bane architecture run memory capacity. 32-bit addresses, IA-32 access 4 GB memory. far largest computers 1985, early 2000s become limiting. 2003, AMD extended address space register sizes 64 bits, calling enhanced architecture AMD64. AMD64 compatibility mode allows run 32-bit programs unmodified OS takes advantage bigger address space. 2004, Intel gave adopted 64-bit extensions, renaming Extended Memory 64 Technology (EM64T). 64-bit addresses, computers access 16 exabytes (16 billion GB) memory. curious details IA-32 architecture, IA-32 Intel Architecture Software Developer’s Manual, freely available Intel’s Web site.348 CHAPTER SIX Architecture Intel Hewlett-Packard jointly developed new 64-bit architecture called IA-64 mid 1990’s. designed clean slate, bypassing convoluted history IA-32, taking advantage 20 years new research computer architec- ture, providing 64-bit address space. However, IA-64 yet become market success. compu- ters needing large address space use 64-bit extensions IA-32.Chapter 06.qxd 1/31/07 8:21 PM Page 3486.8.7 Big Picture section given taste differences MIPS RISC architecture IA-32 CISC architecture. IA-32 tends shorter programs, complex instruction equivalent series simple MIPS instructions instructions encoded minimize memory use. However, IA-32 architecture hodgepodge features accumulated years, longer useful must kept compatibility old programs. regis- ters, instructions difficult decode. Merely explaining instruction set difficult. Despite failings, IA-32 firmly entrenched dominant computer architecture PCs, value software compatibility great huge market justifies effort required build fast IA-32 microprocessors. 6.9 SUMMARY command computer, must speak language. computer architecture defines command processor. Many different com- puter architectures widespread commercial use today, understand one, learning others much easier. key questions ask approaching new architecture /L50776What data word length? /L50776What registers? /L50776How memory organized? /L50776What instructions? MIPS 32-bit architecture operates 32-bit data. MIPS architecture 32 general-purpose registers. principle, almost register used purpose. However, convention, certain registers reserved certain purposes, ease programming procedures written different programmers communicate easily. example, register 0, $0, always holds constant 0, $ra holds return address jalinstruction, $a0–$a3 $v0–$v1 hold arguments return value procedure. MIPS byte- addressable memory system 32-bit addresses. memory map described Section 6.6.1. Instructions 32 bits long must word aligned. chapter discussed commonly used MIPS instructions. power defining computer architecture program written given architecture run many different implemen- tations architecture. example, programs written Intel6.9 Summary 349Chapter 06.qxd 1/31/07 8:21 PM Page 349Pentium processor 1993 generally still run (and run much faster) Intel Core 2 Duo AMD Athlon processors 2006. first part book, learned circuit logic levels abstraction. chapter, jumped archi- tecture level. next chapter, study microarchitecture, arrangement digital building blocks implement processor architecture. Microarchitecture link hardware soft- ware engineering. And, believe one exciting topics engineering: learn build microprocessor!350 CHAPTER SIX ArchitectureChapter 06.qxd 1/31/07 8:21 PM Page 350Exercises Exercise 6.1 Give three examples MIPS architecture architecture design principles: (1) simplicity favors regularity; (2) make com- mon case fast; (3) smaller faster; (4) good design demands good compro- mises. Explain examples exhibits design principle. Exercise 6.2 MIPS architecture register set consists 32 32-bit registers. possible design computer architecture without register set? so, briefly describe architecture, including instruction set. advantages disadvantages architecture MIPS architecture? Exercise 6.3 Consider memory storage 32-bit word stored memory word 42 byte addressable memory. (a) byte address memory word 42? (b) byte addresses memory word 42 spans? (c) Draw number 0xFF223344 stored word 42 big-endian little-endian machines. drawing similar Figure 6.4. Clearly label byte address corresponding data byte value. Exercise 6.4 Explain following program used determine whether computer big-endian little-endian: li $t0, 0xABCD9876 sw $t0, 100($0) lb $s5, 101($0) Exercise 6.5 Write following strings using ASCII encoding. Write final answers hexadecimal. (a) SOS (b) Cool! (c) (your name) Exercise 6.6 Show strings Exercise 6.5 stored byte-addressable memory (a) big-endian machine (b) little-endian machine starting memory address 0x1000100C. Use memory diagram similar Figure 6.4. Clearly indicate memory address byte machine.Exercises 351Chapter 06.qxd 1/31/07 8:21 PM Page 351Exercise 6.7 Convert following MIPS assembly code machine language. Write instructions hexadecimal. add $t0, $s0, $s1 lw $t0, 0x20($t7) addi $s0, $0, /H1100210 Exercise 6.8 Repeat Exercise 6.7 following MIPS assembly code: addi $s0, $0, 73 sw $t1, /H110027($t2) sub $t1, $s7, $s2 Exercise 6.9 Consider I-type instructions. (a) instructions Exercise 6.8 I-type instructions? (b) Sign-extend 16-bit immediate instruction part (a) becomes 32-bit number. Exercise 6.10 Convert following program machine language MIPS assembly language. numbers left instruction address memory, numbers right give instruction address. reverse engineer high-level program would compile assembly language routine write it. Explain words program does. $a0is input, initially contains positive number, n. $v0 output. 0x00400000 0x20080000 0x00400004 0x20090001 0x00400008 0x0089502a 0x0040000c 0x15400003 0x00400010 0x01094020 0x00400014 0x21290002 0x00400018 0x08100002 0x0040001c 0x01001020 Exercise 6.11 nori instruction part MIPS instruction set, functionality implemented using existing instructions. Write short assembly code snippet following functionality: $t0 /H11005$t1 0xF234 . Use instructions possible.352 CHAPTER SIX ArchitectureChapter 06.qxd 1/31/07 8:21 PM Page 352Exercise 6.12 Implement following high-level code segments using slt instruction. Assume integer variables gand hare registers $s0and $s1, respectively. (a)if (g /H11022h) g /H11005g /H11001h; else g /H11005g /H11002h; (b)if (g /H11022/H11005h) g /H11005g /H110011; else h /H11005h /H110021; (c)if (g /H11021/H11005h) g /H110050; else h /H110050; Exercise 6.13 Write procedure high-level language int find42(int array[], int size). size specifies number elements array. array specifies base address array. procedure return index number first array entry holds value 42. array entry 42, return value /H110021. Exercise 6.14 high-level procedure strcpy copies character string xto character string y. // high-level code void strcpy(char x[], char y[]) { int /H110050; (x[i] ! /H110050) { y[i] /H11005x[i]; /H11005i /H110011; } } (a) Implement strcpy procedure MIPS assembly code. Use $s0for i. (b) Draw picture stack before, during, strcpy procedure call. Assume $sp/H110050x7FFFFF00 strcpy called. Exercise 6.15 Convert high-level procedure Exercise 6.13 MIPS assembly code.Exercises 353 simple string copy pro- gram serious flaw: way knowing yhas enough space receive x. malicious programmer able execute strcpy long string x, program- mer might able write bytes memory, possi- bly even modifying code stored subsequent memory locations. clever- ness, modified code might take machine. called buffer overflow attack; employed several nasty programs, including infamous Blaster worm, caused esti- mated $525 million dam- ages 2003.Chapter 06.qxd 1/31/07 8:21 PM Page 353Exercise 6.16 number Fibonacci series sum previous two numbers. Table 6.16 lists first numbers series, fib(n) . (a) fib(n) n/H110050 n/H11005/H110021? (b) Write procedure called fibin high-level language returns Fibonacci number nonnegative value n. Hint: probably want use loop. Clearly comment code. (c) Convert high-level procedure part (b) MIPS assembly code. Add comments every line code explain clearly does. Use SPIM simulator test code fib(9). Exercise 6.17 Consider MIPS assembly code below. proc1 ,proc2 , proc3 non-leaf procedures. proc4 leaf procedure. code shown procedure, comments indicate registers used within procedure. 0x00401000 proc1: ... # proc1 uses $s0 $s1 0x00401020 jal proc2 ... 0x00401100 proc2: ... # proc2 uses $s2 – $s7 0x0040117C jal proc3 ... 0x00401400 proc3: ... # proc3 uses $s1 – $s3 0x00401704 jal proc4 ... 0x00403008 proc4: ... # proc4 uses preserved # registers 0x00403118 jr $ra (a) many words stack frames procedure? (b) Sketch stack proc4 called. Clearly indicate registers stored stack. Give values possible.354 CHAPTER SIX Architecture Table 6.16 Fibonacci series n 1234567 8 91 01 1. . . fib(n) 1123581 3 2 13 45 58 9. . .Chapter 06.qxd 1/31/07 8:21 PM Page 354Exercise 6.18 Ben Bitdiddle trying compute function f(a, b) /H110052a/H110013b nonnegative b. goes overboard use procedure calls recursion produces following high-level code procedures fand f2. // high-level code procedures f f2 int f(int a, int b) { int j; j /H11005a; return j /H11001a /H11001f2(b); } int f2(int x) { int k; k /H110053; (x /H11005/H110050) return 0; else return k /H11001f2(x /H110021); } Ben translates two procedures assembly language follows. also writes procedure, test, calls procedure f(5,3) . # MIPS assembly code # f: $a0 /H11005a, $a1 /H11005b, $s0 /H11005j f2: $a0 /H11005x, $s0 /H11005k 0x00400000 test:addi $a0, $0, 5 # $a0 /H110055 (a /H110055) 0x00400004 addi $a1, $0, 3 # $a1 /H110053 (b /H110053) 0x00400008 jal f # call f(5,3) 0x0040000c loop:j loop # loop forever 0x00400010 f: addi $sp, $sp, /H1100216 # make room stack # $s0, $a0, $a1, $ra 0x00400014 sw $a1, 12($sp) # save $a1 (b) 0x00400018 sw $a0, 8($sp) # save $a0 (a) 0x0040001c sw $ra, 4($sp) # save $ra 0x00400020 sw $s0, 0($sp) # save $s0 0x00400024 add $s0, $a0, $0 # $s0 /H11005$a0 (j /H11005a) 0x00400028 add $a0, $a1, $0 # place b argument f2 0x0040002c jal f2 # call f2(b) 0x00400030 lw $a0, 8($sp) # restore $a0 (a) call 0x00400034 lw $a1, 12($sp) # restore $a1 (b) call 0x00400038 add $v0, $v0, $s0 # $v0 /H11005f2(b) /H11001j 0x0040003c add $v0, $v0, $a0 # $v0 /H11005(f2(b) /H11001j) /H11001a 0x00400040 lw $s0, 0($sp) # restore $s0 0x00400044 lw $ra, 4($sp) # restore $ra 0x00400048 addi $sp, $sp, 16 # restore $sp (stack pointer) 0x0040004c jr $ra # return point call 0x00400050 f2: addi $sp, $sp, /H1100212 # make room stack # $s0, $a0, $ra 0x00400054 sw $a0, 8($sp) # save $a0 (x) 0x00400058 sw $ra, 4($sp) # save return address 0x0040005c sw $s0, 0($sp) # save $s0 0x00400060 addi $s0, $0, 3 # k /H110053Exercises 355Chapter 06.qxd 1/31/07 8:21 PM Page 3550x00400064 bne $a0, $0, else # x /H110050? 0x00400068 addi $v0, $0, 0 #yes:returnvalueshouldbe0 0x0040006c j done # clean 0x00400070 else:addi $a0, $a0, /H110021 # no:$a0 /H11005$a0 /H110021(x /H11005x/H110021) 0x00400074 jal f2 # call f2(x /H110021) 0x00400078 lw $a0, 8($sp) # restore $a0 (x) 0x0040007c add $v0, $v0, $s0 # $v0 /H11005f2(x /H110021) /H11001k 0x00400080 done:lw $s0, 0($sp) # restore $s0 0x00400084 lw $ra, 4($sp) # restore $ra 0x00400088 addi $sp, $sp, 12 # restore $sp 0x0040008c jr $ra # return point call probably find useful make drawings stack similar one Figure 6.26 help answer following questions. (a) code runs starting test, value $v0when program gets loop? program correctly compute 2a /H110013b? (b) Suppose Ben deletes instructions addresses 0x0040001C 0x00400040 save restore $ra. program (1) enter infi- nite loop crash; (2) crash (cause stack grow beyond dynamic data segment PC jump location outside program); (3) produce incorrect value $v0when program returns loop (if so, value?), (4) run correctly despite deleted lines? (c) Repeat part (b) instructions following instruction addresses deleted: (i) 0x00400018 0x00400030 (instructions save restore $a0) (ii) 0x00400014 0x00400034 (instructions save restore $a1) (iii) 0x00400020 0x00400040 (instructions save restore $s0) (iv) 0x00400050 0x00400088 (instructions save restore $sp) (v) 0x0040005C 0x00400080 (instructions save restore $s0) (vi) 0x00400058 0x00400084 (instructions save restore $ra) (vii) 0x00400054 0x00400078 (instructions save restore $a0) Exercise 6.19 Convert following beq,j, jalassembly instructions machine code. Instruction addresses given left instruction. (a) 0x00401000 beq $t0, $s1, Loop 0x00401004 ... 0x00401008 ... 0x0040100C Loop: ...356 CHAPTER SIX ArchitectureChapter 06.qxd 1/31/07 8:21 PM Page 356(b) 0x00401000 beq $t7, $s4, done ... ... 0x00402040 done: ... (c) 0x0040310C back: ... ... ... 0x00405000 beq $t9, $s7, back (d) 0x00403000 jal proc ... ... 0x0041147C proc: ... (e) 0x00403004 back: ... ... ... 0x0040400C j back Exercise 6.20 Consider following MIPS assembly language snippet. numbers left instruction indicate instruction address. 0x00400028 add $a0, $a1, $0 0x0040002c jal f2 0x00400030 f1: jr $ra 0x00400034 f2: sw $s0, 0($s2) 0x00400038 bne $a0, $0, else 0x0040003c jf 1 0x00400040 else: addi $a0, $a0, /H110021 0x00400044 jf 2 (a) Translate instruction sequence machine code. Write machine code instructions hexadecimal. (b) List addressing mode used line code. Exercise 6.21 Consider following C code snippet. // C code void set_array(int num) { int i; int array[10]; (i /H110050; /H1102110; /H11005i /H110011) { array[i] /H11005compare(num, i); } } int compare(int a, int b) { (sub(a, b) > /H110050) return 1; elseExercises 357Chapter 06.qxd 1/31/07 8:21 PM Page 357return 0; } int sub (int a, int b) { return /H11002b; } (a) Implement C code snippet MIPS assembly language. Use $s0to hold variable i. sure handle stack pointer appropriately. array stored stack set_array procedure (see Section 6.4.6). (b) Assume set_array first procedure called. Draw status stack calling set_array procedure call. Indicate names registers variables stored stack mark location $sp. (c) would code function failed store $raon stack? Exercise 6.22 Consider following high-level procedure. // high-level code int f(int n, int k) { int b; b /H11005k /H110012; (n /H11005/H110050) b /H1100510; else b /H11005b /H11001(n * n) /H11001f(n /H110021, k /H110011); return b * k; } (a) Translate high-level procedure finto MIPS assembly language. Pay partic- ular attention properly saving restoring registers across procedure calls using MIPS preserved register conventions. Clearly comment code. use MIPS mult ,mfhi, mflo instructions. proce- dure starts instruction address 0x00400100. Keep local variable bin $s0. (b) Step program part (a) hand case f(2, 4) . Draw picture stack similar one Figure 6.26(c). Write register name data value stored location stack keep track stack pointer value ( $sp). might also find useful keep track values $a0,$a1,$v0, $s0throughout execution. Assume fis called, $s0/H110050xABCD $ra/H110050x400004. final value $v0? Exercise 6.23 range instruction addresses conditional branches, beqand bne, branch MIPS? Give answer num- ber instructions relative conditional branch instruction.358 CHAPTER SIX ArchitectureChapter 06.qxd 1/31/07 8:21 PM Page 358Exercise 6.24 following questions examine limitations jump instruc- tion, j. Give answer number instructions relative jump instruction. (a) worst case, far jump instruction ( j) jump forward (i.e., higher addresses)? (The worst case jump instruction cannot jump far.) Explain using words examples, needed. (b) best case, far jump instruction ( j) jump forward? (The best case jump instruction jump farthest.) Explain. (c) worst case, far jump instruction ( j) jump backward (to lower addresses)? Explain. (d) best case, far jump instruction ( j) jump backward? Explain. Exercise 6.25 Explain advantageous large address field, addr, machine format jump instructions, jand jal. Exercise 6.26 Write assembly code jumps instruction 64 Minstructions first instruction. Recall 1 Minstruction /H11005220 instructions /H110051,048,576 instructions. Assume code begins address 0x00400000. Use minimum number instructions. Exercise 6.27 Write procedure high-level code takes ten-entry array 32-bit integers stored little-endian format converts big-endian for- mat. writing high-level code, convert MIPS assembly code. Comment code use minimum number instructions. Exercise 6.28 Consider two strings: string1 string2 . (a) Write high-level code procedure called concat concatenates (joins together) two strings: void concat(char[] string1, char[] string2, char[] stringconcat) . procedure return value. concate- nates string1 string2 places resulting string stringconcat . may assume character array stringconcat large enough accommodate concatenated string. (b) Convert procedure part (a) MIPS assembly language. Exercise 6.29 Write MIPS assembly program adds two positive single- precision floating point numbers held $s0and $s1. use MIPS floating-point instructions. need worry encod- ings reserved special purposes (e.g., 0, NANs, INF) numbers overflow underflow. Use SPIM simulator test code. need manually set values $s0and $s1to test code. Demonstrate code functions reliably.Exercises 359Chapter 06.qxd 1/31/07 8:21 PM Page 359Exercise 6.30 Show following MIPS program would loaded memory executed. # MIPS assembly code main: lw $a0, x lw $a1, jal diff jr $ra diff: sub $v0, $a0, $a1 jr $ra (a) First show instruction address next assembly instruction. (b) Draw symbol table showing labels addresses. (c) Convert instructions machine code. (d) big (how many bytes) data text segments? (e) Sketch memory map showing data instructions stored. Exercise 6.31 Show MIPS instructions implement following pseudoinstructions. may use assembler register, $at, may corrupt (overwrite) registers. (a)beq $t1, imm 31:0, L (b)ble $t3, $t5, L (c)bgt $t3, $t5, L (d)bge $t3, $t5, L (e)addi $t0, $2, imm 31:0 (f)lw $t5, imm 31:0($s0) (g)rol $t0, $t1, 5 (rotate $t1left 5 put result $t0) (h)ror $s4, $t6, 31 (rotate $t6right 31 put result $s4)360 CHAPTER SIX ArchitectureChapter 06.qxd 1/31/07 8:21 PM Page 360Interview Questions following exercises present questions asked interviews digital design jobs (but usually open assembly language). Question 6.1 Write MIPS assembly code swapping contents two registers, $t0and $t1. may use registers. Question 6.2 Suppose given array positive negative integers. Write MIPS assembly code finds subset array largest sum. Assume array’s base address number array elements $a0and $a1, respectively. code place resulting subset array starting base address $a2. Write code runs fast possible. Question 6.3 given array holds C string. string forms sentence. Design algorithm reversing words sentence storing new sentence back array. Implement algorithm using MIPS assembly code. Question 6.4 Design algorithm counting number 1’s 32-bit number. Implement algorithm using MIPS assembly code. Question 6.5 Write MIPS assembly code reverse bits register. Use instructions possible. Assume register interest $t3. Question 6.6 Write MIPS assembly code test whether overflow occurs $t2and $t3are added. Use minimum number instructions. Question 6.7 Design algorithm testing whether given string palin- drome. (Recall, palindrome word forward back- ward. example, words “wow” “racecar” palindromes.) Implement algorithm using MIPS assembly code.Interview Questions 361Chapter 06.qxd 1/31/07 8:21 PM Page 3617 7.1 Introduction 7.2 Performance Analysis 7.3 Single-Cycle Processor 7.4 Multicycle Processor 7.5 Pipelined Processor 7.6 HDL Representation* 7.7 Exceptions* 7.8 Advanced Microarchitecture* 7.9 Real-World Perspective: IA-32 Microarchitecture* 7.10 Summary Exercises Interview QuestionsMicroarchitecture 7.1INTRODUCTION chapter, learn piece together MIPS micro- processor. Indeed, puzzle three different versions, different trade-offs performance, cost, complexity. uninitiated, building microprocessor may seem like black magic. actually relatively straightforward, point learned everything need know. Specifically, learned design combinational sequential logic given functional timing specifications. familiar circuits arithmetic memory. learned MIPS architecture, specifies programmer’s view MIPS processor terms registers, instruc- tions, memory. chapter covers microarchitecture , connection logic architecture. Microarchitecture specific arrange- ment registers, ALUs, finite state machines (FSMs), memories, logic building blocks needed implement architecture. par- ticular architecture, MIPS, may many different microarchi- tectures, different trade-offs performance, cost, complexity. run programs, internal designs vary widely. design three different microarchitectures chapter illustrate trade-offs. chapter draws heavily David Patterson John Hennessy’s classic MIPS designs text Computer Organization Design . generously shared elegant designs, virtue illustrating real commercial architecture relatively sim- ple easy understand. 7.1.1 Architectural State Instruction Set Recall computer architecture defined instruction set architectural state . architectural state MIPS processor consists 363Chapter 07.qxd 2/1/07 9:33 PM Page 363of program counter 32 registers. MIPS microarchitecture must contain state. Based current architectural state, processor executes particular instruction particular set data produce new architectural state. microarchitectures contain additional nonarchitectural state either simplify logic improve performance; point arises. keep microarchitectures easy understand, consider subset MIPS instruction set. Specifically, handle following instructions: /L50776R-type arithmetic/logic instructions: add, sub, and, or, slt /L50776Memory instructions: lw, sw /L50776Branches: beq building microarchitectures instructions, extend handle addi j. particular instructions chosen sufficient write many interesting programs. understand implement instructions, expand hardware handle others. 7.1.2 Design Process divide microarchitectures two interacting parts: datapath control . datapath operates words data. contains structures memories, registers, ALUs, multiplexers. MIPS 32-bit architecture, use 32-bit datapath. con- trol unit receives current instruction datapath tells datapath execute instruction. Specifically, control unit produces multiplexer select, register enable, memory write signals control operation datapath. good way design complex system start hardware containing state elements. elements include memories architectural state (the program counter registers). Then, add blocks combinational logic state elements compute new state based current state. instruction read part memory; load store instructions read write data another part memory. Hence, often convenient partition overall memory two smaller memories, one containing instructions containing data. Figure 7.1 shows block diagram four state elements: program counter, register file, instruction data memories. Figure 7.1, heavy lines used indicate 32-bit data busses. Medium lines used indicate narrower busses, 5-bit address busses register file. Narrow blue lines used indicate364 CHAPTER SEVEN Microarchitecture David Patterson first family graduate college (UCLA, 1969). professor computer science UC Berkeley since 1977, coinvented RISC, Reduced Instruction Set Computer. 1984, developed SPARC archi- tecture used Sun Micro- systems. also father RAID (Redundant Array Inexpensive Disks ) (Network Workstations ). John Hennessy president Stanford University professor elec- trical engineering com- puter science since 1977. coinvented RISC. developed MIPS archi- tecture Stanford 1984 cofounded MIPS Compu- ter Systems. 2004, 300 million MIPS micro- processors sold. copious free time, two modern paragons write textbooks recreation relaxation.Chapter 07.qxd 2/1/07 9:33 PM Page 364control signals, register file write enable. use convention throughout chapter avoid cluttering diagrams bus widths. Also, state elements usually reset input put known state start-up. Again, save clutter, reset shown. program counter ordinary 32-bit register. output, PC, points current instruction. input, PC/H11032, indicates address next instruction. instruction memory single read port.1It takes 32-bit instruction address input, A, reads 32-bit data (i.e., instruction) address onto read data output, RD. 32-element /H1100332-bit register file two read ports one write port. read ports take 5-bit address inputs, A1and A2, specifying one 25/H1100532 registers source operands. read 32-bit register values onto read data outputs RD1 RD2, respectively. write port takes 5-bit address input, A3; 32-bit write data input, WD; write enable input, WE3 ; clock. write enable 1, register file writes data specified register rising edge clock. data memory single read/write port. write enable, WE, 1, writes data WD address Aon rising edge clock. write enable 0, reads address Aonto RD. instruction memory, register file, data memory read combinationally . words, address changes, new data appears RDafter propagation delay; clock involved. written rising edge clock. fashion, state system changed clock edge. address, data, write enable must setup sometime clock edge must remain stable hold time clock edge. state elements change state rising edge clock, synchronous sequential circuits. microprocessor is7.1 Introduction 365 Resetting PC least, program counter must reset signal initialize value processor turns on. MIPS processors initialize PC 0xBFC00000 reset begin executing code start operating system (OS). OS loads applica- tion program 0x00400000 begins executing it. simplicity chapter, reset PC 0x00000000 place programs instead. 1This oversimplification used treat instruction memory ROM; real processors, instruction memory must writable OS load new program memory. multicycle microarchitecture described Section 7.4 realistic uses combined memory instructions data read written.CLK AR Instruction MemoryA1 A3 WD3RD2RD1WE3 A2CLK Register FileAR Data Memory WDWE PC PC'CLK 32 32 32 32 3232 3232 32325 5 5 Figure 7.1 State elements MIPS processorChapter 07.qxd 2/1/07 9:33 PM Page 365built clocked state elements combinational logic, synchronous sequential circuit. Indeed, processor viewed giant finite state machine, collection simpler interacting state machines. 7.1.3 MIPS Microarchitectures chapter, develop three microarchitectures MIPS proces- sor architecture: single-cycle, multicycle, pipelined. differ way state elements connected together amount nonarchitectural state. single-cycle microarchitecture executes entire instruction one cycle. easy explain simple control unit. completes operation one cycle, require nonarchitectural state. However, cycle time limited slowest instruction. multicycle microarchitecture executes instructions series shorter cycles. Simpler instructions execute fewer cycles compli- cated ones. Moreover, multicycle microarchitecture reduces hard- ware cost reusing expensive hardware blocks adders memories. example, adder may used several different cycles several purposes carrying single instruction. multicycle microprocessor accomplishes adding several nonarchi- tectural registers hold intermediate results. multicycle processor executes one instruction time, instruction takes multi- ple clock cycles. pipelined microarchitecture applies pipelining single-cycle microarchitecture. therefore execute several instructions simulta- neously, improving throughput significantly. Pipelining must add logic handle dependencies simultaneously executing instruc- tions. also requires nonarchitectural pipeline registers. added logic registers worthwhile; commercial high-performance proces- sors use pipelining today. explore details trade-offs three microarchitec- tures subsequent sections. end chapter, briefly mention additional techniques used get even speed modern high-performance microprocessors. 7.2 PERFORMANCE ANALYSIS mentioned, particular processor architecture many microarchitectures different cost performance trade-offs. cost depends amount hardware required implementa- tion technology. year, CMOS processes pack transistors chip amount money, processors take advantage366 CHAPTER SEVEN MicroarchitectureChapter 07.qxd 2/1/07 9:33 PM Page 366of additional transistors deliver performance. Precise cost calculations require detailed knowledge implementation technol- ogy, general, gates memory mean dollars. section lays foundation analyzing performance. many ways measure performance computer system, marketing departments infamous choosing method makes computer look fastest, regardless whether measurement correlation real world performance. example, Intel Advanced Micro Devices (AMD) sell compati- ble microprocessors conforming IA-32 architecture. Intel Pentium III Pentium 4 microprocessors largely advertised according clock frequency late 1990s early 2000s, Intel offered higher clock frequencies competitors. However, Intel’s main competitor, AMD, sold Athlon microprocessors executed programs faster Intel’s chips clock frequency. consumer do? gimmick-free way measure performance measuring execution time program interest you. computer exe- cutes program fastest highest performance. next best choice measure total execution time collection programs similar plan run; may necessary haven’t written program yet somebody else doesn’t program making measurements. collections programs called benchmarks , execution times programs com- monly published give indication processor performs. execution time program, measured seconds, given Equation 7.1. (7.1) number instructions program depends processor archi- tecture. architectures complicated instructions work per instruction, thus reducing number instructions pro- gram. However, complicated instructions often slower execute hardware. number instructions also depends enormously cleverness programmer. purposes chapter, assume executing known programs MIPS processor, number instructions program constant, independent microarchitecture. number cycles per instruction, often called CPI, num- ber clock cycles required execute average instruction. reciprocal throughput (instructions per cycle, IPC). Different microarchitectures different CPIs. chapter, assumeExecution Time /H11005/H20898# instructions /H20899/H20898cycles instruction /H20899/H20898seconds cycle/H208997.2 Performance Analysis 367Chapter 07.qxd 2/1/07 9:33 PM Page 367we ideal memory system affect CPI. Chapter 8, examine processor sometimes wait memory, increases CPI. number seconds per cycle clock period, Tc. clock period determined critical path logic proces- sor. Different microarchitectures different clock periods. Logic circuit designs also significantly affect clock period. example, carry-lookahead adder faster ripple-carry adder. Manufacturing advances historically doubled transistor speeds every 4–6 years, microprocessor built today much faster one last decade, even microarchitecture logic unchanged. challenge microarchitect choose design minimizes execution time satisfying constraints cost and/or power consumption. microarchitectural decisions affect CPI Tcand influenced logic circuit designs, determining best choice requires careful analysis. many factors affect overall computer perform- ance. example, hard disk, memory, graphics system, network connection may limiting factors make processor performance irrelevant. fastest microprocessor world doesn’t help surfing Internet dial-up connection. factors beyond scope book. 7.3 SINGLE-CYCLE PROCESSOR first design MIPS microarchitecture executes instructions single cycle. begin constructing datapath connecting state elements Figure 7.1 combinational logic execute various instructions. Control signals determine specific instruction carried datapath given time. controller contains combinational logic generates appropriate control signals based current instruction. conclude analyzing performance single-cycle processor. 7.3.1 Single-Cycle Datapath section gradually develops single-cycle datapath, adding one piece time state elements Figure 7.1. new connec- tions emphasized black (or blue, new control signals), hardware already studied shown gray. program counter (PC) register contains address instruction execute. first step read instruction instruction memory. Figure 7.2 shows PC simply connected address input instruction memory. instruction memory reads out, fetches , 32-bit instruction, labeled Instr.368 CHAPTER SEVEN MicroarchitectureChapter 07.qxd 2/1/07 9:33 PM Page 368The processor’s actions depend specific instruction fetched. First work datapath connections lw instruction. consider generalize datapath handle instructions. lwinstruction, next step read source register containing base address. register specified rsfield instruction, Instr 25:21. bits instruction connected address input one register file read ports, A1, shown Figure 7.3. register file reads register value onto RD1. lwinstruction also requires offset. offset stored immediate field instruction, Instr 15:0. 16-bit immedi- ate might either positive negative, must sign-extended 32 bits, shown Figure 7.4. 32-bit sign-extended value called SignImm . Recall Section 1.4.6 sign extension simply copies sign bit (most significant bit) short input upper bits longer output. Specifically, SignImm 15:0/H11005Instr 15:0 SignImm 31:16 /H11005Instr 15.7.3 Single-Cycle Processor 369 CLK RD Instruction MemoryA1 A3 WD3RD2RD1WE3 A2CLK Register FilePCPC'Instr RD Data Memory WDWECLK Figure 7.2 Fetch instruction memory InstrCLK AR Instruction MemoryA1 A3 WD3RD2RD1WE3 A2CLK Register FilePC PC'25:21 AR Data Memory WDWECLK Figure 7.3 Read source operand register file SignImmCLK AR Instruction MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister FilePC PC' Instr25:21 15:0AR Data Memory WDWECLK Figure 7.4 Sign-extend immediateChapter 07.qxd 2/1/07 9:33 PM Page 369The processor must add base address offset find address read memory. Figure 7.5 introduces ALU perform addition. ALU receives two operands, SrcA SrcB. SrcA comes register file, SrcB comes sign-extended immediate. ALU perform many operations, described Section 5.2.4. 3-bit ALUControl signal specifies operation. ALU generates 32-bit ALUResult Zero flag, indicates whether ALUResult /H11005/H110050. lwinstruction, ALUControl signal set 010 add base address offset. ALUResult sent data memory address load instruction, shown Figure 7.5. data read data memory onto ReadData bus, written back destination register register file end cycle, shown Figure 7.6. Port 3 register file the370 CHAPTER SEVEN Microarchitecture SignImmCLK AR Instruction MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister FileAR Data Memory WDWE PC PC' Instr25:21 15:0SrcBALUResultSrcA ZeroCLKALUControl 2:0 010ALU Figure 7.5 Compute memory address A1 A3 WD3RD2RD1WE3 A2 SignImmCLK AR Instruction MemoryCLK Sign ExtendRegister FileAR Data Memory WDWE PC PC' Instr25:21 15:0SrcB 20:16ALUResult ReadDataSrcARegWrite ZeroCLKALUControl 2:0 010 1 ALU Figure 7.6 Write data back register fileChapter 07.qxd 2/1/07 9:33 PM Page 370write port. destination register lwinstruction specified rtfield, Instr 20:16, connected port 3 address input, A3, register file. ReadData bus connected port 3 write data input, WD3 , register file. control signal called RegWrite connected port 3 write enable input, WE3 , asserted lwinstruction data value written register file. write takes place rising edge clock end cycle. instruction executed, processor must compute address next instruction, PC/H11032. instructions 32 bits /H110054 bytes, next instruction PC/H110014. Figure 7.7 uses another adder increment PCby 4. new address written program counter next rising edge clock. completes datapath lwinstruction. Next, let us extend datapath also handle swinstruction. Like lwinstruction, swinstruction reads base address port 1 register sign-extends immediate. ALU adds base address immediate find memory address. func- tions already supported datapath. swinstruction also reads second register register file writes data memory. Figure 7.8 shows new connections function. register specified rtfield, Instr 20:16. bits instruction connected second register file read port, A2. register value read onto RD2 port. connected write data port data memory. write enable port data memory, WE, controlled MemWrite . swinstruction, MemWrite /H110051, write data memory; ALUControl /H11005010, add base address7.3 Single-Cycle Processor 371 CLK SignImmAR Instruction Memory 4A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister FileAR Data Memory WDWE PC PC' Instr25:21 15:0SrcB 20:16ALUResult ReadDataSrcA PCPlus4 ResultRegWrite ZeroCLKALUControl 2:0 010 1 ALU + Figure 7.7 Determine address next instruction PCChapter 07.qxd 2/1/07 9:33 PM Page 371and offset; RegWrite /H110050, nothing written register file. Note data still read address given data memory, ReadData ignored RegWrite /H110050. Next, consider extending datapath handle R-type instruc- tions add, sub, and, or, slt. instructions read two regis- ters register file, perform ALU operation them, write result back third register file. differ spe- cific ALU operation. Hence, handled hard- ware, using different ALUControl signals. Figure 7.9 shows enhanced datapath handling R-type instruc- tions. register file reads two registers. ALU performs opera- tion two registers. Figure 7.8, ALU always received SrcB operand sign-extended immediate ( SignImm ). Now, add multiplexer choose SrcB either register file RD2 port SignImm . multiplexer controlled new signal, ALUSrc . ALUSrc 0 R-type instructions choose SrcB register file; 1 lw swto choose SignImm . principle enhancing datapath’s capabilities adding multiplexer choose inputs several possi- bilities extremely useful. Indeed, apply twice com- plete handling R-type instructions. Figure 7.8, register file always got write data data memory. However, R-type instructions write ALUResult register file. Therefore, add another multiplexer choose ReadData ALUResult . call output Result . multi- plexer controlled another new signal, MemtoReg . MemtoReg 0372 CHAPTER SEVEN Microarchitecture SignImmCLK AR Instruction Memory 4A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister FileAR Data Memory WDWE PC PC' Instr25:21 20:16 15:0SrcB 20:16ALUResult ReadData WriteDataSrcA PCPlus4 ResultMemWrite RegWrite ZeroCLKALUControl2:0 1 010 0 ALU + Figure 7.8 Write data memory swinstructionChapter 07.qxd 2/1/07 9:33 PM Page 372for R-type instructions choose Result ALUResult ; 1 lwto choose ReadData . don’t care value MemtoReg sw, swdoes write register file. Similarly, Figure 7.8, register write specified rt field instruction, Instr 20:16. However, R-type instructions, register specified rdfield, Instr 15:11. Thus, add third mul- tiplexer choose WriteReg appropriate field instruc- tion. multiplexer controlled RegDst . RegDst 1 R-type instructions choose WriteReg rdfield, Instr 15:11; 0 lwto choose rtfield, Instr 20:16. don’t care value RegDst sw, swdoes write register file. Finally, let us extend datapath handle beq. beq compares two registers. equal, takes branch adding branch offset program counter. Recall offset positive nega- tive number, stored immfield instruction, Instr 31:26. off- set indicates number instructions branch past. Hence, immediate must sign-extended multiplied 4 get new program counter value: PC/H11032/H11005PC/H110014/H11001SignImm /H110034. Figure 7.10 shows datapath modifications. next PCvalue taken branch, PCBranch , computed shifting SignImm left 2 bits, adding PCPlus4 . left shift 2 easy way multiply 4, shift constant amount involves wires. two registers compared computing SrcA /H11002SrcB using ALU. ALUResult 0, indicated Zero flag ALU, registers equal. add multiplexer choose PC/H11032from either PCPlus4 PCBranch . PCBranch selected instruction is7.3 Single-Cycle Processor 373 SignImmCLK AR Instruction Memory 4+A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File 0 10 1AR Data Memory WDWE 0 1PC PC' Instr25:21 20:16 15:0SrcB 20:16 15:11ALUResult ReadData WriteDataSrcA PCPlus4WriteReg 4:0 ResultRegDst MemWrite MemtoReg ALUSrc RegWrite ZeroCLKALUControl 2:0 0varies 1 0 0 1 ALU Figure 7.9 Datapath enhancements R-type instructionChapter 07.qxd 2/1/07 9:33 PM Page 373a branch Zero flag asserted. Hence, Branch 1 beqand 0 instructions. beq, ALUControl /H11005110, ALU performs subtraction. ALUSrc /H110050 choose SrcB register file. RegWrite MemWrite 0, branch write register file memory. don’t care values RegDst MemtoReg , register file written. completes design single-cycle MIPS processor data- path. illustrated design itself, also design process state elements identified combinational logic connecting state elements systematically added. next section, consider compute control signals direct operation datapath. 7.3.2 Single-Cycle Control control unit computes control signals based opcode funct fields instruction, Instr 31:26 Instr 5:0. Figure 7.11 shows entire single-cycle MIPS processor control unit attached datapath. control information comes opcode , R-type instructions also use funct field determine ALU operation. Thus, simplify design factoring control unit two blocks combinational logic, shown Figure 7.12. main decoder computes outputs opcode . also deter- mines 2-bit ALUOp signal. ALU decoder uses ALUOp signal conjunction funct field compute ALUControl . mean- ing ALUOp signal given Table 7.1.374 CHAPTER SEVEN Microarchitecture SignImmCLK AR Instruction Memory 4+ +A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File 0 10 1AR Data Memory WDWE 0 1PC 0 1PC'Instr25:21 20:16 15:0SrcB 20:16 15:11 <<2ALUResult ReadData WriteDataSrcA PCPlus4 PCBranchWriteReg 4:0 ResultRegDst Branch MemWrite MemtoReg ALUSrc RegWrite ZeroPCSrc CLKALUControl 2:0 0110 0 x 0 x 1ALU Figure 7.10 Datapath enhancements beq instruction RegDstBranchMemWriteMemtoReg ALUSrcOpcode5:0Control Unit ALUControl 2:0 Funct5:0Main Decoder ALUOp 1:0 ALU DecoderRegWrite Figure 7.12 Control unit internal structureChapter 07.qxd 2/1/07 9:33 PM Page 3747.3 Single-Cycle Processor 375 SignImmCLK AR Instruction Memory 4A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File 0 10 1AR Data Memory WDWE 0 1PC 0 1PC' Instr25:21 20:16 15:05:0 SrcB 20:16 15:11 <<2ALUResult ReadData WriteDataSrcA PCPlus4 PCBranch++WriteReg 4:0 Result31:26 RegDstBranchMemWriteMemtoReg ALUSrc RegWriteOp FunctControl Unit ZeroPCSrc CLKALUControl 2:0 ALU Figure 7.11 Complete single-cycle MIPS processor Table 7.1 ALUOp encoding ALUOp Meaning 00 add 01 subtract 10 look funct field 11 n/a Table 7.2 truth table ALU decoder. Recall mean- ings three ALUControl signals given Table 5.1. ALUOp never 11, truth table use don’t care’s X1 1X instead 01 10 simplify logic. ALUOp 00 01, ALU add subtract, respectively. ALUOp 10, decoder examines funct field determine ALUControl . Note that, R-type instructions implement, first two bits funct field always 10, may ignore simplify decoder. control signals instruction described built datapath. Table 7.3 truth table main decoder sum- marizes control signals function opcode. R-type instructions use main decoder values; differ theChapter 07.qxd 2/1/07 9:33 PM Page 375ALU decoder output. Recall that, instructions write register file (e.g., swand beq), RegDst MemtoReg control signals don’t cares (X); address data register write port matter RegWrite asserted. logic decoder designed using favorite techniques combina- tional logic design. Example 7.1 SINGLE-CYCLE PROCESSOR OPERATION Determine values control signals portions datapath used executing orinstruction. Solution: Figure 7.13 illustrates control signals flow data execution orinstruction. PC points memory location holding instruction, instruction memory fetches instruction. main flow data register file ALU represented dashed blue line. register file reads two source operands specified Instr 25:21 Instr 20:16. SrcB come second port register376 CHAPTER SEVEN Microarchitecture Table 7.2 ALU decoder truth table ALUOp Funct ALUControl 00 X 010 (add) X1 X 110 (subtract) 1X 100000 ( add) 010 (add) 1X 100010 ( sub) 110 (subtract) 1X 100100 ( and) 000 (and) 1X 100101 ( or) 001 (or) 1X 101010 ( slt) 111 (set less than) Table 7.3 Main decoder truth table Instruction Opcode RegWrite RegDst ALUSrc Branch MemWrite MemtoReg ALUOp R-type 000000 1 1 0 0 0 0 10 lw 100011 1 0 1 0 0 1 00 sw 101011 0 X 1 0 1 X 00 beq 000100 0 X 0 1 0 X 01Chapter 07.qxd 2/1/07 9:33 PM Page 376file (not SignImm ), ALUSrc must 0. oris R-type instruction, ALUOp 10, indicating ALUControl determined funct field 001. Result taken ALU, MemtoReg 0. result written register file, RegWrite 1. instruction write memory, MemWrite /H110050. selection destination register also shown dashed blue line. destination register specified rdfield, Instr 15:11, RegDst /H110051. updating PC shown dashed gray line. instruction branch, Branch /H110050 and, hence, PCSrc also 0. PC gets next value PCPlus4 . Note data certainly flow nonhighlighted paths, value data unimportant instruction. example, immediate sign-extended data read memory, values influence next state system. 7.3.3 Instructions considered limited subset full MIPS instruction set. Adding support addi jinstructions illustrates principle handle new instructions also gives us sufficiently rich instruction set write many interesting programs. see that7.3 Single-Cycle Processor 377 SignImmCLK AR Instruction Memory 4+ +A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File 0 10 1AR Data Memory WDWE 0 1PC 1Instr25:21 20:16 15:05:0 SrcB 20:16 15:11 <<2ALUResult ReadData WriteDataSrcA PCPlus4 PCBranchWriteReg 4:0 Result31:26 RegDstBranchMemWriteMemtoReg ALUSrc RegWriteOp FunctControl Unit ZeroPCSrc CLKALUControl 2:0 001 0 010 0 10ALU0PC' Figure 7.13 Control signals data flow executing orinstructionChapter 07.qxd 2/1/07 9:33 PM Page 377supporting instructions simply requires enhancing main decoder, whereas supporting others also requires hardware datapath. Example 7.2 addi INSTRUCTION add immediate instruction, addi, adds value register immedi- ate writes result another register. datapath already capable task. Determine necessary changes controller support addi. Solution: need add new row main decoder truth table showing control signal values addi, given Table 7.4. result written register file, RegWrite /H110051. destination register specified rtfield instruction, RegDst /H110050. SrcB comes immediate, ALUSrc /H110051. instruction branch, write memory, Branch /H11005MemWrite /H110050. result comes ALU, memory, MemtoReg /H110050. Finally, ALU add, ALUOp /H1100500.378 CHAPTER SEVEN Microarchitecture Table 7.4 Main decoder truth table enhanced support addi Instruction Opcode RegWrite RegDst ALUSrc Branch MemWrite MemtoReg ALUOp R-type 000000 1 1 0 0 0 0 10 lw 100011 1 0 1 0 0 1 00 sw 101011 0 X 1 0 1 X 00 beq 000100 0 X 0 1 0 X 01 addi 001000 1 0 1 0 0 0 00 Example 7.3 jINSTRUCTION jump instruction, j, writes new value PC. two least signifi- cant bits PC always 0, PC word aligned (i.e., always multiple 4). next 26 bits taken jump address field Instr 25:0. upper four bits taken old value PC. existing datapath lacks hardware compute PC/H11032in fashion. Determine necessary changes datapath controller handle j. Solution: First, must add hardware compute next PC value, PC/H11032, case jinstruction multiplexer select next PC, shown Figure 7.14. new multiplexer uses new Jump control signal.Chapter 07.qxd 2/1/07 9:33 PM Page 378Now must add row main decoder truth table jinstruction column Jump signal, shown Table 7.5. Jump control signal 1 jinstruction 0 others. jdoes write register file memory, RegWrite /H11005MemWrite /H110050. Hence, don’t care computation done datapath, RegDst /H11005ALUSrc /H11005Branch /H11005 MemtoReg /H11005ALUOp /H11005X.7.3 Single-Cycle Processor 379 SignImmCLK AR Instruction Memory 4+ +A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File 0 10 1AR Data Memory WDWE 0 1PC0 1PC'Instr25:21 20:16 15:05:0 SrcB 20:16 15:11 <<2ALUResult ReadData WriteDataSrcA PCPlus4 PCBranchWriteReg 4:0Result31:26 RegDstBranchMemWriteMemtoReg ALUSrc RegWriteOp FunctControl Unit ZeroPCSrc CLKALUControl 2:0 0 1 25:0<<227:0 31:28PCJumpJump ALU Figure 7.14 Single-cycle MIPS datapath enhanced support jinstruction Table 7.5 Main decoder truth table enhanced support j Instruction Opcode RegWrite RegDst ALUSrc Branch MemWrite MemtoReg ALUOp Jump R-type 000000 1 1 0 0 0 0 10 0 lw 100011 1 0 1 0 0 1 00 0 sw 101011 0 X 1 0 1 X 00 0 beq 000100 0 X 0 1 0 X 01 0 addi 001000 1 0 1 0 0 0 00 0 j 000010 0 X X X 0 X XX 1Chapter 07.qxd 2/1/07 9:33 PM Page 3797.3.4 Performance Analysis instruction single-cycle processor takes one clock cycle, CPI 1. critical path lwinstruction shown Figure 7.15 heavy dashed blue line. starts PC loading new address rising edge clock. instruction memory reads next instruction. register file reads SrcA. register file reading, immediate field sign-extended selected ALUSrc multi- plexer determine SrcB. ALU adds SrcA SrcB find effec- tive address. data memory reads address. MemtoReg multiplexer selects ReadData . Finally, Result must setup register file next rising clock edge, properly written. Hence, cycle time (7.2) implementation technologies, ALU, memory, register file accesses substantially slower operations. Therefore, cycle time simplifies (7.3) numerical values times depend specific implemen- tation technology.Tc/H11005tpcq/H11002PC/H110012tmem /H11001tRFread/H110012tmux/H11001tALU/H11001tRFsetup/H11001tALU/H11001tmem/H11001tmux/H11001tRFsetupTc/H11005tpcq/H11002PC/H11001tmem/H11001max[ tRFread, tsext]/H11001tmux380 CHAPTER SEVEN Microarchitecture SignImmCLK AR Instruction Memory 4A1 A3 WD3RD1WE3CLK Register File 0 10 1AR Data Memory WDWE 0 1PC 0 1PC' Instr25:21 20:16 15:05:0 SrcB 20:16 15:11 <<2ALUResult ReadData WriteDataSrcA PCPlus4 PCBranch++WriteReg 4:0 Result31:26 RegDstBranchMemWriteMemtoReg ALUSrc RegWriteOp FunctControl Unit ZeroPCSrc CLKALUControl 2:0 1010 0 1 0100ALU RD2 A2 Sign Extend Figure 7.15 Critical path lwinstructionChapter 07.qxd 2/1/07 9:33 PM Page 380Other instructions shorter critical paths. example, R-type instructions need access data memory. However, disciplining synchronous sequential design, clock period constant must long enough accommodate slowest instruction. Example 7.4 SINGLE-CYCLE PROCESSOR PERFORMANCE Ben Bitdiddle contemplating building single-cycle MIPS processor 65 nm CMOS manufacturing process. determined logic elements delays given Table 7.6. Help compare execution time program 100 billion instructions. Solution: According Equation 7.3, cycle time single-cycle processor Tc1/H1100530/H110012(250) /H11001150 /H110012(25) /H11001200 /H1100120/H11005950 ps. use subscript “1” distinguish subsequent processor designs. According Equation 7.1, total execution time T1/H11005(100 /H11003109instructions)(1 cycle/instruction) (950 /H1100310/H1100212s/cycle) /H1100595 seconds.7.4 Multicycle Processor 381 Table 7.6 Delays circuit elements Element Parameter Delay (ps) register clk-to-Q pcq 30 register setup tsetup 20 multiplexer mux 25 ALU ALU 200 memory read mem 250 register file read RFread 150 register file setup RFsetup 20 7.4 MULTICYCLE PROCESSOR single-cycle processor three primary weaknesses. First, requires clock cycle long enough support slowest instruction (lw), even though instructions faster. Second, requires three adders (one ALU two PC logic); adders relatively expensive circuits, especially must fast. third, sepa- rate instruction data memories, may realistic. computers single large memory holds instructions data read written.Chapter 07.qxd 2/1/07 9:33 PM Page 381The multicycle processor addresses weaknesses breaking instruction multiple shorter steps. short step, processor read write memory register file use ALU. Different instructions use different numbers steps, simpler instructions complete faster complex ones. processor needs one adder; adder reused different purposes various steps. processor uses combined memory instructions data. instruction fetched memory first step, data may read written later steps. design multicycle processor following procedure used single-cycle processor. First, construct datapath con- necting architectural state elements memories combinational logic. But, time, also add nonarchitectural state elements hold intermediate results steps. design controller. controller produces different signals different steps execution single instruction, finite state machine rather com- binational logic. examine add new instructions processor. Finally, analyze performance multicycle processor compare single-cycle processor. 7.4.1 Multicycle Datapath Again, begin design memory architectural state MIPS processor, shown Figure 7.16. single-cycle design, used separate instruction data memories needed read instruction memory read write data memory one cycle. Now, choose use combined memory instructions data. realistic, feasible read instruction one cycle, read write data separate cycle. PC register file remain unchanged. gradually build datapath adding components handle step instruction. new connections emphasized black (or blue, new control signals), whereas hardware already studied shown gray. PC contains address instruction execute. first step read instruction instruction memory. Figure 7.17 shows PC simply connected address input instruc- tion memory. instruction read stored new nonarchitectural382 CHAPTER SEVEN Microarchitecture CLK ARD Instr/Data MemoryPC PC' WDWECLK ENA1 A3 WD3RD2RD1WE3 A2CLK Register FileFigure 7.16 State elements unified instruction/data memoryChapter 07.qxd 2/1/07 9:33 PM Page 382Instruction Register available future cycles. Instruction Register receives enable signal, called IRWrite , asserted updated new instruction. single-cycle processor, work data- path connections lwinstruction. enhance data- path handle instructions. lwinstruction, next step read source register containing base address. register specified rsfield instruction, Instr 25:21. bits instruction connected one address inputs, A1, register file, shown Figure 7.18. register file reads register onto RD1 . value stored another nonarchitectural register, A. lwinstruction also requires offset. offset stored immediate field instruction, Instr 15:0and must sign- extended 32 bits, shown Figure 7.19. 32-bit sign-extended value called SignImm . consistent, might store SignImm another nonarchitectural register. However, SignImm combina- tional function Instr change current instruc- tion processed, need dedicate register hold constant value. address load sum base address offset. use ALU compute sum, shown Figure 7.20. ALUControl set 010 perform addition. ALUResult stored nonarchitectural register called ALUOut . next step load data calculated address memory. add multiplexer front memory choose the7.4 Multicycle Processor 383 PC InstrCLK ENIRWrite CLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Register FilePC' WDWECLK Figure 7.17 Fetch instruction memory CLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Register FilePC PC' Instr25:21CLK WDWECLK CLK ENIRWrite Figure 7.18 Read source operand register fileChapter 07.qxd 2/1/07 9:33 PM Page 383384 CHAPTER SEVEN Microarchitecture SignImmCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister FilePC PC' Instr25:21 15:0CLK WDWECLK CLK ENIRWrite Figure 7.19 Sign-extend immediate SignImmCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister FilePC PC' Instr25:21 15:0SrcBALUResultSrcA ALUOutCLKALUControl 2:0 WDWECLK CLK ACLK ENIRWrite ALU Figure 7.20 Add base address offset SignImmCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister FilePC PC' Instr25:21 15:0SrcBALUResultSrcA ALUOutCLKALUControl 2:0 WDWECLK Adr DataCLKCLK ACLK ENIRWrite IorD 0 1 ALU Figure 7.21 Load data memoryChapter 07.qxd 2/1/07 9:33 PM Page 384memory address, Adr, either PC ALUOut , shown Figure 7.21. multiplexer select signal called IorD , indicate either instruction data address. data read memory stored another nonarchitectural register, called Data . Notice address multiplexer permits us reuse memory lw instruction. first step, address taken PC fetch instruction. later step, address taken ALUOut load data. Hence, IorD must different values different steps. Section 7.4.2, develop FSM controller generates sequences control signals. Finally, data written back register file, shown Figure 7.22. destination register specified rtfield instruction, Instr 20:16. happening, processor must update program counter adding 4 old PC. single-cycle processor, sepa- rate adder needed. multicycle processor, use exist- ing ALU one steps busy. so, must insert source multiplexers choose PC constant 4 ALU inputs, shown Figure 7.23. two-input multiplexer controlled ALUSrcA chooses either PC register Aas SrcA. four-input mul- tiplexer controlled ALUSrcB chooses either 4 SignImm SrcB. use two multiplexer inputs later extend data- path handle instructions. (The numbering inputs mul- tiplexer arbitrary.) update PC, ALU adds SrcA (PC) SrcB (4), result written program counter register. PCWrite control signal enables PC register written certain cycles.7.4 Multicycle Processor 385 SignImmbCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister FilePC PC' Instr25:21 15:0SrcB 20:16ALUResultSrcA ALUOutRegWrite CLKALUControl2:0 WDWECLK Adr DataCLKCLK ACLK ENIRWrite IorD 0 1 ALU Figure 7.22 Write data back register fileChapter 07.qxd 2/1/07 9:33 PM Page 385This completes datapath lwinstruction. Next, let us extend datapath also handle swinstruction. Like lw instruction, swinstruction reads base address port 1 register file sign-extends immediate. ALU adds base address immediate find memory address. func- tions already supported existing hardware datapath. new feature swis must read second register register file write memory, shown Figure 7.24. register specified rtfield instruction, Instr 20:16, connected second port register file. register read, stored nonarchitectural register, B. next step, sent write data port ( WD) data memory written. memory receives additional MemWrite control signal indicate write occur.386 CHAPTER SEVEN Microarchitecture PCWrite SignImmbCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File0 1 PC PC' Instr25:21 15:0SrcB 20:16ALUResultSrcA ALUOutALUSrcA RegWrite CLKALUControl2:0 WDWECLK Adr DataCLKCLK 00 01 10 114CLK EN ENALUSrcB1:0IRWrite IorD 0 1 ALU Figure 7.23 Increment PC 4 SignImmCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File0 1 PC0 1PC' Instr25:21 20:16 15:0SrcB 20:16ALUResultSrcA ALUOutMemWrite ALUSrcA RegWrite CLKALUControl 2:0 WDWECLK Adr DataCLKCLK 00 01 10 114CLK EN ENALUSrcB 1:0 IRWrite IorD PCWrite B ALU Figure 7.24 Enhanced datapath swinstructionChapter 07.qxd 2/1/07 9:33 PM Page 3867.4 Multicycle Processor 387 0 1 SignImmbCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File0 10 1 PC0 1PC' Instr25:21 20:16 15:0SrcB20:16 15:11ALUResultSrcA ALUOutRegDst MemWrite MemtoReg ALUSrcA RegWrite CLKALUControl 2:0 WDWECLK Adr DataCLKCLK B00 01 10 114CLK EN ENALUSrcB 1:0 IRWrite IorD PCWrite ALU Figure 7.25 Enhanced datapath R-type instructions R-type instructions, instruction fetched, two source registers read register file. Another input SrcB multiplexer used choose register Bas second source regis- ter ALU, shown Figure 7.25. ALU performs appro- priate operation stores result ALUOut . next step, ALUOut written back register specified rdfield instruction, Instr 15:11. requires two new multiplexers. MemtoReg multiplexer selects whether WD3 comes ALUOut (for R-type instructions) Data (for lw). RegDst instruction selects whether destination register specified rtor rdfield instruction. beqinstruction, instruction fetched, two source registers read register file. determine whether registers equal, ALU subtracts registers examines Zero flag. Meanwhile, datapath must compute next value PC branch taken: PC/H11032/H11005PC/H110014/H11001SignImm /H110034. single-cycle processor, yet another adder needed compute branch address. multicycle processor, ALU reused save hard- ware. one step, ALU computes PC/H110014 writes back program counter, done instructions. another step, ALU uses updated PC value compute PC/H11001SignImm /H110034. SignImm left-shifted 2 multiply 4, shown Figure 7.26. SrcB multiplexer chooses value adds PC. sum represents destination branch stored ALUOut . new multiplexer, controlled PCSrc , chooses signal sent PC/H11032. program counter written either PCWrite asserted branch taken. new control signal, Branch , indi- cates beqinstruction executed. branch taken Zero also asserted. Hence, datapath computes new PC writeChapter 07.qxd 2/1/07 9:33 PM Page 387enable, called PCEn , TRUE either PCWrite asserted Branch Zero asserted. completes design multicycle MIPS processor data- path. design process much like single-cycle processor hardware systematically connected state elements handle instruction. main difference instruction executed several steps. Nonarchitectural registers inserted hold results step. way, ALU reused several times, saving cost extra adders. Similarly, instructions data stored one shared memory. next section, develop FSM controller deliver appropriate sequence control signals datapath step instruction. 7.4.2 Multicycle Control single-cycle processor, control unit computes control signals based opcode funct fields instruction, Instr 31:26 Instr 5:0. Figure 7.27 shows entire multicycle MIPS processor control unit attached datapath. datapath shown black, control unit shown blue. single-cycle processor, control unit partitioned main controller ALU decoder, shown Figure 7.28. ALU decoder unchanged follows truth table Table 7.2. Now, however, main controller FSM applies proper control signals proper cycles steps. sequence control signals depends instruction executed. remainder section, develop FSM state transition diagram main controller.388 CHAPTER SEVEN Microarchitecture SignImmbCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File0 10 10 1PC0 1PC' Instr25:21 20:16 15:0SrcB 20:16 15:11 <<2ALUResultSrcA ALUOutRegDst Branch MemWrite MemtoReg ALUSrcA RegWrite ZeroPCSrc CLKALUControl 2:0 WDWECLK Adr 0 1DataCLKCLK B00 01 10 114CLK EN ENALUSrcB 1:0 IRWrite IorD PCWritePCEnALU Figure 7.26 Enhanced datapath beq instructionChapter 07.qxd 2/1/07 9:33 PM Page 388The main controller produces multiplexer select register enable signals datapath. select signals MemtoReg, RegDst, IorD, PCSrc, ALUSrcB , ALUSrcA . enable signals IRWrite, MemWrite, PCWrite, Branch , RegWrite . keep following state transition diagrams readable, relevant control signals listed. Select signals listed value matters; otherwise, don’t cares. Enable signals listed asserted; otherwise, 0.7.4 Multicycle Processor 389 SignImmCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File0 10 10 1PC0 1PC' Instr25:21 20:16 15:05:0 SrcB 20:16 15:11 <<2ALUResultSrcA ALUOut31:26tsDgeRBranch MemWritegeRotmeMALUSrcA RegWriteOp FunctControl Unit ZeroPCSrcCLK CLKALUControl2:0 ULA WDWECLK Adr 0 1DataCLKCLK B00 01 10 114CLK EN ENALUSrcB1:0 IRWriteIorDPCWrite PCEn Figure 7.27 Complete multicycle MIPS processor ALUSrcAPCSrc BranchALUSrcB1:0 Opcode5:0Control Unit ALUControl2:0Funct5:0Main Controller (FSM) ALUOp1:0 ALU DecoderRegWritePCWriteIorD MemWriteIRWriteRegDstMemtoReg Register EnablesMultiplexer Selects Figure 7.28 Control unit internal structureChapter 07.qxd 2/1/07 9:33 PM Page 389The first step instruction fetch instruction memory address held PC. FSM enters state reset. read memory, IorD /H110050, address taken PC. IRWrite asserted write instruction instruction register, IR. Meanwhile, PC incremented 4 point next instruction. ALU used anything else, processor use compute PC/H110014 time fetches instruction. ALUSrcA /H110050, SrcA comes PC. ALUSrcB /H11005 01, SrcB constant 4. ALUOp /H1100500, ALU decoder produces ALUControl /H11005010 make ALU add. update PC new value, PCSrc /H110050, PCWrite asserted. control signals shown Figure 7.29. data flow step shown Figure 7.30, instruction fetch shown using dashed blue line PC increment shown using dashed gray line. next step read register file decode instruction. register file always reads two sources specified rsand rt fields instruction. Meanwhile, immediate sign-extended. Decoding involves examining opcode instruction determine next. control signals necessary decode instruc- tion, FSM must wait 1 cycle reading decoding complete, shown Figure 7.31. new state highlighted blue. data flow shown Figure 7.32.390 CHAPTER SEVEN Microarchitecture ResetS0: Fetch PCWriteIorD = 0 AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWrite Figure 7.29 Fetch ALU SignImmCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File0 10 10 1PC0 1PC' Instr25:21RegDstMemtoReg 20:16 15:05:0 SrcB 20:16 15:11 <<2ALUResultSrcA ALUOut31:26Branch MemWrite ALUSrcA RegWriteOp FunctControl Unit ZeroPCSrcCLK CLKALUControl2:0 WDWECLK Adr 0 1DataCLKCLK B00 01 10 114CLK EN ENALUSrcB1:0 IRWriteIorDPCWrite PCEn 0 110 X X00 0101001 0 Figure 7.30 Data flow fetch stepChapter 07.qxd 2/1/07 9:33 PM Page 390Now FSM proceeds one several possible states, depending opcode . instruction memory load store ( lwor sw), multicycle processor computes address adding base address sign-extended immediate. requires ALUSrcA /H110051 select register Aand ALUSrcB /H1100510 select SignImm . ALUOp /H1100500, ALU adds. effective address stored ALUOut register use next step. FSM step shown Figure 7.33, data flow shown Figure 7.34. instruction lw, multicycle processor must next read data memory write register file. two steps shown Figure 7.35. read memory, IorD /H110051 select memory address computed saved ALUOut . address memory read saved Data register step S3. next step, S4, Data written register file. MemtoReg /H110051 select7.4 Multicycle Processor 391 ResetS0: Fetch S1: Decode PCWriteIorD = 0 AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWriteFigure 7.31 Decode SignImmCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File0 10 10 1PC0 1PC' Instr25:21 20:16 15:05:0 SrcB 20:16 15:11 <<2ALUResultSrcA ALUOut31:26Branch MemWrite ALUSrcA RegWrite MemtoReg RegDstOp FunctControl Unit ZeroPCSrcCLK CLKALUControl2:0 WDWECLK Adr 0 1DataCLKCLK B00 01 10 114CLK EN ENALUSrcB1:0 IRWriteIorDPCWrite PCEn X 000 X X0X XXXXXX0 0ALU Figure 7.32 Data flow decode stepChapter 07.qxd 2/1/07 9:33 PM Page 391Data , RegDst /H110050 pull destination register rtfield instruction. RegWrite asserted perform write, completing lwinstruction. Finally, FSM returns initial state, S0, fetch next instruction. subsequent steps, try visual- ize data flow own. state S2, instruction sw, data read second port register file simply written memory. IorD /H110051 select address computed S2 saved ALUOut. MemWrite asserted write memory. Again, FSM returns S0 fetch next instruction. added step shown Figure 7.36.392 CHAPTER SEVEN Microarchitecture ALUSrcA = 1ResetS0: Fetch S2: MemAdrS1: Decode Op = LW Op = SWPCWriteIorD = 0 AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWrite ALUOp = 00ALUSrcB = 10Figure 7.33 Memory address computation SignImmCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File0 10 10 1PC0 1PC' Instr25:21 20:16 15:05:0 SrcB 20:16 15:11 <<2ALUResultSrcA ALUOut31:26Branch MemWrite ALUSrcA RegWrite MemtoReg RegDstOp FunctControl Unit ZeroPCSrcCLK CLKALUControl2:0 WDWECLK Adr 0 1DataCLKCLK B00 01 10 114CLK EN ENALUSrcB1:0 IRWriteIorDPCWrite PCEn X 000 X X01 10010X0 0ALU Figure 7.34 Data flow memory address computationChapter 07.qxd 2/1/07 9:33 PM Page 392If opcode indicates R-type instruction, multicycle proces- sor must calculate result using ALU write result register file. Figure 7.37 shows two steps. S6, instruction executed selecting Aand Bregisters ( ALUSrcA /H110051, ALUSrcB /H11005 00) performing ALU operation indicated funct field instruction. ALUOp /H1100510 R-type instructions. ALUResult stored ALUOut . S7, ALUOut written regis- ter file, RegDst /H110051, destination register specified rdfield instruction. MemtoReg /H110050 write data, WD3 , comes ALUOut. RegWrite asserted write register file. beq instruction, processor must calculate destination address compare two source registers determine whether branch taken. requires two uses ALU hence might seem demand two new states. Notice, however, ALU used S1 registers read. processor might well use ALU time compute destination address adding incremented PC, PC/H110014, SignImm /H110034, shown in7.4 Multicycle Processor 393 IorD = 1ResetS0: Fetch S2: MemAdrS1: Decode S3: MemReadOp = LW Op = SW Op = LW S4: Mem WritebackPCWriteIorD = 0 AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWrite ALUSrcA = 1 ALUOp = 00ALUSrcB = 10 RegDst = 0 MemtoReg = 1 RegWriteFigure 7.35 Memory readChapter 07.qxd 2/1/07 9:33 PM Page 393Figure 7.38 (see page 396). ALUSrcA /H110050 select incremented PC, ALUSrcB /H1100511 select SignImm /H110034, ALUOp /H1100500 add. destination address stored ALUOut . instruction beq, computed address used subsequent cycles, computa- tion harmless. S8, processor compares two registers sub- tracting checking determine whether result 0. is, processor branches address computed. ALUSrcA /H110051 select register A;ALUSrcB /H1100500 select register B; ALUOp /H1100501 subtract; PCSrc /H110051 take destination address ALUOut , Branch /H110051 update PC address ALU result 0.2 Putting steps together, Figure 7.39 shows complete main controller state transition diagram multicycle pr ocessor (see page 397). Converting hardware straightforward tedious task using techniques Chapter 3. Better yet, FSM coded HDL synthesized using techniques Chapter 4.394 CHAPTER SEVEN Microarchitecture IorD = 1IorD = 1 MemWriteResetS0: Fetch S2: MemAdrS1: Decode S3: MemReadS5: MemWriteOp = LW Op = SW Op = LWOp = SW S4: Mem WritebackIRWriteIorD = 0 AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 PCWrite ALUSrcA = 1 ALUOp = 00ALUSrcB = 10 RegDst = 0 RegWriteMemtoReg = 1Figure 7.36 Memory write 2Now see PCSrc multiplexer necessary choose PC/H11032from either ALUResult (in S0) ALUOut (in S8).Chapter 07.qxd 2/1/07 9:33 PM Page 3947.4.3 Instructions Section 7.3.3 single-cycle processor, let us extend multicycle processor support addi jinstructions. next two examples illustrate general design process support new instructions. Example 7.5 addi INSTRUCTION Modify multicycle processor support addi. Solution: datapath already capable adding registers immediates, need add new states main controller FSM addi , shown Figure 7.40 (see page 398). states similar R-type instructions. S9, register Ais added SignImm (ALUSrcA /H110051, ALUSrcB /H1100510, ALUOp /H11005 00) result, ALUResult , stored ALUOut . S10, ALUOut written7.4 Multicycle Processor 395 IorD = 1IorD = 1 MemWriteResetS0: Fetch S2: MemAdrS1: Decode S3: MemReadOp = LW Op = SW Op = LW S4: Mem WritebackS5: MemWriteS6: Execute S7: ALU Writeback Op = R-type Op = SWPCWriteIRWriteIorD = 0 PCSrc = 0ALUOp = 00ALUSrcB = 01AluSrcA = 0 ALUSrcA = 1 ALUOp = 00ALUSrcB = 10 RegDst = 0 RegWriteMemtoReg = 1RegDst = 1 RegWriteMemtoReg = 0ALUSrcA = 1 ALUOp = 10ALUSrcB = 00 Figure 7.37 Execute R-type operationChapter 07.qxd 2/1/07 9:33 PM Page 395to register specified rtfield instruction ( RegDst /H110050, MemtoReg /H110050, RegWrite asserted). astute reader may notice S2 S9 identical could merged single state. Example 7.6 jINSTRUCTION Modify multicycle processor support j. Solution: First, must modify datapath compute next PC value case jinstruction. add state main controller handle instruction. Figure 7.41 shows enhanced datapath (see page 399) . jump destination address formed left-shifting 26-bit addr field instruction two bits, prepending four significant bits already incremented PC. PCSrc multiplexer extended take address third input.396 CHAPTER SEVEN Microarchitecture IorD = 0 AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 0 IRWrite PCWriteALUSrcA = 0 ALUSrcB = 11 ALUOp = 00 ALUSrcA = 1 ALUSrcB = 10 ALUOp = 00 IorD = 1RegDst = 1 MemtoReg = 0 RegWriteIorD = 1 MemWriteALUSrcA = 1 ALUSrcB = 00 ALUOp = 10ALUSrcA = 1 ALUSrcB = 00 ALUOp = 01 PCSrc = 1 BranchResetS0: Fetch S2: MemAdrS1: Decode S3: MemReadS5: MemWriteS6: Execute S7: ALU WritebackS8: BranchOp = LW Op = SWOp = R-typeOp = BEQ Op = LWOp = SW RegDst = 0 MemtoReg = 1 RegWriteS4: Mem WritebackFigure 7.38 BranchChapter 07.qxd 2/1/07 9:33 PM Page 396Figure 7.42 shows enhanced main contr oller (see page 400). new state, S11, simply selects PC/H11032as PCJump value ( PCSrc /H1100510) writes PC. Note PCSrc select signal extended two bits S0 S8 well. 7.4.4 Performance Analysis execution time instruction depends number cycles uses cycle time. Whereas single-cycle processor performed instructions one cycle, multicycle processor uses varying numbers cycles various instructions. However, multicycle processor less work single cycle and, thus, shorter cycle time. multicycle processor requires three cycles beqand jinstruc- tions, four cycles sw, addi , R-type instructions, five cycles lwinstructions. CPI depends relative likelihood instruction used.7.4 Multicycle Processor 397 IorD = 0 ALUSrcA = 0 IorD = 1IorD = 1 MemWriteResetS0: Fetch S2: MemAdrS1: Decode S3: MemReadS5: MemWriteS6: Execute S7: ALU Writeback S8: BranchOp = LW Op = SWOp = R-typeOp = BEQ Op = LWOp = SW S4: Mem Writeback PCWriteIRWritePCSrc = 0ALUOp = 00ALUSrcB = 01AluSrcA = 0 ALUSrcA = 1 ALUOp = 00ALUSrcB = 10 RegDst = 0 RegWriteMemtoReg = 1RegDst = 1 RegWriteMemtoReg = 0ALUOp = 00ALUSrcB = 11 ALUSrcA = 1 ALUOp = 10ALUSrcB = 00ALUSrcA = 1 BranchPCSrc = 1ALUOp = 01ALUSrcB = 00 Figure 7.39 Complete multicycle control FSMChapter 07.qxd 2/1/07 9:33 PM Page 397Example 7.7 MULTICYCLE PROCESSOR CPI SPECINT2000 benchmark consists approximately 25% loads, 10% stores, 11% branches, 2% jumps, 52% R-type instructions.3Determine average CPI benchmark. Solution: average CPI sum instruction CPI instruction multiplied fraction time instruction used. benchmark, Average CPI /H11005(0.11 /H110010.02)(3) /H11001(0.52 /H110010.10)(4) /H11001(0.25)(5) /H11005 4.12. better worst-case CPI 5, would required instructions took time.398 CHAPTER SEVEN Microarchitecture IorD = 1IorD = 1 MemWriteResetS0: Fetch S2: MemAdrS1: Decode S3: MemReadS5: MemWriteS6: Execute S7: ALU WritebackS8: BranchOp = LW Op = SWOp = R-typeOp = BEQ Op = LWOp = SW S4: Mem Writeback Op = ADDI S9: ADDI Execute S10: ADDI WritebackIorD = 0 PCWriteIRWritePCSrc = 0ALUOp = 00ALUSrcB = 01AluSrcA = 0 ALUSrcA = 1 ALUOp = 00ALUSrcB = 10 RegDst = 0 RegWriteMemtoReg = 1RegDst = 1 RegWriteMemtoReg = 0RegDst = 1 RegWriteMemtoReg = 0ALUSrcA = 1 ALUOp = 10ALUSrcB = 00ALUSrcA = 1 ALUOp = 00ALUSrcB = 10ALUSrcA = 0 ALUOp = 00ALUSrcB = 11 ALUSrcA = 1 BranchPCSrc = 1ALUOp = 01ALUSrcB = 00 Figure 7.40 Main controller states addi 3Data Patterson Hennessy, Computer Organization Design , 3rd Edition, Morgan Kaufmann, 2005.Chapter 07.qxd 2/1/07 9:33 PM Page 398Recall designed multicycle processor cycle involved one ALU operation, memory access, register file access. Let us assume register file faster memory writ- ing memory faster reading memory. Examining datapath reveals two possible critical paths would limit cycle time: (7.4) numerical values times depend specific imple- mentation technology. Example 7.8 PROCESSOR PERFORMANCE COMPARISON Ben Bitdiddle wondering whether would better building multicy- cle processor instead single-cycle processor. designs, plans using 65 nm CMOS manufacturing process delays given Table 7.6. Help compare processor’s execution time 100 billion instructions SPECINT2000 benchmark (see Example 7.7). Solution: According Equation 7.4, cycle time multicycle processor Tc2/H1100530/H1100125/H11001250 /H1100120/H11005325 ps. Using CPI 4.12 Example 7.7, total execution time T2/H11005(100 /H11003109instructions)(4.12 cycles/instruction) (325 /H1100310/H1100212s/cycle) /H11005133.9 seconds. According Example 7.4, single- cycle processor cycle time Tc1/H11005950 ps, CPI 1, total exe- cution time 95 seconds. One original motivations building multicycle processor avoid making instructions take long slowest one. Unfortunately, example shows multicycle processor slower single-cycleTc/H11005tpcq/H11001tmux/H11001max( tALU /H11001tmux, tmem)/H11001tsetup7.4 Multicycle Processor 399 SignImmCLK ARD Instr/Data MemoryA1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File0 10 1 PC0 1PC' Instr25:21 20:16 15:0SrcB 20:16 15:11 <<2ALUResultULASrcA ALUOutRegDst Branch MemWrite MemtoReg ALUSrcA RegWrite ZeroPCSrc 1:0 CLKALUControl 2:0 WDWECLK Adr 0 1DataCLKCLK B00 01 10 114CLK EN ENALUSrcB 1:0 IRWrite IorD PCWritePCEn 00 01 10 <<2 25:0 (addr)31:28 27:0PCJump Figure 7.41 Multicycle MIPS datapath enhanced support jinstructionChapter 07.qxd 2/1/07 9:33 PM Page 399processor given assumptions CPI circuit element delays. funda- mental problem even though slowest instruction, lw, broken five steps, multicycle processor cycle time nearly improved five- fold. partly steps exactly length, partly 50-ps sequencing overhead register clk-to-Q setup time must paid every step, entire instruction. general, engineers learned difficult exploit fact computations faster others unless differences large. Compared single-cycle processor, multicycle processor likely less expensive eliminates two adders combines instruction data memories single unit. does, however, require five nonarchitectural registers additional multiplexers.400 CHAPTER SEVEN Microarchitecture IorD = 0 AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 00 IRWrite PCWriteALUSrcA = 0 ALUSrcB = 11 ALUOp = 00 ALUSrcA = 1 ALUSrcB = 10 ALUOp = 00 IorD = 1RegDst = 1 MemtoReg = 0 RegWriteIorD = 1 MemWriteALUSrcA = 1 ALUSrcB = 00 ALUOp = 10ALUSrcA = 1 ALUSrcB = 00 ALUOp = 01 PCSrc = 01 BranchResetS0: Fetch S2: MemAdrS1: Decode S3: MemReadS5: MemWriteS6: Execute S7: ALU WritebackS8: BranchOp = LW Op = SW Op = R-typeOp = BEQ Op = LW Op = SW RegDst = 0 MemtoReg = 1 RegWriteS4: Mem WritebackALUSrcA = 1 ALUSrcB = 10 ALUOp = 00 RegDst = 0 MemtoReg = 0 RegWriteOp = ADDI S9: ADDI Execute S10: ADDI WritebackPCSrc = 10 PCWriteOp = J S11: Jump Figure 7.42 Main controller state jChapter 07.qxd 2/1/07 9:33 PM Page 4007.5 PIPELINED PROCESSOR Pipelining, introduced Section 3.6, powerful way improve throughput digital system. design pipelined processor sub- dividing single-cycle processor five pipeline stages. Thus, five instructions execute simultaneously, one stage. stage one-fifth entire logic, clock frequency almost five times faster. Hence, latency instruction ideally unchanged, throughput ideally five times better. Microprocessors execute millions billions instructions per second, throughput important latency. Pipelining introduces overhead, throughput quite high might ideally desire, pipelining nevertheless gives great advan- tage little cost modern high-performance microproces- sors pipelined. Reading writing memory register file using ALU typically constitute biggest delays processor. choose five pipeline stages stage involves exactly one slow steps. Specifically, call five stages Fetch, Decode, Execute, Memory , Writeback . similar five steps multicycle processor used perform lw. Fetch stage, proces- sor reads instruction instruction memory. Decode stage, processor reads source operands register file decodes instruction produce control signals. Execute stage, processor performs computation ALU. Memory stage, processor reads writes data memory. Finally, Writeback stage, processor writes result register file, applicable. Figure 7.43 shows timing diagram comparing single-cycle pipelined processors. Time horizontal axis, instructions vertical axis. diagram assumes logic element delays Table 7.6 ignores delays multiplexers registers. sin- gle-cycle processor, Figure 7.43(a), first instruction read memory time 0; next operands read register file; ALU executes necessary computation. Finally, data memory may accessed, result written back register file 950 ps. second instruction begins first completes. Hence, diagram, single-cycle processor instruction latency 250 /H11001150 /H11001200 /H11001250 /H11001100 /H11005950 ps throughput 1 instruction per 950 ps (1.05 billion instructions per second). pipelined processor, Figure 7.43(b), length pipeline stage set 250 ps slowest stage, memory access (in Fetch Memory stage). time 0, first instruction fetched memory. 250 ps, first instruction enters Decode stage, and7.5 Pipelined Processor 401Chapter 07.qxd 2/1/07 9:33 PM Page 401402 Time (ps)Instr Fetch InstructionDecode Read RegExecute ALUMemory Read/WriteWrite Reg1 20 100 200 300 400 500 600 700 800 900 1100 1200 1300 1400 1500 1600 1700 1800 1900 1000 (a)Fetch InstructionDecode Read RegExecute ALUMemory Read/WriteWrite Reg Instr 1 2 (b)3Fetch InstructionDecode Read RegExecute ALUMemory Read/Write WriteReg Decode Read RegExecute ALUMemory Read/WriteWrite Reg Fetch InstructionDecode Read RegExecute ALUMemory Read/WriteWrite RegFetch Instruction Figure 7.43 Timing diagrams: (a) single-cycle processor , (b) pipelined processorChapter 07.qxd 2/1/07 9:33 PM Page 402a second instruction fetched. 500 ps, first instruction executes, second instruction enters Decode stage, third instruction fetched. forth, instructions complete. instruc- tion latency 5 /H11003250 /H110051250 ps. throughput 1 instruction per 250 ps (4 billion instructions per second). stages perfectly balanced equal amounts logic, latency slightly longer pipelined single-cycle processor. Similarly, throughput quite five times great five-stage pipeline single-cycle processor. Nevertheless, throughput advantage substantial. Figure 7.44 shows abstracted view pipeline operation stage represented pictorially. pipeline stage repre- sented major component—instruction memory (IM), register file (RF) read, ALU execution, data memory (DM), register file write- back—to illustrate flow instructions pipeline. Reading across row shows clock cycles particular instruction stage. example, subinstruction fetched cycle 3 executed cycle 5. Reading column shows various pipeline stages particular cycle. example, cycle 6, orinstruction fetched instruction memory, $s1is read register file, ALU computing $t5AND$t6, data memory idle, register file writing sum $s3. Stages shaded indicate used. example, data memory used lwin cycle 4 swin cycle 8. instruction memory ALU used every cycle. register file written by7.5 Pipelined Processor 403 Time (cycles) lw $s2, 40($0) RF40$0 RF$s2 +DM RF$t2$t1 RF$s3 +DM RF$s5$s1 RF$s4 -DM RF$t6$t5 RF$s5 &DM RF20$s1 RF$s6 +DM RF$t4$t3 RF$s7 |DMadd $s3, $t1, $t2 sub $s4, $s1, $s5 $s5, $t5, $t6 sw $s6, 20($s1) $s7, $t3, $t4123456789 1 0 add IMIMIMIMIMIMlw sub sw Figure 7.44 Abstract view pipeline operationChapter 07.qxd 2/1/07 9:33 PM Page 403every instruction except sw. assume pipelined processor, register file written first part cycle read sec- ond part, suggested shading. way, data written read back within single cycle. central challenge pipelined systems handling hazards occur results one instruction needed subsequent instruction former instruction completed. example, addin Figure 7.44 used $s2rather $t2, hazard would occur $s2register written lwby time read add. section explores forwarding, stalls , flushes methods resolve hazards. Finally, section revisits performance analysis considering sequencing overhead impact hazards. 7.5.1 Pipelined Datapath pipelined datapath formed chopping single-cycle datapath five stages separated pipeline registers. Figure 7.45(a) shows single-cycle datapath stretched leave room pipeline regis- ters. Figure 7.45(b) shows pipelined datapath formed inserting four pipeline registers separate datapath five stages. stages boundaries indicated blue. Signals given suf- fix (F, D, E, M, W) indicate stage reside. register file peculiar read Decode stage written Writeback stage. drawn Decode stage, write address data come Writeback stage. feedback lead pipeline hazards, discussed Section 7.5.3. One subtle critical issues pipelining signals associated particular instruction must advance pipeline unison. Figure 7.45(b) error related issue. find it? error register file write logic, operate Writeback stage. data value comes ResultW , Writeback stage signal. address comes WriteRegE , Execute stage signal. pipeline diagram Figure 7.44, cycle 5, result lwinstruction would incorrectly written register $s4rather $s2. Figure 7.46 shows corrected datapath. WriteReg signal pipelined along Memory Writeback stages, remains sync rest instruction. WriteRegW ResultW fed back together register file Writeback stage. astute reader may notice PC/H11032logic also problem- atic, might updated Fetch Memory stage signal ( PCPlus4F PCBranchM ). control hazard fixed Section 7.5.3.404 CHAPTER SEVEN MicroarchitectureChapter 07.qxd 2/1/07 9:33 PM Page 4047.5.2 Pipelined Control pipelined processor takes control signals single-cycle processor therefore uses control unit. control unit examines opcode funct fields instruction Decode stage produce control signals, described Section 7.3.2. control signals must pipelined along data remain synchronized instruction. entire pipelined processor control shown Figure 7.47. RegWrite must pipelined Writeback stage feeds back register file, WriteReg pipelined Figure 7.46.7.5 Pipelined Processor 405 SignImmCLK AR Instruction Memory 4A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File 0 10 1AR Data Memory WDWE 0 1PC 0 1PC' Instr25:21 20:16 15:0SrcB 20:16 15:11 <<2ALUResultALUReadData WriteDataSrcA PCPlus4+ +PCBranchWriteReg 4:0 ResultZeroCLK (a) SignImmECLK AR Instruction Memory 4A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File 0 10 1AR Data Memory WDWE 0 1PCF 0 1PC' InstrD25:21 20:16 15:0SrcBE 20:16 15:11RtE RdE <<2ALUOutMALUOutW ReadDataW WriteDataE WriteDataMSrcAE PCPlus4DPCBranchM ResultWPCPlus4E PCPlus4FZeroMCLK CLK WriteRegE4:0CLKCLKCLKALU + + (b)Fetch Decode Execute Memory Writeback Figure 7.45 Single-cycle pipelined datapathsChapter 07.qxd 2/1/07 9:33 PM Page 4057.5.3 Hazards pipelined system, multiple instructions handled concurrently. one instruction dependent results another yet completed, hazard occurs.406 CHAPTER SEVEN Microarchitecture SignImmECLK AR Instruction Memory 4+ +A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File 0 10 1AR Data Memory WDWE 0 1PCF 0 1PC' InstrD25:21 20:16 15:05:0 SrcBE 20:16 15:11RtE RdE <<2ALUOutMALUALUOutW ReadDataW WriteDataE WriteDataMSrcAE PCPlus4DPCBranchMWriteRegM 4:0 ResultWPCPlus4E PCPlus4F31:26 RegDstDBranchDMemWriteDMemtoRegD ALUControlD ALUSrcDRegWriteD Op FunctControl Unit ZeroMPCSrcMCLK CLK CLK CLK CLK WriteRegW 4:0ALUControlE 2:0RegWriteE RegWriteM RegWriteW MemtoRegE MemtoRegM MemtoRegW MemWriteE MemWriteM BranchE BranchM RegDstEALUSrcE WriteRegE 4:0 Figure 7.47 Pipelined processor controlSignImmECLK AR Instruction Memory 4+ +A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File 0 10 1AR Data Memory WDWE 0 1PCF 0 1PC' InstrD25:21 20:16 15:0SrcBE 20:16 15:11RtE RdE <<2ALUOutMALUALUOutW ReadDataW WriteDataE WriteDataMSrcAE PCPlus4DPCBranchMWriteRegM 4:0 ResultWPCPlus4E PCPlus4FZeroMCLK CLK WriteRegW 4:0 WriteRegE 4:0CLKCLKCLK Fetch Decode Execute Memory Writeback Figure 7.46 Corrected pipelined datapathChapter 07.qxd 2/1/07 9:33 PM Page 406The register file read written cycle. Let us assume write takes place first half cycle read takes place second half cycle, register written read back cycle without introducing hazard. Figure 7.48 illustrates hazards occur one instruction writes register ( $s0) subsequent instructions read register. called read write (RAW ) hazard. addinstruction writes result $s0in first half cycle 5. However, andinstruction reads $s0on cycle 3, obtaining wrong value. orinstruction reads $s0on cycle 4, obtaining wrong value. subinstruc- tion reads $s0in second half cycle 5, obtaining correct value, written first half cycle 5. Subsequent instructions also read correct value $s0. diagram shows hazards may occur pipeline instruction writes register either two subsequent instructions read register. Without special treat- ment, pipeline compute wrong result. closer inspection, however, observe sum add instruction computed ALU cycle 3 strictly needed andinstruction ALU uses cycle 4. principle, able forward result one instruction next resolve RAW hazard without slowing pipeline. situations explored later section, may stall pipeline give time result computed subsequent instruc- tion uses result. event, something must done solve hazards program executes correctly despite pipelining. Hazards classified data hazards control hazards. data hazard occurs instruction tries read register yet written back previous instruction. control hazard occurs decision instruction fetch next made time fetch takes place. remainder section, will7.5 Pipelined Processor 407 Time (cycles) add $s0, $s2, $s3 RF$s3$s2 RF$s0+DM RF$s1$s0 RF$t0&DM RF$s0$s4 RF$t1|DM RF$s5$s0 RF$t2-DMand $t0, $s0, $s1 $t1, $s4, $s0 sub $t2, $s0, $s512345678 IMIMIMIMadd sub Figure 7.48 Abstract pipeline diagram illustrating hazardsChapter 07.qxd 2/1/07 9:33 PM Page 407enhance pipelined processor hazard unit detects hazards handles appropriately, processor executes program correctly. Solving Data Hazards Forwarding data hazards solved forwarding (also called bypassing ) result Memory Writeback stage dependent instruction Execute stage. requires adding multiplexers front ALU select operand either register file Memory Writeback stage. Figure 7.49 illustrates principle. cycle 4, $s0is forwarded Memory stage addinstruction Execute stage dependent andinstruction. cycle 5, $s0is forwarded Writeback stage addinstruction Execute stage dependent orinstruction. Forwarding necessary instruction Execute stage source register matching destination register instruction Memory Writeback stage. Figure 7.50 modifies pipelined processor support forwarding. adds hazard detection unit two forwarding multiplexers. hazard detection unit receives two source registers instruction Execute stage desti- nation registers instructions Memory Writeback stages. also receives RegWrite signals Memory Writeback stages know whether destination register actually written (for example, swand beqinstructions write results register file hence need results for- warded). Note RegWrite signals connected name . words, rather cluttering diagram long wires run- ning control signals top hazard unit bottom, connections indicated short stub wire labeled control signal name connected.408 CHAPTER SEVEN Microarchitecture Time (cycles) add $s0, $s2, $s3 RF$s3$s2 RF$s0+DM RF$s1$s0 RF$t0&DM RF$s0$s4 RF$t1|DM RF$s5$s0 RF$t2-DMand $t0, $s0, $s1 $t1, $s4, $s0 sub $t2, $s0, $s512345678 IMIMIMIMadd sub Figure 7.49 Abstract pipeline diagram illustrating forwardingChapter 07.qxd 2/1/07 9:33 PM Page 408409EmmIngiSKLC DR noitcurtsnI yromeM 4+ +1A 3A 3DW2DR1DR3EW 2AKLC ngiS dnetxEretsigeR eliF 0 10 1DR ataD yromeM DWEW 1 0FCP 0 1'CP DrtsnI25:21 20:16 15:05:0 EBcrS 25:21 15:11EsR EdR 2<<MtuOULA WtuOULAWataDdaeR EataDetirW MataDetirWEAcrS D4sulPCP MhcnarBCPM4:0geRetirW WtluseRF4sulPCP31:26 DtsDgeR DhcnarBDetirWmeMDgeRotmeM D2:0lortnoCULA DcrSULADetirWgeR pO tcnuFlortnoC tinU McrSCPKLC KLC KLC KLC KLC W4:0geRetirWE2:0lortnoCULAWetirWgeR MetirWgeR EetirWgeR WgeRotmeM MgeRotmeM EgeRotmeM MetirWmeM EetirWmeM EtsDgeREcrSULA E4:0geRetirW00 10 01 00 10 01 DmmIngiS20:16 EtRDsR DdRDtR tinUForwardAEForwardBERegWriteMRegWriteW drazaHE4sulPCPMhcnarB EhcnarB MoreZALU Figure 7.50 Pipelined processor forwarding solve hazardsChapter 07.qxd 2/1/07 9:33 PM Page 409The hazard detection unit computes control signals forward- ing multiplexers choose operands register file results Memory Writeback stage. forward stage stage write destination register destination register matches source register. However, $0is hardwired 0 never forwarded. Memory Writeback stages contain matching destination registers, Memory stage priority, contains recently executed instruction. summary, function forwarding logic SrcA given below. forwarding logic SrcB (ForwardBE ) identical except checks rtrather rs. ((rsE ! /H110050) (rsE /H11005/H11005WriteRegM) RegWriteM) ForwardAE /H1100510 else ((rsE ! /H110050) (rsE /H11005/H11005WriteRegW) RegWriteW) ForwardAE /H1100501 else ForwardAE /H1100500 Solving Data Hazards Stalls Forwarding sufficient solve RAW data hazards result computed Execute stage instruction, result forwarded Execute stage next instruction. Unfortunately, lwinstruction finish reading data end Memory stage, result cannot forwarded Execute stage next instruction. say lwinstruction two-cycle latency , dependent instruction cannot use result two cycles later. Figure 7.51 shows problem. lwinstruction receives data memory end cycle 4. andinstruction needs data source operand beginning cycle 4. way solve hazard forwarding.410 CHAPTER SEVEN Microarchitecture Time (cycles) lw $s0, 40($0) RF40$0 RF$s0+DM RF$s1$s0 RF$t0&DM RF$s0$s4 RF$t1|DM RF$s5$s0 RF$t2-DMand $t0, $s0, $s1 $t1, $s4, $s0 sub $t2, $s0, $s512345678 IMIMIMIMlw subTrouble! Figure 7.51 Abstract pipeline diagram illustrating trouble forwarding lwChapter 07.qxd 2/1/07 9:33 PM Page 410The alternative solution stall pipeline, holding operation data available. Figure 7.52 shows stalling dependent instruction ( and) Decode stage. enters Decode stage cycle 3 stalls cycle 4. subsequent instruction ( or) must remain Fetch stage cycles well, Decode stage full. cycle 5, result forwarded Writeback stage lwto Execute stage and. cycle 6, source $s0of orinstruc- tion read directly register file, need forwarding. Notice Execute stage unused cycle 4. Likewise, Memory unused Cycle 5 Writeback unused cycle 6. unused stage propagating pipeline called bubble , behaves like nopinstruction. bubble introduced zeroing Execute stage control signals Decode stall bubble performs action changes architectural state. summary, stalling stage performed disabling pipeline register, contents change. stage stalled, previous stages must also stalled, subsequent instructions lost. pipeline register directly stalled stage must cleared prevent bogus information propagating forward. Stalls degrade performance, used necessary. Figure 7.53 modifies pipelined processor add stalls lw data dependencies. hazard unit examines instruction Execute stage. lwand destination register ( rtE) matches either source operand instruction Decode stage ( rsDor rtD), instruction must stalled Decode stage source operand ready. Stalls supported adding enable inputs ( EN) Fetch Decode pipeline registers synchronous reset/clear ( CLR ) input Execute pipeline register. lwstall occurs, StallD StallF7.5 Pipelined Processor 411 Time (cycles) lw $s0, 40($0) RF40$0 RF$s0+DM RF$s1$s0 RF$t0&DM RF$s0$s4 RF$t1|DM RF$s5$s0 RF$t2-DMand $t0, $s0, $s1 $t1, $s4, $s0 sub $t2, $s0, $s512345678 IMIMIMIMlw sub9 RF$s1$s0 IMor Stall Figure 7.52 Abstract pipeline diagram illustrating stall solve hazardsChapter 07.qxd 2/1/07 9:33 PM Page 411412 EmmIngiSKLC DR noitcurtsnI yromeM 4+ +1A 3A 3DW2DR1DR3EW 2AKLC ngiS dnetxEretsigeR eliF 0 10 1DR ataD yromeM DWEW 1 0FCP 0 1'CP DrtsnI12:52 61:02 0:510:5 EBcrS 12:52 11:51EsR EdR 2<<MtuOULA WtuOULAWataDdaeR EataDetirW MataDetirWEAcrS D4sulPCP MhcnarBCPM4:0geRetirW WtluseRF4sulPCP62:13 DtsDgeR DhcnarBDetirWmeMDgeRotmeM D2:0lortnoCULA DcrSULADetirWgeR pO tcnuFlortnoC tinU McrSCPKLC KLC KLC KLC KLC W4:0geRetirWE2:0lortnoCULAWetirWgeR MetirWgeR EetirWgeR WgeRotmeM MgeRotmeM EgeRotmeM MetirWmeM EetirWmeM EtsDgeREcrSULA E4:0geRetirW00 10 01 00 10 01 DmmIngiS61:02 EtRDsR DdRDtR tinU drazaHE4sulPCPMhcnarB EhcnarB MoreZ ForwardAEForwardBERegWriteM MemtoRegE FlushE StallDEN EN ALU CLR StallFRegWriteW Figure 7.53 Pipelined processor stalls solve lwdata hazardChapter 07.qxd 2/1/07 9:33 PM Page 412are asserted force Decode Fetch stage pipeline registers hold old values. FlushE also asserted clear contents Execute stage pipeline register, introducing bubble.4 MemtoReg signal asserted lwinstruction. Hence, logic compute stalls flushes lwstall /H11005((rsD /H11005/H11005rtE) (rtD /H11005/H11005rtE)) MemtoRegE StallF /H11005StallD /H11005FlushE /H11005lwstall Solving Control Hazards beqinstruction presents control hazard: pipelined processor know instruction fetch next, branch deci- sion made time next instruction fetched. One mechanism dealing control hazard stall pipeline branch decision made (i.e., PCSrc computed). decision made Memory stage, pipeline would stalled three cycles every branch. would severely degrade system performance. alternative predict whether branch taken begin executing instructions based prediction. branch decision available, processor throw instructions prediction wrong. particular, suppose predict branches taken simply continue executing program order. branch taken, three instructions fol- lowing branch must flushed (discarded) clearing pipeline registers instructions. wasted instruction cycles called branch misprediction penalty . Figure 7.54 shows scheme, branch address 20 address 64 taken. branch decision made cycle 4, point and, or, subinstructions addresses 24, 28, 2C already fetched. instructions must flushed, sltinstruction fetched address 64 cycle 5. somewhat improvement, flushing many instructions branch taken still degrades performance. could reduce branch misprediction penalty branch decision could made earlier. Making decision simply requires comparing values two registers. Using dedicated equality com- parator much faster performing subtraction zero detection. comparator fast enough, could moved back Decode stage, operands read register file compared determine next PC end Decode stage.7.5 Pipelined Processor 413 4Strictly speaking, register designations ( RsE, RtE, RdE) control sig- nals might update memory architectural state ( RegWrite, MemWrite , Branch ) need cleared; long signals cleared, bubble contain random data effect.Chapter 07.qxd 2/1/07 9:33 PM Page 413Figure 7.55 shows pipeline operation early branch deci- sion made cycle 2. cycle 3, andinstruction flushed sltinstruction fetched. branch misprediction penalty reduced one instruction rather three. Figure 7.56 modifies pipelined processor move branch decision earlier handle control hazards. equality comparator added Decode stage PCSrc gate moved earlier, so414 CHAPTER SEVEN Microarchitecture Time (cycles) beq $t1, $t2, 40 RF$t2$t1 RF -DM RF$s1$s0 RFDM RF$s0$s4 RF |DM RF$s5$s0 RF -DMand $t0, $s0, $s1 $t1, $s4, $s0 sub $t2, $s0, $s512345678 IMIMIMIMlw sub20 24 28 2C 30 ......9 Flush instructions 64 slt $t3, $s2, $s3 RF$s3$s2 RF$t3 DMIMsltslt& Figure 7.54 Abstract pipeline diagram illustrating flushing branch taken Time (cycles) beq $t1, $t2, 40 RF$t2$t1 RF -DM RF$s1$s0 RF &DMand $t0, $s0, $s1 $t1, $s4, $s0 sub $t2, $s0, $s512345678 andIMIMlw20 24 28 2C 30 ......9 Flush instruction 64 slt $t3, $s2, $s3 RF$s3$s2 RF$t3 DMIMsltslt Figure 7.55 Abstract pipeline diagram illustrating earlier branch decisionChapter 07.qxd 2/1/07 9:33 PM Page 414415DlauqE EmmIngiSKLC DR noitcurtsnI yromeM 4+1A 3A 3DW2DR1DR3EW 2AKLC ngiS dnetxEretsigeR eliF 0 10 1DR ataD yromeM DWEW 1 0FCP 0 1'CP DrtsnI12:52 61:02 0:510:5 EBcrS 12:52 11:51EsR EdR 2<< +MtuOULA WtuOULAWataDdaeR EataDetirW MataDetirWEAcrS D4sulPCP DhcnarBCPM4:0geRetirW WtluseRF4sulPCP62:13 DtsDgeR DhcnarBDetirWmeMDgeRotmeM D2:0lortnoCULA DcrSULADetirWgeR pO tcnuFlortnoC tinU DcrSCPKLC KLC KLC KLC KLC W4:0geRetirWE2:0lortnoCULAWetirWgeR MetirWgeR EetirWgeR WgeRotmeM MgeRotmeM EgeRotmeM MetirWmeM EetirWmeM EtsDgeREcrSULA E4:0geRetirW00 10 01 00 10 01= DmmIngiS61:02 EtRDsR DdRDtR tinU drazaHForwardAEForwardBERegWriteM MemtoRegE FlushE StallD StallFRegWriteWCLR ENEN ALU CLR Figure 7.56 Pipelined processor handling branch control hazardChapter 07.qxd 2/1/07 9:33 PM Page 415that PCSrc determined Decoder stage rather Memory stage. PCBranch adder must also moved Decode stage destination address computed time. synchronous clear input ( CLR ) connected PCSrcD added Decode stage pipeline register incorrectly fetched instruction flushed branch taken. Unfortunately, early branch decision hardware introduces new RAW data hazard. Specifically, one source operands branch computed previous instruction yet written register file, branch read wrong operand value reg- ister file. before, solve data hazard forwarding correct value available stalling pipeline data ready. Figure 7.57 shows modifications pipelined processor needed handle Decode stage data dependency. result Writeback stage, written first half cycle read second half, hazard exists. result ALU instruction Memory stage, forwarded equality comparator two new multiplexers. result ALU instruction Execute stage result lwinstruction Memory stage, pipeline must stalled Decode stage result ready. function Decode stage forwarding logic given below. ForwardAD /H11005(rsD ! /H110050) (rsD /H11005/H11005WriteRegM) RegWriteM ForwardBD /H11005(rtD ! /H110050) (rtD /H11005/H11005WriteRegM) RegWriteM function stall detection logic branch given below. processor must make branch decision Decode stage. either sources branch depends ALU instruction Execute stage lwinstruction Memory stage, processor must stall sources ready. branchstall /H11005 BranchD RegWriteE (WriteRegE /H11005/H11005rsD WriteRegE /H11005/H11005rtD) BranchD MemtoRegM (WriteRegM /H11005/H11005rsD WriteRegM /H11005/H11005rtD) processor might stall due either load branch hazard: StallF /H11005StallD /H11005FlushE /H11005lwstall branchstall Hazard Summary summary, RAW data hazards occur instruction depends result another instruction yet written register file. data hazards resolved forwarding result computed soon enough; otherwise, require stalling pipeline result available. Control hazards occur decision instruction fetch made time next instruc- tion must fetched. Control hazards solved predicting which416 CHAPTER SEVEN MicroarchitectureChapter 07.qxd 2/1/07 9:33 PM Page 416417DlauqE EmmIngiSKLC DR noitcurtsnI yromeM 4+ +1A 3A 3DW2DR1DR3EW 2AKLC ngiS dnetxEretsigeR eliF 0 10 1DR ataD yromeM DWEW 1 0FCP 0 1'CP DrtsnI12:52 61:02 0:510:5 EBcrS 12:52 11:51EsR EdR 2<<MtuOULA WtuOULAWataDdaeR EataDetirW MataDetirWEAcrS D4sulPCP DhcnarBCPM4:0geRetirW WtluseRF4sulPCP62:13 DtsDgeR DhcnarBDetirWmeMDgeRotmeM D2:0lortnoCULA DcrSULADetirWgeR pO tcnuFControl Unit DcrSCPKLC KLC KLC KLC KLC W4:0geRetirWE2:0lortnoCULAWetirWgeR MetirWgeR EetirWgeR WgeRotmeM MgeRotmeM EgeRotmeM MetirWmeM EetirWmeM EtsDgeREcrSULA E4:0geRetirW00 10 01 00 10 010 1 0 1= DmmIngiS61:02 EtRDsR DdRDtR tinU drazaHForwardAEForwardBE ForwardAD BranchDForwardBDRegWriteM RegWriteE MemtoRegEMemtoRegM FlushECLRCLR ENEN ALU StallD StallFRegWriteW Figure 7.57 Pipelined processor handling data dependencies branch instructionsChapter 07.qxd 2/1/07 9:33 PM Page 417instruction fetched flushing pipeline prediction later determined wrong. Moving decision early possible minimizes number instructions flushed misprediction. may observed one challenges designing pipelined processor understand possible interactions instructions discover hazards may exist. Figure 7.58 shows complete pipelined processor handling hazards. 7.5.4 Instructions Supporting new instructions pipelined processor much like sup- porting single-cycle processor. However, new instructions may introduce hazards must detected solved. particular, supporting addi jinstructions pipelined processor requires enhancing controller, exactly described Section 7.3.3, adding jump multiplexer datapath branch multiplexer. Like branch, jump takes place Decode stage, subsequent instruction Fetch stage must flushed. Designing flush logic left Exercise 7.29. 7.5.5 Performance Analysis pipelined processor ideally would CPI 1, new instruction issued every cycle. However, stall flush wastes cycle, CPI slightly higher depends specific program executed. Example 7.9 PIPELINED PROCESSOR CPI SPECINT2000 benchmark considered Example 7.7 consists approxi- mately 25% loads, 10% stores, 11% branches, 2% jumps, 52% R-type instructions. Assume 40% loads immediately followed instruction uses result, requiring stall, one quarter branches mispredicted, requiring flush. Assume jumps always flush subsequent instruction. Ignore hazards. Compute average CPI pipelined processor. Solution: average CPI sum instruction CPI instruction multiplied fraction time instruction used. Loads take one clock cycle dependency two cycles processor must stall dependency, CPI (0.6)(1) /H11001(0.4)(2) /H110051.4. Branches take one clock cycle predicted properly two not, CPI (0.75)(1) /H11001(0.25)(2) /H110051.25. Jumps always CPI 2. instructions CPI 1. Hence, benchmark, Average CPI/H11005(0.25)(1.4) /H11001(0.1)(1) /H11001(0.11)(1.25) /H11001(0.02)(2) /H11001(0.52)(1) /H110051.15.418 CHAPTER SEVEN MicroarchitectureChapter 07.qxd 2/1/07 9:33 PM Page 418419EqualD SignImmECL K AR Instruction Memory + 4A1 A3 WD3RD2RD1WE3 A2CL K Sign ExtendRegister File 0 10 1AR Data Memory WDWE 1 0PCF 0 1PC' InstrD25:21 20:16 15:05:0 SrcBE 25:21 15:11RsE RdE <<2 +ALUOutM ALUOutWReadDataW WriteDataE WriteDataMSrcAE PCPlus4D PCBranchDWriteRegM 4:0 ResultWPCPlus4F31:26 RegDstD BranchDMemWriteDMemtoRegD ALUControlD2:0 ALUSrcDRegWriteD Op FunctControl Unit PCSrcDCL K CL K CL K CL K CL K WriteRegW 4:0ALUControlE 2:0 ALURegWriteE RegWriteM RegWriteW MemtoRegE MemtoRegM MemtoRegW MemWriteE MemWriteM RegDstEALUSrcE WriteRegE 4:000 01 10 00 01 100 1 0 1= SignImmD20:16 RtERsD RdDRtD Hazard Unit StallFStallDForwardAEForwardBE ForwardADForwardBDRegWriteERegWriteMRegWriteW MemtoRegE BranchDFlushEEN CLR ENCLR Figure 7.58 Pipelined processor full hazard handlingChapter 07.qxd 2/1/07 9:33 PM Page 419We determine cycle time considering critical path five pipeline stages shown Figure 7.58. Recall regis- ter file written first half Writeback cycle read sec- ond half Decode cycle. Therefore, cycle time Decode Writeback stages twice time necessary half-cycle work. (7.5) Example 7.10 PROCESSOR PERFORMANCE COMPARISON Ben Bitdiddle needs compare pipelined processor performance single-cycle multicycle processors considered Example 7.8. logic delays given Table 7.6. element delays 40 ps equality comparator, 15 ps gate, 100 ps register file write, 220 ps memory write. Help Ben compare execution time 100 billion instructions SPECINT2000 benchmark processor. Solution: According Equation 7.5, cycle time pipelined processor Tc3/H11005max[30 /H11001250 /H1100120, 2(150 /H1100125/H1100140/H1100115/H1100125/H1100120), 30 /H1100125/H1100125/H11001 200 /H1100120, 30 /H11001220 /H1100120, 2(30 /H1100125/H11001100)] /H11005550 ps. According Equation 7.1, total execution time T3/H11005(100 /H11003109instructions)(1.15 cycles/ instruc- tion)(550 /H1100310/H1100212s/cycle) /H1100563.3 seconds. compares 95 seconds single-cycle processor 133.9 seconds multicycle processor. pipelined processor substantially faster others. However, advan- tage single-cycle processor nowhere near five-fold speedup one might hope get five-stage pipeline. pipeline hazards introduce small CPI penalty. significantly, sequencing overhead (clk-to-Q setup times) registers applies every pipeline stage, overall datapath. Sequencing overhead limits benefits one hope achieve pipelining. careful reader might observe Decode stage substantially slower others, register file write, read, branch comparison must happen half cycle. Perhaps moving branch comparison Decode stage good idea. branches resolved Execute stage instead, CPI would increase slightly, mispredict would flush two instructions, cycle time would decrease substantially, giving overall speedup. pipelined processor similar hardware requirements single-cycle processor, adds substantial number pipeline regis- ters, along multiplexers control logic resolve hazards.Tc/H11005max /H20898tpcq/H11001tmem /H11001tsetup 2(tRFread/H11001tmux/H11001teq/H11001tAND /H11001tmux/H11001tsetup) tpcq/H11001tmux/H11001tmux/H11001tALU/H11001tsetup tpcq /H11001tmemwrite /H11001tsetup 2(tpcq/H11001tmux/H11001tRFwrite)/H20903 /H20899420 CHAPTER SEVEN Microarchitecture Fetch Decode Execute Memory WritebackChapter 07.qxd 2/1/07 9:33 PM Page 4207.6 HDL REPRESENTATION* section presents HDL code single-cycle MIPS processor supporting instructions discussed chapter, including addi j. code illustrates good coding practices moderately complex system. HDL code multicycle processor pipelined processor left Exercises 7.22 7.33. section, instruction data memories separated main processor connected address data busses. realistic, real processors external memory. also illustrates processor communicate outside world. processor composed datapath controller. controller, turn, composed main decoder ALU decoder. Figure 7.59 shows block diagram single-cycle MIPS processor interfaced external memories. HDL code partitioned several sections. Section 7.6.1 provides HDL single-cycle processor datapath controller. Section 7.6.2 presents generic building blocks, registers multiplexers, used microarchitecture. Section 7.6.37.6 HDL Representation 421 Opcode5:0ControllerFunct5:0 Datapath AR Instruction MemoryPC InstrA RD Data Memory WDWECL K ALUOut WriteDataReadData RegDst BranchMemWrite MemtoRegALUSrc ALUControl2:0Main DecoderALUOp1:0ALU DecoderRegWrite31:26 5:0 CL K Reset MIPS ProcessorExternal Memory PCSrc Zero Figure 7.59 MIPS single-cycle processor interfaced external memoryChapter 07.qxd 2/1/07 9:33 PM Page 421introduces testbench external memories. HDL available electronic form book’s Web site (see preface). 7.6.1 Single-Cycle Processor main modules single-cycle MIPS processor module given following HDL examples.422 CHAPTER SEVEN Microarchitecture Verilog module mips(input clk, reset, output [31:0] pc, input [31:0] instr, output memwrite, output [31:0] aluout, writedata, input [31:0] readdata); wire memtoreg, branch, alusrc, regdst, regwrite, jump; wire [2:0] alucontrol; controller c(instr[31:26], instr[5:0], zero, memtoreg, memwrite, pcsrc, alusrc, regdst, regwrite, jump, alucontrol); datapathdp(clk, reset, memtoreg, pcsrc, alusrc, regdst, regwrite, jump, alucontrol, zero, pc, instr, aluout, writedata, readdata); endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity mips — — single cycle MIPS processor port(clk, reset: STD_LOGIC; pc: STD_LOGIC_VECTOR(31 downto 0); instr: STD_LOGIC_VECTOR(31 downto 0); memwrite: STD_LOGIC; aluout, writedata: STD_LOGIC_VECTOR(31 downto 0); readdata: STD_LOGIC_VECTOR(31 downto 0)); end; architecture struct mips component controller port(op, funct: STD_LOGIC_VECTOR(5 downto 0); zero: STD_LOGIC; memtoreg,memwrite: STD_LOGIC; pcsrc, alusrc: STD_LOGIC; regdst, regwrite: STD_LOGIC; jump: STD_LOGIC; alucontrol: STD_LOGIC_VECTOR(2 downto 0)); end component; component datapath port(clk, reset: STD_LOGIC; memtoreg, pcsrc: STD_LOGIC; alusrc, regdst: STD_LOGIC; regwrite, jump: STD_LOGIC; alucontrol: STD_LOGIC_VECTOR(2 downto 0); zero: STD_LOGIC; pc: buffer STD_LOGIC_VECTOR(31 downto 0); instr: STD_LOGIC_VECTOR(31 downto 0); aluout, writedata: buf fer STD_LOGIC_VECTOR(31 downto 0); readdata: STD_LOGIC_VECTOR(31 downto 0)); end component; signal memtoreg, alusrc, regdst, regwrite, jump, pcsrc: STD_LOGIC; signal zero: STD_LOGIC; signal alucontrol: STD_LOGIC_VECTOR(2 downto 0); begin cont: controller port map(instr(31 downto 26), instr (5 downto 0), zero, memtoreg, memwrite, pcsrc, alusrc, regdst, regwrite, jump, alucontrol); dp: datapath port map(clk, reset, memtoreg, pcsrc, alusrc, regdst, regwrite, jump, alucontrol, zero, pc, instr, aluout, writedata, readdata); end;HDL Example 7.1 SINGLE-CYCLE MIPS PROCESSORChapter 07.qxd 2/1/07 9:33 PM Page 4227.6 HDL Representation 423 Verilog modulecontroller(input [5:0] op, funct, input zero, output memtoreg, memwrite, output pcsrc, alusrc, output regdst, regwrite, output jump, output [2:0] alucontrol); wire [1:0] aluop; wire branch; maindec md(op, memtoreg, memwrite, branch, alusrc, regdst, regwrite, jump, aluop); aludec ad(funct, aluop, alucontrol); assign pcsrc /H11005branch & zero; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity controller — — single cycle control decoder port(op, funct: STD_LOGIC_VECTOR(5 downto 0); zero: STD_LOGIC; memtoreg, memwrite: STD_LOGIC; pcsrc, alusrc: STD_LOGIC; regdst, regwrite: STD_LOGIC; jump: STD_LOGIC; alucontrol: STD_LOGIC_VECTOR(2 downto 0)); end; architecture struct controller component maindec port(op: STD_LOGIC_VECTOR(5 downto 0); memtoreg, memwrite: STD_LOGIC; branch, alusrc: STD_LOGIC; regdst, regwrite: STD_LOGIC; jump: STD_LOGIC; aluop: STD_LOGIC_VECTOR(1 downto 0)); end component; component aludec port(funct: STD_LOGIC_VECTOR(5 downto 0); aluop: STD_LOGIC_VECTOR(1 downto 0); alucontrol: STD_LOGIC_VECTOR(2 downto 0)); end component; signal aluop: STD_LOGIC_VECTOR(1 downto 0); signal branch: STD_LOGIC; begin md: maindec port map(op, memtoreg, memwrite, branch, alusrc, regdst, regwrite, jump, aluop); ad: aludec port map(funct, aluop, alucontrol); pcsrc /H11021/H11005branch zero; end;HDL Example 7.2 CONTROLLERChapter 07.qxd 2/1/07 9:33 PM Page 423Verilog module maindec(input [5:0] op, output memtoreg, memwrite, output branch, alusrc, output regdst, regwrite, output jump, output [1:0] aluop); reg [8:0] controls; assign {regwrite, regdst, alusrc, branch, memwrite, memtoreg, jump, aluop} /H11005controls; always@(*) case(op) 6/H11032b000000: controls /H11021/H110059/H11032b110000010; //Rtyp 6/H11032b100011: controls /H11021/H110059/H11032b101001000; //LW 6/H11032b101011: controls /H11021/H110059/H11032b001010000; //SW 6/H11032b000100: controls /H11021/H110059/H11032b000100001; //BEQ 6/H11032b001000: controls /H11021/H110059/H11032b101000000; //ADDI 6/H11032b000010: controls /H11021/H110059/H11032b000000100; //J default: controls /H11021/H110059/H11032bxxxxxxxxx; //??? endcase endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity maindec —— main control decoder port(op: STD_LOGIC_VECTOR(5 downto 0); memtoreg, memwrite: STD_LOGIC; branch, alusrc: STD_LOGIC; regdst, regwrite: STD_LOGIC; jump: STD_LOGIC; aluop: STD_LOGIC_VECTOR(1 downto 0)); end; architecture behave maindec signal controls: STD_LOGIC_VECTOR(8 downto 0); begin process(op) begin case op "000000" /H11005/H11022controls /H11021/H11005"110000010"; — — Rtyp "100011" /H11005/H11022controls /H11021/H11005"101001000"; — — LW "101011" /H11005/H11022controls /H11021/H11005"001010000"; — — SW "000100" /H11005/H11022controls /H11021/H11005"000100001"; — — BEQ "001000" /H11005/H11022controls /H11021/H11005"101000000"; — — ADDI "000010" /H11005/H11022controls /H11021/H11005"000000100"; — — J others /H11005/H11022controls /H11021/H11005"---------"; — — illegal op end case; end process; regwrite /H11021/H11005controls(8); regdst /H11021/H11005controls(7); alusrc /H11021/H11005controls(6); branch /H11021/H11005controls(5); memwrite /H11021/H11005controls(4); memtoreg /H11021/H11005controls(3); jump /H11021/H11005controls(2); aluop /H11021/H11005controls(1 downto 0); end;HDL Example 7.3 MAIN DECODER Verilog module aludec(input [5:0] funct, input [1:0] aluop, output reg [2:0] alucontrol); always@(*) case(aluop) 2/H11032b00: alucontrol /H11021/H110053/H11032b010; // add 2/H11032b01: alucontrol /H11021/H110053/H11032b110; // sub default: case(funct) // RTYPE 6/H11032b100000: alucontrol /H11021/H110053/H11032b010; // ADD 6/H11032b100010: alucontrol /H11021/H110053/H11032b110; // SUB 6/H11032b100100: alucontrol /H11021/H110053/H11032b000; // 6/H11032b100101: alucontrol /H11021/H110053/H11032b001; // 6/H11032b101010: alucontrol /H11021/H110053/H11032b111; // SLT default: alucontrol /H11021/H110053/H11032bxxx; // ??? endcase endcase endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity aludec —— ALU control decoder port(funct: STD_LOGIC_VECTOR(5 downto 0); aluop: STD_LOGIC_VECTOR(1 downto 0); alucontrol: STD_LOGIC_VECTOR(2 downto 0)); end; architecture behave aludec begin process(aluop, funct)begin case aluop "00" /H11005/H11022alucontrol /H11021/H11005"010"; —— add (for 1b/sb/addi) "01" /H11005/H11022alucontrol /H11021/H11005"110"; —— sub (for beq) others /H11005/H11022case funct — — R-type instructions "100000" /H11005/H11022alucontrol /H11021/H11005 "010"; — — add "100010" /H11005/H11022alucontrol /H11021/H11005 "110"; — — sub "100100" /H11005/H11022alucontrol /H11021/H11005 "000"; — — "100101" /H11005/H11022alucontrol /H11021/H11005 "001"; — — "101010" /H11005/H11022alucontrol /H11021/H11005 "111"; — — slt others /H11005/H11022alucontrol /H11021/H11005 " ———" ; —— ? ? ? end case; end case; end process; end;HDL Example 7.4 ALU DECODERChapter 07.qxd 2/1/07 9:33 PM Page 424Verilog module datapath(input clk, reset, input memtoreg, pcsrc, input alusrc, regdst, input regwrite, jump, input [2:0] alucontrol, output zero, output [31:0] pc, input [31:0] instr, output [31:0] aluout, writedata, input [31:0] readdata); wire [4:0] writereg; wire [31:0] pcnext, pcnextbr, pcplus4, pcbranch; wire [31:0] signimm, signimmsh; wire [31:0] srca, srcb; wire [31:0] result; // next PC logic flopr #(32) pcreg(clk, reset, pcnext, pc); adder pcadd1(pc, 32 /H11032b100, pcplus4); sl2 immsh(signimm, signimmsh); adder pcadd2(pcplus4, signimmsh, pcbranch); mux2 #(32) pcbrmux(pcplus4, pcbranch, pcsrc, pcnextbr); mux2 #(32) pcmux(pcnextbr, {pcplus4[31:28], instr[25:0], 2 /H11032b00}, jump, pcnext); // register file logic regfile rf(clk, regwrite, instr[25:21], instr[20:16], writereg, result, srca, writedata); mux2 #(5) wrmux(instr[20:16], instr[15:11], regdst, writereg); mux2 #(32) resmux(aluout, readdata, memtoreg, result); signext se(instr[15:0], signimm); // ALU logic mux2 #(32) srcbmux(writedata, signimm, alusrc, srcb); alu alu(srca, srcb, alucontrol, aluout, zero); endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; use IEEE.STD_LOGIC_ARITH.all; entity datapath — — MIPS datapath port(clk, reset: STD_LOGIC; memtoreg, pcsrc: STD_LOGIC; alusrc, regdst: STD_LOGIC; regwrite, jump: STD_LOGIC; alucontrol: STD_LOGIC_VECTOR(2 downto 0); zero: STD_LOGIC; pc: buffer STD_LOGIC_VECTOR(31 downto 0); instr: STD_LOGIC_VECTOR(31 downto 0); aluout, writedata: buffer STD_LOGIC_VECTOR(31 downto 0); readdata: STD_LOGIC_VECTOR(31 downto 0)); end; architecture struct datapath component alu port(a, b: STD_LOGIC_VECTOR(31 downto 0); alucontrol: STD_LOGIC_VECTOR(2 downto 0); result: buffer STD_LOGIC_VECTOR(31 downto 0); zero: STD_LOGIC); end component; component regfile port(clk: STD_LOGIC; we3: STD_LOGIC; ra1, ra2, wa3: STD_LOGIC_VECTOR(4 downto 0); wd3: STD_LOGIC_VECTOR(31 downto 0); rd1, rd2: STD_LOGIC_VECTOR(31 downto 0)); end component; component adder port(a, b: STD_LOGIC_VECTOR(31 downto 0); y: STD_LOGIC_VECTOR(31 downto 0)); end component; component sl2 port(a: STD_LOGIC_VECTOR(31 downto 0); y: STD_LOGIC_VECTOR(31 downto 0)); end component; component signext port(a: STD_LOGIC_VECTOR(15 downto 0); y: STD_LOGIC_VECTOR(31 downto 0)); end component; component flopr generic(width: integer); port(clk, reset: STD_LOGIC; d: STD_LOGIC_VECTOR(width-1 downto 0); q: STD_LOGIC_VECTOR(width-1 downto 0)); end component; component mux2 generic(width: integer); port(d0, d1: STD_LOGIC_VECTOR(width-1 downto 0); s: STD_LOGIC; y: STD_LOGIC_VECTOR(width-1 downto 0)); end component; signal writereg: STD_LOGIC_VECTOR(4 downto 0); signal pcjump, pcnext, pcnextbr, pcplus4, pcbranch: STD_LOGIC_VECTOR(31 downto 0); signal signimm, signimmsh: STD_LOGIC_VECTOR(31 downto 0); signal srca, srcb, result: STD_LOGIC_VECTOR(31 downto 0); begin —— next PC logic pcjump /H11021/H11005pcplus4(31 downto 28) & instr(25 downto 0) & "00"; pcreg: flopr generic map(32) port map(clk, reset, pcnext, pc); pcadd1: adder port map(pc, X"00000004", pcplus4); immsh: sl2 port map(signimm, signimmsh); pcadd2: adder port map(pcplus4, signimmsh, pcbranch); pcbrmux: mux2 generic map(32) port map(pcplus4, pcbranch, pcsrc, pcnextbr); pcmux: mux2 generic map(32) port map(pcnextbr, pcjump, jump, pcnext); — — register file logic rf: regfile port map(clk, regwrite, instr(25 downto 21), instr(20 downto 16), writereg, result, srca, writedata); wrmux: mux2 generic map(5) port map(instr(20 downto 16), instr(15 downto 11), regdst, writereg); resmux: mux2 generic map(32) port map(aluout, readdata, memtoreg, result); se: signext port map(instr(15 downto 0), signimm); — — ALU logic srcbmux: mux2 generic map (32) port map(writedata, signimm, alusrc, srcb); mainalu: alu port map(srca, srcb, alucontrol, aluout, zero); end;HDL Example 7.5 DATAPATH 425Chapter 07.qxd 2/1/07 9:33 PM Page 425Verilog module regfile(input clk, input we3, input [4:0] ra1, ra2, wa3, input [31:0] wd3, output [31:0] rd1, rd2); reg [31:0] rf[31:0]; // three ported register file // read two ports combinationally // write third port rising edge clock // register 0 hardwired 0 always @(posedge clk) if(we3) rf[wa3] /H11021/H11005wd3; assign rd1 /H11005(ra1 ! /H110050) ? rf[ra1] : 0; assign rd2 /H11005(ra2 ! /H110050) ? rf[ra2] : 0; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; use IEEE.STD_LOGIC_UNSIGNED.all; entity regfile — — three-port register file port(clk: STD_LOGIC; we3: STD_LOGIC; ra1, ra2, wa3:in STD_LOGIC_VECTOR(4 downto 0); wd3: STD_LOGIC_VECTOR(31 downto 0); rd1, rd2: STD_LOGIC_VECTOR(31 downto 0)); end; architecture behave regfile type ramtype array(31 downto 0) STD_LOGIC_VECTOR(31 downto 0); signal mem: ramtype; begin — — three-ported register file — — read two ports combinationally — — write third port rising edge clock process(clk) begin clk'event clk /H11005'1' we3 /H11005'1' mem(CONV_INTEGER(wa3)) /H11021/H11005wd3; end if; end if; end process; process(ra1, ra2) begin if(conv_integer(ra1) /H110050) rd1 /H11021/H11005X"00000000"; ——register 0 holds 0 else rd1 /H11021/H11005mem(CONV_INTEGER(ra1)); end if; if(conv_integer(ra2) /H110050) rd2 /H11021/H11005X"00000000"; else rd2 /H11021/H11005mem(CONV_INTEGER(ra2)); end if; end process; end;HDL Example 7.6 REGISTER FILE Verilog module adder(input [31:0] a, b, output [31:0] y); assign /H11005a/H11001b; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; use IEEE.STD_LOGIC_UNSIGNED.all; entity adder — adder port(a, b: STD_LOGIC_VECTOR(31 downto 0); y: STD_LOGIC_VECTOR(31 downto 0)); end; architecture behave adder begin y/H11021/H11005a/H11001b; end;HDL Example 7.7 ADDER7.6.2 Generic Building Blocks section contains generic building blocks may useful MIPS microarchitecture, including register file, adder, left shift unit, sign-extension unit, resettable flip-flop, multiplexer. HDL ALU left Exercise 5.9.Chapter 07.qxd 2/1/07 9:33 PM Page 426Verilog module sl2(input [31:0] a, output [31:0] y); // shift left 2 assign /H11005{a[29:01], 2'b00}; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity sl2 — — shift left 2 port(a: STD_LOGIC_VECTOR(31 downto 0); y: STD_LOGIC_VECTOR(31 downto 0)); end; architecture behave sl2 begin y/H11021/H11005a(29 downto 0) & "00"; end;HDL Example 7.8 LEFT SHIFT (MULTIPLY 4) Verilog module signext(input [15:0] a, output [31:0] y); assign /H11005{{16{a[15]}}, a}; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity signext — — sign extender port(a: STD_LOGIC_VECTOR (15 downto 0); y: STD_LOGIC_VECTOR(31 downto 0)); end; architecture behave signext begin y/H11021/H11005X"0000" & a(15) /H11005'0' else X"ffff" & a; end;HDL Example 7.9 SIGN EXTENSION Verilog module flopr #(parameter WIDTH /H110058) (input clk, reset, input [WIDTH-1:0] d, output reg [WIDTH-1:0] q); always @(posedge clk, posedge reset) if(reset) q /H11021/H110050; else q /H11021/H11005d; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; use IEEE.STD_LOGIC_ARITH.all; entity flopr — — flip-flop synchronous reset generic(width: integer); port(clk, reset: STD_LOGIC; d: STD_LOGIC_VECTOR(width-1 downto 0); q: STD_LOGIC_VECTOR(width-1 downto 0)); end; architecture asynchronous flopr begin process(clk, reset) begin reset /H11005'1' q /H11021/H11005CONV_STD_LOGIC_VECTOR(0, width); elsif clk’event clk /H11005'1' q/H11021/H11005d; end if; end process; end;HDL Example 7.10 RESETTABLE FLIP-FLOP7.6 HDL Representation 427Chapter 07.qxd 2/1/07 9:33 PM Page 427428 CHAPTER SEVEN Microarchitecture Verilog module mux2 #(parameter WIDTH /H110058) (input [WIDTH-1:0] d0, d1, input s, output [WIDTH-1:0] y); assign /H11005s ? d1 : d0; endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; entity mux2 —— two-input multiplexer generic(width: integer); port(d0, d1: STD_LOGIC_VECTOR(width-1 downto 0); s: STD_LOGIC; y: STD_LOGIC_VECTOR(width-1 downto 0)); end; architecture behave mux2 begin y/H11021/H11005d0 /H11005'0' else d1; end;HDL Example 7.11 2:1 MULTIPLEXER # mipstest.asm # David_Harris@hmc.edu 9 November 2005 # # Test MIPS processor. # add, sub, and, or, slt, addi, lw, sw, beq, j # successful, write value 7 address 84 # Assembly Description Address Machine main : addi $2, $0, 5 # initialize $2 /H110055 0 20020005 addi $3, $0, 12 # initialize $3 /H1100512 4 2003000c addi $7, $3, /H110029 # initialize $7 /H110053 8 2067fff7 $4, $7, $2 # $4 /H11021/H110053 5 /H110057 c 00e22025 $5, $3, $4 # $5 /H11021/H1100512 7 /H110054 10 00642824 add $5, $5, $4 # $5 /H110054/H110017/H1100511 14 00a42820 beq $5, $7, end # shouldn’t taken 18 10a7000a slt $4, $3, $4 # $4 /H1100512/H110217/H110050 1c 0064202a beq $4, $0, around # taken 20 10800001 addi $5, $0, 0 # shouldn’t happen 24 20050000 around : slt $4, $7, $2 # $4 /H110053/H110215/H110051 28 00e2202a add $7, $4, $5 # $7 /H110051/H1100111/H1100512 2c 00853820 sub $7, $7, $2 # $7 /H1100512/H110025/H110057 30 00e23822 sw $7, 68($3) # [80] /H110057 34 ac670044 lw $2, 80($0) # $2 /H11005[80] /H110057 38 8c020050 j end # taken 3c 08000011 addi $2, $0, 1 # shouldn’t happen 40 20020001 end: sw $2, 84($0) # write adr 84 /H110057 44 ac020054 Figure 7.60 Assembly machine code MIPS test program20020005 2003000c 2067fff7 00e22025 00642824 00a42820 10a7000a 0064202a 10800001 20050000 00e2202a 00853820 00e23822 ac670044 8c020050 08000011 20020001 ac020054 Figure 7.61 Contents memfile.dat7.6.3 Testbench MIPS testbench loads program memories. program Figure 7.60 exercises instructions performing computation produce correct answer instructions functioning properly. Specifically, program write value 7 address 84 runs correctly, unlikely hardware buggy. example ad hoc testing.Chapter 07.qxd 2/1/07 9:33 PM Page 4287.6 HDL Representation 429 machine code stored hexadecimal file called memfile.dat (see Figure 7.61), loaded testbench simulation. file consists machine code instructions, one instruction per line. testbench, top-level MIPS module, external memory HDL code given following examples. memories example hold 64 words each. Verilog module testbench(); reg clk; reg reset; wire [31:0] writedata, dataadr; wire memwrite; // instantiate device tested top dut(clk, reset, writedata, dataadr, memwrite); // initialize test initial begin reset /H11021/H110051; # 22; reset /H11021/H110050; end // generate clock sequence tests always begin clk /H11021/H110051; # 5; clk /H11021/H110050; # 5; end // check results always @ (negedge clk) begin if(memwrite)begin if(dataadr /H11005/H11005/H1100584 & writedata /H11005/H11005/H110057)begin $display("Simulation succeeded"); $stop; end else if(dataadr ! /H11005/H1100580)begin $display("Simulation failed"); $stop; end end end endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; use IEEE.STD_LOGIC_UNSIGNED.all; entity testbench end; architecture test testbench component top port(clk, reset: STD_LOGIC; writedata, dataadr: STD_LOGIC_VECTOR(31 downto 0); memwrite: STD_LOGIC); end component; signal writedata, dataadr: STD_LOGIC_VECTOR(31 downto 0); signal clk, reset, memwrite: STD_LOGIC; begin — — instantiate device tested dut: top port map(clk, reset, writedata, dataadr, memwrite); — — Generate clock 10 ns period process begin clk /H11021/H11005'1'; wait 5 ns; clk /H11021/H11005'0'; wait 5 ns; end process; — — Generate reset first two clock cycles process begin reset /H11021/H11005'1'; wait 22 ns; reset /H11021/H11005'0'; wait; end process; — — check 7 gets written address 84 — — end program process (clk) begin (clk'event clk /H11005'0' memwrite /H11005'1') (conv_integer(dataadr) /H1100584 conv_integer (writedata) /H110057) report "Simulation succeeded"; elsif (dataadr / /H1100580) report "Simulation failed"; end if; end if; end process; end;HDL Example 7.12 MIPS TESTBENCHChapter 07.qxd 2/1/07 9:33 PM Page 429Verilog module top(input clk, reset, output [31:0] writedata, dataadr, output memwrite); wire [31:0] pc, instr, readdata; // instantiate processor memories mips mips(clk, reset, pc, instr, memwrite, dataadr, writedata, readdata); imem imem(pc[7:2], instr); dmem dmem(clk, memwrite, dataadr, writedata, readdata); endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; use IEEE.STD_LOGIC_UNSIGNED.all; entity top — — top-level design testing port(clk, reset: STD_LOGIC; writedata, dataadr: buffer STD_LOGIC_VECTOR(31downto 0); memwrite: buffer STD_LOGIC); end; architecture test top component mips port(clk, reset: STD_LOGIC; pc: STD_LOGIC_VECTOR(31 downto 0); instr: STD_LOGIC_VECTOR(31 downto 0); memwrite: STD_LOGIC; aluout, writedata: STD_LOGIC_VECTOR(31 downto 0); readdata: STD_LOGIC_VECTOR(31 downto 0)); end component; component imem port(a: STD_LOGIC_VECTOR(5 downto 0) rd: STD_LOGIC_VECTOR(31 downto 0)); end component; component dmem port(clk, we: STD_LOGIC; a, wd: STD_LOGIC_VECTOR(31 downto 0); rd: STD_LOGIC_VECTOR(31 downto 0)); end component; signal pc, instr, readdata: STD_LOGIC_VECTOR(31 downto 0); begin — — instantiate processor memories mips1: mips port map(clk, reset, pc, instr, memwrite, dataadr, writedata, readdata); imem1: imem port map(pc (7 downto 2), instr); dmem1: dmem port map(clk, memwrite, dataadr, writedata, readdata); end;HDL Example 7.13 MIPS TOP-LEVEL MODULE module dmem(input clk, we, input [31:0] a, wd, output [31:0] rd); reg [31:0] RAM[63:0]; assign rd /H11005RAM[a[31:2]]; // word aligned always @(posedge clk) if(we) RAM[a[31:2]] /H11021/H11005wd; endmodulelibrary IEEE; use IEEE.STD_LOGIC_1164.all; use STD.TEXTIO.all; use IEEE.STD_LOGIC_UNSIGNED.all; use IEEE.STD_LOGIC_ARITH.all; entity dmem — — data memory port(clk, we: STD_LOGIC; a, wd: STD_LOGIC_VECTOR(31 downto 0); rd: STD_LOGIC_VECTOR(31 downto 0)); end; architecture behave dmem begin process type ramtype array(63 downto 0) STD_LOGIC_VECTOR (31 downto 0); variable mem: ramtype; begin — — read write memory loop clk'event clk /H11005'1' if(we /H11005'1')then mem(CONV_INTEGER(a(7 downto 2))): /H11005wd; end if; end if; rd/H11021/H11005mem(CONV_INTEGER(a(7 downto 2))); wait clk, a; end loop; end process; end;HDL Example 7.14 MIPS DATA MEMORYChapter 07.qxd 2/1/07 9:33 PM Page 4307.7 EXCEPTIONS* Section 6.7.2 introduced exceptions, cause unplanned changes flow program. section, enhance multicycle processor support two types exceptions: undefined instructionsVerilog module imem(input [5:0] a, output [31:0] rd); reg[31:0] RAM[63:0]; initial begin $readmemh("memfile.dat",RAM); end assign rd /H11005RAM[a]; // word aligned endmoduleVHDL library IEEE; use IEEE.STD_LOGIC_1164.all; use STD.TEXTIO.all; use IEEE.STD_LOGIC_UNSIGNED.all; use IEEE.STD_LOGIC_ARITH.all; entity imem — — instruction memory port(a: STD_LOGIC_VECTOR(5 downto 0); rd: STD_LOGIC_VECTOR(31 downto 0)); end; architecture behave imem begin process file mem_file: TEXT; variable L: line; variable ch: character; variable index, result: integer; type ramtype array(63 downto 0)of STD_LOGIC_VECTOR (31 downto 0); variable mem: ramtype; begin — — initialize memory file 0 63 loop — set contents low mem(conv_integer(i)) : /H11005CONV_STD_LOGIC_VECTOR(0, 32); end loop; index : /H110050; FILE_OPEN(mem_file, "C:/mips/memfile.dat", READ_MODE); endfile(mem_file) loop readline(mem_file, L); result : /H110050; 1 8 loop read(L, ch); '0' /H11021/H11005ch ch /H11021/H11005'9' result : /H11005result*16 /H11001character'pos(ch) /H11002 character'pos('0'); elsif 'a' /H11021/H11005ch ch /H11021/H11005'f' result : /H11005result*16 /H11001character'pos(ch) /H11002 character'pos('a') /H1100110; else report "Format error line" & integer'image (index) severity error; end if; end loop; mem(index) : /H11005CONV_STD_LOGIC_VECTOR(result, 32); index : /H11005index /H110011; end loop; — — read memory loop rd/H11021/H11005mem(CONV_INTEGER(a)); wait a; end loop; end process; end;HDL Example 7.15 MIPS INSTRUCTION MEMORYChapter 07.qxd 2/1/07 9:33 PM Page 431and arithmetic overflow. Supporting exceptions microarchitec- tures follows similar principles. described Section 6.7.2, exception takes place, processor copies PC EPC register stores code Cause register indicating source exception. Exception causes include 0x28 undefined instructions 0x30 overflow (see Table 6.7). processor jumps exception handler memory address 0x80000180. exception handler code responds exception. part operating system. Also discussed Section 6.7.2, exception registers part Coprocessor 0 , portion MIPS processor used system functions. Coprocessor 0 defines 32 special-purpose registers, including Cause EPC. exception handler may use mfc0 (move coprocessor 0) instruction copy special-purpose registers general-purpose register register file; Cause reg- ister Coprocessor 0 register 13, EPC register 14. handle exceptions, must add EPC Cause registers datapath extend PCSrc multiplexer accept exception han- dler address, shown Figure 7.62. two new registers write enables, EPCWrite CauseWrite , store PC exception cause exception takes place. cause generated multiplexer432 CHAPTER SEVEN Microarchitecture SignImmCLK ARD Instr / Data Memory A1 A3 WD3RD2RD1WE3 A2CLK Sign ExtendRegister File0 10 1 PC0 1PC' Instr25:21 20:16 15:0SrcB 20:16 15:11 <<2ALUResultSrcA ALUOutRegDst Branch MemWrite MemtoReg ALUSrcA RegWrite ZeroPCSrc1:0 CLKALUControl2:0 ALU WDWECLK Adr 0 1DataCLKCLK B00 01 10 114CLK EN ENALUSrcB1:0IRWrite IorD PCWritePCEn <<2 25:0 (jump)31:28 27:0PCJump00 01 10 11 0x80000180OverflowCLK ENEPCWrite CLK ENCauseWrite 0 1IntCause 0x30 0x28 EPCCause Figure 7.62 Datapath supporting overflow undefined instruction exceptionsChapter 07.qxd 2/1/07 9:33 PM Page 4327.7 Exceptions 433 selects appropriate code exception. ALU must also generate overflow signal, discussed Section 5.2.4.5 support mfc0 instruction, also add way select Coprocessor 0 registers write register file, shown Figure 7.63. mfc0 instruction specifies Coprocessor 0 register Instr 15:11; diagram, Cause EPC registers sup- ported. add another input MemtoReg multiplexer select value Coprocessor 0. modified controller shown Figure 7.64. controller receives overflow flag ALU. generates three new control signals: one write EPC, second write Cause register, third select Cause. also includes two new states support two exceptions another state handle mfc0 . controller receives undefined instruction (one know handle), proceeds S12, saves PC EPC, writes 0x28 Cause register, jumps exception handler. Similarly, controller detects arithmetic overflow addor subinstruction, proceeds S13, saves PC EPC, writes 0x30 5Strictly speaking, ALU assert overflow add sub, ALU instructions.SignImmCLK ARD Instr / Data MemoryA1 A3 WD3RD2RD1WE3 A2CL K Sign ExtendRegister File0 10 1 PC0 1PC' Instr25:21 20:16 15:0SrcB 20:16 15:11 <<2ALUResultSrcA ALUOutRegDst Branch MemWrite MemtoReg ALUSrcA RegWrite ZeroPCSrc1:0 CLKALUControl2:0 ALU WDWECLK Adr 00 01DataCLKCL K B00 01 10 114CL K EN ENALUSrcB1:0IRWrite IorD PCWritePCEn <<2 25:0 (jump)31:28 27:0PCJump00 01 10 11 0x8000 0180CLK ENEPCWrite CL K ENCauseWrite 0 1IntCause 0x30 0x28 EPCCause Overflow... 01101 01110 ... 15:11 10C0 Figure 7.63 Datapath supporting mfc0Chapter 07.qxd 2/1/07 9:33 PM Page 433434 CHAPTER SEVEN Microarchitecture IorD = 0 AluSrcA = 0 ALUSrcB = 01 ALUOp = 00 PCSrc = 00 IRWriteALUSrcA = 0 ALUSrcB = 11 ALUOp = 00 ALUSrcA = 1 ALUSrcB = 10 ALUOp = 00 IorD = 1RegDst = 1 MemtoReg = 00 RegWriteIorD = 1 MemWriteALUSrcA = 1 ALUSrcB = 00 ALUOp = 10ALUSrcA = 1 ALUSrcB = 00 ALUOp = 01 PCSrc = 01 BranchResetS0: Fetch S2: MemAdrS1: Decode S3: MemReadS5: MemWriteS6: Execute S7: ALU WritebackS8: BranchOp = LW Op = SWOp = R-typeOp = BEQ Op = LWOp = SW RegDst = 0 MemtoReg = 01 RegWriteS4: Mem WritebackALUSrcA = 1 ALUSrcB = 10 ALUOp = 00 RegDst = 0 MemtoReg = 00 RegWriteOp = ADDI S9: ADDI Execute S10: ADDI WritebackPCSrc = 10 PCWriteOp = JS11: Jump Overflow Overflow S13: Overflow PCSrc = 11 PCWrite IntCause = 0 CauseWrite EPCWriteOp = others PCSrc = 11 PCWrite IntCause = 1 CauseWrite EPCWriteS12: Undefined Memtoreg = 10 RegWrite Op = MFC0S14: MFC0 PCWriteRegDst = 0 Figure 7.64 Controller supporting exceptions mfc0 Cause register, jumps exception handler. Note that, exception occurs, instruction discarded register file written. mfc0 instruction decoded, processor goes S14 writes appropriate Coprocessor 0 register main register file.Chapter 07.qxd 2/1/07 9:33 PM Page 4347.8 ADVANCED MICROARCHITECTURE* High-performance microprocessors use wide variety techniques run programs faster. Recall time required run program proportional period clock number clock cycles per instruction (CPI). Thus, increase performance would like speed clock and/or reduce CPI. section surveys existing speedup techniques. implementation details become quite complex, focus concepts. Hennessy & Patterson’s Computer Architecture text definitive reference want fully understand details. Every 2 3 years, advances CMOS manufacturing reduce tran- sistor dimensions 30% direction, doubling number transistors fit chip. manufacturing process character- ized feature size , indicates smallest transistor reliably built. Smaller transistors faster generally consume less power. Thus, even microarchitecture change, clock frequency increase gates faster. Moreover, smaller transistors enable placing transistors chip. Microarchitects use additional transistors build compli- cated processors put processors chip. Unfortunately, power consumption increases number transistors speed operate (see Section 1.8). Power consumption essential concern. Microprocessor designers challenging task juggling trade-offs among speed, power, cost chips billions transistors complex systems humans ever built. 7.8.1 Deep Pipelines Aside advances manufacturing, easiest way speed clock chop pipeline stages. stage contains less logic, run faster. chapter considered classic five-stage pipeline, 10 20 stages commonly used. maximum number pipeline stages limited pipeline haz- ards, sequencing overhead, cost. Longer pipelines introduce dependencies. dependencies solved forwarding, others require stalls, increase CPI. pipeline registers stage sequencing overhead setup time clk-to-Q delay (as well clock skew). sequencing overhead makes adding pipeline stages give diminishing returns. Finally, adding stages increases cost extra pipeline registers hardware required handle hazards.7.8 Advanced Microarchitecture 435Chapter 07.qxd 2/1/07 9:33 PM Page 435Example 7.11 DEEP PIPELINES Consider building pipelined processor chopping single-cycle proces- sor Nstages ( N/H110915). single-cycle processor propagation delay 900 ps combinational logic. sequencing overhead register 50 ps. Assume combinational delay arbitrarily divided number stages pipeline hazard logic increase delay. five-stage pipeline Example 7.9 CPI 1.15. Assume addi- tional stage increases CPI 0.1 branch mispredictions pipeline hazards. many pipeline stages used make proces- sor execute programs fast possible? Solution: 900-ps combinational logic delay divided Nstages stage also pays 50 ps sequencing overhead pipeline register, cycle time Tc/H11005900/N/H1100150. CPI 1.15 /H110010.1(N/H110025). time per instruction, instruction time, product cycle time CPI. Figure 7.65 plots cycle time instruction time versus number stages. instruction time minimum 231 ps N/H1100511 stages. minimum slightly better 250 ps per instruction achieved six-stage pipeline. late 1990s early 2000s, microprocessors marketed largely based clock frequency (1/ Tc). pushed microprocessors use deep pipelines (20 31 stages Pentium 4) maximize clock frequency, even benefits overall performance questionable. Power propor- tional clock frequency also increases number pipeline regis- ters, power consumption important, pipeline depths decreasing.436 CHAPTER SEVEN Microarchitecture 050100150200250300 5 6 7 8 9 10 11 12 13 14 15 Tc Instruction TimeNumber pipeline stagesTime (ps)Figure 7.65 Cycle time instruction time versus number pipeline stagesChapter 07.qxd 2/1/07 9:33 PM Page 4367.8.2 Branch Prediction ideal pipelined processor would CPI 1. branch mispre- diction penalty major reason increased CPI. pipelines get deeper, branches resolved later pipeline. Thus, branch mis- prediction penalty gets larger, instructions issued mispredicted branch must flushed. address problem, pipelined processors use branch predictor guess whether branch taken. Recall pipeline Section 7.5.3 simply pre- dicted branches never taken. branches occur program reaches end loop (e.g., foror statement) branches back repeat loop. Loops tend executed many times, backward branches usually taken. simplest form branch prediction checks direc- tion branch predicts backward branches taken. called static branch prediction , depend history program. Forward branches difficult predict without knowing specific program. Therefore, processors use dynamic branch predictors , use history program execution guess whether branch taken. Dynamic branch predictors maintain table last several hundred (or thousand) branch instructions processor executed. table, sometimes called branch target buffer , includes destination branch history whether branch taken. see operation dynamic branch predictors, consider fol- lowing loop code Code Example 6.20. loop repeats 10 times, beqout loop taken last time. add $s1, $0, $0 # sum /H110050 add $s0, $0, $0 # /H110050 addi $t0, $0, 10 # $t0 /H1100510 for: beq $s0, $t0, done # /H11005/H1100510, branch done add $s1, $s1, $s0 # sum /H11005sum /H11001i addi $s0, $s0, 1 # increment j done: one-bit dynamic branch predictor remembers whether branch taken last time predicts thing next time. loop repeating, remembers beqwas taken last time predicts taken next time. correct prediction last branch loop, branch get taken. Unfortunately, loop run again, branch predictor remembers last branch taken. Therefore,7.8 Advanced Microarchitecture 437Chapter 07.qxd 2/1/07 9:33 PM Page 437it incorrectly predicts branch taken loop first run again. summary, 1-bit branch predictor mispredicts first last branches loop. 2-bit dynamic branch predictor solves problem four states: strongly taken, weakly taken, weakly taken , strongly taken , shown Figure 7.66. loop repeating, enters “strongly taken” state predicts branch taken next time. correct last branch loop, taken moves predictor “weakly taken” state. loop first run again, branch predictor correctly predicts branch taken reenters “strongly taken” state. summary, 2-bit branch predictor mispredicts last branch loop. one imagine, branch predictors may used track even history program increase accuracy predictions. Good branch predictors achieve better 90% accuracy typical programs. branch predictor operates Fetch stage pipeline determine instruction execute next cycle. predicts branch taken, processor fetches next instruction branch destination stored branch target buffer. keeping track branch jump destinations branch target buffer, processor also avoid flushing pipeline jump instructions. 7.8.3 Superscalar Processor superscalar processor contains multiple copies datapath hard- ware execute multiple instructions simultaneously. Figure 7.67 shows block diagram two-way superscalar processor fetches executes two instructions per cycle. datapath fetches two instruc- tions time instruction memory. six-ported register file read four source operands write two results back cycle. also contains two ALUs two-ported data memory execute two instructions time.438 CHAPTER SEVEN Microarchitecture scalar processor acts one piece data time. vec- torprocessor acts several pieces data single instruction. superscalar processor issues several instructions time, operates one piece data. MIPS pipelined processor scalar proces- sor. Vector processors popular supercomputers 1980s 1990s efficiently han- dled long vectors data common scientific compu- tations. Modern high- performance microprocessors superscalar, issuing several independent instructions flexible processing vectors. However, modern proces- sors also include hardware handle short vectors data common multi- media graphics applica- tions. called single instruction multiple data (SIMD ) units.strongly taken predict takenweakly taken predict takenweakly taken predict takenstrongly taken predict taken taken taken takentaken taken taken takentaken Figure 7.66 2-bit branch predictor state transition diagramChapter 07.qxd 2/1/07 9:33 PM Page 438Figure 7.68 shows pipeline diagram illustrating two-way superscalar processor executing two instructions cycle. program, processor CPI 0.5. Designers commonly refer reciprocal CPI instructions per cycle , IPC. processor IPC 2 program. Executing many instructions simultaneously difficult dependencies. example, Figure 7.69 shows pipeline diagram run- ning program data dependencies. dependencies code shown blue. addinstruction dependent $t0, produced lwinstruction, cannot issued time lw. Indeed, addinstruction stalls yet another cycle lw forward $t0to addin cycle 5. dependencies (between7.8 Advanced Microarchitecture 439 CLK CLK CLK CLK ARD A1 A2 RD1 A3 WD3 WD6A4 A5 A6RD4 RD2 RD5Instruction MemoryRegister File Data MemoryPCCLK A1 A2 WD1ALUs WD2RD1 RD2 Figure 7.67 Superscalar datapath Time (cycles)12345678 RF40$s0 RF$t0 + DMIMlw addlw $t0, 40($s0) add $t1, $s1, $s2 sub $t2, $s1, $s3 $t3, $s3, $s4 $t4, $s1, $s5 sw $s5, 80($s0)$t1$s2$s1 + RF$s3$s1 RF$t2 - DMIMsub $t3$s4$s3 & RF +$s5$s1 RF$t4 | DMIMor sw80$s0$s5 Figure 7.68 Abstract view superscalar pipeline operationChapter 07.qxd 2/1/07 9:33 PM Page 439440 CHAPTER SEVEN Microarchitecture StallTime (cycles)12345678 RF40$s0 RF$t0+ DMIMlwlw $t0, 40($s0) add $t1, $t0, $s1 sub $t0, $s2, $s3 $t2, $s4, $t0 sw $s7, 80($t3)$s1$t0add RF$s1$t0 RF$t1+ DM RF$t0$s4 RF$t2 & DMIMand IMorandsub |$s6$s5$t3 RF80$t3 RF+ DMswIM $s79 $s3$s2 $s3$s2 -$t0 $t3, $s5, $s6 IMorRF suband andbased $t0, orand swbased $t3) handled forwarding results produced one cycle consumed next. program, also given below, requires five cycles issue six instructions, IPC 1.17. lw $t0, 40($s0) add $t1, $t0, $s1 sub $t0, $s2, $s3 $t2, $s4, $t0 $t3, $s5, $s6 sw $s7, 80($t3) Recall parallelism comes temporal spatial forms. Pipelining case temporal parallelism. Multiple execution units case spatial parallelism. Superscalar processors exploit forms parallelism squeeze performance far exceeding single- cycle multicycle processors. Commercial processors may three-, four-, even six-way super- scalar. must handle control hazards branches well data hazards. Unfortunately, real programs many dependencies, wide superscalar processors rarely fully utilize execution units. Moreover, large number execution units complex forwarding networks consume vast amounts circuitry power.Figure 7.69 Program data dependenciesChapter 07.qxd 2/1/07 9:33 PM Page 4407.8.4 Out-of-Order Processor cope problem dependencies, out-of-order processor looks ahead across many instructions issue, begin executing, independent instructions rapidly possible. instructions issued dif- ferent order written programmer, long dependencies honored program produces intended result. Consider running program Figure 7.69 two-way superscalar out-of-order processor. processor issue two instructions per cycle anywhere program, long depend- encies observed. Figure 7.70 shows data dependencies operation processor. classifications dependencies RAW WAR discussed shortly. constraints issuing instruc- tions described below. /L50776Cycle 1 – lwinstruction issues. – add,sub , andinstructions dependent lwby way $t0, cannot issue yet. However, orinstruction independent, also issues.7.8 Advanced Microarchitecture 441 Time (cycles)12345678 RF40$s0 RF$t0 + DMIMlwlw $t0, 40($s0) add $t1, $t0, $s1 sub $t0, $s2, $s3 $t2, $s4, $t0sw $s7, 80($t3)or |$s6$s5$t3 RF80$t3 RF+ DMsw $s7or $t3, $s5, $s6 IM RF$s1$t0 RF$t1 + DMIMadd sub-$s3$s2$t0Two-cycle latency lW use $t0 RAW WARRAW RF$t0$s4 RF& DMand IM$t2RAW Figure 7.70 Out-of-order execution program dependenciesChapter 07.qxd 2/1/07 9:33 PM Page 441/L50776Cycle 2 – Remember two-cycle latency lw instruction issues dependent instruction use result, addcannot issue yet $t0dependence. subwrites $t0, cannot issue add, lest addreceive wrong value $t0. dependent sub. – swinstruction issues. /L50776Cycle 3 – cycle 3, $t0is available, addissues. subissues simultane- ously, write $t0until addconsumes $t0. /L50776Cycle 4 – andinstruction issues. $t0is forwarded subto and. out-of-order processor issues six instructions four cycles, IPC 1.5. dependence addon lwby way $t0is read write (RAW) hazard. addmust read $t0until lwhas written it. type dependency accustomed handling pipelined processor. inherently limits speed program run, even infinitely many execution units available. Similarly, dependence swon orby way $t3and andon subby way $t0are RAW dependencies. dependence suband addby way $t0is called write read (WAR ) hazard antidependence . submust write $t0 addreads $t0, addreceives correct value according original order program. WAR hazards could occur simple MIPS pipeline, may happen out-of-order processor dependent instruction (in case, sub) moved early. WAR hazard essential operation program. merely artifact programmer’s choice use register two unrelated instructions. sub instruction written $t4 instead $t0, dependency would disappear subcould issued add. MIPS architecture 32 registers, sometimes programmer forced reuse register introduce hazard registers use. third type hazard, shown program, called write write (WAW ) output dependence . WAW hazard occurs instruction attempts write register subsequent instruction already written it. hazard would result wrong value being442 CHAPTER SEVEN MicroarchitectureChapter 07.qxd 2/1/07 9:33 PM Page 442written register. example, following program, addand sub write $t0. final value $t0 come sub according order program. out-of-order processor attempted execute subfirst, WAW hazard would occur. add $t0, $s1, $s2 sub $t0, $s3, $s4 WAW hazards essential either; again, artifacts caused programmer’s using register two unrelated instructions. subinstruction issued first, program could eliminate WAW hazard discarding result addinstead writing $t0. called squashing add.6 Out-of-order processors use table keep track instructions waiting issue. table, sometimes called scoreboard , contains information dependencies. size table determines many instructions considered issue. cycle, processor examines table issues many instructions can, limited dependencies number execution units (e.g., ALUs, memory ports) available. instruction level parallelism (ILP) number instructions executed simultaneously particular program microarchitecture. Theoretical studies shown ILP quite large out-of-order microarchitectures perfect branch pre- dictors enormous numbers execution units. However, practical processors seldom achieve ILP greater 2 3, even six-way superscalar datapaths out-of-order execution. 7.8.5 Register Renaming Out-of-order processors use technique called register renaming elim- inate WAR hazards. Register renaming adds nonarchitectural renaming registers processor. example, MIPS processor might add 20 renaming registers, called $r0–$r19 . programmer cannot use registers directly, part archi- tecture. However, processor free use eliminate hazards. example, previous section, WAR hazard occurred suband addinstructions based reusing $t0. out-of- order processor could rename$t0to $r0for subinstruction. Then7.8 Advanced Microarchitecture 443 6You might wonder addneeds issued all. reason out-of-order processors must guarantee exceptions occur would occurred program executed original order. addpotentially may produce overflow exception, must issued check exception, even though result discarded.Chapter 07.qxd 2/1/07 9:33 PM Page 443subcould executed sooner, $r0has dependency add instruction. processor keeps table registers renamed consistently rename registers subsequent dependent instructions. example, $t0 must also renamed $r0in andinstruction, refers result sub. Figure 7.71 shows program Figure 7.70 executing out-of-order processor register renaming. $t0is renamed $r0 suband andto eliminate WAR hazard. constraints issuing instructions described below. /L50776Cycle 1 – lwinstruction issues. – addinstruction dependent lwby way $t0, can- issue yet. However, subinstruction independent destination renamed $r0, subalso issues. /L50776Cycle 2 – Remember two-cycle latency lw issues dependent instruction use result, addcannot issue yet $t0dependence. – andinstruction dependent sub, issue. $r0is forwarded subto and. – orinstruction independent, also issues.444 CHAPTER SEVEN Microarchitecture Time (cycles)1234567 RF40$s0 RF$t0 + DMIMlwlw $t0, 40($s0) add $t1, $t0, $s1sub $r0, $s2, $s3 $t2, $s4, $r0 sw $s7, 80($t3)sub -$s3$s2$r0 RF$r0$s4 RF& DMand $s7or $t3, $s5, $s6IM RF$s1$t0 RF$t1 + DMIMadd sw+80$t3RAW $s6$s5 |orRAW RAW$t2 $t3 Figure 7.71 Out-of-order execution program using register renamingChapter 07.qxd 2/1/07 9:33 PM Page 444/L50776Cycle 3 – cycle 3, $t0is available, addissues. $t3is also available, swissues. out-of-order processor register renaming issues six instructions three cycles, IPC 2. 7.8.6 Single Instruction Multiple Data term SIMD (pronounced “sim-dee”) stands single instruction multiple data , single instruction acts multiple pieces data parallel. common application SIMD perform many short arithmetic operations once, especially graphics processing. also called packed arithmetic. example, 32-bit microprocessor might pack four 8-bit data elements one 32-bit word. Packed add subtract instructions operate four data elements within word parallel. Figure 7.72 shows packed 8-bit addition summing four pairs 8-bit numbers produce four results. word could also divided two 16-bit elements. Performing packed arithmetic requires modifying ALU eliminate carries smaller data elements. example, carry a0/H11001b0should affect result a1/H11001b1. Short data elements often appear graphics processing. exam- ple, pixel digital photo may use 8 bits store red, green, blue color components. Using entire 32-bit word process one components wastes upper 24 bits. components four adjacent pixels packed 32-bit word, processing performed four times faster. SIMD instructions even helpful 64-bit architectures, pack eight 8-bit elements, four 16-bit elements, two 32-bit elements single 64-bit word. SIMD instructions also used floating-point computations; example, four 32-bit single-precision floating-point values packed single 128-bit word.7.8 Advanced Microarchitecture 445 padd8 $s2, $s0, $s1 a00 78 1516 2324 32 $s0Bit position a1 a2 a3 b0$s1 b1 b2 b3 a0+ b0$s2 a1+ b1 a2+ b2 a3+ b3+Figure 7.72 Packed arithmetic: four simultaneous 8-bit additionsChapter 07.qxd 2/1/07 9:33 PM Page 4457.8.7 Multithreading ILP real programs tends fairly low, adding execution units superscalar out-of-order processor gives dimin- ishing returns. Another problem, discussed Chapter 8, memory much slower processor. loads stores access smaller faster memory, called cache . However, instruc- tions data available cache, processor may stall 100 cycles retrieving information main mem- ory. Multithreading technique helps keep processor many execution units busy even ILP program low program stalled waiting memory. explain multithreading, need define new terms. pro- gram running computer called process . Computers run multi- ple processes simultaneously; example, play music PC surfing web running virus checker. process consists one threads also run simultaneously. example, word processor may one thread handling user typing, second thread spell-checking document user works, third thread printing document. way, user wait, example, document finish printing able type again. conventional processor, threads give illusion run- ning simultaneously. threads actually take turns executed processor control OS. one thread’s turn ends, OS saves architectural state, loads architectural state next thread, starts executing next thread. procedure called context switching . long processor switches threads fast enough, user perceives threads running time. multithreaded processor contains one copy archi- tectural state, one thread active time. example, extended MIPS processor four program coun- ters 128 registers, four threads could available one time. one thread stalls waiting data main memory, processor could context switch another thread without delay, program counter registers already available. Moreover, one thread lacks sufficient parallelism keep execution units busy, another thread could issue instructions idle units. Multithreading improve performance individual thread, increase ILP. However, improve overall throughput processor, multiple threads use processor resources would idle executing single thread. Multithreading also relatively inexpensive implement, replicates PC register file, execution units memories.446 CHAPTER SEVEN MicroarchitectureChapter 07.qxd 2/1/07 9:33 PM Page 4467.8.8 Multiprocessors multiprocessor system consists multiple processors method communication processors. common form multi- processing computer systems symmetric multiprocessing (SMP), two identical processors share single main memory. multiple processors may separate chips multiple cores chip. Modern processors enormous numbers transistors available. Using increase pipeline depth add exe- cution units superscalar processor gives little performance benefit wasteful power. Around year 2005, computer architects made major shift build multiple copies processor chip; copies called cores. Multiprocessors used run threads simultaneously run particular thread faster. Running threads simultaneously easy; threads simply divided among processors. Unfortunately typical PC users need run small number threads given time. Running particular thread faster much challenging. programmer must divide thread pieces perform processor. becomes tricky processors need communicate other. One major challenges computer designers programmers effectively use large numbers processor cores. forms multiprocessing include asymmetric multiprocessing clusters. Asymmetric multiprocessors use separate specialized micro- processors separate tasks. example, cell phone contains digi- tal signal processor (DSP) specialized instructions decipher wireless data real time separate conventional processor inter- act user, manage phone book, play games. clustered multiprocessing , processor local memory system. Clustering also refer group PCs connected together network running software jointly solve large problem. 7.9 REAL-WORLD PERSPECTIVE: IA-32 MICROARCHITECTURE* Section 6.8 introduced IA-32 architecture used almost PCs. section tracks evolution IA-32 processors progres- sively faster complicated microarchitectures. principles applied MIPS microarchitectures used IA-32. Intel invented first single-chip microprocessor, 4-bit 4004, 1971 flexible controller line calculators. contained 2300 transistors manufactured 12-mm2sliver silicon process 10- /H9262m feature size operated 750 KHz. photo- graph chip taken microscope shown Figure 7.73.7.9 Real-World Perspective: IA-32 Microarchitecture 447 Scientists searching signs extraterrestrial intelligence use world’s largest clus- tered multiprocessors ana- lyze radio telescope data patterns might signs life solar systems. cluster consists per- sonal computers owned 3.8 million volun- teers around world. computer cluster idle, fetches piece data centralized server, analyzes data, sends results back server. volunteer computer’s idle time cluster visiting setiathome.berkeley.edu.Chapter 07.qxd 2/1/07 9:33 PM Page 447In places, columns four similar-looking structures visible, one would expect 4-bit microprocessor. Around periphery bond wires , used connect chip package circuit board. 4004 inspired 8-bit 8008, 8080, eventually evolved 16-bit 8086 1978 80286 1982. 1985, Intel introduced 80386, extended 8086 architecture 32 bits defined IA-32 architecture. Table 7.7 summarizes major Intel IA-32 microprocessors. 35 years since 4004, transistor feature size shrunk 160-fold, number transistors448 CHAPTER SEVEN Microarchitecture Figure 7.73 4004 microprocessor chip Table 7.7 Evolution Intel IA-32 microprocessors Processor Year Feature Size ( /H9262m) Transistors Frequency (MHz) Microarchitecture 80386 1985 1.5–1.0 275k 16–25 multicycle 80486 1989 1.0–0.6 1.2M 25–100 pipelined Pentium 1993 0.8–0.35 3.2–4.5M 60–300 superscalar Pentium II 1997 0.35–0.25 7.5M 233–450 order Pentium III 1999 0.25–0.18 9.5M–28M 450–1400 order Pentium 4 2001 0.18–0.09 42–178M 1400–3730 order Pentium 2003 0.13–0.09 77–140M 900–2130 order Core Duo 2005 0.065 152M 1500–2160 dual coreChapter 07.qxd 2/1/07 9:33 PM Page 448on chip increased five orders magnitude, operating frequency increased almost four orders magnitude. field engineering made astonishing progress short time. 80386 multicycle processor. major components labeled chip photograph Figure 7.74. 32-bit datapath clearly visible left. columns processes one bit data. control signals generated using microcode PLA steps various states control FSM. memory man- agement unit upper right controls access external memory. 80486, shown Figure 7.75, dramatically improved perform- ance using pipelining. datapath clearly visible, along control logic microcode PLA. 80486 added on-chip floating-point unit; previous Intel processors either sent floating-point instructions separate coprocessor emulated software. 80486 fast external memory keep up, incorporated 8-KB cache onto chip hold commonly used instruc- tions data. Chapter 8 describes caches detail revisits cache systems Intel IA-32 processors.7.9 Real-World Perspective: IA-32 Microarchitecture 449 Microcode PLA32-bit DatapathMemory Management Unit ControllerFigure 7.74 80386 microprocessor chipChapter 07.qxd 2/1/07 9:33 PM Page 449The Pentium processor, shown Figure 7.76, superscalar processor capable executing two instructions simultaneously. Intel switched name Pentium instead 80586 AMD becoming serious competitor selling interchangeable 80486 chips, part numbers cannot trademarked. Pentium uses separate instruction data caches. also uses branch predictor reduce performance penalty branches. Pentium Pro, Pentium II, Pentium III processors share common out-of-order microarchitecture, code named P6. complex IA-32 instructions broken one micro-ops similar450 CHAPTER SEVEN Microarchitecture 32-bit Data pathController 8 KB Cache Floating Point Unit Microcode PLAFigure 7.75 80486 microprocessor chipChapter 07.qxd 2/1/07 9:33 PM Page 4507.9 Real-World Perspective: IA-32 Microarchitecture 451 MIPS instructions. micro-ops executed fast out-of- order execution core 11-stage pipeline. Figure 7.77 shows Pentium III. 32-bit datapath called Integer Execution Unit (IEU). floating-point datapath called Floating Point Unit 8 KB Data CacheFloating Point Unit8 KB Instruction Cache Multiprocessor LogicInstruction Fetch & Decode Complex Instruction SupportBus Interface Unit32-bit DatapathSuperscalar ControllerBranch Prediction Figure 7.76 Pentium microprocessor chip Instruction Fetch & 16 KB Cache16 KB Data CacheData TLB Branch Target BufferFPU IEU SIMD Register RenamingMicrocode PLA256 KB Level 2 Cache Order Issue LogicBus Logic Figure 7.77 Pentium III microprocessor chipChapter 07.qxd 2/1/07 9:33 PM Page 451452 CHAPTER SEVEN Microarchitecture IEU8 KB Data CacheTrace Cache 256 KB Level 2 CacheFPU & SIMDBus Logic Figure 7.78 Pentium 4 microprocessor chip(FPU). processor also SIMD unit perform packed opera- tions short integer floating-point data. larger portion chip dedicated issuing instructions out-of-order actually executing instructions. instruction data caches grown 16 KB each. Pentium III also larger slower 256-KB second-level cache chip. late 1990s, processors marketed largely clock speed. Pentium 4 another out-of-order processor deep pipeline achieve extremely high clock frequencies. started 20 stages, later versions adopted 31 stages achieve frequencies greater 3 GHz. chip, shown Figure 7.78, packs 42 178 million transistors (depending cache size), even major exe- cution units difficult see photograph. Decoding three IA-32 instructions per cycle impossible high clock frequencies instruction encodings complex irregular. Instead, processor predecodes instructions simpler micro-ops, stores micro-ops memory called trace cache . Later versions Pentium 4 also perform multithreading increase throughput multiple threads. Pentium 4’s reliance deep pipelines high clock speed led extremely high power consumption, sometimes 100 W. unacceptable laptops makes cooling desktops expensive.Chapter 07.qxd 2/1/07 9:33 PM Page 452Intel discovered older P6 architecture could achieve comparable performance much lower clock speed power. Pentium uses enhanced version P6 out-of-order microarchitecture 32-KB instruction data caches 1- 2-MB second-level cache. Core Duo multicore processor based two Pentium cores con- nected shared 2-MB second-level cache. individual functional units Figure 7.79 difficult see, two cores large cache clearly visible. 7.10 SUMMARY chapter described three ways build MIPS processors, different performance cost trade-offs. find topic almost magical: seemingly complicated device microprocessor actually simple enough fit half-page schematic? Moreover, inner workings, mysterious uniniti- ated, actually reasonably straightforward. MIPS microarchitectures drawn together almost every topic covered text far. Piecing together microarchitecture puzzle illustrates principles introduced previous chapters, includ- ing design combinational sequential circuits, covered Chapters 2 3; application many building blocks described Chapter 5; implementation MIPS architec- ture, introduced Chapter 6. MIPS microarchitectures described pages HDL, using techniques Chapter 4. Building microarchitectures also heavily used tech- niques managing complexity. microarchitectural abstraction forms link logic architecture abstractions, forming7.10 Summary 453 Core 1 Core 2 2 MB Shared Level 2 CacheFigure 7.79 Core Duo microprocessor chipChapter 07.qxd 2/1/07 9:33 PM Page 453the crux book digital design computer architecture. also use abstractions block diagrams HDL succinctly describe arrangement components. microarchitectures exploit regularity modularity, reusing library common building blocks ALUs, memories, multiplexers, registers. Hierarchy used numerous ways. microarchitectures partitioned datapath control units. units built logic blocks, built gates, turn built transistors using techniques developed first five chapters. chapter compared single-cycle, multicycle, pipelined microarchitectures MIPS processor. three microarchitectures implement subset MIPS instruction set architectural state. single-cycle processor straight- forward CPI 1. multicycle processor uses variable number shorter steps execute instructions. thus reuse ALU, rather requiring several adders. However, require several nonarchitectural regis- ters store results steps. multicycle design principle could faster, instructions must equally long. practice, generally slower, limited slowest steps sequencing overhead step. pipelined processor divides single-cycle processor five relatively fast pipeline stages. adds pipeline registers stages separate five instructions simultaneously executing. nominally CPI 1, hazards force stalls flushes increase CPI slightly. Hazard resolution also costs extra hard- ware design complexity. clock period ideally could five times shorter single-cycle processor. practice, short, limited slowest stage sequencing overhead stage. Nevertheless, pipelining provides substantial per- formance benefits. modern high-performance microprocessors use pipelining today. Although microarchitectures chapter implement subset MIPS architecture, seen supporting instructions involves straightforward enhancements datapath controller. Supporting exceptions also requires simple modifications. major limitation chapter assumed ideal memory system fast large enough store entire program data. reality, large fast memories prohibitively expensive. next chapter shows get benefits large fast mem- ory small fast memory holds commonly used infor- mation one larger slower memories hold rest information.454 CHAPTER SEVEN MicroarchitectureChapter 07.qxd 2/1/07 9:33 PM Page 454Exercises 455 Exercises Exercise 7.1 Suppose one following control signals single-cycle MIPS processor stuck-at-0 fault , meaning signal always 0, regardless intended value. instructions would malfunction? Why? (a)RegWrite (b)ALUOp 1 (c)MemWrite Exercise 7.2 Repeat Exercise 7.1, assuming signal stuck-at-1 fault. Exercise 7.3 Modify single-cycle MIPS processor implement one following instructions. See Appendix B definition instructions. Mark copy Figure 7.11 indicate changes datapath. Name new control signals. Mark copy Table 7.8 show changes main decoder. Describe changes required. (a)sll (b)lui (c)slti (d)blez (e)jal (f)lh Exercise 7.4 Many processor architectures load postincrement instruction, updates index register point next memory word completing load. lwinc $rt, imm($rs) equivalent following two instructions: lw $rt, imm($rs) addi $rs, $rs, 4Table 7.8 Main decoder truth table mark changes Instruction Opcode RegWrite RegDst ALUSrc Branch MemWrite MemtoReg ALUOp R-type 000000 1 1 0 0 0 0 10 lw 100011 1 0 1 0 0 1 00 sw 101011 0 X 1 0 1 X 00 beq 000100 0 X 0 1 0 X 01Chapter 07.qxd 2/1/07 9:33 PM Page 455Repeat Exercise 7.3 lwinc instruction. possible add instruction without modifying register file? Exercise 7.5 Add single-precision floating-point unit single-cycle MIPS processor handle add.s, sub.s , mul.s . Assume single-pre- cision floating-point adder multiplier units available. Explain changes must made datapath controller. Exercise 7.6 friend crack circuit designer. offered redesign one units single-cycle MIPS processor half delay. Using delays Table 7.6, unit work obtain greatest speedup overall processor, would cycle time improved machine be? Exercise 7.7 Consider delays given Table 7.6. Ben Bitdiddle builds prefix adder reduces ALU delay 20 ps. element delays stay same, find new cycle time single-cycle MIPS processor determine long takes execute benchmark 100 billion instructions. Exercise 7.8 Suppose one following control signals multicycle MIPS processor stuck-at-0 fault, meaning signal always 0, regardless intended value. instructions would malfunction? Why? (a)MemtoReg (b)ALUOp 0 (c)PCSrc Exercise 7.9 Repeat Exercise 7.8, assuming signal stuck-at-1 fault. Exercise 7.10 Modify HDL code single-cycle MIPS processor, given Section 7.6.1, handle one new instructions Exercise 7.3. Enhance testbench, given Section 7.6.3 test new instruction. Exercise 7.11 Modify multicycle MIPS processor implement one fol- lowing instructions. See Appendix B definition instructions. Mark copy Figure 7.27 indicate changes datapath. Name new control signals. Mark copy Figure 7.39 show changes con- troller FSM. Describe changes required. (a)srlv (b)ori (c)xori (d)jr (e)bne (f)lbu456 CHAPTER SEVEN MicroarchitectureChapter 07.qxd 2/1/07 9:33 PM Page 456Exercise 7.12 Repeat Exercise 7.4 multicycle MIPS processor. Show changes multicycle datapath control FSM. possible add instruction without modifying register file? Exercise 7.13 Repeat Exercise 7.5 multicycle MIPS processor. Exercise 7.14 Suppose floating-point adder multiplier Exercise 7.13 take two cycles operate. words, inputs applied beginning one cycle, output available second cycle. answer Exercise 7.13 change? Exercise 7.15 friend, crack circuit designer, offered redesign one units multicycle MIPS processor much faster. Using delays Table 7.6, unit work obtain greatest speedup overall processor? fast be? (Making faster necessary waste friend’s effort.) cycle time improved processor? Exercise 7.16 Repeat Exercise 7.7 multicycle processor. Exercise 7.17 Suppose multicycle MIPS processor component delays given Table 7.6. Alyssa P. Hacker designs new register file 40% less power twice much delay. switch slower lower power register file multicycle processor design? Exercise 7.18 Goliath Corp claims patent three-ported register file. Rather fighting Goliath court, Ben Bitdiddle designs new register file single read/write port (like combined instruction data memory). Redesign MIPS multicycle datapath controller use new register file. Exercise 7.19 CPI redesigned multicycle MIPS processor Exercise 7.18? Use instruction mix Example 7.7. Exercise 7.20 many cycles required run following program multicycle MIPS processor? CPI program? addi $s0, $0, 5 # sum /H110055 while: beq $s0, $0, done# result /H110220, execute block addi $s0, $s0, /H110021 # block: result /H11005result /H110021 j done:Exercises 457Chapter 07.qxd 2/1/07 9:33 PM Page 457Exercise 7.21 Repeat Exercise 7.20 following program. add $s0, $0, $0 # /H110050 add $s1, $0, $0 # sum /H110050 addi $t0, $0, 10 # $t0 /H1100510 loop: slt $t1, $s0, $t0 # (i /H1102110), $t1 /H110051, else $t1 /H110050 beq $t1, $0, done # $t1 /H11005/H110050 (i /H11022/H1100510), branch done add $s1, $s1, $s0 # sum /H11005sum /H11001i addi $s0, $s0, 1 # increment j loop done: Exercise 7.22 Write HDL code multicycle MIPS processor. processor compatible following top-level module. mem module used hold instructions data. Test processor using testbench Section 7.6.3. module top(input clk, reset, output [31:0] writedata, adr, output memwrite); wire [31:0] readdata; // instantiate processor memories mips mips(clk, reset, adr, writedata, memwrite, readdata); mem mem(clk, memwrite, adr, writedata, readdata); endmodule module mem(input clk, we, input [31:0] a, wd, output [31:0] rd); reg [31:0] RAM[63:0]; initial begin $readmemh(“memfile.dat”,RAM); end assign rd /H11005RAM[a[31:2]]; // word aligned always @ (posedge clk) (we) RAM[a[31:2]] /H11021/H11005wd; endmodule Exercise 7.23 Extend HDL code multicycle MIPS processor Exercise 7.22 handle one new instructions Exercise 7.11. Enhance testbench test new instruction.458 CHAPTER SEVEN MicroarchitectureChapter 07.qxd 2/1/07 9:33 PM Page 458Exercise 7.24 pipelined MIPS processor running following program. registers written, read fifth cycle? add $s0, $t0, $t1 sub $s1, $t2, $t3 $s2, $s0, $s1 $s3, $t4, $t5 slt $s4, $s2, $s3 Exercise 7.25 Using diagram similar Figure 7.52, show forwarding stalls needed execute following instructions pipelined MIPS processor. add $t0, $s0, $s1 sub $t0, $t0, $s2 lw $t1, 60($t0) $t2, $t1, $t0 Exercise 7.26 Repeat Exercise 7.25 following instructions. add $t0, $s0, $s1 lw $t1, 60($s2) sub $t2, $t0, $s3 $t3, $t1, $t0 Exercise 7.27 many cycles required pipelined MIPS processor issue instructions program Exercise 7.21? CPI processor program? Exercise 7.28 Explain extend pipelined MIPS processor handle addi instruction. Exercise 7.29 Explain extend pipelined processor handle j instruction. Give particular attention pipeline flushed jump takes place. Exercise 7.30 Examples 7.9 7.10 point pipelined MIPS proces- sor performance might better branches take place Execute stage rather Decode stage. Show modify pipelined processor Figure 7.58 branch Execute stage. stall flush signals change? Redo Examples 7.9 7.10 find new CPI, cycle time, overall time execute program. Exercise 7.31 friend, crack circuit designer, offered redesign one units pipelined MIPS processor much faster. Using delays Table 7.6 Example 7.10, unit work obtain greatest speedup overall processor? fast be? (Making faster necessary waste friend’s effort.) cycle time improved processor?Exercises 459Chapter 07.qxd 2/1/07 9:33 PM Page 459Exercise 7.32 Consider delays Table 7.6 Example 7.10. suppose ALU 20% faster. Would cycle time pipelined MIPS processor change? ALU 20% slower? Exercise 7.33 Write HDL code pipelined MIPS processor. processor compatible top-level module HDL Example 7.13. support instructions described chapter, including addi j(see Exercises 7.28 7.29). Test design using testbench HDL Example 7.12. Exercise 7.34 Design hazard unit shown Figure 7.58 pipelined MIPS processor. Use HDL implement design. Sketch hardware synthesis tool might generate HDL. Exercise 7.35 nonmaskable interrupt (NMI ) triggered input pin processor. pin asserted, current instruction finish, processor set Cause register 0 take exception. Show modify multicycle processor Figures 7.63 7.64 handle nonmaskable interrupts.460 CHAPTER SEVEN MicroarchitectureChapter 07.qxd 2/1/07 9:33 PM Page 460Interview Questions following exercises present questions asked interviews digital design jobs. Question 7.1 Explain advantages pipelined microprocessors. Question 7.2 additional pipeline stages allow processor go faster, don’t processors 100 pipeline stages? Question 7.3 Describe hazard microprocessor explain ways resolved. pros cons way? Question 7.4 Describe concept superscalar processor pros cons.Interview Questions 461Chapter 07.qxd 2/1/07 9:33 PM Page 4618 8.1 Introduction 8.2 Memory System Performance Analysis 8.3 Caches 8.4 Virtual Memory 8.5 Memory-Mapped I/O* 8.6 Real-World Perspective: IA-32 Memory I/O Systems* 8.7 Summary Exercises Interview QuestionsMemory Systems 8.1 INTRODUCTION Computer system performance depends memory system well processor microarchitecture. Chapter 7 assumed ideal mem- ory system could accessed single clock cycle. However, would true small memory—or slow processor! Early processors relatively slow, memory able keep up. processor speed increased faster rate memory speeds. DRAM memories currently 10 100 times slower proces- sors. increasing gap processor DRAM memory speeds demands increasingly ingenious memory systems try approximate memory fast processor. chapter investigates practical memory systems considers trade-offs speed, capacity, cost. processor communicates memory system mem- ory interface . Figure 8.1 shows simple memory interface used multicycle MIPS processor. processor sends address Address bus memory system. read, MemWrite 0 memory returns data ReadData bus. write, MemWrite 1 processor sends data memory WriteData bus. major issues memory system design broadly explained using metaphor books library. library contains many books shelves. writing term paper meaning dreams, might go library1and pull Freud’s Interpretation Dreams shelf bring cubicle. skimming it, might put back pull Jung’s Psychology 4631We realize library usage plummeting among college students Internet. also believe libraries contain vast troves hard-won human knowledge electronically available. hope Web searching completely displace art library research.Chapter 08.qxd 1/30/07 9:53 Page 463Unconscious . might go back another quote Interpretation Dreams , followed yet another trip stacks Freud’s Ego Id . Pretty soon would get tired walking cubicle stacks. clever, would save time keeping books cubicle rather schlepping back forth. Furthermore, pull book Freud, could also pull several books shelf. metaphor emphasizes principle, introduced Section 6.2.1, making common case fast. keeping books recently used might likely use future cubicle, reduce number time-consuming trips stacks. particular, use principles temporal spatial locality . Temporal locality means used book recently, likely use soon. Spatial locality means use one particular book, likely interested books shelf. library makes common case fast using princi- ples locality. library neither shelf space budget accommodate books world. Instead, keeps lesser-used books deep storage basement. Also, may interlibrary loan agreement nearby libraries offer books physically carries. summary, obtain benefits large collection quick access commonly used books hierarchy storage. commonly used books cubicle. larger collection shelves. even larger collection available, advanced notice, basement libraries. Similarly, memory systems use hierarchy storage quickly access commonly used data still capacity store large amounts data. Memory subsystems used build hierarchy introduced Section 5.5. Computer memories primarily built dynamic RAM (DRAM) static RAM (SRAM). Ideally, computer memory sys- tem fast, large, cheap. practice, single memory two three attributes; either slow, small, expensive. com- puter systems approximate ideal combining fast small cheap memory slow large cheap memory. fast memory stores commonly used data instructions, average memory464 CHAPTER EIGHT Memory Systems Processor MemoryAddressMemWrite WriteDataReadDataWECLK Figure 8.1 memory interface Chapter 08.qxd 1/30/07 9:53 Page 464system appears fast. large memory stores remainder data instructions, overall capacity large. combination two cheap memories much less expensive single large fast memory. principles extend using entire hierarchy memories increasing capacity decreasing speed. Computer memory generally built DRAM chips. 2006, typical PC main memory consisting 256 MB 1 GB DRAM, DRAM cost $100 per gigabyte (GB). DRAM prices declined 30% per year last three decades, memory capacity grown rate, total cost memory PC remained roughly constant. Unfortunately, DRAM speed improved 7% per year, whereas processor performance improved rate 30 50% per year, shown Figure 8.2. plot shows memory processor speeds 1980 speeds baseline. 1980, processor memory speeds same. performance diverged since then, memories badly lagging. DRAM could keep processors 1970s early 1980’s, woefully slow. DRAM access time one two orders magnitude longer processor cycle time (tens nanoseconds, compared less one nanosecond). counteract trend, computers store commonly used instructions data faster smaller memory, called cache . cache usually built SRAM chip processor. cache speed comparable processor speed, SRAM inherently faster DRAM, on-chip memory elimi- nates lengthy delays caused traveling separate chip. 2006, on-chip SRAM costs order $10,000/GB, cache relatively small (kilobytes megabytes), overall8.1 Introduction 465 Ye rCPU100,000 10,000 1001000Performance 10 1 1980198119821983 198519861987198819891990199119921993199419951996199719981999200020012002200320042005 1984MemoryFigure 8.2 Diverging processor memory performance Adapted permission Hennessy Patterson, Computer Architecture: Quantitative Approach , 3rd ed., Morgan Kaufmann, 2003.Chapter 08.qxd 1/30/07 9:53 Page 465cost low. Caches store instructions data, refer contents generically “data.” processor requests data available cache, returned quickly. called cache hit. Otherwise, processor retrieves data main memory (DRAM). called cache miss. cache hits time, processor seldom wait slow main memory, average access time low. third level memory hierarchy hard disk , hard drive . way library uses basement store books fit stacks, computer systems use hard disk store data fit main memory. 2006, hard disk cost less $1/GB access time 10 ms. Hard disk costs decreased 60%/year access times scarcely improved. hard disk provides illusion capacity actually exists main memory. thus called virtual memory . Like books basement, data virtual memory takes long time access. Main memory, also called physical memor y, holds subset virtual memory. Hence, main memory viewed cache commonly used data hard disk. Figure 8.3 summarizes memory hierarchy computer sys- tem discussed rest chapter. processor first seeks data small fast cache usually located chip. data available cache, processor looks main memory. data either, processor fetches data virtual memory large slow hard disk. Figure 8.4 illustrates capacity speed trade-off memory hierarchy lists typical costs access times 2006 technology. access time decreases, speed increases. Section 8.2 introduces memory system performance analysis. Section 8.3 explores several cache organizations, Section 8.4 delves virtual memory systems. conclude, chapter explores processors access input output devices, keyboards monitors, much way access memory. Section 8.5 investigates memory-mapped I/O.466 CHAPTER EIGHT Memory Systems CPU CacheMain MemoryProcessor ChipCLK Hard DiskFigure 8.3 typical memory hierarchyChapter 08.qxd 1/30/07 9:53 Page 4668.2 MEMORY SYSTEM PERFORMANCE ANALYSIS Designers (and computer buyers) need quantitative ways measure performance memory systems evaluate cost-benefit trade-offs various alternatives. Memory system performance metrics miss rateor hit rate average memory access time . Miss hit rates calculated as: Number missesMiss Rate /H11005------------------------------------------------------------------------------------- /H110051/H11002Hit Rate (8.1)Number total memory accesses Number hitsHit Rate /H11005------------------------------------------------------------------------------------- /H110051/H11002Miss RateNumber total memory accesses Example 8.1 CALCULATING CACHE PERFORMANCE Suppose program 2000 data access instructions (loads stores), 1250 requested data values found cache. 750 data values supplied processor main memory disk memory. miss hit rates cache? Solution: miss rate 750/2000 /H110050.375 /H1100537.5%. hit rate 1250/2000 /H110050.625 /H110051/H110020.375 /H1100562.5%. Average memory access time (AMAT) average time processor must wait memory per load store instruction. typical computer system Figure 8.3, processor first looks data cache. cache misses, processor looks main memory. main memory misses, processor accesses virtual memory hard disk. Thus, AMAT calculated as: AMAT /H11005tcache /H11001MR cache(tMM/H11001MR MMtVM) (8.2)8.2 Memory System Performance Analysis 467 Cache Main MemorySpeed Virtual Memory CapacityTechnology Cost/GB Access Time SRAM ~ $10,000 ~ 1 ns DRAM ~ $100 ~ 100 ns Hard Disk ~ $1 ~ 10,000,000 nsFigure 8.4 Memory hierarchy components, typical characteristics 2006Chapter 08.qxd 1/30/07 9:53 Page 467where tcache, tMM, tVMare access times cache, main memory, virtual memory, MR cacheand MR MMare cache main memory miss rates, respectively. Example 8.2 CALCULATING VERAGE MEMORY ACCESS TIME Suppose computer system memory organization two levels hierarchy, cache main memory. average memory access time given access times miss rates given Table 8.1? Solution: average memory access time 1 /H110010.1(100) /H1100511 cycles.468 CHAPTER EIGHT Memory Systems Table 8.1 Access times miss rates Memory Access Time Miss Level (Cycles) Rate Cache 1 10% Main Memory 100 0% Gene Amdahl, 1922–. famous Amdahl’s Law, observation made 1965. graduate school, began designing computers free time. side work earned Ph.D. theo- retical physics 1952. joined IBM immediately graduation, later went found three companies, including one called Amdahl Corporation 1970. Example 8.3 IMPROVING ACCESS TIME 11-cycle average memory access time means processor spends ten cycles waiting data every one cycle actually using data. cache miss rate needed reduce average memory access time 1.5 cycles given access times Table 8.1? Solution: miss rate m, average access time 1 /H11001100m. Setting time 1.5 solving mrequires cache miss rate 0.5%. word caution, performance improvements might always good sound. example, making memory system ten times faster necessarily make computer program run ten times fast. 50% program’s instructions loads stores, ten- fold memory system improvement means 1.82-fold improvement program performance. general principle called Amdahl’s Law , says effort spent increasing performance sub- system worthwhile subsystem affects large percentage overall performance. 8.3 CACHES cache holds commonly used memory data. number data words hold called capacity, C . capacityChapter 08.qxd 1/30/07 9:53 Page 468of cache smaller main memory, computer sys- tem designer must choose subset main memory kept cache. processor attempts access data, first checks cache data. cache hits, data available immediately. cache misses, processor fetches data main memory places cache future use. accommodate new data, cache must replace old data. section investigates issues cache design answering following questions: (1) data held cache? (2) data found? (3) data replaced make room new data cache full? reading next sections, keep mind driving force answering questions inherent spatial temporal locality data accesses applications. Caches use spatial temporal locality predict data needed next. program accesses data random order, would benefit cache. explain following sections, caches specified capacity ( C), number sets ( S), block size ( b), number blocks ( B), degree associativity ( N). Although focus data cache loads, principles apply fetches instruction cache. Data cache store operations similar discussed Section 8.3.4. 8.3.1 Data Held Cache? ideal cache would anticipate data needed processor fetch main memory ahead time cache zero miss rate. impossible predict future perfect accuracy, cache must guess data needed based past pattern memory accesses. particular, cache exploits tempo- ral spatial locality achieve low miss rate. Recall temporal locality means processor likely access piece data soon accessed data recently. Therefore, processor loads stores data cache, data copied main memory cache. Subsequent requests data hit cache. Recall spatial locality means that, processor accesses piece data, also likely access data nearby memory locations. Therefore, cache fetches one word memory, may also fetch several adjacent words. group words called cache block . number words cache block, b, called block size. cache capacity Ccontains B/H11005C/bblocks. principles temporal spatial locality experimen- tally verified real programs. variable used program, the8.3 Caches 469 Cache : hiding place especially concealing preserving provisions implements. – Merriam Webster Online Dictionary. 2006. http:// www.merriam-webster.comChapter 08.qxd 1/30/07 9:53 Page 469same variable likely used again, creating temporal locality. element array used, elements array also likely used, creating spatial locality. 8.3.2 Data Found? cache organized sets , holds one blocks data. relationship address data main memory location data cache called mapping . memory address maps exactly one set cache. address bits used determine cache set contains data. set contains one block, data may kept blocks set. Caches categorized based number blocks set. direct mapped cache, set contains exactly one block, cache S/H11005Bsets. Thus, particular main memory address maps unique block cache. N-way set associative cache, set contains Nblocks. address still maps unique set, S/H11005B/N sets. data address go Nblocks set. fully associative cache S/H110051 set. Data go Bblocks set. Hence, fully associative cache another name B-way set associative cache. illustrate cache organizations, consider MIPS memory system 32-bit addresses 32-bit words. memory byte-addressable, word four bytes, memory consists 230words aligned word boundaries. analyze caches eight- word capacity ( C) sake simplicity. begin one-word block size ( b), generalize later larger blocks. Direct Mapped Cache direct mapped cache one block set, organized S/H11005Bsets. understand mapping memory addresses onto cache blocks, imagine main memory mapped b-word blocks, cache is. address block 0 main memory maps set 0 cache. address block 1 main memory maps set 1 cache, forth address block B/H110021 main memory maps block B/H110021 cache. blocks cache, mapping wraps around, block Bof main memory maps block 0 cache. mapping illustrated Figure 8.5 direct mapped cache capacity eight words block size one word. cache eight sets, contains one-word block. bottom two bits address always 00, word aligned. next log 28/H110053 bits indicate set onto memory address maps. Thus, data addresses 0x00000004, 0x00000024, . . . ,470 CHAPTER EIGHT Memory SystemsChapter 08.qxd 1/30/07 9:53 Page 4700xFFFFFFE4 map set 1, shown blue. Likewise, data addresses 0x00000010, . . . , 0xFFFFFFF0 map set 4, forth. main memory address maps exactly one set cache. Example 8.4 CACHE FIELDS cache set Figure 8.5 word address 0x00000014 map? Name another address maps set. Solution: two least significant bits address 00, address word aligned. next three bits 101, word maps set 5. Words addresses 0x34, 0x54, 0x74, . . . , 0xFFFFFFF4 map set. many addresses map single set, cache must also keep track address data actually contained set. least significant bits address specify set holds data. remaining significant bits called tagand indi- cate many possible addresses held set. previous example, two least significant bits 32-bit address called byte offset , indicate byte within word. next three bits called set bits , indicate set address maps. (In general, number set bits log2S.) remaining 27 tag bits indicate memory address data stored given cache set. Figure 8.6 shows cache fields address 0xFFFFFFE4. maps set 1 tag 1’s. 8.3 Caches 471 00...000 10000 230-Word Main Memorymem[0x00000000]mem[0x00000004]mem[0x00000008]mem[0x0000000C]mem[0x00000010]mem[0x00000014]mem[0x00000018]mem[0x0000001C]mem[0x00000020]mem[0x00000024]mem[0xFFFFFFE0]mem[0xFFFFFFE4]mem[0xFFFFFFE8]mem[0xFFFFFFEC]mem[0xFFFFFFF0]mem[0xFFFFFFF4]mem[0xFFFFFFF8]mem[0xFFFFFFFC] 23-Word CacheAddress 00...000 0000000...000 0010000...000 0100000...000 0110000...000 1010000...000 1100000...000 1110000...001 0000000...001 0010011...111 10000 11...111 0000011...111 0010011...111 0100011...111 0110011...111 1010011...111 1100011...111 11100 Set 7 ( 111) Set 6 ( 110) Set 5 ( 101) Set 4 ( 100) Set 3 ( 011) Set 2 ( 010) Set 1 ( 001) Set 0 ( 000)Data Figure 8.5 Mapping main memory direct mapped cacheChapter 08.qxd 1/30/07 9:53 Page 471Example 8.5 CACHE FIELDS Find number set tag bits direct mapped cache 1024 (210) sets one-word block size. address size 32 bits. Solution: cache 210sets requires log 2(210)/H1100510 set bits. two least sig- nificant bits address byte offset, remaining 32 /H1100210/H110022/H1100520 bits form tag. Sometimes, computer first starts up, cache sets contain data all. cache uses valid bit set indicate whether set holds meaningful data. valid bit 0, contents meaningless. Figure 8.7 shows hardware direct mapped cache Figure 8.5. cache constructed eight-entry SRAM. entry, set, contains one line consisting 32 bits data, 27 bits tag, 1 valid bit. cache accessed using 32-bit address. two least significant bits, byte offset bits, ignored word accesses. next three bits, set bits, specify entry set cache. load instruction reads specified entry cache checks tag valid bits. tag matches significant472 CHAPTER EIGHT Memory Systems 00Tag SetByte OffsetMemory Address001 111 ... 111 FFFFFF E 4Figure 8.6 Cache fields address 0xFFFFFFE4 mapping cache Figure 8.5 Data Tag00Tag SetByte OffsetMemory Address Data HitV =27 3 27 328-entry x (1+27+32)-bit SRAMSet 7 Set 6 Set 5 Set 4 Set 3 Set 2 Set 1 Set 0Figure 8.7 Direct mapped cache 8 setsChapter 08.qxd 1/30/07 9:53 Page 47227 bits address valid bit 1, cache hits data returned processor. Otherwise, cache misses memory system must fetch data main memory. Example 8.6 TEMPORAL LOCALITY DIRECT MAPPED CACHE Loops common source temporal spatial locality applications. Using eight-entry cache Figure 8.7, show contents cache executing following silly loop MIPS assembly code. Assume cache initially empty. miss rate? addi $t0, $0, 5 loop: beq $t0, $0, done lw $t1, 0x4($0) lw $t2, 0xC($0) lw $t3, 0x8($0) addi $t0, $t0, /H110021 j loop done: Solution: program contains loop repeats five iterations. iteration involves three memory accesses (loads), resulting 15 total memory accesses. first time loop executes, cache empty data must fetched main memory locations 0x4, 0xC, 0x8 cache sets 1, 3, 2, respectively. However, next four times loop executes, data found cache. Figure 8.8 shows contents cache last request memory address 0x4. tags 0 upper 27 bits addresses 0. miss rate 3/15 /H1100520%.8.3 Caches 473 Data TagV 00...001 mem[0x00...04]0 0 0 0000Tag SetByte OffsetMemory Address V3001 00...00 1 00...0000...00 1mem[0x00...0C] mem[0x00...08]Set 7 ( 111) Set 6 ( 110) Set 5 ( 101) Set 4 ( 100) Set 3 ( 011) Set 2 ( 010) Set 1 ( 001) Set 0 ( 000)Figure 8.8 Direct mapped cache contents two recently accessed addresses map cache block, conflict occurs, recently accessed address evicts previ- ous one block. Direct mapped caches one block set, two addresses map set always cause con- flict. example next page illustrates conflicts.Chapter 08.qxd 1/30/07 9:53 Page 473Example 8.7 CACHE BLOCK CONFLICT miss rate following loop executed eight-word direct mapped cache Figure 8.7? Assume cache initially empty. addi $t0, $0, 5 loop: beq $t0, $0, done lw $t1, 0x4($0) lw $t2, 0x24($0) addi $t0, $t0, /H110021 j loop done: Solution: Memory addresses 0x4 0x24 map set 1. initial execution loop, data address 0x4 loaded set 1 cache. data address 0x24 loaded set 1, evicting data address 0x4. Upon second execution loop, pattern repeats cache must refetch data address 0x4, evicting data address 0x24. two addresses conflict, miss rate 100%. Multi-way Set Associative Cache N-way set associative cache reduces conflicts providing Nblocks set data mapping set might found. mem- ory address still maps specific set, map one Nblocks set. Hence, direct mapped cache another name one-way set associative cache. Nis also called degree associativity cache. Figure 8.9 shows hardware C/H110058-word, N/H110052-way set associative cache. cache S/H110054 sets rather 8.474 CHAPTER EIGHT Memory Systems Data TagTag SetByte OffsetMemory Address Data 10 Hit1V =00 32 32 32Data TagV = Hit1 Hit0 Hit28 2 28 28Way 1 Way 0 Set 3 Set 2 Set 1 Set 0 Figure 8.9 Two-way set associative cacheChapter 08.qxd 1/30/07 9:53 Page 474Thus, log 24/H110052 set bits rather 3 used select set. tag increases 27 28 bits. set contains two ways degrees associativity. way consists data block valid tag bits. cache reads blocks ways selected set checks tags valid bits hit. hit occurs one ways, multiplexer selects data way. Set associative caches generally lower miss rates direct mapped caches capacity, fewer conflicts. However, set associative caches usually slower somewhat expensive build output multiplexer additional comparators. also raise question way replace ways full; addressed Section 8.3.3. commercial systems use set associative caches. Example 8.8 SET ASSOCIATIVE CACHE MISS RATE Repeat Example 8.7 using eight-word two-way set associative cache Figure 8.9. Solution: memory accesses, addresses 0x4 0x24, map set 1. However, cache two ways, accommodate data addresses. first loop iteration, empty cache misses addresses loads words data two ways set 1, shown Figure 8.10. next four iterations, cache hits. Hence, miss rate 2/10 /H1100520%. Recall direct mapped cache size Example 8.7 miss rate 100%.8.3 Caches 475 Data TagV Data TagV 00...001 mem[0x00...24] 00...101 mem[0x00...04]0 0 00 0 0Way 1 Way 0 Set 3 Set 2 Set 1 Set 0Figure 8.10 Two-way set associative cache contents Fully Associative Cache fully associative cache contains single set Bways, Bis number blocks. memory address map block ways. fully associative cache another name B-way set associative cache one set. Figure 8.11 shows SRAM array fully associative cache eight blocks. Upon data request, eight tag comparisons (not shown) must made, data could block. Similarly, 8:1 multi- plexer chooses proper data hit occurs. Fully associative caches tendChapter 08.qxd 1/30/07 9:53 Page 475to fewest conflict misses given cache capacity, require hardware additional tag comparisons. best suited relatively small caches large number comparators. Block Size previous examples able take advantage temporal locality, block size one word. exploit spatial locality, cache uses larger blocks hold several consecutive words. advantage block size greater one miss occurs word fetched cache, adjacent words block also fetched. Therefore, subsequent accesses likely hit spatial locality. However, large block size means fixed-size cache fewer blocks. may lead conflicts, increasing miss rate. Moreover, takes time fetch missing cache block miss, one data word fetched main memory. time required load missing block cache called miss penalty . adjacent words block accessed later, effort fetching wasted. Nevertheless, real programs benefit larger block sizes. Figure 8.12 shows hardware C/H110058-word direct mapped cache b/H110054-word block size. cache B/H11005C/b/H110052 blocks. direct mapped cache one block set, cache is476 CHAPTER EIGHT Memory Systems Data TagV Data TagV Data TagV Data TagV Data TagV Data TagV Data TagV Data TagVWay 0 Way 1 Way 2 Way 3 Way 4 Way 5 Way 6 Way 7 Data Tag00TagByte OffsetMemory Address DataVBlock Offset 32 32 32 32 32 Hit=Set 2727 2 Set 1 Set 0 00 01 10 11Figure 8.11 Eight-block fully associative cache Figure 8.12 Direct mapped cache two sets four-word block sizeChapter 08.qxd 1/30/07 9:53 Page 476organized two sets. Thus, log 22/H110051 bit used select set. multiplexer needed select word within block. multiplexer controlled log 24/H110052 block offset bits address. significant 27 address bits form tag. one tag needed entire block, words block consecutive addresses. Figure 8.13 shows cache fields address 0x8000009C maps direct mapped cache Figure 8.12. byte offset bits always 0 word accesses. next log 2b/H110052 block offset bits indicate word within block. next bit indicates set. remaining 27 bits tag. Therefore, word 0x8000009C maps set 1, word 3 cache. principle using larger block sizes exploit spatial locality also applies associative caches. Example 8.9 SPATIAL LOCALITY DIRECT MAPPED CACHE Repeat Example 8.6 eight-word direct mapped cache four-word block size. Solution: Figure 8.14 shows contents cache first memory access. first loop iteration, cache misses access memory address 0x4. access loads data addresses 0x0 0xC cache block. subsequent accesses (as shown address 0xC) hit cache. Hence, miss rate 1/15 /H110056.67%.8.3 Caches 477 00TagByte OffsetMemory Address11 100...100Block Offset 1 800000 9 CSetFigure 8.13 Cache fields address 0x8000009C mapping cache Figure 8.12 Set 1Data TagV Set 0 00...001 mem[0x00...0C]0 mem[0x00...08] mem[0x00...04] mem[0x00...00]00TagByte OffsetMemory Address VBlock OffsetSet 00...00 0 11 Figure 8.14 Cache contents block size ( b) four words Putting Together Caches organized two-dimensional arrays. rows called sets, columns called ways. entry array consists ofChapter 08.qxd 1/30/07 9:53 Page 477a data block associated valid tag bits. Caches characterized /L50776capacity C /L50776block size b(and number blocks, B/H11005C/b) /L50776number blocks set ( N) Table 8.2 summarizes various cache organizations. address memory maps one set stored ways. Cache capacity, associativity, set size, block size typically powers 2. makes cache fields (tag, set, block offset bits) subsets address bits. Increasing associativity, N, usually reduces miss rate caused conflicts. higher associativity requires tag comparators. Increasing block size, b, takes advantage spatial locality reduce miss rate. However, decreases number sets fixed sized cache therefore could lead conflicts. also increases miss penalty. 8.3.3 Data Replaced? direct mapped cache, address maps unique block set. set full new data must loaded, block set replaced new data. set associative fully associative caches, cache must choose block evict cache set full. principle temporal locality suggests best choice evict least recently used block, least likely used soon. Hence, associative caches least recently used (LRU ) replacement policy. two-way set associative cache, use bit, U , indicates way within set least recently used. time one ways used, U adjusted indicate way. set associative caches two ways, tracking least recently used way becomes com- plicated. simplify problem, ways often divided two groups Uindicates group ways least recently used.478 CHAPTER EIGHT Memory Systems Table 8.2 Cache organizations Number Ways Number Sets Organization ( N)( S) direct mapped 1 B set associative 1 /H11021N/H11021BB /N fully associative B 1Chapter 08.qxd 1/30/07 9:53 Page 478Upon replacement, new block replaces random block within least recently used group. policy called pseudo-LRU good enough practice. Example 8.10 LRU REPLACEMENT Show contents eight-word two-way set associative cache execut- ing following code. Assume LRU replacement, block size one word, initially empty cache. lw $t0, 0x04($0) lw $t1, 0x24($0) lw $t2, 0x54($0) Solution: first two instructions load data memory addresses 0x4 0x24 set 1 cache, shown Figure 8.15(a). U/H110050 indicates data way 0 least recently used. next memory access, address 0x54, also maps set 1 replaces least recently used data way 0, shown Figure 8.15(b), use bit, U, set 1 indicate data way 1 least recently used.8.3 Caches 479 Data Tag V 0Data TagV 0 0 00 0U mem[0x00...04] 1 mem[0x00...24] 100...000 00...0100 0 00 (a)Way 1 Way 0 Set 3 (11) Set 2 (10) Set 1 (01) Set 0 (00) Data Tag V 0Data TagV 0 0 00 0U mem[0x00...54] 1 00...101 mem[0x00...24] 1 00...0100 0 01 (b)Way 1 Way 0 Set 3 (11) Set 2 (10) Set 1 (01) Set 0 (00)Figure 8.15 Two-way associative cache LRU replacement 8.3.4 Advanced Cache Design* Modern systems use multiple levels caches decrease memory access time. section explores performance two-level caching sys- tem examines block size, associativity, cache capacity affect miss rate. section also describes caches handle stores, writes, using write-through write-back policy.Chapter 08.qxd 1/30/07 9:53 Page 479Multiple-Level Caches Large caches beneficial likely hold data interest therefore lower miss rates. However, large caches tend slower small ones. Modern systems often use two levels caches, shown Figure 8.16. first-level (L1) cache small enough provide one- two-cycle access time. second-level (L2) cache also built SRAM larger, therefore slower, L1 cache. processor first looks data L1 cache. L1 cache misses, processor looks L2 cache. L2 cache misses, processor fetches data main memory. modern systems add even levels cache memory hierarchy, accessing main memory slow. Example 8.11 SYSTEM L2 CACHE Use system Figure 8.16 access times 1, 10, 100 cycles L1 cache, L2 cache, main memory, respectively. Assume L1 L2 caches miss rates 5% 20%, respectively. Specifically, 5% accesses miss L1 cache, 20% also miss L2 cache. average memory access time ( AMAT )? Solution: memory access checks L1 cache. L1 cache misses (5% time), processor checks L2 cache. L2 cache misses (20% time), processor fetches data main memory. Using Equation 8.2, calculate average memory access time follows: 1 cycle /H110010.05[10 cycles /H110010.2(100 cycles)] /H110052.5 cycles L2 miss rate high receives “hard” memory accesses, miss L1 cache. accesses went directly L2 cache, L2 miss rate would 1%.480 CHAPTER EIGHT Memory Systems L1 Cache L2 Cache Main Memory CapacityVirtual MemorySpeedFigure 8.16 Memory hierarchy two levels cacheChapter 08.qxd 1/30/07 9:53 Page 480Reducing Miss Rate Cache misses reduced changing capacity, block size, and/or associativity. first step reducing miss rate understand causes misses. misses classified compulsory, capacity, conflict. first request cache block called compulsory miss , block must read memory regard- less cache design. Capacity misses occur cache small hold concurrently used data. Conflict misses caused several addresses map set evict blocks still needed. Changing cache parameters affect one type cache miss. example, increasing cache capacity reduce conflict capacity misses, affect compulsory misses. hand, increasing block size could reduce compulsory misses (due spa- tial locality) might actually increase conflict misses (because addresses would map set could conflict). Memory systems complicated enough best way eval- uate performance running benchmarks varying cache parameters. Figure 8.17 plots miss rate versus cache size degree associativity SPEC2000 benchmark. benchmark small number compulsory misses, shown dark region near x-axis. expected, cache size increases, capacity misses decrease. Increased associativity, especially small caches, decreases number conflict misses shown along top curve.8.3 Caches 481 0.10 1-way 2-way 4-way 8-way CapacityCompulsory Cache Size (KB)0.09 0.08 0.07 0.06 0.05Miss Rate per Type 0.04 0.03 0.02 0.01 0.00 32 16 8 4 64 128 512 256 1024Figure 8.17 Miss rate versus cache size associativity SPEC2000 benchmark Adapted permission Hennessy Patterson, Computer Architecture: Quantitative Approach , 3rd ed., Morgan Kaufmann, 2003.Chapter 08.qxd 1/30/07 9:53 Page 481Increasing associativity beyond four eight ways provides small decreases miss rate. mentioned, miss rate also decreased using larger block sizes take advantage spatial locality. block size increases, number sets fixed size cache decreases, increasing probability conflicts. Figure 8.18 plots miss rate versus block size (in number bytes) caches varying capacity. small caches, 4-KB cache, increasing block size beyond 64 bytes increases miss rate conflicts. larger caches, increasing block size change miss rate. However, large block sizes might still increase execution time larger miss penalty, time required fetch missing cache block main memory miss. Write Policy previous sections focused memory loads. Memory stores, writes, follow similar procedure loads. Upon memory store, processor checks cache. cache misses, cache block fetched main memory cache, appropriate word cache block written. cache hits, word simply written cache block. Caches classified either write-through write-back. write-through cache, data written cache block simultaneously written main memory. write-back cache, dirty bit (D) associ- ated cache block. Dis 1 cache block writ- ten 0 otherwise. Dirty cache blocks written back main memory evicted cache. write-through482 CHAPTER EIGHT Memory Systems 10% Miss Rate5% 0% 16 32 64 Block Size128 256256 K64 K16 K4 K Figure 8.18 Miss rate versus block size cache size SPEC92 benchmark Adapted permission Hennessy Patterson, Computer Architecture: Quantitative Approach , 3rd ed., Morgan Kaufmann, 2003.Chapter 08.qxd 1/30/07 9:53 Page 482cache requires dirty bit usually requires main memory writes write-back cache. Modern caches usually write-back, main memory access time large. Example 8.12 WRITE-THROUGH VERSUS WRITE-BACK Suppose cache block size four words. many main memory accesses required following code using write policy: write- write-back? sw $t0, 0x0($0) sw $t0, 0xC($0) sw $t0, 0x8($0) sw $t0, 0x4($0) Solution: four store instructions write cache block. write- cache, store instruction writes word main memory, requiring four main memory writes. write-back policy requires one main memory access, dirty cache block evicted. 8.3.5 Evolution MIPS Caches* Table 8.3 traces evolution cache organizations used MIPS processor 1985 2004. major trends introduction multiple levels cache, larger cache capacity, increased associativ- ity. trends driven growing disparity CPU frequency main memory speed decreasing cost transis- tors. growing difference CPU memory speeds necessi- tates lower miss rate avoid main memory bottleneck, decreasing cost transistors allows larger cache sizes.8.3 Caches 483 Table 8.3 MIPS cache evolution* Year CPU MHz L1 Cache L2 Cache 1985 R2000 16.7 none none 1990 R3000 33 32 KB direct mapped none 1991 R4000 100 8 KB direct mapped 1 MB direct mapped 1995 R10000 250 32 KB two-way 4 MB two-way 2001 R14000 600 32 KB two-way 16 MB two-way 2004 R16000A 800 64 KB two-way 16 MB two-way *Adapted D. Sweetman, See MIPS Run , Morgan Kaufmann, 1999.Chapter 08.qxd 1/30/07 9:53 Page 4838.4 VIRTUAL MEMORY modern computer systems use hard disk (also called hard drive ) lowest level memory hierarchy (see Figure 8.4). Compared ideal large, fast, cheap memory, hard disk large cheap terribly slow. disk provides much larger capacity possible cost-effective main memory (DRAM). However, significant fraction memory accesses involve disk, performance dismal. may encountered PC running many programs once. Figure 8.19 shows hard disk lid case removed. name implies, hard disk contains one rigid disks platters , read/write head end long triangular arm. head moves correct location disk reads writes data magnetically disk rotates beneath it. head takes several milliseconds seek correct location disk, fast human perspective millions times slower processor.484 CHAPTER EIGHT Memory Systems Figure 8.19 Hard diskChapter 08.qxd 1/30/07 9:53 Page 484The objective adding hard disk memory hierarchy inexpensively give illusion large memory still providing speed faster memory accesses. computer 128 MB DRAM, example, could effectively provide 2 GB memory using hard disk. larger 2-GB memory called virtual memory , smaller 128-MB main memory called physical memory . use term physical memory refer main memory throughout section. Programs access data anywhere virtual memory, must use virtual addresses specify location virtual memory. physical memory holds subset recently accessed virtual mem- ory. way, physical memory acts cache virtual memory. Thus, accesses hit physical memory speed DRAM, yet program enjoys capacity larger virtual memory. Virtual memory systems use different terminologies caching principles discussed Section 8.3. Table 8.4 summarizes analogous terms. Virtual memory divided virtual pages , typically 4 KB size. Physical memory likewise divided physical pages size. virtual page may located physical memory (DRAM) disk. example, Figure 8.20 shows virtual mem- ory larger physical memory. rectangles indicate pages. virtual pages present physical memory, located disk. process determining physical address virtual address called address translation . processor attempts access virtual address physical memory, page fault occurs, operating system loads page hard disk physical memory. avoid page faults caused conflicts, virtual page map physical page. words, physical memory behaves fully associative cache virtual memory. conventional fully associative cache, every cache block comparator checks signifi- cant address bits tag determine whether request hits in8.4 Virtual Memory 485 computer 32-bit addresses access maxi- mum 232bytes /H110054 GB memory. one motivations moving 64-bit computers, access far memory. Table 8.4 Analogous cache virtual memory terms Cache Virtual Memory Block Page Block size Page size Block offset Page offset Miss Page fault Tag Virtual page numberChapter 08.qxd 1/30/07 9:53 Page 485the block. analogous virtual memory system, physical page would need comparator check significant virtual address bits tag determine whether virtual page maps physical page. realistic virtual memory system many physical pages providing comparator page would excessively expensive. Instead, virtual memory system uses page table perform address translation. page table contains entry virtual page, indicat- ing location physical memory disk. load store instruction requires page table access followed physical memory access. page table access translates virtual address used program physical address. physical address used actually read write data. page table usually large located physical memory. Hence, load store involves two physical memory accesses: page table access, data access. speed address translation, translation lookaside buffer (TLB) caches com- monly used page table entries. remainder section elaborates address translation, page tables, TLBs. 8.4.1 Address Translation system virtual memory, programs use virtual addresses access large memory. computer must translate vir- tual addresses either find address physical memory take page fault fetch data hard disk. Recall virtual memory physical memory divided pages. significant bits virtual physical address specify virtual physical page number . least significant bits specify word within page called page offset .486 CHAPTER EIGHT Memory Systems Physical MemoryPhysical AddressesVirtual Addresses Hard DiskAddress Translation Figure 8.20 Virtual physical pagesChapter 08.qxd 1/30/07 9:53 Page 486Figure 8.21 illustrates page organization virtual memory system 2 GB virtual memory 128 MB physical memory divided 4-KB pages. MIPS accommodates 32-bit addresses. 2-GB /H11005231-byte virtual memory, least significant 31 virtual address bits used; 32nd bit always 0. Similarly, 128-MB /H11005227-byte physical memory, least significant 27 physical address bits used; upper 5 bits always 0. page size 4 KB /H11005212bytes, 231/212/H11005219 virtual pages 227/212/H11005215physical pages. Thus, virtual physical page numbers 19 15 bits, respectively. Physical memory hold 1/16th virtual pages given time. rest virtual pages kept disk. Figure 8.21 shows virtual page 5 mapping physical page 1, virtual page 0x7FFFC mapping physical page 0x7FFE, forth. example, virtual address 0x53F8 (an offset 0x3F8 within virtual page 5) maps physical address 0x13F8 (an offset 0x3F8 within physical page 1). least significant 12 bits virtual physical addresses (0x3F8) specify page offset within virtual physical pages. page number needs translated obtain physical address virtual address. Figure 8.22 illustrates translation virtual address physi- cal address. least significant 12 bits indicate page offset require translation. upper 19 bits virtual address specify virtual page number (VPN ) translated 15-bit physical page number (PPN). next two sections describe page tables TLBs used perform address translation.8.4 Virtual Memory 487 Physical MemoryPhysical Page Number Physical Addresses Virtual MemoryVirtual Page Number Virtual Addresses 7FFF 0x7FFF000 - 0x7FFFFFF 0x7FFE000 - 0x7FFEFFF 0x0000000 - 0x0000FFF0x0001000 - 0x0001FFF7FFE 0001 00007FFFA 7FFF9 00006 000057FFFC 7FFFB7FFFE 7FFFD7FFFF 00001 0000000003 00002000040x7FFFF000 - 0x7FFFFFFF 0x7FFFE000 - 0x7FFFEFFF 0x7FFFD000 - 0x7FFFDFFF 0x7FFFC000 - 0x7FFFCFFF 0x7FFFB000 - 0x7FFFBFFF 0x7FFFA000 - 0x7FFFAFFF 0x00005000 - 0x00005FFF 0x00003000 - 0x00003FFF 0x00001000 - 0x00001FFF0x7FFF9000 - 0x7FFF9FFF 0x00006000 - 0x00006FFF 0x00004000 - 0x00004FFF 0x00002000 - 0x00002FFF 0x00000000 - 0x00000FFFFigure 8.21 Physical virtual pagesChapter 08.qxd 1/30/07 9:53 Page 487Example 8.13 VIRTUAL ADDRESS PHYSICAL ADDRESS TRANSLATION Find physical address virtual address 0x247C using virtual memory system shown Figure 8.21. Solution: 12-bit page offset (0x47C) requires translation. remaining 19 bits virtual address give virtual page number, virtual address 0x247C found virtual page 0x2. Figure 8.21, virtual page 0x2 maps physical page 0x7FFF. Thus, virtual address 0x247C maps physical address 0x7FFF47C. 8.4.2 Page Table processor uses page table translate virtual addresses physical addresses. Recall page table contains entry virtual page. entry contains physical page number valid bit. valid bit 1, virtual page maps physical page specified entry. Otherwise, virtual page found disk. page table large, stored physical memory. Let us assume stored contiguous array, shown Figure 8.23. page table contains mapping memory system Figure 8.21. page table indexed virtual page number (VPN). example, entry 5 specifies virtual page 5 maps physical page 1. Entry 6 invalid ( V/H110050), virtual page 6 located disk. Example 8.14 USING PAGE TABLE PERFORM ADDRESS TRANSLATION Find physical address virtual address 0x247C using page table shown Figure 8.23. Solution: Figure 8.24 shows virtual address physical address translation virtual address 0x247C. 12-bit page offset requires translation. remaining 19 bits virtual address virtual page number, 0x2, and488 CHAPTER EIGHT Memory Systems Page Offset PPN11 10 9 ... 2 1 0 Page Offset VPNVirtual Address Physical Address30 29 28 ... 14 13 12 11 10 9 ... 2 1 0 26 25 24 ... 13 1219 1512TranslationFigure 8.22 Translation virtual address physical address Page TableVirtual Page Number 7FFFA 00006 000057FFFC 7FFFB7FFFE 7FFFD7FFFF 00001 0000000003 0000200004V 00007Physical Page Number 0 0 1 0x0000 1 0x7FFE 0 0 0 0 1 0x0001 0 0 1 0x7FFF 0 0 Figure 8.23 page table Figure 8.21Chapter 08.qxd 1/30/07 9:53 Page 488The page table stored anywhere physical memory, discretion OS. processor typically uses dedicated register, called page table register , store base address page table physical memory. perform load store, processor must first translate virtual address physical address access data physical address. processor extracts virtual page number virtual address adds page table register find physical address page table entry. processor reads page table entry physical memory obtain physical page number. entry valid, merges physical page number page offset create physical address. Finally, reads writes data physical address. page table stored physical memory, load store involves two physical memory accesses.8.4 Virtual Memory 489 0 0 1 0x0000 1 0x7FFE 0 0 0 0 1 0x0001 Page Table 0 0 1 0x7FFF 0 0VVirtual Address0x00002 47C HitPhysical Page Number12 19 15 12Virtual Page NumberPage Offset Physical Address0x7FFF 47CFigure 8.24 Address translation using page tablegive index page table. page table maps virtual page 0x2 physical page 0x7FFF. So, virtual address 0x247C maps physical address 0x7FFF47C. least significant 12 bits physical virtual address.Chapter 08.qxd 1/30/07 9:53 Page 4898.4.3 Translation Lookaside Buffer Virtual memory would severe performance impact required page table read every load store, doubling delay loads stores. Fortunately, page table accesses great temporal local- ity. temporal spatial locality data accesses large page size mean many consecutive loads stores likely ref- erence page. Therefore, processor remembers last page table entry read, probably reuse translation without rereading page table. general, processor keep last several page table entries small cache called translation lookaside buffer (TLB). processor “looks aside” find trans- lation TLB access page table physical memory. real programs, vast majority accesses hit TLB, avoiding time-consuming page table reads physical memory. TLB organized fully associative cache typically holds 16 512 entries. TLB entry holds virtual page number corresponding physical page number. TLB accessed using virtual page number. TLB hits, returns corresponding physical page number. Otherwise, processor must read page table physical memory. TLB designed small enough accessed less one cycle. Even so, TLBs typically hit rate greater 99%. TLB decreases number memory accesses required load store instructions two one. Example 8.15 USING TLB PERFORM ADDRESS TRANSLATION Consider virtual memory system Figure 8.21. Use two-entry TLB explain page table access necessary translate virtual addresses 0x247C 0x5FB0 physical addresses. Suppose TLB currently holds valid translations virtual pages 0x2 0x7FFFD. Solution: Figure 8.25 shows two-entry TLB request virtual address 0x247C. TLB receives virtual page number incoming address, 0x2, compares virtual page number entry. Entry 0 matches valid, request hits. translated physical address physical page number matching entry, 0x7FFF, concatenated page offset virtual address. always, page offset requires translation. request virtual address 0x5FB0 misses TLB. So, request for- warded page table translation.490 CHAPTER EIGHT Memory SystemsChapter 08.qxd 1/30/07 9:53 Page 4908.4.4 Memory Protection far section focused using virtual memory provide fast, inexpensive, large memory. equally important reason use vir- tual memory provide protection concurrently running programs. probably know, modern computers typically run several pro- grams processes time. programs simultane- ously present physical memory. well-designed computer system, programs protected program crash hijack another program. Specifically, program able access another program’s memory without permission. called memory protection . Virtual memory systems provide memory protection giving program virtual address space . program use much memory wants virtual address space, portion virtual address space physical memory given time. pro- gram use entire virtual address space without worry programs physically located. However, program access physical pages mapped page table. way, program cannot accidentally maliciously access another pro- gram’s physical pages, mapped page table. cases, multiple programs access common instructions data. operating system adds control bits page table entry determine programs, any, write shared physical pages.8.4 Virtual Memory 491 Hit1V =15 15 15= Hit 10 1 Hit0 Hit19 1919 Virtual Page NumberPhysical Page NumberEntry 1 1 0x7FFFD 0x0000 1 0x00002 0x7FFFVirtual Address0x00002 47C 12 19Virtual Page NumberPage Offset VVirtual Page NumberPhysical Page NumberEntry 0 12Physical Address0x7FFF 47CTLB Figure 8.25 Address translation using two-entry TLBChapter 08.qxd 1/30/07 9:53 Page 4918.4.5 Replacement Policies* Virtual memory systems use write-back approximate least recently used (LRU) replacement policy. write-through policy, write physical memory initiates write disk, would impractical. Store instructions would operate speed disk instead speed processor (milliseconds instead nanoseconds). write- back policy, physical page written back disk evicted physical memory. Writing physical page back disk reloading different virtual page called swapping , disk virtual memory system sometimes called swap space . processor swaps one least recently used physical pages page fault occurs, replaces page missing virtual page. support replacement policies, page table entry contains two additional status bits: dirty bit, D, use bit, U. dirty bit 1 store instructions changed physical page since read disk. physical page swapped out, needs written back disk dirty bit 1; otherwise, disk already holds exact copy page. use bit 1 physical page accessed recently. cache system, exact LRU replacement would impractically compli- cated. Instead, OS approximates LRU replacement periodically resetting use bits page table. page accessed, use bit set 1. Upon page fault, OS finds page U/H110050 swap physical memory. Thus, necessarily replace least recently used page, one least recently used pages. 8.4.6 Multilevel Page Tables* Page tables occupy large amount physical memory. exam- ple, page table previous sections 2 GB virtual memory 4 KB pages would need 219entries. entry 4 bytes, page table 219/H1100322bytes /H11005221bytes /H110052 MB. conserve physical memory, page tables broken mul- tiple (usually two) levels. first-level page table always kept phys- ical memory. indicates small second-level page tables stored virtual memory. second-level page tables contain actual translations range virtual pages. particular range transla- tions actively used, corresponding second-level page table swapped hard disk waste physical memory. two-level page table, virtual page number split two parts: page table number page table offset , shown Figure 8.26. page table number indexes first-level page table, must reside physical memory. first-level page table entry gives base address second-level page table indicates that492 CHAPTER EIGHT Memory SystemsChapter 08.qxd 1/30/07 9:53 Page 492it must fetched disk Vis 0. page table offset indexes second-level page table. remaining 12 bits virtual address page offset, before, page size 212/H110054 KB. Figure 8.26 19-bit virtual page number broken 9 10 bits, indicate page table number page table offset, respec- tively. Thus, first-level page table 29/H11005512 entries. 512 second-level page tables 210/H110051 K entries. first- second-level page table entries 32 bits (4 bytes) two second- level page tables present physical memory once, hierarchical page table uses (512 /H110034 bytes) /H110012/H11003(1 K /H110034 bytes) /H1100510 KB physical memory. two-level page table requires fraction physi- cal memory needed store entire page table (2 MB). drawback two-level page table adds yet another memory access translation TLB misses. Example 8.16 USING MULTILEVEL PAGE TABLE ADDRESS TRANSLATION Figure 8.27 shows possible contents two-level page table Figure 8.26. contents one second-level page table shown. Using two-level page table, describe happens access virtual address 0x003FEFB0.8.4 Virtual Memory 493 First-Level Page TablePage Table Address 210 = 1K entries29 = 512 entriesPage Table NumberPage Table OffsetVirtual Address V9 Physical Page Number V10 Second-Level Page TablesPage Offset Figure 8.26 Hierarchical page tablesChapter 08.qxd 1/30/07 9:53 Page 4938.5 MEMORY-MAPPED I/O* Processors also use memory interface communicate input/output (I/O) devices keyboards, monitors, printers. processor accesses I/O device using address data busses way accesses memory. portion address space dedicated I/O devices rather memory. example, suppose addresses range494 CHAPTER EIGHT Memory Systems Page Table AddressPage Table NumberPage Table OffsetVirtual Address V9 Physical Page Number V10Page Offset 0 0 01 0x40000 Valid11 0x2375000 First-Level Page Table Second-Level Page Tables0x0 3FE FB0 Valid215 12 Physical Address0x23F1 FB012 0 1 0x7FFE 0 0 0 0 1 0x0073 0 0 1 0x72FC 0 0 0 1 0x00C11 0x1003 1 0x23F1 Figure 8.27 Address translation using two-level page tableSolution: always, virtual page number requires translation. significant nine bits virtual address, 0x0, give page table number, index first-level page table. first-level page table entry 0x0 indi- cates second-level page table resident memory ( V/H110051) phys- ical address 0x2375000. next ten bits virtual address, 0x3FE, page table offset, gives index second-level page table. Entry 0 bottom second-level page table, entry 0x3FF top. Entry 0x3FE second- level page table indicates virtual page resident physical memory (V/H110051) physical page number 0x23F1. physical page number concatenated page offset form physical address, 0x23F1FB0.Chapter 08.qxd 1/30/07 9:53 Page 4940xFFFF0000 0xFFFFFFFF used I/O. Recall Section 6.6.1 addresses reserved portion memory map. I/O device assigned one memory addresses range. store specified address sends data device. load receives data device. method communicating I/O devices called memory-mapped I/O . system memory-mapped I/O, load store may access either memory I/O device. Figure 8.28 shows hardware needed support two memory-mapped I/O devices. address decoder determines device communicates processor. uses Address Mem Write signals generate control signals rest hardware. ReadData multiplexer selects memory various I/O devices. Write-enabled registers hold values written I/O devices. Example 8.17 COMMUNICATING I/O DEVICES Suppose I/O Device 1 Figure 8.28 assigned memory address 0xFFFFFFF4. Show MIPS assembly code writing value 7 I/O Device 1 reading output value I/O Device 1. Solution: following MIPS assembly code writes value 7 I/O Device 1.2 addi $t0, $0, 7 sw $t0, 0xFFF4($0) address decoder asserts WE1 address 0xFFFFFFF4 MemWrite TRUE. value WriteData bus, 7, written regis- ter connected input pins I/O Device 1.8.5 Memory-Mapped I/O 495 Processor MemoryAddressMemWrite WriteData ReadData I/O Device 1 I/O Device 2CLK EN ENAddress Decoder WE1WEMRDsel1:0 WE2 WECLK 00 01 10CLK Figure 8.28 Support hardware memory-mapped I/O architectures, notably IA-32, use specialized instruc- tions instead memory- mapped I/O communicate I/O devices. instructions follow- ing form, devicel device2 unique ID peripheral device: lwio $t0, device1 swio $t0, device2 type communication I/O devices called pro- grammed I/O . 2Recall 16-bit immediate 0xFFF4 sign-extended 32-bit value 0xFFFFFFF4.Chapter 08.qxd 1/30/07 9:53 Page 495To read I/O Device 1, processor performs following MIPS assembly code. lw $t1, 0xFFF4($0) address decoder sets RDsel 1:0to 01, detects address 0xFFFFFFF4 MemWrite FALSE. output I/O Device 1 passes multiplexer onto ReadData bus loaded $t1in processor. Software communicates I/O device called device driver . probably downloaded installed device drivers printer I/O device. Writing device driver requires detailed knowledge I/O device hardware. programs call func- tions device driver access device without under- stand low-level device hardware. illustrate memory-mapped I/O hardware software, rest section describes interfacing commercial speech synthesizer chip MIPS processor. Speech Synthesizer Hardware Radio Shack SP0256 speech synthesizer chip generates robot-like speech. Words composed one allophones , fundamental units sound. example, word “hello” uses five allophones repre- sented following symbols SP0256 speech chip: HH1 EH AX OW. speech synthesizer uses 6-bit codes represent 64 different allophones appear English language. example, five allophones word “hello” correspond hexadecimal values 0x1B, 0x07, 0x2D, 0x0F, 0x20, respectively. processor sends series allophones speech synthesizer, drives speaker blabber sounds. Figure 8.29 shows pinout SP0256 speech chip. I/O pins highlighted blue used interface MIPS processor produce speech. Pins A6:1receive 6-bit allophone encoding processor. allophone sound produced Digital pin. Digital signal first amplified sent speaker. two highlighted pins, SBY _____ ALD , status control pins. SBY output 1, speech chip standing ready receive new allophone. falling edge address load input_____ ALD , speech chip reads allophone specified A6:1. pins, power ground ( VDDand VSS) clock ( OSC1 ), must connected shown driven processor. Figure 8.30 shows speech synthesizer interfaced MIPS processor. processor uses three memory-mapped I/O addresses communicate speech synthesizer. arbitrarily chosen496 CHAPTER EIGHT Memory Systems Seewww.speechchips.com information SP0256 allophone encodings.Chapter 08.qxd 1/30/07 9:53 Page 496that A6:1port mapped address 0xFFFFFF00, _____ ALD 0xFFFFFF04, SBY 0xFFFFFF08. Although WriteData bus 32 bits, least significant 6 bits used A6:1, least significant bit used for_____ ALD ; bits ignored. Similarly, SBY read least significant bit ReadData bus; bits 0.8.5 Memory-Mapped I/O 497 1 2 3 4 5 6 7 8 9 10 11 12 13 1428 27 26 25 24 23 22 21 20 19 18 17 16 15OSC 2 OSC 1 ROM Clock SBY Reset Digital VD1 Test Ser ALD SE A1 A2 A3 A4VSS Reset ROM Disable C1 C2 C3 VDD SBYTo ProcessorFrom Processor ProcessorFrom ProcessorLRQ A8 A7 Ser A6 A5SPO2563.12 MHz AAmplifier Speaker Processor MemoryAddressMemWrite WriteData ReadData SP0256CLK EN ENAddress Decoder WECLK CLK 5:0 0A6:1 ALDSBY0 1 31:1 WE1WEMRDsel WE2Figure 8.29 SPO256 speech synthesizer chip pinout Figure 8.30 Hardware driving SPO256 speech synthesizerChapter 08.qxd 1/30/07 9:53 Page 497Speech Synthesizer Device Driver device driver controls speech synthesizer sending appropri- ate series allophones memory-mapped I/O interface. follows protocol expected SPO256 chip, given below: /L50776Set _____ ALD 1 /L50776Wait chip asserts SBY indicate finished speaking previous allophone ready next /L50776Write 6-bit allophone A6:1 /L50776Reset _____ ALD 0 initiate speech sequence repeated number allophones. MIPS assembly Code Example 8.1 writes five allophones speech chip. allophone encodings stored 32-bit values five-entry array starting memory address 0x10000000. assembly code Code Example 8.1 polls, repeatedly checks, SBY signal determine speech chip ready receive new allophone. code functions correctly wastes valuable proces- sor cycles could used perform useful work. Instead polling, processor could use interrupt connected SBY. SBY rises, processor stops jumps code handles interrupt. case speech synthesizer, interrupt handler498 CHAPTER EIGHT Memory Systems init: addi $t1, $0, 1 # $t1 /H110051(valuetowritetoALD___ ) addi $t2, $0, 20 # $t2 /H11005array size * 4 lui $t3, 0x1000 # $t3 /H11005array base address addi $t4, $0, 0 # $t4 /H110050 (array index) start: sw $t1, 0xFF04($0) # ALD___ =1 loop: lw $t5, 0xFF08($0) # $t5 /H11005SBY beq $0, $t5, loop # loop SBY /H11005/H110051 add $t5, $t3, $t4 # $t5 /H11005address allophone lw $t5, 0($t5) # $t5 /H11005allophone sw $t5, 0xFF00($0) # A6:1 /H11005allophone sw $0, 0xFF04($0) # ALD___ = 0 initiate speech addi $t4, $t4, 4 # increment array index beq $t4, $t2, done # last allophone array? j start # repeat done:Code Example 8.1 SPEECH CHIP DEVICE DRIVERChapter 08.qxd 1/30/07 9:53 Page 498would send next allophone, let processor resume interrupt. described Section 6.7.2, processor handles interrupts like exception. 8.6 REAL-WORLD PERSPECTIVE: IA-32 MEMORY I/O SYSTEMS* processors get faster, need ever elaborate memory hierarchies keep steady supply data instructions flowing. section describes memory systems IA-32 processors illustrate progres- sion. Section 7.9 contained photographs processors, highlighting on-chip caches. IA-32 also unusual programmed I/O system differs common memory-mapped I/O. 8.6.1 IA-32 Cache Systems 80386, initially produced 1985, operated 16 MHz. lacked cache, directly accessed main memory instructions data. Depending speed memory, processor might get immediate response, might pause one cycles memory react. cycles called wait states , increase CPI processor. Microprocessor clock frequencies increased least 25% per year since then, whereas memory latency scarcely diminished. delay processor sends address main memory memory returns data exceed 100 processor clock cycles. Therefore, caches low miss rate essential good performance. Table 8.5 summarizes evolu- tion cache systems Intel IA-32 processors. 80486 introduced unified write-through cache hold instructions data. high-performance computer systems also pro- vided larger second-level cache motherboard using commercially available SRAM chips substantially faster main memory. Pentium processor introduced separate instruction data caches avoid contention simultaneous requests data instructions. caches used write-back policy, reducing commu- nication main memory. Again, larger second-level cache (typically 256–512 KB) usually offered motherboard. P6 series processors (Pentium Pro, Pentium II, Pentium III) designed much higher clock frequencies. second-level cache motherboard could keep up, moved closer processor improve latency throughput. Pentium Pro packaged multichip module (MCM ) containing proces- sor chip second-level cache chip, shown Figure 8.31. Like Pentium, processor separate 8-KB level 1 instruction data8.6 Real-World Perspective: IA-32 Memory I/O Systems 499Chapter 08.qxd 1/30/07 9:53 Page 499caches. However, caches nonblocking , out-of- order processor could continue executing subsequent cache accesses even cache missed particular access fetch data main memory. second-level cache 256 KB, 512 KB, 1 MB size could operate speed processor. Unfortunately, MCM packaging proved expensive high-volume manufacturing. Therefore, Pentium II sold lower-cost cartridge containing processor second-level cache. level 1 caches dou- bled size compensate fact second-level cache oper- ated half processor’s speed. Pentium III integrated full-speed second-level cache directly onto chip processor. cache chip operate better latency throughput, substantially effective off-chip cache size. Pentium 4 offered nonblocking level 1 data cache. switched trace cache store instructions decoded micro-ops, avoiding delay redecoding time instructions fetched cache. Pentium design adapted Pentium III. increased level 1 caches 32 KB featured 1- 2-MB level 2 cache. Core Duo contains two modified Pentium processors and500 CHAPTER EIGHT Memory Systems Table 8.5 Evolution Intel IA-32 microprocessor memory systems Frequency Level 1 Level 1 Processor Year (MHz) Data Cache Instruction Cache Level 2 Cache 80386 1985 16–25 none none none 80486 1989 25–100 8 KB unified none chip Pentium 1993 60–300 8 KB 8 KB none chip Pentium Pro 1995 150–200 8 KB 8 KB 256 KB–1 MB MCM Pentium II 1997 233–450 16 KB 16 KB 256–512 KB cartridge Pentium III 1999 450–1400 16 KB 16 KB 256–512 KB chip Pentium 4 2001 1400–3730 8–16 KB 12 K op 256 KB–2 MB trace cache chip Pentium 2003 900–2130 32 KB 32 KB 1–2 MB chip Core Duo 2005 1500–2160 32 KB/core 32 KB/core 2 MB shared chipChapter 08.qxd 1/30/07 9:53 Page 500a shared 2-MB cache one chip. shared cache used communi- cation processors: one write data cache, read it. 8.6.2 IA-32 Virtual Memory IA-32 processors operate either real mode protected mode. Real mode backward compatible original 8086. uses 20 bits addresses, limiting memory 1 MB, allow virtual memory. Protected mode introduced 80286 extended 32-bit addresses 80386. supports virtual memory 4-KB pages. also provides memory protection one program cannot access pages belonging programs. Hence, buggy mali- cious program cannot crash corrupt programs. modern operating systems use protected mode. 32-bit address permits 4 GB memory. Processors since Pentium Pro bumped memory capacity 64 GB using a8.6 Real-World Perspective: IA-32 Memory I/O Systems 501 Figure 8.31 Pentium Pro multichip module processor (left) 256-KB cache (right) pin grid array (PGA) package (Courtesy Intel.) Although memory protection became available hard- ware early 1980s, Microsoft Windows took almost 15 years take advantage feature prevent bad programs crashing entire computer. release Windows 2000, consumer versions Windows notoriously unstable. lag hardware features soft- ware support extremely long.Chapter 08.qxd 1/30/07 9:53 Page 501technique called physical address extension . process uses 32-bit addresses. virtual memory system maps addresses onto larger 36-bit virtual memory space. uses different page tables process, process address space 4 GB. 8.6.3 IA-32 Programmed I/O architectures use memory-mapped I/O, described Section 8.5, programs access I/O devices reading writing memory locations. IA-32 uses programmed I/O , special instructions used read write I/O devices. IA-32 defines 216 I/O ports. instruction reads one, two, four bytes port specified DX AL, AX, EAX. similar, writes port. Connecting peripheral device programmed I/O system simi- lar connecting memory-mapped system. accessing I/O port, processor sends port number rather memory address 16 least significant bits address bus. device reads writes data data bus. major difference processor also produces M/IO___ signal. M/IO___ /H110051, processor accessing memory. 0, process accessing one I/O devices. address decoder must also look M/IO___ generate appropriate enables main memory I/O devices. I/O devices also send interrupts processor indicate ready communicate. 8.7 SUMMARY Memory system organization major factor determining computer performance. Different memory technologies, DRAM, SRAM, hard disks, offer trade-offs capacity, speed, cost. chapter introduced cache virtual memory organizations use hierarchy memories approximate ideal large, fast, inexpensive memory. Main memory typically built DRAM, significantly slower processor. cache reduces access time keeping com- monly used data fast SRAM. Virtual memory increases memory capacity using hard disk store data fit main memory. Caches virtual memory add complexity hardware computer system, benefits usually outweigh costs. mod- ern personal computers use caches virtual memory. processors also use memory interface communicate I/O devices. called memory-mapped I/O. Programs use load store operations access I/O devices.502 CHAPTER EIGHT Memory SystemsChapter 08.qxd 1/30/07 9:53 Page 502EPILOGUE chapter brings us end journey together realm digital systems. hope book conveyed beauty thrill art well engineering knowledge. learned design combinational sequential logic using schematics hard- ware description languages. familiar larger building blocks multiplexers, ALUs, memories. Computers one fascinating applications digital systems. learned program MIPS processor native assembly language build processor memory system using digital building blocks. Throughout, seen application abstraction, discipline, hierarchy, modularity, regularity. techniques, pieced together puzzle microprocessor’s inner workings. cell phones digital television Mars rovers medical imaging sys- tems, world increasingly digital place. Imagine Faustian bargain Charles Babbage would made take similar journey century half ago. merely aspired calculate mathematical tables mechanical precision. Today’s digital systems yesterday’s science fiction. Might Dick Tracy listened iTunes cell phone? Would Jules Verne launched constellation global positioning satellites space? Could Hippocrates cured illness using high-resolution digital images brain? time, George Orwell’s nightmare ubiqui- tous government surveillance becomes closer reality day. rogue states develop nuclear weapons using laptop computers powerful room-sized supercomputers simulated Cold War bombs. microprocessor revolution continues accelerate. changes coming decades surpass past. tools design build new systems shape future. newfound power comes profound responsibility. hope use it, fun riches, also benefit humanity.Epilogue 503Chapter 08.qxd 1/30/07 9:53 Page 503Exercises Exercise 8.1 less one page, describe four everyday activities exhibit temporal spatial locality. List two activities type locality, specific. Exercise 8.2 one paragraph, describe two short computer applications exhibit temporal and/or spatial locality. Describe how. specific. Exercise 8.3 Come sequence addresses direct mapped cache size (capacity) 16 words block size 4 words outperforms fully associative cache least recently used (LRU) replacement capacity block size. Exercise 8.4 Repeat Exercise 8.3 case fully associative cache outperforms direct mapped cache. Exercise 8.5 Describe trade-offs increasing following cache parameters keeping others same: (a) block size (b) associativity (c) cache size Exercise 8.6 miss rate two-way set associative cache always, usually, occasionally, never better direct mapped cache capacity block size? Explain. Exercise 8.7 following statements pertains miss rate caches. Mark statement true false. Briefly explain reasoning; present counterexample statement false. (a) two-way set associative cache always lower miss rate direct mapped cache block size total capacity. (b) 16-KB direct mapped cache always lower miss rate 8-KB direct mapped cache block size. (c) instruction cache 32-byte block size usually lower miss rate instruction cache 8-byte block size, given degree associativity total capacity.504 CHAPTER EIGHT Memory SystemsChapter 08.qxd 1/30/07 9:53 Page 504Exercise 8.8 cache following parameters: b, block size given numbers words; S, number sets; N, number ways; A, number address bits. (a) terms parameters described, cache capacity, C? (b) terms parameters described, total number bits required store tags? (c) Sand Nfor fully associative cache capacity Cwords block size b? (d) Sfor direct mapped cache size Cwords block size b? Exercise 8.9 16-word cache parameters given Exercise 8.8. Consider following repeating sequence lwaddresses (given hexadecimal): 40 44 48 4C 70 74 78 7C 80 84 88 8C 90 94 98 9C 0 4 8 C 10 14 18 1C 20 Assuming least recently used (LRU) replacement associative caches, determine effective miss rate sequence input following caches, ignoring startup effects (i.e., compulsory misses). (a) direct mapped cache, S/H1100516, b/H110051 word (b) fully associative cache, N/H1100516, b/H110051 word (c) two-way set associative cache, S/H110058, b/H110051 word (d) direct mapped cache, S/H110058, b/H110052 words Exercise 8.10 Suppose running program following data access pattern. pattern executed once. 0x0, 0x8, 0x10, 0x18, 0x20, 0x28 (a) use direct mapped cache cache size 1 KB block size 8 bytes (2 words), many sets cache? (b) cache block size part (a), miss rate direct mapped cache given memory access pattern? (c) given memory access pattern, following would decrease miss rate most? (Cache capacity kept constant.) Circle one. (i) Increasing degree associativity 2. (ii) Increasing block size 16 bytes.Exercises 505Chapter 08.qxd 1/30/07 9:53 Page 505(iii) Either (i) (ii). (iv) Neither (i) (ii). Exercise 8.11 building instruction cache MIPS processor. total capacity 4 C/H110052c/H110012bytes. N/H110052n-way set associative ( N≥8), block size b/H110052b/H11032bytes ( b≥8). Give answers following questions terms parameters. (a) bits address used select word within block? (b) bits address used select set within cache? (c) many bits tag? (d) many tag bits entire cache? Exercise 8.12 Consider cache following parameters: N(associativity) /H110052, b(block size) /H110052 words, W(word size) /H1100532 bits, C(cache size) /H1100532 K words, A(address size) /H1100532 bits. need consider word addresses. (a) Show tag, set, block offset, byte offset bits address. State many bits needed field. (b) size allthe cache tags bits? (c) Suppose cache block also valid bit ( V) dirty bit ( D). size cache set, including data, tag, status bits? (d) Design cache using building blocks Figure 8.32 small number two-input logic gates. cache design must include tag storage, data storage, address comparison, data output selection, parts feel relevant. Note multiplexer comparator blocks may size ( pbits wide, respectively), SRAM blocks must 16 K /H110034 bits. sure include neatly labeled block diagram.506 CHAPTER EIGHT Memory Systems 16K × 4 SRAM14 4=p p 0 1n nn Figure 8.32 Building blocksChapter 08.qxd 1/30/07 9:53 Page 506Exercise 8.13 You’ve joined hot new Internet startup build wrist watches built-in pager Web browser. uses embedded processor multilevel cache scheme depicted Figure 8.33. processor includes small on-chip cache addition large off-chip second-level cache. (Yes, watch weighs 3 pounds, see surf!) Assume processor uses 32-bit physical addresses accesses data word boundaries. caches characteristics given Table 8.6. DRAM access time tmand size 512 MB. (a) given word memory, total number locations might found on-chip cache second-level cache? (b) size, bits, tag on-chip cache second- level cache? (c) Give expression average memory read access time. caches accessed sequence. (d) Measurements show that, particular problem interest, on-chip cache hit rate 85% second-level cache hit rate 90%. However, on-chip cache disabled, second-level cache hit rate shoots 98.5%. Give brief explanation behavior.Exercises 507 Figure 8.33 Computer systemCPULevel 1 CacheLevel 2 CacheMain MemoryProcessor Chip Table 8.6 Memory characteristics Characteristic On-chip Cache Off-chip Cache organization four-way set associative direct mapped hit rate AB access time ta tb block size 16 bytes 16 bytes number blocks 512 256KChapter 08.qxd 1/30/07 9:53 Page 507Exercise 8.14 chapter described least recently used (LRU) replacement policy multiway associative caches. Other, less common, replacement policies include first-in-first-out (FIFO) random policies. FIFO replacement evicts block longest, regardless recently accessed. Random replacement randomly picks block evict. (a) Discuss advantages disadvantages replacement policies. (b) Describe data access pattern FIFO would perform better LRU. Exercise 8.15 building computer hierarchical memory system consists separate instruction data caches followed main memory. using MIPS multicycle processor Figure 7.41 running 1 GHz. (a) Suppose instruction cache perfect (i.e., always hits) data cache 5% miss rate. cache miss, processor stalls 60 ns access main memory, resumes normal operation. Taking cache misses account, average memory access time? (b) many clock cycles per instruction (CPI) average required load store word instructions considering non-ideal memory system? (c) Consider benchmark application Example 7.7 25% loads, 10% stores, 11% branches, 2% jumps, 52% R-type instructions.3 Taking non-ideal memory system account, average CPI benchmark? (d) suppose instruction cache also non-ideal 7% miss rate. average CPI benchmark part (c)? Take account instruction data cache misses. Exercise 8.16 computer uses 64-bit virtual addresses, much virtual memory access? Note 240bytes /H110051 terabyte , 250bytes /H110051 petabyte , 260bytes /H110051 exabyte . Exercise 8.17 supercomputer designer chooses spend $1 million DRAM amount hard disks virtual memory. Using prices Figure 8.4, much physical virtual memory computer have? many bits physical virtual addresses necessary access memory?508 CHAPTER EIGHT Memory Systems 3Data Patterson Hennessy, Computer Organization Design , 3rd Edition, Morgan Kaufmann, 2005. Used permission.Chapter 08.qxd 1/30/07 9:53 Page 508Exercise 8.18 Consider virtual memory system address total 232 bytes. unlimited hard disk space, limited 8 MB semiconductor (physical) memory. Assume virtual physical pages 4 KB size. (a) many bits physical address? (b) maximum number virtual pages system? (c) many physical pages system? (d) many bits virtual physical page numbers? (e) Suppose come direct mapped scheme maps virtual pages physical pages. mapping uses least significant bits virtual page number determine physical page number. many virtual pages mapped physical page? “direct mapping” bad plan? (f) Clearly, flexible dynamic scheme translating virtual addresses physical addresses required one described part (d). Suppose use page table store mappings (translations virtual page number physical page number). many page table entries page table contain? (g) Assume that, addition physical page number, page table entry also contains status information form valid bit ( V) dirty bit ( D). many bytes long page table entry? (Round integer number bytes.) (h) Sketch layout page table. total size page table bytes? Exercise 8.19 decide speed virtual memory system Exercise 8.18 using translation lookaside buffer (TLB). Suppose memory system characteristics shown Table 8.7. TLB cache miss rates indicate often requested entry found. main memory miss rate indicates often page faults occur.Exercises 509 Table 8.7 Memory characteristics Memory Unit Access Time (Cycles) Miss Rate TLB 1 0.05% cache 1 2% main memory 100 0.0003% disk 1,000,000 0%Chapter 08.qxd 1/30/07 9:53 Page 509(a) average memory access time virtual memory system adding TLB? Assume page table always resident physical memory never held data cache. (b) TLB 64 entries, big (in bits) TLB? Give numbers data (physical page number), tag (virtual page number), valid bits entry. Show work clearly. (c) Sketch TLB. Clearly label fields dimensions. (d) size SRAM would need build TLB described part (c)? Give answer terms depth /H11003width. Exercise 8.20 Suppose MIPS multicycle processor described Section 7.4 uses virtual memory system. (a) Sketch location TLB multicycle processor schematic. (b) Describe adding TLB affects processor performance. Exercise 8.21 virtual memory system designing uses single-level page table built dedicated hardware (SRAM associated logic). supports 25-bit virtual addresses, 22-bit physical addresses, 216-byte (64 KB) pages. page table entry contains physical page number, valid bit (V) dirty bit ( D). (a) total size page table, bits? (b) operating system team proposes reducing page size 64 16 KB, hardware engineers team object grounds added hardware cost. Explain objection. (c) page table integrated processor chip, along on-chip cache. on-chip cache deals physical (not virtual) addresses. possible access appropriate set on-chip cache concurrently page table access given memory access? Explain briefly relationship necessary concurrent access cache set page table entry. (d) possible perform tag comparison on-chip cache concurrently page table access given memory access? Explain briefly. Exercise 8.22 Describe scenario virtual memory system might affect application written. sure include discussion page size physical memory size affect performance application.510 CHAPTER EIGHT Memory SystemsChapter 08.qxd 1/30/07 9:53 Page 510Exercise 8.23 Suppose personal computer (PC) uses 32-bit virtual addresses. (a) maximum amount virtual memory space program use? (b) size PC’s hard disk affect performance? (c) size PC’s physical memory affect performance? Exercise 8.24 Use MIPS memory-mapped I/O interact user. time user presses button, pattern choice displays five light-emitting diodes (LEDs). Suppose input button mapped address 0xFFFFFF10 LEDs mapped address 0xFFFFFF14. button pushed, output 1; otherwise 0. (a) Write MIPS code implement functionality. (b) Draw schematic similar Figure 8.30 memory-mapped I/O system. (c) Write HDL code implement address decoder memory- mapped I/O system. Exercise 8.25 Finite state machines (FSMs), like ones built Chapter 3, also implemented software. (a) Implement traffic light FSM Figure 3.25 using MIPS assembly code. inputs ( TAand TB) memory-mapped bit 1 bit 0, respectively, address 0xFFFFF000. two 3-bit outputs ( LAand LB) mapped bits 0–2 bits 3–5, respectively, address 0xFFFFF004. Assume one-hot output encodings light, LAand LB; red 100, yellow 010, green 001. (b) Draw schematic similar Figure 8.30 memory-mapped I/O system. (c) Write HDL code implement address decoder memory- mapped I/O system.Exercises 511Chapter 08.qxd 1/30/07 9:53 Page 511Interview Questions following exercises present questions asked interviews. Question 8.1 Explain difference direct mapped, set associative, fully associative caches. cache type, describe application cache type perform better two. Question 8.2 Explain virtual memory systems work. Question 8.3 Explain advantages disadvantages using virtual memory system. Question 8.4 Explain cache performance might affected virtual page size memory system. Question 8.5 addresses used memory-mapped I/O cached? Explain not.512 CHAPTER EIGHT Memory SystemsChapter 08.qxd 1/30/07 9:53 Page 512A A.1 Introduction A.2 74xx Logic A.3 Programmable Logic A.4 Application-Specific Integrated Circuits A.5 Data Sheets A.6 Logic Families A.7 Packaging Assembly A.8 Transmission Lines A.9 EconomicsDigital System Implementation A.1 INTRODUCTION appendix introduces practical issues design digital sys- tems. material appendix necessary understanding rest book. However, seeks demystify process building real digital systems. Moreover, believe best way understand digital systems build debug laboratory. Digital systems usually built using one chips. One strat- egy connect together chips containing individual logic gates larger elements arithmetic/logical units (ALUs) memories. Another use programmable logic, contains generic arrays circuitry programmed perform specific logic functions. Yet third design custom integrated circuit containing specific logic necessary system. three strategies offer trade-offs cost, speed, power consumption, design time explored following sections. appendix also examines physical packag- ing assembly circuits, transmission lines connect chips, economics digital systems. A.2 74XX LOGIC 1970s 1980s, many digital systems built simple chips, containing handful logic gates. example, 7404 chip contains six gates, 7408 contains four gates, 7474 contains two flip-flops. chips collectively referred 74xx-series logic. sold many manufacturers, typically 10 25 cents per chip. chips largely obsolete, still handy simple digital systems class projects, inexpensive easy use. 74xx-series chips commonly sold 14-pin dual inline packages (DIPs ). 51574LS04 inverter chip 14-pin dual inline package. part number first line. LS indicates logic family (see Section A.6). N suffix indicates DIP package. large logo manufacturer, Signetics. bottom two lines gibberish codes indicating batch chip manufactured. Appendix A.qxd 1/30/07 2:57 PM Page 515A.2.1 Logic Gates Figure A.1 shows pinout diagrams variety popular 74xx-series chips containing basic logic gates. sometimes called small-scale integration (SSI) chips, built transistors. 14-pin packages typically notch top dot top left indicate orientation. Pins numbered starting 1 upper left going counterclockwise around package. chips need receive power ( VDD/H110055 V) ground (GND /H110050 V) pins 14 7, respec- tively. number logic gates chip determined number pins. Note pins 3 11 7421 chip connected (NC) anything. 7474 flip-flop usual D, CLK , Qterminals. also complementary output, . Moreover, receives asynchronous set (also called preset, PRE) reset (also called clear, CLR) sig- nals. active low; words, flop sets , resets ,and operates normally . A.2.2 Functions 74xx series also includes somewhat complex logic functions, including shown Figures A.2 A.3. called medium- scale integration (MSI) chips. use larger packages accommodate inputs outputs. Power ground still provided upper right lower left, respectively, chip. general func- tional description provided chip. See manufacturer’s data sheets complete descriptions. A.3 PROGRAMMABLE LOGIC Programmable logic consists arrays circuitry configured perform specific logic functions. already introduced three forms programmable logic: programmable read memories (PROMs), programmable logic arrays (PLAs), field programmable gate arrays (FPGAs). section shows chip implementations these. Configuration chips may performed blowing on-chip fuses connect disconnect circuit elements. called one-time programmable (OTP ) logic because, fuse blown, cannot restored. Alternatively, configuration may stored memory reprogrammed will. Reprogrammable logic convenient laboratory, chip reused development. A.3.1 PROMs discussed Section 5.5.7, PROMs used lookup tables. 2N-word /H11003M-bit PROM programmed perform combina- tional function Ninputs Moutputs. Design changes simplyPRE /H11005CLR /H110051 CLR /H110050PRE /H110050Q516 APPENDIX Digital System ImplementationAppendix A.qxd 1/30/07 2:57 PM Page 516A.3 Programmable Logic 517 DQ Q1 2 3 4 5 6 714 13 12 11 10 9 8GNDVDD 1A 1B 1Y 2A 2B 2Y4B 4A 4Y 3B 3A 3Y 7400 NAND1 2 3 4 5 6 714 13 12 11 10 9 8GNDVDD 1Y 1A 1B 2Y 2A 2B4Y 4B 4A 3Y 3B 3A 7402 NOR1 2 3 4 5 6 714 13 12 11 10 9 8GNDVDD 1A 1Y 2A 2Y 3A 3Y6A 6Y 5A 5Y 4A 4Y 7404 1 2 3 4 5 6 714 13 12 11 10 9 8GNDVDD 1A 1B 2A 2B 2C 2Y1C 1Y 3C 3B 3A 3Y 7411 AND31 2 3 4 5 6 714 13 12 11 10 9 8GNDVDD 1A 1B 1Y 2A 2B 2Y4B 4A 4Y 3B 3A 3Y 7408 1 2 3 4 5 6 714 13 12 11 10 9 8VDD 1A 1B 1Y 2A 2B 2Y4B 4A 4Y 3B 3A 3Y 7486 XORGND1 2 3 4 5 6 714 13 12 11 10 9 8VDD 1A 1B 1Y 2A 2B 2Y4B 4A 4Y 3B 3A 3Y 7432 ORGND 1 2 3 4 5 6 714 13 12 11 10 9 8GNDVDD 1A 1B 1C 1D 1Y2D 2C NC 2B 2A 2Y 7421 AND4NC1 2 3 4 5 6 714 13 12 11 10 9 8GNDVDD 1D 1Q 7474 FLOP1CLK1CLR 1PRE 1Q2CLR 2D 2PRE 2Q 2Q2CLKreset setDQ Qreset set Figure A.1 Common 74xx-series logic gatesAppendix A.qxd 1/30/07 2:57 PM Page 517518 APPENDIX Digital System Implementation CLR CLK D0 D1 D2 D3 ENP GND 74161 /163 CounterVDD Q0RCO LOADENT1 2 3 4 5 6 7 816 15 14 13 12 11 10 9Q1 Q2 Q3 always @(posedge CLK) // 74163 (~CLRb) Q <= 4'b0000; else (~LOADb) Q <= D; else (ENP & ENT) Q <= Q+1; assign RCO = (Q == 4'b1111) & ENT;4-bit Counter CLK: clock Q3:0: counter output D3:0: parallel input CLRb: async reset (161) sync reset (163) LOADb: load Q ENP, ENT: enables RCO: ripple carry out1G S1 1D3 1D2 1D1 1D0 1Y GND 74153 4 :1 MuxVDD 2G S0 2D3 2D2 2D1 2D0 2Y1 2 3 4 5 6 7 816 15 14 13 12 11 10 9always @(1Gb, S, 1D) (1Gb) 1Y = 0; else 1Y = 1D[S]; always @(2Gb, S, 2D) (2Gb) 2Y = 0; else 2Y = 2D[S];Two 4:1 Multiplexers D3:0: data S1:0: select Y: output Gb: enable A0 A1 A2 G2A G2B G1 Y7 GND 74138 3 :8 DecoderVDD Y0 Y1 Y2 Y3 Y4 Y5 Y61 2 3 4 5 6 7 816 15 14 13 12 11 10 93:8 Decoder A2:0: address output G1: active high enable G2: active low enables G1 G2A G2B A2:0 Y7:0 0 x x xxx 11111111 1 1 x xxx 11111111 1 0 1 xxx 11111111 1 0 01YS 1D0 1D1 2D0 2D1 2Y GND 74157 2 :1 MuxVDD G 4D0 4D1 4Y 3D0 3D1 3Y1 2 3 4 5 6 7 816 15 14 13 12 11 10 9always @(*) (~Gb) 1Y = 0; else 1Y = ? 1D[1] : 1D[0]; (~Gb) 2Y = 0; else 2Y = ? 2D[1] : 2D[0]; (~Gb) 3Y = 0; else 3Y = ? 3D[1] : 3D[0]; (~Gb) 4Y = 0; else 4Y = ? 4D[1] : 4D[0];Four 2:1 Multiplexers D1:0:d S: select Y: output Gb: enable 1EN 1A0 2Y3 1A1 2Y2 GND 74244 Tristate Bu fferVDD 2EN 1Y0 2A3 1Y1 2A2 1Y2 2A11 2 3 4 5 6 7 820 19 18 17 16 15 14 13 9 1012 111A2 2Y1 1A3 1Y0 1Y3 2A0assign 1Y = 1ENb ? 4'bzzzz : 1A; assign 2Y = 2ENB ? 4'bzzzz : 2A;8-bit Tristate Buffer A3:0: input Y3:0: output ENb: enable always @(posedge clk) (~ENb) Q <= D;EN Q0 D0 D1 Q1 GND 74377 RegisterVDD Q7 D7 D6 Q6 Q5 D5 D41 2 3 4 5 6 7 820 19 18 17 16 15 14 13 9 1012 11Q2 D2 D3 Q3 Q4 CLK8-bit Enableable Register CLK: clock D7:0:d Q7:0:o u p u ENb: enableYb7:0: 000 11111110 1 0 0 001 11111101 1 0 0 010 11111011 1 0 0 011 11110111 1 0 0 100 11101111 1 0 0 101 11011111 1 0 0 110 10111111 1 0 0 111 01111111 Figure A.2 Medium-scale integration chipsNote: Verilog variable names cannot start numbers, names example code Figure A.2 chosen match manufacturer’s data sheet.Appendix A.qxd 1/30/07 2:57 PM Page 518A.3 Programmable Logic 519 4-bit ALU A3:0,B3:0 : Y3:0 : output F3:0 : function select : mode select Cbn : carry Cbnplus4 :carry AeqB : equality (in modes) X,Y : carry lookahead adder outputsB0 A0 S3 S2 S1 S0 Cn F0 F1 F2 GND 74181 ALUVDD A1 B1 A2 B2 A3 B3 Cn+4 X A=B F31 2 3 4 5 6 7 8 9 10 11 1224 23 22 21 20 19 18 17 16 15 14 13D1 D2 LT RBO RBI D3 D0 GND 7447 7 - Segment DecoderVDD f g b c e1 2 3 4 5 6 7 816 15 14 13 12 11 10 97-segment Display Decoder D3:0 : data a...f : segments (low = ON) LTb: light test RBIb: ripple blanking RBOb: ripple blanking outRBO LT RBI D3:0 b c e f g 0 x x x 1 1 1 1 1 1 1 1 0 x x 0 0 0 0 0 0 0 x 1 0 0000 1 1 1 1 1 1 1 1 1 1 0000 0 0 0 0 0 0 1 1 1 1 0001 1 0 0 1 1 1 1 1 1 1 0010 0 0 1 0 0 1 0 1 1 1 0011 0 0 0 0 1 1 0 1 1 1 0100 1 0 0 1 1 0 0 1 1 1 0101 0 1 0 0 1 0 0 1 1 1 0110 1 1 0 0 0 0 0 1 1 1 0111 0 0 0 1 1 1 1 1 1 1 1000 0 0 0 0 0 0 0 1 1 1 1001 0 0 0 1 1 0 0 1 1 1 1010 1 1 1 0 0 1 0 1 1 1 1011 1 1 0 0 1 1 0 1 1 1 1100 1 0 1 1 1 0 0 1 1 1 1101 0 1 1 0 1 0 0 1 1 1 1110 0 0 0 1 1 1 1 1 1 1 1111 0 0 0 0 0 0 0a b c defg B3 AltBin AeqBin AgtBin AgtBout AeqBout AltBout GND 7485 ComparatorVDD A3 B2 A2 A1 B1 A0 B01 2 3 4 5 6 7 816 15 14 13 12 11 10 9always @(*) (A > B | (A == B & AgtBin)) begin AgtBout = 1; AeqBout = 0; AltBout = 0; end else (A < B | (A == B & AltBin) begin AgtBout = 0; AeqBout = 0; AltBout = 1; end else begin AgtBout = 0; AeqBout = 1; AltBout = 0; end4-bit Comparator A3:0,B3:0 :data relin : input relation relout : output relation always @(*) case (F) 0000: = ? ~A : + ~Cbn; 0001: = ? ~(A | B) : + B + ~Cbn; 0010: = ? (~A) & B : + ~B + ~Cbn; 0011: = ? 4'b0000 : 4'b1111 + ~Cbn; 0100: = ? ~(A & B) : + (A & ~B) + ~Cbn; 0101: = ? ~B : (A | B) + (A & ~B) + ~Cbn; 0110: = ? ^ B : - B - Cbn; 0111: = ? & ~B : (A & ~B) - Cbn; 1000: = ? ~A + B : + (A & B) + ~Cbn; 1001: = ? ~(A ^ B) : + B + ~Cbn; 1010: = ? B : (A | ~B) + (A & B) + ~Cbn; 1011: = ? & B : (A & B) + ~Cbn; 1100: = ? 1 : + + ~Cbn; 1101: = ? | ~B : (A | B) + + ~Cbn; 1110: = ? | B : (A | ~B) + + ~Cbn; 1111: = ? : - Cbn; endcaseinputs Figure A.3 medium-scale integration (MSI) chipsAppendix A.qxd 1/30/07 2:57 PM Page 519involve replacing contents PROM rather rewiring con- nections chips. Lookup tables useful small functions become prohibitively expensive number inputs grows. example, classic 2764 8-KB (64-Kb) erasable PROM (EPROM) shown Figure A.4. EPROM 13 address lines specify one 8K words 8 data lines read byte data word. chip enable output enable must asserted data read. maximum propagation delay 200 ps. normal operation, VPP used. EPROM usually pro- grammed special programmer sets , applies 13 V VPP, uses special sequence inputs configure memory. Modern PROMs similar concept much larger capaci- ties pins. Flash memory cheapest type PROM, selling $30 per gigabyte 2006. Prices historically declined 30 40% per year. A.3.2 PLAs discussed Section 5.6.1, PLAs contain planes compute combinational function written sum-of-products form. planes programmed using techniques PROMs. PLA two columns input one column output. one row minterm. organization efficient PROM many functions, array still grows excessively large functions numerous I/Os minterms. Many different manufacturers extended basic PLA concept build programmable logic devices (PLDs ) include registers.PGM /H110050PGM /H110051520 APPENDIX Digital System Implementation A6VPP A12 A7 A5 A4 A3 A2VDD PGM NC A8 A9 A11 OE A101 2 3 4 5 6 7 828 27 26 25 24 23 22 21 9 10 11 12 13 1420 19 18 17 16 15A0A1 D0 D1 D2 GNDCE D7 D6 D5 D4 D3assign = (~CEb & ~OEb) ? ROM[A] : 8'bZ;8 KB EPROM A12:0: address input D7:0 : data output CEb : chip enable OEb : output enable PGMb : program VPP : program voltage NC : connection Figure A.4 2764 8KB EPROMAppendix A.qxd 1/30/07 2:57 PM Page 520The 22V10 one popular classic PLDs. 12 dedicated input pins 10 outputs. outputs come directly PLA clocked registers chip. outputs also fed back PLA. Thus, 22V10 directly implement FSMs 12 inputs, 10 outputs, 10 bits state. 22V10 costs $2 quantities 100. PLDs rendered mostly obsolete rapid improvements capacity cost FPGAs. A.3.3 FPGAs discussed Section 5.6.2, FPGAs consist arrays configurable logic blocks (CLBs ) connected together programmable wires. CLBs contain small lookup tables flip-flops. FPGAs scale gracefully extremely large capacities, thousands lookup tables. Xilinx Altera two leading FPGA manufacturers. Lookup tables programmable wires flexible enough implement logic function. However, order magnitude less efficient speed cost (chip area) hard-wired versions functions. Thus, FPGAs often include specialized blocks, memories, multipliers, even entire microprocessors. Figure A.5 shows design process digital system FPGA. design usually specified hardware description lan- guage (HDL), although FPGA tools also support schematics. design simulated. Inputs applied compared expected outputs verify logic correct. Usually debug- ging required. Next, logic synthesis converts HDL Boolean functions. Good synthesis tools produce schematic functions, prudent designer examines schematics, well warnings produced synthesis, ensure desired logic produced. Sometimes sloppy coding leads circuits much larger intended circuits asynchronous logic. synthesis results good, FPGA tool maps functions onto CLBs specific chip. place route tool determines functions go lookup tables wired together. Wire delay increases length, critical circuits placed close together. design big fit chip, must reengineered. Timing analysis compares timing constraints (e.g., intended clock speed 100 MHz) actual circuit delays reports errors. logic slow, may redesigned pipelined differently. design correct, file generated specifying contents CLBs programming wires FPGA. Many FPGAs store configuration informa- tion static RAM must reloaded time FPGA turned on. FPGA download information computer theA.3 Programmable Logic 521 Design Entry SynthesisLogic Verification Mapping Timing Analysis Configure FPGAPlace RouteDebug Debug big slow Figure A.5 FPGA design flowAppendix A.qxd 1/30/07 2:57 PM Page 521laboratory, read nonvolatile ROM power first applied. Example A.1 FPGA TIMING ANALYSIS Alyssa P. Hacker using FPGA implement M&M sorter color sensor motors put red candy one jar green candy another. design implemented FSM, using Spartan XC3S200 FPGA, chip Spartan 3 series family. According data sheet, FPGA timing characteristics shown Table A.1. Assume design small enough wire delay negligible. Alyssa would like FSM run 100 MHz. maximum number CLBs critical path? fastest speed FSM could possibly run? SOLUTION: 100 MHz, cycle time, Tc, 10 ns. Alyssa uses Equation 3.13 fig- ure minimum combinational propagation delay, tpd, cycle time: tpd/H1134910 ns /H11002(0.72 ns /H110010.53 ns) /H110058.75 ns (A.1) Alyssa’s FSM use 14 consecutive CLBs (8.75/0.61) implement next-state logic. fastest speed FSM run Spartan 3 FPGA using single CLB next state logic. minimum cycle time Tc/H113500.61 ns /H110010.72 ns /H110010.53 ns /H110051.86 ns (A.2) Therefore, maximum frequency 538 MHz.522 APPENDIX Digital System Implementation Table A.1 Spartan 3 XC3S200 timing name value (ns) tpcq 0.72 tsetup 0.53 thold 0 tpd (per CLB) 0.61 tskew 0 Xilinx advertises XC3S100E FPGA 1728 lookup tables flip-flops $2 quantities 500,000 2006. modest quan- tities, medium-sized FPGAs typically cost $10, largestAppendix A.qxd 1/30/07 2:57 PM Page 522FPGAs cost hundreds even thousands dollars. cost declined approximately 30% per year, FPGAs becoming extremely popular. A.4 APPLICATION-SPECIFIC INTEGRATED CIRCUITS Application-specific integrated circuits (ASICs ) chips designed particular purpose. Graphics accelerators, network interface chips, cell phone chips common examples ASICS. ASIC designer places transistors form logic gates wires gates together. ASIC hardwired specific function, typically sev- eral times faster FPGA occupies order magnitude less chip area (and hence cost) FPGA function. However, masks specifying transistors wires located chip cost hundreds thousands dollars produce. fabri- cation process usually requires 6 12 weeks manufacture, package, test ASICs. errors discovered ASIC manufac- tured, designer must correct problem, generate new masks, wait another batch chips fabricated. Hence, ASICs suit- able products produced large quantities whose function well defined advance. Figure A.6 shows ASIC design process, similar FPGA design process Figure A.5. Logic verification especially important correction errors masks produced expensive. Synthesis produces netlist consisting logic gates con- nections gates; gates netlist placed, wires routed gates. design satisfactory, masks generated used fabricate ASIC. single speck dust ruin ASIC, chips must tested fabrication. fraction manufactured chips work called yield; typically 50 90%, depending size chip maturity manufacturing process. Finally, working chips placed pack- ages, discussed Section A.7. A.5 DATA SHEETS Integrated circuit manufacturers publish data sheets describe functions performance chips. essential read understand data sheets. One leading sources errors digi- tal systems comes misunderstanding operation chip. Data sheets usually available manufacturer’s Web site. cannot locate data sheet part clear documentation another source, don’t use part. entries data sheet may cryptic. Often manufacturer pub- lishes data books containing data sheets many related parts. TheA.5 Data Sheets 523 Design Entry SynthesisLogic Verification Timing Analysis Generate MasksPlace Route Debug Debug big slow Fabricate ASIC Test ASIC Package ASICDefective Figure A.6 ASIC design flowAppendix A.qxd 1/30/07 2:57 PM Page 523beginning data book additional explanatory information. information usually found Web careful search. section dissects Texas Instruments (TI) data sheet 74HC04 inverter chip. data sheet relatively simple illustrates many major elements. TI still manufacturers wide variety 74xx-series chips. past, many companies built chips too, market consolidating sales decline. Figure A.7 shows first page data sheet. key sec- tions highlighted blue. title SN54HC04, SN74HC04 HEX INVERTERS. HEX INVERTERS means chip contains six inverters. SN indicates TI manufacturer. manufacture codes include MC Motorola DM National Semiconductor. generally ignore codes, manufacturers build compatible 74xx- series logic. HC logic family (high speed CMOS). logic family determines speed power consumption chip, func- tion. example, 7404, 74HC04, 74LS04 chips contain six inverters, differ performance cost. logic families discussed Section A.6. 74xx chips operate across commercial industrial temperature range (0 70 /H11034C /H1100240 85 /H11034C, respectively), whereas 54xx chips operate across military temperature range (/H1100255 125 /H11034C) sell higher price otherwise compatible. 7404 available many different packages, impor- tant order one intended make purchase. packages distinguished suffix part number. N indicates plastic dual inline package (PDIP ), fits breadboard soldered through-holes printed circuit board. packages discussed Section A.7. function table shows gate inverts input. Ais HIGH (H), Yis LOW (L) vice versa. table trivial case interesting complex chips. Figure A.8 shows second page data sheet. logic dia- gram indicates chip contains inverters. absolute maximum section indicates conditions beyond chip could destroyed. particular, power supply voltage ( VCC, also called VDDin book) exceed 7 V. continuous output current exceed 25 mA. thermal resistanc e impedance, /H9258JA, used cal- culate temperature rise caused chip’s dissipating power. ambient temperature vicinity chip TAand chip dissi- pates Pchip, temperature chip junction package TJ/H11005TA/H11001Pchip/H9258JA (A.3) example, 7404 chip plastic DIP package operating hot box 50 /H11034C consumes 20 mW, junction temperature will524 APPENDIX Digital System ImplementationAppendix A.qxd 1/30/07 2:57 PM Page 524A.5 Data Sheets 525 SCLS078D – DECEMBER 1982 – REVISED JULY 2003 POST OFFICE BOX 655303 •DALLAS, TEXAS 75265Wide Operating Voltage Range 2 V 6 V Outputs Drive 10 LSTTL Loads Low Power Consumption, 20- μA Max ICCTypical pd = 8 ns ±4-mA Output Drive 5 V Low Input Current 1 μA Max 1 2 3 4 5 6 714 13 12 11 10 9 81A 1Y 2A 2Y 3A 3Y GNDVCC 6A 6Y 5A 5Y 4A 4YSN54HC04 . . . J W PACKAGE SN74HC04 . . . D, N, NS, PW PACKAGE (TOPVIEW) 321 2 0 1 9 91 01 11 21 34 5 6 7 818 17 16 15 146Y NC 5A NC 5Y2A NC 2Y NC 3A Y1 A1 CN Y4 A4VCC A6Y3 DNG CNSN54HC04 . . . FK PACKAGE (TOPVIEW) NC – internal connection description/ordering information ORDERING INFORMATION TAPACKAGE† ORDERABLE PARTNUMBERTOP-SIDE MARKING PDIP – N Tube 25 SN74HC04N SN74HC04N Tube 50 SN74HC04D SOIC – DReel 2500 SN74HC04DR HC04 Reel 250 SN74HC04DT –40°C 85 °C SOP – NS Reel 2000 SN74HC04NSR HC04 Tube 90 SN74HC04PW TSSOP – PW Reel 2000 SN74HC04PWR HC04 Reel 250 SN74HC04PWT CDIP – J Tube 25 SNJ54HC04J SNJ54HC04J –55°C 125 °C CFP – W Tube 150 SNJ54HC04W SNJ54HC04W LCCC – FK Tube 55 SNJ54HC04FK SNJ54HC04FK † Package drawings, standard packing quantities, thermal data, symbolization, PCB design guidelines available www.ti.com/sc/package. FUNCTION TABLE (each inverter) INPUT AOUTPUT H L L H Please aware important notice concerning availability, standard warranty, use critical applications Texas Instruments semiconductor products disclaimers appears end data sheet. Copyright (c)2003, Texas Instruments Incorporated PRODUCTION DATA information current publication date. Products conform specifications per terms Texas Instruments standard warranty. Production processing necessarily include testing parameters.On products compliant MIL-PRF-38535, parameters tested unless otherwise noted. products, production processing necessarily include testing parameters.SN54HC04, SN74HC04 HEX INVERTERS ’HC04 devices contain six independent inverters. perform Boolean function = positive logic. Figure A.7 7404 data sheet page 1Appendix A.qxd 1/30/07 2:57 PM Page 525526 APPENDIX Digital System Implementation SN54HC04, SN74HC04 HEX INVERTERS SCLS078D – DECEMBER 1982 – REVISED JULY 2003 POST OFFICE BOX 655303 •DALLAS, TEXAS 75265logic diagram (positive logic) absolute maximum ratings operating free-air temperature range (unless otherwise noted)† Supply voltage range, V CC –0.5 V 7 V .......................................................... Input clamp current, IK(VI < 0 V I>VCC) (see Note 1) ±20 .................................... Output clamp current, OK(VO < 0 V O>VCC) (see Note 1) ±20 ................................ Continuous output current, O(VO= 0 V CC) ±25 .............................................. Continuous current V CCor GND ±50 ................................................... Package thermal impedance, θJA 86° C/W egakcapD:)2etoNees( ................................... 80° C/W egakcapN ................................... 76° C/W egakcapSN ................................. 131° C/W egakcapWP ................................ Storage temperature range, stg –65° C 150 ° C ................................................... †Stresses beyond listed “absolute maximum ratings” may cause permanent damage device. stress ratings only, functional operation device conditions beyond indicated “recommended operating conditions” implied. Exposure absolute-maximum-rated conditions extended periods may affect device reliability. NOTES: 1. input output voltage ratings may exceeded input output current ratings observed. 2. package thermal impedance calculated accordance JESD 51-7. recommended operating conditions (see Note 3) SN54HC04 SN74HC04 UNIT MIN NOM MAX MIN NOM MAXUNIT VCC Supply voltage 2 5 6 2 5 6 V VCC=2V 1.5 1.5 VIH High-level input voltage VCC= 4.5 V 3.15 3.15 V VCC=6V 4.2 4.2 VCC=2V 0.5 0.5 VIL Low-level input voltage VCC= 4.5 V 1.35 1.35 V VCC=6V 1.8 1.8 VI Input voltage 0 VCC 0 VCC V VO Output voltage 0 VCC 0 VCC V VCC=2V 1000 1000 Δt /Δv Input transition rise/fall time VCC= 4.5 V 500 500 ns VCC=6V 400 400 TA Operating free-air temperature –55 125 –40 85 ° C NOTE 3: unused inputs device must held V CCor GND ensure proper device operation. Refer TI application report, Implications Slow Floating CMOS Inputs , literature number SCBA004. TEXAS INSTRUMENTS Figure A.8 7404 datasheet page 2Appendix A.qxd 1/30/07 2:57 PM Page 526climb 50 /H11034C/H110010.02 W /H1100380/H11034C/W /H1100551.6 /H11034C. Internal power dissipa- tion seldom important 74xx-series chips, becomes important modern chips dissipate tens watts more. recommended operating conditions define environment chip used. Within conditions, chip meet specifications. conditions stringent absolute maximums. example, power supply voltage 2 6 V. input logic levels HC logic family depend VDD. Use 4.5 V entries VDD/H110055 V, allow 10% droop power supply caused noise system. Figure A.9 shows third page data sheet. electrical characteristics describe device performs used within recommended operating conditions inputs held constant. example, VCC/H110055 V (and droops 4.5 V) output cur- rent, IOH/IOLdoes exceed 20 /H9262A, VOH/H110054.4 V VOL/H110050.1 V worst case. output current increases, output voltages become less ideal, transistors chip struggle pro- vide current. HC logic family uses CMOS transistors draw little current. current input guaranteed less 1000 nA typically 0.1 nA room tempera- ture. quiescent power supply current ( IDD) drawn chip idle less 20 /H9262A. input less 10 pF capacitance. switching characteristics define device performs used within recommended operating conditions inputs change. propagation delay, pd, measured input passes 0.5 VCCto output passes 0.5 VCC. VCCis nominally 5 V chip drives capacitance less 50 pF, propagation delay exceed 24 ns (and typically much faster). Recall input may present 10 pF, chip cannot drive five identical chips full speed. Indeed, stray capaci- tance wires connecting chips cuts useful load. transition time , also called rise/fall time, measured out- put transitions 0.1 VCCand 0.9 VCC. Recall Section 1.8 chips consume static dynamic power . Static power low HC circuits. 85 /H11034C, maximum quiescent supply current 20 /H9262A. 5 V, gives static power consumption 0.1 mW. dynamic power depends capacitance driven switching frequency. 7404 internal power dissipation capacitance 20 pF per inverter. six inverters 7404 switch 10 MHz drive external loads 25 pF, dynamic power given Equation 1.4 (6)(20 pF /H11001 25 pF)(52)(10 MHz) /H1100533.75 mW maximum total power 33.85 mW.1 2A.5 Data Sheets 527Appendix A.qxd 1/30/07 2:57 PM Page 527528 APPENDIX Digital System Implementation SN54HC04, SN74HC04 HEX INVERTERS SCLS078D – DECEMBER 1982 – REVISED JULY 2003 POST OFFICE BOX 655303 • DALLAS, TEXAS 75265TEXAS INSTRUMENTSelectrical characteristics recommended operating free-air temperature range (unless otherwise noted) PARAMETER TEST CONDITIONS VCCTA = 25° C SN54HC04 SN74HC04UNITMIN TYP MAX MIN MAX MIN MAXUNIT 2V 1.9 1.998 1.9 1.9 IOH = –20 μA IOL = 20 μA4.5V 4.4 4.499 4.4 4.4 VOH VOLVI = VIH VIL VI = VIH VIL VI = VCC 0 VI = VCC 0, 6V 5.9 5.999 5.9 5.9 V IOH = –4 IOL = 4 mA4.5V 3.98 4.3 3.7 3.84 IOH = –5.2 IOL = 5.2 mA6V 5.48 5.8 5.2 5.34 2V 0.002 0.1 0.1 0.1 4.5V 0.001 0.1 0.1 0.1 6V 0.001 0.1 0.1 0.1 V 4.5V 0.17 0.26 0.4 0.33 6V 0.15 0.26 0.4 0.33 II 6V ±0.1 ±100 ±1000 ±1000 nA ICCIO = 0 6V 2 40 20 μA Ci 2Vt o6V 3 10 10 10 pF switching characteristics recommended operating free-air temperature range, C L = 50 pF (unless otherwise noted) (see Figure 1) TOVCCTA = 25° C SN54HC04 SN74HC04UNIT PARAMETER(INPUT) (OUTPUT) MIN TYP MAX MIN MAX MIN MAXUNIT 2V 45 95 145 120 tpdA 4.5V 9 19 29 24 ns 6V 8 16 25 20 2V 38 75 11 0 95 ttY 4.5V 8 15 22 19 ns 6V 6 13 19 16 operating characteristics, TA = 25 ° C PARAMETER TEST CONDITIONS TYP UNIT Cpd Power dissipation capacitance per inverter load 20 pF Figure A.9 7404 datasheet page 3Appendix A.qxd 1/30/07 2:57 PM Page 528A.6 LOGIC FAMILIES 74xx-series logic chips manufactured using many different technologies, called logic families , offer different speed, power, logic level trade-offs. chips usually designed compatible logic families. original chips, 7404, built using bipolar transistors technology called Transistor- Transistor Logic (TTL). Newer technologies add one letters 74 indicate logic family, 74LS04, 74HC04, 74AHCT04. Table A.2 summarizes common 5-V logic families. Advances bipolar circuits process technology led Schottky (S) Low-Power Schottky (LS) families. faster TTL. Schottky draws power, whereas Low-power Schottky draws less. Advanced Schottky (AS) Advanced Low-Power Schottky (ALS) improved speed power compared LS. Fast (F) logic faster draws less power AS. families provide current LOW outputs HIGH outputs hence asym- metric logic levels. conform “TTL” logic levels: VIH/H110052 V, VIL/H110050.8 V, VOH/H110222.4 V, VOL/H110210.5 V.A.6 Logic Families 529 Table A.2 Typical specifications 5-V logic families CMOS / TTL Bipolar / TTL CMOS Compatible Characteristic TTL LS ALS F HC AHC HCT AHCT tpd(ns) 22 9 12 7.5 10 6 21 7.5 30 7.7 VIH(V) 2 2 2 2 2 2 3.15 3.15 2 2 VIL(V) 0.8 0.8 0.8 0.8 0.8 0.8 1.35 1.35 0.8 0.8 VOH(V) 2.4 2.7 2.7 2.5 2.5 2.5 3.84 3.8 3.84 3.8 VOL(V) 0.4 0.5 0.5 0.5 0.5 0.5 0.33 0.44 0.33 0.44 IOH(mA) 0.4 1 0.4 2 0.4 1 4 8 4 8 IOL(mA) 16 20 8 20 8 20 4 8 4 8 IIL(mA) 1.6 2 0.4 0.5 0.1 0.6 0.001 0.001 0.001 0.001 IIH(mA) 0.04 0.05 0.02 0.02 0.02 0.02 0.001 0.001 0.001 0.001 IDD(mA) 33 54 6.6 26 4.2 15 0.02 0.02 0.02 0.02 Cpd(pF) n/a 20 12 20 14 cost*(US $) obsolete 0.57 0.29 0.53 0.33 0.20 0.15 0.15 0.15 0.15 *Per unit quantities 1000 7408 Texas Instruments 2006Appendix A.qxd 1/30/07 2:57 PM Page 529As CMOS circuits matured 1980s 1990s, became popular draw little power supply input current. High Speed CMOS (HC) Advanced High Speed CMOS (AHC ) families draw almost static power. also deliver current HIGH LOW outputs. conform “CMOS” logic levels: VIH/H110053.15 V, VIL/H110051.35 V, VOH/H110223.8 V, VOL/H110210.44 V. Unfortunately, levels incompatible TTL circuits, TTL HIGH output 2.4 V may recog- nized legal CMOS HIGH input. motivates use High Speed TTL-compatible CMOS (HCT ) Advanced High Speed TTL- compatible CMOS (AHCT ), accept TTL input logic levels generate valid CMOS output logic levels. families slightly slower pure CMOS counterparts. CMOS chips sensi- tive electrostatic discharge (ESD) caused static electricity. Ground touching large metal object handling CMOS chips, lest zap them. 74xx-series logic inexpensive. newer logic families often cheaper obsolete ones. LS family widely available robust popular choice laboratory hobby projects special performance requirements. 5-V standard collapsed mid-1990s, transistors became small withstand voltage. Moreover, lower voltage offers lower power consumption. 3.3, 2.5, 1.8, 1.2, even lower voltages commonly used. plethora voltages raises challenges communicating chips different power supplies. Table A.3 lists low-voltage logic families. 74xx parts avail- able logic families. low-voltage logic families use CMOS transistors, workhorse modern integrated circuits. operate wide range VDD, speed degrades lower voltage. Low-Voltage CMOS (LVC) logic Advanced Low-Voltage CMOS (ALVC ) logic commonly used 3.3, 2.5, 1.8 V. LVC withstands inputs 5.5 V, receive inputs 5-V CMOS TTL circuits. Advanced Ultra-Low-Voltage CMOS (AUC) commonly used 2.5, 1.8, 1.2 V exceptionally fast. ALVC AUC with- stand inputs 3.6 V, receive inputs 3.3-V circuits. FPGAs often offer separate voltage supplies internal logic, called core, input/output (I/O) pins. FPGAs advanced, core voltage dropped 5 3.3, 2.5, 1.8, 1.2 V save power avoid damaging small transistors. FPGAs configurable I/Os operate many different voltages, compatible rest system.530 APPENDIX Digital System ImplementationAppendix A.qxd 1/30/07 2:57 PM Page 530A.7 PACKAGING ASSEMBLY Integrated circuits typically placed packages made plastic ceramic. packages serve number functions, including connecting tiny metal I/O pads chip larger pins package ease connection, protecting chip physical damage, spreading heat generated chip larger area help cooling. packages placed breadboard printed circuit board wired together assemble system. Packages Figure A.10 shows variety integrated circuit packages. Packages generally categorized through-hole surface mount (SMT ). Through-hole packages, name implies, pins inserted holes printed circuit board socket. Dual inline packages (DIPs ) two rows pins 0.1-inch spacing pins. Pin grid arrays (PGAs ) support pins smaller package placing pins package. SMT packages soldered directly surface printed circuit board without using holes. Pins SMT parts called leads . thin small outline package (TSOP ) two rows closely spaced leads (typically 0.02-inch spac- ing). Plastic leaded chip carriers (PLCCs ) J-shaped leads fourA.7 Packaging Assembly 531 Table A.3 Typical specifications low-voltage logic families LVC ALVC AUC Vdd(V) 3.3 2.5 1.8 3.3 2.5 1.8 2.5 1.8 1.2 tpd(ns) 4.1 6.9 9.8 2.8 3 ?11.8 2.3 3.4 VIH(V) 2 1.7 1.17 2 1.7 1.17 1.7 1.17 0.78 VIL(V) 0.8 0.7 0.63 0.8 0.7 0.63 0.7 0.63 0.42 VOH(V) 2.2 1.7 1.2 2 1.7 1.2 1.8 1.2 0.8 VOL(V) 0.55 0.7 0.45 0.55 0.7 0.45 0.6 0.45 0.3 IO(mA) 24 8 4 24 12 12 9 8 3 II(mA) 0.02 0.005 0.005 IDD(mA) 0.01 0.01 0.01 Cpd(pF) 10 9.8 7 27.5 23 ?*17 14 14 cost (US $) 0.17 0.20 available *Delay capacitance available time writingAppendix A.qxd 1/30/07 2:57 PM Page 531sides, 0.05-inch spacing. soldered directly board placed special sockets. Quad flat packs (QFPs ) accommodate large number pins using closely spaced legs four sides. Ball grid arrays (BGAs ) eliminate legs altogether. Instead, hundreds tiny solder balls underside package. carefully placed matching pads printed circuit board, heated solder melts joins package underlying board. Breadboards DIPs easy use prototyping, placed breadboard . breadboard plastic board containing rows sockets, shown Figure A.11. five holes row connected together. pin package placed hole separate row. Wires placed adjacent holes row make connections pin. Breadboards often provide separate columns connected holes running height board distribute power ground. Figure A.11 shows breadboard containing majority gate built 74LS08 chip 74LS32 chip. schematic circuit shown Figure A.12. gate schematic labeled chip (08 32) pin numbers inputs outputs (see Figure A.1). Observe connections made breadboard. inputs connected pins 1, 2, 5 08 chip, output measured pin 6 32 chip. Power ground connected pins 14 7, respectively, chip, verti- cal power ground columns attached banana plug receptacles, Vb Va. Labeling schematic way checking connections made good way reduce number mistakes made breadboarding. Unfortunately, easy accidentally plug wire wrong hole wire fall out, breadboarding requires great deal care (and usually debugging laboratory). Breadboards suited prototyping, production.532 APPENDIX Digital System Implementation Figure A.10 Integrated circuit packagesAppendix A.qxd 1/30/07 2:57 PM Page 532Printed Circuit Boards Instead breadboarding, chip packages may soldered printed circuit board (PCB). PCB formed alternating layers conduct- ing copper insulating epoxy. copper etched form wires called traces . Holes called viasare drilled board plated metal connect layers. PCBs usually designed computer-aided design (CAD ) tools. etch drill simple boards laboratory, send board design specialized factory inexpensive mass production. Factories turn- around times days (or weeks, cheap mass production runs) typically charge hundred dollars setup fees dollars per board moderately complex boards built large quantities.A.7 Packaging Assembly 533 08 08 0832 321BC Y23 4 56 89 101 23 4 56A Figure A.12 Majority gate schematic chips pins identified GNDRows 5 pins internally connectedVDD Figure A.11 Majority circuit breadboardAppendix A.qxd 1/30/07 2:57 PM Page 533534 APPENDIX Digital System Implementation Signal Layer Signal LayerPower Plane Ground PlaneCopper Trace Insulator Figure A.13 Printed circuit board cross-section PCB traces normally made copper low resistance. traces embedded insulating material, usually green, fire- resistant plastic called FR4. PCB also typically copper power ground layers, called planes , signal layers. Figure A.13 shows cross-section PCB. signal layers top bottom, power ground planes embedded center board. power ground planes low resistance, distribute sta- ble power components board. also make capacitance inductance traces uniform predictable. Figure A.14 shows PCB 1970s vintage Apple II /H11001computer. top Motorola 6502 microprocessor. Beneath six 16-Kb ROM chips forming 12 KB ROM containing operating system. Three rows eight 16-Kb DRAM chips provide 48 KB RAM. right several rows 74xx-series logic memory address decoding functions. lines chips traces wire chips together. dots ends traces vias filled metal. Putting Together modern chips large numbers inputs outputs use SMT packages, especially QFPs BGAs. packages require printed circuit board rather breadboard. Working BGAs especially challenging require specialized assembly equipment. Moreover, balls cannot probed voltmeter oscilloscope debugging laboratory, hidden package. summary, designer needs consider packaging early determine whether breadboard used prototyping whether BGA parts required. Professional engineers rarely use breadboards confident connecting chips together cor- rectly without experimentation. A.8 TRANSMISSION LINES assumed far wires equipotential connections single voltage along entire length. Signals actually propagate along wires speed light form electromagnetic waves. wires short enough signals change slowly, equipotential assumptionAppendix A.qxd 1/30/07 2:57 PM Page 534is good enough. wire long signal fast, trans- mission time along wire becomes important accurately determine circuit delay. must model wires transmission lines , wave voltage current propagates speed light. wave reaches end line, may reflect back along line. reflection may cause noise odd behaviors unless steps taken limit it. Hence, digital designer must consider transmission line behavior accurately account delay noise effects long wires. Electromagnetic waves travel speed light given medium, fast instantaneous. speed light depends permittivity , ε, permeability , μ, medium2: .v/H110051 s/H9262/H9255/H110051 sLCA.8 Transmission Lines 535 Figure A.14 Apple II /H11001circuit board 2The capacitance, C, inductance, L, wire related permittivity permeability physical medium wire located.Appendix A.qxd 1/30/07 2:57 PM Page 535The speed light free space /H9263/H11005c/H110053/H11003108m/s. Signals PCB travel half speed, FR4 insulator four times permittivity air. Thus, PCB signals travel 1.5 /H11003108m/s, 15 cm/ns. time delay signal travel along transmission line length lis td/H11005l/v (A.4) characteristic impedance transmission line, Z0(pronounced “Z-naught”), ratio voltage current wave traveling along line: Z0/H11005V/I. notthe resistance wire (a good transmis- sion line digital system typically negligible resistance). Z0depends inductance capacitance line (see derivation Section A.8.7) typically value 50 75 /H9024. (A.5) Figure A.15 shows symbol transmission line. symbol resembles coaxial cable inner signal conductor outer grounded conductor like used television cable wiring. key understanding behavior transmission lines visualize wave voltage propagating along line speed light. wave reaches end line, may absorbed reflected, depending termination load end. Reflections travel back along line, adding voltage already line. Terminations classified matched, open, short, mismatched. following subsections explore wave propagates along line happens wave reaches termination. A.8.1 Matched Termination Figure A.16 shows transmission line length lwith matched ter- mination , means load impedance, ZL, equal characteristic impedance, Z0. transmission line characteris- tic impedance 50 /H9024. One end line connected voltageZ0/H11005vL C536 APPENDIX Digital System Implementation V –+Z0= CL Figure A.15 Transmission line symbolAppendix A.qxd 1/30/07 2:57 PM Page 536A.8 Transmission Lines 537 VSt = 0 Z0 = 50 Ωlength = l td = l /vAC B l /3 ZL = 50 Ω Figure A.16 Transmission line matched termination Figure A.17 Voltage waveforms Figure A.16 points A, B, C VSZL = 50 ΩA, B, C Figure A.18 Equivalent circuit Figure A.16 steady statesource switch closes time t/H110050. end connected 50 /H9024matched load. section analyzes volt- ages currents points A, B, C—at beginning line, one-third length along line, end line, respectively. Figure A.17 shows voltages points A, B , Cover time. Initially, voltage current flowing transmission line, switch open. time t/H110050, switch closes, voltage source launches wave voltage V/H11005VSalong line. characteristic impedance Z0, wave current I/H11005VS/Z0. voltage reaches beginning line (point A) immediately, shown Figure A.17(a). wave propagates along line speed light. time td/3, wave reaches point B. voltage point abruptly rises 0 VS, shown Figure A.17(b). time td, incident wave reaches point Cat end line, voltage rises too. current, I, flows resistor, ZL, producing voltage across resistor ZLI/H11005ZL(VS/Z0)/H11005VSbecause ZL/H11005Z0. voltage consistent wave flowing along transmission line. Thus, wave absorbed load impedance, transmission line reaches steady state . steady state, transmission line behaves like ideal equipoten- tial wire is, all, wire. voltage points along line must identical. Figure A.18 shows steady-state equivalent model circuit Figure A.16. voltage VSevery- along wire. Example A.2 TRANSMISSION LINE MATCHED SOURCE LOAD TERMINATIONS Figure A.19 shows transmission line matched source load impedances ZSand ZL. Plot voltage nodes A, B, Cversus time. system reach steady-state, equivalent circuit steady-state? SOLUTION: voltage source source impedance, ZS, series transmission line, part voltage drops across Z S, remainder(a)ttdVA VS (c)tVS td VC(b)tVS td /3 td VBAppendix A.qxd 1/30/07 2:57 PM Page 537propagates transmission line. first, transmission line behaves impedance Z0, load end line cannot possibly influence behavior line speed light delay elapsed. Hence, voltage divider equation , incident voltage flowing line (A.6) Thus, t/H110050, wave voltage, , sent line point A. Again, signal reaches point Bat time td/3 point Cat td, shown Figure A.20. current absorbed load impedance ZL, circuit enters steady-state t/H11005td. steady-state, entire line VS/2, steady-state equivalent circuit Figure A.21 would predict. A.8.2 Open Termination load impedance equal Z0, termination cannot absorb current, wave must reflected. Figure A.22 shows transmission line open load termination. current flow open termination, current point Cmust always 0. voltage line initially zero. t/H110050, switch closes wave voltage, , begins propagating line. Notice initial wave Example A.2 independent termination, load end line cannot influence behavior beginning least tdhas elapsed. wave reaches point Bat td/3 point Cat tdas shown Figure A.23. incident wave reaches point C, cannot continue forward wire open. must instead reflect back toward source. reflected wave also voltage , open termina- tion reflects entire wave. voltage point sum incident reflected waves. time t/H11005td, voltage point Cis . reflected wave reaches point Bat 5td/3 point Aat 2td. reaches point A, wave absorbed source terminationV/H11005VS 2/H11001VS 2/H11005VSV/H11005VS 2V/H11005VS Z0 Z0/H11001ZS/H11005VS 2V/H11005VS 2V/H11005VS/H20898Z0 Z0/H11001ZS/H20899/H11005VS 2538 APPENDIX Digital System Implementation tVA (a)VS/2 td (b)td / 3VS/2VB (c)tdVC VS / 2td Figure A.20 Voltage waveforms Figure A.19 points A, B, C ZL = 50 Ω ZS = 50 ΩA, B, C VS Figure A.21 Equivalent circuit Figure A.19 steady stateVSt = 0 Z0 = 50 ΩZL = 50 ΩZS = 50 Ω length = l td = l /vA C B l /3 Figure A.19 Transmission line matched source load impedancesAppendix A.qxd 1/30/07 2:57 PM Page 538A.8 Transmission Lines 539 impedance matches characteristic impedance line. Thus, system reaches steady state time t/H110052td, transmission line becomes equivalent equipotential wire voltage VSand current I/H110050. A.8.3 Short Termination Figure A.24 shows transmission line terminated short circuit ground. Thus, voltage point Cmust always 0. previous examples, voltages line initially 0. switch closes, wave voltage, , begins propagating line (Figure A.25). reaches end line, must reflect opposite polarity. reflected wave, voltage , adds incident wave, ensuring voltage point C remains 0. reflected wave reaches source time t/H110052tdand absorbed source impedance. point, system reaches steady state, transmission line equivalent equipotential wire voltage V/H110050.V/H11005/H11002VS 2V/H11005VS 2 tVS /2VS 5td /3 td /3 td VB tVS td VC (c)(b)(a)t tdVA VS /2VS 2td Figure A.23 Voltage waveforms Figure A.22 points A, B, CVSt = 0 Z0 = 50 Ωlength = l td = l /vAC B l /3 ZS = 50 Ω Figure A.22 Transmission line open load termination VSt = 0 Z0 = 50 Ωlength = l td = l /vAC B l /3 ZS = 50 Ω Figure A.24 Transmission line short termination A.8.4 Mismatched Termination termination impedance said mismatched equal characteristic impedance line. general, incident wave reaches mismatched termination, part wave absorbed part reflected. reflection coefficient, kr, indicates fraction incident wave ( Vi) reflected: Vr/H11005krVi. Section A.8.8 derives reflection coefficient using conservation current arguments. shows that, incident wave flowing along aAppendix A.qxd 1/30/07 2:57 PM Page 539transmission line characteristic impedance Z0reaches termination impedance, ZT, end line, reflection coefficient (A.7) Note special cases. termination open circuit ( ZT/H11005/H11009), kr/H110051, incident wave entirely reflected (so current end line remains zero). termination short circuit ( ZT/H110050), kr/H11005/H110021, incident wave reflected negative polarity (so voltage end line remains zero). termination matched load ( ZT/H11005Z0), kr/H110050, incident wave absorbed. Figure A.26 illustrates reflections transmission line mis- matched load termination 75 /H9024. ZT/H11005ZL/H1100575/H9024, Z0/H1100550 /H9024, kr/H110051/5. previous examples, voltage line initially 0. switch closes, wave voltage, , propagates line, reaching end t/H11005td. incident wave reaches termination end line, one fifth wave reflected, remaining four fifths flows load impedance. Thus, reflected wave voltage . total voltage point Cis sum incoming reflected voltages, . t/H110052td, reflected wave reaches point A, absorbed matched 50 /H9024termination, ZS. Figure A.27 plots voltages currents along line. Again, note that, steady state (in case time t/H11022 2td), transmission line equivalent equipotential wire, shown Figure A.28. steady-state, system acts like voltage divider, Reflections occur ends transmission line. Figure A.29 shows transmission line source impedance, ZS, 450 /H9024and open termination load. reflection coefficients load source, krLand krS, 4/5 1, respectively. case, waves reflect ends transmission line steady state reached. bounce diagram , shown Figure A.30, helps visualize reflections ends transmission line. horizontal axis representsVA/H11005VB/H11005VC/H11005VS/H20898ZL ZL/H11001ZS/H20899/H11005VS/H2089875/H9024 75/H9024/H11001 50/H9024/H20899/H110053VS 5VC/H11005VS 2/H11001VS 10/H110053VS 5V/H11005VS 2 /H110031 5/H11005VS 10V/H11005VS 2kr/H11005ZT/H11002Z0 ZT/H11001Z0540 APPENDIX Digital System Implementation tdVA VS /2 2td (a) tVS /2 5td /3 td /3 td VB (b) (c)tVS td VC Figure A.25 Voltage waveforms Figure A.24 points A, B, C VSt= 0 Z0= 50 Ωlength = l td= l/vAC B l /3 ZL= 75 ΩZS= 50 Ω +– Figure A.26 Transmission line mismatched terminationAppendix A.qxd 1/30/07 2:57 PM Page 540distance along transmission line, vertical axis represents time, increasing downward. two sides bounce diagram represent source load ends transmission line, points Aand C. incom- ing reflected signal waves drawn diagonal lines points Aand C. time t/H110050, source impedance transmission line behave voltage divider, launching voltage wave point Atoward point C. time t/H11005td, signal reaches point Cand completely reflected ( krL/H110051). time t/H110052td, reflected wave reaches point Aand reflected reflection coefficient, krS/H110054/5, produce wave traveling toward point C, forth. voltage given time point transmission line sum incident reflected waves. Thus, time t/H110051.1td, voltage point Cis . time t/H110053.1td, voltage point Cis , forth. Figure A.31 plots voltages time. tapproaches infinity, voltages approach steady-state VA/H11005VB/H11005VC/H11005VS.VS 10/H11001VS 10/H110012VS 25/H110012VS 25/H110059VS 25VS 10/H11001VS 10/H11005VS 52VS 25VS 10VS 10A.8 Transmission Lines 541 Figure A.27 Voltage waveforms Figure A.26 points A, B, C VSt = 0 length = l td= l/vAC B l /3 ZS = 450 Ω + Z0 = 50 Ω– Figure A.29 Transmission line mismatched source load terminationsA, B, C VSZS = 50 Ω ZL = 75 Ω + – Figure A.28 Equivalent circuit Figure A.26 steady-state Voltage AC 10 VS 10 25 25 125 125t = td krS = 4/5B VS 2VS 2VS 8VS 8VSt = 3td = 5td = 6tdt = 4tdt = 2tdt = 0 td krL = 1 Figure A.30 Bounce diagram Figure A.29ttdVA VS /23VS /5 2td (a)tVB 3VS /5 VS /2 td 5td /3 td /3 (b)t tdVC (c)3VS /5Appendix A.qxd 1/30/07 2:57 PM Page 541A.8.5 Use Transmission Line Models Transmission line models wires needed whenever wire delay, td, longer fraction (e.g., 20%) edge rates (rise fall times) signal. wire delay shorter, insignificant effect propagation delay signal, reflections dissipate signal transitioning. wire delay longer, must consid- ered order accurately predict propagation delay waveform signal. particular, reflections may distort digital characteris- tic waveform, resulting incorrect logic operations. Recall signals travel PCB 15 cm/ns. TTL logic, edge rates 10 ns, wires must modeled transmission lines longer 30 cm (10 ns /H1100315 cm/ns /H1100320%). PCB traces usually less 30 cm, traces modeled ideal equipotential wires. contrast, many modern chips edge rates 2 ns less, traces longer 6 cm (about 2.5 inches) must modeled transmission lines. Clearly, use edge rates crisper necessary causes difficulties designer. Breadboards lack ground plane, electromagnetic fields signal nonuniform difficult model. Moreover, fields interact signals. cause strange reflections crosstalk signals. Thus, breadboards unreliable megahertz. contrast, PCBs good transmission lines consistent characteristic impedance velocity along entire line. long terminated source load impedance matched impedance line, PCB traces suffer reflections. A.8.6 Proper Transmission Line Terminations two common ways properly terminate transmission line, shown Figure A.32. parallel termination (Figure A.32(a)), driver low impedance ( ZS≈0). load resistor ( ZL) impedance Z0is placed parallel load (between input receiver gate and542 APPENDIX Digital System Implementation Figure A.31 Voltage current waveforms Figure A.29tVS 102525VA 2td7VS16VS 4td 6td (a)t 3 33 33 3102525 525VB VSVS7VS9VS16VS td 5td7td11td13td17td (b)t525125VC (c)td 3td 5td9VS61VS VSAppendix A.qxd 1/30/07 2:57 PM Page 542ground). driver switches 0 VDD, sends wave voltage VDDdown line. wave absorbed matched load ter- mination, reflections take place. eries termination (Figure A.32(b)), source resistor (Z 5) placed series driver raise source impedance Z0. load high impedance ( ZL≈/H11009). driver switches, sends wave voltage VDD/2 line. wave reflects open circuit load returns, bringing voltage line VDD. wave absorbed source termina- tion. schemes similar voltage receiver transitions 0 VDDat t/H11005td, one would desire. differ power consumption waveforms appear elsewhere along line. Parallel termination dissipates power continuously load resis- tor line high voltage. Series termination dissipates DC power, load open circuit. However, series terminated lines, points near middle transmission line initially see voltage VDD/2, reflection returns. gates attached theA.8 Transmission Lines 543 AC B driver gate (b)receiver gate series termination resistorZL≈ ∞ ttd tVDDVA VB VCt tVDDVDD VB VCAC B (a)driver gatereceiver gate parallel termination resistorZS ≈ 0Z0 ZL = Z0ZS = Z0Z0 VA VDD /2 VDD td /3 td VDD td td 2td 5td /3 td /3 td tdVDD VDD /2 Figure A.32 Termination schemes: (a) parallel, (b) seriesAppendix A.qxd 1/30/07 2:57 PM Page 543middle line, momentarily see illegal logic level. Therefore, series termination works best point-to-point communication single driver single receiver. Parallel termination better buswith multiple receivers, receivers middle line never see illegal logic level. A.8.7 Derivation Z0* Z0is ratio voltage current wave propagating along trans- mission line. section derives Z0; assumes previous knowledge resistor-inductor-capacitor (RLC) circuit analysis. Imagine applying step voltage input semi-infinite trans- mission line (so reflections). Figure A.33 shows semi-infinite line model segment line length dx. R, L , C, values resistance, inductance, capacitance per unit length. Figure A.33(b) shows transmission line model resistive component, R. called lossy transmission line model, energy dissipated, lost, resistance wire. However, loss often negligible, simplify analysis ignoring resistive component treating transmission line ideal transmission line, shown Figure A.33(c). Voltage current functions time space throughout transmission line, given Equations A.8 A.9. (A.8) (A.9) Taking space derivative Equation A.8 time derivative Equation A.9 substituting gives Equation A.10, wave equation . (A.10) Z0is ratio voltage current transmission line, illus- trated Figure A.34(a). Z 0must independent length line, behavior wave cannot depend things dis- tance. independent length, impedance must still equal Z0after addition small amount transmission line, dx, shown Figure A.34(b).∂2 ∂x2V(x, t)/H11005LC∂2 ∂t2 I(x, t)∂ ∂xI(x, t)/H11005C∂ ∂t V(x, t)∂ ∂xV(x, t)/H11005L∂ ∂t I(x, t)544 APPENDIX Digital System Implementation x dx (a)CdxRdx dxLdx (b)Ldx Cdx dx (c)Figure A.33 Transmission line models: (a) semi-infinite cable, (b) lossy, (c) idealAppendix A.qxd 1/30/07 2:57 PM Page 544Using impedances inductor capacitor, rewrite relationship Figure A.34 equation form: Z0/H11005j/H9275Ldx /H11001[Z0||(1/(j/H9275Cdx))] (A.11) Rearranging, get Z2 0(j/H9275C)/H11002j/H9275L/H11001/H92752Z0LCdx /H110050 (A.12) Taking limit dxapproaches 0, last term vanishes find (A.13) A.8.8 Derivation Reflection Coefficient* reflection coefficient, kr, derived using conservation current. Figure A.35 shows transmission line characteristic impedance, Z0, load impedance, ZL. Imagine incident wave voltage Viand cur- rent Ii. wave reaches termination, current, IL, flows load impedance, causing voltage drop, VL. remainder current reflects back line wave voltage, Vr, current, Ir. Z0is ratio voltage current waves propagating along line, . voltage line sum voltages incident reflected waves. current flowing positive direction line difference currents incident reflected waves. VL/H11005Vi/H11001Vr (A.14) IL/H11005Ii/H11002Ir (A.15)Vi Ii/H11005Vr Ir/H11005Z0Z0/H11005vL CA.8 Transmission Lines 545 jωLdx dxjωCdx1Z0 V –+I V –+I (a)Z0 (b)Figure A.34 Transmission line model: (a) entire line (b) additional length, dx Figure A.35 Transmission line showing incoming, reflected, load voltages currentsZ0 ZLIi ,Vi + –ILIr ,Vr VLAppendix A.qxd 1/30/07 2:57 PM Page 545546 APPENDIX Digital System Implementation Using Ohm’s law substituting IL, Ii, Irin Equation A.15, get (A.16) Rearranging, solve reflection coefficient, kr: (A.17) A.8.9 Putting Together Transmission lines model fact signals take time propagate long wires speed light finite. ideal transmis- sion line uniform inductance, L, capacitance, C, per unit length zero resistance. transmission line characterized charac- teristic impedance, Z0, delay, td, derived inductance, capacitance, wire length. transmission line significant delay noise effects signals whose rise/fall times less 5 td. means that, systems 2 ns rise/fall times, PCB traces longer 6 cm must analyzed transmission lines accurately understand behavior. digital system consisting gate driving long wire attached input second gate modeled transmission line shown Figure A.36. voltage source, source impedance ( ZS), switch model first gate switching 0 1 time 0. driver gate cannot supply infinite current; modeled ZS. ZSis usually small logic gate, designer may choose add resistor series gate raise ZSand match impedance line. input second gate modeled ZL. CMOS circuits usually little input current, ZLmay close infinity. designer may also choose add resistor parallel second gate, gate input ground, ZLmatches impedance line.Vr Vi/H11005ZL/H11002Z0 ZL/H11001Z0/H11005krVi/H11001Vr ZL/H11005Vi Z0/H11002Vr Z0 (a)long wiredriver gatereceiver gate VS td , Z0Z –S (b)receiver gatelong wiredriver gate ZLt = 0 +Figure A.36 Digital system modeled transmission lineAppendix A.qxd 1/30/07 2:57 PM Page 546When first gate switches, wave voltage driven onto transmission line. source impedance transmission line form voltage divider, voltage incident wave (A.18) time td, wave reaches end line. Part absorbed load impedance, part reflected. reflection coefficient, kr, indicates portion reflected: kr/H11005Vr/Vi, Vris voltage reflected wave Viis voltage incident wave. (A.19) reflected wave adds voltage already line. reaches source time 2 td, part absorbed part reflected. reflections continue back forth, voltage line eventually approaches value would expected line simple equipotential wire. A.9 ECONOMICS Although digital design much fun us would free, designers companies intend make money. Therefore, economic considerations major factor design decisions. cost digital system divided nonrecurring engineering costs (NRE ), recurring costs . NRE accounts cost designing system. includes salaries design team, com- puter software costs, costs producing first working unit. fully loaded cost designer United States 2006 (including salary, health insurance, retirement plan, computer design tools) roughly $200,000 per year, design costs signifi- cant. Recurring costs cost additional unit; includes components, manufacturing, marketing, technical support, shipping. sales price must cover cost system also costs office rental, taxes, salaries staff directly contribute design (such janitor CEO). expenses, company still make profit. Example A.3 BEN TRIES MAKE MONEY Ben Bitdiddle designed crafty circuit counting raindrops. decides sell device try make money, needs help deciding implementation use. decides use either FPGA ASIC. Thekr/H11005ZL/H11002Z0 ZL/H11001Z0Vi/H11005VS Z0 Z0/H11001ZSA.9 Economics 547Appendix A.qxd 1/30/07 2:57 PM Page 547development kit design test FPGA costs $1500. FPGA costs $17. ASIC costs $600,000 mask set $4 per chip. Regardless chip implementation chooses, Ben needs mount packaged chip printed circuit board (PCB), cost $1.50 per board. thinks sell 1000 devices per month. Ben coerced team bright undergraduates designing chip senior project, doesn’t cost anything design. sales price twice cost (100% profit margin), product life 2 years, implementation better choice? SOLUTION: Ben figures total cost implementation 2 years, shown Table A.4. 2 years, Ben plans selling 24,000 devices, total cost given Table A.4 option. product life two years, FPGA option clearly superior. per-unit cost $445,500/24,000 /H11005 $18.56, sales price $37.13 per unit give 100% profit margin. ASIC option would cost $732,000/24,000 /H11005$30.50 would sold $61 per unit. Example A.4 BEN GETS GREEDY seeing marketing ads product, Ben thinks sell even chips per month originally expected. choose ASIC option, many devices per month would sell make ASIC option profitable FPGA option? SOLUTION: Ben solves minimum number units, N, would need sell 2 years: $600,000 /H11001(N/H11003$5.50) /H11005$1500 /H11001(N/H11003$18.50)548 APPENDIX Digital System Implementation Table A.4 ASIC vs FPGA costs Cost ASIC FPGA NRE $600,000 $1500 chip $4 $17 PCB $1.50 $1.50 TOTAL $600,000 /H11001(24,000 /H11003$5.50) $1500 /H11001(24,000 /H11003$18.50) /H11005$732,000 /H11005 $445,500 per unit $30.50 $18.56Appendix A.qxd 1/30/07 2:57 PM Page 548A.9 Economics 549 Solving equation gives N/H1100546,039 units, 1919 units per month. would need almost double monthly sales benefit ASIC solution. Example A.5 BEN GETS LESS GREEDY Ben realizes eyes gotten big stomach, doesn’t think sell 1000 devices per month. think prod- uct life longer 2 years. sales volume 1000 devices per month, long would product life make ASIC option worth- while? SOLUTION: Ben sells 46,039 units total, ASIC option best choice. So, Ben would need sell volume 1000 per month least 47 months (rounding up), almost 4 years. then, product likely obsolete. Chips usually purchased distributor rather directly manufacturer (unless ordering tens thousands units). Digikey ( www.digikey.com ) leading distributor sells wide variety electronics. Jameco ( www.jameco.com ) Electronics ( www.allelectronics.com ) eclectic catalogs competitively priced well suited hobbyists.Appendix A.qxd 1/30/07 2:57 PM Page 549BMIPS Instructions appendix summarizes MIPS instructions used book. Tables B.1–B.3 define opcode funct fields instruction, along short description instruction does. following nota- tions used: /L50776[reg]: contents register /L50776imm: 16-bit immediate field I-type instruction /L50776addr: 26-bit address field J-type instruction /L50776SignImm: sign-extended immediate /H11005{{16{imm[15]}}, imm} /L50776ZeroImm: zero-extended immediate /H11005{16/H11032b0, imm} /L50776Address: [rs] /H11001SignImm /L50776[Address]: contents memory location Address /L50776BTA: branch target address1 /H11005PC/H110014/H11001(SignImm /H11021/H110212) /L50776JTA: jump target address /H11005{(PC /H110014)[31:28], addr, 2 /H11032b0} 5511The SPIM simulator branch delay slot, BTA PC /H11001(SignImm /H11021/H110212). Thus, use SPIM assembler create machine code real MIPS processor, must decrement immediate field 1 compensate.Appendix B.qxd 2/1/07 9:36 PM Page 551Table B.1 Instructions, sorted opcode552 APPENDIX B MIPS Instructions Opcode Name Description Operation 000000 (0) R-type R-type instructions see Table B.2 000001 (1) bltz/bgez branch less zero/ ([rs] /H110210) PC /H11005BTA/ (rt/H110050/1) branch greater ([rs] /H110910) PC /H11005 BTA equal zero 000010 (2) j jump PC /H11005JTA 000011 (3) jal jump link $ra /H11005PC/H110014, PC /H11005JTA 000100 (4) beq branch equal ([rs] /H11005/H11005[rt]) PC /H11005BTA 000101 (5) bne branch equal ([rs]! /H11005[rt]) PC /H11005BTA 000110 (6) blez branch less equal zero ([rs] /H110880) PC /H11005BTA 000111 (7) bgtz branch greater zero ([rs] /H110220) PC /H11005BTA 001000 (8) addi add immediate [rt] /H11005[rs] /H11001SignImm 001001 (9) addiu add immediate unsigned [rt] /H11005[rs] /H11001SignImm 001010 (10) slti set less immediate [rs] /H11021SignImm ? [rt] /H110051 : [rt] /H110050 001011 (11) sltiu set less immediate unsigned [rs] /H11021SignImm ? [rt] /H110051 : [rt] /H110050 001100 (12) andi immediate [rt] /H11005[rs] & ZeroImm 001101 (13) ori immediate [rt] /H11005[rs] | ZeroImm 001110 (14) xori xor immediate [rt] /H11005[rs] /H11625ZeroImm 001111 (15) lui load upper immediate [rt] /H11005{Imm, 16 /H11032b0} 010000 (16) mfc0, move from/to coprocessor 0 [rt] /H11005[rd]/[rd] /H11005[rt] (rs/H110050/4) mtc0 (rd coprocessor 0) 010001 (17) F-type fop /H1100516/17: F-type instructions see Table B.3 010001 (17) bc1f/bc1t fop /H110058: branch fpcond (fpcond /H11005/H110050) PC /H11005BTA/ (rt/H110050/1) FALSE/TRUE (fpcond /H11005/H110051) PC /H11005BTA 100000 (32) lb load byte [rt] /H11005SignExt([Address] 7:0) 100001 (33) lh load halfword [rt] /H11005SignExt([Address] 15:0) 100011 (35) lw load word [rt] /H11005[Address] 100100 (36) lbu load byte unsigned [rt] /H11005ZeroExt([Address] 7:0) 100101 (37) lhu load halfword unsigned [rt] /H11005ZeroExt([Address] 15:0) 101000 (40) sb store byte [Address] 7:0/H11005[rt]7:0 (continued )Appendix B.qxd 2/1/07 9:36 PM Page 552Table B.1 Instructions, sorted opcode —Cont’d Table B.2 R-type instructions, sorted funct fieldAppendix B 553 Funct Name Description Operation 000000 (0) sll shift left logical [rd] /H11005[rt] /H11021/H11021shamt 000010 (2) srl shift right logical [rd] /H11005[rt] /H11022/H11022shamt 000011 (3) sra shift right arithmetic [rd] /H11005[rt] /H11022/H11022/H11022shamt 000100 (4) sllv shift left logical [rd] /H11005[rt] /H11021/H11021[rs]4:0 variable assembly: sllv rd, rt, rs 000110 (6) srlv shift right logical [rd] /H11005[rt] /H11022/H11022[rs]4:0 variable assembly: srlv rd, rt, rs 000111 (7) srav shift right arithmetic [rd] /H11005[rt] /H11022/H11022/H11022[rs]4:0 variable assembly: srav rd, rt, rs 001000 (8) jr jump register PC/H11005[rs] 001001 (9) jalr jump link register $ra /H11005PC/H110014, PC /H11005[rs] 001100 (12) syscall system call system call exception 001101 (13) break break break exception 010000 (16) mfhi move hi [rd] /H11005[hi] 010001 (17) mthi move hi [hi] /H11005[rs] 010010 (18) mflo move lo [rd] /H11005[lo] 010011 (19) mtlo move lo [lo] /H11005[rs] 011000 (24) mult multiply {[hi], [lo]} /H11005[rs] /H11003[rt] 011001 (25) multu multiply unsigned {[hi], [lo]} /H11005[rs] /H11003[rt] 011010 (26) div divide [lo] /H11005[rs]/[rt], [hi] /H11005[rs]%[rt]101001 (41) sh store halfword [Address] 15:0 /H11005[rt]15:0 101011 (43) sw store word [Address] /H11005[rt] 110001 (49) lwc1 load word FP coprocessor 1 [ft] /H11005[Address] 111001 (56) swc1 store word FP coprocessor 1 [Address] /H11005[ft] (continued )Opcode Name Description OperationAppendix B.qxd 2/1/07 9:36 PM Page 553554 APPENDIX B MIPS Instructions Table B.2 R-type instructions, sorted funct field —Cont’d Table B.3 F-type instructions ( fop /H1154916/17)Funct Name Description Operation 011011 (27) divu divide unsigned [lo] /H11005[rs]/[rt], [hi] /H11005[rs]%[rt] 100000 (32) add add [rd] /H11005[rs] /H11001[rt] 100001 (33) addu add unsigned [rd] /H11005[rs] /H11001[rt] 100010 (34) sub subtract [rd] /H11005[rs] /H11002[rt] 100011 (35) subu subtract unsigned [rd] /H11005[rs] /H11002[rt] 100100 (36) [rd] /H11005[rs] & [rt] 100101 (37) [rd] /H11005[rs] | [rt] 100110 (38) xor xor [rd] /H11005[rs] /H11625[rt] 100111 (39) [rd] /H11005~([rs] | [rt]) 101010 (42) slt set less [rs] /H11021[rt] ? [rd] /H110051 : [rd] /H110050 101011 (43) sltu set less unsigned [rs] /H11021[rt] ? [rd] /H110051 : [rd] /H110050 Funct Name Description Operation 000000 (0) add.s/add.d FP add [fd] /H11005[fs] /H11001[ft] 000001 (1) sub.s/sub.d FP subtract [fd] /H11005[fs] /H11002[ft] 000010 (2) mul.s/mul.d FP multiply [fd] /H11005[fs] * [ft] 000011 (3) div.s/div.d FP divide [fd] /H11005[fs]/[ft] 000101 (5) abs.s/abs.d FP absolute value [fd] /H11005([fs] /H110210) ? [ /H11002fs] : [fs] 000111 (7) neg.s/neg.d FP negation [fd] /H11005[/H11002fs] 111010 (58) c.seq.s/c.seq.d FP equality comparison fpcond /H11005([fs] /H11005/H11005[ft]) 111100 (60) c.lt.s/c.lt.d FP less comparison fpcond /H11005([fs] /H11021[ft]) 111110 (62) c.le.s/c.le.d FP less equal comparison fpcond /H11005([fs] /H11088[ft])Appendix B.qxd 2/1/07 9:36 PM Page 554555Further Reading Berlin L., Man Behind Microchip: Robert Noyce Invention Silicon Valley , Oxford University Press, 2005. fascinating biography Robert Noyce, inventor microchip founder Fairchild Intel. anyone thinking working Silicon Valley, book gives insights culture region, cul- ture influenced heavily Noyce individual. Colwell R., Pentium Chronicles: People, Passion, Politics Behind Intel’s Landmark Chips , Wiley, 2005. insider’s tale development several generations Intel’s Pentium chips, told one leaders project. con- sidering career field, book offers views managment huge design projects behind-the-scenes look one significant commercial microprocessor lines. Ercegovac M., Lang T., Digital Arithmetic , Morgan Kaufmann, 2003. complete text computer arithmetic systems. excellent resource building high-quality arithmetic units computers. Hennessy J., Patterson D., Computer Architecture: Quantitative Approach, 4th ed. , Morgan Kaufmann, 2006. authoritative text advanced computer architecture. intrigued inner workings cutting-edge microprocessors, book you. Kidder T., Soul New Machine , Back Bay Books, 1981. classic story design computer system. Three decades later, story still page-turner insights project managment technology still ring true. Pedroni V., Circuit Design VHDL , MIT Press, 2004. reference showing design circuits VHDL. Thomas D., Moorby P., Verilog Hardware Description Language, 5th ed. , Kluwer Academic Publishers, 2002. Ciletti M., Advanced Digital Design Verilog HDL , Prentice Hall, 2003. excellent references covering Verilog detail. 555Further Reading.qxd 1/27/07 12:29 PM Page 555556 Reading Verilog IEEE Standard (IEEE STD 1364). IEEE standard Verilog Hardware Description Language; last updated 2001. Available ieeexplore.ieee.org . VHDL IEEE Standard (IEEE STD 1076). IEEE standard VHDL; last updated 2004. Available IEEE. Available ieeexplore.ieee.org . Wakerly J., Digital Design: Principles Practices, 4th ed. , Prentice Hall, 2006. comprehensive readable text digital design, excellent ref- erence book. Weste N., Harris D., CMOS VLSI Design, 3rd ed. , Addison-Wesley, 2005. Large Scale Integration (VLSI) Design art science building chips containing oodles transistors. book, coauthored one favorite writers, spans field beginning advanced techniques used commercial products.Further Reading.qxd 1/27/07 12:29 PM Page 556557Index 0, 23. See also LOW, 1, 23. See also HIGH, 74xx series logic, 515–516 parts, 2:1 Mux (74157), 518 3:8 Decoder (74138), 518 4:1 Mux (74153), 518 (7408), 517 AND3 (7411), 517 AND4 (7421), 517 Counter (74161, 74163), 518 FLOP (7474), 515–517 NAND (7400), 517 (7402), 517 (7404), 515 (7432), 517 XOR (7486), 517 Register (74377), 518 Tristate buffer (74244), 518 schematics of, 517–518 add, 291 Adders, 233–240 carry-lookahead. SeeCarry- lookahead adder carry-propagate (CPA). SeeCarry- propagate adder prefix. SeePrefix adder ripple-carry. SeeRipple-carry adder add immediate ( addi ), 327, 378 add immediate unsigned ( addiu ), 552 add unsigned ( addu ), 554 Addition, 14–15, 233–240, 291floating-point, 252–255 overflow. SeeOverflow two’s complement, 15, 240 underflow. SeeUnderflow unsigned binary, 15 Address, 485–490 physical, 485 translation, 486–489 virtual, 485–490 word alignment, 298 Addressing modes, 327–329 base, 327 immediate, 327 MIPS, 327–329 PC-relative, 327–328 pseudo-direct, 328–329 register-only, 327 Advanced microarchitecture, 435–447 branch prediction. SeeBranch prediction deep pipelines. SeeDeep pipelines multiprocessors. SeeMultiprocessors multithreading. SeeMultithreading out-of-order processor. SeeOut-of-order processor register renaming. SeeRegister renaming single instruction multiple data. See Single instruction multiple data (SIMD) units superscalar processor. See Superscalar processor vector processor. SeeSingle instruc- tion multiple data (SIMD) units Alignment. SeeWord alignment ALU. SeeArithmetic/logical unitALU decoder, 374–376 ALU decoder truth table, 376 ALUControl, 370 ALUOp, 374–375 ALUOut, 383–385 ALUResult, 370–371 AMAT. SeeAverage memory access time Amdahl, Gene, 468 Amdahl’s Law, 468 Anodes, 27–28 immediate ( andi ), 306, 346–347 gate, 20–22, 32–33 Application-specific integrated circuits (ASICs), 523 Architectural state, 363–364 Architecture. SeeInstruction Set Architecture Arithmetic, 233–249, 305–308, 515. See also Adders, Addition, Comparator, Divider, Multiplier adders. SeeAdders addition. SeeAddition ALU. SeeArithmetic/logical unit circuits, 233–248 comparators. SeeComparators divider. SeeDivider division. SeeDivision fixed-point, 249 floating-point, 252–255 logical instructions, 305–308 multiplier. SeeMultiplier packed, 445 rotators. SeeRotators shifters. SeeShifters signed unsigned, 338–339 subtraction. SeeSubtraction 557Index.qxd 1/30/07 3:14 PM Page 557Arithmetic ( Continued ) subtractor. SeeSubtractor underflow. SeeAddition, Underflow Arithmetic/logical unit (ALU), 242–244, 515 32-bit, 244 adder. SeeAdders ALUOp, 374–376 ALUResult, 370–371 ALUOut, 383–385 comparator. SeeComparators control, 242 subtractor. SeeSubtractor Arrays, 314–318 accessing, 315–317 bytes characters, 316–318 FPGA, SeeField programmable gate array logic. SeeLogic arrays memory. SeeMemory RAM, 265 ROM, 266 ASCII (American Standard Code Information Interchange) codes, 317 table of, 317 Assembler directives, 333 ASICs. SeeApplication-specific inte- grated circuits Assembly language, MIPS. SeeMIPS assembly language Associativity, 58–59 Average memory access time (AMAT), 467–468 Asynchronous circuits, 116–117 Asynchronous inputs, 144 Asynchronous resettable registers HDL for, 192 Axioms. SeeBoolean axioms B Babbage, Charles, 7–8, 26 Base address, 295–296 Base register, 302, 343, 347 Base 2 number representations. SeeBinary numbers Base 8 number representations. SeeOctal numbersBase 16 number representations. SeeHexadecimal numbers Block, digital building. SeeDigital building blocks code, else block, 311 block, 310–311 Base addressing, 327 Baudot, Jean-Maurice-Emile, 317 Behavioral modeling, 171–185 Benchmarks, 367 SPEC2000, 398–399 Biased numbers, 41. See also Floating point Big-Endian, 172, 296–297 Binary numbers, 9–11. See also Arithmetic ASCII, 317 binary coded decimal, 252 conversion. SeeNumber conversion fixed point, 249–250 floating-point. SeeFloating-point numbers signed, 15–19 sign/magnitude. SeeSign/ magnitude numbers two’s complement. SeeTwo’s complement numbers unsigned, 9–15 Binary decimal conversion, 10–11 Binary hexadecimal conversion, 12 Bit, 9–11 dirty, 482–483 least significant, 13–14 significant, 13–14 sign, 16 use, 478–479 valid, 472 Bit cells, 258 Bit swizzling, 182 Bitwise operators, 171–174 Boole, George, 8 Boolean algebra, 56–62 axioms, 57 equation simplification, 61–62 theorems, 57–60 Boolean axioms, 57 Boolean equations, 54–56 product-of-sums (POS) canonical form, 56sum-of-products (SOP) canonical form, 54–55 terminology, 54 Boolean theorems, 57–60 DeMorgan’s , 59 complement , 58, 59 consensus , 60 covering , 58 combining , 58 Branching, 308–310 calculating address, 309 conditional, 308 prediction, 437–438 target address (BTA), 327–328 unconditional (jump), 309 Branch equal ( beq), 308–309 Branch equal ( bne), 308–309 Branch/control hazards, 407, 413–416. See also Hazards Branch prediction, 437–438 Breadboards, 532–533 Bubble, 59 pushing, 67–69 Buffer, 20 tristate, 70–71 “Bugs,” 169 Bus, 52 tristate, 71 Bypassing, 408 Bytes, 13–14 Byte-addressable memory, 295–297 Byte order, 296–297 Big-Endian, 296–297 Little-Endian, 296–297 C C programming language, 290 overflows, 339 strings, 318 Caches, 468–484. See also Memory accessing, 472–473, 476–477, 479 advanced design, 479–483 associativity, 469, 474–475, 478–479 block size, 476–477 blocks, 469–470, 476 capacity, 468–470 data placement, 469–470 data replacement, 478–479558 IndexIndex.qxd 1/30/07 3:14 PM Page 558definition, 468 direct mapped, 470–474 dirty bit, 482–483 entry fields, 472–473 evolution MIPS, 483 fully associative, 475–476 hit, 466 hit rate, 467 IA-32 systems, 499–500 level 2 (L2), 480 mapping, 470–478 miss, 466 capacity, 481 compulsory, 481 conflict, 481 miss rate, 467 miss rate versus cache parameters, 481–482 miss penalty, 476 multiway set associative, 474–475 nonblocking, 500 organizations, 478 performance, 467 set associative, 470, 474–475 tag, 471–472 use bit, 478–479 valid bit, 472–473 write policy, 482–483 CAD. SeeComputer-aided design Canonical form, 53 Capacitors, 28 Capacity miss, 481 Carry-lookahead adder, 235–237 Carry propagate adder (CPA), 274 Cathodes, 27–28 Cause register, 337–338 Chips, 28, 449 74xx series logic. See74xx series logic Circuits, 82–83, 87–88 74xx series logic. See74xx series logic application-specific integrated (ASIC), 523 arithmetic. SeeArithmetic asynchronous, 116–117 bistable device, 147 combinational, 53 definition, 51 delays, 73–75, 84–87 calculating, 86–87 dynamic, 273 multiple-output, 64pipelining, 152 priority, 65, 202, 203 synchronous sequential, 114–116 synthesized, 186–190, 193–195, 199, 200 timing, 84–91 timing analysis, 138 types, 51–54 without glitch, 91 CISC. SeeComplex instruction set computers CLBs. SeeConfigurable logic blocks Clock cycle. SeeClock period Clock period, 135–139 Clock rate. SeeClock period Clock cycles per instruction (CPI), 367–368 Clustered computers, 447 Clock skew, 140–143 CMOS. SeeComplementary Metal- Oxide-Semiconductor Logic Code, 303 Code size, 334 Combinational composition, 52–53 Combinational logic design, 51–100 Boolean algebra, 56–62 Boolean equations, 54–56 building blocks, 79–84 delays, 85–87 don’t cares, 65 HDLs and. SeeHardware descrip- tion languages Karnaugh maps, 71–79 logic, 62–65 multilevel, 65–69 overview, 51–54 precedence, 54 timing, 84–91 two-level, 65–66 X’s (contention). SeeContention X’s (don’t cares). SeeDon’t cares Z’s (floating). SeeFloating Comparators, 240–241 equality, 241 magnitude, 241, 242 Compiler, 331–333 Complementary Metal-Oxide- Semiconductor Logic (CMOS), 25 bubble pushing, 69 logic gates, 31–33 NAND gate, 32 gate, 32–33 gate, 31transistors, 26–34 Complex instruction set computers (CISC), 292, 341 Compulsory miss, 481 Computer-aided design (CAD), 167 Computer Organization Design (Patterson Hennessy), 290, 363 Complexity management, 4–6 abstraction, 4–5 discipline, 5–6 hierarchy, 6 modularity, 6 regularity, 6 Conditional assignment, 175–176 Conditional branches, 308 Condition codes, 344 Conflict misses, 481 Conditional statements, 310–311 Constants, 298. See also Immediates Contamination delay, 84–88 Contention (X), 69–70 Context switch, 446 Control signals, 79, 242–243 Control unit, 364, 366, 374–406 multicycle MIPS processor FSM, 381–395 pipelined MIPS processor, 405–406 single-cycle MIPS processor, 374–377 Configurable logic blocks (CLBs), 268–272 Control hazards. SeeBranch/control hazards, Pipelining Coprocessor 0, 338 Counters, 254 Covalent bond, 27 CPA. SeeCarry propagate adder CPI. SeeClock cycles per instruction Critical path, 85–89 Cyclic paths, 114 Cycle time. SeeClock Period Data hazards. SeeHazards Data memory, 365 Data sheets, 523–528 Datapath, 364. See also MIPS micro- processorsIndex 559Index.qxd 1/30/07 3:14 PM Page 559Datapath ( Continued ) elements, 364 multicycle MIPS processor, 382–388 pipelined MIPS processor, 404 single-cycle MIPS processor, 368–374 Data segments. SeeMemory map Data types. SeeHardware description languages DC. SeeDirect current Decimal numbers, 9 conversion binary hexadeci- mal. SeeNumber conversion scientific notation, 249–250 Decimal Binary conversion, 11 Decimal hexadecimal conversion, 13 Decoders implementation, 83 logic, 83 parameterized, 212 Deep pipelines, 435–436 Delay, 182 DeMorgan, Augustus, 56 DeMorgan’s theorem, 59, 60 Dennard, Robert, 260 Destination register, 301, 305–306, 370–371, 377–378 Device test (DUT), 214–218. See also Unit test Device driver, 496, 498 Dice, 28 Digital abstraction, 4–5, 8–9, 22–26 DC transfer characteristics, 23–24 logic levels, 22–23 noise margins, 23 supply voltage, 22 Digital design abstraction, 7–9 discipline, 5–6 hierarchy, 6 modularity, 6 regularity, 6 Digital system implementation, 515–548 74xx series logic. See74xx series logic application-specific integrated circuits (ASICs), 523 data sheets, 523–528 economics, 546–548 logic families, 529–531 overview, 515 packaging assembly, 531–534breadboards, 532 packages, 531–532 printed circuit boards, 533–534 programmable logic, 516–523 transmission lines. SeeTransmission lines Diodes, 27–28 DIP. SeeDual-inline package Direct current (DC), 23, 24 transfer characteristics, 23–24, 25 Direct mapped cache, 470–474 Dirty bit, 482–483 Discipline, 5–6 Disk. SeeHard disk divide (div), 308 divide unsigned ( divu ), 339 Divider, 247–248 Division, 247–248 floating-point, 253 instructions, 308 Divisor, 247 Don’t care (X), 65 Dopant atoms, 27 Double. SeeDouble-precision floating- point numbers Double-precision floating point num- bers, 251–252 DRAM. SeeDynamic random access memory Driver. SeeDevice driver Dual-inline package (DIP), 28, 531 DUT. SeeDevice test Dynamic discipline, 134 Dynamic data segment, 331 Dynamic random access memory (DRAM), 257, 260, 463 E Edison, Thomas, 169 Edge-triggered digital systems, 108, 112 Equations simplification, 61–62 Electrically erasable programmable read memory (EEPROM), 263 Enabled registers, 193 HDL for, 193 EPC. SeeException Program Counter registerErasable programmable read memory (EPROM), 263 Exceptions, 337–339 Exception handler, 337–338 Exception program counter (EPC), 337–338 Exclusive or. SeeXOR Executable file, 334 Execution time, 367 Exponent, 250–253 F Failures, 144–146 FDIV bug, 253 FET. SeeField effect transistors Field programmable gate array (FPGA), 268–272, 521–523 Field effect transistors, 26 FIFO. SeeFirst-in-first-out queue. See alsoQueue Finite state machines (FSMs), 117–133 design example, 117–123 divide-by-3, 207–208 factoring, 129–132 HDLs and, 206–213 Mealy machines. SeeMealy machines Moore machines. SeeMoore machines Moore versus Mealy machines, 126–129 state encodings, 123–126 state transition diagram, 118–119 First-in-first-out (FIFO) queue, 508 Fixed-point numbers, 249–250 Flash memory, 263–264 Flip-flops, 103–112, 257. See also Registers comparison latches, 106, 112 D, 108 enabled, 109–110 register, 108–109 resettable, 110, 427 asynchronous, 192 synchronous, 192 transistor count, 108 transistor-level, 110–111 Floating (Z), 69–71 Floating-point numbers, 250–253560 IndexIndex.qxd 1/30/07 3:14 PM Page 560addition, 252–255. See also Addition converting binary decimal to. See Number conversions division, 253. See also Division double-precision, 251–252 FDIV bug. SeeFDIV bug floating-point unit (FPU), 253 instructions, 340–341 rounding, 252 single-precision, 251–252 special cases infinity, 251 number (NaN), 251 Forwarding, 408–409 Fractional numbers, 274 FPGA. SeeField programmable gate array Frequency, 135. See also Clock period FSM. SeeFinite state machines Full adder, 52, 178. See also Adder, Addition HDL using always/process, 197 using nonblocking assignments, 204 Fully associative cache, 475–476 Funct field, 299–300 Functional specification, 51 Functions. SeeProcedure calls Fuse, 263 G Gates, 19–22 AND, 20–22, 32–33 NAND, 21, 32 NOR, 21, 32–33 OR, 21 transistor-level implementation, 262 XOR, 21 XNOR, 21 Gedanken-Experiments Sequential Machines (Moore), 111 Generate signal, 235, 237 Glitches, 75, 88–91 Global pointer ( $gp), 294, 331. See alsoStatic data segment Gray, Frank, 65 Gray codes, 65, 72 Gulliver’s Travels (Swift), 297H Half word, 339 Half adder, 233–234 Hard disk, 484 Hard drive. SeeHard disk Hardware reduction, 66–67 Hardware description languages (HDLs), 167–230 assignment statements, 177 behavioral modeling, 171–184 combinational logic, 171–185, 195–206 bit swizzling, 182 bitwise operators, 171–174 blocking nonblocking assignments, 201–206 case statements, 198–199 conditional assignment, 175–176 delays, 182–183 statements, 199–201 internal variables, 176–178 numbers, 179 precedence, 178–179 reduction operators, 174 synthesis tools. SeeSynthesis Tools Verilog, 201 VHDL libraries types, 183–185 Z’s X’s, 179–182 finite state machines, 206–213 generate statement, 213 generic building blocks, 426 invalid logic level, 181 language origins, 168–169 modules, 167–168 origins of, 168–169 overview, 167 parameterized modules, 211–213 representation, 421–431 sequential logic, 190–195, 205 enabled registers, 193 latches, 195 multiple registers, 194–195 registers, 190–191. See also Registers resettable registers, 191–193 simulation synthesis, 169–171 single-cycle processor, 422 structural modeling, 185–189 testbenches, 214–218, 428–431Hazards, 75, 406–418. See also Glitches control hazards, 413–416 data hazards 408–413 solving, 408–416 forwarding, 408–410 stalls, 410–413 WAR. SeeWrite read WAW. SeeWrite write Hazard unit, 408, 411, 419 Heap, 331 HDLs. SeeHardware description languages Hennessy, John, 290, 364 Hexadecimal numbers, 11–13 binary conversion table, 12 Hierarchy, 6, 189 HIGH, 23. See also 1, High-level programming languages, 290–294 translating assembly, 290–291 compiling, linking, launching, 330–331 Hit, 466 High impedance. SeeFloating, Z High Z. SeeFloating, High impedance, Z Hold time, 133–154 I-type instruction, 301–302 IA-32 microprocessor, 290, 341–349, 447–453 branch conditions, 346 cache systems, 499–500 encoding, 346–348 evolution, 448, 500 instructions, 344, 345 memory input/output (I/O) systems, 499–502 operands, 342–344 programmed I/O, 502 registers, 342 status flags, 344 virtual memory, 501 IEEE 754 floating-point standard, 251 Idempotency, 58 Idioms, 171 IEEE, 169Index 561Index.qxd 1/30/07 3:14 PM Page 561If statements, 199–201, 310 If/else statements, 311 ILP. SeeInstruction-level parallelism Immediates, 298 Immediate addressing, 327 Information, amount of, 8 IorD, 385 I/O (input/output), 337, 494–502 communicating with, 494–495 device driver, 496, 498 devices, 494–496. See also Peripheral devices memory interface, 494, 502 memory-mapped I/O, 494–499 Inputs, asynchronous, 144–145 Instruction encoding. SeeMachine Language Instruction register (IR), 383, 390 Instruction set architecture (ISA), 289–361. See also MIPS instruc- tion set architecture Input/output blocks (IOBs), 268 Input terminals, 51 Institute Electrical Electronics Engineers, 250 Instruction decode, 401–402 Instruction encoding. SeeInstruction format Instruction format F-type, 340 I-type, 301–302 J-type, 302 R-type, 299–300 Instruction-level parallelism (ILP), 443, 446 Instruction memory, 365 Instruction set. SeeInstruction set architecture Instructions. See also Language arithmetic/logical, 304–308 floating-point, 340–341 IA-32, 344–346 I-type, 301–302 J-type, 302 loads. SeeLoads multiplication division, 308 pseudoinstructions, 336–337 R-type, 299–300 set less than, 339 shift, 306–307 signed unsigned, 338–339 Intel, 30, 111, 290, 348, 367 Inverter. SeeNOT gateIntegrated circuits (ICs), 26, 137, 515, 532 costs, 137, 169 manufacturing process, 515 Intel. SeeIA-32 microprocessors Interrupts. SeeExceptions Investigation Laws Thought (Boole), 8 Involution, 58 IOBs. SeeInput/output blocks I-type instructions, 301–302 J Java, 316. See also Language JTA. SeeJump target address J-type instructions, 302 Jump, 309–310. See also Branch, unconditional, Programming Jump target address (JTA), 329 K K-maps. SeeKarnaugh maps Karnaugh, Maurice, 64, 71 Karnaugh maps (K-maps), 71–79 logic minimization using, 73–76 prime implicants, 61, 74 seven-segment display decoder, 75–77 “don’t cares,” 78 without glitches, 91 Kilby, Jack, 26 Kilobyte, 14 K-maps. SeeKarnaugh maps L Labels, 308–309 Language. See also Instructions assembly, 290–299 high-level, 290–294 machine, 299–304 mnemonic, 291 translating assembly machine, 300Last-in-first-out (LIFO) queue, 321. See alsoStack, Queue Latches, 103–112 comparison flip-flops, 106, 112 D, 107 SR, 105–107 transistor-level, 110–111 Latency, 149 Lattice, 27 Leaf procedures, 324–325 Least recently used (LRU) replacement, 478–479 Least significant bit (lsb), 13 Least significant byte (LSB), 296 LIFO. SeeLast-in-first-out queue Literal, 54, 61, 167 Little-Endian, 296–297 Load, 255 byte (lb), 317 byte unsigned ( lbu), 317 half (lh), 339 immediate ( li), 336 upper immediate ( lui), 308 word (lw), 295–296 Loading, 335 Locality, 464 Local variables, 326–327 Logic, 62–65. See also Multilevel com- binational logic; Sequential logic design bubble pushing. SeeBubble pushing combinational. SeeCombinational logic families, 529–531 gates. SeeLogic gates hardware reduction. SeeHardware reduction, Equation simplifi- cation multilevel. SeeMultilevel combina- tional logic programmable, 516–523 sequential. SeeSequential logic synthesis, 170–171 two-level, 65–66 using memory arrays, 264. See also Logic arrays Logic arrays, 266–274 field programmable gate array, 268–272 programmable logic array, 266–268 transistor-level implementations, 273–274 Logic families, 25, 529–531562 IndexIndex.qxd 1/30/07 3:14 PM Page 562compatibility, 26 specifications, 529, 531 Logic gates, 19–22, 173 buffer, 20 delays, 183 multiple-input gates, 21–22 two-input gates, 21 types AND. SeeAND gate AOI (and-or-invert). SeeAnd-or-invert gate NAND. SeeNAND gate NOR. SeeNOR gate NOT. SeeNOT gate OAI (or-and-invert). SeeOr-and-invert gate OR. SeeOR gate XOR. SeeXOR gate XNOR. SeeXNOR gate Logic levels, 22–23 Logical operations, 304–308 Lookup tables (LUTs), 268 Loops, 311–314 for, 313 while, 312–313 LOW, 23. See also 0, Low Voltage CMOS Logic (LVCMOS), 25 Low Voltage TTL Logic (LVTTL), 25 LRU. SeeLeast recently used replacement LSB. SeeLeast significant byte LUTs. SeeLookup tables LVCMOS. SeeLow Voltage CMOS Logic LVTTL. SeeLow Voltage TTL Logic Machine language, 299–304 function fields, 299 interpreting code, 302–303 I-type instructions, 301–302 J-type instructions, 302 opcodes, 299–303 R-type instructions, 299–300 stored programs, 303–304 translating assembly language, 300–302 translating assembly language, 303Main decoder, 374–379 Main memory, 466–469 Mapping, 470 Mantissa, 250, 252–253. See also Floating-point numbers Masuoka, Fujio, 263 MCM. SeeMultichip module Mealy, George H., 111 Mealy machines, 126–129, 130, 210 combined state transition output table, 127 state transition diagram, 118–119 timing diagram, 131 Mean time failures (MTBF), 146 Memory, 51, 295–298 access, 298 average memory access time (AMAT), 467 cache. SeeCaches DRAM. SeeDynamic random access memory hierarchy, 466 interface, 464 main, 466–469 map, 330–331 dynamic data segment, 331 global data segment, 330–331 reserved segment, 331 text segment, 330 nonvolatile, 259–260 performance, 465 physical, 466, 485–486 protection, 491. See also Virtual memory RAM, 259 ROM, 259 separate data instruction, 430–431 shared, 71 stack. SeeStack types flip-flops, 105–112 latches, 105–112 DRAM, 257 registers, 108–109 register file, 261–262 SRAM, 257 virtual, 466. See also Virtual memory volatile, 259–261 word-addressable, 29. SeeWord- addressable memoryMemory arrays, 257–266 area, 261 bit cells, 258 delay, 261 DRAM. SeeDynamic random access memory HDL code for, 264–266 logic implementation using, 264. See also Logic arrays organization, 258 overview, 257–260 ports, 259 register files built using, 261–262 types, 259–260 DRAM. SeeDynamic random access memory ROM. SeeRead memory SRAM. SeeStatic random access memory Memory-mapped I/O (input/output), 494–498 address decoder, 495–496 communicating I/O devices, 495–496 hardware, 495 speech synthesizer device driver, 498 speech synthesizer hardware, 496–497 SP0256, 496 Memory protection, 491 Memory systems, 463–512 caches. SeeCaches IA-32, 499–502 MIPS, 470–478 overview, 463–467 performance analysis, 467–468 virtual memory. SeeVirtual memory Mercedes Benz, 268 Metal-oxide-semiconductor field effect transistors (MOSFETs), 26–31. See also CMOS, nMOS, pMOS, transistors Metastability, 143–144 MTBF. SeeMean time failures metastable state, 143 probability failure, 145 resolution time, 144 synchronizers, 144–146 Method Synthesizing Sequential Circuits (Mealy), 111Index 563Index.qxd 1/30/07 3:14 PM Page 563Microarchitecture, 290, 363–461 advanced. SeeAdvanced microarchitecture architectural state. SeeArchitectural State. See also Architecture design process, 364–366 exception handling, 431–434 HDL representation, 421–431. IA-32. SeeIA-32 microprocessor instruction set. SeeInstruction set MIPS. SeeMIPS microprocessor overview, 363–366 performance analysis, 366–368 types, advanced. SeeAdvanced microarchitecture multicycle. SeeMulticycle MIPS processor pipelined. SeePipelined MIPS processor single-cycle. SeeSingle-cycle MIPS processor Microprocessors, 3, 13 advanced. SeeAdvanced microarchitecture chips. SeeChips clock frequencies, 124 IA-32. SeeIA-32 microprocessor instructions. SeeMIPS instructions, IA-32 instructions MIPS. SeeMIPS microprocessor Microsoft Windows, 501 Minterms, 54 Maxterms, 54 MIPS (Millions instructions per second). SeeMillions instructions per second MIPS architecture. SeeMIPS instruction set architecture (ISA) MIPS assembly language. See also MIPS instruction set architecture addressing modes, 327–329 assembler directives, 333 instructions, 290–292 logical instructions, 304–308 mnemonic, 291 operands, 292–298 procedure calls, 319–327 table instructions, 336 translating machine language to, 303 translating machine language, 300 MIPS instruction set architecture (ISA)addressing modes, 327–329 assembly language, 290–299 compiling, assembling, loading, 330–335 exceptions, 337–338 floating-point instructions, 340–341 IA-32 instructions, 344–346 machine language, 299–304 MIPS instructions, 290–292 overview, 289–290 programming, 304–327 pseudoinstructions, 336–337 signed unsigned instructions, 338–339 SPARC, 364 translating starting program. SeeTranslating starting program MIPS instructions, 551–554 formats F-type, 340 I-type, 301–302 J-type, 302 R-type, 299–300 tables of, 552–554 opcodes, 552 R-type funct fields, 553–554 types, arithmetic, 304–308 branching. SeeBranching division, 308 floating-point, 340–341 logical, 304–308 multiplication, 308 pseudoinstructions, 336–337 MIPS microprocessor, 364 ALU, 242–244 multicycle. SeeMulticycle MIPS processor pipelined. SeePipelined MIPS processor single-cycle. SeeSingle-cycle MIPS processor MIPS processor. SeeMIPS micro- processor MIPS registers, 293–294, 308 nonpreserved, 322–324 preserved, 322–324 table of, 294 MIPS single-cycle HDL implemen- tation, 421–431 building blocks, 426–428 controller, 423 datapath, 425testbench, 429 top-level module, 430 Misses, 466, 481 AMAT. SeeAverage memory access time cache, 466 capacity, 481 compulsory, 481 conflict, 481 page fault, 485 Miss penalty, 476 Miss rate, 467 Mnemonic, 291 Modeling, structural. SeeStructural modeling Modeling, behavioral. SeeBehavioral modeling Modularity, 6, 168 Modules, HDL 167–168. See also Hardware description languages behavioral, 168, 171 parameterized, 211–213 structural, 168 Moore, Edward F., 111 Moore, Gordon, 30 Moore machine, 126–129, 130, 208, 209 output table, 128 state transition diagram, 127 state transition table, 128 timing diagram, 131 Moore’s law, 30 MOSFETs. SeeMetal-oxide-semicon- ductor field effect transistors significant bit (msb), 13 significant byte (MSB), 296 Move hi ( mfhi ), 308 Move lo ( mflo ), 308 Move coprocessor 0 ( mfc0 ), 338 msb. SeeMost significant bit MSB. SeeMost significant byte MTBF. SeeMean time failure Multichip module (MCM), 499 Multicycle MIPS processor, 366, 381–400 control, 388–394 control FSM, 394–395 datapath, 382–388 performance analysis, 397–400 Multilevel combinational logic, 65–69. See also Logic Multilevel page table, 493 Multiplexers, 79–82, 175, 176, 428564 IndexIndex.qxd 1/30/07 3:14 PM Page 564instance, 188 logic, 80–82 parameterized, 211. See also Hardware description languages symbol truth table, 79 timing, 87–88 type conversion, 185 wide, 80 Multiplicand, 246 Multiplication, 246–247. See also Arithmetic, Multiplier architecture, 339 instructions, 308 Multiplier, 246–247 multiply ( mult ), 308, 339 multiply unsigned ( multu ), 339 Multiprocessors, 447 chip, 448 Multithreading, 446 Mux. SeeMultiplexers N NaN. SeeNot number Negation, 340. See also Taking two’s complement number (NaN), 251 NAND gate, 21, 32 nor, 179 gate, 21, 32–33 gate, 24, 172. See also Inverter HDL using always/process, 196 Nested procedure calls, 324–326 Netlist, 170 Next state, 115 Nibbles, 13–14 nMOS, 28–31 nMOS transistors, 28–31 operation. Seenop Noise margins, 23, 24 nop, 336 Noyce, Robert, 26 Number conversion, 9–19 See also Number systems, Binary numbers binary decimal, 10–11 binary hexadecimal, 12 decimal binary, 11 decimal hexadecimal, 13 taking two’s complement, 15, 240 Number systems, 9–19, 249–253addition. SeeAddition binary numbers. SeeBinary numbers comparison of, 18–19 conversion of. SeeNumber conversions decimal numbers. SeeDecimal numbers estimating powers two, 14 fixed-point, 249–250. SeeFixed- point numbers floating-point, 250–253. See Floating-point numbers hardware description languages, 179 hexadecimal numbers. See Hexadecimal numbers negative positive, 15–19 rounding, 252. See also Floating- point numbers sign bit, 16 signed, 15–19. See also Signed binary numbers sign/magnitude numbers. See Sign/magnitude numbers two’s complement numbers. See Two’s complement numbers unsigned, OAI gate. SeeOr-and-invert gate Object files, 331–334 Octal numbers, 180 OFF, 23. See also 0, LOW Offset, 295–296 ON, 23. See also 1, HIGH, Asserted One-cold, 124 One-hot, 82 Opcode, 299 Operands, 292–298 Operators bitwise, 171–174 immediate ( ori), 308 gate, 21 Or-and-invert (OAI) gate, 43 precedence table of, 179 reduction, 174 Out-of-order execution, 443 Out-of-order processor, 441–443 Output devices, 466Output terminals, 51 Overflow, 15 detecting, 15 addition, 15 P Page, 485 size, 485 Page fault, 485 Page offset, 486–488 Page table, 486 Parity, 22 Parallelism, 149–153 pipelining. SeePipelining, Pipelined MIPS processor SIMD. SeeSingle instruction multiple data unit spatial temporal, 151 vector processor. SeeVector processor Patterson, David, 290, 364 PCBs. SeePrinted circuit boards PC-relative addressing, 327–328. See also Addressing modes PCSrc, 281, 387–390 PCWrite, 385 Pentium processors, 449–452. See also Intel, IA-32 Pentium 4, 452 Pentium II, 450, 499 Pentium III, 450, 451, 499 Pentium M, 453 Pentium Pro, 450, 499, 501 Perfect induction, 60 Performance, 366–368 Peripheral devices. SeeI/O devices Perl programming language, 20 Physical memory, 466, 485–486 Physical pages, 486–494 Physical page number, 486 Pipelined MIPS processor, 151, 366, 401–421. See also MIPS, Architecture, Microarchitecture control, 405–406 datapath, 404 forwarding, 408–410 hazards. SeeHazards performance analysis, 418–421 processor performance comparison, 420 stalls, 410–413. See also Hazards timing, 402Index 565Index.qxd 1/30/07 3:14 PM Page 565Pipelining hazards. SeeHazards PLAs. SeeProgrammable logic arrays Plastic leaded chip carriers (PLCCs), 531–532 PLCCs. SeePlastic leaded chip carriers PLDs. SeeProgrammable logic devices pMOS, 29–30 pMOS transistors, 28–31 Pointer, 321 global, 331 stack, 321 Pop, 345–346. See also Stack Ports, 259 POS. SeeProduct sums form Power consumption, 34–35 Prediction. SeeBranch prediction Prefix adder, 237–239 Preserved registers, 322–324 Prime implicants, 61, 74 Printed circuit boards (PCBs), 533–534 Procedure calls, 319–327 arguments variables, 326–327 nested, 324–326 preserved versus nonpreserved registers, 323–324 returns, 319–320 return values, 320 stack frame, 322 stack usage, 321–322 Processors. SeeMicroprocessors Product-of-sums (POS) canonical form, 56 Program counter ( PC), 365 Programmable logic arrays (PLAs), 63, 266–268, 520–521 Programmable logic devices (PLDs), 268 Programmable read memories (PROMs), 516–520. See also Read memories Programming, 304–327 arithmetic/logical instructions. See Arithmetic, 304–308 arrays. SeeArrays branching. SeeBranching conditional statements. See Conditional statements constants, 307–308 immediates, 298 loops. SeeLoops procedure calls. SeeProcedure calls shift instructions, 306–307translating starting program, 331–335 Programming languages, 290–294 Propagation delay, 84 Protection, memory. SeeMemory protection Proving Boolean theorems. SeePerfect induction PROMs. SeeProgrammable read memories Pseudo-direct addressing, 328–329. See also Addressing modes Pseudo-nMOS logic, 33–34. See also Transistors Pseudoinstructions, 336–337 Push, 67–69. See also Stack Q Queue, 321 FIFO. SeeFirst-in-first-out queue LIFO. SeeLast-in-first-out queue Q output. SeeSequential logic design R R-type instructions, 299–300 RAM. SeeRandom access memory Random access memory (RAM), 257, 262–264. See also Memory arrays synthesized, 265 Read memory, 199, 257, 262–264. See also Memory arrays EPROM. SeeErasable programma- ble read memory EEPROM. SeeElectrically erasable programmable read memory flash memory. SeeFlash memory PROM. SeeProgrammable read memory transistor-level implementation, 273 Read/write head, 484 Recursive procedure calls, 324–325. See also Procedure calls Reduced instruction set computer (RISC), 292, 364Reduction operators, 174. See also Hardware description languages, Verilog RegDst, 373–374 Register-only addressing, 327. See also Addressing modes Register renaming, 443–445. See also Advanced microarchitecture Register(s), 190–191, 261–262, 292–294. See also Flip-flops, Register file arguments ( $a0-$a3 ) assembler temporary ( $at) enabled. SeeEnabled registers file, 261 global pointer ( $gp), 331 multiple, 194–195 program counter ( PC), 365 preserved nonpreserved, 322–324 renaming, 443–445 resettable. SeeResettable registers asynchronous, 192 synchronous, 192 return address ( $ra), 319–320 Register set, 294. See also Register file, MIPS registers, IA-32 registers Regularity, 6, 188 RegWrite, 371 Replacement policies, 492. See also Caches, Virtual memory Resettable registers,191–193 asynchronous. SeeAsynchronous resettable registers synchronous. SeeSynchronous resettable registers Return address ( $ra), 319–320 Ripple-carry adder, 234 RISC. SeeReduced instruction set computer ROM, SeeRead Memory Rotators, 244–246 Rounding, 252 Scalar processor, 438 Scan chains, 255. See also Shift registers Schematic, 62–65 Scientific notation, 249–250566 IndexIndex.qxd 1/30/07 3:14 PM Page 566Seek time, 484 Segments, memory, 330–331 Semiconductor industry, sales, 3 Semiconductors, 27. See also Transistors CMOS. SeeComplementary metal oxide silicon diodes. SeeDiodes transistors. SeeTransistors MOSFET. SeeMetal oxide silicon field effect transistors nMOS. SeenMOS transistors pMOS. SeepMOS transistors pseudo nMOS. SeePseudo nMOS Sensitivity list, 190, 191, 196 Sequential building blocks. SeeSequential logic Sequential logic, 103–165, 190–195, 254–257 enabled registers, 193 latches, 103–112, 195 multiple registers, 194–195 overview, 103 registers, 190–191 shift registers, 255–257 synchronous, 113–117 timing of, 133–149. See also Timing set less ( slt), 313 set less immediate ( slti ), 339 set less immediate unsigned (sltiu ), 339 set less unsigned ( sltu ), 339 Setup time, 133, 135–136 Seven-segment display decoder, 75–77 “don’t cares,” 78 Shared memory, 71 Shift amount ( shamt ), 245 shift left logical ( sll), 306 shift left logical variable ( sllv ), 306 shift right arithmetic ( sra), 306 shift right arithmetic variable ( srav ), 306 shift right logical ( srl), 306 shift right logical variable ( srlv ), 306 Shifters, 244–246 arithmetic, 244 logical, 244 Shift instructions, 306–307 Shift registers, 255–257 Short path, 86 Sign/magnitude numbers, 15–16 Sign bit, 16 Sign extension, 18 Significand. SeeMantissaSilicon (Si), 27 Silicon dioxide (SO 2), 28 Silicon Valley, 26 Simplicity, 291–292 SIMD. SeeSingle instruction multiple data units Single-cycle MIPS processor, 366, 368–381. See also MIPS micro- processor, MIPS architecture, MIPS microarchitecture control, 374–377 ALU decoder truth table. See ALU decoder Main decoder truth table. See Main decoder datapath, 368–374 HDL representation, 422 operation, 376–377 performance analysis, 380–381 timing, 402 Single instruction multiple data (SIMD) units, 438, 445 Slash notation, 53 SPARC architecture, 364 SRAM. SeeStatic random access memory SP0256, 496 Spatial locality, 464 Speech synthesis, 496–498 device driver, 498 SP0256, 496 Stack, 321–322. See also Memory map, Procedure calls, Queue dynamic data segment, 331 frame, 322 LIFO. SeeLast-in-first-out queue pointer, 321 Stalls, 410–413. See also Hazards Static discipline, 24–26 Static random access memory (SRAM), 257, 260 Status flags, 344 Stored program concept, 303–304 Stores store byte ( sb), 318 store half ( sh), 553 store word ( sw), 296 Strings, 318 Structural modeling, 185–189 subtract ( sub), 291 subtract unsigned (subu), 339 Subtraction, 17–18, 240, 291 Subtractor, 240Sum-of-products (SOP) canonical form, 54–55 Sun Microsystems, 364 Superscalar processor, 438–440 Supply voltage, 22 Swap space, 492 Swift, Jonathan, 297 Switch/case statements, 311 Symbol table, 333 Synchronizers, 144–146 asynchronous inputs, 146 MTBF. SeeMean time failure probability failure. See Probability failure Synchronous resettable registers, 192 HDL for, 192 Synchronous sequential logic, 113–117 problematic circuits, 113–114 Synthesis, 78–79, 186, 187, 188, 189, 190, 193, 194, 195, 199, 200 Synthesis Tools, 195 Taking two’s complement, 16 Temporal locality, 464 Testbenches, 171, 214–218, 428–431 self-checking, 215 test vector file, 216 Text segment, 330 Theorems. SeeBoolean Theorems Thin small outline package (TSOP), 531 Threshold voltage, 29 Throughput, 149 Timing analysis, 137–138 delay, 86–87 glitches, 88–91 sequential logic, 133–149 clock skew, 140–143 dynamic discipline, 134 hold time. SeeHold time hold time constraint, 136–137. SeeHold time constraint, Hold time violation hold time violation. SeeHold time violation, Hold time constraint, 139Index 567Index.qxd 1/30/07 3:14 PM Page 567Timing ( Continued ) metastability, 143–144 setup time. SeeSetup time setup time constraint, 135–136 setup time violations resolution time, 146–149. See alsoMetastability synchronizers, 144–146 system timing, 135–140 specification, 51 TLB. SeeTranslation lookaside buffer Token, 149 Transistors, 23, 28–31, 34 CMOS. SeeComplement metal oxide silicon nMOS. SeenMOS pMOS. SeepMOS Transistor-Transistor Logic (TTL), 25 Translation lookaside buffer (TLB), 490 Translating starting program, 331–336 Transmission gates, 33. See also Transistors Transmission lines, 534–546 reflection coefficient, 544–545 Z0, 543–544 matched termination, 536–538 mismatched termination, 539–541 open termination, 538–539 proper terminations, 542 short termination, 539 use, 41–542 Tristate buffer, 70–71 Truth tables, 55, 56, 60, 61, 177 ALU decoder, 376 “don’t care,” 77 main decoder, 376, 379 multiplexer, 79 seven-segment display decoder, 76 SR latch, 106 undefined floating inputs, 181 TSOP. SeeThin small outline package TTL. SeeTransistor-Transistor Logic Two-level logic, 65–66 Two’s complement numbers, 16–18. See also Binary numbersU Unconditional branches, 308. See also Jumps Unicode, 316. See also ASCII Unit test (UUT), 201 Unity gain points, 24 Unsigned numbers, 18 Use bit, 478–479 UUT. SeeUnit test V Valid bit, 472. See also Caches, Virtual memory Vanity Fair (Carroll), 65 VCC, 23 VDD, 23 Vector processors, 438. See also Advanced microarchitecture Verilog, 167, 169, 172, 173, 174, 175, 176, 178, 180, 181, 201, 203, 205 3:8 decoder, 199 accessing parts busses, 189 adder, 426 ALU decoder, 424 AND, 168 architecture body, 168 assign statement, 168, 197, 178 asynchronous reset, 192 bad synchronizer blocking assignments, 206 bit swizzling, 182 blocking assignment, 202 case sensitivity, 174 casez, 201 combinational logic, 168, 202 comments, 174 comparators, 242 continuous assignment statement, 173 controller, 423 counter, 254 datapath, 425 default, 198 divide-by-3 finite state machine, 207, 208 latch, 195eight-input AND, 174 entity declaration, 168 full adder, 178 using always/process, 197 using nonblocking assignments, 204 IEEE_STD_LOGIC_1164, 168, 183 IEEE_STD_LOGIC_SIGNED, 183 IEEE_STD_LOGIC_UNSIGNED, 183 inverters, 172 using always/process, 196 left shift, 427 library use clause, 168 logic gates, 173 delays, 183 main decoder, 424 MIPS testbench, 429 MIPS top-level module, 430 multiplexers, 175, 176, 428 multiplier, 247 nonblocking assignment, 191, 202 NOT, 168 numbers, 180 operator precedence, 179 OR, 168 parameterized N:2Ndecoder, 212 N-bit multiplexer, 211 N-input gate, 213 pattern recognizer Mealy FSM, 210 Moore FSM, 209 priority circuit, 201 RAM, 265 reg, 191, 194 register, 191 register file, 42 resettable flip-flop, 427 resettable enabled register, 193 resettable register, 192 ROM, 266 self-checking testbench, 215 seven-segment display decoder, 198 shift register, 256 sign extension, 427 single-cycle MIPS processor, 422 STD_LOGIC, 168, 183 statement, 173 structural models568 IndexIndex.qxd 1/30/07 3:14 PM Page 5682:1 multiplexer, 188 4:1 multiplexer, 187 subtractor, 241 synchronizer, 194 synchronous reset, 192 testbench, 214 test vector file, 216 tristate buffer, 180 truth tables undefined floating inputs, 181 type declaration, 168 wires, 178 VHDL libraries types, 167, 169, 172, 173, 174, 175, 176, 178, 180, 181, 183–185, 203, 205 3:8 decoder, 199 accessing parts busses, 189 adder, 426 architecture, 187 asynchronous reset, 192 bad synchronizer blocking assignments, 206 bit swizzling, 182 boolean, 183 case sensitivity, 174 clk’event, 191 combinational logic, 168 comments, 174 comparators, 242 concurrent signal assignment, 173, 178 controller, 423 CONV_STD_LOGIC_VECTOR, 212 counter, 254 datapath, 425 decoder, 424 divide-by-3 finite state machine, 207, 208 latch, 195 eight-input AND, 174 expression, 173 full adder, 178 using always/process, 197 using nonblocking assignments, 204 generic statement, 211 inverters, 172 using always/process, 196 left shift, 427 logic gates, 173 delays, 183 main decoder, 424MIPS testbench, 429 MIPS top-level module, 430 multiplexers, 175, 176, 428 multiplier, 247 numbers, 180 operand, 173 operator precedence, 179 others, 198 parameterized N-bit multiplexer, 211 N-input gate, 213 N:2Ndecoder, 212 pattern recognizer Mealy FSM, 210 Moore FSM, 209 priority circuit, 201 process, 191 RAM, 265 register, 191 register file, 426 resettable enabled register, 193 resettable flip-flop, 427 resettable register, 192 RISING_EDGE, 191 ROM, 266 selected signal assignment state- ments, 176 self-checking testbench, 215 seven-segment display decoder, 198 shift register, 256 sign extension, 427 signals, 178, 194 simulation waveforms delays, 170, 183 single-cycle MIPS processor, 422 STD_LOGIC_ARITH, 212 structural models 2:1 multiplexer, 188 4:1 multiplexer, 187 subtractor, 241 synchronizer, 194 synchronous reset, 192 testbench, 214 test vector file, 216 tristate buffer, 180 truth tables undefined floating inputs, 181 VHSIC, 169 Virtual address, 485–490 Virtual memory, 484–494 address translation, 486–488 IA-32, 501 memory protection, 491pages, 485 page faults, 485 page offset, 486–488 page table, 488–489 multilevel page tables, 492–494 replacement policies, 492 translation lookaside buffer (TLB), 490. SeeTranslation looka- side buffer write policies, 482–483 Virtual pages, 485 Virtual page number, 487 Volatile memory, 259. See also DRAM, SRAM, Flip-flops Voltage, threshold, 29 VSS, 23 W Wafers, 28 Wall, Larry, 20 WAR. SeeWrite read WAW. SeeWrite write loop, 312–313 White space, 174 Whitmore, Georgiana, 7 Wire, 63 Word-addressable memory, 295 Write policies, 482–483 Write read (WAR) hazard, 442. See also Hazards Write write (WAW) hazard, 442–443. See also Hazards X XOR gate, 21 XNOR gate, 21 Xilinx FPGA, 268 X. SeeContention, Don’t care., Z Z,. SeeFloating Zero extension, 302Index 569Index.qxd 1/30/07 3:14 PM Page 569