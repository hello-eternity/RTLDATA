instruction,input,output
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a 64-bit Johnson counter (torsional ring counter), and cyclic state of the the similar 4-bit Johnson counter is as follows: 0000, 1000, 1100, 1110, 1111, 0111, 0011, 0001, 0000.
Module name:  
    JC_counter               
Input ports：
    input                clk ,
    input                rst_n
Output ports：
    output reg [63:0]     Q
","`timescale 1ns/1ns

module verified_JC_counter(
   input                clk ,
   input                rst_n,
 
   output reg [63:0]     Q  
);
    always@(posedge clk or negedge rst_n)begin
        if(!rst_n) Q <= 'd0;
        else if(!Q[0]) Q <= {1'b1, Q[63 : 1]};
        else Q <= {1'b0, Q[63 : 1]};
    end
endmodule
"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement the design of unsigned 16bit multiplier based on shifting and adding opration. 
Module name:  
    multi_16bit               
Input ports：
    input clk;       
    input rst_n;      
    input start;      // Chip enable signal. 
    input [15:0] ain; 
    input [15:0] bin;
Output ports：
    output [31:0] yout; // Product output with a data width of 32 bits.
    output done;      // Chip output flag signal. Defined as 1 indicates multiplication operation completion.","module verified_multi_16bit(
    clk, 
    rst_n,
    start, 
    ain, 
    bin, 
    yout, 
    done
);

input clk;        // Chip clock signal.
input rst_n;      // Active-low reset signal. Defined as 0 for chip reset; defined as 1 for reset signal inactive.
input start;      // Chip enable signal. 
input [15:0] ain; // Input a (multiplicand) with a data width of 16 bits.
input [15:0] bin; // Input b (multiplier) with a data width of 16 bits.

output [31:0] yout; // Product output with a data width of 32 bits.
output done;      // Chip output flag signal. Defined as 1 indicates multiplication operation completion.

reg [15:0] areg;    // Multiplicand a register.
reg [15:0] breg;    // Multiplier b register.
reg [31:0] yout_r;  // Product register.
reg done_r;
reg [4:0] i;        // Shift count register.


//------------------------------------------------
// Data bit control
always @(posedge clk or negedge rst_n)
    if (!rst_n) i <= 5'd0;
    else if (start && i < 5'd17) i <= i + 1'b1; 
    else if (!start) i <= 5'd0;

//------------------------------------------------
// Multiplication completion flag generation
always @(posedge clk or negedge rst_n)
    if (!rst_n) done_r <= 1'b0;
    else if (i == 5'd16) done_r <= 1'b1; // Multiplication completion flag
    else if (i == 5'd17) done_r <= 1'b0; // Flag reset

assign done = done_r;

//------------------------------------------------
// Dedicated register for shift and accumulate operation
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin 
        areg <= 16'h0000;
        breg <= 16'h0000;
        yout_r <= 32'h00000000;
    end
    else if (start) begin // Start operation
        if (i == 5'd0) begin // Store multiplicand and multiplier
            areg <= ain;
            breg <= bin;
        end
        else if (i > 5'd0 && i < 5'd17) begin
            if (areg[i-1]) 
            yout_r <= yout_r + ({16'h0000, breg} << (i-1)); // Accumulate and shift
        end
    end
end

assign yout = yout_r;

endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a radix-2 divider module and the inputs are two 8-bit operands. 
The registers remainder_reg, divisor_reg, and quotient_reg are used to store the current values of the remainder, divisor, and quotient, respectively. i is a 4-bit counter for the iterations.

Inside the always block, the code handles the initialization when rst_n is low. It sets the remainder_reg to the value of dividend, divisor_reg to the value of divisor, and quotient_reg to 0.

In the else block (when rst_n is high), the radix-2 division algorithm is executed.

The code performs four iterations to calculate the quotient and remainder. Each iteration checks if the remainder_reg is greater than or equal to a shifted version of the divisor_reg concatenated with zeros. If it is, the corresponding bit of the quotient is set to 1, and the remainder_reg is updated by subtracting the shifted divisor. Otherwise, the corresponding bit of the quotient is set to 0.

After each iteration, the bits of the quotient are shifted down by 4 positions to prepare for the next iteration.

The final quotient and remainder values are assigned to the output ports quotient and remainder, respectively.

Module name:  
    radix2_div               
Input ports：
    input 			[7:0]  		dividend 	,  		
    input 			[7:0]  		divisor 	,   	
    input						clk 	 	,	 	
    input                       rst_n	
Output ports：
    output 		[7:0] 	quotient 	,  		
    output 		[7:0] 	remainder","module verified_radix2_div(
    input 			[7:0]  		dividend 	,  		
    input 			[7:0]  		divisor 	,   	
    input						clk 	 	,	 	
    input                       rst_n       ,       
    output wire 		[7:0] 	quotient 	,  		
    output wire 		[7:0] 	remainder  			
);

reg [7:0] remainder_reg; 
reg [7:0] divisor_reg;   
reg [7:0] quotient_reg;  
reg [3:0] i;             

always@(posedge  clk or negedge rst_n) begin
    if (!rst_n ) begin
            remainder_reg <= dividend;
            divisor_reg <= divisor;
            quotient_reg <= 0;
    end
    else begin
  
        if(remainder_reg >= {divisor_reg,4'b0}) begin
            remainder_reg <= remainder_reg - {divisor_reg,4'b0};
            quotient_reg[7] <= 1;
        end
        else begin
            quotient_reg[7] <= 0;
        end
        
        
        if(remainder_reg >= {divisor_reg,3'b0,1'b0}) begin
            remainder_reg <= remainder_reg - {divisor_reg,3'b0,1'b0};
            quotient_reg[6] <= 1;
        end
        else begin
            quotient_reg[6] <= 0;
        end
        
      
        if(remainder_reg >= {divisor_reg,2'b0,2'b0}) begin
            remainder_reg <= remainder_reg - {divisor_reg,2'b0,2'b0};
            quotient_reg[5] <= 1;
        end
        else begin
            quotient_reg[5] <= 0;
        end
        
       
        if(remainder_reg >= {divisor_reg,1'b0,3'b0}) begin
            remainder_reg <= remainder_reg - {divisor_reg,1'b0,3'b0};
            quotient_reg[4] <= 1;
        end
        else begin
            quotient_reg[4] <= 0;
        end
        
        
        for(i=0;i<4;i=i+1) begin
            quotient_reg[i] <= quotient_reg[i+4];
        end
    end
end


assign quotient = quotient_reg;
assign remainder = remainder_reg;
    
endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a signal generator module, select the signal wave_choise according to the waveform to send out the corresponding waveform: wave_choice=0, send out the square wave signal; wave_choice=1, sends a sawtooth signal; wave_choice=2, the triangular wave signal is emitted. 
Module name:  
    signal_generator               
Input ports：
    input clk,
	input rst_n,
	input [1:0] wave_choise
Output ports：
    output reg [4:0]wave","`timescale 1ns/1ns
module verified_signal_generator(
	input clk,
	input rst_n,
	input [1:0] wave_choise,
	output reg [4:0]wave
	);

    reg [4:0] cnt;
    reg flag;
    
  	// square
    always@(posedge clk or negedge rst_n) begin
        if(~rst_n)
            cnt <= 0;
        else
            cnt <= wave_choise!=0 ? 0:
                   cnt        ==19? 0:
                   cnt + 1;
    end
    
  	// tri
    always@(posedge clk or negedge rst_n) begin
        if(~rst_n)
            flag <= 0;
        else
            flag <= wave_choise!=2 ? 0:
                    wave       ==1 ? 1:
                    wave       ==19? 0:
                    flag;
    end
    
  
  	// update
    always@(posedge clk or negedge rst_n) begin
        if(~rst_n) 
            wave <= 0;
        else 
            case(wave_choise)
                0      : wave <= cnt == 9? 20    : 
                                 cnt ==19? 0     :
                                 wave;
                1      : wave <= wave==20? 0     : wave+1;
                2      : wave <= flag==0 ? wave-1: wave+1;
                default: wave <= 0;
            endcase
    end
endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement an asynchronous FIFO, FIFO bit width and depth can be configured(parameter DEPTH = 16,parameter WIDTH = 8). The asynchronous FIFO structure is divided into several parts. The first part is dual-port RAM, which is used for data storage. Instantiate dual-port RAM as a submodule, The RAM ports are input wclk,input wenc,input [$clog2(DEPTH)-1:0] waddr,input [WIDTH-1:0] wdata,input rclk,input renc,input [$clog2(DEPTH)-1:0] raddr,output reg [WIDTH-1:0] rdata. The second part is the data write controller. The third part is the data read controller. The fourth part is the read pointer synchronizer. The read pointer is collected using the two-stage trigger of the write clock and output to the data write controller. The fifth part is the write pointer synchronizer, which uses the two-stage trigger of the read clock to collect the write pointer and output it to the data read controller.
The method of empty and full judgment is to generate empty and full signal by comparing Gray code. Use 4-bit Gray code as a read/write pointer for a FIFO with depth 8. The gray code is converted to a four-digit binary number, using the lower three digits of the binary number as the address to access RAM. When the read and write Pointers are equal, the FIFO is null.
When the write pointer has one more cycle RAM than the read pointer, the highest and second-highest bits of the read and write pointer are opposite, the remaining bits are the same, and the FIFO is full.
Module name:  
    asyn_fifo               
Input ports：
    input 					wclk	, 
	input 					rclk	,   
	input 					wrstn	,
	input					rrstn	,
	input 					winc	,
	input 			 		rinc	,
	input 		[WIDTH-1:0]	wdata	
Output ports：
    output wire				wfull	,
	output wire				rempty	,
	output wire [WIDTH-1:0]	rdata","`timescale 1ns/1ns

/***************************************RAM*****************************************/
module dual_port_RAM #(parameter DEPTH = 16,  parameter WIDTH = 8)
(
	 input wclk	,
	 input wenc	,
	 input [$clog2(DEPTH)-1:0] waddr  ,
	 input [WIDTH-1:0] wdata ,
	 input rclk	,
	 input renc	,
	 input [$clog2(DEPTH)-1:0] raddr ,
	 output reg [WIDTH-1:0] rdata 		
);

reg [WIDTH-1:0] RAM_MEM [0:DEPTH-1];

always @(posedge wclk) begin
	if(wenc)
		RAM_MEM[waddr] <= wdata;
end 

always @(posedge rclk) begin
	if(renc)
		rdata <= RAM_MEM[raddr];
end 

endmodule  

/***************************************AFIFO*****************************************/
module verified_asyn_fifo#(
	parameter	WIDTH = 8,
	parameter 	DEPTH = 16
)(
	input 					wclk	, 
	input 					rclk	,   
	input 					wrstn	,
	input					rrstn	,
	input 					winc	,
	input 			 		rinc	,
	input 		[WIDTH-1:0]	wdata	,

	output wire				wfull	,
	output wire				rempty	,
	output wire [WIDTH-1:0]	rdata
);

parameter ADDR_WIDTH = $clog2(DEPTH);


reg 	[ADDR_WIDTH:0]	waddr_bin;
reg 	[ADDR_WIDTH:0]	raddr_bin;

always @(posedge wclk or negedge wrstn) begin
	if(~wrstn) begin
		waddr_bin <= 'd0;
	end 
	else if(!wfull && winc)begin
		waddr_bin <= waddr_bin + 1'd1;
	end
end
always @(posedge rclk or negedge rrstn) begin
	if(~rrstn) begin
		raddr_bin <= 'd0;
	end 
	else if(!rempty && rinc)begin
		raddr_bin <= raddr_bin + 1'd1;
	end
end

/**********************addr gray gen*************************/
wire 	[ADDR_WIDTH:0]	waddr_gray;
wire 	[ADDR_WIDTH:0]	raddr_gray;
reg 	[ADDR_WIDTH:0]	wptr;
reg 	[ADDR_WIDTH:0]	rptr;
assign waddr_gray = waddr_bin ^ (waddr_bin>>1);
assign raddr_gray = raddr_bin ^ (raddr_bin>>1);
always @(posedge wclk or negedge wrstn) begin 
	if(~wrstn) begin
		wptr <= 'd0;
	end 
	else begin
		wptr <= waddr_gray;
	end
end
always @(posedge rclk or negedge rrstn) begin 
	if(~rrstn) begin
		rptr <= 'd0;
	end 
	else begin
		rptr <= raddr_gray;
	end
end
/**********************syn addr gray*************************/
reg		[ADDR_WIDTH:0]	wptr_buff;
reg		[ADDR_WIDTH:0]	wptr_syn;
reg		[ADDR_WIDTH:0]	rptr_buff;
reg		[ADDR_WIDTH:0]	rptr_syn;
always @(posedge wclk or negedge wrstn) begin 
	if(~wrstn) begin
		rptr_buff <= 'd0;
		rptr_syn <= 'd0;
	end 
	else begin
		rptr_buff <= rptr;
		rptr_syn <= rptr_buff;
	end
end
always @(posedge rclk or negedge rrstn) begin 
	if(~rrstn) begin
		wptr_buff <= 'd0;
		wptr_syn <= 'd0;
	end 
	else begin
		wptr_buff <= wptr;
		wptr_syn <= wptr_buff;
	end
end
/**********************full empty gen*************************/
assign wfull = (wptr == {~rptr_syn[ADDR_WIDTH:ADDR_WIDTH-1],rptr_syn[ADDR_WIDTH-2:0]});
assign rempty = (rptr == wptr_syn);

/**********************RAM*************************/
wire 	wen	;
wire	ren	;
wire 	wren;//high write
wire [ADDR_WIDTH-1:0]	waddr;
wire [ADDR_WIDTH-1:0]	raddr;
assign wen = winc & !wfull;
assign ren = rinc & !rempty;
assign waddr = waddr_bin[ADDR_WIDTH-1:0];
assign raddr = raddr_bin[ADDR_WIDTH-1:0];

dual_port_RAM #(.DEPTH(DEPTH),
				.WIDTH(WIDTH)
)dual_port_RAM(
	.wclk (wclk),  
	.wenc (wen),  
	.waddr(waddr[ADDR_WIDTH-1:0]),  //The depth is logarithmic to 2 to get the bit width of the address
	.wdata(wdata),       	//data_write
	.rclk (rclk), 
	.renc (ren), 
	.raddr(raddr[ADDR_WIDTH-1:0]),   
	.rdata(rdata)  		
);

endmodule"
Please act as a professional verilog designer.,"[ 0 :  0 :  0]
[ 0 :  0 :  1]
[ 0 :  0 :  2]
[ 0 :  0 :  3]
[ 0 :  0 :  4]
[ 0 :  0 :  5]
[ 0 :  0 :  6]
[ 0 :  0 :  7]
[ 0 :  0 :  8]
[ 0 :  0 :  9]
[ 0 :  0 : 10]
[ 0 :  0 : 11]
[ 0 :  0 : 12]
[ 0 :  0 : 13]
[ 0 :  0 : 14]
[ 0 :  0 : 15]
[ 0 :  0 : 16]
[ 0 :  0 : 17]
[ 0 :  0 : 18]
[ 0 :  0 : 19]
[ 0 :  0 : 20]
[ 0 :  0 : 21]
[ 0 :  0 : 22]
[ 0 :  0 : 23]
[ 0 :  0 : 24]
[ 0 :  0 : 25]
[ 0 :  0 : 26]
[ 0 :  0 : 27]
[ 0 :  0 : 28]
[ 0 :  0 : 29]
[ 0 :  0 : 30]
[ 0 :  0 : 31]
[ 0 :  0 : 32]
[ 0 :  0 : 33]
[ 0 :  0 : 34]
[ 0 :  0 : 35]
[ 0 :  0 : 36]
[ 0 :  0 : 37]
[ 0 :  0 : 38]
[ 0 :  0 : 39]
[ 0 :  0 : 40]
[ 0 :  0 : 41]
[ 0 :  0 : 42]
[ 0 :  0 : 43]
[ 0 :  0 : 44]
[ 0 :  0 : 45]
[ 0 :  0 : 46]
[ 0 :  0 : 47]
[ 0 :  0 : 48]
[ 0 :  0 : 49]
[ 0 :  0 : 50]
[ 0 :  0 : 51]
[ 0 :  0 : 52]
[ 0 :  0 : 53]
[ 0 :  0 : 54]
[ 0 :  0 : 55]
[ 0 :  0 : 56]
[ 0 :  0 : 57]
[ 0 :  0 : 58]
[ 0 :  0 : 59]
[ 0 :  1 :  0]
[ 0 :  1 :  1]
[ 0 :  1 :  2]
[ 0 :  1 :  3]
[ 0 :  1 :  4]
[ 0 :  1 :  5]
[ 0 :  1 :  6]
[ 0 :  1 :  7]
[ 0 :  1 :  8]
[ 0 :  1 :  9]
[ 0 :  1 : 10]
[ 0 :  1 : 11]
[ 0 :  1 : 12]
[ 0 :  1 : 13]
[ 0 :  1 : 14]
[ 0 :  1 : 15]
[ 0 :  1 : 16]
[ 0 :  1 : 17]
[ 0 :  1 : 18]
[ 0 :  1 : 19]
[ 0 :  1 : 20]
[ 0 :  1 : 21]
[ 0 :  1 : 22]
[ 0 :  1 : 23]
[ 0 :  1 : 24]
[ 0 :  1 : 25]
[ 0 :  1 : 26]
[ 0 :  1 : 27]
[ 0 :  1 : 28]
[ 0 :  1 : 29]
[ 0 :  1 : 30]
[ 0 :  1 : 31]
[ 0 :  1 : 32]
[ 0 :  1 : 33]
[ 0 :  1 : 34]
[ 0 :  1 : 35]
[ 0 :  1 : 36]
[ 0 :  1 : 37]
[ 0 :  1 : 38]
[ 0 :  1 : 39]
[ 0 :  1 : 40]
[ 0 :  1 : 41]
[ 0 :  1 : 42]
[ 0 :  1 : 43]
[ 0 :  1 : 44]
[ 0 :  1 : 45]
[ 0 :  1 : 46]
[ 0 :  1 : 47]
[ 0 :  1 : 48]
[ 0 :  1 : 49]
[ 0 :  1 : 50]
[ 0 :  1 : 51]
[ 0 :  1 : 52]
[ 0 :  1 : 53]
[ 0 :  1 : 54]
[ 0 :  1 : 55]
[ 0 :  1 : 56]
[ 0 :  1 : 57]
[ 0 :  1 : 58]
[ 0 :  1 : 59]
[ 0 :  2 :  0]
[ 0 :  2 :  1]
[ 0 :  2 :  2]
[ 0 :  2 :  3]
[ 0 :  2 :  4]
[ 0 :  2 :  5]
[ 0 :  2 :  6]
[ 0 :  2 :  7]
[ 0 :  2 :  8]
[ 0 :  2 :  9]
[ 0 :  2 : 10]
[ 0 :  2 : 11]
[ 0 :  2 : 12]
[ 0 :  2 : 13]
[ 0 :  2 : 14]
[ 0 :  2 : 15]
[ 0 :  2 : 16]
[ 0 :  2 : 17]
[ 0 :  2 : 18]
[ 0 :  2 : 19]
[ 0 :  2 : 20]
[ 0 :  2 : 21]
[ 0 :  2 : 22]
[ 0 :  2 : 23]
[ 0 :  2 : 24]
[ 0 :  2 : 25]
[ 0 :  2 : 26]
[ 0 :  2 : 27]
[ 0 :  2 : 28]
[ 0 :  2 : 29]
[ 0 :  2 : 30]
[ 0 :  2 : 31]
[ 0 :  2 : 32]
[ 0 :  2 : 33]
[ 0 :  2 : 34]
[ 0 :  2 : 35]
[ 0 :  2 : 36]
[ 0 :  2 : 37]
[ 0 :  2 : 38]
[ 0 :  2 : 39]
[ 0 :  2 : 40]
[ 0 :  2 : 41]
[ 0 :  2 : 42]
[ 0 :  2 : 43]
[ 0 :  2 : 44]
[ 0 :  2 : 45]
[ 0 :  2 : 46]
[ 0 :  2 : 47]
[ 0 :  2 : 48]
[ 0 :  2 : 49]
[ 0 :  2 : 50]
[ 0 :  2 : 51]
[ 0 :  2 : 52]
[ 0 :  2 : 53]
[ 0 :  2 : 54]
[ 0 :  2 : 55]
[ 0 :  2 : 56]
[ 0 :  2 : 57]
[ 0 :  2 : 58]
[ 0 :  2 : 59]
[ 0 :  3 :  0]
[ 0 :  3 :  1]
[ 0 :  3 :  2]
[ 0 :  3 :  3]
[ 0 :  3 :  4]
[ 0 :  3 :  5]
[ 0 :  3 :  6]
[ 0 :  3 :  7]
[ 0 :  3 :  8]
[ 0 :  3 :  9]
[ 0 :  3 : 10]
[ 0 :  3 : 11]
[ 0 :  3 : 12]
[ 0 :  3 : 13]
[ 0 :  3 : 14]
[ 0 :  3 : 15]
[ 0 :  3 : 16]
[ 0 :  3 : 17]
[ 0 :  3 : 18]
[ 0 :  3 : 19]
[ 0 :  3 : 20]
[ 0 :  3 : 21]
[ 0 :  3 : 22]
[ 0 :  3 : 23]
[ 0 :  3 : 24]
[ 0 :  3 : 25]
[ 0 :  3 : 26]
[ 0 :  3 : 27]
[ 0 :  3 : 28]
[ 0 :  3 : 29]
[ 0 :  3 : 30]
[ 0 :  3 : 31]
[ 0 :  3 : 32]
[ 0 :  3 : 33]
[ 0 :  3 : 34]
[ 0 :  3 : 35]
[ 0 :  3 : 36]
[ 0 :  3 : 37]
[ 0 :  3 : 38]
[ 0 :  3 : 39]
[ 0 :  3 : 40]
[ 0 :  3 : 41]
[ 0 :  3 : 42]
[ 0 :  3 : 43]
[ 0 :  3 : 44]
[ 0 :  3 : 45]
[ 0 :  3 : 46]
[ 0 :  3 : 47]
[ 0 :  3 : 48]
[ 0 :  3 : 49]
[ 0 :  3 : 50]
[ 0 :  3 : 51]
[ 0 :  3 : 52]
[ 0 :  3 : 53]
[ 0 :  3 : 54]
[ 0 :  3 : 55]
[ 0 :  3 : 56]
[ 0 :  3 : 57]
[ 0 :  3 : 58]
[ 0 :  3 : 59]
[ 0 :  4 :  0]
[ 0 :  4 :  1]
[ 0 :  4 :  2]
[ 0 :  4 :  3]
[ 0 :  4 :  4]
[ 0 :  4 :  5]
[ 0 :  4 :  6]
[ 0 :  4 :  7]
[ 0 :  4 :  8]
[ 0 :  4 :  9]
[ 0 :  4 : 10]
[ 0 :  4 : 11]
[ 0 :  4 : 12]
[ 0 :  4 : 13]
[ 0 :  4 : 14]
[ 0 :  4 : 15]
[ 0 :  4 : 16]
[ 0 :  4 : 17]
[ 0 :  4 : 18]
[ 0 :  4 : 19]
[ 0 :  4 : 20]
[ 0 :  4 : 21]
[ 0 :  4 : 22]
[ 0 :  4 : 23]
[ 0 :  4 : 24]
[ 0 :  4 : 25]
[ 0 :  4 : 26]
[ 0 :  4 : 27]
[ 0 :  4 : 28]
[ 0 :  4 : 29]
[ 0 :  4 : 30]
[ 0 :  4 : 31]
[ 0 :  4 : 32]
[ 0 :  4 : 33]
[ 0 :  4 : 34]
[ 0 :  4 : 35]
[ 0 :  4 : 36]
[ 0 :  4 : 37]
[ 0 :  4 : 38]
[ 0 :  4 : 39]
[ 0 :  4 : 40]
[ 0 :  4 : 41]
[ 0 :  4 : 42]
[ 0 :  4 : 43]
[ 0 :  4 : 44]
[ 0 :  4 : 45]
[ 0 :  4 : 46]
[ 0 :  4 : 47]
[ 0 :  4 : 48]
[ 0 :  4 : 49]
[ 0 :  4 : 50]
[ 0 :  4 : 51]
[ 0 :  4 : 52]
[ 0 :  4 : 53]
[ 0 :  4 : 54]
[ 0 :  4 : 55]
[ 0 :  4 : 56]
[ 0 :  4 : 57]
[ 0 :  4 : 58]
[ 0 :  4 : 59]
[ 0 :  5 :  0]
[ 0 :  5 :  1]
[ 0 :  5 :  2]
[ 0 :  5 :  3]
[ 0 :  5 :  4]
[ 0 :  5 :  5]
[ 0 :  5 :  6]
[ 0 :  5 :  7]
[ 0 :  5 :  8]
[ 0 :  5 :  9]
[ 0 :  5 : 10]
[ 0 :  5 : 11]
[ 0 :  5 : 12]
[ 0 :  5 : 13]
[ 0 :  5 : 14]
[ 0 :  5 : 15]
[ 0 :  5 : 16]
[ 0 :  5 : 17]
[ 0 :  5 : 18]
[ 0 :  5 : 19]
[ 0 :  5 : 20]
[ 0 :  5 : 21]
[ 0 :  5 : 22]
[ 0 :  5 : 23]
[ 0 :  5 : 24]
[ 0 :  5 : 25]
[ 0 :  5 : 26]
[ 0 :  5 : 27]
[ 0 :  5 : 28]
[ 0 :  5 : 29]
[ 0 :  5 : 30]
[ 0 :  5 : 31]
[ 0 :  5 : 32]
[ 0 :  5 : 33]
[ 0 :  5 : 34]
[ 0 :  5 : 35]
[ 0 :  5 : 36]
[ 0 :  5 : 37]
[ 0 :  5 : 38]
[ 0 :  5 : 39]
[ 0 :  5 : 40]
[ 0 :  5 : 41]
[ 0 :  5 : 42]
[ 0 :  5 : 43]
[ 0 :  5 : 44]
[ 0 :  5 : 45]
[ 0 :  5 : 46]
[ 0 :  5 : 47]
[ 0 :  5 : 48]
[ 0 :  5 : 49]
[ 0 :  5 : 50]
[ 0 :  5 : 51]
[ 0 :  5 : 52]
[ 0 :  5 : 53]
[ 0 :  5 : 54]
[ 0 :  5 : 55]
[ 0 :  5 : 56]
[ 0 :  5 : 57]
[ 0 :  5 : 58]
[ 0 :  5 : 59]
[ 0 :  6 :  0]
[ 0 :  6 :  1]
[ 0 :  6 :  2]
[ 0 :  6 :  3]
[ 0 :  6 :  4]
[ 0 :  6 :  5]
[ 0 :  6 :  6]
[ 0 :  6 :  7]
[ 0 :  6 :  8]
[ 0 :  6 :  9]
[ 0 :  6 : 10]
[ 0 :  6 : 11]
[ 0 :  6 : 12]
[ 0 :  6 : 13]
[ 0 :  6 : 14]
[ 0 :  6 : 15]
[ 0 :  6 : 16]
[ 0 :  6 : 17]
[ 0 :  6 : 18]
[ 0 :  6 : 19]
[ 0 :  6 : 20]
[ 0 :  6 : 21]
[ 0 :  6 : 22]
[ 0 :  6 : 23]
[ 0 :  6 : 24]
[ 0 :  6 : 25]
[ 0 :  6 : 26]
[ 0 :  6 : 27]
[ 0 :  6 : 28]
[ 0 :  6 : 29]
[ 0 :  6 : 30]
[ 0 :  6 : 31]
[ 0 :  6 : 32]
[ 0 :  6 : 33]
[ 0 :  6 : 34]
[ 0 :  6 : 35]
[ 0 :  6 : 36]
[ 0 :  6 : 37]
[ 0 :  6 : 38]
[ 0 :  6 : 39]
[ 0 :  6 : 40]
[ 0 :  6 : 41]
[ 0 :  6 : 42]
[ 0 :  6 : 43]
[ 0 :  6 : 44]
[ 0 :  6 : 45]
[ 0 :  6 : 46]
[ 0 :  6 : 47]
[ 0 :  6 : 48]
[ 0 :  6 : 49]
[ 0 :  6 : 50]
[ 0 :  6 : 51]
[ 0 :  6 : 52]
[ 0 :  6 : 53]
[ 0 :  6 : 54]
[ 0 :  6 : 55]
[ 0 :  6 : 56]
[ 0 :  6 : 57]
[ 0 :  6 : 58]
[ 0 :  6 : 59]
[ 0 :  7 :  0]
[ 0 :  7 :  1]
[ 0 :  7 :  2]
[ 0 :  7 :  3]
[ 0 :  7 :  4]
[ 0 :  7 :  5]
[ 0 :  7 :  6]
[ 0 :  7 :  7]
[ 0 :  7 :  8]
[ 0 :  7 :  9]
[ 0 :  7 : 10]
[ 0 :  7 : 11]
[ 0 :  7 : 12]
[ 0 :  7 : 13]
[ 0 :  7 : 14]
[ 0 :  7 : 15]
[ 0 :  7 : 16]
[ 0 :  7 : 17]
[ 0 :  7 : 18]
[ 0 :  7 : 19]
[ 0 :  7 : 20]
[ 0 :  7 : 21]
[ 0 :  7 : 22]
[ 0 :  7 : 23]
[ 0 :  7 : 24]
[ 0 :  7 : 25]
[ 0 :  7 : 26]
[ 0 :  7 : 27]
[ 0 :  7 : 28]
[ 0 :  7 : 29]
[ 0 :  7 : 30]
[ 0 :  7 : 31]
[ 0 :  7 : 32]
[ 0 :  7 : 33]
[ 0 :  7 : 34]
[ 0 :  7 : 35]
[ 0 :  7 : 36]
[ 0 :  7 : 37]
[ 0 :  7 : 38]
[ 0 :  7 : 39]
[ 0 :  7 : 40]
[ 0 :  7 : 41]
[ 0 :  7 : 42]
[ 0 :  7 : 43]
[ 0 :  7 : 44]
[ 0 :  7 : 45]
[ 0 :  7 : 46]
[ 0 :  7 : 47]
[ 0 :  7 : 48]
[ 0 :  7 : 49]
[ 0 :  7 : 50]
[ 0 :  7 : 51]
[ 0 :  7 : 52]
[ 0 :  7 : 53]
[ 0 :  7 : 54]
[ 0 :  7 : 55]
[ 0 :  7 : 56]
[ 0 :  7 : 57]
[ 0 :  7 : 58]
[ 0 :  7 : 59]
[ 0 :  8 :  0]
[ 0 :  8 :  1]
[ 0 :  8 :  2]
[ 0 :  8 :  3]
[ 0 :  8 :  4]
[ 0 :  8 :  5]
[ 0 :  8 :  6]
[ 0 :  8 :  7]
[ 0 :  8 :  8]
[ 0 :  8 :  9]
[ 0 :  8 : 10]
[ 0 :  8 : 11]
[ 0 :  8 : 12]
[ 0 :  8 : 13]
[ 0 :  8 : 14]
[ 0 :  8 : 15]
[ 0 :  8 : 16]
[ 0 :  8 : 17]
[ 0 :  8 : 18]
[ 0 :  8 : 19]
","module verified_calendar(CLK,RST,Hours,Mins,Secs);
input CLK,RST;
output [5:0] Hours,Mins,Secs;
reg [5:0] Hours,Mins,Secs;

always@(posedge CLK or posedge RST) begin
	if (RST)
		Secs <= 0;
	else if (Secs == 59)
		Secs <= 0;
	else
		Secs <= Secs + 1;
end

always@(posedge CLK or posedge RST) begin
	if (RST)
		Mins <= 0;
	else if((Mins==59)&&(Secs==59))
		Mins <= 0;
	else if(Secs== 59)
		Mins <= Mins + 1;
	else
		Mins <= Mins;
end

always@(posedge CLK or posedge RST) begin
        if (RST)
                Hours <= 0;
        else if((Hours == 23)&&(Mins==59)&&(Secs==59))
                Hours <= 0;
        else if((Mins == 59)&&(Secs==59))
                Hours <= Hours + 1;
        else
                Hours <= Hours;
end

endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a traffic light, with red, yellow and green three small indicators and a pedestrian button, under normal circumstances, the motor vehicle lane indicator light according to 60 clock cycles of green, 5 clock cycles of yellow, 10 clock cycles of red. When the pedestrian button is pressed, if the remaining green time is greater than 10 clocks, it is shortened to 10 clocks, and if it is less than 10 clocks, it remains unchanged.
Note: The lane light and the sidewalk light should be paired, when the lane light is green or yellow, the sidewalk light is red; When the lane light is red, the sidewalk light is green, and for the sake of simplicity, only the lane light is considered.
Module name:  
    traffic_light               
Input ports：
    input rst_n, 
    input clk,
    input pass_request
Output ports：
    output wire[7:0]clock,
    output reg red,
    output reg yellow,
    output reg green","`timescale 1ns/1ns

module verified_traffic_light
    (
		input rst_n, 
      input clk, 
      input pass_request,
		  output wire[7:0]clock,
      output reg red,
		  output reg yellow,
		  output reg green
    );
	
	parameter 	idle = 2'd0,
				s1_red = 2'd1,
				s2_yellow = 2'd2,
				s3_green = 2'd3;
	reg [7:0] cnt;
	reg [1:0] state;
	reg p_red,p_yellow,p_green;	


always @(posedge clk or negedge rst_n) 
    begin
        if(!rst_n)
        begin
			state <= idle;
			p_red <= 1'b0;
			p_green <= 1'b0;
			p_yellow <= 1'b0;			
        end
        else case(state)
		idle:
			begin
				p_red <= 1'b0;
				p_green <= 1'b0;
				p_yellow <= 1'b0;
				state <= s1_red;
			end
		s1_red:
			begin
				p_red <= 1'b1;
				p_green <= 1'b0;
				p_yellow <= 1'b0;
				if (cnt == 3) 
					state <= s2_yellow;
				else
					state <= s1_red;
			end
		s2_yellow:
			begin
				p_red <= 1'b0;
				p_green <= 1'b0;
				p_yellow <= 1'b1;
				if (cnt == 3) 
					state <= s3_green;
				else
					state <= s2_yellow;
			end
		s3_green:
			begin
				p_red <= 1'b0;
				p_green <= 1'b1;
				p_yellow <= 1'b0;
				if (cnt == 3) 
					state <= s1_red;
				else
					state <= s3_green;
			end
		endcase
	end
 
always @(posedge clk or negedge rst_n) 
      if(!rst_n)
			cnt <= 7'd10;
		else if (pass_request&&green&&(cnt>10))
			cnt <= 7'd10;
		else if (!green&&p_green)
			cnt <= 7'd60;
		else if (!yellow&&p_yellow)
			cnt <= 7'd5;
		else if (!red&&p_red)
			cnt <= 7'd10;	
		else cnt <= cnt -1;
 assign clock = cnt;

always @(posedge clk or negedge rst_n) 
        if(!rst_n)
			begin
				yellow <= 1'd0;
				red <= 1'd0;
				green <= 1'd0;
			end
		else 
			begin
				yellow <= p_yellow;
				red <= p_red;
				green <= p_green;
			end		

endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a module of a carry lookahead 32 bit adder based on CLAs.
Module name:  
    adder_32bit               
Input ports：
    input [32:1] A,
    input [32:1] B
Output ports：
    output [32:1] S,
    output C32","module verified_adder_32bit(A,B,S,C32);
     input [32:1] A;
     input [32:1] B;
     output [32:1] S;
     output C32;

     wire px1,gx1,px2,gx2;
     wire c16;

  CLA_16 CLA1(
      .A(A[16:1]),
        .B(B[16:1]),
        .c0(0),
        .S(S[16:1]),
        .px(px1),
        .gx(gx1)
    );

  CLA_16 CLA2(
        .A(A[32:17]),
          .B(B[32:17]),
          .c0(c16),
          .S(S[32:17]),
          .px(px2),
          .gx(gx2)
    );

  assign c16 = gx1 ^ (px1 && 0), //c0 = 0
         C32 = gx2 ^ (px2 && c16);
endmodule

module CLA_16(A,B,c0,S,px,gx);
    input [16:1] A;
    input [16:1] B;
    input c0;
    output gx,px;
    output [16:1] S;

    wire c4,c8,c12;
    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;

    adder_4 adder1(
         .x(A[4:1]),
          .y(B[4:1]),
          .c0(c0),
          .c4(),
          .F(S[4:1]),
          .Gm(Gm1),
          .Pm(Pm1)
    );

    adder_4 adder2(
         .x(A[8:5]),
          .y(B[8:5]),
          .c0(c4),
          .c4(),
          .F(S[8:5]),
          .Gm(Gm2),
          .Pm(Pm2)
    );

    adder_4 adder3(
         .x(A[12:9]),
          .y(B[12:9]),
          .c0(c8),
          .c4(),
          .F(S[12:9]),
          .Gm(Gm3),
          .Pm(Pm3)
    );

    adder_4 adder4(
         .x(A[16:13]),
          .y(B[16:13]),
          .c0(c12),
          .c4(),
          .F(S[16:13]),
          .Gm(Gm4),
          .Pm(Pm4)
    );

    assign   c4 = Gm1 ^ (Pm1 & c0),
             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),
             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);

    assign  px = Pm1 & Pm2 & Pm3 & Pm4,
            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);
endmodule

module adder_4(x,y,c0,c4,F,Gm,Pm);
      input [4:1] x;
      input [4:1] y;
      input c0;
      output c4,Gm,Pm;
      output [4:1] F;

      wire p1,p2,p3,p4,g1,g2,g3,g4;
      wire c1,c2,c3;
      adder adder1(
                 .X(x[1]),
                     .Y(y[1]),
                     .Cin(c0),
                     .F(F[1]),
                     .Cout()
                );

      adder adder2(
                 .X(x[2]),
                     .Y(y[2]),
                     .Cin(c1),
                     .F(F[2]),
                     .Cout()
                );  

      adder adder3(
                 .X(x[3]),
                     .Y(y[3]),
                     .Cin(c2),
                     .F(F[3]),
                     .Cout()
                );

      adder adder4(
                 .X(x[4]),
                     .Y(y[4]),
                     .Cin(c3),
                     .F(F[4]),
                     .Cout()
                );      

        CLA CLA(
            .c0(c0),
            .c1(c1),
            .c2(c2),
            .c3(c3),
            .c4(c4),
            .p1(p1),
            .p2(p2),
            .p3(p3),
            .p4(p4),
            .g1(g1),
            .g2(g2),
            .g3(g3),
            .g4(g4)
        );



  assign   p1 = x[1] ^ y[1],      
           p2 = x[2] ^ y[2],
           p3 = x[3] ^ y[3],
           p4 = x[4] ^ y[4];

  assign   g1 = x[1] & y[1],
           g2 = x[2] & y[2],
           g3 = x[3] & y[3],
           g4 = x[4] & y[4];

  assign Pm = p1 & p2 & p3 & p4,
         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);
endmodule

module CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);

     input c0,g1,g2,g3,g4,p1,p2,p3,p4;
     output c1,c2,c3,c4;

     assign c1 = g1 ^ (p1 & c0),
            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),
            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),
            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);
endmodule

module adder(X,Y,Cin,F,Cout);

  input X,Y,Cin;
  output F,Cout;

  assign F = X ^ Y ^ Cin;
  assign Cout = (X ^ Y) & Cin | X & Y;
endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement an ALU for 32bit MIPS-ISA CPU. The “a” and “b” are the two oprands of the ALU, the “aluc” is the opcode, the “r” gives out the result. “zero” means if the result is zero, “carry” means if there is a carry bit, “negative” means if the result is negative, “overflow” means if the computation is overflow, the “flag” is the result of “slt” and “sltu” instructions. The supported operations and corresponding opcode are shown below:
    parameter ADD = 6'b100000;
    parameter ADDU = 6'b100001;
    parameter SUB = 6'b100010;
    parameter SUBU = 6'b100011;
    parameter AND = 6'b100100;
    parameter OR = 6'b100101;
    parameter XOR = 6'b100110;
    parameter NOR = 6'b100111;
    parameter SLT = 6'b101010;
    parameter SLTU = 6'b101011;
    parameter SLL = 6'b000000;
    parameter SRL = 6'b000010;
    parameter SRA = 6'b000011;
    parameter SLLV = 6'b000100;
    parameter SRLV = 6'b000110;
    parameter SRAV = 6'b000111;
    parameter LUI = 6'b001111;

Module name:  
    alu               
Input ports：
    input [31:0] a,
    input [31:0] b,
    input [5:0] aluc,
Output ports：
    output [31:0] r,
    output zero,
    output carry,
    output negative,
    output overflow,
    output flag
","`timescale 1ns / 1ps

module verified_alu(
    input [31:0] a,
    input [31:0] b,
    input [5:0] aluc,
    output [31:0] r,
    output zero,
    output carry,
    output negative,
    output overflow,
    output flag
    );
    

    parameter ADD = 6'b100000;
    parameter ADDU = 6'b100001;
    parameter SUB = 6'b100010;
    parameter SUBU = 6'b100011;
    parameter AND = 6'b100100;
    parameter OR = 6'b100101;
    parameter XOR = 6'b100110;
    parameter NOR = 6'b100111;
    parameter SLT = 6'b101010;
    parameter SLTU = 6'b101011;
    parameter SLL = 6'b000000;
    parameter SRL = 6'b000010;
    parameter SRA = 6'b000011;
    parameter SLLV = 6'b000100;
    parameter SRLV = 6'b000110;
    parameter SRAV = 6'b000111;
    parameter JR = 6'b001000;
    
    parameter LUI = 6'b001111;
      
    
    wire signed [31:0] a_signed;
    wire signed [31:0] b_signed;
    
  
    reg [32:0] res;
    
    
    assign a_signed = a;
    assign b_signed = b;
    assign r = res[31:0];
    
    assign flag = (aluc == SLT || aluc == SLTU) ? ((aluc == SLT) ? (a_signed < b_signed) : (a < b)) : 1'bz; 
    assign zero = (res == 32'b0) ? 1'b1 : 1'b0;
    
    always @ (a or b or aluc)
    begin
        case(aluc)
            ADD: begin
                res <= a_signed + b_signed;
            end
            ADDU: begin
                res <= a + b;
            end
            SUB: begin 
                res <= a_signed - b_signed;
            end
            SUBU: begin 
                res <= a - b;
            end
            AND: begin
                res <= a & b;
            end
            OR: begin
                res <= a | b;
            end
            XOR: begin
                res <= a ^ b;
            end
            NOR: begin
                res <= ~(a | b);
            end
            SLT: begin
                res <= a_signed < b_signed ? 1 : 0;
            end
            SLTU: begin
                res <= a < b ? 1 : 0;
            end
            SLL: begin
                res <= b << a;
            end
            SRL: begin
                res <= b >> a;
            end
            SRA: begin
                res <= b_signed >>> a_signed;
            end
            SLLV: begin
                res <= b << a[4:0];
            end
            SRLV: begin
                res <= b >> a[4:0];
            end
            SRAV: begin
                res <= b_signed >>> a_signed[4:0];
            end
            LUI: begin
                res <= {a[15:0], 16'h0000};
            end
            default:
            begin
                res <= 32'bz;
            end
        endcase
    end
endmodule
"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a frequency divider that the input clock frequency of 100MHz signal, and the outputs are 3 clock frequencies: 50MHz, 10MHz, 1MHz.
Module name:  
    freq_div               
Input ports：
    input CLK_in,
	input RST
Output ports：
    output reg CLK_50,
    output reg CLK_10,
    output reg CLK_1","module verified_freq_div (CLK_in,CLK_50,CLK_10,CLK_1,RST);
input CLK_in,RST;
output reg CLK_50,CLK_10,CLK_1;

reg [3:0] cnt_10;
reg [6:0] cnt_100;
reg [1:0] cnt_2;

always @(posedge CLK_in or posedge RST) begin
	if (RST) begin
		CLK_50<= 1'b0;
                cnt_2<=0;
        end
	else if (cnt_2==1) begin
		CLK_50<= ~CLK_50;
                cnt_2<=0;
        end
        else begin
                cnt_2<=cnt_2+1;
        end
end

always @(posedge CLK_in or posedge RST) begin
	if (RST) begin
		CLK_10<= 1'b0;
                cnt_10<=0;
        end
	else if (cnt_10==4) begin
		CLK_10<= ~CLK_10;
                cnt_10<=0;
        end
        else begin
                cnt_10<=cnt_10+1;
        end
end

always @(posedge CLK_in or posedge RST) begin
	if (RST) begin
		CLK_1<= 1'b0;
                cnt_100<=0;
        end
	else if (cnt_100==49) begin
		CLK_1<= ~CLK_1;
                cnt_100<=0;
        end
        else begin
                cnt_100<=cnt_100+1;
        end
end

endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a Multiplying Accumulator for 32bit integer. In the MAC_PE, there is a register that stores the partial sum (the intermediate accumulation result), and in each cycle, the result of “a multiplied by b” will be accumulated in this register, and the “c” shows the value of the register.

Module name:  
    pe               
Input ports：
    input clk,
    input rst,
    input [31:0] a,
    input [31:0] b,
Output ports：
    output [31:0] c
","module verified_pe(
    input clk,
    input rst,
    input [31:0] a,
    input [31:0] b,

    output [31:0] c
);

reg [31:0] c;

always@(posedge clk or posedge rst)
begin

  if(rst)
  begin
    c<=0;
  end

  else
  begin
    c<=c+a*b;
  end

end

endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a module for edge detection, there is a slowly changing 1 bit signal a. When the rising edge of signal a is detected, the indicating signal rise is given; when the falling edge of signal A is shown, the indicating signal down is given. rise and down are high on the next clock when the corresponding edge appears, and then return to 0 until the corresponding edge appears again.
Module name:  
    edge_detect               
Input ports：
    input clk,
	input rst_n,
	input a 
Output ports：
    output reg rise,
	output reg down","`timescale 1ns/1ns
module verified_edge_detect(
	input clk,
	input rst_n,
	input a,
	
	output reg rise,
	output reg down
);
	reg a0;
    always@(posedge clk or negedge rst_n) begin
        if(~rst_n) begin
            rise <= 1'b0;
            down <= 1'b0;
        end 
        else begin
            if(a & ~a0) begin
                rise <= 1;
                down <= 0;
            end 
            else if (~a & a0) begin
                rise <= 0;
                down <= 1;
            end else begin
                rise <= 0;
                down <= 0;
            end
        end
    end
    
    always@(posedge clk or negedge rst_n) begin
        if(~rst_n) 
            a0 <= 0;
        else 
            a0 <= a;
    end
endmodule
"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a series-parallel conversion circuit, the input end inputs single bit data, and when the module receives 6 input data, the output end outputs the 6bit data after splicing. The module adopts the valid-ready two-way handshake mechanism between the input and upstream, and the valid-only handshake mechanism between the output and downstream. During data concatenation, the received data is placed in the lower part of data_b. 
Module name:  
    s_to_p               
Input ports：
    input 				clk 		,   
	input 				rst_n		,
	input				valid_a		,
	input	 			data_a		
Output ports：
    output	reg 		ready_a		,
 	output	reg			valid_b		,
	output  reg [5:0] 	data_b","
module verified_serial2parallel(
    input               clk         ,   
    input               rst_n       ,
    input               valid_a     ,
    input               data_a      ,
 
    output  reg            ready_a     ,
    output  reg         valid_b     ,
    output      [5:0]   data_b
);

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        ready_a <= 1'b0;
    end
    else 
        ready_a <= 1'b1;
 end

reg [2:0]cnt;
reg [5:0]data_t,data_t1;
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        // reset
        data_t <= 'd0;
        cnt <= 'd0;
    end
    else if (valid_a && ready_a) begin

        data_t <= {data_a,data_t[5:1]};


        if(cnt == 'd5)begin
            cnt <= 'd0;
        end
        else begin
            cnt <= cnt + 1'b1;
        end
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        valid_b <= 'd0;
    end
    else if (valid_b== 1'b0 && cnt == 'd5 && valid_a && ready_a) begin
        valid_b <= 'd1;
       
    end
    else begin
        valid_b <= 'd0;
        
    end
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        data_t1 <= 'd0;
    end
    else if (valid_b) begin
        data_t1 <= data_t;   
    end
end

assign data_b = valid_b ? data_t : data_t1;
endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement the design where a single clock-cycle width pulse(data_in) is extracted from the A clock(fast) domain and a new single clock-width pulse (data_out) will be created in the clock domain B(slow). The frequency of clock domain A is 10 times that of clock domain B.
Module name:  
    pulse_detect               
Input ports：
    input                 clk_fast    , 
    input                 clk_slow    ,   
    input                 rst_n        ,
    input                 data_in	
Output ports：
     output               dataout","`timescale 1ns/1ns

module verified_pulse_detect(
	input 				clk_fast	, 
	input 				clk_slow	,   
	input 				rst_n		,
	input				data_in		,

	output  		 	dataout
);
    reg data_level, data_level1, data_level2, data_level3;
    
  	
    always@(posedge clk_fast or negedge rst_n) begin
        if(~rst_n)
            data_level <= 0;
        else
            data_level <= data_in? ~data_level: data_level;
    end
    
  	
    always@(posedge clk_slow or negedge rst_n) begin
        if(~rst_n) begin
            data_level1 <= 0;
            data_level2 <= 0;
            data_level3 <= 0;
        end
        else begin
            data_level1 <= data_level;
            data_level2 <= data_level1;
            data_level3 <= data_level2;
        end
    end
    assign dataout = data_level3^data_level2;
endmodule
"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a module of a counter design that requires counting from 4 'b0000 to 4' d12. The counting can be controlled by the input signal valid_count. That is, the count is paused if valid_count is invalid.
Module name:  
    counter_12               
Input ports：
    input rst_n,
	input clk,
	input valid_count
Output ports：
    output [3:0] out","module dfflr #(
	parameter DW = 4
)(
	input clk,
	input rst_n,
	input load,
	input [DW-1:0] in,
	output [DW-1:0] out
    );
    	reg [DW-1:0] out_reg;
    	always@(posedge clk or negedge rst_n)  
    	begin
        	if(rst_n == 1'b0)
            		out_reg[DW-1:0] = {DW{1'b0}};
        	else if(load)
            		out_reg[DW-1:0] = in[DW-1:0];
        	else 
            		out_reg[DW-1:0] = out[DW-1:0];
   	 end
    	assign out[DW-1:0] = out_reg[DW-1:0];
endmodule

module verified_counter_12(
    input rst_n,
	input clk,
	input valid_count, 
	output [3:0] out
	);
	wire [3:0]count_nxt;
	wire [3:0]count_r;
    dfflr #(4) count(clk,rst_n,valid_count,count_nxt,count_r);
    assign out = count_r;
    assign count_nxt = (count_r==4'd12)?4'd12:count_r+4'b1;
       
endmodule




"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a data width conversion circuit that converts 8-bit data input to 16-bit data output. The first arriving 8-bit data should be placed in the higher 8 bits of the 16-bit data output. 
Module name:  
    width_8to16               
Input ports：
    input                 clk      ,   
    input                 rst_n    ,
    input                 valid_in ,
    input  [7:0]          data_in    
Output ports：
    output   reg          valid_out,
    output   reg [15:0]   data_out","`timescale 1ns/1ns
module verified_width_8to16(
	input 				   clk 		,   
	input 				   rst_n		,
	input				      valid_in	,
	input	   [7:0]		   data_in	,
 
 	output	reg			valid_out,
	output   reg [15:0]	data_out
);
reg 	[7:0]		data_lock;  //data buffer
reg 				flag	   ;
//input data buff in data_lock
always @(posedge clk or negedge rst_n ) begin
	if(!rst_n) 
		data_lock <= 'd0;
	else if(valid_in && !flag)
		data_lock <= data_in;
end
//generate flag
always @(posedge clk or negedge rst_n ) begin
	if(!rst_n) 
		flag <= 'd0;
	else if(valid_in)
		flag <= ~flag;
end
//generate valid_out
always @(posedge clk or negedge rst_n ) begin
	if(!rst_n) 
		valid_out <= 'd0;
	else if(valid_in && flag)
		valid_out <= 1'd1;
	else
		valid_out <= 'd0;
end
//data stitching 
always @(posedge clk or negedge rst_n ) begin
	if(!rst_n) 
		data_out <= 'd0;
	else if(valid_in && flag)
		data_out <= {data_lock, data_in};
end

endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a module for parallel-to-serial conversion, where every four input bits are converted to one output bit. The output signal valid_in indicates the validity of the input at that time. 
Module name:  
    p_to_s               
Input ports：
    input  clk  ,
	input  rst  ,
	input  [3:0]d 
Output ports：
    output  valid_in ,
	output  dout","`timescale 1ns/1ns
module verified_parallel2serial(
	input wire clk  ,
	input wire rst  ,
	input wire [3:0]d ,
	output wire valid_in ,
	output wire dout
	);


reg [3:0] data = 'd0;
reg [1:0]cnt;
reg valid;
assign dout = data[3];
assign valid_in =valid;
always @(posedge clk or negedge rst) begin
    if(!rst)begin
        data<= 'd0;
        cnt <= 'd0;
        valid <= 'd0;
    end
    else  begin
                
		if (cnt == 'd3) begin
			data <= d;
			cnt <= 'd0;
			valid <= 1;
		end
		else begin
			cnt <= cnt + 'd1;
			valid <= 0;
			data  <= {data[2:0],data[3]};
		end
    end
		
end


endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a module of an 8 bit adder in gate level.
Module name:  
    adder_8bit               
Input ports：
    input [7:0] a, b,
    input cin
Output ports：
    output [7:0] sum,
    output SUM,
    output cout","// module verified_adder_8bit(
//     input [7:0] a, b,input cin,
//     output [7:0] sum,
//     output cout
// );
// wire c1, c2, c3, c4, c5, c6, c7;
// full_adder f0(a[0], b[0], cin, sum[0], c1);
// full_adder f1(a[1],b[1],c1, sum[1],c2);
// full_adder f2(a[2],b[2], c2,sum[2],c3);
// full_adder f3(a[3], b[3], c3, sum[3], c4);
// full_adder f4(a[4],b[4],c4,sum[4],c5);
// full_adder f5(a[5],b[5], c5,sum[5],c6);
// full_adder f6(a[6],b[6], c6, sum[6], c7);
// full_adder f7(a[7], b[7], c7, sum[7], cout);

// endmodule

// module full_adder(
//     input a, b, cin,
//     output sum, cout
// );
//     assign sum = a ^ b ^ cin;
//     assign cout= (a & b)|(cin & (a^ b)); 
// endmodule

module verified_adder_8bit(
    input [7:0] a, b, 
    input cin, output [7:0] sum, 
    output SUM, 
    output cout);
    
    wire [8:0] c;

    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));
    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));
    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));
    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));
    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));
    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));
    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));
    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));

    assign cout = c[7]; 
    assign SUM = sum[7];
endmodule

module full_adder (input a, b, cin, output sum, cout);
    assign {cout, sum} = a + b + cin;
endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a true dual-port RAM with a depth of 8 and a bit width of 4 bits, with all data initialized to 0000. It has two groups of ports, respectively for reading data and writing data, and read and write operations can be carried out at the same time. When the read_en signal is valid, the read_data of the corresponding position is read through the read_addr signal and output; When the write_en signal is valid, data is written to the corresponding position through the write_addr signal and write-data signal.
Module name:  
    RAM               
Input ports：
    input clk,
	input rst_n,
	
	input write_en,
	input [7:0]write_addr,
	input [3:0]write_data,
	
	input read_en,
	input [7:0]read_addr,
Output ports：
    output reg [3:0]read_data","module verified_RAM (
	input clk,
	input rst_n,
	
	input write_en,
	input [7:0]write_addr,
	input [5:0]write_data,
	
	input read_en,
	input [7:0]read_addr,
	output reg [5:0]read_data
);
    //prameter 
    parameter WIDTH = 6;
    parameter DEPTH = 8;
    
    //defination
    reg [DEPTH - 1 : 0] RAM [2**WIDTH-1:0];

    //output 
    integer i;
    always@(posedge clk or negedge rst_n)begin
        if(!rst_n) begin
               for(i = 0; i < DEPTH; i = i + 1) begin
                   RAM[i] <= 'd0;
               end
        end
        else if(write_en) 
            RAM[write_addr] <= write_data;
    end
    always@(posedge clk or negedge rst_n)begin
        if(!rst_n) 
            read_data <= 'd0;
        else if(read_en) 
            read_data <= RAM[read_addr];
        else 
            read_data <= 'd0;
    end
endmodule
"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a module to achieve serial input data accumulation output, input input 8bit data, whenever the module receives 4 input data, the output outputs 4 received data accumulation results. The input and output interfaces interact with the upstream and downstream using the valid-ready two-way handshake mechanism. When both upstream and downstream are required to be able to transmit at full speed, there is no bubble in data transmission, and no additional performance loss can be caused due to the design of this module.
Module name:  
    accu               
Input ports：
    input 				clk 		,   
	input 				rst_n		,
	input		[7:0]	data_in		,
	input				valid_a		,
	input	 			ready_b		,        
Output ports：
    output		 		ready_a		,
 	output	reg			valid_b		,
	output  reg [9:0] 	data_out","`timescale 1ns/1ns

module verified_accu(
    input               clk         ,   
    input               rst_n       ,
    input       [7:0]   data_in     ,
    input               valid_a     ,
    input               ready_b     ,
 
    output              ready_a     ,
    output  reg         valid_b     ,
    output  reg [9:0]   data_out
);
    
   reg [1:0] count;
   wire add_cnt;
   wire end_cnt;

   assign add_cnt = valid_a && ready_a;
   assign end_cnt = valid_a && ready_a && (count == 'd3);
   
   //count
   always @(posedge clk or negedge rst_n) begin
       if(!rst_n) begin
          count <= 0;
       end
       else if(end_cnt) begin
          count <= 0;
       end
       else if(add_cnt) begin
          count <= count + 1;
       end
   end

    //data_out
   always @(posedge clk or negedge rst_n) begin
      if(!rst_n) begin
        data_out <= 0;
      end
      else if (add_cnt && count == 0) begin
          data_out <= data_in;
      end
      else if (add_cnt) begin
          data_out <= data_out + data_in;
      end
   end

   //ready_a
   assign ready_a = !valid_b | ready_b;

   //valid_b
   always @(posedge clk or negedge rst_n) begin
       if(!rst_n) begin
           valid_b <= 0;
       end
       else if(end_cnt) begin
           valid_b <= 1;
       end
       else if(ready_b) begin
           valid_b <= 0;
       end
   end  
     
endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a 16-bit divider module, dividend is 16-bit and divider is 8-bit. Extract the higher bits of the dividend, matching the bit width of the divisor. Compare these bits with the divisor: if the dividend bits are greater, set the quotient to 1, otherwise set it to 0, and use the difference as the remainder. Concatenate the remainder with the highest remaining 1-bit of the dividend, and repeat the process until all dividend bits are processed.
Module name:
div_16bit
Input ports：
input wire [15:0] A,
input wire [7:0] B,
Output ports：
output wire [15:0] result,
output wire [15:0] odd","module verified_div_16bit(
    input wire [15:0] A,
    input wire [7:0] B,
    output wire [15:0] result,
    output wire [15:0] odd
    );

reg [15:0] a_reg;
reg [15:0] b_reg;
reg [31:0] tmp_a;
reg [31:0] tmp_b;
integer i;

always@(*) begin
    a_reg = A;
    b_reg = B;
end

always@(*) begin
    begin
        tmp_a = {16'b0,a_reg};
        tmp_b = {b_reg,16'b0};
        for(i=0;i<16;i=i+1)begin
            tmp_a = tmp_a << 1;
            if (tmp_a >= tmp_b) begin
                tmp_a = tmp_a - tmp_b + 1;
            end
            else begin
                tmp_a = tmp_a;
            end
        end
    end
end

assign odd = tmp_a[31:16];
assign result = tmp_a[15:0];

endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement an 8bit booth-4 multiplier. The module contains the following internal signals and registers:

p: 16-bit register to store the product
multiplier: 16-bit register to store the multiplier value
multiplicand: 16-bit register to store the multiplicand value
rdy: Ready signal register indicating the completion of the multiplication operation
ctr: 5-bit counter to keep track of the current bit position being processed in the multiplier
The module uses an always block sensitive to the positive edge of the clock signal (posedge clk) and the positive edge of the reset signal (posedge reset). Inside the always block, the behavior of the module is defined as follows:

During the reset condition (reset signal is high), the module initializes the registers and signals:

rdy is set to 0 to indicate that the multiplication operation is not yet complete.
p is set to 0 to clear the product register.
ctr is set to 0 to reset the counter.
multiplier is set to the sign-extended value of the a input, where the most significant bit of a is replicated to the left 8 bits of multiplier.
multiplicand is set to the sign-extended value of the b input, where the most significant bit of b is replicated to the left 8 bits of multiplicand.
During the non-reset condition, the module performs the Booth multiplication algorithm:

If the counter ctr is less than 16, the module shifts the multiplicand register to the left by 1 bit (multiplicand <= multiplicand << 1).
If the current bit of the multiplier at position ctr is 1, the module adds the shifted multiplicand to the p register (p <= p + multiplicand).
The counter ctr is incremented by 1 in each clock cycle.
Once the counter ctr reaches 16, the multiplication operation is complete, and the rdy signal is set to 1 to indicate readiness.

Module name:  
    booth4_mul               
Input ports：
   input clk, reset;
   input [7:0] a, b;
Output ports：
   output [15:0] p;
   output rdy;","`timescale 1ns / 1ps

module verified_booth4_mul (p, rdy, clk, reset, a, b);
   input clk, reset;
   input [7:0] a, b;
   output [15:0] p;
   output rdy;
   
   reg [15:0] p;
   reg [15:0] multiplier;
   reg [15:0] multiplicand;
   reg rdy;
   reg [4:0] ctr;

always @(posedge clk or posedge reset) begin
    if (reset) 
    begin
    rdy     <= 0;
    p   <= 0;
    ctr     <= 0;
    multiplier <= {{8{a[7]}}, a};
    multiplicand <= {{8{b[7]}}, b};
    end 
    else 
    begin 
      if(ctr < 16) 
          begin
          multiplicand <= multiplicand << 1;
            if (multiplier[ctr] == 1)
            begin
                p <= p + multiplicand;
            end
            ctr <= ctr + 1;
          end
       else 
           begin
           rdy <= 1;
           end
    end
  end //End of always block
    
endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a multi-bit MUX synchronizer, data_in will remain constant during the period when data_en is high, and data_en is high for at least 3 B clock cycles. When the value of data_en is high, data can be synchronized. The data change frequency of data_in is very low. The change interval between two adjacent data is at least 10 B clock cycles.
Module name:  
    mux               
Input ports：
    input 				clk_a	, 
	input 				clk_b	,   
	input 				arstn	,
	input				brstn   ,
	input		[3:0]	data_in	,
	input               data_en 
Output ports：
    output reg  [3:0] 	dataout","module verified_mux(
	input 				clk_a	, 
	input 				clk_b	,   
	input 				arstn	,
	input				brstn   ,
	input		[3:0]	data_in	,
	input               data_en ,

	output reg  [3:0] 	dataout
);
    reg [3:0] data_reg;
    reg       data_en_a, data_en_b0, data_en_b1;
    
    always@(posedge clk_a or negedge arstn) begin
        if(~arstn)
            data_reg <= 0;
        else
            data_reg <= data_in;
    end
    
    always@(posedge clk_a or negedge arstn) begin
        if(~arstn)
            data_en_a <= 0;
        else
            data_en_a <= data_en;
    end
    
    always@(posedge clk_b or negedge brstn) begin
        if(~brstn) begin
            data_en_b0 <= 0;
            data_en_b1 <= 0;
        end
        else begin
            data_en_b0 <= data_en_a;
            data_en_b1 <= data_en_b0;
        end
    end
    
    always@(posedge clk_b or negedge brstn) begin
        if(~brstn) 
            dataout <= 0;
        else 
            dataout <= data_en_b1? data_reg: dataout;
    end

endmodule

"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement the design of unsigned 8bit multiplier based on pipelining processing. 
Module name:  
    multi_pipe_8bit               
Input ports：
    input clk;           
    input rst_n; 
    input mul_en_in;      
    input [size-1:0] mul_a;       
    input [size-1:0] mul_b;  	
Output ports：
    output reg mul_en_out;  
    output reg [size*2-1:0] mul_out;","module verified_multi_pipe_8bit#(
    parameter size = 8
)(
          clk,      
          rst_n,       
          mul_a,       
          mul_b, 
          mul_en_in,
 
          mul_en_out,      
          mul_out    
);
 
   input clk;           
   input rst_n; 
   input mul_en_in;      
   input [size-1:0] mul_a;       
   input [size-1:0] mul_b;       
 
   output reg mul_en_out;  
   output reg [size*2-1:0] mul_out;    
 
            
   reg [2:0] mul_en_out_reg;
 always@(posedge clk or negedge rst_n)
       if(!rst_n)begin
            mul_en_out_reg <= 'd0;             
            mul_en_out     <= 'd0;                           
       end
       else begin
            mul_en_out_reg <= {mul_en_out_reg[1:0],mul_en_in};            
            mul_en_out     <= mul_en_out_reg[2];                  
       end
 
 
    reg [7:0] mul_a_reg;
    reg [7:0] mul_b_reg;
  always @(posedge clk or negedge rst_n)
         if(!rst_n) begin
              mul_a_reg <= 'd0;
              mul_a_reg <= 'd0;
         end
         else begin
              mul_a_reg <= mul_en_in ? mul_a :'d0;
              mul_b_reg <= mul_en_in ? mul_b :'d0;
         end
 
  
     wire [15:0] temp [size-1:0];
  assign temp[0] = mul_b_reg[0]? {8'b0,mul_a_reg} : 'd0;
  assign temp[1] = mul_b_reg[1]? {7'b0,mul_a_reg,1'b0} : 'd0;
  assign temp[2] = mul_b_reg[2]? {6'b0,mul_a_reg,2'b0} : 'd0;
  assign temp[3] = mul_b_reg[3]? {5'b0,mul_a_reg,3'b0} : 'd0;
  assign temp[4] = mul_b_reg[4]? {4'b0,mul_a_reg,4'b0} : 'd0;
  assign temp[5] = mul_b_reg[5]? {3'b0,mul_a_reg,5'b0} : 'd0;
  assign temp[6] = mul_b_reg[6]? {2'b0,mul_a_reg,6'b0} : 'd0;
  assign temp[7] = mul_b_reg[7]? {1'b0,mul_a_reg,7'b0} : 'd0; 
 
 
     reg [15:0] sum [3:0];//[size/2-1:1]
 always @(posedge clk or negedge rst_n) 
       if(!rst_n) begin
          sum[0]  <= 'd0;
          sum[1]  <= 'd0;
          sum[2]  <= 'd0;
          sum[3]  <= 'd0;
       end 
       else begin
          sum[0] <= temp[0] + temp[1];
          sum[1] <= temp[2] + temp[3];
          sum[2] <= temp[4] + temp[5];
          sum[3] <= temp[6] + temp[7];
       end
 
     reg [15:0] mul_out_reg;
 always @(posedge clk or negedge rst_n) 
       if(!rst_n)
          mul_out_reg <= 'd0;
       else 
          mul_out_reg <= sum[0] + sum[1] + sum[2] + sum[3];
 
 
 always @(posedge clk or negedge rst_n) 
       if(!rst_n)
          mul_out <= 'd0;
       else if(mul_en_out_reg[2])
          mul_out <= mul_out_reg;
       else
          mul_out <= 'd0;
 
          
endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a FSM detection circuit that detects a single bit input IN. When the input is 10011, output MATCH is high, and MATCH is 0 in other cases.
Module name:  
    fsm               
Input ports：
    input CLK,
    input RST,
    input IN
Output ports：
    output reg MATCH","module verified_fsm(IN,MATCH,CLK,RST);
input IN,CLK,RST;
output reg MATCH;

reg [2:0] ST_cr,ST_nt;

parameter s0 = 3'b000;
parameter s1 = 3'b001;
parameter s2 = 3'b010;
parameter s3 = 3'b011;
parameter s4 = 3'b100;
parameter s5 = 3'b101;

always@(posedge CLK or posedge RST) begin
	if(RST)
		ST_cr <= s0;
	else
		ST_cr <= ST_nt;
end

always@(*) begin
	case(ST_cr)
		s0:begin
			if (IN==0)
				ST_nt = s0;
			else
				ST_nt = s1;
		end
		
		s1:begin
                        if (IN==0)
                                ST_nt = s2;
                        else
                                ST_nt = s1;
                end

                s2:begin
                        if (IN==0)
                                ST_nt = s3;
                        else
                                ST_nt = s1;
                end

                s3:begin
                        if (IN==0)
                                ST_nt = s0;
                        else
                                ST_nt = s4;
                end

                s4:begin
                        if (IN==0)
                                ST_nt = s2;
                        else
                                ST_nt = s5;
                end

                s5:begin
                        if (IN==0)
                                ST_nt = s2;
                        else
                                ST_nt = s1;
                end

	endcase
end

always@(posedge CLK or posedge RST) begin
        if(RST)
                MATCH  <= 0;
        else if (ST_cr == s5)
                MATCH  <= 1;
	else 
		MATCH  <= 0;
end

endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a a right shifter. Unrestricted serial input with a delay of 8bits after passing through the register. The module performs an 8-bit right shift on a 1-bit input by first initializing the q register to 0. On each rising edge of the clock, the module shifts the contents of the q register to the right by one bit and inserts the new input bit d into the most significant position of the register.
Module name:  
    right_shifter               
Input ports：
    input  clk,  
    input d
Output ports：
    output  [7:0] q","module verified_right_shifter(clk, q,d);  
     input  clk;  
     input d;  
     output  [7:0] q;  
      reg   [7:0]  q; 
    initial q = 0;
    always @(posedge clk)
          begin
            q<=(q>>1);
            q[7]<=d;
          end  
endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a module of a 16-bit full adder.
Module name:  
    adder_16bit               
Input ports：
    input    [15:0]  a,
    input    [15:0]  b,
    input            c_up
Output ports：
    output    [15:0]  y,
    output            Co","module verified_adder_16bit(
    input   wire    [15:0]  a,
    input   wire    [15:0]  b,
    input   wire            c_up,
    
    output wire     [15:0]  y,
    output wire             Co
);
 
        wire    Co_temp;
 
        add8    add8_inst1(
            .a          (a[15:8]),
            .b          (b[15:8]),
            .c_up       (Co_temp), 
             
            .y          (y[15:8]),
            .Co     (Co)
        );
 
        add8    add8_inst2(
            .a          (a[7:0]),
            .b          (b[7:0]),
            .c_up       (c_up),
             
            .y          (y[7:0]),
            .Co     (Co_temp)
        ); 
 
endmodule

module add8(
    input   wire    [7:0]   a,
    input   wire    [7:0]   b,
    input   wire                c_up,
     
    output wire     [7:0]       y,
    output wire                 Co
);
 
        wire    Co_temp;
 
        add4    add4_inst1(
            .a          (a[7:4]),
            .b          (b[7:4]),
            .c_up       (Co_temp), 
             
            .y          (y[7:4]),
            .Co     (Co)
        );
 
        add4    add4_inst2(
            .a          (a[3:0]),
            .b          (b[3:0]),
            .c_up       (c_up),
             
            .y          (y[3:0]),
            .Co     (Co_temp)
        );
 
 
endmodule

module add4(
    input   wire    [3:0]   a,
    input   wire    [3:0]   b,
    input   wire                c_up,
     
    output wire     [3:0]       y,
    output wire                 Co
);
 
        wire    Co_temp;
 
        add2    add2_inst1(
            .a          (a[3:2]),
            .b          (b[3:2]),
            .c_up       (Co_temp), 
             
            .y          (y[3:2]),
            .Co     (Co)
        );
 
        add2    add2_inst2(
            .a          (a[1:0]),
            .b          (b[1:0]),
            .c_up       (c_up),
             
            .y          (y[1:0]),
            .Co     (Co_temp)
        ); 
 
endmodule

module add2(
    input   wire    [1:0]   a,
    input   wire    [1:0]   b,
    input   wire                c_up,
     
    output wire     [1:0]       y,
    output wire                 Co
);
 
        wire    Co_temp;

        add1    add1_inst1(
            .a          (a[1]),
            .b          (b[1]),
            .c_up       (Co_temp), 
             
            .y          (y[1]),
            .Co     (Co)
        );
 
        add1    add1_inst2(
            .a          (a[0]),
            .b          (b[0]),
            .c_up       (c_up),
             
            .y          (y[0]),
            .Co     (Co_temp)
        );
         
endmodule

module add1(
    input   wire        a,
    input   wire        b,
    input   wire        c_up,
     
    output wire         y,
    output wire         Co
);
    assign  y   = ((~a)&(~b)&c_up | (~a)&b&(~c_up) | a&(~b)&(~c_up) | (a&b&c_up));
    assign  Co  = ((~a&b&c_up) | (a&~b&c_up) | (a&b&~c_up) | (a&b&c_up));

endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement a module of a ripple 64 bit adder, which is divided into 4 sections to achieve 4-stage pipeline. 
Module name:  
    adder_64bit               
Input ports：
    input                               clk             ,
    input                               rst_n           ,
    input                               i_en            ,
    input       [DATA_WIDTH-1:0]        adda            ,
    input       [DATA_WIDTH-1:0]        addb            ,
   
Output ports：
    output      [DATA_WIDTH:0]          result          ,
    output reg                          o_en            ","module verified_adder_64bit
#(
    parameter           DATA_WIDTH = 64,
    parameter           STG_WIDTH  = 16
)
(
    input                               clk             ,
    input                               rst_n           ,
    input                               i_en            ,
    input       [DATA_WIDTH-1:0]        adda            ,
    input       [DATA_WIDTH-1:0]        addb            ,
    output      [DATA_WIDTH:0]          result          ,
    output reg                          o_en            
);
reg         stage1;
reg         stage2;
reg         stage3;

wire [STG_WIDTH-1:0]  a1;
wire [STG_WIDTH-1:0]  b1;
wire [STG_WIDTH-1:0]  a2;
wire [STG_WIDTH-1:0]  b2;
wire [STG_WIDTH-1:0]  a3;
wire [STG_WIDTH-1:0]  b3;
wire [STG_WIDTH-1:0]  a4;
wire [STG_WIDTH-1:0]  b4;

reg  [STG_WIDTH-1:0]  a2_ff1;
reg  [STG_WIDTH-1:0]  b2_ff1;

reg  [STG_WIDTH-1:0]  a3_ff1;
reg  [STG_WIDTH-1:0]  b3_ff1;
reg  [STG_WIDTH-1:0]  a3_ff2;
reg  [STG_WIDTH-1:0]  b3_ff2;

reg  [STG_WIDTH-1:0]  a4_ff1;
reg  [STG_WIDTH-1:0]  b4_ff1;
reg  [STG_WIDTH-1:0]  a4_ff2;
reg  [STG_WIDTH-1:0]  b4_ff2;
reg  [STG_WIDTH-1:0]  a4_ff3;
reg  [STG_WIDTH-1:0]  b4_ff3;

reg                   c1;
reg                   c2;
reg                   c3;
reg                   c4;

reg  [STG_WIDTH-1:0]  s1;
reg  [STG_WIDTH-1:0]  s2;
reg  [STG_WIDTH-1:0]  s3;
reg  [STG_WIDTH-1:0]  s4;

reg  [STG_WIDTH-1:0]  s1_ff1;
reg  [STG_WIDTH-1:0]  s1_ff2;
reg  [STG_WIDTH-1:0]  s1_ff3;

reg  [STG_WIDTH-1:0]  s2_ff1;
reg  [STG_WIDTH-1:0]  s2_ff2;

reg  [STG_WIDTH-1:0]  s3_ff1;



assign a1 = adda[STG_WIDTH-1:0];
assign b1 = addb[STG_WIDTH-1:0];
assign a2 = adda[STG_WIDTH*2-1:16];
assign b2 = addb[STG_WIDTH*2-1:16];
assign a3 = adda[STG_WIDTH*3-1:32];
assign b3 = addb[STG_WIDTH*3-1:32];
assign a4 = adda[STG_WIDTH*4-1:48];
assign b4 = addb[STG_WIDTH*4-1:48];

always@(posedge clk, negedge rst_n) begin
    if(!rst_n) begin
        stage1              <= 1'b0;
        stage2              <= 1'b0;
        stage3              <= 1'b0;
        o_en                <= 1'b0;
    end
    else begin
        stage1              <= i_en;
        stage2              <= stage1;
        stage3              <= stage2;
        o_en                <= stage3;
    end
end

always@(posedge clk, negedge rst_n) begin
    if(!rst_n) begin
       a2_ff1       <= 'd0;   
       b2_ff1       <= 'd0;
       a3_ff1       <= 'd0;
       b3_ff1       <= 'd0;
       a3_ff2       <= 'd0;
       b3_ff2       <= 'd0;
       a4_ff1       <= 'd0;
       b4_ff1       <= 'd0;
       a4_ff2       <= 'd0;
       b4_ff2       <= 'd0;
       a4_ff3       <= 'd0;
       b4_ff3       <= 'd0;
    end
    else begin
       a2_ff1       <= a2;   
       b2_ff1       <= b2;
       a3_ff1       <= a3;
       b3_ff1       <= b3;
       a3_ff2       <= a3_ff1;
       b3_ff2       <= b3_ff1;
       a4_ff1       <= a4;
       b4_ff1       <= b4;
       a4_ff2       <= a4_ff1;
       b4_ff2       <= b4_ff1;
       a4_ff3       <= a4_ff2;
       b4_ff3       <= b4_ff2;
    end
end




always@(posedge clk, negedge rst_n) begin
    if(!rst_n) begin
        s1_ff1          <= 'd0;
        s1_ff2          <= 'd0; 
        s1_ff3          <= 'd0;              
        s2_ff1          <= 'd0;
        s2_ff2          <= 'd0;              
        s3_ff1          <= 'd0;
    end
    else begin
        s1_ff1          <= s1;
        s1_ff2          <= s1_ff1;
        s1_ff3          <= s1_ff2;
        s2_ff1          <= s2;
        s2_ff2          <= s2_ff1;
        s3_ff1          <= s3;

    end
 end

always@(posedge clk, negedge rst_n) begin
    if(!rst_n) begin
       c1           <= 1'b0; 
       s1           <= 'd0; 
    end
    else if(i_en)
        {c1,s1}     <= a1+b1;
    else begin
        c1          <= c1;
        s1          <= s1;
    end
end

always@(posedge clk, negedge rst_n) begin
    if(!rst_n) begin
       c2           <= 1'b0; 
       s2           <= 'd0; 
    end
    else if(stage1)
        {c2,s2}     <= a2_ff1+b2_ff1+c1;
    else begin
        c2          <= c2;
        s2          <= s2;
    end
end

always@(posedge clk, negedge rst_n) begin
    if(!rst_n) begin
       c3           <= 1'b0; 
       s3           <= 'd0; 
    end
    else if(stage2)
        {c3,s3}     <= a3_ff2+b3_ff2+c2;
    else begin
        c3          <= c3;
        s3          <= s3;
    end
end

always@(posedge clk, negedge rst_n) begin
    if(!rst_n) begin
       c4           <= 1'b0; 
       s4           <= 'd0; 
    end
    else if(stage3)
        {c4,s4}     <= a4_ff3+b4_ff3+c3;
    else begin
        c4          <= c4;
        s4          <= s4;
    end
end

assign result = {c4, s4, s3_ff1, s2_ff2, s1_ff3};


endmodule"
Please act as a professional verilog designer.,"Please act as a professional verilog designer.

Implement the design of 4bit unsigned number pipeline multiplier. 
Module name:  
    multi_pipe               
Input ports：
    input 						clk 		,   
	input 						rst_n		,
	input	[size-1:0]			mul_a		,
	input	[size-1:0]			mul_b		
Output ports：
    output	reg	[size*2-1:0]	mul_out	","`timescale 1ns/1ns

module verified_multi_pipe#(
	parameter size = 4
)(
	input 						clk 		,   
	input 						rst_n		,
	input	[size-1:0]			mul_a		,
	input	[size-1:0]			mul_b		,
 
 	output	reg	[size*2-1:0]	mul_out		
);
    //parameter 
    parameter N = size * 2;
    //defination
    wire [N - 1 : 0] temp [0 : 3];
    
    reg [N - 1 : 0] adder_0;
    reg [N - 1 : 0] adder_1;
    
    //output 
    genvar i;
    generate
        for(i = 0; i < 4; i = i + 1)begin : loop
            assign temp[i] = mul_b[i] ? mul_a << i : 'd0;
        end
    endgenerate
    
    always@(posedge clk or negedge rst_n)begin
        if(!rst_n) adder_0 <= 'd0;
        else adder_0 <= temp[0] + temp[1];
    end
    
    always@(posedge clk or negedge rst_n)begin
        if(!rst_n) adder_1 <= 'd0;
        else adder_1 <= temp[2] + temp[3];
    end
    
    always@(posedge clk or negedge rst_n)begin
        if(!rst_n) mul_out <= 'd0;
        else mul_out <= adder_0 + adder_1;
    end
endmodule
"
