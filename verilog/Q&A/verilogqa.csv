instruction,input,output,,,,,
Do bitwise operations distribute over addition?,"I'm looking at an algorithm I'm trying to optimize, and it's basically a lot of bit twiddling, followed by some additions in a tight feedback.   If I could use carry-save addition for the adders, it would really help me speed things up, but I'm not sure if I can distribute the operations over the addition.

Specifically if I represent:

  a = sa+ca  (state + carry)
  b = sb+cb


can I represent (a >>> r) in terms of s and c?
How about a | b and a &amp; b?","Think about it...

sa = 1    ca = 1
sb = 1    cb = 1
a = sa + ca = 2
b = sb + cb = 2
(a | b) = 2
(a &amp; b) = 2
(sa | sb) + (ca | cb) = (1 | 1) + (1 | 1) = 1 + 1 = 2 # Coincidence?
(sa &amp; sb) + (ca &amp; cb) = (1 &amp; 1) + (1 &amp; 1) = 1 + 1 = 2 # Coincidence?


Let's try some other values:

sa = 1001   ca = 1   # Binary
sb = 0100   cb = 1
a = sa + ca = 1010
b = sb + cb = 0101
(a | b) = 1111
(a &amp; b) = 0000
(sa | sb) + (ca | cb) = (1001 | 0101) + (1 | 1) = 1101 + 1 = 1110 # Oh dear!
(sa &amp; sb) + (ca &amp; cb) = (1001 &amp; 0101) + (1 &amp; 1) = 0001 + 1 = 2    # Oh dear!


So, proof by 4-bit counter example that you cannot distribute AND or OR over addition.

What about '>>>' (unsigned or logical right shift).  Using the last example values, and r = 1:

sa = 1001
ca = 0001
sa &gt;&gt;&gt; 1 = 0101
ca &gt;&gt;&gt; 1 = 0000
(sa &gt;&gt;&gt; 1) + (ca &gt;&gt;&gt; 1) = 0101 + 0000 = 0101
(sa + ca) &gt;&gt;&gt; 1 = (1001 + 0001) &gt;&gt;&gt; 1 = 1010 &gt;&gt;&gt; 1 = 0101  # Coincidence?


Let's see whether that is coincidence too:

sa = 1011
ca = 0001
sa &gt;&gt;&gt; 1 = 0101
ca &gt;&gt;&gt; 1 = 0000
(sa &gt;&gt;&gt; 1) + (ca &gt;&gt;&gt; 1) = 0101 + 0000 = 0101
(sa + ca) &gt;&gt;&gt; 1 = (1011 + 0001) &gt;&gt;&gt; 1 = 1100 &gt;&gt;&gt; 1 = 0110  # Oh dear!


Proof by counter-example again.

So logical right shift is not distributive over addition either.",,,,,
What do curly braces mean in Verilog?,"I am having a hard time understanding the following syntax in Verilog:

input  [15:0] a;      // 16-bit input
output [31:0] result; // 32-bit output
assign result = {{16{a[15]}}, {a[15:0]}};


I know the assign statement will wire something up to the result bus using wires and combinational logic, but what's up with the curly braces and 16{a[15]}?","The curly braces mean concatenation, from most significant bit (MSB) on the left down to the least significant bit (LSB) on the right.  You are creating a 32-bit bus (result) whose 16 most significant bits consist of 16 copies of bit 15 (the MSB) of the a bus, and whose 16 least significant bits consist of just the a bus (this particular construction is known as sign extension, which is needed e.g. to right-shift a negative number in two's complement form and keep it negative rather than introduce zeros into the MSBits).
For what it's worth, the nested curly braces around a[15:0] are superfluous.",,,,,
VHDL: how to set a value on an inout port?,"I am trying to test a VHDL component, but I can't seem to get this one inout port to give me any behaviour. I've tried setting the port to everything from '1' to '-', but it still comes up as 'U' in simulation. Any sugestions what might be wrong? ","For Inout port (for example in RAM): 

....
port(
    data    :inout std_logic_vector (DATA_WIDTH-1 downto 0);
....
-- Memory Write Block
-- Write Operation : When we = 1, cs = 1
  MEM_WRITE: process (address, cs, we, data, address_1, cs_1, we_1, data_1) begin
    if (cs = '1' and we = '1') then
       mem(conv_integer(address)) &lt;= data;
    end if;
  end process;

 -- Tri-State Buffer control
  data &lt;= data_out when (cs = '1' and oe = '1' and we = '0') else (others=&gt;'Z');

 -- Memory Read Block
  MEM_READ: process (address, cs, we, oe, mem) begin
    if (cs = '1' and we = '0' and oe = '1') then
      data_out &lt;= mem(conv_integer(address));
    else
      data_out &lt;= (others=&gt;'0');
    end if;
  end process;


You assign data read and write for inout with a condition. When data is read, it is driven by another module. When it writes, it is driven by internal.


When driven by another module (as in signal), data is resolved between all 'Z' and a vector ""0101010"" for example. The data will driven as ""0101010"".
In the other case: the other module must drive data by all ""Z"" and then the internal signal can put its value to data.
",,,,,
Which programming language has very short context-free Grammar in its formal specification?,"What programming language has short and beautiful grammars (in EBNF)?

Some languages are easer to be parsed. Some time ago I have created a simple VHDL parser, but it was very slow. Not because it is implemented completely in Python, but because VHDL grammar (in EBNF) is huge. The EBNF of Python is beautiful but it is not very short.

I suggest that many functional programming languages like LISP have short simple grammars, but I am interested in a more popular simple imperative language like C or Bash.","I haven't compared, but Lua is a language renowned for its simple syntax. The BNF is at the very end of this reference manual: http://www.lua.org/manual/5.1/manual.html .",,,,,
Open-source field-programmable gate array (FPGA) development tools,"I want to pick up FPGA programming. I've heard all types of horror stories of proprietary tools. Is there any entirely open-source tool chain available?

If not, how should I learn this? My background: familiar with Scheme, C++, assembly, and MIPS architecture.",Icarus is an open source Verilog implementation. You will still need the tool chain from your FPGA vendor to get the code on the FPGA itself.,,,,,
How to share register and bit field definitions between a device driver and the FPGA it controls,"Are there any good, existing software tools available to assist in generating C header files with appropriate #defines for register offsets as well as bit definitions from VHDL?  If any such tools do exist, what restrictions to they place on the VHDL and how are things that should be exported designated?

So far, I've found these tools but they aren't exactly what I'm looking for:


Vregs by Veripool
SpectraReg by PDTi
Bitwise by Duolog


Based upon these tools I am also interested if the proper workflow is to generate both the C and the VHDL rather than trying to go directly from VHDL (perhaps with extra tags in the comments) to C.","I think that final though that was bugging you is sending you in the right direction.  And I'd agree with RedGlyph in that you should consider changing your work flow a little.  

Have you thought about having one 'master document' for your control register information and generated everything automatically from this - RTL, testbench code, driver software headers and documentation?

I've worked on projects where the control info was kept in one master spreadsheet and everything we needed generated from this.  On one family of chips, I'd written a few Python scripts to generate this stuff from CSV files exported from the spreadsheet.  On another project, the spreadsheet contained macros to generate the RTL files etc that we needed.

Writing in-house scripts is all fine and good as you've total control over them and know how they work in detail.  But remember that you have to spend time supporting these scripts and updating them to do new things.  And consider what would happen if whoever wrote these scripts decided to go get a new job - would anyone else be familiar enough with the scripts to modify them?  We're considering buying in a 3rd party tool for the reasons mentioned above.

I've also worked on projects were the documentation and header files was back-ported from the RTL -it was a nightmare.  Documentation usually lagged behind the design, and often control fields would 'go missing'.  I'd rather not be involved in such a project again ;)",,,,,
Experiences with Test Driven Development (TDD) for logic (chip) design in Verilog or VHDL,"I have looked on the web and the discussions/examples appear to be for traditional software development.  Since Verilog and VHDL (used for chip design, e.g. FPGAs and ASICs) are similar to software development C and C++ it would appear to make sense.  However they have some differences being fundamentally parallel and requiring hardware to fully tests.

What experiences, good and bad, have you had?  Any links you can suggest on this specific application?

Edits/clarifications:
10/28/09:  I'm particularly asking about TDD.  I'm familiar with doing test benches, including self-checking ones.  I'm also aware that SystemVerilog has some particular features for test benches.

10/28/09:  The questions implied include 1) writing a test for any functionality, never using waveforms for simulation and 2) writing test/testbenches first.

11/29/09: In Empirical Studies Show Test Driven Development Improves Quality they report for (software) TDD ""The pre-release defect density of the four products, measured as defects per thousand lines of code, decreased between 40% and 90% relative to the projects that did not use TDD. The teams' management reported subjectively a 15â€?5% increase in initial development time for the teams using TDD, though the teams agreed that this was offset by reduced maintenance costs.""  The reduced bugs reduces risk for tape-out, at the expense of moderate schedule impact.  This also has some data.

11/29/09: I'm mainly doing control and datapath code, not DSP code.  For DSP, the typical solution involves a Matlab bit-accurate simulation.

03/02/10: The advantage of TDD is you make sure the test fails first.  I suppose this could be done with assertions too.","I write code for FPGAs, not ASICS... but TDD is my still my preferred approach.  I like to have a full suite of tests for all the functional code I write, and I try (not always successfully) to write testcode first.  Staring at waveforms always happens at some point when you're debugging, but it's not a good way of validating your code (IMHO).

Given the difficulty of performing proper tests in the real hardware (stimulating corner cases is particularly hard) and the fact that a VHDL-compile takes seconds (vs a ""to hardware"" compile that takes many minutes (or even hours)), I don't see how anyone can operate any other way!

I also build assertions into the RTL as I write it to catch things I know shouldn't ever happen.  Apparantly this is seen as a bit ""weird"", as there's a perception that verification engineers write assertions and RTL designers don't.  But mostly I'm my own verification engineer, so maybe that's why!",,,,,
Tool for drawing timing diagrams,"Recently I am working with a hardware design group developing an ASIC. And I am drawing a lot of timing diagrams for which I am using Microsoft Excel, as it is easy to import into Word document. But, things are getting more and more difficult with Excel.

What can be used to draw timing diagrams? Is there any easy tool out there?","I have the same problem and tried the following tools:


drawtiming
timing (LaTeX)
tikz-timing (LaTeX)
Microsoft Visio


After trying all these I now ended up using Visio and pen&amp;pencil. All other programs lacked support for adding arrows/relationships between signals easily. In Visio, such things are absolutely easy. And you can export the diagrams directly to PowerPoint or even as PDF for using them in LaTeX.",,,,,
How can I separate long statements into lines in Verilog,"For example, I have a single long statement:

    $display(""input_data: %x, 
              output_data: %x,
              result: %x"",
              input_data,
              output_data,
              result);


How can I make it into single statement and multiple lines in Verilog?","You need to break up the quoted string.  Here is one way:

module tb;

initial begin
    integer input_data  = 1;
    integer output_data = 0;
    integer result      = 55;
    $display(""input_data: %x ""  , input_data,
             ""output_data: %x "" , output_data,
             ""result: %x ""      , result);
end

endmodule


Outputs:

input_data: 00000001 output_data: 00000000 result: 00000037 
",,,,,
What' s the difference between <= and := in VHDL,"Currently, I am learning some FPGA design techniques using VHDL, my problem is whether we can use := and &lt;= interchangeably in VHDL or not, though I've seen the use of := in constants declarations and &lt;= in assignments? Thanks in advance!","The rules are a little more complex than this, but basically: you use &lt;= to do signal assignment, which takes effect on the next delta cycle. You use := to do variable assignment, which takes place immediately. So if you have a signal, you always use &lt;=. If you have a variable, you always use :=.

Some places where this is not quite that case that you will commonly run into, for instance, initialization, where := is used even for signals.

So:

signal some_signal : std_logic := '0'; -- 0 initial value
...
variable some_variable : std_logic := '0'; -- 0 initial value
...
some_signal &lt;= '1'; -- will assign 1 at the next time step (delta cycle)
...
some_variable := '1'; -- assigns 1 immediately
",,,,,
Division in verilog,"I am teaching myself verilog. The book I am following stated in the introduction chapters that to perform division we use the '/' operator or '%' operator. In later chapters it's saying that division is too complex for verilog and cannot be synthesized, so to perform division it introduces a long algorithm.

So I am confused, can't verilog handle simple division? is the / operator useless?","It all depends what type of code you're writing.

If you're writing code that you intend to be synthesised, that you intend to go into an FPGA or ASIC, then you probably don't want to use the division or modulo operators. When you put any arithmetic operator in RTL the synthesiser instances a circuit to do the job; An adder for + &amp; -; A multiplier for *. When you write / you're asking for a divider circuit, but a divider circuit is a very complex thing. It often takes multiple clock cycles, and may use look up tables. It's asking a lot of a synthesis tool to infer what you want when you write a / b.

(Obviously dividing by powers of 2 is simple, but normally you'd use the shift operators)

If you're writing code that you don't want to be synthesised, that is part of a test bench for example, then you can use division all you want.

So to answer your question, the / operator isn't useless, but you have be concious of where and why you're using it. The same is true of *, but to a lesser degree. Multipliers are quite expensive, but most synthesisers are able to infer them.",,,,,
Is initialization necessary?,"In VHDL, is initialization necessary when creating a signal or a vector? 
What happens if one forgets to initialize a signal or integer value?              ","In simulation, if you do not set an initial value, each element of your vector will get the default value (this is defined by the VHDL language specification). For enum types, this is the first element defined in the enumeration type: booleans will be false, std_logic will be 'U' (undefined). Note that 'U' has no meaning in electrical circuits. It is merely a hint for the verification engineer that you don't know which value the flip-flop has at power-on. 

After synthesis: FPGA synthesizers will use the initial value that you set as the ""power on"" value of the flip-flops and memories if the target technology supports this! If the technology does not support a forced initial value (and for ASICs), the initial value at power-on is not known. It could be 1 or 0. (See for example: http://quartushelp.altera.com/11.0/mergedProjects/hdl/vhdl/vhdl_pro_power_up_state.htm)

Two possible styles: 


Choose an explicit initial value, with or without explicit reset circuits (usually for modern FPGAs)
Set 'U' as initial value, and have a proper reset circuit to force a known reset value


If you go with the first choice, be sure to check if your target technology supports this style!",,,,,
Best way to learn VHDL?,"I want to learn VHDL but I really don't know from where to start.

I want some advice and explanation about the software I need to get started.

I would like also to get some references in order to learn it efficiently without wasting time by searching on the Internet, since there are a lot of e-books and tutorials and I'm really confused about which one to choose.","I suggest, you have good background in Digital Design. If not, start with any edition of ""Digital Design"" book or, alternatively ""Contemporary logic design"".


Download GHDL (VHDL compiler/simulator using GCC technology) or a little more friendly software tool boot.
Learn how to build a VHDL program with GHDL. Try to compile simple
""Hello, world!"".
Learn VHDL syntax with the open-source book Free Range VHDL. It is very important step.
",,,,,
Approximate e^x,"I'd like to approximate the ex function.

Is it possible to do so using multiple splines type based approach? i.e between x1 and x2, then 


  y1 = a1x + b1, between x2 and x3, 


then 


  y2 = a2x + b2


etc

This is for dedicated fpga hardware and not a general purpose CPU. As such I need to create the function myself. Accuracy is much less of a concern. Furthermore I can't really afford more than one multiplication circuit and/or multiple shifts/adders. Also I want something much smaller than a CORDIC function, in fact size is critical.","How about a strategy like this that uses the formula


  ex = 2 x/ln(2)



Precalculate 1/ln(2)
Multiply this constant by your argument (1 multiplication)
Use binary shifts to raise 2 to the integer portion of the power (assumes exp+mantissa format)
Adjust based on the fractional power-of-2 remainder (likely a second multiplication)


I realize this is not a complete solution, but it does only require a single multiplication and reduces the remaining problem to approximating a fractional power of 2, which should be easier to implement in hardware.

Also, if your application is specialized enough, you could try to re-derive all of the numerical code that will run on your hardware to be in a base-e number system and implement your floating point hardware to work in base e as well.  Then no conversion is needed at all.",,,,,
Why do I need to redeclare VHDL components before instantiating them in other architectures?,"I've been scratching my head since my first VHDL class and decided to post my question here.

Given that I have a declared entity (and also an architecture of it) and want to instantiate it inside another architecture, why is it that I seemingly have to redeclare the ""entity"" (component) inside this containing architecture before instantiating it?

Isn't the compiler smart enough to match an instantiation to its architecture just by its name? Where is the need for the component declaration?","You can directly instantiate the component, if desired:

  MyInstantiatedEntity : entity work.MyEntity_E
    generic map (
        config          =&gt; whatever)
    port map (
        clk             =&gt; signal1,
        clk_vid         =&gt; signal2,
        ...


Creating a component declaration gives you the extra ability to change what gets bound to the instantiation via a configuration specification or similar.",,,,,
"VHDL Case/When: multiple cases, single clause","Inside a process I have something like this:

CASE res IS
  WHEN ""00"" =&gt; Y &lt;= A;
  WHEN ""01"" =&gt; Y &lt;= A;
  WHEN ""10"" =&gt; Y &lt;= B;
  WHEN ""11"" =&gt; Y &lt;= C;
  WHEN OTHERS =&gt; Y &lt;= 'X';
END CASE;


Note that case ""00"" and ""01"" get the same value. Is there a correct syntax for something like

WHEN ""00"", ""01""  =&gt; ?

Extra note: There's far more to this than Y being changed, I just used that for simplicity. So the case/when is necessary.","You can separate multiple choices with the ""pipe"" or bar symbol.  The proper syntax for your example is:

CASE res IS
  WHEN ""00"" | ""01"" =&gt; Y &lt;= A;
  WHEN ""10"" =&gt; Y &lt;= B;
  WHEN ""11"" =&gt; Y &lt;= C;
  WHEN OTHERS =&gt; Y &lt;= 'X';
END CASE;
",,,,,
How commonly used are the xilinx chips?,"I'm beginning to learn embedded with C (and maybe some C++) and someone from the office said they're willing to donate a free xilinx chip they've got sitting on their shelf. I was thinking more along the lines of an Arduino, especially that the Arduino tutorials and sample projects are abundant. 


Can someone confirm how xilinx chips compare to arduino? Are they known within the industry to be more ""real world"" in any way? or not?
Are there specific xilinx chips (maybe older models) that I should avoid, at least while I'm still starting out?
Do they have a relatively steeper learning curve than an Arduino due to lack of tutorials or not?


I'm interested in hearing whatever comes to your mind when you hear xilinx as opposed to Arduino. I know very little about chips, let alone this particular one, so it's very hard to have any informed comparison.","You are comparing chalk and cheese.  Xilinx is a company, not a chip and Arduino is an open development platform based on Atmel AVR microcontroller.

Also 'a chip' alone is probably useless to you; it will have to be assembled onto a development board with subsidiary components and power supplies etc.

Xilinx make FPGAs and other programmable logic devices.  It is possible to have an FPGA with a hard or soft core processor embedded (i.e. a processor defined in FPGA logic gates), and for that core to be programmed in C, but if you are starting out, how many balls do you want to juggle at once?  Such a core will be useless without the ability also to synthesize the peripheral hardware necessary to make it do something useful.  They are used in highly specialised applications where the core and peripheral set need to be tightly coupled to the application.  They are often used in applications where standards are still under development (such as wireless communications), where both firmware and software may need to change in-field to support changes.  Another use of FPGAs is in directly implementing algorithms in hardware to take advantage of the parallelism and pipe-lining that they make possible offering massive acceleration compared to software solutions..

While Arduino, or more specifically AVR  (there are other AVR development platforms available) can be programmed in C and C++, if you are serious about using C++ in embedded systems, a 32-bit platform may be more appropriate (as well as having performance advantages).  A development board based on an ARM Cortex-M3 or ARM 7 would be a good start, especially since ARM is also a common choice for soft-core processors on FPGAs if you eventually progress to that.",,,,,
Creating a VHDL backend for LLVM?,"LLVM is very modular and allows you to fairly easily define new backends.  However most of the documentation/tutorials on creating an LLVM backend focus on adding a new processor instruction set and registers.  I'm wondering what it would take to create a VHDL backend for LLVM?  Are there examples of using LLVM to go from one higher level language to another?

Just to clarify: are there examples of translating LLVM IR to a higher level language instead of to an assembly language?  For example: you could read in C with Clang, use LLVM to do some optimization and then write out code in another language like Java or maybe Fortran.","Yes ! 

There are many LLVM back-end targeting VHDL/Verilog around :


(open source) Legup paper
(commercial) Xilinx HLS
(online) C-to-verilog


And I know there are many others...

The interesting thing about such low-level representations as LLVM or GIMPLE (also called RTL by the the way) is that they expose static-single assignments (SSA) forms : this can be translated to hardware quite directly, as SSA can be seen as a tree of multiplexers... ",,,,,
What is the function of $readmemh and $writememh in Verilog?,"I have been looking at some Verilog testbench code that heavily uses $readmemh and $writememh.
I have a vague understanding that these functions basically read to and write from memory. What is their specific function and how do they work?","I agree its not too easy to find something about readmem/writemem. You can find a little bit here:
https://www.fullchipdesign.com/readmemh.htm
Anyway there is not too much to say about these functions, the syntax is:
$readmem[hb](&quot;File&quot;, ArrayName, StartAddr, EndAddr)
$writemem[hb](&quot;File&quot;, ArrayName, StartAddr, EndAddr)

Verilog is very picky about the file format, the number of bit in the text file have to match the number of bits in the array.
I recommend you play around a little bit by defining an array, filling it up with data write it out with writememh/writememb and print it out afterwards.
Something like this should get you started (not tried out!).
integer i;
reg [7:0] memory [0:15]; // 8 bit memory with 16 entries

initial begin
    for (i=0; i&lt;16; i++) begin
        memory[i] = i;
    end
    $writememb(&quot;memory_binary.txt&quot;, memory);
    $writememh(&quot;memory_hex.txt&quot;, memory);
end
",,,,,
Concatenating bits in VHDL,"How do you concatenate bits in VHDL? I'm trying to use the following code:

Case b0 &amp; b1 &amp; b2 &amp; b3 is 
 ...

and it throws an error

Thanks","The concatenation operator '&amp;' is allowed on the right side of the signal assignment operator '&lt;=', only",,,,,
Program for drawing VHDL block diagrams?,"Is there any free program out there that can parse a collection of VHDL files and build a block diagram from them?

I'm looking more for a program that will build a block diagram image to go along with the documentation for the hierarchy, similar to the way javadoc builds a class diagram after parsing the documentation for a series of classes.","There's nothing open-sourced anyways.  A while back, I looked for something simliar for verilog designs with no success.  ",,,,,
Verilog automatic task,"What does it mean if a task is declared with the automatic keyword in Verilog?

task automatic do_things;
  input [31:0] number_of_things;
  reg [31:0] tmp_thing;
  begin
    // ...
  end
endtask;


Note: This question is mostly because I'm curious if there are any hardware programmers on the site. :)","It means that the task is re-entrant - items declared within the task are dynamically allocated rather than shared between different invocations of the task.

You see - some of us do Verilog...  (ugh)",,,,,
"How do I set output flags for ALU in ""Nand to Tetris"" course?","Although I tagged this homework, it is actually for a course which I am doing on my own for free. Anyway, the course is called ""From Nand to Tetris"" and I'm hoping someone here has seen or taken the course so I can get some help. I am at the stage where I am building the ALU with the supplied hdl language. My problem is that I can't get my chip to compile properly. I am getting errors when I try to set the output flags for the ALU. I believe the problem is that I can't subscript any intermediate variable, since when I just try setting the flags to true or false based on some random variable (say an input flag), I do not get the errors. I know the problem is not with the chips I am trying to use since I am using all builtin chips.

Here is my ALU chip so far:

/**
 * The ALU.  Computes a pre-defined set of functions out = f(x,y)
 * where x and y are two 16-bit inputs. The function f is selected 
 * by a set of 6 control bits denoted zx, nx, zy, ny, f, no.
 * The ALU operation can be described using the following pseudocode:
 *     if zx=1 set x = 0       // 16-bit zero constant
 *     if nx=1 set x = !x      // Bit-wise negation
 *     if zy=1 set y = 0       // 16-bit zero constant
 *     if ny=1 set y = !y      // Bit-wise negation
 *     if f=1  set out = x + y // Integer 2's complement addition
 *     else    set out = x &amp; y // Bit-wise And
 *     if no=1 set out = !out  // Bit-wise negation
 *
 * In addition to computing out, the ALU computes two 1-bit outputs:
 *     if out=0 set zr = 1 else zr = 0 // 16-bit equality comparison
 *     if out&lt;0 set ng = 1 else ng = 0 // 2's complement comparison
 */

CHIP ALU {

IN  // 16-bit inputs:
    x[16], y[16],
    // Control bits:
    zx, // Zero the x input
    nx, // Negate the x input
    zy, // Zero the y input
    ny, // Negate the y input
    f,  // Function code: 1 for add, 0 for and
    no; // Negate the out output

OUT // 16-bit output
    out[16],

    // ALU output flags
    zr, // 1 if out=0, 0 otherwise
    ng; // 1 if out&lt;0, 0 otherwise

PARTS:
// Zero the x input
Mux16( a=x, b=false, sel=zx, out=x2 );

// Zero the y input
Mux16( a=y, b=false, sel=zy, out=y2 );

// Negate the x input
Not16( in=x, out=notx );
Mux16( a=x, b=notx, sel=nx, out=x3 );

// Negate the y input
Not16( in=y, out=noty );
Mux16( a=y, b=noty, sel=ny, out=y3 );

// Perform f
Add16( a=x3, b=y3, out=addout );
And16( a=x3, b=y3, out=andout );
Mux16( a=andout, b=addout, sel=f, out=preout );

// Negate the output
Not16( in=preout, out=notpreout );
Mux16( a=preout, b=notpreout, sel=no, out=out );

// zr flag
Or8way( in=out[0..7], out=zr1 );   // PROBLEM SHOWS UP HERE
Or8way( in=out[8..15], out=zr2 );
Or( a=zr1, b=zr2, out=zr );

// ng flag
Not( in=out[15], out=ng );

}


So the problem shows up when I am trying to send a subscripted version of 'out' to the Or8Way chip. I've tried using a different variable than 'out', but with the same problem. Then I read that you are not able to subscript intermediate variables. I thought maybe if I sent the intermediate variable to some other chip, and that chip subscripted it, it would solve the problem, but it has the same error. Unfortunately I just can't think of a way to set the zr and ng flags without subscripting some intermediate variable, so I'm really stuck!

Just so you know, if I replace the problematic lines with the following, it will compile (but not give the right results since I'm just using some random input):

// zr flag
Not( in=zx, out=zr );

// ng flag
Not( in=zx, out=ng );


Anyone have any ideas?

Edit: Here is the appendix of the book for the course which specifies how the hdl works. Specifically look at section 5 which talks about buses and says: ""An internal pin (like v above) may not be subscripted"".

Edit: Here is the exact error I get: ""Line 68, Can't connect gate's output pin to part"". The error message is sort of confusing though, since that does not seem to be the actual problem. If I just replace ""Or8way( in=out[0..7], out=zr1 );"" with ""Or8way( in=false, out=zr1 );"" it will not generate this error, which is what lead me to look up in the appendix and find that the out variable, since it was derived as intermediate, could not be subscripted.","The solution as Pax suggested was to use an intermediate variable as input to another chip, such as Or16Way. Here is the code after I fixed the problem and debugged:

CHIP ALU {

IN  // 16-bit inputs:
    x[16], y[16],
    // Control bits:
    zx, // Zero the x input
    nx, // Negate the x input
    zy, // Zero the y input
    ny, // Negate the y input
    f,  // Function code: 1 for add, 0 for and
    no; // Negate the out output

OUT // 16-bit output
    out[16],

    // ALU output flags
    zr, // 1 if out=0, 0 otherwise
    ng; // 1 if out&lt;0, 0 otherwise

PARTS:
// Zero the x input
Mux16( a=x, b=false, sel=zx, out=x2 );

// Zero the y input
Mux16( a=y, b=false, sel=zy, out=y2 );

// Negate the x input
Not16( in=x2, out=notx );
Mux16( a=x2, b=notx, sel=nx, out=x3 );

// Negate the y input
Not16( in=y2, out=noty );
Mux16( a=y2, b=noty, sel=ny, out=y3 );

// Perform f
Add16( a=x3, b=y3, out=addout );
And16( a=x3, b=y3, out=andout );
Mux16( a=andout, b=addout, sel=f, out=preout );

// Negate the output
Not16( in=preout, out=notpreout );
Mux16( a=preout, b=notpreout, sel=no, out=preout2 );

// zr flag
Or16Way( in=preout2, out=notzr );
Not( in=notzr, out=zr );

// ng flag
And16( a=preout2, b=true, out[15]=ng );

// Get final output
And16( a=preout2, b=preout2, out=out );
}
",,,,,
Random number generation on Spartan-3E,I need to generate pseudo-random numbers for my genetic algorithm on a Spartan-3E FPGA and i want to implement it in verilog: could you give me any pointers on this?,"Typically you'd use the IEEE.math_real uniform function 

use IEEE.math_real.all;
procedure UNIFORM (variable Seed1,Seed2:inout integer; variable X:out real);


But do a tiny bit a research on pseudo random number generators (PRNGs) and you'll find many variants that are simple LFSR's - which look remarkably similar to CRC generators.

Here are several resources if you want to roll your own starting from existing, working PRNGs:

http://www.opencores.org/?do=project&amp;who=systemc_rng

http://verificationguild.com/modules.php?name=Downloads&amp;d_op=viewdownload&amp;cid=3

Here's a CRC VHDL code generator:

http://www.easics.be/webtools/crctool",,,,,
Why can't I increment this `std_logic_vector`,"What's going on here? Why am I getting an 'operator argument type mismatch', and what can I do to fix it?

--
-- 32-bit counter with enable and async reset
--
architecture synthesis1 of counter_32bit is    
signal nextvalue : std_logic_vector ( 31 downto 0 );    
begin

  --
  -- combo
  --
  nextvalue &lt;= value + 1; -- here

  --
  -- sequential
  --
  ff:process( clk, rst )
  begin

    if( rst = '1' ) then
      value &lt;= 0; -- and here...
    elsif( clk'event and ( clk ='1' ) ) then
      if( ena = '1' ) then
         value &lt;= nextvalue;
      end if;
    end if;

  end process ff;    

end synthesis1;


Thanks","you can't increment std_logic directly, you need to convert it to unsigned and the result back to std_logic_vector using the numeric_std package. 

use ieee.numeric_std.all
...
nextvalue &lt;= std_logic_vector( unsigned(value) + 1 );


See How Do Perform STD_LOGIC_VECTOR Addition Using IEEE.NUMERIC_STD for example.",,,,,
"What are the best practices for Hardware Description Languages (Verilog, VHDL etc.)","What best practices should be observed when implementing HDL code?

What are the commonalities and differences when compared to more common software development fields?","The best book on this topic is Reuse Methodology Manual.  It covers both VHDL and Verilog.

And in particular some issues that don't have an exact match in software: 


No latches
Be careful with resets
Check your internal and external timing
Use only synthesizable code
Register your outputs of all modules
Be careful with blocking vs. non-blocking assignments
Be careful with sensitive lists for combinatorial logic (or use @(*) in Verilog)


Some that are the same include


Use CM
Have code reviews
Test (simulate) your code
Reuse code when appropriate
Have an up-to-date schedule
Have a spec or use cases or an Agile customer
",,,,,
How to write a linter?,"In my day job I, and others on my team write a lot of hardware models in Verilog-AMS, a language supported primarily by commercial vendors and a few opensource simulator projects. 
One thing that would make supporting each others code more helpful would be a LINTER that would check our code for common problems and assist with enforcing a shared code formatting style. 
I of course want to be able to add my own rules and, after I prove their utility to myself, promote them to the rest of the team.. 
I don't mind doing the work that has to be done, but of course also want to leverage the work of other existing projects. 

Does having the allowed language syntax in a yacc or bison format give me a leg up? 
or should I just suck each language statement into a perl string, and use pattern matching to find the things I don't like? 

(most syntax and compilation errors are easily caught by the commercial tools.. but we have some of our own extentions.) ","lex/flex and yacc/bison provide easy-to-use, well-understood lexer- and parser-generators, and I'd really recommend doing something like that as opposed to doing it procedurally in e.g. Perl.  Regular expressions are powerful stuff for ripping apart strings with relatively-, but not totally-fixed structure.  With any real programming language, the size of your state machine gets to be simply unmanageable with anything short of a Real Lexer/Parser (tm).  Imagine dealing with all possible interleavings of keywords, identifiers, operators, extraneous parentheses, extraneous semicolons, and comments that are allowed in something like Verilog AMS, with regular expressions and procedural code alone.

There's no denying that there's a substantial learning curve there, but writing a grammar that you can use for flex and bison, and doing something useful on the syntax tree that comes out of bison, will be a much better use of your time than writing a ton of special-case string-processing code that's more naturally dealt with using a syntax-tree in the first place.  Also, what you learn writing it this way will truly broaden your skillset in ways that writing a bunch of hacky Perl code just won't, so if you have the means, I highly recommend it ;-)

Also, if you're lazy, check out the Eclipse plugins that do syntax highlighting and basic refactoring for Verilog and VHDL.  They're in an incredibly primitive state, last I checked, but they may have some of the code you're looking for, or at least a baseline piece of code to look at to better inform your approach in rolling your own.",,,,,
packed vs unpacked vectors in system verilog,"Looking at some code I'm maintaining in System Verilog I see some signals that are defined like this:

node [range_hi:range_lo]x;


and others that are defined like this:

node y[range_hi:range_lo];


I understand that x is defined as packed, while y is defined as unpacked.  However, I have no idea what that means.

What is the difference between packed and unpacked vectors in System Verilog?

Edit: Responding to @Empi's answer, why should a hardware designer who's writing in SV care about the internal representation of the array?  Are there any times when I shouldn't or can't use packed signals?","This article gives more details about this issue:
http://electrosofts.com/systemverilog/arrays.html, especially section 5.2. 


  A packed array is a mechanism for subdividing a vector into subfields which can be conveniently accessed as array elements. Consequently, a packed array is guaranteed to be represented as a contiguous set of bits. An unpacked array may or may not be so represented. A packed array differs from an unpacked array in that, when a packed array appears as a primary, it is treated as a single vector.
",,,,,
Finding the next in round-robin scheduling by bit twiddling,"Consider the following problem. You have a bit-string that represents the current scheduled slave in one-hot encoding. For example, ""00000100"" (with the leftmost bit being #7 and rightmost #0) means that slave #2 is scheduled. 

Now, I want to pick the next scheduled slave in a round-robin scheduling scheme, with a twist. I have a ""request mask"" which says which slaves actually want to be scheduled. The next slave will be picked only from those that want to.

Some examples (assume round-robin scheduling is done by rotating left). 
Example1:


Current: ""00000100""
Mask: ""01100000""
Next schedule: ""00100000"" - in normal round-robin, #3 and then #4 should come after #2, but they don't request, so #5 is picked.


Example2:


Current: ""01000000""
Mask: ""00001010""
Next: ""00000010"" - because scheduling is done by cycling left, and #1 is the first requesting slave in that order.




Now, this can be easily coded in a loop, I know. But I actually want to get my result by a bit-twiddling operation, without loops. The motivation: I want to implement this in hardware (in an FPGA) in VHDL/Verilog.

A bonus is to make up an algorithm that's generic for any amount of slaves N.

By the way, this is not a homework question. It's an important problem whenever one wants to schedule slaves in some manner, and condition the scheduling by the slaves' requests. My current solution is somewhat ""heavy"" and I wanted to know if I'm missing something obvious.","I've found the following Verilog code for implementing the task in the Altera advanced synthesis cookbook. 

// 'base' is a one hot signal indicating the first request
// that should be considered for a grant.  Followed by higher
// indexed requests, then wrapping around.
//

module arbiter (
    req, grant, base
);

parameter WIDTH = 16;

input [WIDTH-1:0] req;
output [WIDTH-1:0] grant;
input [WIDTH-1:0] base;

wire [2*WIDTH-1:0] double_req = {req,req};
wire [2*WIDTH-1:0] double_grant = double_req &amp; ~(double_req-base);
assign grant = double_grant[WIDTH-1:0] | double_grant[2*WIDTH-1:WIDTH];

endmodule


It uses subtraction (only once, though), so conceptually it's quite similar to Doug's solution.",,,,,
Can anyone recommend a good resource for learning VHDL?,"Can anyone recommend a good book for learning VHDL? Or failing that, any good resource?","The unfortunate problem with VHDL is that there are loads of outdated, poorly styled and outright wrong resources out there; both electronic and in print.  

Part of the art of mastering VHDL is knowing how to filter these out.  The following is the filtering I did in my previous life as a hardware designer.  I hope it is helpful to you.

These are the things you want to read, or own, or download:


Book: ""The Designer's Guide to VHDL"" by Peter J. Ashenden (ISBN 1-55860-270-4).  It does not waste your time by telling you to use obsolete or vendor specific libraries; it does not explain VHDL assuming you are a software engineer who wants to know about HDLs; it does not explain VHDL by assuming you are a hardware engineer who wants to know about HDLs.  It does not advocate a vendor and its solutions (working with a particular vendor toolchain is a separate issue, and I've found it helpful to keep learning VHDL and vendor-specific separate).  What it does do is introduce VHDL from the right perspective: as a language used to describe discrete event systems, from which smart programs can extract something that can end up as being hardware.  It also describes what the standard language constructs are, which standards of the language exist, and what are their specific properties.  Modern tools are ever more adherent to the standards, so this info is way more useful than a bunch of analogies that some other books (to remain nameless) seem to purport.  Buy it, it's worth every cent.
The newsgroup comp.lang.vhdl is inhabited by people who are very knowledgeable about modern VHDL and can give you sane advice if you can ask questions well.  To be able to do the latter, read the book mentioned above.  Wading through numerous VHDL forums is in general a waste of time, as the information content there is generally drowned in noise.
Know your tools.  Get yourself a PDF of the toolchain you will be using and know it very well.  The more, the better.  Especially know their limitations.  Tools often have idiosyncrasies that you will need to work around or play along with to get things just right.  For instance, you will probably want to write the portable behavioral code; except for the parts that are either technology-specific, or are such that your tool happens to synthesize them wrong.
Know where to find sane VHDL resources.  An example of a sane resource is the Hamburg VHDL archive (at: http://tams-www.informatik.uni-hamburg.de/research/vlsi/vhdl/)  I found through using the sampling method that the signal-to-noise ratio on that particular website is pretty high.  Use it.
A fairly obscure book about hardware synthesis (for the really curious; and written from an academic perspective) is Giovanni de Micheli's ""Synthesis and Optimization of Digital Circuits"" (http://si2.epfl.ch/~demichel/publications/mcgraw/index.html) which may shed some light on the hardware synthesis methods -- though a substantial body of work has been done to improve the results given there since.  You may want to borrow this one from a nearby library and leaf through it.
",,,,,
CUDA or FPGA for special purpose 3D graphics computations?,"I am developing a product with heavy 3D graphics computations, to a large extent closest point and range searches. Some hardware optimization would be useful. While I know little about this, my boss (who has no software experience) advocates FPGA (because it can be tailored), while our junior developer advocates GPGPU with CUDA, because its cheap, hot and open. While I feel I lack judgement in this question, I believe CUDA is the way to go also because I am worried about flexibility, our product is still under strong development.

So, rephrasing the question, are there any reasons to go for FPGA at all? Or is there a third option?","I investigated the same question a while back. After chatting to people who have worked on FPGAs, this is what I get:


FPGAs are great for realtime systems, where even 1ms of delay might be too long. This does not apply in your case;
FPGAs can be very fast, espeically for well-defined digital signal processing usages (e.g. radar data) but the good ones are much more expensive and specialised than even professional GPGPUs;
FPGAs are quite cumbersome to programme. Since there is a hardware configuration component to compiling, it could take hours. It seems to be more suited to electronic engineers (who are generally the ones who work on FPGAs) than software developers.


If you can make CUDA work for you, it's probably the best option at the moment. It will certainly be more flexible than a FPGA. 

Other options include Brook from ATI, but until something big happens, it is simply not as well adopted as CUDA. After that, there's still all the traditional HPC options (clusters of x86/PowerPC/Cell), but they are all quite expensive.

Hope that helps.",,,,,
Component Instantiation vs Entity Instantiation in VHDL,"I have experience with Verilog/SystemVerilog but I am new to VHDL and I am trying to figure out when I should use component instantiation or entity instantiation.
By component instantiation I mean the legacy way of declaring components of an entity before instantiating them. On the other hand, entity instantiation, which has been introduced with VHDL-93, allows you to declare an entity directly without specifying the component. 
Related Article

It seems to me that Entity Instantiation is always preferable unless you don't have an architecture implemented yet and you just want to define a black box. 

This is a Related Question that I've found but it does fully address my doubts. Since it is possible to define both the generic map and the architecture for any entity:

entity work.MyEntity_E(ARCH) generic map(
...)
port map(
...
);


what is the additional flexibility of doing component instantiation? What would be the simplest example showing something that can not be done with entity instantiation but can be done with component instantiation?","I like to think of a component as being like an IC socket. You can take that analogy further by likening compilation (analysis) to assembling the PCB and likening elaboration to putting the chips in the sockets. If you use IC sockets, you can assemble the PCB even if you haven't ordered the chips yet; you can  defer putting the chips in the socket till later. Likewise if you use components: you can compile the design if even if the entities and architectures corresponding to the components don't yet exist; you can defer binding till later, till elaboration.

So, why might that be? Why might they not yet exist?

i) It's a big project. Not every one has finished their block yet. But you can still easily compile the top-level and run simulations on either bits of the design. You could do this by commenting-out/editing, but using components makes it easier.

ii) You've generated some IP automatically. This has given you a behavioural model for simulation, but no synthesisable model - the idea is that you combine some auto-generated physical view of the IP later in the flow. This is OK for simulation, but how can you compile your design for synthesis if there's a bit missing - your generated IP?

iii) You're doing recursive instantiation: you're instantiating one block inside itself. With direct instantiation, you've got an unbreakable chicken-and-egg situation (aka a circular dependency); with direct instantiation, you cannot instantiate something that has yet to be compiled, yet you cannot compile it, because the instantiated entity has not yet been compiled. Component instantiation can break this circular dependency.

iv) Component instantiation also enables you to instantiate different entities in the same place in your design (under the control of a configuration). @user1155120 gives an example of that above: using component instantiation (and a configuration) enables you to create identical blocks with differing sub-blocks.

Here's an example comparing the two on EDA Playground - https://www.edaplayground.com/x/2QrS.",,,,,
Wait until <signal>=1 never true in VHDL simulation,"Below is the code that I am running.  My question is why doesn't the 3rd wait until trigger in modelsim?  The console output is simply GOT HERE.  It never gets to the line GOT HERE 2.  I would think that having the same wait until &lt;SIGNAL&gt; = 1 twice in a row would be fine because the condition is true both times.  I didn't add 'event in there, so I wouldn't think the simulator would need to see the edge.  Can anyone explain this behavior?

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity example_wait_failure is
end example_wait_failure;

architecture behave of example_wait_failure is

  signal r_CLK_TB : std_logic := '0';

begin

  r_CLK_TB &lt;= '1' after 20 ns, '0' after 40 ns, '1' after 60 ns;


  p_TEST : process
  begin

    wait until r_CLK_TB = '1';
    report ""GOT HERE"" severity note;

    wait until r_CLK_TB = '1';
    wait until r_CLK_TB = '1';
    report ""GOT HERE 2 "" severity note;

  end process p_TEST;

end behave;
","The behaviour is in the details of the wait statement (the details of wait that
Jim Lewis refers to).  The reason is that the wait statements has three
parts:

wait
  [on sensitivity_list]
  [until condition]
  [for time_expression];  -- Only for timeout, and not relevant here


The wait in the relevant code only has an until part, so the
sensitivity_list is created according to VHDL standard: ""If no sensitivity
clause appears, the sensitivity set is constructed according to the following
(recursive) rule: ..."".  The generated sensitivity_list will in this case
contain r_CLK_TB.

The VHDL standard has an example that matches the code precisely, and this
states that:

wait until r_CLK_TB = '1';


is identical to:

loop
  wait on r_CLK_TB;
  exit when r_CLK_TB = '1';
end loop;


So even though the wait does not explicitly contain a wait until
r_CLK_TB'event (as written in comment), the execution results in waiting until
an event on r_CLK_TB in order to pass the first wait in wait on r_CLK_TB.
Is that intuitive... judge for yourself ;-)

So maybe the original code should be changes so:

wait until r_CLK_TB = '1';


is replaced with:

if r_CLK_TB /= '1' then
  wait until r_CLK_TB = '1';
end if;


In this case both ""GOT HERE"" and ""GOT HERE 2"" are shown at 20 ns, since the
condition of all three constructions will be TRUE here.",,,,,
How to manage large VHDL testbenches,"One problem I've seen again and again on different VHDL projects is that the top-level testbenches are always large and difficult to keep organized. There is basically a main test process where EVERY test signal is controlled or validated from, which becomes HUGE over time. I know that you can make testbenches for the lower-level components, but this question mainly applies to top-level input/output tests.

I'd like to have some kind of hierarchy structure to keep things organized. I've tried implementing VHDL procedures, but the compiler was very unhappy because it thought I was trying to assign signals from different sections of code...

Is there anything available in VHDL to achieve the behavior of c programming's inline-function or #define preprocessor replacement macros? If not, what can you suggest? It would make me happy to be able to have my top-level test bench look like this:

testClockSignals();
testDigitialIO();
testDACSignals();
...


Having the implementation of these functions in a separate file would be icing on the cake. Haha...I'd just like to write and simulate the test benches in C.","Separating test bench code in manageable procedures is possible, but maybe the
compiler complained because a procedure tries to access signals that were not
in scope ?  If a procedure is to controls a signal that is not in scope, then
the signal can be given as argument to the procedure, as shown for the
procReset example below.

A test bench structure, with multiple levels for easier maintenance, is shown
below:

--==========================================================
-- Reusable procedures

-- Reset generation
procedure procReset(signal rst : out std_logic; ...) is
...

--==========================================================
-- Main test control procedure in test bench
process is

  ------------------------------------------------------------
  -- General control and status

  -- Reset device under test and related test bench modules
  procedure genReset is
  begin
    procReset(rst, 100 ns);  -- procReset declared elsewhere
    -- Other code as required for complete reset
  end procedure;

  ------------------------------------------------------------
  -- Test cases

  procedure testClockSignals is
  begin
    genReset;  -- Apply reset to avoid test case interdependency
    -- Test code here, and call genErr if mismatch detected
  end procedure;

  procedure testDigitialIO is
  begin
    genReset;  -- Apply reset to avoid test case interdependency
    -- Test code here, and call genErr if mismatch detected
  end procedure;

  procedure testDACSignals is
  begin
    genReset;  -- Apply reset to avoid test case interdependency
    -- Test code here, and call genErr if mismatch detected
  end procedure;

begin

  ------------------------------------------------------------
  -- Run test cases
  testClockSignals;
  testDigitialIO;
  testDACSignals;
  -- End of simulation
  std.env.stop(0);
  wait;

end process;


There are several levels in the structure:


Run test cases: Where the procedures for each test case is
called.  It is thereby possible to comment out one or
more of the test cases during development and debugging.
Test cases: Test test case code itself, which is written as
separate and independent procedures.  Interdependence between
run of the different test cases is avoided by reset (using
genReset procedure) of the device under test and related test
bench support modules.
General control and status: Reusable test bench specific
procedure, for example reset of device under test and test
bench support modules.
Reusable procedures: Does not control or use test bench
signals directly, but only through procedure arguments.  These
procedures may be located in packages (other files) for reuse
in other test benches.


The test bench file may still be quite a number of lines, since all the test
case code still have to be in the same file with the above approach, if this
test bench code need direct access to test bench signals in order to control or
check the signals values.  If signal values can be passed to test case
procedures through arguments, as done for the procReset call, then it is
possible to move the test case code to another package.",,,,,
Why is rising edge preferred over falling edge,"Flip-Flops(,Registers ...) are usually triggered by a rising or falling edge. But mostly in code you see an if-clause which uses the rising edge triggering. In fact i never saw a code with falling edge.

Why is that? Is it because naturally the programmers use rising edge, because they are used to, or is it because of some physical/analog law/fact, where the rising edge programming is faster/simpler/energy-efficient/... ? ","As zennehoy says, it's convention - but one going back to when logic was done in discrete chips with a few gates or flipflops within them.  Those packages of flipflops were always rising-edge triggered...as far as I recall, but maybe someone with better recollection of the yellow books will correct me!



So when synthesis came along, no doubt everyone felt comfortable carrying on that way!",,,,,
Initializing an array of records in VHDL,"I have an record defined as follows

type ifx_t is
record
  data                        : std_logic_vector(127 downto 0);
  address                     : std_logic_vector (19 downto 0); 
  WrReq                       : std_logic;-- 
  RdReq                       : std_logic; --
end record;
type Array_ifx_t is array (0 to 2) of ifx_t;


And I have to initialize an instance of this array of records and I have tried the following way and it doesn't work

signal pair_in       : Array_ifx_t:= (others =&gt;((others =&gt;'0'),(others=&gt;'0'),'0','0')); 


Kindly help.  ","As said in the comment, ModelSim work when compiling the code from question with ModelSim. However, other tools may be more strict about using a typed value for elements in Array_ifx_t.

For a typed assign and use of named record elements, which I think gives getter overview and avoid mistakes by position references, you can make the initialization with:

constant IFX_T_0S : ifx_t := (data =&gt; (others =&gt;'0'),
                              address =&gt; (others=&gt;'0'),
                              WrReq =&gt; '0',
                              RdReq =&gt; '0');

signal pair_in : Array_ifx_t:= (others =&gt; IFX_T_0S);
",,,,,
Printing signed integer value stored in a variable of type reg,"How do I print a signed integer value stored in an 8-bit register declared as: 

reg [7:0] acc;


Using:

$display(""acc : %d"", acc)


It prints the unsigned value.

What's the correct syntax for the $display function?","If you declare the reg as signed, $display will show the minus sign:

module tb;

reg signed [7:0] acc;

initial begin
    acc = 8'hf0;
    $display(""acc : %d"", acc);
end

endmodule


Prints out:

acc :         -16
",,,,,
Incrementing Multiple Genvars in Verilog Generate Statement,"I'm trying to create a multi-stage comparator in verilog and I can't figure out how to increment multiple genvars in a single generate loop. I'm trying the following:

genvar i,j;
//Level 1
generate
  j=0;
  for (i=0;i&lt;128;i=i+1)
  begin: level1Comp
    assign ci1[i] = minw(tc[j],tc[j+1]);
    j = j+2;
  end
endgenerate


And getting the following error:

Error-[SE] Syntax error
  Following verilog source has syntax error :
  ""encoder.v"", 322: token is '='
    j=0;


Anyone know how to increment multiple genvars in the same generate statement? Or at least get equivalent functionality?","Assuming that ci1 has half the depth of tc and you want, say ci1[0] = min(tc[0], tc[1]), ci[1] = min(tc[2], tc[3]) etc, the following should work:

module st_genvar();

  int ci1 [0:127];
  int tc [0:255];

  function int minw(int i1, int i2);
      if(i1 &lt; i2 )
        minw = i1;
      else
        minw = i2;
  endfunction

  genvar i;
  //Level 1
  generate
      for (i=0;i&lt;128;i=i+1)
        begin: level1Comp
            assign ci1[i] = minw(tc[i*2],tc[i*2+1]);
        end
  endgenerate

endmodule
",,,,,
shift a std_logic_vector of n bit to right or left,"I have a vector signal tmp : std_logic_vector(15 downto 0)

I have to shift it to left or right of n bit. how can I realize this operation. I thought to concatenation operation but I didn't know how use it.","Use the ieee.numeric_std library, and the appropriate vector type for the numbers you are working on (unsigned or signed).

Then the operators are `sla`/`sra` for arithmetic shifts (ie fill with sign bit on right shifts and lsb on left shifts) and `sll`/`srl` for logical shifts (ie fill with '0's).
You pass a parameter to the operator to define the number of bits to shift:
A &lt;= B srl 2; -- logical shift right 2 bits


---
Update:
---
I have no idea what I was writing above (thanks to Val for pointing that out!)
Of course the correct way to shift signed and unsigned types is with the shift_left and shift_right functions defined in ieee.numeric_std.
The shift and rotate operators sll, ror etc are for vectors of boolean, bit or std_ulogic, and can have interestingly unexpected behaviour in that the arithmetic shifts duplicate the end-bit even when shifting left.
And much more history can be found here:
http://jdebp.eu./FGA/bit-shifts-in-vhdl.html
However, the answer to the original question is still
sig &lt;= tmp sll number_of_bits;
",,,,,
VHDL driving signal from different processes,"I have a little problem with following VHDL code:

process (zbroji)
begin
    if rising_edge(zbroji) then
        oduzima &lt;= '0';
        ucitanPrvi &lt;= '1';
        broj1 &lt;= ulaz_broj;
    end if;
end process;

process (oduzmi)
begin
    if rising_edge(oduzmi) then
        oduzima &lt;= '1';
        ucitanPrvi &lt;= '1';
        broj1 &lt;= ulaz_broj;
    end if;

end process;


The problem is that signal ucitanPrvi always has value X. If I don't try to set it's value in two processes, then I don't have any problems ... So I know that I mustn't drive one signal from multiple processes, but I don't know how to write this differently ...
Does anyone have an idea how I could resolve this problem ?

Thanks !

EDIT: Thank you all guys for replying :) Now I understand why I can't drive one signal from multiple processes (at least in the way I wanted it to work).","If you want to synthesize your design for a real FPGA or ASIC, you are going to have to think of VHDL in terms of real hardware (wires, flip flops, gates, etc.). Also, if you want to perform a real rising edge detect in hardware, you will need a system clock that drives a flip flop. Given your original code sample, it doesn't seem that zbroji or oduzmi are system clocks, but just std_logic signals. I wrote this code example assuming basic functionality from your example, hopefully, you can take my code and comments and accomplish what you need. 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity example is
  port (Reset      : in  std_logic;
        SysClk     : in  std_logic;
        zbroji     : in  std_logic;
        oduzmi     : in  std_logic;
        ulaz_broj  : in  std_logic;
        oduzima    : out std_logic;
        ucitanPrvi : out std_logic;
        broj1      : out std_logic
        );

end example;

architecture Behavioral of example is

  -- Delayed version of input signals (1 clock cycle delay)
  signal zbroji_d : std_logic;
  signal oduzmi_d : std_logic;

  signal zbrojiRE : std_logic;
  signal oduzmiRE : std_logic;

begin

  -- Generate 1 clock cycle delayed version of
  -- signals we want to detect the rising edge
  -- Assumes active high reset
  -- Note: You should only use the rising_edge macro
  -- on an actual global or regional clock signal. FPGA's and
  -- ASICs place timing constraints on defined clock signals
  -- that make it possible to use rising_edge, otherwise, we have
  -- to generate our own rising edge signals by comparing delayed
  -- versions of a signal with the current signal.
  -- Also, with any respectable synthesizer / simulator using
  -- rising_edge is almos exactly the same as (clk'event and clk='1')
  -- except rising_edge only returns a '1' when the clock makes a
  -- valid '0' to '1' transition. (see link below)
  EdgeDetectProc : process (Reset, SysClk)
  begin
    if Reset = '1' then
      zbroji_d &lt;= '0';
      oduzmi_d &lt;= '0';
    elsif rising_edge(SysClk) then
      zbroji_d &lt;= zbroji;
      oduzmi_d &lt;= oduzmi;
    end if;
  end process EdgeDetectProc;

  -- Assert risinge edge signals for one clock cycle 
  zbrojiRE &lt;= '1' when zbroji = '1' and zbroji_d = '0' else '0';
  oduzmiRE &lt;= '1' when oduzmi = '1' and oduzmi_d = '0' else '0';

  -- Assumes that you want a single cycle pulse on ucitanPrvi on the
  -- rising edege of zbroji or oduzmi;
  ucitanPrvi &lt;= zbrojiRE or oduzmiRE;

  -- Based on your example, I can't tell what you want to do with the
  -- broj1 signal, but this logic will drive broj1 with ulaz_broj on
  -- either the zbroji or oduzmi rising edge, otherwise '0'.
  broj1 &lt;= ulaz_broj when zbrojiRE = '1' else
           ulaz_broj when oduzmiRE = '1' else
           '0';

  -- Finally, it looks like you want to clear oduzima on the rising
  -- edge of zbroji and assert oduzima on the rising edge of
  -- oduzmi
  LatchProc : process (Reset, SysClk)
  begin
    if Reset = '1' then
      oduzima &lt;= '0';
    elsif rising_edge(SysClk) then
      if zbrojiRE = '1' then
        oduzima &lt;= '0';
      elsif oduzmiRE = '1' then
        oduzima &lt;= '1';
      end if;
    end if;
  end process LatchProc;

end Behavioral;


The previous code assumes you have a system clock. In a simulator like ModelSim (free student edition), you can generate a 100 MHz clock with non-synthesizable testbench code like this...

ClockProc : process
begin 
   SysClk &lt;= '0';
   wait for 5 ns;
   SysClk &lt;= '1';
   wait for 5 ns;
end process ClockProc;


In an actual FPGA/ASIC implementation, you will probably want to use an external oscillator that you run into your chip, drive the signal into a DCM (Digital clock manager), which will output a very clean clock signal to all of your VHDL logic, so you can have a glitch free design.

And finally, here is a great explanation on the differences between rising_edge and
(clk'event and clk='1')

http://vhdlguru.blogspot.com/2010/04/difference-between-risingedgeclk-and.html

Hope that helps.",,,,,
Python ast package: traversing object hierarchies,"The following is a Python code snippet using the ast and symtable
packages.  I am trying to parse the code and check the types.  But I 
don't understand how to traverse objects to get to the actual variable 
being referenced.

The following code implements a NodeVisitor, and a function is presented to the compiler and parsed by the compiler and the ast walked.  The function being analyzed (eval_types) is passed a couple objects.  

Below are the code chunks that make up the example.  I have added some comments for each chunk.  To run the code, the ""chunks"" need to be reassembled.

The imports and a function to un-indent a block of code for parsing.

import inspect
import ast
import symtable
from tokenize import generate_tokens, untokenize, INDENT
from cStringIO import StringIO

# _dedent borrowed from the myhdl package (www.myhdl.org)
def _dedent(s):
    """"""Dedent python code string.""""""

    result = [t[:2] for t in generate_tokens(StringIO(s).readline)]
    # set initial indent to 0 if any
    if result[0][0] == INDENT:
        result[0] = (INDENT, '')
    return untokenize(result)


The following is the node visitor, it has the generic unhandled and name visitor overloads.

class NodeVisitor(ast.NodeVisitor):
    def __init__(self, SymbolTable):
        self.symtable = SymbolTable
        for child in SymbolTable.get_children():
            self.symtable = child
            print(child.get_symbols())

    def _visit_children(self, node):
        """"""Determine if the node has children and visit""""""
        for _, value in ast.iter_fields(node):
            if isinstance(value, list):
                for item in value:
                    if isinstance(item, ast.AST):
                        print('  visit item %s' % (type(item).__name__))
                        self.visit(item)

            elif isinstance(value, ast.AST):
                print('  visit value %s' % (type(value).__name__))
                self.visit(value)

    def generic_visit(self, node):
        print(type(node).__name__)
        self._visit_children(node)

    def visit_Name(self, node):
        print('  variable %s type %s' % (node.id,
                                         self.symtable.lookup(node.id)))
        print(dir(self.symtable.lookup(node.id)))


The following are some simple classes that will be used in the function that will be parsed and analyzed with the AST.

class MyObj(object):
    def __init__(self):
        self.val = None

class MyObjFloat(object):
    def __init__(self):
        self.x = 1.

class MyObjInt(object):
    def __init__(self):
        self.x = 1

class MyObjObj(object):
    def __init__(self):
        self.xi = MyObjInt()
        self.xf = MyObjFloat()


The following is the test function, the eval_types function is the function that will be analyzed with the AST.

def testFunc(x,y,xo,z):

    def eval_types():
        z.val = x + y + xo.xi.x + xo.xf.x

    return eval_types


The code to execute the example, compile the function and analyze.

if __name__ == '__main__':
    z = MyObj()
    print(z.val)
    f = testFunc(1, 2, MyObjObj(), z)
    f()
    print(z.val)
    s = inspect.getsource(f)
    s = _dedent(s)
    print(type(s))
    print(s)

    SymbolTable = symtable.symtable(s,'string','exec')
    tree = ast.parse(s)
    v = NodeVisitor(SymbolTable)
    v.visit(tree)


The following is an example output up to the first name visit.  

Module
  visit item FunctionDef
FunctionDef
  visit value arguments
arguments
  visit item Assign
Assign
  visit item Attribute
Attribute
  visit value Name
  variable z type &lt;symbol 'z'&gt;
['_Symbol__flags', '_Symbol__name', '_Symbol__namespaces', 
 '_Symbol__scope', '__class__', '__delattr__', '__dict__', 
 '__doc__', '__format__', '__getattribute__', '__hash__', 
 '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', 
 '__repr__', '__setattr__', '__sizeof__', '__str__', 
 '__subclasshook__', '__weakref__', 'get_name', 'get_namespace', 
 'get_namespaces', 'is_assigned', 'is_declared_global', 
 'is_free', 'is_global', 'is_imported', 'is_local', 
 'is_namespace', 'is_parameter', 'is_referenced']


Creating the node visitor doesn't seem to bad but I can't figure out
how to traverse an object hierarchy.  In the general case the variable 
being accessed could be buried deep in a object.  How to get to the actual variable being accessed from the ast visitor?  I only see that an object is at the node but no additional information what the result variable access is.","I don't know if you're still looking for this, but it looks like you just need to add a visit_Attribute and traverse backwards.  If you add this to your example:

def visit_Attribute(self, node):
    print('  attribute %s' % node.attr)
    self._visit_children(node)


Then the output for xo.xf.x is:

Add
  visit value Attribute
  attribute x
  visit value Attribute
  attribute xf
  visit value Name
  variable xo type &lt;symbol 'xo'&gt;
  visit value Load


Depending what you want to do with this, you would just need to store the attributes in a list until a Name is encountered, then reverse them.",,,,,
Verilog Barrel Shifter,"I want to create a 64-bit barrel shifter in verilog (rotate right for now). I want to know if there is a way to do it without writing a 65 part case statement? Is there a way to write some simple code such as:

    Y = {S[i - 1:0], S[63:i]};


I tried the code above in Xilinx and get an error: i is not a constant.

Main Question: Is there a way to do this without a huge case statment?","I've simplified some of the rules for clarity, but here are the details.

In the statement

Y = {S[i - 1:0], S[63:i]};


you have a concatenation of two signals, each with a constant part select.  A constant part select is of the form

identifier [ constant_expression : constant_expression ]

but your code uses a variable for the first expression. As you saw this isn't allowed, but you are correct in that there are ways to avoid typing a large case statement. What you can use instead is an indexed part select. These are of the form

identifier [ expression +: constant_expression ]

identifier [ expression -: constant_expression ]

These constructs enforce that the width of the resulting signal is constant, regardless of the variable on the left side.

wire [HIGH_BIT:LOW_BIT] signalAdd,signaSub;
signalAdd[some_expression +: some_range];
signalSub[some_expression -: some_range];
//Resolves to
signalAdd[some_expression + (some_range - 1) : some_expression];
signalSub[some_expression                    : some_expression - (some_range - 1)];

//The location of the high value depends on how the signal was declared:
wire [15: 0] a_vect;
wire [0 :15] b_vect;
a_vect[0 +: 8] // a_vect[7 : 0]
b_vect[0 +: 8] // b_vect[0 : 7]


Rather than trying to build one signal out of two part selects, you can simply extend the input signal to 128 bits, and use a variable part select from that.

wire [63:0] data_in,data_out;
wire [127:0] data_in_double;
wire [5:0] select;

//Concatenate the input signal
assign data_in_double = {data_in,data_in};

//The same as signal[select + 63 : select]
assign data_out = data_in_double[select+63-:64];


Another approach you could use is generate loops. This is a more general approach to replicating code based on a variable. It is much less efficient since it creates 4096 signals.

wire [63:0] data_in,data_out;
wire [127:0] data_in_double;
wire [5:0] select;
wire [63:0] array [0:63];
genver i;

//Concatenate the input signal
assign data_in_double = {data_in,data_in};
for(i=0;i&lt;64;i=i+1)
  begin : generate_loop
  //Allowed since i is constant when the loop is unrolled
  assign array[i] = data_in_double[63+i:i];
  /*
  Unrolls to 
  assign array[0] = data_in_double[63:0];
  assign array[1] = data_in_double[64:1];
  assign array[2] = data_in_double[65:2];
  ...
  assign array[63] = data_in_double[127:64];
  */
  end

//Select the shifted value
assign data_out = array[select];
",,,,,
Better way of coding a RAM in Verilog,"Which code is better in writing a RAM?


assigning data_out inside always block:

module memory(
    output reg [7:0] data_out,
    input [7:0] address,
    input [7:0] data_in, 
    input write_enable,
    input clk
);
    reg [7:0] memory [0:255];

    always @(posedge clk) begin
        if (write_enable) begin
            memory[address] &lt;= data_in;
        end
        data_out &lt;= memory[address];
    end

endmodule

assigning data_out using assign statement:

module memory(
    output [7:0] data_out,
    input [7:0] address,
    input [7:0] data_in, 
    input write_enable,
    input clk
);
    reg [7:0] memory [0:255];

    always @(posedge clk) begin
        if (write_enable) begin
            memory[address] &lt;= data_in;
        end
    end

    assign data_out = memory[address];

endmodule



Any recommendations?","It depends on your requirements.

This registers your memory output.  If you are synthesizing this to gates, you will have 8 more flip-flops than in case 2.  That means you use a little more area.  It also means your output will have less propagation delay relative to the clock than case 2.  Furthermore, the output data will not be available until the next clock cycle.

Your output data will be available within the same clock cycle as it was written, albeit with longer propagation delay relative to the clock.


You need to decide which to use based on your requirements.
A third option is to use a generated RAM, which is a hard macro.  This should have area, power and possibly timing advantages over both case 1 and 2.",,,,,
downto vs. to in VHDL,"I'm not sure I understand the difference between 'downto' vs. 'to' in vhdl.

I've seen some online explanations, but I still don't think I understand.  Can anyone lay it out for me?","One goes up, one goes down:

-- gives 0, 1, 2, 3:
for i in 0 to 3 loop

-- gives 3, 2, 1, 0:
for i in 3 downto 0 loop
",,,,,
What are some practical applications of an FPGA?,"I'm super excited about my program powering a little seven-segment display, but when I show it off to people not in the field, they always say ""well what can you do with it?"" I'm never able to give them a concise answer. Can anyone help me out?","First: They don't need to have volatile memory. 

Indeed the big players (Xilinx, Altera) usually have their configuration on-chip in SRAM, so you need additional EEPROM/Flash/WhatEver(TM) to store it outside. 

But there are others, e.g. Actel is one big player that come to mind, that has non-volatile configuration storage on their FPGAs (btw. this has also other advantages, as SRAM is usually not very radiation tolerant, and you have to require special measurements when you go into orbit).

There are two big things that justify FPGAS:


Price - They are not cheap. But sometimes you can't do something in software, and you need hardware for it. And when you are below a certain point in your required volume (e.g. because its just small series, or a prototype) an FPGA is MUCH cheaper than an ASIC. Also, while developing ASICs this allows - before a final state is reached - much higher turn-around times.
Reconfiguration - You can reconfigure your FPGA. That is something a processor or an ASIC can't do. There are some applications where you can use this: E.g. When you need the ability to fix something in the design, but you can't get physically to the device. Example for this: The mars orbiters/rovers used Xilinx FPGAs. When someone finds there a mistake (or wants to switch to a different coding for transmitting data or whatever), you can't replace the ship, as it is just not reachable. But with an FPGA you can just reconfigure and can apply your changes. Another scenario is, that you can have one single chip which is able to perform different accelerations, depending on the scenario. Imagine a smartphone, when telephoning the FPGA can be configured to make audio en-/decoding, when surfing it can work as a compression engine, when playing videos it can be configured as h264 decoder/accelerator. Another thing you could do is that you can match your hardware to your problem instance. E.g. Cisco uses many FPGAs in their hardware. You need the hardware to perform switching/routing/packet inspection with the required speed, and you can generate from actual setting matching engines directly into hardware.


Another thing which might come up soon (I know some car manufacturer thought about it), is for devices which include a lot of different electronics and have a big supply chain. It's more or less a combination of price and reconfiguration. It's more expensive to have 10 ASICs than 10 FPGAs - where both perform the same task, but it's cheaper to have 10 FPGAs with just one supplier and the need to hold just 1 type of chip at service and supply than to have 10 suppliers with the necessity to hold and manage 10 different chips in supply and service.",,,,,
Read a specific memory address via /dev/mem from the command line,"For context, programming a driver to interact with an FPGA IP core on an embedded Linux (Yocto: krogoth) on a Xilinx board.

For debugging purposes I would like to read out specific memory addresses from physical memory. /dev/mem looks promising. I wanted to ask how I can read out the value of a specific physical memory address from the command line. I was hoping for something along the lines of cat /dev/mem 0x2000000 to read the byte at 0x2000000.","Usually you should already have devmem tool installed in your Linux image:

$ devmem 0x2000000


If you don't however, you can go to Busybox menu and tweak it to make sure it gets compiled and installed:

$ bitbake busybox -c menuconfig


(search for devmem)",,,,,
"What will be the values of a, b, c?","Mixing blocking and non-blocking is not recommended as I understand. But if it indeed exists, what will be the values of a, b, c?

module TB; 
reg a, b, c;
initial begin 
  a = 3;
  b = 4;
  $display (""a = %d, b = %d, c=%d\n"", a, b, c);
  c &lt;=  a + b;
  $display (""a = %d, b = %d, c=%d\n"", a, b, c);
  a &lt;= 10;
  b  &lt;= 2;
  c = a + b;
  $display (""a = %d, b = %d, c=%d\n"", a, b, c);
end
endmodule
","module TB; 
reg ***[2:0]*** a, b, c;
initial begin 
   a = 3;
   b = 4;
$display (""a = %d, b = %d, c=%d\n"", a, b, c);
c &lt;=  a + b;
$display (""a = %d, b = %d, c=%d\n"", a, b, c);
a &lt;= 10;
b  &lt;= 2;
c = a + b;
$display (""a = %d, b = %d, c=%d\n"", a, b, c);
end
endmodule


a=3, b=4 and c=7

Timing Queue of Verilog is divided into four parts:
Active Region -> Inactive -> NBA -> Postponed
Blocking assignments gets evaluated and assign in the ACTIVE region along with $display(). While Nonblocking assignments get evaluated in the ACTIVE region and assign in the NON BLOCKING ASSIGNMENT(NBA) Region. Hence whatever updates made to the a,b,c wont get printed using display statement. You can use $monitor which gets executed in the postponed region.",,,,,
How will this loop work in SystemVerilog language?,"How will this loop work in SystemVerilog language ?

for(bit [2:0] i = 0; i &lt; 4; i++)


What will be the values of i after each iteration provided i is 3 bit wire ?","bit [2:0] i;


As i is 3-bit value, it can take values from 0-7.

so i will get values 0,1,2,3",,,,,
Is it possible to create several instances of the same component using a loop?,"I have a component:

Component CAU is
    port 
    (
        CLK              : in std_logic;
        RESET            : in std_logic;
        START            : in std_logic;
        V_DIRECTION      : in vector_3d;
        P_ORIGIN         : in vector_3d;      
        V_NORMAL_IN      : in vector_3d;
        DOT_A            : in vector_3d;
        DOT_B            : in vector_3d;
        DOT_C            : in vector_3d;
        ID_DATA_IN       : in scalar;

        ID_DATA_OUT      : out scalar;
        V_REFLECT        : out vector_3d;          
        V_PASS           : out vector_3d;        
        P_INTERSECT      : out vector_3d;
        V_NORMAL_OUT     : out vector_3d;
        T_OUT            : out scalar;
        SUCCESS          : out std_logic; 
        FINISH           : out std_logic
    );   
end  Component; 


And I want to create 8 instances of it. each is called CAU_inst0, CAU_inst1, and so on. Each of the instances is connected the following way:

CAU_inst0 : CAU
 PORT MAP
 (
    CLK              =&gt; CLK_CAU,
    RESET            =&gt; RESET,
    START            =&gt; start_0_sig,
    V_DIRECTION      =&gt; v_direction_0_sig,
    P_ORIGIN         =&gt; p_origin_0_sig,
    V_NORMAL_IN      =&gt; v_normal_in_0_sig,
    DOT_A            =&gt; dot_a_0_sig,
    DOT_B            =&gt; dot_b_0_sig,
    DOT_C            =&gt; dot_c_0_sig,
    ID_DATA_IN       =&gt; id_data_in_0_sig,

    ID_DATA_OUT      =&gt; id_data_out_0_sig
    V_REFLECT        =&gt; v_reflect_0_sig,
    V_PASS           =&gt; v_pass_0_sig,
    P_INTERSECT      =&gt; p_intersect_0_sig,
    V_NORMAL_OUT     =&gt; v_normal_out_0_sig,
    T_OUT            =&gt; t_0_sig,
    SUCCESS          =&gt; success_0_sig,
    FINISH           =&gt; finish_0_sig
 );


where for each instance i the number 0 is replaced with i. What I did was to create a Matlab script that created the 8 different instances with the correct number. But it's an ugly solution as it takes 170 lines of just the same code with little changes. Is there a way to create the components (and if possible the appropriate signals) in a loop inside the code to reduce cluter and line?","What you are looking to use is a for...generate statement.

Here is an example, similar to what you want to achieve:

architecture GEN of REG_BANK is
  component REG
    port(D,CLK,RESET : in  std_ulogic;
         Q           : out std_ulogic);
  end component;
begin
   GEN_REG: 
   for I in 0 to 3 generate
      REGX : REG port map
        (DIN(I), CLK, RESET, DOUT(I));
   end generate GEN_REG;
end GEN;


In your case, you will need to make all the signals that connect up to your block vectors and or vectors of vectors.

For example, if you signal is currently defined as:

signal v_normal_in_0_sig : std_logic_vector(7 downto 0);


You will need to change it to:

type vector16 is array (natural range &lt;&gt;) of std_logic_vector(15 downto 0);
signal v_normal_in_sig : vector16(7 downto 0);


In this case, you can now use your signal as v_normal_in_sig(i) to connect to the ith generated instanciation of your entity/component.

Note that if you are using VHDL-2008, you can do the following instead...

type vector_array is array (natural range &lt;&gt;) of std_logic_vector;
signal v_normal_in_sig : vector_array(7 downto 0)(15 downto 0);
",,,,,
Integer to real conversion function,"Is there a common conversion function to convert a integer type object to a real type in VHDL?
This is for a testbench so synthesizability is a non-issue.","You can convert integer to real as follows:

signal i: integer;
signal R: Real;

...

R &lt;= Real(i);
",,,,,
"How to ""slice"" an std_logic_vector in VHDL?","I'm developing a little thing in VHDL and am quite new to it. I'm having trouble figuring out how to slice a bigger std_logic_vector into a smaller one. 

For instance I have 3 signals:

signal allparts: std_logic_vector(15 downto 0);
signal firstpart: std_logic_vector(7 downto 0);
signal secondpart: std_logic_vector(7 downto 0);


Basically, what I want is to assign bits 15 through 8 to secondpart and bits 7 through 0 to firstpart. How exactly would I ""slice"" a vector like this without assigning individual bits","You can directly assign them:

firstpart &lt;= allparts(15 downto 8);
secondpart &lt;= allparts(7 downto 0);


...or if firstpart and secondpart are simply alternate ways to refer to part of the allparts signal, you may want to use an alias:

alias firstpart is allparts(15 downto 8);
alias secondpart is allparts(7 downto 0);
",,,,,
is there a verilog tutorial where you build a very simple microprocessor?,"I'm a programmer wishing to learn verilog.

What would be amazingly neat would be a tutorial where one constructs a tiny microprocessor with a very clean design, something like an Intel 4004, and then goes on to actually make it using an fpga and gets it to flash LEDs to order.

Is there such a tutorial?

If not, I might have a go at writing one as I try to do it. Has anyone got any recommendations as to resources I might draw on? e.g. nice open source verilog compiler, debugging tools, simulators, verilog tutorials, cheap fpgas and programming tools, breadboards for LEDs, etc.","I found some glorious slides about an elementary microprocessor here:

http://www.slideshare.net/n380/elementary-processor-tutorial",,,,,
Configure ModelSim simulation to display text,"Can I make ModelSim simulation to display text (rather than a numeric value) on a signal? I have a couple of state-machine states say, 

localparam S_IDLE  = 2'b00; 
localparam S_START = 2'b01; 
localparam S_STOP  = 2'b10;


Is there a way to display S_IDLE for example, on a signal rather than 00? Thanks.","One thing you can do that is should work across all simulators is to create a signal that holds an ascii string, and then change the radix of that signal to ascii in the simulation window:

reg [8*8-1:0] mytextsignal;
always@(state) begin 
    case(state) 
        S_IDLE : mytextsignal = ""  S_IDLE"";
        S_START: mytextsignal = "" S_START"";
        S_STOP:  mytextsignal = ""  S_STOP"";
        default: mytextsignal = "" UNKNOWN"";
     endcase
 end


It should show up as readable text in the waveform viewer.",,,,,
Continuous assignment seemingly not working,"I'm working on a FIR filter, specifically the delay line. x_delayed is initialized to all zeros.

type slv32_array is array(natural range &lt;&gt;) of std_logic_vector(31 downto 0);
...
signal x_delayed : slv32_array(0 to NTAPS-1) := (others =&gt; (others =&gt; '0'));


This does not work:

x_delayed(0) &lt;= x;             -- Continuous assignment

DELAYS : process(samp_clk)
begin
    if rising_edge(samp_clk) then
        for i in 1 to NTAPS-1 loop
            x_delayed(i) &lt;= x_delayed(i-1);
        end loop;
    end if; -- rising_edge(samp_clk)
end process;






But this does:

DELAYS : process(samp_clk)
begin
    if rising_edge(samp_clk) then
        x_delayed(0) &lt;= x;           -- Registering input
        for i in 1 to NTAPS-1 loop
            x_delayed(i) &lt;= x_delayed(i-1);
        end loop;
    end if; -- rising_edge(samp_clk)
end process;




The problem with this ""solution"" is that the first element in x_delayed is delayed by one sample, which it should not be. (The rest of the code expects x_delayed(0) to be the current sample).

I'm using Xilinx ISE 13.2, simulating with ISim, but this was also confirmed simulating with ModelSim.

What gives? 



Edit:

The problem was essentially that, even though x_delayed(0) didn't appear to be driven inside the process, it was.

After implementing Brian Drummond's idea it works perfectly:

x_delayed(0) &lt;= x;

-- Synchronous delay cycles.
DELAYS : process(samp_clk)
begin
    -- Disable the clocked driver, allowing the continuous driver above to function correctly.
    -- https://stackoverflow.com/questions/18247955/#comment26779546_18248941
    x_delayed(0) &lt;= (others =&gt; 'Z');        

    if rising_edge(samp_clk) then
        for i in 1 to NTAPS-1 loop
            x_delayed(i) &lt;= x_delayed(i-1);
        end loop;
    end if; -- rising_edge(samp_clk)
end process;






Edit 2:

I took OllieB's suggestion for getting rid of the for loop. I had to change it, since my x_delayed is indexed from (0 to NTAPS-1), but we end up with this nice looking little process:

x_delayed(0) &lt;= x;

DELAYS : process(samp_clk)
begin
    x_delayed(0) &lt;= (others =&gt; 'Z');
    if rising_edge(samp_clk) then
        x_delayed(1 to x_delayed'high) &lt;= x_delayed(0 to x_delayed'high-1);
    end if; -- rising_edge(samp_clk)
end process;




Edit 3: 

Following OllieB's next suggestion, it turns out the x_delayed(0) &lt;= (others =&gt; 'Z') was unnecessary, following his previous change. The following works just fine:

x_delayed(0) &lt;= x;

DELAYS : process(samp_clk)
begin    
    if rising_edge(samp_clk) then
        x_delayed(1 to x_delayed'high) &lt;= x_delayed(0 to x_delayed'high-1);
    end if;
end process;
","In the first case, the x_delayed(0) actually has two drivers, out outside the
process, being x_delayed(0) &lt;= x, and an implicit one inside the DELAY
process.

The driver inside the process is a consequence of a VHDL standard concept
called ""longest static prefix"", described in VHDL-2002 standard (IEEE Std
1076-2002) section ""6.1 Names"", and the loop construction with a loop variable
i, whereby the longest static prefix for x_delayed(i) is x_delayed.  

The VHDL standard then further describes drives for processes in section
""12.6.1 Drivers"", which says ""... There is a single driver for a given scalar
signal S in a process statement, provided that there is at least one signal
assignment statement in that process statement and that the longest static
prefix of the target signal of that signal assignment statement denotes S ..."".

So as a (probably surprising) consequence the x_delayed(0) has a driver in
the DELAY process, which drives all std_logic elements to 'U' since unassigned,
whereby the std_logic resolution function causes the resulting value to be 'U',
no matter what value is driven by the external x_delayed(0) &lt;= x.

But in the case of your code, there seems to be more to it, since there actually are some ""0"" values in the simulation output for x_delayed(0), for what I can see from the figures.  However, it is hard to dig further into this when I do not have the entire code.

One way to see that the loop is the reason, is to manually roll out the loop by
replacing the for ... loop with:

x_delayed(1) &lt;= x_delayed(1-1);
x_delayed(2) &lt;= x_delayed(2-1);
...
x_delayed(NTAPS) &lt;= x_delayed(NTAPS-1);


This is of course not a usable solution for configurable modules with NTAPS as
a generic, but it may be interesting to see that the operation then is as
intuitively expected.

EDIT: Multiple solutions are listed in ""edit"" sections after the question above, based on comments.  A solution with variable, which allows for complex expressions if required, is shown below.  If complex expression is not required, then as per OllieB's suggestion it is possible to reduce the assign to x_delayed(1 to x_delayed_dir'high) &lt;= x_delayed(0 to x_delayed_dir'high-1):

x_delayed(0) &lt;= x;
DELAYS : process(samp_clk)
  variable x_delayed_v : slv32_array(1 to NTAPS-1);
begin
  if rising_edge(samp_clk) then
    for i in 1 to NTAPS-1 loop
      x_delayed_v(i) := x_delayed(i-1);  -- More complex operations are also possible
    end loop;
    x_delayed(1 to x_delayed_dir'high) &lt;= x_delayed_v;
  end if;  -- rising_edge(samp_clk)
end process;
",,,,,
vsim does not accept -modelsimini parameter on Windows,"I'm using the command line argument -modelsimini &lt;modelsim.ini&gt; to specify my own modelsim.ini file for most QuestaSim / ModelSim executables.

This works perfectly fine on Linux for vcom and vsim, as well as for vcom on Windows. But the Windows vsim aborts and throws an error:

C:\Mentor\QuestaSim64\10.4c\win64\vsim.exe -do ""do D:/git/PoC/sim/vSim.batch.tcl"" -c -modelsimini D:\git\PoC\temp\precompiled\vsim\modelsim.ini -error 3473 -t 1fs test.arith_prng_tb
Reading C:/Mentor/QuestaSim64/10.4c/tcl/vsim/pref.tcl

# 10.4c

# ** Error: (vsim-7) Failed to open -modelsimini file ""{D:\git\PoC\temp\precompiled\vsim\modelsim.ini}"" in read mode.
#
# Invalid argument. (errno = EINVAL)
# Error loading design
Error loading design
# Errors: 1, Warnings: 0


The modelsim.ini files exists and has the following content:

[Library]
others = $MODEL_TECH/../modelsim.ini


(This file will contain more lines if vendor tools add their library mappings.)

How can I pass my own modelsim.ini configuration file to vsim.exe?","It is questionable whether this should be considered as a bug or not  because TCL requires that file names are specified with forward slashes instead of backward slashes. Of course, one would expect that file-names are handled the same way when calling vcom or vsim. So the solution from this viewpoint is to specify the path with forward slashes:

C:\Mentor\QuestaSim64\10.4c\win64\vsim.exe -do ""do D:/git/PoC/sim/vSim.batch.tcl"" -c -modelsimini D:/git/PoC/temp/precompiled/vsim/modelsim.ini -error 3473 -t 1fs test.arith_prng_tb


Checked it here with ModelSim 10.1d under Windows and a modelsim.ini in my temporary directory.



Some experiments under the vsim TCL console reveals that -modelsimini file-name is handled differently by the vcom  and vsim commands. At first a backslash indicates an escape sequence, a \t in the file-name is expanded to a tab for example:

vcom -modelsimini c:\tmp\modelsim.ini test.vhdl
# ** Error: (vcom-7) Failed to open -modelsimini file ""c:   mpmodelsim.ini"" in read mode.
# 
# Invalid argument. (errno = EINVAL)
# D:/altera/13.1_web/modelsim_ase/win32aloem/vcom failed.


To prevent this, the argument can be put in curly braces {} for example:

vcom -modelsimini {c:\tmp\modelsim.ini} test.vhdl
# ** Error: (vcom-7) Failed to open -modelsimini file ""c:\tmp\modelsim.ini"" in read mode.
# 
# No such file or directory. (errno = ENOENT)
# D:/altera/13.1_web/modelsim_ase/win32aloem/vcom failed.


I specified a non-existent file, so that one can see the expansion. If I create the file c:\tmp\modelsim.ini, vcom will proceed as expected. Yes, backslashes in file-names are allowed here.

If we give the same arguments to vsim, the error messages (and the actual behaviour) will be different:

vsim -modelsimini c:\tmp\modelsim.ini test
# vsim -modelsimini {{c:    mpmodelsim.ini}} test 
# ** Error: (vsim-7) Failed to open -modelsimini file ""{c:  mpmodelsim.ini}"" in read mode.
# 
# No such file or directory. (errno = ENOENT)
# Error loading design

vsim -modelsimini {c:\tmp\modelsim.ini} test
# vsim -modelsimini {{c:\tmp\modelsim.ini}} test 
# ** Error: (vsim-7) Failed to open -modelsimini file ""{c:\tmp\modelsim.ini}"" in read mode.
# 
# Invalid argument. (errno = EINVAL)
# Error loading design


The file-name argument will be processed the same way as before. But then the vsim script adds another pair of curly-braces around the expanded argument. This behavior should be considered as a bug, because it does not make any sense. vsim finally looks for a file called {c:\tmp\modelsim.ini} which can never be found on a Windows file system. In your error message the file-name is also enclosed by curly braces.",,,,,
How to pre-process source files while a Sphinx run?,"I have set up a Sphinx documentation for my project and would like to extract doc strings for the source files and embed them into the final documentation. Unfortunately, the source file's language (VHDL) is not supported by Sphinx. There seems to be no Sphinx domain for VHDL.

So my ideas is as follows:


Hook into the Sphinx run and execute some Python code before Sphinx
The Python codes extracts text blocks from each source file (the top-most multi-line comment block) and assembles one reST file per source file, consisting of this comment block and some other reST markup.
All source files are listed in an index.rst, to generate the apropriate .. toctree:: directive.
The text extraction and transformation is done recursively per source code directory.


So the main question is: How to hook into Spinx?

Or should I just import and run my own configuration in conf.py?

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
from my_preprocessor import my_proc
proc = my_proc()
proc.run()
#
# Test documentation build configuration file, created by
# sphinx-quickstart on Tue May 24 11:28:20 2016.
# ....


I can't modify the build process files: Makefile and make.bat, because the real build process runs on ReadTheDocs.org. RTDs only executes conf.py.","As noted in my previous comments and mertyildiran's answer, the official way to hook into Sphinx for a language would be to create an extension to implement a new domain for VHDL.  

This has already been done for many other languages - e.g. Erlang, PHP, CoffeeScript - and APIs - e.g. HTTP REST - just to name a few from sphinx-contrib.  However, that is going to take a lot of time, which you don't have...  You are therefore left with an option to do some quick parsing yourself and then hooking that into your Sphinx build somehow.

Since you are bypassing the official hooks, this question becomes ""how do I run my own code inside a Sphinx build?""  For which, I would recommend that you simply follow the guidance for a local extension - i.e. put it in a separate directory, add that to your path, then import and invoke it.  As noted in the docs:


  The configuration file is executed as Python code at build time (using execfile(), and with the current directory set to its containing directory), and therefore can execute arbitrarily complex code. Sphinx then reads simple names from the fileâ€™s namespace as its configuration.


As a final though, this opens up the options to use 3rd party packages like pyVhdl2Sch (with a nod again to mertyildiran's answer) to create some schematic and then maybe write your static rst files around it to explain the schematic.",,,,,
Is $readmem synthesizable in Verilog?,"I am trying to implement a microcontroller on an FPGA, and I need to give it a ROM for its program. If I use $readmemb, will that be correctly synthesized to a ROM? If not, what is the standard way to do this?","It depends on the synthesis tool whether or not $readmemb is synthesizable.

Altera's Recommended HDL Coding Styles guide includes example 10-31 (page 10-38), which demonstrates a ROM inferred from $readmemb (reproduced below):

module dual_port_rom (
   input [(addr_width-1):0] addr_a, addr_b,
   input clk, 
   output reg [(data_width-1):0] q_a, q_b
);
   parameter data_width = 8;
   parameter addr_width = 8;
   reg [data_width-1:0] rom[2**addr_width-1:0];
   initial // Read the memory contents in the file
           // dual_port_rom_init.txt. 
   begin
      $readmemb(""dual_port_rom_init.txt"", rom);
   end
   always @ (posedge clk)
   begin
      q_a &lt;= rom[addr_a];
      q_b &lt;= rom[addr_b];
   end
endmodule


Similarly, Xilinx's XST User Guide states that:


  The $readmemb and $readmemh system
  tasks can be used to initialize block
  memories. For more information, see:
  
  Initializing RAM From an External File
  Coding Examples
  
  Use $readmemb for
  binary and $readmemh for hexadecimal
  representation. To avoid the possible
  difference between XST and simulator
  behavior, XilinxÂ® recommends that you
  use index parameters in these system
  tasks. See the following coding
  example.
  
  $readmemb(""rams_20c.data"",ram, 0, 7);
",,,,,
Where can I find a definitive list of the ModelSim error codes?,"I am running some VHDL through ModelSim. Each error and warning has its own error code (like this: (vcom-1292) Slice range direction ""downto"" specified in slice with prefix of unknown direction. This is just an example message; I understand what it means.

I assume that Mentor has a list of all possible error codes and a more elaborate description of what they mean, and how to avoid them. I did not find this error code in the PDFs that come with ModelSim, nor did I find it through Google. Any pointers anybody?","There is a modelsim command called verror with an -all option to list them all, and other options to inspect the messages further.",,,,,
How to sign-extend a number in Verilog,"I'm working on a simple sign-extender in Verilog for a processor I'm creating for Computer Architecture.

Here's what I've got so far: [EDIT: Changed the selection statement slightly]

`timescale 1ns / 1ps

module SignExtender( CLK, extend, extended );
input[7:0] extend;
input CLK;
output[15:0] extended;

reg[15:0] extended;
wire[7:0] extend;

always
begin
    while (CLK == 1)
    extended[7:0] = extend[7:0];
    extended[15:8] = {8{extend[7]}};
end
endmodule


I added the while (CLK == 1) thinking that would solve my problem, which I believe is an infinite loop. When I try to test this in iSim, the circuit never initializes.

I also tried removing the copying syntax and just doing extended[8] = extend[7] etc. for [8]-[15], but the same result occurs, so I'm pretty sure that the innermost syntax is correct.

Here's the test file:

`timescale 1ns / 1ps
module SignExtender_testbench0;

    // Inputs
    reg [7:0] extend;
    reg CLK;

    // Outputs
    wire [15:0] extended;

    // Instantiate the Unit Under Test (UUT)
    SignExtender uut (
        .extend(extend), 
        .extended(extended)
    );

    initial begin
        // Initialize Inputs
        extend = 0;

        #100; // Wait 100 ns for global reset to finish

        extend = -30;
        CLK = 1;
        #10;
        CLK = 0;
        if (extended == -30)
            $display(""okay 1"");
        else
            $display(""fail 1"");

        extend = 40;
        #10;
        if (extended == 40)
            $display(""okay 2"");
        else
            $display(""fail 2"");

    end

endmodule


Any ideas how I can do this successfully?","You nearly got it...

always @( posedge clk ) begin
    extended[15:0] &lt;= { {8{extend[7]}}, extend[7:0] };
end


You're also missing a clock edge for the '40' test. Try this, &amp; let me know how you get on...",,,,,
What to use for VHDL/digital-logic simulation on Mac OS X,"I suddenly realized that there is no Altera Quartus or Xilins ISE or ModelSim on Mac OS X.

What do people use to at least simulate VHDL and schematic designs on Macs?","Try GHDL (alternate link: at ghdl.free.fr).

From the site:


  GHDL is an open-source simulator for the VHDL language. GHDL allows
  you to compile and execute your VHDL code directly in your PC.
  Combined with a GUI-based wave viewer and a good VHDL text editor,
  GHDL is a very powerful tool for writing, testing and simulating your
  VHDL code.
  
  GHDL is based on the very popular GNU compiler GCC and runs on Linux,
  Windows and Apple OS X. You can freely download a binary distribution
  for your OS or try to compile GHDL on your own machine.
",,,,,
How to interpret blocking vs non blocking assignments in Verilog?,"I am a little confused about how blocking and non blocking assignments are interpreted when it comes to drawing a hardware diagram. Do we have to infer that a non blocking assignment gives us a register? Then according to this statement c &lt;= a+b , c would be a register right, but not a and b? 

module add (input logic clock,  
output logic[7:0] f);   

logic[7:0] a, b, c;  

always_ff @(posedge clock)  
begin   
  a = b + c;   
  b = c + a;   
  c &lt;= a + b;  
end   

assign f = c;  

endmodule
","It's definitely a bit tricky to get your head around the differences between blocking and nonblocking assignments initially. But no fear - there's a handy rule of thumb:


  If you want to infer combo logic with an always block, use blocking assignments (=). If you want sequential logic, use a clocked always block with nonblocking assignments (&lt;=). And try not to mix the two.


Your code above is probably not the best example. Without knowing what adder/flipflop structure you were trying to build, there's the danger of having combo feedback paths (which are bad). And since you've no input buses, you're essentially trying to construct a, b &amp; c out of thin air!

But to answer your question, any variable assigned to within a clocked always block will infer a flipflop, unless its assigned using the blocking operator (=) and used as a kind of a local variable.

module add
  (
   input clock,
   input [7:0] in1,
   input [7:0] in2,
   output logic [7:0] f1, f2, f3, f4, f5
   );   


   // f1 will be a flipflop
   always_ff @(posedge clock) begin
      f1 = in1 + in2;
   end


   // f2 will be a flipflop
   always_ff @(posedge clock) begin
      f2 &lt;= in1 + in2;
   end


   // f3 will be a flipflop
   // c1 will be a flipflop
   logic [7:0] c1;
   always_ff @(posedge clock) begin
      c1 &lt;= in1 + in2;
      f3 &lt;= c1 + in1;
   end


   // f4 will be a flipflop
   // c2 is used only within the always block and so is treated
   // as a tmp variable and won't be inferred as a flipflop
   logic [7:0] c2;
   always_ff @(posedge clock) begin
      c2 = in1 + in2;
      f4 = c2 + in1;
   end


   // c3 will be a flipflop, as it's used outside the always block
   logic [7:0] c3;
   always_ff @(posedge clock) begin
      c3 = in1 + in2;
   end

   assign f5 = c3 + in1;

endmodule


A big reason for following the rule of thumb and not mixing blocking and nonblocking assignments within an always block, is that mixing your assignments can cause serious simulation mismatches between RTL sims and gate-sims/real hardware operation. The verilog simulator treats = and &lt;= quite differently. Blocking assignments mean 'assign the value to the variable right away this instant'. Nonblocking assignments mean 'figure out what to assign to this variable, and store it away to assign at some future time'. A good paper to read to understand this better is: Also see: http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA.pdf",,,,,
What FPGAs (Field-Programmable Gate Arrays) can one buy to experiment with at home?,"What is an FPGA, and where can I buy one? How much do they cost?

What sort of system do you need to experiment with them? How to program them?

Can you ""load"" if that's the right term an FPGA using an ordinary Mac?

Are they extremely expensive or can I buy one today?

I have become interested in FPGAs after reading this question.","Although it is far from the cheapest, buying a Xilinx XUPv5 is a good idea if you want to learn a lot - not only is the 110T chip large enough to build very ambitious projects (a fully functional Nintendo console replica, for example), but it is also the board many top-tier universities use in their digital design class. Berkeley, for example, publishes their full notes, labs, etc for use with the XUPv5 board. I taught the class for a number of years, and would like to believe that it is an excellent, high-quality resource.

Hope this helps,",,,,,
What is the fastest way to perform hardware division of an integer by a fixed constant?,"I have a 16 bit number which I want to divide by 100. Let's say it's 50000. The goal is to obtain 500. However, I am trying to avoid inferred dividers on my FPGA because they break timing requirements. The result does not have to be accurate; an approximation will do.

I have tried hardware multiplication by 0.01 but real numbers are not supported. I'm looking at pipelined dividers now but I hope it does not come to that.","Conceptually: Multiply by 655 (= 65536/100) and then shift right by 16 bits. Of course, in hardware, the shift right is free.

If you need it to be even faster, you can hardwire the divide as a sum of divisions by powers of two (shifts). E.g., 

1/100 ~= 1/128                  = 0.0078125
1/100 ~= 1/128 + 1/256          = 0.01171875
1/100 ~= 1/128 + 1/512          = 0.009765625
1/100 ~= 1/128 + 1/512 + 1/2048 = 0.01025390625
1/100 ~= 1/128 + 1/512 + 1/4096 = 0.010009765625
etc.


In C code the last example above would be:

uint16_t divideBy100 (uint16_t input)
{
    return (input &gt;&gt; 7) + (input &gt;&gt; 9) + (input &gt;&gt; 12);
}
",,,,,
Difference between @(posedge Clk); a<= 1'b1; and @(posedge Clk) a<= 1'b1;,"Is there any difference between

@(posedge Clk);
   a&lt;= 1'b1;


and 

@(posedge Clk)
   a&lt;= 1'b1;


Note the semicolon after Clk. I came across similar lines of code when I was browsing through a testbench. I did some simple experiments and I could not find any differences during simulation. Will the sequence of execution for the code following these lines change in any way due to the presence/absence of the semicolon?","You're correct -there's no behavioural difference.

The semicolon version is: Wait. Do this.
The non-semicolon version is: Wait then do this. You'll sometimes see this form used in one-liners: 

@(posedge Clk) a&lt;= 1'b1;
",,,,,
When must a signal be inserted into the sensitivity list of a process,"I am confused about when a signal declared in an architecture must be inserted into the sensitivity list of a process. 

Is there is a general law that can be followed in any situation? 

I have real difficulties understanding when I have to include a signal in a process sensitivity list.","The ""general law"" is that 


  anything that your process needs to know about changes of needs to be in the sensitivity list.




For a typical synthesisable register with a synchronous reset:

process (clk) is
begin
    if rising_edge(clk) then
        if reset = '1' then
             -- do reset things
        else
             -- read some signals, assign some outputs
        end if;
    end if;
end process;


Only the clock needs to be in the list, as everything else is only looked at when the clock changes  (due to the if rising_edge(clk) statement.



If you need an asynchronous reset:

process (clk, reset) is
begin
    if reset = '1' then
        -- do reset things
    elsif rising_edge(clk) then
        -- read some signals, assign some outputs
    end if;
end process;


then the reset signal must also be in the sensitivity list, as your design needs to check the value of it every time it changes, irrespective of what the clock is doing.



For combinatorial logic, I avoid using processes completely because of the problems keeping the sensitivity list up-to-date, and the potential for simulation then behaving differently to the synthesised code.  This has been eased by the all keyword in VHDL-2008, but I still haven't found myself wanting to write long complicated combinatorial logic such that a process would help.",,,,,
How to declare an output with multiple zeros in VHDL,"Hello i am trying to find a way to replace this command: Bus_S &lt;= ""0000000000000000000000000000000"" &amp; Ne; with something more convenient. Counting zeros one by one is not very sophisticated. The program is about an SLT unit for an ALU in mips. The SLT gets only 1 bit(MSB of an ADDSU32) and has an output of 32 bits all zeros but the first bit that depends on the Ne=MSB of ADDSU32. (plz ignore ALUop for the time being)

entity SLT_32x is
   Port ( Ne : in  STD_LOGIC;
         ALUop : in STD_LOGIC_VECTOR (1 downto 0);
         Bus_S : out  STD_LOGIC_VECTOR (31 downto 0));
end SLT_32x;

architecture Behavioral of SLT_32x is
begin
  Bus_S &lt;= ""0000000000000000000000000000000"" &amp; Ne; 
end Behavioral;


Is there a way to use (30 downto 0)='0' or something like that? Thanks.","Try this: bus_S &lt;= (0 =&gt; Ne, others =&gt; '0')
It means: set bit 0 to Ne, and set the other bits to '0'.",,,,,
Can you program FPGAs in C-like languages?,"At university I programmed a FPGA in a C-like language. However, I also know that one usually programs FPGAs in Verilog or VHDL. Is this a designer choice? If so, what are the performance drawbacks?

I would ideally like to program the FPGA in a C-like language, rather than VHDL.

I was thinking of getting an Xilinx Virtex-5 if it makes any difference?","The short answer is ""yes, certainly"".

Here's an excellent survey of C compilers for FPGAs and FPGA-based systems.

C-to-hardware compiler (HLL synthesis)

Performance drawbacks and considerations are found in the system architecture and communication bandwidths rather than in using C vs. a hardware design language (HDL). The considerations in using C vs. an HDL lies in programming time and software maintenance issues, not so much in performance.",,,,,
How to initialize contents of inferred Block RAM (BRAM) in Verilog,"I am having trouble initializing the contents of an inferred ram in Verilog. The code for the ram is as below:

module ram(
        input clock, // System clock
        input we, // When high RAM sets data in input lines to given address
        input [13:0] data_in, // Data lines to write to memory
        input [10:0] addr_in, // Address lines for saving data to memory
        input [10:0] addr_out, // Address for reading from ram
        output reg data_out // Data out
);

reg [13:0] ram[2047:0];

// Initialize RAM from file
// WHAT SHOULD GO HERE?

always @(posedge clock) begin
    // Save data to RAM
    if (we) begin
        ram[addr_in] &lt;= data_in;
    end

    // Place data from RAM
    data_out &lt;= ram[addr_out];
end        
endmodule


I have run into the command $readmemh. However, documentation for it seems sparse. How should I format the file that contains the data? Also, how can I pass the file as argument when instantiating this module so that I can have different instances of this module load from different files?

I want the initialized content to be available for both simulation and actual implementation. So that the FPGA already boots with this content in RAM.

I am using Vivado 2015.4 to program a Kintex xc7k70 FPGA.","You are correct that you should use $readmemh inside an initial block. In order to make it so different instances of the module can have different initialization files, you should use a parameter like so:

parameter MEM_INIT_FILE = """";
...
initial begin
  if (MEM_INIT_FILE != """") begin
    $readmemh(MEM_INIT_FILE, ram);
  end
end


The format is described in Section 21.4 of the IEEE1800-2012 specification; typically the file is just a bunch of lines containing hex numbers of the correct bit-length, like so:

0001
1234
3FFF
1B34
...


Note that there is no ""0x"" prefix and each line represents an adjacent address (or any separating whitespace). In the example above, $readmemh would put 14'h0001 into ram[0], 14'h1234 into ram[1], 14'h3FFF into ram[2] and so on. You can also include comments in the hex file using // or /* */. Finally, you can use the @ symbol to designate an address for the following numbers to be located at, like so:

@0002
0101
0A0A
...


In the above file, ram[0] and ram[1] would be uninitialized and ram[2] would get 14'h0101. Those are all the major constructs of the hex file format, though you can also use _, x and z as you would in other Verilog numbers and theres a few more rules you can read in the section sited above.",,,,,
Prefered syntax for verilog module declaration,"I am relatively new to FPGAs, and I am looking for some guidance for modern best practice regarding the declaration of modules in Verilog.

I have seen two ways of declaring a module in verilog.  The first reminds me of Traditional C, such as the examples on wikipedia:

module toplevel(clock,reset);
    input clock;
    input reset;

    /* snip */
endmodule


Whereas the alternative syntax has the input/output specifier as part of the argument list, not too dissimilar to VHDL, as in this example:

module fadder(
    input a,         //data in a
    input b,         //data in b
    input cin,       //carry in
    output sum_out,  //sum output
    output c_out     //carry output
);

/* snip */
endmodule


For newly written verilog code, which syntax is preferred?  ""Preferred"", in this instance, means something written in a standard or related material (either explicitly written, or implicitly by examples given in the standard), or written in a well-regarded style guide. The question isn't asking for a personal preference!","The second syntax form was indented to replace the first syntax form. If you look at the 1364-2001 Verlog LRM, as well as the current 1800-2012 SystemVerilog LRM, you will notice that all examples of module declarations use the second form. The first form is only there for legacy, but unfortunately, it has taken longer than expected for textbooks and course material to switch over.

The key benefit of this newer (or ANSI-style) syntax is that you only have to declare your port name in one place. With the older syntax, you had to declare a port name up to three times; once for the positional ordering, another time for the port direction, and if the port needed to be something other than a wire, a third time to declare its data type. ",,,,,
How to ignore output ports with port maps,"Well often in VHDL I notice that a certain component has multiple output ports. Ie in one of our examples we were given the following component:

COMPONENT eight_bitadder
  PORT ( a, b: in std_logic_vector(7 downto 0); 
        f: in std_logic; 
        C: out std_logic_vector(7 downto 0); 
        o, z: out std_logic);
END COMPONENT;


Where z determines if the result is 0, and o triggers on overflow.

Now in my case I wish to use this adder, however the actual result is not of importance, rather I only wish to check if the result is ""0"". I could of course add a dummy signal and store the port to this signal, however that seems needlessly complicated, and might add extra components during synthesis?","When you instantiate the component you can leave the output ports that you don't care about open.  The only signal you care about below is ""overflow"".

EDIT: Note that the synthesis tools will optimize away any outputs that are not being used.

EIGHT_BITADDER_INST : eight_bitadder
  port map (
    a =&gt; a,
    b =&gt; b, 
    f =&gt; f, 
    c =&gt; open, 
    o =&gt; overflow,
    z =&gt; open
    );
",,,,,
How can I use foreach and fork together to do something in parallel?,"This question is not UVM specific but the example that I am working on is UVM related.
I have an array of agents in my UVM environment and I would like to launch a sequence on all of them in parallel.

If I do the below:

foreach (env.agt[i])
  begin
    seq.start(env.agt[i].sqr);
  end


, the sequence seq first executes on env.agt[0].sqr. Once that gets over, it then executes on env.agt[1].sqr and so on.

I want to implement a foreach-fork statement so that seq is executed in parallel on all agt[i] sequencers.

No matter how I order the fork-join and foreach, I am not able to achieve that. Can you please help me get that parallel sequence launching behavior?

Thanks.

Update to clarify the problem I am trying to solve:
The outcome of the below code constructs is the exact same as above without the fork-join.


foreach (env.agt[i])
  fork
    seq.start(env.agt[i].sqr);
  join



fork
  foreach (env.agt[i])
    seq.start(env.agt[i].sqr);
  join



// As per example in Â§ 9.3.2 of IEEE SystemVerilog 2012 standard
for (int i=0; i&lt;`CONST; ++i)
  begin
    fork
      automatic int var_i = i;
      seq.start(env.agt[var_i].sqr);
    join
  end
","Greg's solution below helped me derive the solution to my UVM based problem. Here is my solution:
The below fork-join block resides in the main_phase task in a test case class. The wait fork; statement waits for all the fork statements in its scope (= the foreach_fork begin-end block) to finish before proceeding further. An important thing to note is that the wrapping fork-join around the begin-end was required for setting the scope of wait fork; to the foreach_fork block.

fork 
  begin : foreach_fork
    seq_class seq **[`CONST]**;
    foreach(env.agt[i])
      begin
        int j = i;
        **seq[j] = seq_class::type_id::create
                  (.name($sformatf(""seq_%0d"", j)), .contxt(get_full_name()));**
        fork
          begin
            seq[j].start(env.agt[j].sqr);
          end
        join_none // non-blocking thread
      end
    **wait fork;**
  end : foreach_fork  
join

Alternative solution that makes use of the in-sequence objection to delay the sim end.

begin
  seq_class seq **[`CONST]**;
  foreach(env.agt[i])
    begin
      int j = i;
      **seq[j] = seq_class::type_id::create
                (.name($sformatf(""seq_%0d"", j)), .contxt(get_full_name()));**
      fork
        begin
          **seq[j].starting_phase = phase;**
          seq[j].start(env.agt[j].sqr);
        end
      join_none // non-blocking thread
    end
end  

I realized that I also needed to create a new sequence object for each seq I wanted to run in parallel.
Thanks to Dave for making the point that the properties in System Verilog classes are automatic by default.
Note for the alternative solution:
As I didn't use wait fork; I use the UVM objections raised in the sequence itself to do the job of holding off the simulation $finish call. To enable raising of the objections in the sequences, I use the seq[j].starting_phase = phase; construct.",,,,,
Include a module in verilog,I want to include a verilog module into another file. How do I include it in the code and how do I compile the code to include the header file? Is it like in c?,"
A basic example can include them both in the same file as shown on page 4 of verilog in a day.
All files in the same folder should be automatically found. 
Include them as shown in Hello_World_Program_Output or Example below.
Advanced workflows can have files.f listing the verilog or config files specifying include directories.


Include example for (3):

`include ""folder/sub.sv""
module top;
  sub sub_i(
    .a(),
    .b()
    ...


The file extension .v is used for verilog compilation, your compiler should use the latest standard up to Verilog 2005. The .sv extension is for SystemVerilog. Which replaced Verilog in 2009. The file extension causes the compiler to switch to SystemVerilog.",,,,,
Is integer overflow defined in VHDL?,"I was wondering if integer overflow is defined in VHDL. I wasn't able to find anything in the 2002 Specification.

As an example (Note, this might not compile, it's just a generic example...):

entity foo is port (
    clk : std_logic
);
end entity;

architecture rtl of foo is
    signal x : integer range 0 to 2 := 0;
begin
    process (clk)
    begin
        if rising_edge(clk) then
            x &lt;= x + 1;
        end if;
    end process;
end architecture;


It's clear that x will go from 0 to 1, and then to 2. Is it defined what will happen on the next increment? Is that undefined behavior?","for a test bench for rtl of foo in ghdl:

ghdl -r foo_tb --wave=foo_tb.ghw
./foo_tb:error: bound check failure at foo_tb.vhdl:15
./foo_tb:error: simulation failed

I added a context clause to Bill's foo entity and architecture:
library ieee;
use ieee.std_logic_1164.all;

entity foo is port (

Line 15 is the signal assignment to x:
            x &lt;= x + 1;

This is a simulation error (occurs at runtime).
From IEEE 1076-1993:
7.2.4 Adding operators

The adding operators + and - are predefined for any numeric type and have their conventional mathematical meaning.

This means the result of the &quot;+&quot; operator can be outside the subtype constraint of x. Note that a function declared to provide an overload for the &quot;+&quot; is not allowed to specify the result subtype. (The returned value may be an object declared with a subtype indication, which can define the value range or an array length).
and 12.6.2 Propagation of signal values

In order to update a signal during a given simulation cycle, the kernel process first determines the driving and effective values of that signal. The kernel process then updates the variable containing the current value of the signal with the newly determined effective value, as follows:

a) If S is a signal of some type that is not an array type, the effective value of S is used to update the current value of S. A check is made that the effective value of S belongs to the subtype of S. An error occurs if this subtype check fails. Finally, the effective value of S is assigned to the variable representing the current value of the signal.


If the result of the addition doesn't match the subtype constraint of the target x it will generate an error.  That subtype constraint is provided by the object x declaration which provides a subtype indication for an integer (the range).
A run-time error causes the simulation to terminate for an LRM compliant implementation.
Without a standardized format for error reporting ghdl does not provide the current simulation time.  That can be found be examining the produced waveform:

The waveform quite being updated after 20 ns. The next scheduled event:
library ieee;
use ieee.std_logic_1164.all;

entity foo_tb is
end entity;

architecture foo of foo_tb is
    signal clk: std_logic := '0';
begin
DUT:
    entity work.foo
        port map (
            clk =&gt; clk
        );
        
CLOCK:
    process
    begin
        wait for 5 ns;
        clk &lt;= not clk;
        if now &gt; 30 ns then
            wait;
        end if;
    end process;
    
end architecture;

would have been the rising edge of clk at 25 ns.
So this tells us how a constrained integer produces an overflow error.
What about an integer without a subtype constraint:
architecture fum of foo is
    signal x : integer := INTEGER'HIGH - 2;
begin
    process (clk)
    begin
        if rising_edge(clk) then
            x &lt;= x + 1;
        end if;
    end process;
end architecture;

We define x as an unconstrained integer set it's default value where we expect x to overflow.
Package standard explicity declares INTEGER &quot;+&quot;:
--  function &quot;+&quot;      (anonymous, anonymous: INTEGER) return INTEGER;

The expected result is outside the range of INTEGER if as we see &quot;+&quot; has it's ordinary mathematical meaning.
However, from the implementation dependent declaration in package standard:
type integer is range -2147483648 to 2147483647;

and simulation:

We see the value of x wrap around.
The assignment of the &quot;+&quot; operator result violated no constraint:
3 Types:

The set of possible values for an object of a given type can be subjected to a condition that is called a constraint (the case where the constraint imposes no restriction is also included); a value is said to satisfy a constraint if it satisfies the corresponding condition. A subtype is a type together with a constraint. A value is said to belong to a subtype of a given type if it belongs to the type and satisfies the constraint; the given type is called the base type of the subtype. A type is a subtype of itself; such a subtype is said to be unconstrained (it corresponds to a condition that imposes no restriction). The base type of a type is the type itself.

In our second architecture and there is no constraint but there are no possible values outside the declared range for type INTEGER. The value instead rolls over.
The semantics for VHDL have been constructed to not require detection here and this matches mathematical operations on single dimensional arrays of elements representing binary bits (hardware).",,,,,
How to represent Integer greater than integer'high,"Is there any way to use pre-defined types from STD_LOGIC_1164 or STD_NUMERIC to represent an integer ranging from 0 to 2^32-1 ? (considering the default integer type ranges from -2^31-1 to 2^31-1)

I need to implement 32-bit counter and was looking for some way to save code using integer type instead of std_logic_vector.. Any design pattern for this ?

Or, better asked: Whats the best way to declare a 32-bit (unsigned) integer supporting the operations >/&lt;, =, +-/ ?

Tahnks in advance

Edit1: One option I found was to declare a signal as std_logic_vector(31 downto 0), and to perform conversions when doing comparisons or +- operations.. ex: counter &lt;= counter + std_logic_vector(unsigned(value) + 1).. Still haven't found a way to do division though (in case,for example, 1/4 of the value of counter is needed)","Using the Integer types, you cannot (at least, not portably; there may be some VHDL tools that go beyond the minimum and offer a 64-bit integer)

Using IEEE.numeric_std, you can declare an Unsigned with a full 32-bit range (or 53-bit if you wish) and it should do everything you want.need, unless I misunderstand what you are asking.",,,,,
"$size, $bits, verilog","What is the difference between $size and $bits operator in verilog.?
if I've variables, [9:0]a,[6:0]b,[31:0]c.

c &lt;= [($size(a)+$size(b)-1]-:$bits(b)];


What will be the output at 'c' from the above expression?","$size shall return the number of elements in the dimension, which is equivalent to $high - $low + 1. It is relative to the dimension, not only bit counts. If the type is 1D packed array or integral type, it is equal to $bits.

$bits system function returns the number of bits required to hold an expression as a bit stream.  

$bits ( [expression|type_identifier] )


It returns 0 when called with a dynamically sized type that is currently empty. It is an error to use the $bits system function directly with a dynamically sized type identifier.

I have no idea about your question, c &lt;= [($size(a)+$size(b)-1]-:$bits(b)];. Is it a valid expression in RHS? Are you talking about the array range expression, [n +: m] or [n -: m] ?",,,,,
Reverse bit order on VHDL,"I'm having trouble doing something like

b(0 to 7) &lt;= a(7 downto 0)


when I compile it with ghdl, I have an order error. The only way I have found to make my circuit work is the following:

library ieee;
use ieee.std_logic_1164.all;
entity reverser is
    port(
        a: in std_logic_vector(7 downto 0);
        y: out std_logic_vector(7 downto 0);
        rev: in std_logic
        );
end reverser;

architecture rtl of reverser is
    signal b: std_logic_vector (7 downto 0);

begin

    b(7) &lt;= a(0);
    b(6) &lt;= a(1);
    b(5) &lt;= a(2);
    b(4) &lt;= a(3);
    b(3) &lt;= a(4);
    b(2) &lt;= a(5);
    b(1) &lt;= a(6);
    b(0) &lt;= a(7);

    y &lt;= b when rev = '1' else a;

end rtl;


Suggestions?
Thanks in advance","That's not allowed - VHDL is so strongly typed that if you want to reverse bit orders, you have to do it explicitly.

The standard solution is to use a function (I didn't write this - Jonathan Bromley did):

function reverse_any_vector (a: in std_logic_vector)
return std_logic_vector is
  variable result: std_logic_vector(a'RANGE);
  alias aa: std_logic_vector(a'REVERSE_RANGE) is a;
begin
  for i in aa'RANGE loop
    result(i) := aa(i);
  end loop;
  return result;
end; -- function reverse_any_vector
",,,,,
"Difference of SystemVerilog data types (reg, logic, bit)","There are different data types in systemverilog that can be used like the following:

reg [31:0] data;
logic [31:0] data;
bit [31:0] data;


How does the three of them differ?","reg and wire were the original types. Wires are constantly assigned and regs are evaluated at particular points, the advantage here is for the simulator to make optimisations.

wire w_data;
assign w_data = y;

// Same function as above using reg
reg r_data;
always @* 
  r_data = y ;


A common mistake when learning Verilog is to assume the a reg type implies a register in hardware. The earlier optimisation for the simulator can be done through the context of its usage.

This introduces logic which can be used in place of wire and reg.

logic  w_data;
assign w_data = y;

// Same function as above using reg
logic r_data;
always @* 
  r_data = y ;


The type bit and byte have also been created that can only hold 2 states 0 or 1 no x or z. byte implies bit [7:0]. Using these types offers a small speed improvement but I would recommend not using them in RTL as your verification may miss uninitialized values or critical resets.

The usage of bit and byte would be more common in testbench components, but can lead to issues in case of having to drive x's to stimulate data corruption and recovery.



Update

At the time of writing I was under the impression that logic could not be used for tristate, I am unable to find the original paper that I based this on. Until further updates, comments or edits, I revoke my assertion that logic can not be used to create tri-state lines.



The tri type has been added, for explicitly defining a tri-state line. It is based on the properties of a wire, logic is based on the properties of a reg.

tri t_data;
assign t_data = (drive) ? y : 1'bz ;


If you no longer have to support backwards compatibility Verilog then I would recommend switching to using logic and tri. Using logic aids re-factoring and and tri  reflects the design intent of a tristate line.",,,,,
Using hex values in constants,"I am trying to create a few constants and assign hex numbers to them; however, I keep getting errors.
I want the constant FOO_CONST to be equal to 0x38
Like this...
constant FOO_CONST : integer := x&quot;38&quot;;
The error:
Type integer does not match with a string literal
I've tried a few variants with no success.","You can specify a base for integers by using the format base#value#:

constant FOO_CONST : integer := 16#38#;
",,,,,
Verilog code error,"I am getting error in this code. The code is for a 4 bit comparator. The error is that I get ""unspecified"" output in the out1 port.

Please help.

module bitCompare(num1,num2,out1,out2);

    parameter n = 3;

    output out1;
    output out2;
    input  [n:0] num1;
    input  [n:0] num2;

    wire [n:0] eq;
    wire x0,x1,x2,x3;
    wire a,b,c,d;
    wire an;

    // Comparator in structural mode
    xnor xn1(x0,num1[0],num2[0]);
    xnor xn2(x1,num1[1],num2[1]);
    xnor xn3(x2,num1[2],num2[2]);
    xnor xn4(x3,num1[3],num2[3]);
    and  a1(out2,x0,x1,x2,x3);
    not  n1(an,num1[3]);
    and  a2(a,an,num2[3]);
    not  n2(an,num1[2]);
    and  a3(b,x3,an,num2[2]);
    not  n3(aN,num1[1]);
    and  a4(c,x3,x2,an,num2[1]);
    not  n4(an,num1[0]);
    and  a5(d,x3,x2,x1,an,num2[0]);
    or   o1(out1,a,b,c,d);
endmodule

module Testbench;

    reg [3:0] numb1, numb2;
    wire outp1;
    wire outp2;
    bitCompare c(numb1, numb2,outp1,outp2);

    initial
    begin
    //case 0
        numb1 &lt;= 4'b0000;
        numb2 &lt;= 4'b0001;  #20;  $display(""isEqual= %b\t"",outp2); $display(""less= %b\n"",outp1);
        numb1 &lt;= 4'b1111;
        numb2 &lt;= 4'b1111;  #10;  $display(""isEqual= %b\t"",outp2); $display(""less= %b\n"",outp1);
        numb1 &lt;= 4'b1000;
        numb2 &lt;= 4'b1010;  #10;  $display(""isEqual= %b\t"",outp2); $display(""less= %b\n"",outp1);
        numb1 &lt;= 4'b0111;
        numb2 &lt;= 4'b0111;  #10;  $display(""isEqual= %b\t"",outp2); $display(""less= %b\n"",outp1);
    //case2
    end
endmodule
","Verilog simulates almost everything in parallel. When a net has multiple drivers, the values values need to be resolved. If the drivers are all the same value, then the output will have a known value. If the driving values do not match, the output is X. There is not last assignment wins except within an blocking statements. 

Verilog allows multiple drivers on a net and it is not going to warn you about it. Insuring a single-driver can be done by switching to SystemVerilog and assign values within always_comb, always_ff, and always_latch blocks.",,,,,
Convert enum type to std_logic_vector VHDL,"I want to know if it is possible to convert a enum type, like FSM states to std_logic_vector or integer. I'm doing a testbench with OSVVM for a FSM and I want to use the scoreboard package to automatically compare the expected state with the actual one.

Thanks!","To convert to integer, use:

IntVal := StateType'POS(State) ; 


From there, it is easy to convert to std_logic_vector, but I prefer to work with integers when possible as they are smaller in storage than std_logic_vector.   For verification, it will be easier if you start to think more about integers when the value is less than 32 bits.

If you need it as std_logic_vector, using only numeric_std you can:

Slv8Val := std_logic_vector(to_unsigned(IntVal, Slv8Val'length)) ; 


For verification, I liberally use numeric_std_unsigned, so the conversion is a easier:

Slv8Val := to_slv(IntVal, Slv8Val'length) ; 


In the event you have an integer and want to convert it back to a enumerated value, you can use 'VAL.

State := StateType'VAL(IntVal) ; 


In OSVVM, we use records with resolved values to create a transaction interface.  We have a resoled types for integers (osvvm.ResolutionPkg.integer_max).   We transfer enumerated values through the record using 'POS (as we put it in) and 'VAL (as we get it out).

Note don't confuse 'VAL with 'VALUE.   'VALUE converts a string to a value - opposite to 'IMAGE.

You of course learn all of this in SynthWorks' OSVVM class :).",,,,,
"Is it necessary to seperate combinational logic from sequential logic while coding in VHDL, while aiming for synthesis?","I am working on projects which requires synthesis of my RTL codes specifically for ASIC development. Given the case, how much important is it, to separate sequential logic from differential logic while designing my RTLs ? And if it is important, then what should be my approach while designing, as if how should I differentiate my design for sequential and combinational logic?","In general, I would not hesitate to mix combinational with sequential logic. I come from an IC design background and have always mixed up combinational logic with sequential. I think that you are restricting yourself too much if you don't and are not fully using the power of your logic synthesiser. 

For example, here is how I would design a simple, asynchronously-reset counter in VHDL:

  process (Clock, Reset)
  begin
    if Reset = '1' then
      Cnt &lt;= (others =&gt; '0');
    elsif Rising_edge(Clock) then
      if Enable = '1' then
          Cnt &lt;= Cnt + 1;
      end if;
    end if;
  end process;


This style of writing a counter in VHDL is ubiquitous. I personally can see no advantage to splitting the code up into two separate processes, one sequential the other combinational. I have just taught a room full of engineers to design a counter in exactly this way.

Here are some exceptions. I would split the combinational logic from the sequential logic if:

i) I were designing a state machine:

There is what I think is a really elegant way of coding a state machine, where you do split the combinational logic from the sequential:

  Registers: process (Clock, Reset)
  begin
    if Reset = '1' then
      State &lt;= Idle;
    elsif Rising_edge(Clock) then
      State &lt;= NextState;
    end if;
  end process Registers;

  Combinational: process (State, Inputs)
  begin
    NextState &lt;= State;
    Output1 &lt;= '0';
    Output2 &lt;= '0';
    -- etc
    case State is
      when Idle =&gt;
        if Inputs(1) = '1' then
          NextState &lt;= State2;
        end if;
      when State2=&gt;
        Output1 &lt;= '1';
        if Inputs = ""00"" then
          NextState &lt;= State3;
        end if;
      -- etc
    end case;
  end process Combinational;


The advantage of coding a state machine like this is that the combinational process looks very like the state diagram. It is less error prone to write, less error prone to modify and less error prone to read.

ii) The combinational logic were complex:

For really big block of combinational logic, I would separate. The exact definition of ""really big"" is a matter of judgement.

iii) The combinational logic were on the Q output of a flip-flop:

Any signal driven in a sequential process infers a flip-flop. Therefore, if you wish to implement combinational logic that drives an output of an entity* then this combinational logic must be in a separate process.

*often not a good idea - be careful.",,,,,
"Difference between ""parameter"" and ""localparam""","I'm writing a project with Verilog and want to use parameter to define some parameter in my module. But when I read in some source code, localparam sometimes is used instead of parameter.

What's difference between them?","Generally, the idea behind the localparam (added to the Verilog-2001 standard) is to protect value of localparam from accidental or incorrect redefinition by an end-user (unlike a parameter value, this value can't be modified by parameter redefinition or by a defparam statement).

Based on IEEE 1364-2005 (ch. 4.10.2):


  Verilog HDL local parameters are identical to parameters except that they cannot directly be modified by defparam statements or module instance parameter value assignments. Local parameters can be assigned constant expressions containing parameters, which can be modified with defparam statements or module instance parameter value assignments.


Additionally, in SystemVerilog (IEEE 1800-2012 (ch. 6.20.4)):


  Unlike nonlocal parameters, local parameters can be declared in a generate block, package, class body, or compilation-unit scope. In these contexts, the parameter keyword shall be a synonym for the localparam keyword.
  Local parameters may be declared in a moduleâ€™s parameter_port_list. Any parameter declaration appearing in such a list between a localparam keyword and the next parameter keyword (or the end of the list, if there is no next parameter keyword) shall be a local parameter. Any other parameter declaration in such a list shall be a nonlocal parameter that may be overridden.


If you want to learn more about this topic, I'd recommend you Clifford E. Cummings paper ""New Verilog-2001 Techniques for Creating Parameterized Models (or Down With `define and Death of a defparam!)"".",,,,,
Synthesizable multidimensional arrays in VHDL,"I need to use multidimensional arrays to represent matrices in my design. I have tried the two available options: 


Declaring array of arrays 

type t11 is array (0 to c1_r2) of std_logic_vector(31 downto 0);
type t1 is array (0 to r1) of t11; --r1*c1_r2 matrix

Multidimensional arrays. 

type matrix  is array (natural range &lt;&gt;, natural range &lt;&gt;)
               of std_logic_vector(31 downto 0);



However, in both the cases my post synthesis simulation in xilinx gives me the error ""Sliced name is allowed only on single-dimensional arrays"". 
What is the correct way of using multidimensional arrays in synthesizable vhdl design? Any inputs would be welcome.

I am using the XST Synthesizer that comes with Xilinx ISE.
I am indexing both i and j, as my matrix dimension is m * n * 32.

My net a_in in the entity 

    a_in: in  matrix (0 to size - 1, 0 to size - 1);


got modified to

    a_in : in STD_LOGIC_VECTOR3 ( 1 downto 0 , 1 downto 0 , 31 downto 0 );


In my program, I access values from the matrix inside two generate statements for k and m as: 

    add_instx: add 
            port map (
                a =&gt; a_in(k,m),
                b =&gt; b_in(k,m),
                clk =&gt; clk,
                sclr =&gt; clr,
                ce =&gt; start,
                result =&gt; temp_out(k,m),
                rdy =&gt; add_over(k,m)
            );


My test bench input for a_in is given as

    a_in &lt;= ((""00111111100000000000000000000000"", ""00000000000000000000000000000000""),(""00000000000000000000000000000000"", ""00111111100000000000000000000000""));


My synthesis generated warnings of the type: Xst:387 - The KEEP property attached to the net  may hinder timing optimization. You may achieve better results by removing this property. However, I have not set any keep property and I am not sure where to look for this property. Please help! Thanks a lot.

I apologize for not adding the complete code. Please find below the code and package. 

    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;
    use IEEE.NUMERIC_STD.ALL;
    use work.mat_pak.all;


    entity newproj is
        generic ( size:  natural := 2 );
        port ( 
            clk:                in  std_logic;
            clr:                in  std_logic;
            start:              in  std_logic;
            a_in:               in  matrix (0 to size - 1, 0 to size - 1);
            b_in:               in  matrix (0 to size - 1, 0 to size - 1);
            aplusb:             out matrix (0 to size - 1, 0 to size - 1);
            parallel_add_done:  out std_logic);
    end newproj;

    architecture Behavioral of newproj is
    COMPONENT add --This is a 32 bit floating point add IP core
      PORT (
        a : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
        b : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
        clk : IN STD_LOGIC;
         sclr : IN STD_LOGIC;
         ce : IN STD_LOGIC;
        result : OUT STD_LOGIC_VECTOR(31 DOWNTO 0);
         rdy: OUT STD_LOGIC
      );
    END COMPONENT;

        signal temp_out: matrix (0 to size - 1, 0 to size - 1) :=  (others =&gt; (others =&gt; (others =&gt; '0')));  
        signal add_over: bmatrix (0 to size - 1, 0 to size - 1) := (others =&gt; (others =&gt; '0'));  

    begin

        g0: 
            for k in  0 to mat_dim generate 
            g0x: 
                for m in 0 to mat_dim generate
                add_instx: add 
                    port map (
                        a =&gt; a_in(k,m),
                        b =&gt; b_in(k,m),
                        clk =&gt; clk,
                        sclr =&gt; clr,
                        ce =&gt; start,
                        result =&gt; temp_out(k,m),
                        rdy =&gt; add_over(k,m)
                    );
            end generate;   
        end generate;

        aplusb &lt;= temp_out;

         p1_add:
        process (add_over)
            variable check_all_done: std_logic;
        begin
            check_all_done := '1';
            for k in 0 to mat_dim loop
                for m in 0 to mat_dim loop
                    check_all_done := check_all_done and add_over(k)(m);
                end loop;
            end loop;
            parallel_add_done &lt;= check_all_done;
        end process;

    end Behavioral;


The package used here is:

    library IEEE;
    use IEEE.STD_LOGIC_1164.all;
    use IEEE.NUMERIC_STD.ALL;


    package mat_pak is

        CONSTANT mat_dim : natural := 2;

        type matrix  is array (natural range &lt;&gt;, natural range &lt;&gt;)
                   of std_logic_vector(31 downto 0);
        type bmatrix is array (natural range &lt;&gt;, natural range &lt;&gt;) 
                   of std_logic;                      


    end mat_pak;


The post synthesis simulation model file modified the entity in terms of ordering and data type, on its own. The entity looks as below:

    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;
    library UNISIM;
    use UNISIM.VCOMPONENTS.ALL;
    use UNISIM.VPKG.ALL;

    entity newproj is
      port (
        clk : in STD_LOGIC := 'X'; 
        clr : in STD_LOGIC := 'X'; 
        start : in STD_LOGIC := 'X'; 
        parallel_add_done : out STD_LOGIC; 
        a_in : in STD_LOGIC_VECTOR3 ( 1 downto 0 , 1 downto 0 , 31 downto 0 ); 
        b_in : in STD_LOGIC_VECTOR3 ( 1 downto 0 , 1 downto 0 , 31 downto 0 ); 
        aplusb : out STD_LOGIC_VECTOR3 ( 1 downto 0 , 1 downto 0 , 31 downto 0 ) 
      );
    end newproj;
","Your first array is not a multi dimensional array, it's a 2-times nested 1 dimensional array.

Your example:

type t11 is array (0 to c1_r2) of std_logic_vector(31 downto 0);
type t1 is array (0 to r1) of t11;


This definition is more clear:

subtype t_dim1 is std_logic_vector(31 downto 0);
type t_dim1_vector is array(natural range &lt;&gt;) of t_dim1;
subtype t_dim2 is t_dim1_vector(0 to c1_r2);
type t_dim3_vector is array(natural range &lt;&gt;) of t_dim2;
subtype t_dim3 is t_dim3_vector(0 to r1);


You can access this structure by indexing each dimension:

signal matrix3 : t_dim3;
signal matrix2 : t_dim2;
signal matrix1 : t_dim1;
signal slv : std_logic_vector(31 downto 0);
signal sl : std_logic;

matrix2 &lt;= matrix3(i);
matrix1 &lt;= matrix2(j);
matrix1 &lt;= matrix3(i)(j);
slv &lt;= matrix3(i)(j);
sl &lt;= matrix3(i)(j)(k);


You can also slice each dimension:

signal matrix3 : t_dim3;
signal slice3 : t_dim3_vector(0 to 3);
signal slice2 : t_dim2_vector(0 to 3);
signal slv : std_logic_vector(7 downto 0);

slice3 &lt;= matrix3(4 to 7);
slice2 &lt;= matrix3(i)(2 to 5);
slice2 &lt;= slice3(i)(2 to 5);
slv &lt;= matrix3(i)(j)(15 downto 8);


Your second example:

type matrix is array (natural range &lt;&gt;, natural range &lt;&gt;) of std_logic_vector(31 downto 0);


This is a 2-dimensional array with a nested 1-dimensional array. This structure can be accessed as follows:

signal mat : matrix(0 to r1, p to c1_r2);
signal slv : std_logic_vector(31 downto 0);
signal sl : std_logic;

slv &lt;= mat(i, j);
sl &lt;= mat(i, j)(k);


Since VHDL-2008 slicing is also allowed in multi dimensional array. Before VHDL-2008 you have to employ functions for this job.

Have a look into my PoC.vectors package to see ways on how you can handle 1- and multi dimensional arrays.",,,,,
Why do we use functions in VHDL,"Functions are obviously less verbose to write than entities. But it implies many drawbacks, including:


No generic keyword equivalent
Only one output possible


It appears that functions can be called recursively. May it not be the case with entities? If so, is there any good reason to use functions except for aesthetic purposes?","Functions in vhdl make the code easy to maintain and read. generally architectures are very big and while debugging if something is not working you can easily find the problematic function and correct it  and no need to analyse the entire architecture body.

in case of small codes it's useless but in more big machines it makes you better understand if you consider it function wise. 

There is no rule for this so all comments are welcome.

in short : the advantage of functions are


overloading 
operators definition 
overloading of operators therefore
Better Structure of code
",,,,,
3-stage MD5 pipeline in VHDL,"I am trying to implement a 3-stage MD5 pipeline according to this link. In particular the algoritms on page 31. There is also another document which describes data forwarding. The MD5 algoritm is described in RFC1321. This is done in an FPGA (Terasic DE2-115). There is no schematics in this project, only VHDL code

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity md5core is
    port (
        CLOCK_50        : in std_logic;
        SW              : in std_logic_vector(17 downto 17)
    );
end entity md5core;

architecture md5core_rtl of md5core is
type r_array is array(0 to 64) of std_logic_vector(7 downto 0);
constant R        : r_array := ( x""07"", x""0c"", x""11"", x""16"", x""07"", x""0c"", x""11"", x""16"", x""07"", x""0c"", x""11"", x""16"", x""07"", x""0c"", x""11"", 
                                 x""16"", x""05"", x""09"", x""0e"", x""14"", x""05"", x""09"", x""0e"", x""14"", x""05"", x""09"", x""0e"", x""14"", x""05"", x""09"",
                                 x""0e"", x""14"", x""04"", x""0b"", x""10"", x""17"", x""04"", x""0b"", x""10"", x""17"", x""04"", x""0b"", x""10"", x""17"", x""04"",
                                 x""0b"", x""10"", x""17"", x""06"", x""0a"", x""0f"", x""15"", x""06"", x""0a"", x""0f"", x""15"", x""06"", x""0a"", x""0f"", x""15"",
                                 x""06"", x""0a"", x""0f"", x""15"", others =&gt; x""00"");

type k_array is array(0 to 66) of std_logic_vector(31 downto 0);
constant K        : k_array := (x""d76aa478"", x""e8c7b756"", x""242070db"", x""c1bdceee"",
                                x""f57c0faf"", x""4787c62a"", x""a8304613"", x""fd469501"",
                                x""698098d8"", x""8b44f7af"", x""ffff5bb1"", x""895cd7be"",
                                x""6b901122"", x""fd987193"", x""a679438e"", x""49b40821"", 
                                x""f61e2562"", x""c040b340"", x""265e5a51"", x""e9b6c7aa"",
                                x""d62f105d"", x""02441453"", x""d8a1e681"", x""e7d3fbc8"",
                                x""21e1cde6"", x""c33707d6"", x""f4d50d87"", x""455a14ed"",
                                x""a9e3e905"", x""fcefa3f8"", x""676f02d9"", x""8d2a4c8a"",
                                x""fffa3942"", x""8771f681"", x""6d9d6122"", x""fde5380c"",
                                x""a4beea44"", x""4bdecfa9"", x""f6bb4b60"", x""bebfbc70"",
                                x""289b7ec6"", x""eaa127fa"", x""d4ef3085"", x""04881d05"",
                                x""d9d4d039"", x""e6db99e5"", x""1fa27cf8"", x""c4ac5665"",
                                x""f4292244"", x""432aff97"", x""ab9423a7"", x""fc93a039"",
                                x""655b59c3"", x""8f0ccc92"", x""ffeff47d"", x""85845dd1"",
                                x""6fa87e4f"", x""fe2ce6e0"", x""a3014314"", x""4e0811a1"",
                                x""f7537e82"", x""bd3af235"", x""2ad7d2bb"", x""eb86d391"", others =&gt; x""00000000"");

type g_array is array(0 to 64) of integer range 0 to 15;
constant g_arr      : g_array := (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                                          1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12,
                                          5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2,
                                          0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9, 0);                                               

type w_array is array(0 to 15) of std_logic_vector(31 downto 0);
signal W            : w_array;

constant AA        : std_logic_vector(31 downto 0) := x""67452301"";
constant BB        : std_logic_vector(31 downto 0) := x""EFCDAB89"";
constant CC        : std_logic_vector(31 downto 0) := x""98BADCFE"";
constant DD        : std_logic_vector(31 downto 0) := x""10325476"";

signal res_A    : std_logic_vector(31 downto 0) := x""00000000"";
signal res_B    : std_logic_vector(31 downto 0) := x""00000000"";
signal res_C    : std_logic_vector(31 downto 0) := x""00000000"";
signal res_D    : std_logic_vector(31 downto 0) := x""00000000"";

type in_str_t is array(0 to 5) of std_logic_vector(7 downto 0);
constant in_str    : in_str_t := (x""68"", x""65"", x""6c"", x""6c"", x""6f"", x""6f"");

type pad_str_t    is array(0 to 63) of std_logic_vector(7 downto 0);
signal pad_str    : pad_str_t;

type state_t is (start, padding, init_w, state_1, state_2, state_3, state_4, done);
signal state    : state_t;

signal a, b, c, d, f    : std_logic_vector(31 downto 0) := x""00000000"";
signal i                : integer range 0 to 64 := 0;
signal g                        : integer range 0 to 15 := 0;
--signal tmp_b              : std_logic_vector(31 downto 0);

signal akw                  : std_logic_vector(31 downto 0);
signal ak                   : std_logic_vector(31 downto 0);
signal b_tmp                : std_logic_vector(31 downto 0);
begin

    --tmp_b &lt;= std_logic_vector(unsigned(b) + rotate_left(unsigned(a) + unsigned(f) + unsigned(K(i)) + unsigned(W(g)), to_integer(unsigned(R(i)))));

    pipe_p : process(CLOCK_50, SW, a, b, c, d, i)
    begin
        if SW(17) = '0' then
--          ak &lt;= std_logic_vector(unsigned(K(2)) + unsigned(BB));
--          akw &lt;= std_logic_vector(unsigned(W(0)) + 1 + unsigned(K(2)) + unsigned(BB));
            b_tmp &lt;= BB;
        elsif rising_edge(CLOCK_50) and state = state_1 then
            if i = 0 then
                ak &lt;= std_logic_vector(unsigned(K(0)) + unsigned(a));
            elsif i = 1 then
                ak &lt;= std_logic_vector(unsigned(K(1)) + unsigned(a));
                akw &lt;= std_logic_vector(unsigned(W(0)) + unsigned(ak));
            elsif i = 2 then
                ak &lt;= std_logic_vector(unsigned(K(2)) + unsigned(a));
                akw &lt;= std_logic_vector(unsigned(W(1)) + unsigned(ak));
                b_tmp &lt;= std_logic_vector(unsigned(b) + (rotate_left(unsigned(akw) + unsigned(f), to_integer(unsigned(R(0))))));
            else
                ak &lt;= std_logic_vector(unsigned(K(i)) + unsigned(a));
                akw &lt;= std_logic_vector(unsigned(W(g_arr(i-1))) + unsigned(ak));
                b_tmp &lt;= std_logic_vector(unsigned(b) + (rotate_left(unsigned(akw) + unsigned(f), to_integer(unsigned(R(i-2))))));
            end if;
        end if;
    end process pipe_p;


    md5_f_p : process(state, a, b, c, d, i)
    begin 
        case state is
            when state_1 =&gt;
                if i = 0 or i &gt; 4 then
                    f &lt;= (b and c) or ((not b) and d);
                    g &lt;= g_arr(i);
                end if;

            when state_2 =&gt;
            f &lt;= (d and b) or ((not d) and c);
                g &lt;= g_arr(i);

            when state_3 =&gt;
                f &lt;= b xor c xor d;
            g &lt;= g_arr(i);

            when state_4 =&gt;
                f &lt;= c xor (b or (not d));
            g &lt;= g_arr(i);

            when others =&gt;
                f &lt;= x""00000000"";
                g &lt;= 0;             

        end case;
    end process md5_f_p;

     md5_p : process(CLOCK_50, SW, a, b, c, d, f, g)
     begin
        if SW(17) = '0' then
            state &lt;= start;
                i &lt;= 0;
                a &lt;= AA;
            b &lt;= BB;
            c &lt;= CC;
            d &lt;= DD;                
            W &lt;= (others =&gt; x""00000000"");
                pad_str &lt;= (others =&gt; x""00"");
                --tmp_b := BB;
        elsif rising_edge(CLOCK_50) then
            case state is            
                when start =&gt;

                    pad_str(0) &lt;= in_str(0);
                    pad_str(1) &lt;= in_str(1);
                    pad_str(2) &lt;= in_str(2);
                    pad_str(3) &lt;= in_str(3);
                    pad_str(4) &lt;= in_str(4);
                    pad_str(5) &lt;= in_str(5);
                    state &lt;= padding;

                when padding =&gt;
                    pad_str(6) &lt;= ""10000000"";
                    pad_str(56) &lt;= std_logic_vector(to_unsigned(in_str'length*8, 8));
                          state &lt;= init_w;

                when init_w =&gt;                
                    W(0) &lt;= pad_str(3) &amp; pad_str(2) &amp; pad_str(1) &amp; pad_str(0);
                    W(1) &lt;= pad_str(7) &amp; pad_str(6) &amp; pad_str(5) &amp; pad_str(4);
                    W(14) &lt;= pad_str(59) &amp; pad_str(58) &amp; pad_str(57) &amp; pad_str(56);
                          state &lt;= state_1;

                when state_1 =&gt;
                          if i = 16 then
                              state &lt;= state_2;
                          else 
                        if i &gt; 2 then
                                    --tmp_b := b;
                                    a &lt;= d;
                                    c &lt;= b;
                                    d &lt;= c;
                                    b &lt;= b_tmp;

--                                  d &lt;= c;
--                                  b &lt;= b_tmp;
--                                  c &lt;= b;
--                                  a &lt;= d;
                                end if;
                                i &lt;= i + 1;
                    end if;

                when state_2 =&gt;
                    if i = 32 then
                        state &lt;= state_3;
                          else                  
                        d &lt;= c;
                        b &lt;= b_tmp;
                                c &lt;= b;
                        a &lt;= d;
                        i &lt;= i + 1;
                    end if;

                when state_3 =&gt;
                    if i = 48 then
                                state &lt;= state_4;
                          else
                        d &lt;= c;
                        b &lt;= b_tmp;
                                c &lt;= b;
                        a &lt;= d;
                        i &lt;= i + 1;
                    end if;

                when state_4 =&gt;
                    if i = 64 then
                                res_A &lt;= std_logic_vector(unsigned(AA) + unsigned(a));
                                res_B &lt;= std_logic_vector(unsigned(BB) + unsigned(b));
                                res_C &lt;= std_logic_vector(unsigned(CC) + unsigned(c));
                                res_D &lt;= std_logic_vector(unsigned(DD) + unsigned(d));
                                state &lt;= done;
                    else
                        d &lt;= c;
                        c &lt;= b;
                                b &lt;= b_tmp;
                        a &lt;= d;
                        i &lt;= i + 1;
                    end if;

                when done =&gt;
                    state &lt;= done;

                when others =&gt;
                    state &lt;= done;

            end case;
        end if;
    end process md5_p;
end architecture md5core_rtl;


Using this code, I get correct values for b in the first stage of round 0, but thereafter nothing seems to fit. As seen in this simulation, first stage in round 0 is correct, but thereafter not. This is when using a in this expression:

ak &lt;= std_logic_vector(unsigned(K(0)) + unsigned(a)); -- using a




But... If I understand the second document correctly I should be using c instead of a (data forwarding), but then the first stage in round 0 doesn't work either. I.e when I do this, the first stage in round 0 gets the wrong numbers too.

ak &lt;= std_logic_vector(unsigned(K(0)) + unsigned(c)); -- changed to c


For the particular string in the code (helloo) the following values are correct (all stages).

i:0 =&gt; a:271733878, b:3679623978, c:4023233417, d:2562383102, f:2562383102, g:0
i:1 =&gt; a:2562383102, b:268703616, c:3679623978, d:4023233417, f:3421032412, g:1
i:2 =&gt; a:4023233417, b:566857930, c:268703616, d:3679623978, f:4291410697, g:2
i:3 =&gt; a:3679623978, b:2813098031, c:566857930, d:268703616, f:3658619808, g:3
i:4 =&gt; a:268703616, b:3540887984, c:2813098031, d:566857930, f:831002506, g:4
i:5 =&gt; a:566857930, b:1416558949, c:3540887984, d:2813098031, f:2748069994, g:5
i:6 =&gt; a:2813098031, b:1417573490, c:1416558949, d:3540887984, f:4086081834, g:6
i:7 =&gt; a:3540887984, b:412978483, c:1417573490, d:1416558949, f:3614439904, g:7
i:8 =&gt; a:1416558949, b:2667121787, c:412978483, d:1417573490, f:1417573494, g:8
i:9 =&gt; a:1417573490, b:3587014656, c:2667121787, d:412978483, f:1486847027, g:9
i:10 =&gt; a:412978483, b:2424005293, c:3587014656, d:2667121787, f:2631470387, g:10
i:11 =&gt; a:2667121787, b:3779826569, c:2424005293, d:3587014656, f:2663976018, g:11
i:12 =&gt; a:3587014656, b:2371593944, c:3779826569, d:2424005293, f:2496594569, g:12
i:13 =&gt; a:2424005293, b:2829036837, c:2371593944, d:3779826569, f:2439758509, g:13
i:14 =&gt; a:3779826569, b:1652927941, c:2829036837, d:2371593944, f:3378230920, g:14
i:15 =&gt; a:2371593944, b:343664023, c:1652927941, d:2829036837, f:2917117725, g:15
i:16 =&gt; a:2829036837, b:3610776431, c:343664023, d:1652927941, f:1109108165, g:1
i:17 =&gt; a:1652927941, b:2356907245, c:3610776431, d:343664023, f:1450852695, g:6
i:18 =&gt; a:343664023, b:1950114052, c:2356907245, d:3610776431, f:3346765549, g:11
i:19 =&gt; a:3610776431, b:1998115502, c:1950114052, d:2356907245, f:1551601028, g:0
i:20 =&gt; a:2356907245, b:2811855282, c:1998115502, d:1950114052, f:1948049836, g:5
i:21 =&gt; a:1950114052, b:1476613917, c:2811855282, d:1998115502, f:655922090, g:10
i:22 =&gt; a:1998115502, b:1051434612, c:1476613917, d:2811855282, f:3498136348, g:15
i:23 =&gt; a:2811855282, b:2313778686, c:1051434612, d:1476613917, f:2123093565, g:4
i:24 =&gt; a:1476613917, b:2391742621, c:2313778686, d:1051434612, f:782884220, g:9
i:25 =&gt; a:1051434612, b:2587925491, c:2391742621, d:2313778686, f:2412476830, g:14
i:26 =&gt; a:2313778686, b:1270631524, c:2587925491, d:2391742621, f:2386958835, g:3
i:27 =&gt; a:2391742621, b:2967137637, c:1270631524, d:2587925491, f:449612646, g:8
i:28 =&gt; a:2587925491, b:4275359302, c:2967137637, d:1270631524, f:3523005797, g:13
i:29 =&gt; a:1270631524, b:221196138, c:4275359302, d:2967137637, f:4208389445, g:2
i:30 =&gt; a:2967137637, b:1826025400, c:221196138, d:4275359302, f:1309552482, g:7
i:31 =&gt; a:4275359302, b:4266766346, c:1826025400, d:221196138, f:1845489448, g:12
i:32 =&gt; a:221196138, b:3855169043, c:4266766346, d:1826025400, f:2678616280, g:5
i:33 =&gt; a:1826025400, b:1648727666, c:3855169043, d:4266766346, f:2001627553, g:8
i:34 =&gt; a:4266766346, b:3280661187, c:1648727666, d:3855169043, f:2044530795, g:11
i:35 =&gt; a:3855169043, b:933955932, c:3280661187, d:1648727666, f:1141263010, g:14
i:36 =&gt; a:1648727666, b:1316709518, c:933955932, d:3280661187, f:2523166189, g:1
i:37 =&gt; a:3280661187, b:1172621265, c:1316709518, d:933955932, f:3126494993, g:4
i:38 =&gt; a:933955932, b:638303819, c:1172621265, d:1316709518, f:1010084355, g:7
i:39 =&gt; a:1316709518, b:2518531516, c:638303819, d:1172621265, f:764681492, g:10
i:40 =&gt; a:1172621265, b:1723348322, c:2518531516, d:638303819, f:4126327846, g:13
i:41 =&gt; a:638303819, b:1796634879, c:1723348322, d:2518531516, f:3601741461, g:0
i:42 =&gt; a:2518531516, b:1242042285, c:1796634879, d:1723348322, f:2612260897, g:3
i:43 =&gt; a:1723348322, b:3271112123, c:1242042285, d:1796634879, f:1202078256, g:6
i:44 =&gt; a:1796634879, b:171818493, c:3271112123, d:1242042285, f:3823583977, g:9
i:45 =&gt; a:1242042285, b:4279516322, c:171818493, d:3271112123, f:2194442219, g:12
i:46 =&gt; a:3271112123, b:1084087837, c:4279516322, d:171818493, f:936424676, g:15
i:47 =&gt; a:171818493, b:4055665426, c:1084087837, d:4279516322, f:3048496962, g:2
i:48 =&gt; a:4279516322, b:4279453145, c:4055665426, d:1084087837, f:2975995202, g:0
i:49 =&gt; a:1084087837, b:1002426141, c:4279453145, d:4055665426, f:248508137, g:7
i:50 =&gt; a:4055665426, b:2580293036, c:1002426141, d:4279453145, f:3236739620, g:14
i:51 =&gt; a:4279453145, b:429799967, c:2580293036, d:1002426141, f:2723377331, g:5
i:52 =&gt; a:1002426141, b:969799177, c:429799967, d:2580293036, f:1142038355, g:12
i:53 =&gt; a:2580293036, b:4081959629, c:969799177, d:429799967, f:1717683268, g:3
i:54 =&gt; a:429799967, b:424965883, c:4081959629, d:969799177, f:3466605028, g:10
i:55 =&gt; a:969799177, b:2878206675, c:424965883, d:4081959629, f:742112562, g:1
i:56 =&gt; a:4081959629, b:3289205483, c:2878206675, d:424965883, f:3068889352, g:8
i:57 =&gt; a:424965883, b:932769765, c:3289205483, d:2878206675, f:1294088508, g:15
i:58 =&gt; a:2878206675, b:3877873675, c:932769765, d:3289205483, f:3019351302, g:6
i:59 =&gt; a:3289205483, b:3573278773, c:3877873675, d:932769765, f:3362476794, g:13
i:60 =&gt; a:932769765, b:2755809458, c:3573278773, d:3877873675, f:1004294196, g:4
i:61 =&gt; a:3877873675, b:2328479269, c:2755809458, d:3573278773, f:1747304387, g:11
i:62 =&gt; a:3573278773, b:198924010, c:2328479269, d:2755809458, f:261064541, g:2
i:63 =&gt; a:2755809458, b:3186462216, c:198924010, d:2328479269, f:3509991882, g:9


By the way, AKM in the document is akw in the code.

Any tips or suggestions on bringing me in the right direction would be very appreciated. Code would be ideal. If something is unclear, I'll edit the question and try to rectify that.","the problem is, that you have a pipeline of two in your ""b-path"" (--> 1st stage is b_tmp, 2nd stage is b) while the allocation pipeline has one stage (e.g. a&lt;=d) only. I did some changes to the code and marked them with ""--***"". with this code, you get the first results right...

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity md5core is
    port (
        CLOCK_50        : in std_logic;
        SW              : in std_logic_vector(17 downto 17)
    );
end entity md5core;

architecture md5core_rtl of md5core is
type r_array is array(0 to 64) of std_logic_vector(7 downto 0);
constant R        : r_array := ( x""07"", x""0c"", x""11"", x""16"", x""07"", x""0c"", x""11"", x""16"", x""07"", x""0c"", x""11"", x""16"", x""07"", x""0c"", x""11"", 
                                 x""16"", x""05"", x""09"", x""0e"", x""14"", x""05"", x""09"", x""0e"", x""14"", x""05"", x""09"", x""0e"", x""14"", x""05"", x""09"",
                                 x""0e"", x""14"", x""04"", x""0b"", x""10"", x""17"", x""04"", x""0b"", x""10"", x""17"", x""04"", x""0b"", x""10"", x""17"", x""04"",
                                 x""0b"", x""10"", x""17"", x""06"", x""0a"", x""0f"", x""15"", x""06"", x""0a"", x""0f"", x""15"", x""06"", x""0a"", x""0f"", x""15"",
                                 x""06"", x""0a"", x""0f"", x""15"", others =&gt; x""00"");

type k_array is array(0 to 66) of std_logic_vector(31 downto 0);
constant K        : k_array := (x""d76aa478"", x""e8c7b756"", x""242070db"", x""c1bdceee"",
                                x""f57c0faf"", x""4787c62a"", x""a8304613"", x""fd469501"",
                                x""698098d8"", x""8b44f7af"", x""ffff5bb1"", x""895cd7be"",
                                x""6b901122"", x""fd987193"", x""a679438e"", x""49b40821"", 
                                x""f61e2562"", x""c040b340"", x""265e5a51"", x""e9b6c7aa"",
                                x""d62f105d"", x""02441453"", x""d8a1e681"", x""e7d3fbc8"",
                                x""21e1cde6"", x""c33707d6"", x""f4d50d87"", x""455a14ed"",
                                x""a9e3e905"", x""fcefa3f8"", x""676f02d9"", x""8d2a4c8a"",
                                x""fffa3942"", x""8771f681"", x""6d9d6122"", x""fde5380c"",
                                x""a4beea44"", x""4bdecfa9"", x""f6bb4b60"", x""bebfbc70"",
                                x""289b7ec6"", x""eaa127fa"", x""d4ef3085"", x""04881d05"",
                                x""d9d4d039"", x""e6db99e5"", x""1fa27cf8"", x""c4ac5665"",
                                x""f4292244"", x""432aff97"", x""ab9423a7"", x""fc93a039"",
                                x""655b59c3"", x""8f0ccc92"", x""ffeff47d"", x""85845dd1"",
                                x""6fa87e4f"", x""fe2ce6e0"", x""a3014314"", x""4e0811a1"",
                                x""f7537e82"", x""bd3af235"", x""2ad7d2bb"", x""eb86d391"", others =&gt; x""00000000"");

type g_array is array(0 to 64) of integer range 0 to 15;
constant g_arr      : g_array := (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                                          1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12,
                                          5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2,
                                          0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9, 0);                                               

type w_array is array(0 to 15) of std_logic_vector(31 downto 0);
signal W            : w_array;

constant AA        : std_logic_vector(31 downto 0) := x""67452301"";
constant BB        : std_logic_vector(31 downto 0) := x""EFCDAB89"";
constant CC        : std_logic_vector(31 downto 0) := x""98BADCFE"";
constant DD        : std_logic_vector(31 downto 0) := x""10325476"";

signal res_A    : std_logic_vector(31 downto 0) := x""00000000"";
signal res_B    : std_logic_vector(31 downto 0) := x""00000000"";
signal res_C    : std_logic_vector(31 downto 0) := x""00000000"";
signal res_D    : std_logic_vector(31 downto 0) := x""00000000"";

type in_str_t is array(0 to 5) of std_logic_vector(7 downto 0);
constant in_str    : in_str_t := (x""68"", x""65"", x""6c"", x""6c"", x""6f"", x""6f"");

type pad_str_t    is array(0 to 63) of std_logic_vector(7 downto 0);
signal pad_str    : pad_str_t;

type state_t is (start, padding, init_w, state_1, state_2, state_3, state_4, done);
signal state    : state_t;

signal a, b, c, d, f    : std_logic_vector(31 downto 0) := x""00000000"";
signal i                : integer range 0 to 64 := 0;
signal g                        : integer range 0 to 15 := 0;
--signal tmp_b              : std_logic_vector(31 downto 0);

signal akw                  : std_logic_vector(31 downto 0);
signal ak                   : std_logic_vector(31 downto 0);
signal b_tmp                : std_logic_vector(31 downto 0);

begin

    --tmp_b &lt;= std_logic_vector(unsigned(b) + rotate_left(unsigned(a) + unsigned(f) + unsigned(K(i)) + unsigned(W(g)), to_integer(unsigned(R(i)))));

    pipe_p : process(CLOCK_50, SW)--*** removed: , a, b, c, d, i)
    begin
        if SW(17) = '0' then
--          ak &lt;= std_logic_vector(unsigned(K(2)) + unsigned(BB));
--          akw &lt;= std_logic_vector(unsigned(W(0)) + 1 + unsigned(K(2)) + unsigned(BB));
            b &lt;= BB;--*** changed, was: b_tmp
        elsif rising_edge(CLOCK_50) and state = state_1 then
            if i = 0 then
                ak &lt;= std_logic_vector(unsigned(K(0)) + unsigned(a));
            elsif i = 1 then
                ak &lt;= std_logic_vector(unsigned(K(1)) + unsigned(d));--*** changed, was: unsigned(a));
                akw &lt;= std_logic_vector(unsigned(W(0)) + unsigned(ak));
            elsif i = 2 then
                ak &lt;= std_logic_vector(unsigned(K(2)) + unsigned(c));--*** changed, was: unsigned(a));
                akw &lt;= std_logic_vector(unsigned(W(1)) + unsigned(ak));
                b &lt;= std_logic_vector(unsigned(b) + (rotate_left(unsigned(akw) + unsigned(f), to_integer(unsigned(R(0))))));--*** changed, was: b_tmp
            else
                ak &lt;= std_logic_vector(unsigned(K(i)) + unsigned(c));--*** changed, was:  unsigned(a));
                akw &lt;= std_logic_vector(unsigned(W(g_arr(i-1))) + unsigned(ak));
                b &lt;= std_logic_vector(unsigned(b) + (rotate_left(unsigned(akw) + unsigned(f), to_integer(unsigned(R(i-2))))));--*** changed, was: b_tmp
            end if;
        end if;
    end process pipe_p;


    md5_f_p : process(state, a, b, c, d, i)
    begin 
        case state is
            when state_1 =&gt;
                -- if i = 0 or i &gt; 4 then----*** removed
                    f &lt;= (b and c) or ((not b) and d);
                    g &lt;= g_arr(i);
                -- end if;----*** removed

            when state_2 =&gt;
            f &lt;= (d and b) or ((not d) and c);
                g &lt;= g_arr(i);

            when state_3 =&gt;
                f &lt;= b xor c xor d;
            g &lt;= g_arr(i);

            when state_4 =&gt;
                f &lt;= c xor (b or (not d));
            g &lt;= g_arr(i);

            when others =&gt;
                f &lt;= x""00000000"";
                g &lt;= 0;             

        end case;
    end process md5_f_p;

     md5_p : process(CLOCK_50, SW)----*** removed: , a, b, c, d, f, g)
     begin
        if SW(17) = '0' then
            state &lt;= start;
                i &lt;= 0;
                a &lt;= AA;
            -- b &lt;= BB; ----*** removed
            c &lt;= CC;
            d &lt;= DD;                
            W &lt;= (others =&gt; x""00000000"");
                pad_str &lt;= (others =&gt; x""00"");
                --tmp_b := BB;
        elsif rising_edge(CLOCK_50) then
            case state is            
                when start =&gt;

                    pad_str(0) &lt;= in_str(0);
                    pad_str(1) &lt;= in_str(1);
                    pad_str(2) &lt;= in_str(2);
                    pad_str(3) &lt;= in_str(3);
                    pad_str(4) &lt;= in_str(4);
                    pad_str(5) &lt;= in_str(5);
                    state &lt;= padding;

                when padding =&gt;
                    pad_str(6) &lt;= ""10000000"";
                    pad_str(56) &lt;= std_logic_vector(to_unsigned(in_str'length*8, 8));
                          state &lt;= init_w;

                when init_w =&gt;                
                    W(0) &lt;= pad_str(3) &amp; pad_str(2) &amp; pad_str(1) &amp; pad_str(0);
                    W(1) &lt;= pad_str(7) &amp; pad_str(6) &amp; pad_str(5) &amp; pad_str(4);
                    W(14) &lt;= pad_str(59) &amp; pad_str(58) &amp; pad_str(57) &amp; pad_str(56);
                          state &lt;= state_1;

                when state_1 =&gt;
                          if i = 16 then
                              state &lt;= state_2;
                          else 
                        if i &gt; 1 then----*** changed, was: --if i &gt; 2 then
                                    --tmp_b := b;
                                    a &lt;= d;
                                    c &lt;= b;
                                    d &lt;= c;
                                    -- b &lt;= b_tmp; --*** removed

--                                  d &lt;= c;
--                                  b &lt;= b_tmp;
--                                  c &lt;= b;
--                                  a &lt;= d;
                                end if;
                                i &lt;= i + 1;
                    end if;

                when state_2 =&gt;
                    if i = 32 then
                        state &lt;= state_3;
                          else                  
                        d &lt;= c;
                        -- b &lt;= b_tmp;--*** removed
                                c &lt;= b;
                        a &lt;= d;
                        i &lt;= i + 1;
                    end if;

                when state_3 =&gt;
                    if i = 48 then
                                state &lt;= state_4;
                          else
                        d &lt;= c;
                        -- b &lt;= b_tmp;----*** removed
                                c &lt;= b;
                        a &lt;= d;
                        i &lt;= i + 1;
                    end if;

                when state_4 =&gt;
                    if i = 64 then
                                res_A &lt;= std_logic_vector(unsigned(AA) + unsigned(a));
                                res_B &lt;= std_logic_vector(unsigned(BB) + unsigned(b));
                                res_C &lt;= std_logic_vector(unsigned(CC) + unsigned(c));
                                res_D &lt;= std_logic_vector(unsigned(DD) + unsigned(d));
                                state &lt;= done;
                    else
                        d &lt;= c;
                        c &lt;= b;
                                -- b &lt;= b_tmp;----*** removed
                        a &lt;= d;
                        i &lt;= i + 1;
                    end if;

                when done =&gt;
                    state &lt;= done;

                when others =&gt;
                    state &lt;= done;

            end case;
        end if;
    end process md5_p;
end architecture md5core_rtl;




library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity md5core is
    port (
        CLOCK_50        : in std_logic;
        SW              : in std_logic_vector(17 downto 17)
    );
end entity md5core;

architecture md5core_rtl of md5core is
type r_array is array(0 to 64) of std_logic_vector(7 downto 0);
constant R        : r_array := ( x""07"", x""0c"", x""11"", x""16"", x""07"", x""0c"", x""11"", x""16"", x""07"", x""0c"", x""11"", x""16"", x""07"", x""0c"", x""11"", 
                                 x""16"", x""05"", x""09"", x""0e"", x""14"", x""05"", x""09"", x""0e"", x""14"", x""05"", x""09"", x""0e"", x""14"", x""05"", x""09"",
                                 x""0e"", x""14"", x""04"", x""0b"", x""10"", x""17"", x""04"", x""0b"", x""10"", x""17"", x""04"", x""0b"", x""10"", x""17"", x""04"",
                                 x""0b"", x""10"", x""17"", x""06"", x""0a"", x""0f"", x""15"", x""06"", x""0a"", x""0f"", x""15"", x""06"", x""0a"", x""0f"", x""15"",
                                 x""06"", x""0a"", x""0f"", x""15"", others =&gt; x""00"");

type k_array is array(0 to 66) of std_logic_vector(31 downto 0);
constant K        : k_array := (x""d76aa478"", x""e8c7b756"", x""242070db"", x""c1bdceee"",
                                x""f57c0faf"", x""4787c62a"", x""a8304613"", x""fd469501"",
                                x""698098d8"", x""8b44f7af"", x""ffff5bb1"", x""895cd7be"",
                                x""6b901122"", x""fd987193"", x""a679438e"", x""49b40821"", 
                                x""f61e2562"", x""c040b340"", x""265e5a51"", x""e9b6c7aa"",
                                x""d62f105d"", x""02441453"", x""d8a1e681"", x""e7d3fbc8"",
                                x""21e1cde6"", x""c33707d6"", x""f4d50d87"", x""455a14ed"",
                                x""a9e3e905"", x""fcefa3f8"", x""676f02d9"", x""8d2a4c8a"",
                                x""fffa3942"", x""8771f681"", x""6d9d6122"", x""fde5380c"",
                                x""a4beea44"", x""4bdecfa9"", x""f6bb4b60"", x""bebfbc70"",
                                x""289b7ec6"", x""eaa127fa"", x""d4ef3085"", x""04881d05"",
                                x""d9d4d039"", x""e6db99e5"", x""1fa27cf8"", x""c4ac5665"",
                                x""f4292244"", x""432aff97"", x""ab9423a7"", x""fc93a039"",
                                x""655b59c3"", x""8f0ccc92"", x""ffeff47d"", x""85845dd1"",
                                x""6fa87e4f"", x""fe2ce6e0"", x""a3014314"", x""4e0811a1"",
                                x""f7537e82"", x""bd3af235"", x""2ad7d2bb"", x""eb86d391"", others =&gt; x""00000000"");

type g_array is array(0 to 64) of integer range 0 to 15;
constant g_arr      : g_array := (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                                          1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12,
                                          5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2,
                                          0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9, 0);                                               

type w_array is array(0 to 15) of std_logic_vector(31 downto 0);
signal W            : w_array;

constant AA        : std_logic_vector(31 downto 0) := x""67452301"";
constant BB        : std_logic_vector(31 downto 0) := x""EFCDAB89"";
constant CC        : std_logic_vector(31 downto 0) := x""98BADCFE"";
constant DD        : std_logic_vector(31 downto 0) := x""10325476"";

signal res_A    : std_logic_vector(31 downto 0) := x""00000000"";
signal res_B    : std_logic_vector(31 downto 0) := x""00000000"";
signal res_C    : std_logic_vector(31 downto 0) := x""00000000"";
signal res_D    : std_logic_vector(31 downto 0) := x""00000000"";

type in_str_t is array(0 to 5) of std_logic_vector(7 downto 0);
constant in_str    : in_str_t := (x""68"", x""65"", x""6c"", x""6c"", x""6f"", x""6f"");

type pad_str_t    is array(0 to 63) of std_logic_vector(7 downto 0);
signal pad_str    : pad_str_t;

type state_t is (start, padding, init_w, state_1, state_2, state_3, state_4, done);
signal state    : state_t;

signal a, b, c, d, f    : std_logic_vector(31 downto 0) := x""00000000"";
signal i                : integer range 0 to 65 := 0;--**** changed, was: to 64
signal g                        : integer range 0 to 15 := 0;
--signal tmp_b              : std_logic_vector(31 downto 0);

signal akw                  : std_logic_vector(31 downto 0);
signal ak                   : std_logic_vector(31 downto 0);
signal b_tmp                : std_logic_vector(31 downto 0);

begin

    --tmp_b &lt;= std_logic_vector(unsigned(b) + rotate_left(unsigned(a) + unsigned(f) + unsigned(K(i)) + unsigned(W(g)), to_integer(unsigned(R(i)))));

    pipe_p : process(CLOCK_50, SW)--*** removed: , a, b, c, d, i)
    begin
        if SW(17) = '0' then
--          ak &lt;= std_logic_vector(unsigned(K(2)) + unsigned(BB));
--          akw &lt;= std_logic_vector(unsigned(W(0)) + 1 + unsigned(K(2)) + unsigned(BB));
            b &lt;= BB;--*** changed, was: b_tmp
        elsif rising_edge(CLOCK_50) then --**** removed: and state = state_1 then
                --**** added start
                if state = done then
                    b&lt;=b;
                    ak&lt;=ak;
                    akw&lt;=akw;
                --**** added stop
            elsif i = 0 then
                ak &lt;= std_logic_vector(unsigned(K(0)) + unsigned(a));
            elsif i = 1 then
                ak &lt;= std_logic_vector(unsigned(K(1)) + unsigned(d));--*** changed, was: unsigned(a));
                akw &lt;= std_logic_vector(unsigned(W(0)) + unsigned(ak));
            elsif i = 2 then
                ak &lt;= std_logic_vector(unsigned(K(2)) + unsigned(c));--*** changed, was: unsigned(a));
                akw &lt;= std_logic_vector(unsigned(W(1)) + unsigned(ak));
                b &lt;= std_logic_vector(unsigned(b) + (rotate_left(unsigned(akw) + unsigned(f), to_integer(unsigned(R(0))))));--*** changed, was: b_tmp
            else
                ak &lt;= std_logic_vector(unsigned(K(i)) + unsigned(c));--*** changed, was:  unsigned(a));
                akw &lt;= std_logic_vector(unsigned(W(g_arr(i-1))) + unsigned(ak));
                b &lt;= std_logic_vector(unsigned(b) + (rotate_left(unsigned(akw) + unsigned(f), to_integer(unsigned(R(i-2))))));--*** changed, was: b_tmp
            end if;
        end if;
    end process pipe_p;


    md5_f_p : process(state, a, b, c, d, i)
    begin 
        case state is
            when state_1 =&gt;
                -- if i = 0 or i &gt; 4 then----*** removed
                    f &lt;= (b and c) or ((not b) and d);
--                    g &lt;= g_arr(i);--**** removed
                -- end if;----*** removed

            when state_2 =&gt;
            f &lt;= (d and b) or ((not d) and c);
--                g &lt;= g_arr(i);--**** removed

            when state_3 =&gt;
                f &lt;= b xor c xor d;
--            g &lt;= g_arr(i);--**** removed

            when state_4 =&gt;
                f &lt;= c xor (b or (not d));
--            g &lt;= g_arr(i);--**** removed

            when others =&gt;
                f &lt;= x""00000000"";
--                g &lt;= 0;       --**** removed      

        end case;
    end process md5_f_p;

     md5_p : process(CLOCK_50, SW)----*** removed: , a, b, c, d, f, g)
     begin
        if SW(17) = '0' then
            state &lt;= start;
                i &lt;= 0;
                a &lt;= AA;
            -- b &lt;= BB; ----*** removed
            c &lt;= CC;
            d &lt;= DD;                
            W &lt;= (others =&gt; x""00000000"");
                pad_str &lt;= (others =&gt; x""00"");
                --tmp_b := BB;
        elsif rising_edge(CLOCK_50) then
            case state is            
                when start =&gt;

                    pad_str(0) &lt;= in_str(0);
                    pad_str(1) &lt;= in_str(1);
                    pad_str(2) &lt;= in_str(2);
                    pad_str(3) &lt;= in_str(3);
                    pad_str(4) &lt;= in_str(4);
                    pad_str(5) &lt;= in_str(5);
                    state &lt;= padding;

                when padding =&gt;
                    pad_str(6) &lt;= ""10000000"";
                    pad_str(56) &lt;= std_logic_vector(to_unsigned(in_str'length*8, 8));
                          state &lt;= init_w;

                when init_w =&gt;                
                    W(0) &lt;= pad_str(3) &amp; pad_str(2) &amp; pad_str(1) &amp; pad_str(0);
                    W(1) &lt;= pad_str(7) &amp; pad_str(6) &amp; pad_str(5) &amp; pad_str(4);
                    W(14) &lt;= pad_str(59) &amp; pad_str(58) &amp; pad_str(57) &amp; pad_str(56);
                          state &lt;= state_1;

                when state_1 =&gt;
                          if i = 17 then--**** changed, was: 16
                              state &lt;= state_2;
                                    end if; --****added
--                          else --**** removed
                        if i &gt; 1 then----*** changed, was: --if i &gt; 2 then
                                    --tmp_b := b;
                                    a &lt;= d;
                                    c &lt;= b;
                                    d &lt;= c;
                                    -- b &lt;= b_tmp; --*** removed

--                                  d &lt;= c;
--                                  b &lt;= b_tmp;
--                                  c &lt;= b;
--                                  a &lt;= d;
                                end if;
                                i &lt;= i + 1;
--                    end if;--**** removed

                when state_2 =&gt;
                    if i = 33 then--**** changed, was: 32
                        state &lt;= state_3;
                            end if; --****added
--                    else --**** removed                 
                        d &lt;= c;
                        -- b &lt;= b_tmp;--*** removed
                        c &lt;= b;
                        a &lt;= d;
                        i &lt;= i + 1;
--                    end if;--**** removed  

                when state_3 =&gt;
                    if i = 49 then--**** changed, was: 48
                                state &lt;= state_4;
                            end if; --****added
--                          else--**** removed  
                        d &lt;= c;
                        -- b &lt;= b_tmp;----*** removed
                        c &lt;= b;
                        a &lt;= d;
                        i &lt;= i + 1;
--                    end if;--**** removed  

                when state_4 =&gt;
                    if i = 65 then--**** changed, was: 64
--                                res_A &lt;= std_logic_vector(unsigned(AA) + unsigned(a));--**** removed  
--                                res_B &lt;= std_logic_vector(unsigned(BB) + unsigned(b));--**** removed  
--                                res_C &lt;= std_logic_vector(unsigned(CC) + unsigned(c));--**** removed  
--                                res_D &lt;= std_logic_vector(unsigned(DD) + unsigned(d));--**** removed  
                                  state &lt;= done;
                            end if; --****added
--                    else--**** removed  
                        d &lt;= c;
                        c &lt;= b;
                        -- b &lt;= b_tmp;----*** removed
                        a &lt;= d;
                        i &lt;= i + 1;
--                    end if;--**** removed  

                when done =&gt;
                          res_A &lt;= std_logic_vector(unsigned(AA) + unsigned(a));--****added
                          res_B &lt;= std_logic_vector(unsigned(BB) + unsigned(b));--****added
                          res_C &lt;= std_logic_vector(unsigned(CC) + unsigned(c));--****added
                          res_D &lt;= std_logic_vector(unsigned(DD) + unsigned(d));    --****added              
                    state &lt;= done;

                when others =&gt;
                    state &lt;= done;

            end case;
        end if;
    end process md5_p;
end architecture md5core_rtl;
",,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 was: b_tmp,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 was: unsigned(a));,,,,,,,
,,,,,,,
,,,,,,,
 was: unsigned(a));,,,,,,,
,,,,,,,
 to_integer(unsigned(R(0))))));--*** changed, was: b_tmp,,,,,,
,,,,,,,
 was:  unsigned(a));,,,,,,,
,,,,,,,
 to_integer(unsigned(R(i-2))))));--*** changed, was: b_tmp,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 a, b, c,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 SW)----*** removed: , a, b,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 8));,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 was: 16,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 was: --if i &gt; 2 then,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 was: 32,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 was: 48,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 was: 64,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 b,,,,,,,
,,,,,,,
,,,,,,,
c_o[0],.a(a[3:0]), .b(b[3:0),,,,,
c_o[1],a[4],b[4],,,,,
c_out,a[5],b[5],,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
       // carry out,,,,,,,
 b,    // operands,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
c_o[0],a[0],b[0],,,,,
c_o[1],a[1],b[1],,,,,
c_o[2],a[2],b[2],,,,,
c_out,a[3],b[3],,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
   // carry out,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
c_in1,a,b);,,,,,
c_out2,sum1,c_in);,,,,,
c_out2,c_in1);,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
   // carry out,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 and it works. But I cannot find the mistake. I am not sure if I made the correct connections in the adder4 function that I have used in adder6 module.,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 ,,,,,,,
 ,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 and I've eliminated the carry in. But now, it doesn't calculate the sum. For a=63 and b=63 the sum is X. This is the new adder6 module:,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 ,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
c_out0,a[3:0],b[3:0],,,,,
c_out1,a[4],b[4],,,,,
sum[6],a[5],b[5],,,,,
,,,,,,,
,,,,,,,
,,,,,,,
c_o[0],.a(a[3:0]), .b(b[3:0),,,,,
,,,,,,,
,,,,,,,
 you've called an instance of adder4 a. At the same time, you've called an input port a. That's why you're getting an error when trying to compile your code. The easiest solution would be to rename an adder4 instance.,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 .c_out(c_o[0]), .a(a[3:0]), .b(b[3:0]),,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 b,,,,,,,
,,,,,,,
,,,,,,,
c_o[0],.a(a[3:0]), .b(b[3:0),,,,,
c_o[1],a[4],b[4],,,,,
c_out,a[5],b[5],,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
       // carry out,,,,,,,
 b,    // operands,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
c_o[0],a[0],b[0],,,,,
c_o[1],a[1],b[1],,,,,
c_o[2],a[2],b[2],,,,,
c_out,a[3],b[3],,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
   // carry out,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
c_in1,a,b);,,,,,
c_out2,sum1,c_in);,,,,,
c_out2,c_in1);,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
   // carry out,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 and it works. But I cannot find the mistake. I am not sure if I made the correct connections in the adder4 function that I have used in adder6 module.,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 ,,,,,,,
 ,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 and I've eliminated the carry in. But now, it doesn't calculate the sum. For a=63 and b=63 the sum is X. This is the new adder6 module:,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 ,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
c_out0,a[3:0],b[3:0],,,,,
c_out1,a[4],b[4],,,,,
sum[6],a[5],b[5],,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
c_o[0],.a(a[3:0]), .b(b[3:0),,,,,
,,,,,,,
,,,,,,,
 you've called an instance of adder4 a. At the same time, you've called an input port a. That's why you're getting an error when trying to compile your code. The easiest solution would be to rename an adder4 instance.,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 .c_out(c_o[0]), .a(a[3:0]), .b(b[3:0]),,,,,
" bad or irrelevant?""","The general rule of thumb mentioned in all of books I have read so far is that you have to use non-blocking assignments in always blocks that are driven by the raising or falling edge of the clock. On a contrary, blocking assignments must be used for combinatorial logic description. This rule makes sense to me and authors of examples follow it thoroughly.

However, I spotted the following piece of Verilog in one of the production code:

always @* begin
   in_ready &lt;= out_ready || ~out_valid;
end


Note that non-blocking assignment &lt;= is being used. I don't think it makes any difference in this case because there are no multiple assignments. However, I cannot seem to find any explanation for this. So the question is - does it or does not make any difference, both in the scope of a given always block and as part of the larger design?","Irrelevant but bad practise.

I doubt that the single assignment causes any side effects. The always block will trigger for any change on the right hand side, updating in_ready. There is nothing to block, so non-blocking will not cause issues.

If a larger design had :

always @* begin 
  in_ready    &lt;= out_ready || ~out_valid  ;
  other_ready &lt;= in_ready  || other_ready ;
end


I am not too sure, as it is combinatorial it might just take an extra delta step to resolve.",,,,,
What's the best way to tell if a bus contains a single x in Verilog?,"I have a test bench that monitors a bus.  Some of the signals (bits) within the bus can be 1'bx.  For a variety of reasons, I need to know if any of the signals within the bus are 1'bx.  What's the best way to test (not for synthesis -- only for simulation purposes) if a bus contains any x's?  I had hoped that I could use a reduction OR and then use ===, but this doesn't seem to work.","(^bus === 1'bX) 

Bit-wise xor the bus then check if the result is X. If any bit is X or Z then the result will be X.

To know which bit in the bus has the error:

always @* begin
  for(integer i=0; i&lt;$size(bus); i++) begin
     if(bus[i]===1'bX) $display(""bus[%0d] is X"",bus[i]);
     if(bus[i]===1'bZ) $display(""bus[%0d] is Z"",bus[i]);
  end
end
",,,,,
How to convert 8 bits to 16 bits in VHDL?,I have an input signal from ADC convertor that is 8 bits (std_logic_vector(7 downto 0)). I have to convert them to a 16 bits signal (std_logic_vector(15 downto 0)) for 16 bits signal processing to the 16 bits system. ,"If the 8 bit value is interpreted as signed (2's complement), then the general and standard VHDL conversion method is to use the IEEE numeric_std library:

library ieee;
use ieee.numeric_std.all;

architecture sim of tb is
    signal slv_8  : std_logic_vector( 8 - 1 downto 0);
    signal slv_16 : std_logic_vector(16 - 1 downto 0);
begin
    slv_16 &lt;= std_logic_vector(resize(signed(slv_8), slv_16'length));
end architecture;


So first the std_logic_vector is converted to a signed value, then the resize is applied, which will sign extend the signed value, and the result is finally converted back to std_logic_vector.

The conversion is rather lengthy, but has the advantage that it is general and works even if the target length is changed later on.

The attribute 'length simply returns the length of the slv_16 std_logic_vector, thus 16.

For unsigned representation instead of signed, it can be done using unsigned instead of signed, thus with this code:

    slv_16 &lt;= std_logic_vector(resize(unsigned(slv_8), slv_16'length));
",,,,,
Can Verilog variables be given local scope to an always block?,"I sometimes find it useful to use blocking assignments for ""local variables"" inside clocked always blocks. This can help cut down on repeated code. 

To avoid accidentally using the same variable in a different always block (which can be non-deterministic for simulation), I'd like to give it local scope. Is there a nice synthesizable way of doing this?

Something like:

module sum3(
  input            clk,
  input      [7:0] in1,
  input      [7:0] in2,
  input      [7:0] in3,
  output reg [7:0] result,
  output reg [7:0] result_p1);

  begin :sum
    reg [7:0] sum_temp; // local variable
    always @(posedge clk) begin
      sum_temp   = in1 + in2 + in3;
      result    &lt;= sum_temp;
      result_p1 &lt;= sum_temp + 1;
    end
  end

endmodule


(ModelSim seems to be okay with this, but Synplify doesn't seem to like it.)","I'm not sure of the semantics in plain Verilog, but according to the SystemVerilog LRM section 6.21:


  Variable declarations shall precede any statements within a procedural block.


Therefore the following is legal syntax in SystemVerilog:

module sum3(
  input            clk,
  input      [7:0] in1,
  input      [7:0] in2,
  input      [7:0] in3,
  output reg [7:0] result,
  output reg [7:0] result_p1);

  always @(posedge clk) begin : sum
    reg [7:0] sum_temp; // local variable (scope limited to process)
    sum_temp   = in1 + in2 + in3;
    result    &lt;= sum_temp;
    result_p1 &lt;= sum_temp + 1;
  end

endmodule


Note that I have moved the variable declaration sum_temp into the process, thereby limiting the scope and removing the need for the named sum block.  This compiles on Modelsim and Riviera (example on EDA Playground).

If your tool doesn't support this syntax, raise a bug!",,,,,
Difference between mod and rem operators in VHDL?,"I came across these statements in VHDL programming and could not understand the difference between the two operators mod and rem

    9 mod 5
    (-9) mod 5
    9 mod (-5)
    9 rem 5
    (-9) rem 5
    9 rem (-5)
","A way to see the different is to run a quick simulation in a test bench, for
example using a process like this:

process is
begin
  report ""  9  mod   5  = "" &amp; integer'image(9 mod 5);
  report ""  9  rem   5  = "" &amp; integer'image(9 rem 5);
  report ""  9  mod (-5) = "" &amp; integer'image(9 mod (-5));
  report ""  9  rem (-5) = "" &amp; integer'image(9 rem (-5));
  report ""(-9) mod   5  = "" &amp; integer'image((-9) mod 5);
  report ""(-9) rem   5  = "" &amp; integer'image((-9) rem 5);
  report ""(-9) mod (-5) = "" &amp; integer'image((-9) mod (-5));
  report ""(-9) rem (-5) = "" &amp; integer'image((-9) rem (-5));
  wait;
end process;


It shows the result to be:

# ** Note:   9  mod   5  =  4
# ** Note:   9  rem   5  =  4
# ** Note:   9  mod (-5) = -1
# ** Note:   9  rem (-5) =  4
# ** Note: (-9) mod   5  =  1
# ** Note: (-9) rem   5  = -4
# ** Note: (-9) mod (-5) = -4
# ** Note: (-9) rem (-5) = -4


Wikipedia - Modulo operation
has an elaborate description, including the rules:


mod has sign of divisor, thus n in a mod n
rem has sign of dividend, thus a in a rem n


The mod operator gives the residue for a division that rounds down (floored division), so a = floor_div(a, n) * n + (a mod n).  The advantage is that a mod n is a repeated sawtooth graph when a is increasing even through zero, which is important in some calculations.

The rem operator gives the remainder for the regular integer division a / n that rounds towards 0 (truncated division), so a = (a / n) * n + (a rem n).",,,,,
"What does ""others=>'0'"" mean in an assignment statement?","cmd_register: process (rst_n, clk)
begin
   if (rst_n='0') then
    cmd_r&lt;= (others=&gt;'0');
   elsif (clk'event and clk='1') then
    cmd_r&lt;=...;
   end if;
end process cmd_register;


I know ""&lt;="" specifies assignment but what is others? And what does =&gt; do?","cmd_r is defined as a std_logic_vector, or unsigned or signed signal. let's see how this signal type are defined:

type std_logic_vector is array (natural range &lt;&gt;) of std_logic; 
type unsigned         is array (natural range &lt;&gt;) of std_logic; 
type signed           is array (natural range &lt;&gt;) of std_logic;


Note that these 3 types have the same definition as an array of std_logic items.

The statement ""Others => '0'"" is a feature of the VHDL when the coder want to defined several items in an array with the same value.

In your example, all item std_logic in the array are set to '0'.

Another application of this statement is to set some items at a specific value and all others at a default value : 

cmd_r &lt;= (0      =&gt; '1',
          4      =&gt; '1',
          others =&gt; '0');


In this case, the bit 0 and 4 are set to '1' and all other bits are set to '0'.

One last thing, it's NOT possible to write something like this :

  cmd_r &lt;= (0          =&gt; '1',
            4 downto 2 =&gt; ""111"", -- this line is wrong !!!
            others     =&gt; '0');
",,,,,
"Altera Quartus Error (12007): Top-level design entity ""alt_ex_1"" is undefined","I've looked at all the previous questions and no one seems to have a problem
as simple as mine. Also I've searched the web and can't find a solution.
I'm new to VHDL and am trying to compile the simple example provided
by Altera, which is as follows:
library ieee;
use ieee.std_logic_1164.all;

entity light is
port(x1, x2: in std_logic;
          f: out std_logic);
end light;

architecture LogicFunction of light is
begin
    f &lt;= (x1 and not x2) or (not x1  and x2);
end LogicFunction;

I followed the project creation steps in the Altera tutorial,
but when I try to compile the project I get the error:
Error (12007): Top-level design entity &quot;alt_ex_1&quot; is undefined
","In chapter Starting a New Project, you were asked to call your project light. It seems to me that you didn't follow that step correctly and name your project alt_ex_1. That's why you're getting 12007 error, since the compiler has no idea what is the top-level entity in you design. 

To solve that problem you can:


Change the top-level entity assignment in Assignments -&gt; Device -&gt; General.
Set your module as top-entity via Project Navigator (Files -&gt; Set as top-level entity).


Btw 1, 2, 3, ... - all about the same problem.",,,,,
What is the practical difference between implementing FOR-LOOP and FOR-GENERATE? When is it better to use one over the other?,"Let's suppose I have to test different bits on an std_logic_vector. would it be better to implement one single process, that for-loops for each bit or to instantiate 'n' processes using for-generate on which each process tests one bit?

FOR-LOOP

my_process: process(clk, reset) begin
  if rising_edge (clk) then
    if reset = '1' then
      --init stuff
    else
      for_loop: for i in 0 to n loop
        test_array_bit(i);
      end loop;
    end if;      
  end if; 
end process;


FOR-GENERATE

for_generate: for i in 0 to n generate begin
my_process: process(clk, reset) begin
  if rising_edge (clk) then
    if reset = '1' then
      --init stuff
    else
      test_array_bit(i);
    end if;
  end if; 
end process;
end generate;


What would be the impact on FPGA and ASIC implementations for this cases? What is easy for the CAD tools to deal with? 

EDIT:
Just adding a response I gave to one helping guy, to make my question more clear:

For instance, when I ran a piece of code using for-loops on ISE, the synthesis summary gave me a fair result, taking a long while to compute everything. when I re-coded my design, this time using for-generate, and several processes, I used a bit more area, but the tool was able to compute everything way way faster and my timing result was better as well. So, does it imply on a rule, that is always better to use for-generates with a cost of extra area and lower complexity or is it one of the cases I have to verify every single implementation possibility?","Assuming relatively simple logic in the reset and test functions (for example, no interactions between adjacent bits) I would have expected both to generate the same logic.

Understand that since the entire for loop is executed in a single clock cycle, synthesis will unroll it and generate a separate instance of test_array_bit for each input bit. Therefore it is quite possible for synthesis tools to generate identical logic for both versions - at least in this simple example.

And on that basis, I would (marginally) prefer the for ... loop version because it localises the program logic, whereas the ""generate"" version globalises it, placing it outside the process boilerplate. If you find the loop version slightly easier to read, then you  will agree at some level.

However it doesn't pay to be dogmatic about style, and your experiment illustrates this : the loop synthesises to inferior hardware. Synthesis tools are complex and imperfect pieces of software, like highly optimising compilers, and share many of the same issues. Sometimes they miss an ""obvious"" optimisation, and sometimes they make a complex optimisation that (e.g. in software) runs slower because its increased size trashed the cache.

So it's preferable to write in the cleanest style where you can, but with some flexibility for working around tool limitations and occasionally real tool defects.

Different versions of the tools remove (and occasionally introduce) such defects. You may find that ISE's ""use new parser"" option (for pre-Spartan-6 parts) or Vivado or Synplicity get this right where ISE's older parser doesn't. (For example, passing signals out of procedures, older ISE versions had serious bugs).

It might be instructive to modify the example and see if synthesis can ""get it right"" (produce the same hardware) for the simplest case, and re-introduce complexity until you find which construct fails.

If you discover something concrete this way, it's worth reporting here (by answering your own question). Xilinx used to encourage reporting such defects via its Webcase system; eventually they were even fixed! They seem to have stopped that, however, in the last year or two.",,,,,
What is the meaning or difference between Simulation and Synthesis in VHDL?,"short question. 
What is the meaning of Simulation and Synthesis in VHDL?
What is the difference between Simulation and Synthesis in VHDL?

Yours sincerely
Momo","As you've probably realized by now, VHDL is not a programming language but a Hardware Description Language. It is very easy to get confused about the terminology cause HDL doesn't work like software.

Simulation consists of using a simulator (surprise) such as ModelSim to interpret your VHDL code while stimulating inputs to see what the outputs would look like. The results are typically displayed in a waveform chart, so whenever you see a waveform chart odds are it's about simulation. Simulation takes place in a computer never involving an actual FPGA. Simulation software can be very expensive, I recently came across a free online tool with fair simulation capabilities: EDA Playground

Synthesizing is a completely different thing. Once your design has been proved to work in simulation, the VHDL code goes through a tough process that figures how to implement, simplify, layout and route the actual resources in the FPGA to perform the functions it's supposed to (think of it as the hardware equivalent to compiling). The output of this process is a file that is downloaded to the FPGA.

Hope it helps!",,,,,
When to use VHDL library std_logic_unsigned and numeric_std?,"I use VHDL-200X in ISE.I always use data type like std_logic_vector,std_logic,integer,boolean and real.Always use std_logic_vector convert to integer and reverse.
My team mates ask me to use these three parts of library IEEE.

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;


But someone said do not use IEEE.STD_LOGIC_UNSIGNED.ALL instead of IEEE.NUMERIC_STD.ALL.Because you have everything you need in numeric_std, and STD_LOGIC_UNSIGNED is not standard library. Here.

I confused about it and anybody can help?","Never use std_logic_arith or std_logic_**signed. Always use numeric_std when signed or unsigned values are needed. The former packages claim to be IEEE, but they aren't. They are vendor specific extensions from Synopsys or Mentor Graphics.

Both defined arithmetic operations on std_logic_vector based on the imported packages. This e.g. means you can't used signed and unsigned values in the same architecture.

Doing all math in integers has some drawbacks:


no uninitialized value
no 'X' propagation
limited to 32 bits
(How to write a 64 bit counter?)
",,,,,
Is there a simple example of how to generate verilog from Chisel3 module?,"I'm looking for a simple howto to convert a simple Chisel3 module in Verilog.

I take Gcd source code given on official web page of chisel.

  import chisel3._

  class GCD extends Module {
    val io = IO(new Bundle {
      val a  = Input(UInt(32.W))
      val b  = Input(UInt(32.W))
      val e  = Input(Bool())
      val z  = Output(UInt(32.W))
      val v  = Output(Bool())
    })
    val x = Reg(UInt(32.W))
    val y = Reg(UInt(32.W))
    when (x &gt; y) {
      x := x -% y
    }.otherwise {
      y := y -% x
    }
    when (io.e) {
      x := io.a
      y := io.b
    }
    io.z := x
    io.v := y === 0.U
  }


I can't find a how to write a build.sbt and class instantiation for converting it in Verilog.","Thank you for your interest in Chisel! We generally encourage people to use our chisel-template repo as a starting point for Chisel3 projects:  https://github.com/ucb-bar/chisel-template
If you want to do the most barebones possible thing. Create this build.sbt and put it in the root directory for your project.
scalaVersion := &quot;2.13.8&quot;

addCompilerPlugin(&quot;edu.berkeley.cs&quot; % &quot;chisel3-plugin&quot; % &quot;3.5.3&quot; cross CrossVersion.full)

libraryDependencies += &quot;edu.berkeley.cs&quot; %% &quot;chisel3&quot; % &quot;3.5.3&quot;

Put the above GCD source code in GCD.scala and add the following to the file:
import chisel3.stage.ChiselStage

object GCDDriver extends App {
  (new ChiselStage).emitVerilog(new GCD, args)
}

You can then generate the Verilog by running:  sbt &quot;runMain GCDDriver&quot;. The default output directory is the current directory.
You can see what command-line options are available by running sbt &quot;runMain GCDDriver --help&quot; For example --target-dir will let you change the target directory",,,,,
"How to define variable number of ""and"" gates (logic gates) programatically?","I need to create 31 ""and"" gates, and I tried using a for loop and begin:

for(i=1;i&lt;=30;i=i+1)
    begin
    and g[i](u[i],p[i],q[1]);  // Line 29
    end
end


But, it is showing syntax error at ""and""- line 29.
Is there any way it can be declared and initialised programmatically rather than declaring each ""and"" gate?

","There are two other ways. You can use an array of instances

and g[31:1](u,p, q);


or you can use a generate loop

genvar i;
for(i=1;i&lt;=31;i=i+1) begin : block
  and g(u[i],p[i],q[i]);
end


This creates the and gates block[1].g through block[31].g",,,,,
Implement MATLAB algorithm in Spartan 3E,I am new to FPGA. Is it possible to implement MATLAB algorithm in Spartan 3E without using RS232?,"RS232 is a connection port for things like UART.

If you are asking about downloading matlab code into an FPGA, then no. You can create simulink models and include them into your designs at compile time; but this has nothing to do with RS232.",,,,,
Type vs Subtype and down vs to for Integers in VHDL,"What is the difference between type and subtype in VHDL and where should I use them ?   

My understanding is that subtype is just narrowed down version of one of the primary types, such as integer: subtype small_integer is integer range -128 to 127; All the operations possible on primary type, are also possible on subtypes(of course, with certain limitations) . Also, it is better to use subtypes to prevent errors.

So what is the purpose of the type ?  

What is the difference between donwto and to for the integers ? (To get the point across, here is an example)
subtype bit_index is integer range 31 downto 0;
 subtype bit_index is integer range 0 to 31;  

Thanks !","
As you correctly say, a type is the base for subtypes; without type there is no subtype. However, subtypes are only safer in simulation; in real hardware, there are no boundary checks etc...

The standard libraries of VHDL defines a number of base types for you to build upon, like std_logic, std_ulogic, std_logic_vector (unconstrained, defined in package std_logic_1164) integer, character (defined in package standard),  and so on. Your own definitions like std_logic_vector(7 downto 0) create a subtype indirectly (or directly if you define and name your subtypes explicitly)

When you are looking at your own enumerations, e.g., when describing the states of a state machine, you need a type:
type tState is (IDLE, DO_SOMETHING, DONE);

About the downto and to for the integers: it is useless for the integer itself. However, integer, natural etc. can be array index types. In some situations with unconstrained arrays, e.g. like here
constant c : std_logic_vector := &quot;1000&quot;
the direction of the range of the index type is taken as direction of the literal. In this case, the index type of std_logic_vector is natural, which itself is defined as subtype natural is integer range 0 to integer'high;. Therefor constant c is defined as to and the literal is parsed accordingly ('1' is the LSB)

",,,,,
"Verilog equivalent of ""wait until ... for ...""?","In a Verilog testbench, I'm trying to code the following behavior:


Wait until an event occurs (rising / falling edge) for a maximum time, i.e. an equivalent of the VHDL instruction:

wait until &lt;event&gt; for &lt;duration&gt;;



which has the following behavior (reminder):


either the event occurs;
or the duration expires.


Unless I'm mistaken, I did not find any direct equivalent of this function in Verilog... So I tried the following code:

reg watchdog;
// ...

// Set a signal 'watchdog' in background which will be triggered in 10 us.
fork
  watchdog &lt;= #10_000 1'b1;
join

// Wait until SIGNAL is set to '1' *OR* watchdog event occurs.
@(posedge SIGNAL or posedge watchdog);

// Reset the watchdog
watchdog &lt;= 1'b0;


This code does the work but the last instruction does not cancel or supercede the fork instruction. So, in a second call to this code (with for example watchdog &lt;= #50_000 1'b1;), the first watchdog may be triggered (too soon unfortunately).

Any better idea? (either an equivalent or a way to cancel the first planned fork?)

P-S : to do it in SystemVerilog is not an option... ;-)","To do this in Verilog you need to use disable.  I would suggest getting rid of the watchdog signal entirely and just using two branches of a fork.

Below is a working example.  Note that each branch of the fork calls disable f if that branch succeeds.  Disabling the fork will terminate the branch which did not succeed.

module top;

reg signal;

task test();
   fork : f
      begin
         // Timeout check
         #10
         $display(""%t : timeout"", $time);
         disable f;
      end
      begin
         // Wait on signal
         @(posedge signal);
         $display(""%t : posedge signal"", $time);
         disable f;
      end
   join
endtask

initial begin
   // test signal before timeout
   fork
      test;
      begin
         signal = 0;
         #5;
         signal = 1;
         #5;
         signal = 0;
         #10;
      end
   join
   // test signal after timeout
   fork
      test;
      begin
         signal = 0;
         #15;
         signal = 1;
         #5;
      end
   join
end
",,,,,
Verilog question mark (?) operator,"I'm trying to translate a Verilog program into VHDL and have stumbled across a statement where a question mark (?) operator is used in the Verilog program.

The following is the Verilog code;

1  module music(clk, speaker);
2  input clk;
3  output speaker;
4  parameter clkdivider = 25000000/440/2;

5  reg [23:0] tone;
6  always @(posedge clk) tone &lt;= tone+1;

7  reg [14:0] counter;
8  always @(posedge clk) if(counter==0) counter &lt;= (tone[23] ? clkdivider-1 : clkdivider/2-1); else counter &lt;= counter-1;

9  reg speaker;
10  always @(posedge clk) if(counter==0) speaker &lt;= ~speaker;
11  endmodule


I don't understand the 8th line, could anyone please shed some light on this?
I've read on the asic-world website that the question mark is the Verilog alternate for the Z character. But I don't understand why it's being used in this context.

Kind regards","That's a ternary operator. It's shorthand for an if statement

Format:

condition ? if true : if false


Example:

tone[23] ? clkdivider-1 : clkdivider/2-1


Translates to something like (not correct syntax but I think you'll get it): 

if tone[23] is 1, counter = clkdivider-1
else counter = clkdivider/2-1


Here are two examples of a 2 to 1 MUX using if statement and ternary operator.

On the asic-world website, it is covered under Conditional Operators",,,,,
How does Verilog behave with negative numbers?,"For instance, say I have a reg [7:0] myReg
I assign it the value -8'D69

I know Verilog stores it as 2's complement so it should be stored as

10111011


The question I have now is if I were to perform an operation on it, say myReg/2

Would it evaluate to -34? Or would it take 10111011 and turn it into 187 then perform the division, returning 93?","You need to remember that -8d69 is just a bit pattern. reg is a type which holds bit patterns. It is the type of variable that instructs / to perform signed or unsigned arithmetic.

If this is for synthesis bare in mind that you want to try and avoid dividers, you really want to try and avoid signed dividers. It will likely synthesis smaller with &gt;&gt;&gt; 1 

reg [7:0] a;
reg signed [7:0] b;
reg [7:0] c;
reg signed [7:0] d;

initial begin
  a =  -8'd69 ;
  b =  -8'd69 ;
  c =  -8'd69 ;
  d =  -8'd69 ;
  #10ns;
  a = a/2     ;
  b = b/2     ;
  #10ns;
  $display(""a      : %8b, %d"", a, a);
  $display(""b      : %8b, %d"", b, b);
  $display(""c &gt;&gt;&gt;1 : %8b, %d"", c&gt;&gt;&gt;1, c&gt;&gt;&gt;1);
  $display(""d &gt;&gt;&gt;1 : %8b, %d"", d&gt;&gt;&gt;1, d&gt;&gt;&gt;1);
end


Gives:

a      : 01011101,  93
b      : 11011110,  -34 
c &gt;&gt;&gt;1 : 01011101,  93
d &gt;&gt;&gt;1 : 11011101,  -35


&gt;&gt; x Shifts right by x places, &gt;&gt;&gt; x Shifts right x places but sign extends for signed types. 

NB: the /2 is also rounding up in my examples, &gt;&gt;&gt; will round down/truncate.",,,,,
How can the linux kernel be forced to enumerate the PCI-e bus?,"Linux kernel 2.6

I've got an fpga that is loaded over GPIO connected to a development board running linux.
The fpga will transmit and receive data over the pci-express bus. However, this is enumerated
at boot and as such, no link is discovered (because the fpga is not loaded at boot).

How can I force re-enumeration of the pci-e bus in linux?
Is there a simple command or will I have to make kernel changes? 
I need the capability to hotplug pcie devices. ","I wonder what platform you are on: A work around (aka hack) for this that works on x86 systems is to have the BIOS basically statically configure a PCI device at whatever bus, device, function the FPGA normally lands on, then the OS will enumerate the device and reserve the PCI space for it (even though the device isn't really there). Then in your device driver you will have to do some extra things like setup the BARs and int lines manually after the fpga has been programmed. Of course this requires modifying the BIOS, which if you are working with a BIOS vendor you can contract them to make this change for you, if you are not working with a BIOS vendor then it will be much harder... Also keep in mind that I was working on VxWorks on x86, and we had a AMI make a custom BIOS for our boards... 

If you don't have a BIOS, then consider programming it in the bootloader, there you already have the ability to read from disk, and adding GPIO capabilities probably isn't too difficult (assuming you are using jtag and GPIOs?), in fact depending on what bootloader you use it might already be able to do GPIO? 

The issues with modifying the kernel to do this is that you have to find the sweet spot where you can read the bitfile, before the PCI enumeration... If for example the disk device drivers are initialized after PCI, then obviously you must do some radical changes to the kernel just to read the bitfile prior to PCI enumeration, which might cause other annoying problems...

One other option which you may have already discovered, and which is really only ok for development time: Power up the system, program the fpga board, then do a reset (without power cycle, for example: sudo reboot now), the FPGA should keep its configuration, and linux should enumerate it... ",,,,,
Instantiate Modules in Generate For Loop in Verilog,"I'm trying to instantiate some modules in Verilog using a generate block since I'm going to be instantiating a variable amount of them.

genvar i;
generate
    for (i=1; i&lt;=10; i=i+1) begin
    status whatever_status (
        .clk(clk),
        .reset_n(reset_n),
        .a(a[i]),
        .b(b[i]),
        .out(out[i])
    );
end 
endgenerate


a &amp; b are declared as input arrays to the parent module and out is declared as a array of wires.

What am I doing wrong here?  Is this not allowed in Verilog?  Quartus is telling me:

Error (10644): Verilog HDL error at driver.v(63): this block requires a name


Line 63 is the for loop above.  Any help is appreciated!","You can apply label identifier to begin-end block with a colon after the begin (example: begin : label - end. This has always been an optional feature for generate blocks, though it is highly recommended.  Quartus should not be giving an error. 

It is an easy fix to satisfy Quartus-- add a label of any name you want:

genvar i;
generate
    for (i=1; i&lt;=10; i=i+1) begin : generate_block_identifier // &lt;-- example block name
    status whatever_status (
        .clk(clk),
        .reset_n(reset_n),
        .a(a[i]),
        .b(b[i]),
        .out(out[i])
    );
end 
endgenerate
",,,,,
<= Assignment Operator in Verilog,"What does the &lt;= do in Verilog?

For example:

always @(posedge Clock) begin
   if (Clear) begin
      BCD1 &lt;= 0;
      BCD0 &lt;= 0;
   end
end
","""&lt;="" in Verilog is called non-blocking assignment which brings a whole lot of difference than ""="" which is called as blocking assignment because of scheduling events in any vendor based simulators. 

It is Recommended to use non-blocking assignment for sequential logic and blocking assignment for combinational logic, only then it infers correct hardware logic during synthesis.

Non-blocking statements in sequential block will infer flip flop in actual hardware.

Always remember do not mix blocking and non-blocking in any sequential or combinational block.

During scheduling process of simulator:

There are four regions and order of execution of commands as follows

1) Active region
     --Blocking assignments
     --Evaluation of RHS of non-blocking assignments(NBA)
     --Continuous assignment
     --$display command
     --Evaluate input and output of primitives
2) Inactive region
     --#0 blocking assignments
3) NBA(non-blocking assignment update)
     --update LHS of non-blocking assignments (NBA)
4) Postponed
     --$monitor command
     --$strobe command


Using of blocking assignment ""="" for two variable at the same time slot causes race condition 

eg: Verilog code with race condition, 

always @(posedge Clock) 
   BCD0 = 0; // Usage of blocking statements should be avoided
always @(posedge Clock) 
   BCD1 = BCD0; 


In order to avoid race condition use non-blocking statement ""&lt;=""

eg: 

   always @(posedge Clock) 
       BCD0 &lt;= 0; // Recommended to use NBA
    always @(posedge Clock) 
       BCD1 &lt;= BCD0; 


When this block is executed, there will be two events added to the non blocking assign update queue.
Hence, it does the updation of BCD1 from BCD0 at the end of the time step.

Using Non-blocking ""&lt;="" assignment in continuous assignment statement is not allowed according to verilog LRM and will result in compilation error.

eg: 

assign BCD0 &lt;= BCD1; //Results in compilation error


Only use NBA in procedural assignment statements, 

 - initial and
 - always blocks
",,,,,
Testing FPGA Designs at Different Levels,"Various aspects of test strategies for FPGAs have been discussed here on SO but I can't find that the following question has been asked/discussed/answered:

At what levels should you simulate your FPGA design and what do you verify at each level?

If you answer using concepts such as x-level testing where x = block, subsystem, function, or something else,  please describe what x is for you. Something like typical size, complexity, or an example.



Sep 14

Both given answers are the same when it comes to the actual question but I'll accept the answer from @kraigher since it's the shortest one.



Sep 10

This is a summary and a comparison of the two answers from @Paebbles and @kraigher. One of the answers is very long so hopefully this will help anyone that want to contribute with their own answer. Remember that there's a bounty at stake!


They both simulate all components at all levels. At least @Paebbles makes exceptions for components that have very little functional content, for example a MUX.
They both strive for test automation
They both develop ""tools"" to simplify board-level testing
They both avoid testing things at one level that have already been tested at the level below
The biggest difference seems to be in how often the testbenches are simulated. @Paebbles tests directly in HW unless there are major design changes in which case the simulations are run as well. @kraigher runs the simulations more continuously as the design evolves. I think this is a very important question as well and personally I prefer the way @kraigher expressed. However, this was not part of the original question so I think there is consensus between the two answers. The question on how often tests should be run has also been discussed before on SO, for example how often should the entire suite of a system&#39;s unit tests be run?


There is a difference in how much in-lab testing they do but it seems mostly related to the specific circumstances for the projects (how many things that can't be effectively tested with simulations). I happen to know a bit about @kraigher last project so I can say that both projects are in the 1+ year category. It would be interesting to hear a story from someone with a smaller project. From what I've seen far from all projects are as complete with respect to functional coverage in simulations so there must be other stories.



Sep 7

This is a number of follow-up questions to @peabbles too long to fit among the comments.

Yes @peabbles, you have provided much of what I was looking for but I still have extra questions. I'm afraid that this may be a lengthy discussion but given the amount of time we spend on verification and the various strategies people apply I think it deserves a lot of attention. Hopefully we will have some more answers such that various approaches can be compared. Your bounty will surely help.

I think your story contains many good and interesting solutions but I'm an engineer so I will focus on the pieces I think can be challenged ;-)

You've spend a lot of time testing on hardware to address all the external issues you had. From a practical point of view (since they were not going to fix their SATA standard violations) it's like having a flawed requirement spec such that you develop a design solving the wrong problem. This is typically discovered when you â€œdeliverâ€?which motivates why you should deliver frequently and discover the problems early as you did. I'm curious about one thing though. When you discovered a bug in the lab that needed a design change would you then update the testbenches at the lowest level where this could be tested? Not doing that increases the risk that the bug reappears in lab and over time it would also degrade the functional coverage of your testbenches making you more dependent on lab testing.

You said that most testing was done in the lab and that was caused by the amount of external problems you had to debug. Is your answer the same if you just look at your own internal code and bugs? 

When you're working with long turnaround times like you did you find various ways to make use of that time. You described that you started to synthesize the next design when the first was being tested and if you found a bug in one drive you started to synthesize a fix for that one while continuing to test other drives with the current design. You also described problems with observability when testing in the lab. I'm going to do a number of sceptical interpretations of this, you have to provide the positive ones!

If you could synthesize the next design immediately when you started to test the first it seems like you were working with very small increments but still made the effort to run every test at every level all the way to hardware. This seems a bit overkill/expensive, especially when you're not fully automated on the hardware testing. Another sceptical interpretation is that you're looking for a bug but due to poor observability you are producting random trial and error type of builds hoping that they will give clues to the problem you're trying to isolate. Was this really effective use of time in the sense that every build added value or was it more â€œdoing something is better than doing nothingâ€? 

When designing the higher protocol layers did you consider to short circuit the communication stack on the higher levels to speed up the simulation? After all, the lower layers were already tested.

You reused some components and assumed them to be bug free. Was that because they were shipped with testbenches proving that? Proven in use tend to be weak since reuse often happens in another context. The Arianne 5 rocket is a spectacular example, your reuse of XAPP 870 for Virtex 5 another.

Since you have simulations at various levels I would assume that you value the faster run times at the lower levels and the shorter feedback loop you have when you can verify a piece of your design before the larger structure has been completed. Still you had pieces of code that were significant enough to be awarded their own components but still too simple to be awarded their own testbenches. Can you give an example of such a component? Were they really bug free? Personally I don't write many lines of code before I make a mistake so if I have a well packaged piece of code like a component I take the opportunity to test at that level for the reasons mentioned above.","I perform behavioral simulation at all levels. That is all entities should have one corresponding test bench aiming for full functional coverage. If specific details of entities A, B and C have already been tested in isolation in their corresponding test benches they do not have to be covered in the test bench for entity D which instantiates A, B and C which should focus on proving the integration.

I also have device or board level tests where the actual design is verified on the actual device or board. This is because you cannot trust a device level simulation when models start to become inexact and also it takes to long. In the real device hours of testing can be achieved instead of milliseconds.

I try to avoid to perform any post-synthesis simulation unless a failure occurs in the device level tests in which case I perform it to find bugs in the synthesis tool. In this case I can make a small wrapper of the post-synthesis netlist and re-use the testbench from the behavioral simulation.

I work very hard to avoid any form of manual testing and instead rely on test automation frameworks for both simulation and device level testing such that testing can be performed continuously.

To automate simulation I use the VUnit test automation framework which @lasplund and myself are the authors of.",,,,,
How to define and initialize a vector containing only ones in Verilog?,"If I want to declare a 128 bit vector of all ones, which one of these methods is always correct?

wire [127:0] mywire;

assign mywire = 128'b1;
assign mywire = {128{1'b1}};
assign mywire = 128'hFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
","As a quick simulation would prove, assign mywire = 128'b1; does not assign all bits of mywire to 1.  Only bit 0 is assigned 1.

Both of the following always assign all 128 bits to 1:

assign mywire = {128{1'b1}};
assign mywire = 128'hFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;


One advantage of the 1st line is that it is more easily scalable to widths greater than and less than 128.

With SystemVerilog, the following syntax also always assigns all 128 bits to 1:

assign mywire = '1;
",,,,,
Comparing a long std_logic_vector to zeros,"In simulation this works perfect. Is this is the best way of checking for
zeros for a synthesisable code. What would be the resources generated?

signal vector_slv : std_logic_vector(2048 downto 0);
...
if (vector_slv = (vector_slv'range =&gt; '0')) then
  -- do something...


Is there any other optimal way to implement this solution considering h/w mapping (with optimal resource utilization).

I would be more interested in understanding the resources used.","There's no way that makes more or less sense for synthesis. Write the code that best expresses your intention.

If you are comparing a vector for all zeros, the following should all produce the same results, or you should file a serious bug against the tool!

signal vector_slv : std_logic_vector(2048 downto 0);
constant zeros : std_logic_vector(vector_slv'range) := (others =&gt; '0');
...
if vector_slv = (vector_slv'range =&gt; '0') then
  -- do something...
if vector_slv = zeros then
  -- do something...
if unsigned(vector_slv) = to_unsigned(0, vector_slv'length) then
  -- do something...


and indeed for shorter vectors which fit in an integer:

if intvar = 0 then


will be exactly the same as any 32-bit vector comparison.


(BTW, note there is no need for parentheses around the if condition - VHDL is not C :)
",,,,,
"Hello,I am new to VHDL programming please help me out with these errors","I don't know why its showing error although syntax seems to be right.

I'm t rying to program sramctl where address adds_in is input address and sram_adds output address I am just mapping the address and have not consider the data bus.

library IEEE;
use IEEE.std_logic_1164.all;

entity sramctrl is
port(clk,adsn,blastn,lwdrn,lhold:in std_logic;
 adds_in :in std_logic_vector(9 downto 2);          

 adds_4msb:in std_logic_vector(31 downto 28);
 readyn,btermn,sramcsn,sramoen,lholda :out std_logic;
 sram_adds:out std_logic_vector(9 downto 2));
 end sramctrl;
architecture behavioral of sramctrl is
type state_type is(s0,s1,s2);
signal state:state_type;
begin
process(clk,adsn,blastn,lwdrn,lhold,adds_in,adds_4msb)
begin
    variable sa:std_logic:='0';
    variable a31_a28 :std_logic_vector(3 downto 0):=""0000"";
    variable temp:std_logic_vector(9 downto 2):=""00000000"";
    if(rising_edge(clk))then
        if ((not adsn) and (adds_4msb=""0000""))then         
        a31_28 := adds_4msb; 
        end if;
        if (lhold='1')then
            lholda&lt;='1';
        else
             lholda&lt;='0';
        end if;
        sa:=lhold and lholda ;
        case state is
            when s0=&gt;sramoen&lt;='1';
                    sramcsn&lt;='1';
                    readyn&lt;='1';
                    btermn&lt;='1';
                    if((not adsn) and (not adds_4msb) and sa)then
                        temp:=adds_in;
                            if(lwdrn='1')then
                                state&lt;=s1;
                                ready&lt;='0';
                            else
                                state&lt;=s2;
                            end if;
                    else
                        state&lt;=s0;
                    end if;
                when s1=&gt;sramoen&lt;='1';
                        sramcsn&lt;='0';
                        if(lwdrn and (not blastn) and sa)then
                            sram_adds&lt;=temp;
                            readyn&lt;='1';
                            btermn&lt;='1';
                            state&lt;=s0;
                        elsif(lwdrn and blastn and sa)then
                            if(temp=X""fe"")then
                                sram_adds&lt;=temp;
                                temp:=temp+1;
                                btermn&lt;='0';
                                readyn&lt;='0';
                                state&lt;=s1;
                            elsif(temp=X""ff"")then
                                sram_adds&lt;=temp;
                                btermn&lt;='1';
                                readyn&lt;='1';
                                state&lt;=s0;
                            else
                                sram_adds&lt;=temp;
                                temp:=temp+1;
                                btermn&lt;='1';
                                readyn&lt;='0';
                                state&lt;=s1;
                            end if;
                        else
                            state&lt;=s2;
                        end if;
             when s2=&gt;sramoen&lt;='0';
                      sramcsn&lt;='0';
                     if((not lwdrn) and (not blastn) and sa)then
                        sram_adds&lt;=temp;
                        readyn&lt;='1';
                        btermn&lt;='1';
                        state&lt;=s0;
                    elsif((not lwdrn) and blastn and sa)then
                        if(temp=X""fe"")then
                            sram_adds&lt;=temp;
                            temp:=temp+1;
                            btermn&lt;='0';
                            readyn&lt;='0';
                            state&lt;=s2;
                        elsif(temp=X""ff"")then
                            sram_adds&lt;=temp;
                            btermn&lt;='1';
                            readyn&lt;='1';
                            state&lt;=s0;
                        else
                            sram_adds&lt;=temp;
                            temp:=temp+1;
                            btermn&lt;='1';
                            readyn&lt;='0';
                            state&lt;=s2;
                        end if;
                    else
                     state&lt;=s2;
                    end if;
       when others =&gt;state&lt;=s0;
      end case;
      end if;
      end process;
      end behavioral ;


I couldn't find a solution please help me out. Errors it has popped:


  COMP96 Compile Architecture ""behavioral"" of Entity ""sramctrl""
   COMP96 ERROR COMP96_0019: ""Keyword 'end' expected."" ""design.vhd"" 18 9
  COMP96 ERROR COMP96_0019: ""Keyword 'end' expected."" ""design.vhd"" 19 3
  COMP96 ERROR COMP96_0016: ""Design unit declaration expected."" ""design.vhd""  
","No your syntax isn't correct.

As noted by Amir :

process(clk,adsn,blastn,lwdrn,lhold,adds_in,adds_4msb)
begin
    variable sa:std_logic:='0';
    variable a31_a28 :std_logic_vector(3 downto 0):=""0000"";
    variable temp:std_logic_vector(9 downto 2):=""00000000"";


Should be:

process(clk,adsn,blastn,lwdrn,lhold,adds_in,adds_4msb)
    variable sa:std_logic:='0';
    variable a31_a28 :std_logic_vector(3 downto 0):=""0000"";
    variable temp:std_logic_vector(9 downto 2):=""00000000"";
begin


begin separates the process declarative part from the process statement part here.

Also, here:

        if ((not adsn) and (adds_4msb=""0000""))then    


There isn't an and operator that ANDs a std_logic and a boolean (result of the right expression).not is not a logical reduction operator, it returns a std_logic in this case.

should be along the lines of:

        if adsn = '0' and adds_4msb = ""0000"" then


Which ANDs two boolean results. Notice the corrected spelling of adds_4msb.

The next line:

        a31_28 := adds_4msb; 


has a misspelling, that should be a31_a28.

And here::

        if lhold = '1' then
            lholda &lt;= '1';
        else
             lholda &lt;= '0';
        end if;
        sa := lhold and lholda ;


lholda is an output and in some tools not IEEE Std 1076-2008 compliant can not be read.  It also produces a sa that's simply delayed by one delta simulation cycle (no time advancing) and has no meaning other that to trim a delta cycle off the end of holda for sa or off the beginning of lhold.  If you're counting on that delta cycle hold over not being there you have a defective design.  Delta cycles emulate parallelism and variables shouldn't be counted on for timing relationships.  This would imply you don't have a synthesis eligible model of sram_ctl.  Synthesis would see lhold and lholda as one and the same, and sa as a different name for the same thing.

Here:

                                ready&lt;='0';


There is no signal ready present in your design.

And:

                        if(lwdrn and (not blastn) and sa)then


as well as:

                        elsif(lwdrn and blastn and sa)then


You're trying to produce a boolean condition with logic operators.  (All those parentheses are also redundant) try conditional testing the two expressions to a std_logic value.

These two conditions show up two places each.

And:

                                temp:=temp+1;


There is no adding operator ""+"" directly visible (two places).  You should either be using package std_logic_unsigned or temp should be an unsigned and you should be using package numeric_std (requiring a type conversion when assigning to sram_adds).",,,,,
"What does ""net"" stand for in Verilog?","I'm just starting to learn Verilog. As I understand, Verilog has net datatypes.

What does net stand for?","A net is such a data type, where you don't use it for storing values. They represent physical connections. You can think of wire as a net data type.
You can see more on nets here.",,,,,
Multidimensional Array Of Signals in VHDL,"I have a signal in VHDL declared like this : 

signal Temp_Key : std_logic_vector(79 downto 0);


This Temp_Key is passed through a for loop 31 times and it is modified. I want to store all the 31 different Temp_Keys in an array. 

Is it possible to use multi-dimensional arrays in VHDL to store 80 bit signals ? ","Yes, first you need to declare a type:

type YOUR_ARRAY_TYPE is array (0 to 30) of std_logic_vector(79 downto 0);


Note you can also declare the type to be of undefined length - so you can specify how many 80 bit words it has when you declare your signal. And with VHDL 2008, you can also leave the size of the slv unspecified, also to be declared when you create your signal. For example:

type slv_array is array (natural range &lt;&gt;) of std_logic_vector;


and then use it

signal MY_SIGNAL : YOUR_ARRAY_TYPE;
...
MY_SIGNAL(0) &lt;= data;
...
MY_SIGNAL(1) &lt;= data;


See here for a reference.",,,,,
Assign a synthesizable initial value to a reg in Verilog,"I'm an FPGA noob trying to learn Verilog.  How can I ""assign"" a value to a reg in an always block, either as an initial value, or as a constant.  I'm trying to do something like this in the code below.  I get an error because the 8 bit constant doesn't count as input.  I also don't want to trigger the always off of a clock.  I just want to assign a register to a specific value.  As I want it to be synthesisable I can't use an initial block.  Thanks a lot. 

module top
(
    input wire clk,
    output wire [7:0] led   
 );


reg [7:0] data_reg ; 
always @*
begin
    data_reg = 8'b10101011;
end

assign led = data_reg;

endmodule
","You can combine the register declaration with initialization.

reg [7:0] data_reg = 8'b10101011;


Or you can use an initial block

reg [7:0] data_reg;
initial data_reg = 8'b10101011;
",,,,,
How to declare and use 1D and 2D byte arrays in Verilog?,"How to declare and use 1D and 2D byte arrays in Verilog?

eg. how to do something like

byte a_2D[3][3];
byte a_1D[3];

// using 1D
for (int i=0; i&lt; 3; i++)
{
    a_1D[i] = (byte)i;
}

// using 2D
for (int i=0; i&lt; 3; i++)
{
    for (int j=0; j&lt; 3; j++)
    {
        a_2D[i][j] = (byte)i*j;
    }
}
","Verilog thinks in bits, so reg [7:0] a[0:3] will give you a 4x8 bit array (=4x1 byte array). You get the first byte out of this with a[0]. The third bit of the 2nd byte is a[1][2].  

For a 2D array of bytes, first check your simulator/compiler. Older versions (pre '01, I believe) won't support this.  Then reg [7:0] a [0:3] [0:3] will give you a 2D array of bytes.  A single bit can be accessed with a[2][0][7] for example. 

reg [7:0] a [0:3];
reg [7:0] b [0:3] [0:3];

reg [7:0] c;
reg d;

initial begin

   for (int i=0; i&lt;=3; i++) begin
      a[i] = i[7:0];
   end

   c = a[0];
   d = a[1][2]; 


   // using 2D
   for (int i=0; i&lt;=3; i++)
      for (int j=0; j&lt;=3; j++)
          b[i][j] = i*j;  // watch this if you're building hardware

end
",,,,,
Algorithms FPGAs dominate CPUs on,"For most of my life, I've programmed CPUs; and although for most algorithms, the big-Oh running time remains the same on CPUs / FPGAs, the constants are quite different (for example, lots of CPU power is wasted shuffling data around; whereas for FPGAs it's often compute bound).

I would like to learn more about this -- anyone know of good books / reference papers / tutorials that deals with the issue of:

what tasks do FPGAs dominate CPUs on (in terms of pure speed)
what tasks do FPGAs dominate CPUs on (in terms of work per jule)

Note: marked community wiki","[no links, just my musings]

FPGAs are essentially interpreters for hardware!
The architecture is like dedicated ASICs, but to get rapid development, and you pay a factor of ~10 in frequency and a [don't know, at least 10?] factor in power efficiency.

So take any task where dedicated HW can massively outperform CPUs, divide by the FPGA 10/[?] factors, and you'll probably still have a winner.  Typical qualities of such tasks:


Massive opportunities for fine-grained parallelism.
(Doing 4 operations at once doesn't count; 128 does.)
Opportunity for deep pipelining.
This is also a kind of parallelism, but it's hard to apply it to a 
single task, so it helps if you can get many separate tasks to 
work on in parallel.
(Mostly) Fixed data flow paths.
Some muxes are OK, but massive random accesses are bad, cause you 
can't parallelize them.  But see below about memories.
High total bandwidth to many small memories.
FPGAs have hundreds of small (O(1KB)) internal memories 
(BlockRAMs in Xilinx parlance), so if you can partition you 
memory usage into many independent buffers, you can enjoy a data 
bandwidth that CPUs never dreamed of.
Small external bandwidth (compared to internal work).
The ideal FPGA task has small inputs and outputs but requires a 
lot of internal work.  This way your FPGA won't starve waiting for 
I/O. (CPUs already suffer from starving, and they alleviate it 
with very sophisticated (and big) caches, unmatchable in FPGAs.)
It's perfectly possible to connect a huge I/O bandwidth to an 
FPGA (~1000 pins nowdays, some with high-rate SERDESes) - 
but doing that requires a custom board architected for such 
bandwidth; in most scenarios, your external I/O will be a 
bottleneck.
Simple enough for HW (aka good SW/HW partitioning).
Many tasks consist of 90% irregular glue logic and only 10% 
hard work (""kernel"" in the DSP sense).  If you put all that 
onto an FPGA, you'll waste precious area on logic that does no 
work most of the time.  Ideally, you want all the muck
to be handled in SW and fully utilize the HW for the kernel.
(""Soft-core"" CPUs inside FPGAs are a popular way to pack lots of 
slow irregular logic onto medium area, if you can't offload it to
a real CPU.)
Weird bit manipulations are a plus.
Things that don't map well onto traditional CPU instruction sets,
such as unaligned access to packed bits, hash functions, coding &amp;
compression...  However, don't overestimate the factor this gives
you - most data formats and algorithms you'll meet have already 
been designed to go easy on CPU instruction sets, and CPUs keep
adding specialized instructions for multimedia.
Lots of Floating point specifically is a minus because both 
CPUs and GPUs crunch them on extremely optimized dedicated silicon.
(So-called ""DSP"" FPGAs also have lots of dedicated mul/add units, 
but AFAIK these only do integers?)
Low latency / real-time requirements are a plus.
Hardware can really shine under such demands.


EDIT: Several of these conditionsÂ â€”Â esp. fixed data flows and many separate tasks to work on â€?also enable bit slicing on CPUs, which somewhat levels the field.",,,,,
Programming VHDL on Linux?,Anyone knows good environment to program VHDL and simulate it (don't matter Xilinx or Altera) using Linux?,"You're stuck with either vendors tools, which are spotty at best on Linux (though my experience with Alteras utilities are somewhat better than with ISE).

However, if all you want to do is run your testbed, not actually synthesize anything, ghdl will be of use.",,,,,
VHDL/Verilog related programming forums?,"Hardware design with VHDL or Verilog is more like programming nowadays. However, I see SO members are not so actively talking about VHDL/Verilog programming.

Is there any forum dealing with hardware design with Verilog/VHDL/SystemVerilog or SystemC?","Logic Design was closed because of too little attention. It's now reopened, but interest remains low.",,,,,
Professional VHDL IDE?,"Is there a good IDE to work with VHDL projects ?
Or are most of the professionals working with emacs/vim/notepad++ ?","I use Emacs+VHDL-mode which is great if you don't mind (or have already climbed) the learning curve of Emacs.

Alternatively, you could try Sigasi-HDT which is Eclipse-based and has more GUI.  And some more powerful refactoring tools by the look of it.",,,,,
Passing Generics to Record Port Types,"I did recently start to use records for my port definitions, especially if I want to group signals that belong to a certain interface. However, the problem I'm facing here is that I cannot pass, say the width of a std_logic_vector, to the entity by means of a generic. So what I basically want to do is the following:

library ieee;
use ieee.std_logic_1164.all;
use work.math_pkg.all;

package fifo_pkg is

  type fifo_in_type is record
    data_in : std_logic_vector(DATA_WIDTH_??- 1 downto 0);
    rd      : std_logic;
    wr      : std_logic;
  end record;

  type fifo_out_type is record
    data_out : std_logic_vector(DATA_WIDTH_?? - 1 downto 0);
    empty    : std_logic;
    full     : std_logic;
  end record;

  component fifo is
    generic
      (
        MIN_DEPTH  : integer;
        DATA_WIDTH : integer
        );
    port
      (
        clk   : in  std_logic;
        res_n : in  std_logic;
        i     : in  fifo_in_type;
        o     : out fifo_out_type
        );
  end component fifo;

end fifo_pkg;   


So the ideal solutions would be when i can use the same generic in my record as i did in the entity. (So that DATA_WIDTH is the same as DATA_WIDTH_??). I know that this should work somehow with vhdl 2008, however my quartus II 11sp1 does not support generics in records.

Is there an elegant way to achieve that kind of ""generic passing"" that is synthesizable? I know that one could just store a constant in the package, but then I cannot use the same fifo package to instantiate several fifo's with different widths.

Thanks a million,
T","Can you use type generics with Quartus?

Then you leave the type completely unspecified, so that you can create a FIFO of integers or any other data type:

package fifo_pkg is
  generic (type element_type);

  type fifo_in_type is record
    data_in : element_type;
    rd      : std_logic;
    wr      : std_logic;
  end record;

  type fifo_out_type is record
    data_out : element_type;
    empty    : std_logic;
    full     : std_logic;
  end record;

  component fifo is
    generic
      (
        MIN_DEPTH  : integer;
        DATA_WIDTH : integer
        );
    port
      (
        clk   : in  std_logic;
        res_n : in  std_logic;
        i     : in  fifo_in_type;
        o     : out fifo_out_type
        );
  end component fifo;

end fifo_pkg;


Then when you want to use it:

package wide_fifo_pkg is new fifo_pkg
   generic map (type =&gt; std_logic_vector(31 downto 0));


and then you can use fifo_in_type and fifo_out_type:

signal i : fifo_in_type;


If you have more than one FIFO in a design unit you can create several versions of the package and use the package prefix to get the right type:

package narrow_fifo_pkg is new fifo_pkg
   generic map (type =&gt; std_logic_vector(3 downto 0));

signal i32 : wide_fifo_pkg.fifo_in_type;
signal i4  : narrow_fifo_pkg.fifo_in_type;




Another VHDL 2008 option: you can have an unconstrained record type:

 type fifo_in_type is record
    data_in : std_logic_vector;
    rd      : std_logic;
    wr      : std_logic;
  end record;


which you can then create subtypes of for your various uses:

subtype fifo1_data_type is fifo_in_type(data_in(31 downto 0));
subtype fifo2_data_type is fifo_in_type(data_in(15 downto 0));




No idea if Quartus supports either of those options - please let us know!",,,,,
VHDL difference between => and <=,I keep forgetting and its difficult to search for the answer in a textbook or the Internet.,"Well, &lt;= is assignment.

signal &lt;= A or B;


=> is syntax used for case statements like so:
(Stolen from http://www.cs.umbc.edu/portal/help/VHDL/sequential.html)

case  my_val  is
  when 1 =&gt;  // This is kind of like how the : operator is used for switch in many languages
    a:=b;
  when 3 =&gt;
    c:=d;
    do_it;
  when others =&gt;
    null; // do nothing
end case;

end case;


=> can also be used in array assignments

myVector &lt;= (1=&gt;'1', OTHERS=&gt;'0');  -- assigns ('0','1','0','0') to ""myVector""


Source: http://www.eda.org/comp.lang.vhdl/html3/gloss_example.html",,,,,
Indexing vectors and arrays with +:,"I am seeing a code in SystemVerilog which has something like this:

if(address[2*pointer+:2])
  do_something;


How should I understand the +: when indexing this vector?

I found that it is called bit slicing, but I can't find an explanation about it.","Description and examples can be found in IEEE Std 1800-2017 &sect; 11.5.1 ""Vector bit-select and part-select addressing"". First IEEE appearance is IEEE 1364-2001 (Verilog) &sect; 4.2.1 ""Vector bit-select and part-select addressing"". Here is an direct example from the LRM:


logic [31: 0] a_vect;
logic [0 :31] b_vect;
logic [63: 0] dword;
integer sel;
a_vect[ 0 +: 8] // == a_vect[ 7 : 0]
a_vect[15 -: 8] // == a_vect[15 : 8]
b_vect[ 0 +: 8] // == b_vect[0 : 7]
b_vect[15 -: 8] // == b_vect[8 :15]
dword[8*sel +: 8] // variable part-select with fixed width



If sel is 0 then dword[8*(0) +: 8] == dword[7:0]
If sel is 7 then dword[8*(7) +: 8] == dword[63:56]

The value to the left always the starting index. The number to the right is the width and must be a positive constant. the + and - indicates to select the bits of a higher or lower index value then the starting index.

Assuming address is in little endian ([msb:lsb]) format, then if(address[2*pointer+:2]) is the equivalent of if({address[2*pointer+1],address[2*pointer]})",,,,,
' << ' operator in verilog,"i have a verilog code in which there is a line as follows:

parameter ADDR_WIDTH = 8 ;
parameter RAM_DEPTH = 1 &lt;&lt; ADDR_WIDTH;


here what will be stored in RAM_DEPTH and what does the &lt;&lt; operator do here.","&lt;&lt; is a binary shift, shifting 1 to the left 8 places.

4'b0001 &lt;&lt; 1 =&gt; 4'b0010


&gt;&gt; is a binary right shift adding 0's to the MSB.
&gt;&gt;&gt; is a signed shift which maintains the value of the MSB if the left input is signed.

4'sb1011 &gt;&gt;  1 =&gt; 0101
4'sb1011 &gt;&gt;&gt; 1 =&gt; 1101


Three ways to indicate left operand is signed:

module shift;
  logic        [3:0] test1 = 4'b1000;
  logic signed [3:0] test2 = 4'b1000;

  initial begin
    $display(""%b"", $signed(test1) &gt;&gt;&gt; 1 ); //Explicitly set as signed
    $display(""%b"", test2          &gt;&gt;&gt; 1 ); //Declared as signed type
    $display(""%b"", 4'sb1000       &gt;&gt;&gt; 1 ); //Signed constant
    $finish;
  end
endmodule
",,,,,
What is `+:` and `-:`?,"What are the +: and -: Verilog/SystemVerilog operators?  When and how do you use them?  For example:

logic [15:0] down_vect;
logic [0:15] up_vect;

down_vect[lsb_base_expr +: width_expr]
up_vect  [msb_base_expr +: width_expr]
down_vect[msb_base_expr -: width_expr]
up_vect  [lsb_base_expr -: width_expr]
","That particular syntax is called an indexed part select.  It's very useful when you need to select a fixed number of bits from a variable offset within a multi-bit register.

Here's an example of the syntax:

reg [31:0] dword;
reg [7:0] byte0;
reg [7:0] byte1;
reg [7:0] byte2;
reg [7:0] byte3;

assign byte0 = dword[0 +: 8];    // Same as dword[7:0]
assign byte1 = dword[8 +: 8];    // Same as dword[15:8]
assign byte2 = dword[16 +: 8];   // Same as dword[23:16]
assign byte3 = dword[24 +: 8];   // Same as dword[31:24]


The biggest advantage with this syntax is that you can use a variable for the index.  Normal part selects in Verilog require constants.  So attempting the above with something like dword[i+7:i] is not allowed.

So if you want to select a particular byte using a variable select, you can use the indexed part select. 

Example using variable:

reg [31:0] dword;
reg [7:0] byte; 
reg [1:0] i;

// This is illegal due to the variable i, even though the width is always 8 bits
assign byte = dword[(i*8)+7 : i*8];  // ** Not allowed!

// Use the indexed part select 
assign byte = dword[i*8 +: 8];
",,,,,
VHDL - How should I create a clock in a testbench?,"How should I create a clock in a testbench? I already have found one answer, however others on stack overflow have suggested that there are alternative or better ways of achieving this:

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY test_tb IS 
END test_tb;

ARCHITECTURE behavior OF test_tb IS

    COMPONENT test
        PORT(clk : IN std_logic;)
    END COMPONENT;

   signal clk : std_logic := '0';
   constant clk_period : time := 1 ns;

BEGIN

   uut: test PORT MAP (clk =&gt; clk);       

   -- Clock process definitions( clock with 50% duty cycle is generated here.
   clk_process :process
   begin
        clk &lt;= '0';
        wait for clk_period/2;  --for 0.5 ns signal is '0'.
        clk &lt;= '1';
        wait for clk_period/2;  --for next 0.5 ns signal is '1'.
   end process;

END;


(source here)","My favoured technique:
signal clk : std_logic := '0'; -- make sure you initialise!
...
clk &lt;= not clk after half_period;

I usually extend this with a finished signal to allow me to stop the clock:
clk &lt;= not clk after half_period when finished /= '1' else '0';

If you use a std_logic item for your finished signal can be driven from all the items in your test environment:
signal finished : std_logic;

....
stimulus_process:process
begin
   finished &lt;= '0';
   drive_various_signals_sync_with_clk;
   finished &lt;= '1';
end process;

monitor_process:process
begin
   finished &lt;= '0';
   check_all_signals_until_all_tests_complete;
   finished &lt;= '1';
end process;


Gotcha alert:
Care needs to be taken if you calculate half_period from another constant by dividing by 2.  The simulator has a &quot;time resolution&quot; setting, which often defaults to nanoseconds... In which case, 5 ns / 2 comes out to be 2 ns so you end up with a period of 4ns! Set the simulator to picoseconds and all will be well (until you need fractions of a picosecond to represent your clock time anyway!)",,,,,
How to design a 64 x 64 bit array multiplier in Verilog?,"I know how to design a 4x4 array multiplier , but if I follow the same logic , the coding becomes tedious.


4 x 4 - 16 partial products
64 x 64 - 4096 partial products.


Along with 8 full adders and 4 half adders, How many full adders and half adders do I need for 64 x 64 bit. How do I reduce the number of Partial products? Is there any simple way to solve this ?","Whenever tediously coding a repetitive pattern you should use a generate statement instead:

module array_multiplier(a, b, y);

parameter width = 8;
input [width-1:0] a, b;
output [width-1:0] y;

wire [width*width-1:0] partials;

genvar i;
assign partials[width-1 : 0] = a[0] ? b : 0;
generate for (i = 1; i &lt; width; i = i+1) begin:gen
    assign partials[width*(i+1)-1 : width*i] = (a[i] ? b &lt;&lt; i : 0) +
                                   partials[width*i-1 : width*(i-1)];
end endgenerate

assign y = partials[width*width-1 : width*(width-1)];

endmodule


I've verified this module using the following test-bench:
http://svn.clifford.at/handicraft/2013/array_multiplier/array_multiplier_tb.v

EDIT:

As @Debian has asked for a pipelined version - here it is. This time using a for loop in an always-region for the array part.

module array_multiplier_pipeline(clk, a, b, y);

parameter width = 8;

input clk;
input [width-1:0] a, b;
output [width-1:0] y;

reg [width-1:0] a_pipeline [0:width-2];
reg [width-1:0] b_pipeline [0:width-2];
reg [width-1:0] partials [0:width-1];
integer i;

always @(posedge clk) begin
    a_pipeline[0] &lt;= a;
    b_pipeline[0] &lt;= b;
    for (i = 1; i &lt; width-1; i = i+1) begin
        a_pipeline[i] &lt;= a_pipeline[i-1];
        b_pipeline[i] &lt;= b_pipeline[i-1];
    end

    partials[0] &lt;= a[0] ? b : 0;
    for (i = 1; i &lt; width; i = i+1)
        partials[i] &lt;= (a_pipeline[i-1][i] ? b_pipeline[i-1] &lt;&lt; i : 0) +
                partials[i-1];
end

assign y = partials[width-1];

endmodule


Note that with many synthesis tools it's also possible to just add (width) register stages after the non-pipelined adder and let the tools register balancing pass do the pipelining.",,,,,
How do I compile and run a VHDL program on Mac with ghdl?,"i just wrote a simple VHDL program. I saved the file as a .vhd file. Then I compiled it with 

ghdl -a test.vhd


and then built and executable file with 

ghdl -e test


And finally tried to run it with 

ghdl -r test


What happened is that I now have a work-obj93.cf file that is visible and two other files, namely .. and . that are somehow invisible.

Can someone tell how exactly I can test a vhdl program on my Mac? Maybe in in combination with GTKWave.","That as they say is a big ask!

There's a version of ghdl for OS X running on Intel processors for versions 10.5, 10.6,10.7 and 10.8 available from  ghdl.free.fr (can be downloaded at  GHDL for Mac OS X).  It's the mcode version (like on Windows), which means it doesn't produce object codes or a standalone executable of a VHDL model with the consequence you can't bind foreign objects (subprograms) to the model.  

The elaborated model only exists in memory at run time and the -e elaborate command is superfluous other than an entry in the working library .cf file. In an mcode version of ghdl the -r run command also elaborates.  All you are going to see is the work-obj93.cf file for the working directory and any .cf files for pre-analyzed libraries, by default these will show up in /usr/local/ghdl/libraries, the executable ghdl found in /usr/local/bin links to /usr/local/ghdl/translate/ghdldrv/ghdl_mcode, and /usr/local/ghdl is a stripped down tree resulting from the compilation of the ghdl_mcode version.

This version is derived from svn129 (following the ghdl-0.29 release), and contains an i386 binary.

The documentation for ghdl is found in /usr/local/ghdl/doc/, there's the ghdl man page which is linked elsewhere, ghdl.html and ghdl.texi which are the ghdl manual and not linked elsewhere.  In ghdl.html you could search for every occurrence of 'Windows' to find reference to the mcode version. As an oversight I didn't think to amend the ghdl manual to include the word mcode wherever Windows appeared and release modified manual.

Where ever 'Windows' appears it should be read as 'Windows or other mcode version'. 

In the ghdl manual see 1.3 What is GHDL?, (The Windows(TM) version of GHDL is not based on GCC but on an internal code generator).  Also 2.1 The hello world program:

2.1 The hello world program


To illustrate the large purpose of VHDL, here is a commented VHDL ""Hello world"" program.

 --  Hello world program.
 use std.textio.all; --  Imports the standard textio package.

 --  Defines a design entity, without any ports.
 entity hello_world is
 end hello_world;

 architecture behaviour of hello_world is
 begin
    process
       variable l : line;
    begin
       write (l, String'(""Hello world!""));
       writeline (output, l);
       wait;
    end process;
 end behaviour;


Suppose this program is contained in the file hello.vhdl. First, you have to compile the file; this is called analysis of a design file in VHDL terms.

 $ ghdl -a hello.vhdl


This command creates or updates a file work-obj93.cf, which describes the library â€˜workâ€? On GNU/Linux, this command generates a file hello.o, which is the object file corresponding to your VHDL program. The object file is not created on Windows.

Then, you have to build an executable file.

 $ ghdl -e hello_world


The â€?eâ€?option means elaborate. With this option, GHDL creates code in order to elaborate a design, with the â€˜helloâ€?entity at the top of the hierarchy.

On GNU/Linux, the result is an executable program called hello which can be run:

 $ ghdl -r hello_world


or directly:

 $ ./hello_world


On Windows, no file is created. The simulation is launched using this command:

 &gt; ghdl -r hello_world


The result of the simulation appears on the screen:

 Hello world!


Saving the source code for the hello_world command to the file hello.vhdl and executing the commands:

david_koontz@Macbook: ghdl -a hello.vhdl

david_koontz@Macbook: ghdl -e hello_world

david_koontz@Macbook: ghdl -r hello_world

Yields:

Hello world!

on standard output (the TTY session in your terminal window).  

You'll end up with a work-obj93.cf library configuration file in the current working directory and no other output files.  You'll also want to understand the implications of the -r run command (section 3.1.3), with no optional secondary unit passed on the command line VHDL defaults to the last compiled architecture.

Obtaining Tony Bybell's  gtkwave  gtkwave.app, the documentation is found in /Applications/gtkwave.app/Contents/Resources/doc, both a source .odt file and a PDF file. (You can select an application in the Applications folder and 'Show Package Contents' to navigate to the doc directory).

There's a waveform format unique to ghdl called ghw, which can be invoked with the run command option '--wave=.ghw'.  See ghdl manual 4.1 Simulation options.  Also see the vcd options in that directory should you choose to use VCD instead.

You should also limit the run time duration with a guard timer should your test bench provide a free running clock.  VHDL will only stop executing when either ther are no more scheduled signal updates or execution time maxes out.  This is a run command option along the lines of '--stop-time=587200ns'.

The OS X gtkwave.app is sensitive to two file types with extensions .ghw and .gtkw, the first the ghdl waveform dump file, the second gtkwave's configuration file with an OS X suffix allowing invocation of gtkwave by clicking on the gtkw file.  The configuration file has to be saved after setting up your wave form display in gtkwave before it exists.  See the gtkwave manual. A ghw file can be clicked on and gtkwave has a set of rules used to search for the applicable gtkw file.

There are a couple of advantages to using the ghw file format.  The automatic invocation of the gtkwave app by clicking on files is one.  Another is that ghdl saves all signal transactions to it's ghw dump file.  You can always select more in gtkwave to display more information.  While this can be a disadvantage in large models the ghw format allows any type or subtype enumeration literal display.  

Joining the GHDL discuss list and posting a question is a good way to attract ghdl expertise attention. (And yes the certificate for gna.org is expired or otherwise invalid).  Tony Bybell provides an email contact on the gtkwave web page but exigencies of paid employment limit his availability.



Elaborating the use of ghdl and gtkwave with an example.

The original poster asked for some real examples with command line values.  There's a  however poor GHDL/GTKWave Tutorial (PDF, 234 KB) that contains an example and used VCD.

I'll list the command lines for a GHDL Waveform format version:

david_koontz@Macbook: ghdl -a CarryRipple.vhd

david_koontz@Macbook: ghdl -a CarryRipple_tb.vhd

david_koontz@Macbook: ghdl -e carryRipple_tb

david_koontz@Macbook: ghdl -r carryRipple_tb --wave=carryRipple_tb.ghw

invoking gtkwave.app can either be done by clicking on the resulting carryRipple_tb.ghw or by using OS X's open command:

david_koontz@Macbook: open -a gtkwave carryRipple_tb.ghw

Gtkwave's SST window (upper left) will display top, expand by clicking the + box.  Do the same for the revealed carryripple_tb.  Click a.  In the signals window select a[3:0] and hit the insert button. Repeat for b.  

In the SST window select U0 and then in the signals window select cin hit the insert button then the same for cout.

In the SST window select s, and in the signals window select s[3:0] and hit insert.

And yes getting the source for the two VHDL files from the 'tutorial' was painful.  I didn't do it.

You might also note the assignment of 'X' to Cin at 60 ns in the gtkwave display, I did it to show the last values assigned in the testbench.

I wouldn't claim it's a good tutorial, but you're getting what you paid for here.  Doing better would have been a bigger ask.  

The test bench (carryRipple_tb.vhd) provides stimulous to drive the model (CarryRipple.vhd) during simulation.  The model quits executing after the last signal event so no stop time need be passed to the run command ( e.g. --stop-time=587200ns).

There's also a five part GHDL/GTKWave Tutorial on Youtube by Chad Kersey.  The resolution isn't so good and it's Linux centric.  Part 0 is about installing the two tools.  The only real difference in my example is using the ghw waveform format.  Most browsers will allow you to see the gtkwave window shot below at full size.



added

There's a recent answer showing a demonstration with a Toggle Flip Flop, showing an error in the original VHDL code, and three possible fixes. It uses configuration declarations to run the various fixed versions.  See how to avoid delay in the output of simple process statement in VHDL.",,,,,
Can custom types be used in port declaration?,"I am preparing for an exam by going through some old ones. One of the questions is:

Write the synthesizable behavioral VHDL code that implements the synchronous FSM in fig...
The FSM has one input, called request, that is of enumeration type with values (r1, r2, r3)...

That makes me want to write this code:

entity fsm is
  port ( clk     : in  std_logic;
         request : in  my_enum_type
  );
end fsm;


And somewhere have a:

type my_enum_type is (r1, r2, r3);


somewhere (I have tried right befor the port declaration and right after the architecture declaration).

But I can't seem to get that to work.
Can I have custom types as inputs or outputs like that?","Yes you can, and I regard it as best practice - it means least work, best understanding, easiest maintenance, and cleanest design.

The trick is to declare the types common to your whole design in a package (I usually call it ""Common"" :-) and add use work.Common.all before the entity declaration AND in every customer of that entity. More specialised components can have appropriate names, of course!

For example:

package Common is    -- untested...

   type my_enum_type is (r1, r2, r3);

   -- (optional) useful tools
   function to_slv (e : my_enum_type) return std_logic_vector;
   function to_enum (s : std_logic_vector(my_enum'length downto 0)) 
                    return my_enum_type;

end Common;

package body Common is
   -- subprogram bodies here
end Common;


Now when you add a value to the enumeration, you ONLY modify ""Common"" and rebuild the design, while those who follow conventional guidelines are still trying to identify every port and signal where they have to increase the range of their ""std_logic_vector"" by 1.

Works really well for bus interfaces too, where a record in each direction hides all the individual bus and handshaking signals.

You WILL have to fight brain-dead tools like Xilinx ""automatic testbench generator"" which will helpfully translate ALL your port types - integer or boolean as well as custom - into std_logic(_vector) and then fail to compile. Just translate them back again.

You can still make a case that at the very top level, all the external FPGA pins should still be std_logic based. And if you ever need to simulate a post-synthesis version of your design, then you will either need to live with std_logic_vector ports, or add a simple wrapper to convert from one form to the other.",,,,,
Dealing with arrays in HDL,"How does one use arrays (representing busses) in HDL?

For example, I have the following code:

/**
 * 16-bit bitwise And:
 * for i = 0..15: out[i] = (a[i] and b[i])
 */

CHIP And16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    // Put your code here:
}


Assuming I have And already implemented, how could I implement this?

I'd rather not have the following:

And(a=a[0],b=b[0],out=out[0]);
And(a=a[1],b=b[1],out=out[1]);
...
And(a=a[14],b=b[14],out=out[14]);
And(a=a[15],b=b[15],out=out[15]);
","There are no arrays in HDL. In section 1.3 of the nand2tetris companion book, he says


  Since we already know how to implement the elementary versions of these gates, the implementation of their n-ary versions is simply a matter of constructing arrays of n elementary gates, having each gate operate separately on its bits. This implementation task is rather boring, but it will carry its weight when these multi-bit gates are used in more complex chips, as described in subsequent chapters.


So besides writing a trivial script in Python to avoid all that typing, you're not missing anything.",,,,,
Im trying to make a right/left shifter using verilog but my output is xxxxx,"module MyProject(A,B,k,right,F);
  input [31:0]A;
  input [31:0]B;
  input [4:0]k;
  input right;
  output reg [31:0]F;
  reg [31:0]F1;
  integer i,j;
  initial
  begin
  assign F1=(A&amp;~B)+(~A&amp;B);
  for(j=0;j&lt;k;j=j+1)
    begin
      if(right==1)
        begin
          for(i=0;i&lt;32;i=i+1)
          begin
            F1[i]=F1[i+1];
            if(i==31)
            F1[i]=0;
          end
        end
      else if(right==0)
        begin
          for(i=31;i&gt;-1;i=i-1)
          begin
            F1[i]=F1[i-1];
            if(i==0)
              F1[i]=0;
          end
        end
    end
    for(i=0;i&lt;32;i=i+1)
      F[i]=F1[i];
    //F=F1;
  end

endmodule
","Your code got a little jumbled in the question - here's the original question with the Enter Code Here lines replaced with new lines:

module MyProject(A,B,k,right,F);
input [31:0]A;    
input [31:0]B;    
input [4:0]k;    
input right;    
output reg [31:0]F;    
reg [31:0]F1;    
integer i,j;    
initial    
   begin    
   assign F1=(A&amp;~B)+(~A&amp;B);    
   for(j=0;j    
   begin    
   if(right==1)    
     begin    
        for(i=0;i&lt;32;i=i+1)    
           begin    
              F1[i]=F1[i+1];      
              if(i==31)    
              F1[i]=0;    
          end    
    end    
     else if(right==0)    
        begin    
         for(i=31;i&gt;-1;i=i-1)    
           begin    
              F1[i]=F1[i-1];    
             if(i==0)    
                F1[i]=0;    
           end    
      end    
   end    
  for(i=0;i&lt;32;i=i+1)    
     F[i]=F1[i];    
  //F=F1;    
 end    
endmodule    


I am guessing the objective is to perform a logical operation on the inputs A and B, and then generate a shifted output.  I think you are close, but there a few things that should be corrected:


The function just has an initial block, so it gets run once when the simulator starts up, and it never runs again.  You didn't mention if the assignment was to create a function that continuously generates output F (i.e. a bunch of gates with no registers) or a function that evaluates ""A/B/k/right"" on a clock edge, and then generates the output.  If you are creating a combinatorial function, when you would need to replace the ""initial"" with something like ""always @*"" which will re-run the function every time an input value changes, and you will also need to change the reg's to wires.  If you are creating a registered block, you will need to add a clock.  You might look at this code for a good example of a clocked shift register.
There is an assign statement inside the initial block.  Assign statements represent expressions that are always true in Verilog, so they go outside of procedural blocks.  The assign statement assigns a value to a register - assign statements should be paired with wires.
The procedural code uses the F1 register as the input and output, but F1 has already been assigned a value.  I would suggest breaking this up into two steps, mainly compute (A&amp;~B)+(~A&amp;B) and assign that to F1.  Then write a procedural block to perform the shifting of F1 into the output, which could be a wire or register depending on the answer to #1


Hope that helps.",,,,,
What is the benefit of automatic variables?,"I'm looking for benefits of ""automatic"" in Systemverilog.
I have been seeing the ""automatic"" factorial example. But I can't get though them. Does anyone know why we use ""automatic""?","Traditionally, Verilog has been used for modelling hardware at RTL and at Gate level abstractions. Since both RTL and Gate level abstraction are static/fixed (non-dynamic), Verilog supported only static variables. So for example, any reg or wire in Verilog would be instantiated/mapped at the beginning of simulation and would remain mapped in the simulation memory till the end of simulation. As a result, you can take dump of any wire/reg as a waveform, and the reg/wire would have a value from the beginning till the end, since it is always mapped. In a programmers perspective, such variables are termed static. In C/C++ world, to declare such a variable, you will have to use storage class specifier static. In Verilog every variable is implicitly static.

Note that until the advent of SystemVerilog, Verilog supported only static variables. Even though Verilog also supported some constructs for modelling at behavioural abstraction, the support was limited by absence of automatic storage class.

automatic (called auto in software world) storage class variables are mapped on the stack. When a function is called, all the local (non-static) variables declared in the function are mapped to individual locations in the stack. Since such variables exist only on the stack, they cease to exist as soon as the execution of the function is complete and the stack correspondingly shrinks.

Amongst other advantages, one possibility that this storage class enables is recursive functions. In Verilog world, a function can not be re-entrant. Recursive (or re-entrant) functions do not serve any useful purpose in a world where automatic storage class is not available. To understand this, you can imagine a re-entrant function as a function which dynamically makes multiple recursive instantiations of itself. Each instance gets its automatic variables mapped on the stack. As we progress into the recursion, the stack grows and each function gets to make its computations using its own set of variables. When the function calls return the computed values are collated and a final result made available. With only static variables, each function call will store the variable values at the same common locations thus erasing any benefit of having multiple calls (instantiations).

Coming to the factorial algorithm, it is relatively easy to conceptualize factorial as a recursive algorithm. In maths we write factorial(n) = n(factial(n-1))*. So you need to calculate factorial(n-1) in order to know factorial(n). Note that recursion can not be completed without a terminating case, which in case of factorial is n=1.

function automatic int factorial;
   input int n;
   if (n &gt; 1)
     factorial = factorial (n - 1) * n;
   else
     factorial = 1;
endfunction


Without automatic storage class, since all variables in a function would be mapped to a fixed location, when we call factorial(n-1) from inside factorial(n), the recursive call would overwrite any variable inside the caller context. In the factorial function as defined in the above code snippet, if we do not specify the storage class as automatic, both n and the result factorial would be overwritten by the recursive call to factorial(n-1). As a result the variable n would consecutively be overwritten as n-1, n-2, n-3 and so on till we reach the terminating condition of n = 1. The terminating recursive call to factorial would have a value of 1 assigned to n and when the recursion unwinds, factorial(n-1) * n would evaluate to 1 in each stage.

With automatic storage class, each recursive function call would have its own place in the memory (actually on the stack) to store variable n. As a result consecutive calls to factorial will not overwrite variable n of the caller. As a result when the recursion unwinds, we shall have the right value for factorial(n) as n*(n-1)(n-2) .. *1.

Note that it is possible to define factorial using iteration as well. And that can be done without use of automatic storage class. But in many cases, recursion makes it possible for the user to code algorithms in a more intuitive fashion.",,,,,
What SystemVerilog features should be avoided in synthesis?,"SystemVerilog introduced some very useful constructs to improve coding style.  However, as one of my coworkers always says, ""You are not writing software, you are describing hardware.""  With that in mind, what features of the language should be avoided when the end result needs to be synthesized?  This paper shows what features are currently synthesizable by the Synopsys tools, but to be safe I think one should only use the features that are synthesizable by all of the major vendors.  Also, what constructs will produce strange results in the netlist which will be difficult to follow in an ECO?

In summary: I like compact and easy to maintain code, but not if it causes issues in the back end.  What should I avoid?

Edit: In response to the close vote I want to try to make this a bit more specific.  This question was inspired by this answer.  I am a big fan of using the 'sugar' as Dave calls it to reduce the code complexity, but not if some synthesis tools are going to mangle signal names and make the result difficult to deal with.  I am looking for more examples like this.","Theoretically, if you can write software that is synthesized into machine code to run on a piece of hardware, that software can be synthesized into hardware. And conversely, there are hardware constructs in Verilog-1995 that are not considered synthesizable simply because none of the major vendors ever got around to supporting it (e.g. assign/deassign). We still have people using //synopsis translate on/off because it took so long for them to support `ifdef SYNOPSYS.

Most of what I consider to be safe for synthesis in SystemVerilog is what I call syntactic sugar for Verilog. This is just more convenient ways of writing the same Verilog code with a lot less typing.  Examples would be:


data types: typedef, struct, enum, int, byte
use of those types as ports, arguments and function return values
assignment operators: ++ -- +=
type casting and bit-streaming 
packages
interfaces
port connection shortcuts
defaults for function/tasks/macro arguments, and port connections


Most of the constructs that fall into this category are taken from C and don't really change how the code gets synthesized. It's just more convenient to define and reference signals.

The place it gets difficult to synthesize is where there is dynamically allocated storage. This would be class objects, queues, dynamic arrays, and strings. as well as dynamically created processes with fork/join.

I think some people have a misconception about SystemVerilog thinking it is only for Verification when in fact the first version of the standard was the synthesizable subset, and Intel was one of the first users of it as a language for Design.",,,,,
Best way to access the uvm_config_db from the testbench?,"I want to create a clock in my top level testbench whose period can be controlled from the test.  What I did was set the period into the uvm_config_db and get it back in the testbench.  I had to put in a #1 to make sure that the build phase was finished, otherwise the get returned the wrong value:

module testbench_top;
  int clk_period;

  bit clk = 0;

  initial begin
    #1;    
    void'(uvm_config_db #(int) ::get(null, ""uvm_test_top.env"", ""clk_period"", clk_period));
    // Create clk
    forever begin
      #(clk_period/2) clk = !clk;
    end
  end


I am annoyed by the #1.  Is there a better way to check that the config has been set?  Can I somehow block until start_of_simulation_phase?","I found it buried in the class reference: You can access the global singleton versions of each phase with &lt;phase name&gt;_ph.  Then I can use the wait_for_state function to block until the start of the start of simulation phase.  Simulated and it seems to work:

module testbench_top;
  int clk_period;

  bit clk = 0;

  initial begin
    start_of_simulation_ph.wait_for_state(UVM_PHASE_STARTED);    
    if(!uvm_config_db #(int) ::get(null, ""uvm_test_top.env"", ""clk_period"", clk_period))
      `uvm_fatal(""CONFIG"", ""clk_period not set"");
    // Create clk
    forever begin
      #(clk_period/2) clk = !clk;
    end
  end
",,,,,
Time stamp in VHDL,is there any function in VHDL which is used to get current simulation time at which a process is running? May be same like the function in systemC sc_time_stamp(),"Yes there is.  Use the keyword now.  

You can print the simulation time using VHDL Attributes:

report ""current time = "" &amp; time'image(now);


You can also store the current time to a variable:

variable v_TIME : time := 0 ns;
v_TIME := now;
-- STUFF HAPPENS
v_TIME := now - V_TIME; --used to find delta time
",,,,,
"Meaning of ""**"" in Verilog?","Can someone tell me what's the meaning of ** in Verilog.
For an example, what is result of 2**i, if i=3 is genvar in generate block?","** in Verilog is an arithmetic operator: 2**i means 2 to the power of i.
When i=3, this equals 8.",,,,,
How to set all the bits to be 0 in a two-dimensional array in Verilog?,"I've built a 8*2bits array to represent a piece of memory in Verilog

reg [1:0] m [0:7]


There is a reset signal for this memory and if reset is 1, all the bits in this memory should be reset to 0. But I don't know how to set all the bits of m in a concise way, because if there are hundreds thousands of bits in the memory, the following way is obviously unfeasible.

always@(posedge clk or posedge reset)
begin
  if (reset) 
    begin
      m[0]&lt;=2'b00;
      m[1]&lt;=2'b00;
      m[2]&lt;=2'b00;
      m[3]&lt;=2'b00;        
      m[4]&lt;=2'b00;
      m[5]&lt;=2'b00;
      m[6]&lt;=2'b00;
      m[7]&lt;=2'b00;
    end
  else
    ....
end
","Use a for loop:

  integer i;
  always@(posedge clk or posedge reset)
  begin
    if (reset) 
      begin
        for (i=0; i&lt;8; i=i+1) m[i] &lt;= 2'b00;
      end
    else
      ....
  end


This is described in the IEEE Std 1800-2012 (Section 12.7.1 The for-loop, for example).",,,,,
Verilog: How to instantiate a module,"If I have a Verilog module 'top' and a verilog module 'subcomponent' how do I instantiate subcomponent in top?

top:

module top(
   input        clk,
   input        rst_n,
   input        enable,
   input  [9:0] data_rx_1,
   input  [9:0] data_rx_2,
   output [9:0] data_tx_2
);


subcomponent:

module subcomponent(
   input        clk,
   input        rst_n,
   input  [9:0] data_rx,
   output [9:0] data_tx
);


Note
This was written as a generic question that keeps cropping up now and again, it is following the self-answer format. Addition answers and updates are encouraged.","This is all generally covered by Section 23.3.2 of SystemVerilog IEEE Std 1800-2012.

The simplest way is to instantiate in the main section of top, creating a named instance and wiring the ports up in order:

module top(
   input        clk,
   input        rst_n,
   input        enable,
   input  [9:0] data_rx_1,
   input  [9:0] data_rx_2,
   output [9:0] data_tx_2
);

subcomponent subcomponent_instance_name (
  clk, rst_n, data_rx_1, data_tx ); 

endmodule


This is described in Section 23.3.2.1 of SystemVerilog IEEE Std 1800-2012.

This has a few draw backs especially regarding the port order of the subcomponent code. simple refactoring here can break connectivity or change behaviour. for example if some one else fixs a bug and reorders the ports for some reason, switching the clk and reset order. There will be no connectivity issue from your compiler but will not work as intended.

module subcomponent(
  input        rst_n,       
  input        clk,
  ...


It is therefore recommended to connect using named ports, this also helps tracing connectivity of wires in the code.

module top(
   input        clk,
   input        rst_n,
   input        enable,
   input  [9:0] data_rx_1,
   input  [9:0] data_rx_2,
   output [9:0] data_tx_2
);

subcomponent subcomponent_instance_name (
  .clk(clk), .rst_n(rst_n), .data_rx(data_rx_1), .data_tx(data_tx) ); 

endmodule


This is described in Section 23.3.2.2 of SystemVerilog IEEE Std 1800-2012.

Giving each port its own line and indenting correctly adds to the readability and code quality. 

subcomponent subcomponent_instance_name (
  .clk      ( clk       ), // input
  .rst_n    ( rst_n     ), // input
  .data_rx  ( data_rx_1 ), // input  [9:0]
  .data_tx  ( data_tx   )  // output [9:0]
);


So far all the connections that have been made have reused inputs and output to the sub module and no connectivity wires have been created. What happens if we are to take outputs from one component to another:

clk_gen( 
  .clk      ( clk_sub   ), // output
  .en       ( enable    )  // input

subcomponent subcomponent_instance_name (
  .clk      ( clk_sub   ), // input
  .rst_n    ( rst_n     ), // input 
  .data_rx  ( data_rx_1 ), // input  [9:0]
  .data_tx  ( data_tx   )  // output [9:0]
);


This nominally works as a wire for clk_sub is automatically created, there is a danger to relying on this. it will only ever create a 1 bit wire by default. An example where this is a problem would be for the data:

Note that the instance name for the second component has been changed

subcomponent subcomponent_instance_name (
  .clk      ( clk_sub   ), // input
  .rst_n    ( rst_n     ), // input 
  .data_rx  ( data_rx_1 ), // input  [9:0]
  .data_tx  ( data_temp )  // output [9:0]
);
subcomponent subcomponent_instance_name2 (
  .clk      ( clk_sub   ), // input
  .rst_n    ( rst_n     ), // input 
  .data_rx  ( data_temp ), // input  [9:0]
  .data_tx  ( data_tx   )  // output [9:0]
);


The issue with the above code is that data_temp is only 1 bit wide, there would be a compile warning about port width mismatch. The connectivity wire needs to be created and a width specified. I would recommend that all connectivity wires be explicitly written out.

wire [9:0] data_temp
subcomponent subcomponent_instance_name (
  .clk      ( clk_sub   ), // input
  .rst_n    ( rst_n     ), // input 
  .data_rx  ( data_rx_1 ), // input  [9:0]
  .data_tx  ( data_temp )  // output [9:0]
);
subcomponent subcomponent_instance_name2 (
  .clk      ( clk_sub   ), // input
  .rst_n    ( rst_n     ), // input 
  .data_rx  ( data_temp ), // input  [9:0]
  .data_tx  ( data_tx   )  // output [9:0]
);


Moving to SystemVerilog there are a few tricks available that save typing a handful of characters. I believe that they hinder the code readability and can make it harder to find bugs.

Use .port with no brackets to connect to a wire/reg of the same name. This can look neat especially with lots of clk and resets but at some levels you may generate different clocks or resets or you actually do not want to connect to the signal of the same name but a modified one and this can lead to wiring bugs that are not obvious to the eye. 

module top(
   input        clk,
   input        rst_n,
   input        enable,
   input  [9:0] data_rx_1,
   input  [9:0] data_rx_2,
   output [9:0] data_tx_2
);

subcomponent subcomponent_instance_name (
  .clk,                    // input **Auto connect**
  .rst_n,                  // input **Auto connect**
  .data_rx  ( data_rx_1 ), // input  [9:0]
  .data_tx  ( data_tx   )  // output [9:0]
);

endmodule


This is described in Section 23.3.2.3 of SystemVerilog IEEE Std 1800-2012.

Another trick that I think is even worse than the one above is .* which connects unmentioned ports to signals of the same wire. I consider this to be quite dangerous in production code. It is not obvious when new ports have been added and are missing or that they might accidentally get connected if the new port name had a counter part in the instancing level, they get auto connected and no warning would be generated.

subcomponent subcomponent_instance_name (
  .*,                      // **Auto connect**
  .data_rx  ( data_rx_1 ), // input  [9:0]
  .data_tx  ( data_tx   )  // output [9:0]
);


This is described in Section 23.3.2.4 of SystemVerilog IEEE Std 1800-2012.",,,,,
What is the difference between = and <= in Verilog?,"What is the difference between = and &lt;= in this code?  Also, how do I print the value of data?

    module always_example();
reg clk,reset,enable,q_in,data;

always @ (posedge clk)
if (reset)  begin
   data &lt;= 0;
end else if (enable) begin   
   data &lt;= q_in;
end
// if i put     $print(""data=%d"", data);   there is error
endmodule
","&lt;= is a nonblocking assignment.  It is used to describe sequential logic, like in your code example.  Refer to IEEE Std 1800-2012, section 10.4.2 ""Nonblocking procedural assignments"".

= is for blocking assignments.  It is used to describe combinational logic.

See also Nonblocking Assignments in Verilog Synthesis, Coding Styles That Kill!

You can use $display instead of $print to print the value of variables.  See also IEEE Std 1800-2012, section 21.2 ""Display system tasks"".",,,,,
Is it written in VHDL or Verilog,"I am new to HDL and just wanted to confirm whether these lines of code are written in VHDL or Verilog?

DE0_SOPC DE0_SOPC_inst(
                        // 1) global signals:
                         .clk(CLOCK_50),
                         .pll_cpu(),
                         .pll_sdram(DRAM_CLK),
                         .reset_n(system_reset_n));
","Yes. These are verilog code lines. As per your previous comments, Type: .v files belong to verilog codes.",,,,,
How do I read an environment variable in Verilog/System Verilog?,"How do I read an environment variable in Verilog ? (Running on a VCS simulator)

I am trying to accomplish

File=$fopen(""$PATH/FileName"",""r"");


$PATH is an environment variable.","You can simply use SystemVerilog DPI for getting environment.
And because getenv is a standard C library for every POSIX platform, so you do not need to implement your own getenv() equivalent function for the function definition again.

Example code in SV.

import ""DPI-C"" function string getenv(input string env_name);

module top;

  initial begin
    $write(""env = %s\n"", {getenv(""HOME""), ""/FileName""});
  end
endmodule


Running

ncverilog -sv dpi.v


or

vcs -sverilog dpi.v


It will show

env = /home/user/FileName


And one more issue in your original question, PATH is a environment for executable search path and concatenate with "":"" character. I think it should be an example here, not really ""PATH"" environment. Otherwise, your fopen file name could be ""/bin:/usr/bin:/usr/local/bin/FileName"", which is wrong.",,,,,
VHDL: creating a very slow clock pulse based on a very fast clock,"(I'd post this in EE but it seems there are far more VHDL questions here...)

Background: I'm using the Xilinx Spartan-6LX9 FPGA with the Xilinx ISE 14.4 (webpack).

I stumbled upon the dreaded ""PhysDesignRules:372 - Gated clock"" warning today, and I see there's a LOT of discussion out there concerning that in general. The consensus seems to be to use one of the DCMs on the FPGA to do clock division but... my DCM doesn't appear to be capable of going from 32 MHz to 4.096 KHz (per the wizard it bottoms out at 5MHz based on 32MHz... and it seems absurd to try to chain multiple DCMs for this low-frequency purpose).

My current design uses clk_in to count up to a specified value (15265), resets that value to zero and toggles the clk_out bit (so I end up with a duty cycle of 50%, FWIW). It does the job, and I can easily use the rising edge of clk_out to drive the next stage of my design. It seems to work just fine, but... gated clock (even though it isn't in the range where clock skew would IMHO be very relevant). (Note: All clock tests are done using the rising_edge() function in processes sensitive to the given clock.)

So, my questions:


If we're talking about deriving a relatively slow clk_out from a much faster clk_in, is gating still considered bad? Or is this sort of ""count to x and send a pulse"" thing pretty typical for FPGAs to generate a ""clock"" in the KHz range and instead some other unnecessary side-effect may be triggering this warning instead?
Is there a better way to create a low KHz-range clock from a MHz-range master clock, keeping in mind that using multiple DCMs appears to be overkill here (if it's possible at all given the very low output frequency)? I realize the 50% duty cycle may be superfluous but assuming one clock in and not using the on-board DCMs how else would one perform major clock division with an FPGA?


Edit: Given the following (where CLK_MASTER is the 32 MHz input clock and CLK_SLOW is the desired slow-rate clock, and LOCAL_CLK_SLOW was a way to store the state of the clock for the whole duty-cycle thing), I learned that this configuration causes the warning:

architecture arch of clock is
    constant CLK_MASTER_FREQ: natural := 32000000; -- time := 31.25 ns
    constant CLK_SLOW_FREQ: natural := 2048;
    constant MAX_COUNT: natural := CLK_MASTER_FREQ/CLK_SLOW_FREQ;
    shared variable counter: natural := 0;
    signal LOCAL_CLK_SLOW: STD_LOGIC := '0';
begin
    clock_proc: process(CLK_MASTER)
    begin
        if rising_edge(CLK_MASTER) then
            counter := counter + 1;
            if (counter &gt;= MAX_COUNT) then
                counter := 0;
                LOCAL_CLK_SLOW &lt;= not LOCAL_CLK_SLOW;
                CLK_SLOW &lt;= LOCAL_CLK_SLOW;
            end if;
        end if;
    end process;
end arch;


Whereas this configuration does NOT cause the warning:

architecture arch of clock is
    constant CLK_MASTER_FREQ: natural := 32000000; -- time := 31.25 ns
    constant CLK_SLOW_FREQ: natural := 2048;
    constant MAX_COUNT: natural := CLK_MASTER_FREQ/CLK_SLOW_FREQ;
    shared variable counter: natural := 0;
begin
    clock_proc: process(CLK_MASTER)
    begin
        if rising_edge(CLK_MASTER) then
            counter := counter + 1;
            if (counter &gt;= MAX_COUNT) then
                counter := 0;
                CLK_SLOW &lt;= '1';
            else
                CLK_SLOW &lt;= '0';
            end if;
        end if;
    end process;
end arch;


So, in this case it was all for lack of an else (like I said, the 50% duty cycle was originally interesting but wasn't a requirement in the end, and the toggle of the ""local"" clock bit seemed quite clever at the time...) I was mostly on the right track it appears.

What's not clear to me at this point is why using a counter (which stores lots of bits) isn't causing warnings, but a stored-and-toggled output bit does cause warnings. Thoughts?","If you just need a clock to drive another part of your logic in the FPGA, the easy answer is to use a clock enable.
That is, run your slow logic on the same (fast) clock as everything else, but use a slow enable for it. Example:
signal clk_enable_200kHz  : std_logic;
signal clk_enable_counter : std_logic_vector(9 downto 0);

--Create the clock enable:
process(clk_200MHz)
begin
  if(rising_edge(clk_200MHz)) then
    clk_enable_counter &lt;= clk_enable_counter + 1;
    if(clk_enable_counter = 0) then
      clk_enable_200kHz &lt;= '1';
    else
      clk_enable_200kHz &lt;= '0';
    end if;
  end if;
end process;


--Slow process:
process(clk_200MHz)
begin
  if(rising_edge(clk_200MHz)) then
    if(reset = '1') then
      --Do reset
    elsif(clk_enable_200kHz = '1') then
      --Do stuff
    end if;
  end if;
end process;

The 200kHz is approximate though, but the above can be extended to basically any clock enable frequency you need. Also, it should be supported directly by the FPGA hardware in most FPGAs (it is in Xilinx parts at least).
Gated clocks are almost always a bad idea, as people often forget that they are creating new clock-domains, and thus do not take the necessary precautions when interfacing signals between these. It also uses more clock-lines inside the FPGA, so you might quickly use up all your available lines if you have a lot of gated clocks.
Clock enables have none of these drawbacks. Everything runs in the same clock domain (although at different speeds), so you can easily use the same signals without any synchronizers or similar.",,,,,
How to launch Xilinx ISE Web Pack under Ubuntu?,I've downloaded and successfully installed Xilinx ISE Web Pack 14.4 on Ubuntu 12.10 although I'm unable to launch it.,"Well: it's UNIX, so there are multiple ways to do it.

One of them is this


Some preparations (needed only once)

$ cd .../14.4/ISE_DS
$ chmod u+x *.csh *.sh

Execute the correct settings script you can find in the root of the installation

$ /path_to_the_installation_dir/14.4/ISE_DS/settings64.sh


For a none cshell system with 64 bits.
Run a Xilinx tool

$ /path_to_the_installation_dir/14.4/ISE_DS/ISE/bin/lin64/ise
$ /path_to_the_installation_dir/14.4/ISE_DS/ISE/bin/lin64/coregen
$ /path_to_the_installation_dir/14.4/ISE_DS/EDK/bin/lin64/xps
$ /path_to_the_installation_dir/14.4/ISE_DS/EDK/bin/lin64/xsdk



If you want a better system I advise you to take a look at the TCL version of the Modules tool.  

How to setup your Unix environment to point to the correct licenses can be found in installation document of Xilinx.",,,,,
What does always block @(*) means?,"If I write the following code:
module POLY(CLK,RESET_n,IN_VALID,IN,OUT_VALID,OUT);

input         CLK,RESET_n,IN_VALID;
input  [ 3:0] IN;
output        OUT_VALID;
output [12:0] OUT;

and then use it:
always @(*)
begin
.........
end


Does it mean that the input CLK,RESET_n,IN_VALID;input  [ 3:0] IN; will trigger the always block or only the input that has used in the block will trigger the always block?

But it doesn't write posedge or negedge, so the two both edge will trigger the always block or not?

","The (*) means ""build the sensitivity list for me"". 

For example, if you had a statement a = b + c; then you'd want a to change every time either b or c changes. In other words, a is ""sensitive"" to b &amp; c. So to set this up:

always @( b or c ) begin
    a = b + c;
end


But imagine you had a large always block that was sensitive to loads of signals. Writing the sensitivity list would take ages. In fact, if you accidentally leave a signal out, the behaviour might change too! So (*) is a shorthand to solve these problems.",,,,,
How to create a string from a pre-processor macro,"I have a preprocessor macro that represents a hierarchical path into my design.

Example:

`define HPATH top.chip.block


I need to construct a string which holds the value of `HPATH, so in my example the string should equal top.chip.block.

Is there a way to construct such a string? 

None of the following attempts worked:

string hpath;
hpath = ""`HPATH"";     // Results in hpath = ""`HPATH""
hpath = \""``HPATH\"";  // Doesn't compile
hpath = `HPATH;       // Doesn't compile


I want hpath to be equivalent to doing this assignment hpath = ""top.chip.block"", but by using `HPATH instead of specifying the path again.

I cannot use %m because I need the string within my top-level UVM environment, not within a module.

A little more background: the reason I want to do this is because I am using backdoor register access in the UVM class library. The backdoor API requires setting the hdl_path to the blocks within the design, as a string. I already have `defines for the hierarchical paths and am trying to reuse those when specifying the hdl_paths so I don't have the same path defined twice. My testbench will use both the hierarchical path and the string path.","It's not possible to use a `define macro within a string literal. According to the SystemVerilog LRM:


  Macro substitution and argument substitution shall not occur within string literals.


However a string literal can be constructed by using a macro that takes an argument and including the quotes in the macro by using ``""`.

Again, from the LRM:


  An `"" overrides the usual lexical meaning of "" and indicates that the expansion shall include the quotation
  mark, substitution of actual arguments, and expansions of embedded macros. This allows string literals to be
  constructed from macro arguments.


So this works:

`define STRINGIFY(x) `""x`""
`define HPATH top.chip.block
string hpath = `STRINGIFY(`HPATH);
$display(hpath);                       // Output: ""top.chip.block""


The example code can be run here: http://www.edaplayground.com/s/4/879",,,,,
Simple algorithms that can be implemented on a FPGA,"I am new to FPGA programming and was planning on implementing several algorithms that may become useful in future to me when I am doing my projects. So, I wanted to ask for suggestions on things I could implement on FPGA (specially some interesting algorithms) ordered in difficulty level. Thank you!","Some of the suggestions in the comment are really awesome. But you said you are beginner that's why I would suggest 
that 


  implement a 64 bit ALU with addition,subtraction, multiplication or
  division. The last two seems easy but they have pretty decent
  algorithm in terms of computers. 




For easy implementation you can first go for 4/8 bit ALU..then extend it to 64 bit one. It takes some time to grasp the whole idea. Give it a try of you want.

After that you can obviously go for CRC-generator, then Reed Solomon encoder , Random number generator and MPEG4 video encoder like user3386109 said.",,,,,
Mips instruction single cycle datapath,"module mult4_to_1_32(out,i0,i1,i2,i3,s0);
output [31:0] out;
input [31:0]i0,i1,i2,i3;
input [1:0]s0;
always @(s0)
begin
  case(s0)
    2'b00: out=i0;      
    2'b01: out=i1;  
    2'b10: out=i2;
    2'b11: out=i3;  
    default: out=i0;    
    endcase
end
endmodule


I want to build 4 to 1 multiplexer in modelsim.

Why do I get this error?


  Compile Error:Illegal reference to net ""out"".
","out needs to be a reg type to be assigned in an always block.


IEEE Std 1364-1995 and above

output [31:0] out;
reg [31:0] out;

IEEE Std 1364-2001 and above (recommenced)

output reg [31:0] out;



Other problem, i0 through 3 are in in the sensitivity list of your always block. This infers complex latching logic.


IEEE Std 1364-1995 and above

always @(s0 or i0 or i1 or i2 or i3)

IEEE Std 1364-2001 and above (recommenced)

always @* // or @(*)

",,,,,
How to generate schematic file from verilog source in Xilinx,"What I'm doing
I started playing around with Xilinx ISE Design Suite and wrote simple Arithmetical Logic Units in verilog. Using verilog Unit Under Tests to create input and output signals for ISim, I verified, that the code works just as I want it.
I would like to generate schematic file from the verilog source.
Under tools menu, there is a schematic viewer

, but I can not figure out, why:

it only lists first source file
and how to save generated file in project

Question:
How to generate schematic file from verilog source in Xilinx?","1) You can double-click on a component to go deeper. In newer versions of ISE that expands the block in-place instead of switching your view to the module clicked.

2) Apparently, there's no saving option. The schematics is generated from HDL code, so there's not much sense in saving it anyway.",,,,,
How to use const in verilog,"Instead of using 

module ... ( .. )  ;

     #15 
endmodule


I want use 

module ... ( ... ) ;
 // GateDelay is a const, like in c language const int GateDelay = 15 ;
 # GateDelay     

endmodule


Or same thing

module ... ( ... ) ;
 // assume Wordsize is defined at "" define Wordsize 15 ""
 reg [ Wordsize -1 : 0 ] mem ;

endmodule


Can I do that wish in verilog ? ","You've a few options :


Macros with `defines
parameters 
localparams


Here's a small example with them all.

`define CONSTANT_MACRO 1          /* important: no ';' here */
module mymodule
    #( parameter WIDTH = 5 )
    ( 
      input wire [WIDTH-1:0] in_a,
      output wire [WIDTH-1:0] out_a
    );

    localparam CONSTANT_LOCAL = 2;

    assign out_a = in_a + `CONSTANT_MACRO - CONSTANT_LOCAL;

endmodule 
",,,,,
When should I use std_logic_vector and when should I use other data types?,"I'm new to VHDL and am having trouble figuring out which data types are appropriate to use where. If I understand correctly, for synthesis, all top level entity ports should be declared either std_logic_vector or std_logic and never any other type.

But std_logic_vector doesn't support arithmetics so how should I handle this?

My intuition tells me that I should simply use std_logic_vector at the top level and then convert this to and from integral data types when passing it to other entities. Is this correct?

And what integral data type (integer, unsigned, signed) should be used where? I understand the difference between signed and unsigned but when should I use integer?","Use the data types that are most appropriate for your modeling purposes, including for ports. It is simply not true that synthesis requires that you should only use std_logic or std_logic_vector for ports. Don't believe those that tell you otherwise.

If you need bit vectors with arithmetic support, consider signed/unsigned from ieee.numeric_std. (In VHDL 2008, there is a standard package that adds arithmetic support to std_logic_vector, but I consider that evil.)

There may only be an issue at the very top-level after synthesis, when you want to simulate the synthesized net list. The port types of that net list may not match your top-level RTL interface. However, you can easily fix that when instantiating the gate level, by doing the proper conversions at that moment. That is the proper time for such low-level concerns - they should not influence your RTL modeling style.",,,,,
What is the difference between == and === in Verilog?,"What is the difference between:

if (dataoutput[7:0] == 8'bx) begin


and

if (dataoutput[7:0] === 8'bx) begin 


After executing dataoutput = 52'bx, the second gives 1, but the first gives 0. Why? (0 or 1 is the comparison result.)","Some data types in Verilog, such as reg, are 4-state.  This means that each bit can be one of 4 values: 0,1,x,z.

With the ""case equality"" operator, ===, x's are compared, and the result is 1.

With ==, the result of the comparison is not 0, as you stated; rather, the result is x, according to the IEEE Std (1800-2009), section 11.4.5 ""Equality operators"":


  For the logical equality and logical
  inequality operators (== and !=), if,
  due to unknown or high-impedance bits
  in the operands, the relation is
  ambiguous, then the result shall be a
  1-bit unknown value (x).
",,,,,
Verilog Always block using (*) symbol,"I have a simple question regarding how to write an always block in a Verilog module.
If I have the following inputs in my Verilog module:   

input        [31:0] PCplus4 ;       // Value of PC + 4
input        [31:0] A;          // Value A, i.e. RSbus (Use Forwarded Value)
input        [31:0] B;          // Value B, i.e. RTbus (Use Forwarded Value)
input        [31:0] IMM;            // Extended Immediate Value
input        [25:0] TARGET;         // Target Address for Jumps
input         [3:0] BR;         // Branch Selector Input


Is there any difference if I use  

always @ (*)  


instead of  

always @ (PCplus4  or A or B or IMM or TARGET or BR)  


Is this always @ (*)   syntax valid for all versions of Verilog?","The always @(*) syntax was added to the IEEE Verilog Std in 2001.  All modern Verilog tools (simulators, synthesis, etc.) support this syntax.

Here is a quote from the LRM (1800-2009):


  An incomplete event_expression list of
  an event control is a common source of
  bugs in register transfer level (RTL)
  simulations. The implicit
  event_expression, @*, is a convenient
  shorthand that eliminates these
  problems by adding all nets and
  variables that are read by the
  statement (which can be a statement
  group) of a procedural_timing_
  control_statement to the
  event_expression.


So, your two lines of code may be equivalent (it depends on the code in the body of your always block).  However, the @* syntax is easier to maintain.",,,,,
What is always followed by #(...) pound mean in Verilog?,"In a simple clock generator example, I see the following code:

always #(cycle/2) clk ~= clk;


I've seen always @(*) before but not pound (#). I tried to find it in the documentation, but all I could find was some reference to ""real-valued ports"" with no further elaboration.","It's a delay operation. It essentially just reads 

always begin
   #(cycle/2) //wait for cycle/2 time
   clk ~= clk;
end


You might sometimes see this used with raw values, like #5 or #10, which means to wait 5 or 10 units of your timescale.",,,,,
What is the difference between structural Verilog and behavioural Verilog?,"As in the title, what are the main differences between structural and behavioural Verilog?","There is no strict definition of these terms, according to the IEEE Std.  However, customarily, structural refers to describing a design using module instances (especially for the lower-level building blocks such as AND gates and flip-flops), whereas behavioral refers to describing a design using always blocks.

Gate netlists are always structural, and RTL code is typically behavioral.  It is common for RTL to have instances of clock gates and synchronizer cells.",,,,,
Use of forever and always statements,"Both the following codes generate a clock. I need to know if there is any use of forever loop other than clock generation? I have only come across forever in clock generation. If it only serves this purpose, isn't it useless?

initial begin
clk = 0;
forever begin
#5 clk = ~clk;
end
end

initial begin
clk = 0 ;
always begin 
# 5 clk = ~clk;
end
end
","Yes, forever loops have widespread usage in testbenches for design verification, particulalry in the industry standard methodology, UVM, and its predecessors (such as VMM).  They are used in verification components such as drivers and monitors which make extensive use of tasks in SystemVerilog classes.",,,,,
Verilog sequence of non blocking assignments,"Say the following code section (same block):

A &lt;= 1
A &lt;= 2


Will variable A always be assigned 2? or will there be a race condition and 1 or 2 will be assigned ?

My understanding of non blocking assignment is that it is up to the hardware to assign the variable A at a future time so it could be a random result. However, this is non intuitive. Simulations show that 2 always get assigned, but I would like to know if this is definitely the case for hardware synthesis.","A would be 2 in simulation, the last defined value takes effect. If they are not in the same block then there could be a race condition depending on the simulator scheduler as to which was defined last in simulation.

I have seen this technique used quite a lot and never seen any unexpected results after synthesis.

From Verilog IEEE 1364-2005 Section 11.4.1 Determinism


  Statements within a begin-end block shall be executed in the order in which they appear in that begin-end block. Execution of statements in a particular begin-end block can be suspended in favor of other processes in the model; however, in no case shall the statements in a begin-end block be executed in any order other than that in which they appear in the source.


This is also in SystemVerilog-IEEE1800 2012 as section 4.6 Determinism

Usage of this might be a FSM which sparsely defines its outputs:

always @(posedge clk) begin
  out_one &lt;= 1'b0;
  out_two &lt;= 1'b0;
  out_thr &lt;= 1'b0;
  case (state)
    2'd1 : out_one &lt;= 1'b1;
    2'd2 : out_two &lt;= 1'b1;
    2'd3 : out_thr &lt;= 1'b1;
  endcase
end
",,,,,
VHDL Variable Vs. Signal,"I have been reading a text (Don't have it in front so can't give the title) about VHDL programming. One problem I've been having a hard time understanding from the text is when to use a variable vs a signal. I think I have a clear understanding of when to use a signal (internal signal that is) but not so much for a variable.

I did notice that the text generally declares and initializes signals before defining a process whereas a variable is declared (and I guess never initialized..) inside of a process.

Anyway to clear that up, either by definition or by example would be great!","Variables are used when you want to create serialized code, unlike the normal parallel code. (Serialized means that the commands are executed in their order, one after the other instead of together). A variable can exist only inside a process, and the assignment of values is not parallel. For example, consider the following code:

signal a,b : std_logic_vector(0 to 4);

process (CLK)
    begin
        if (rising_edge(clk)) then
            a &lt;= '11111';
            b &lt;= a;
        end if;
end process;


will put into b the value of a before the process ran, and not '11111'. On the other hand, the code:

signal a,b : std_logic_vector(0 to 4);

process (CLK)
    variable var : std_logic_vector(0 to 4);
    begin 
        if (rising_edge(clk)) then
            var := '11111';
            a &lt;= var;
            b &lt;= var;
        end if;
end process;


will put the value '11111' into both a and b.

Frankly, in my experience, most of the time you don't need to use variables, the only place I used it was in a loop where I needed to check if any of a number of signals is 1:

type    BitArray        is array (natural range &lt;&gt;) of std_logic;

--...

entity CAU_FARM is
    port
        (
            --   IN   --
              REQUEST         : in BitArray(0 to (FLOW_num -1));
              --..
        );
end CAU_FARM;
--...

farm_proc: process(CLK_FARM, RESET)
    variable request_was_made_var : std_logic;
    begin
    if RESET = C_INIT then 
       -- ...

    elsif rising_edge(CLK_FARM) then

            -- read state machine --
        case read_state is
            when        st_read_idle =&gt;

                request_was_made_var := '0';
                for i in 0 to (FLOW_num -1) loop
                    if (REQUEST(i) = '1') then
                        request_was_made_var := '1';
                    end if;
                end loop;
                if (request_was_made_var = '1') and (chosen_cau_read_sig /= 8) then
                    read_state &lt;= st_read_stage_1;
                    for i in 0 to (FLOW_num -1) loop
                        if (i = choice_out_sig) then
                            ACKNOWLEDGE(i) &lt;= '1';
                        end if;
                    end loop;
                else
                    read_state &lt;= st_read_idle;
                end if;
            ------------------------
            when        st_read_stage_1 =&gt;
            --...
",,,,,
ADDRESS WIDTH from RAM DEPTH,"I am implementing a configurable DPRAM where RAM DEPTH is the parameter.

How to determine ADDRESS WIDTH from RAM DEPTH?

I know the relation RAM DEPTH = 2 ^ (ADDRESS WIDTH)

i.e ADDRESS WIDTH = log (base 2) RAM DEPTH.

How to implement the log (base 2) function in Verilog?","The $clog2 system task was added to the SystemVerilog extension to Verilog (IEEE Std 1800-2005). This returns an integer which has the value of the ceiling of the log base 2.  The DEPTH need not be a power of 2.  

module tb;

parameter DEPTH = 5;
parameter WIDTH = $clog2(DEPTH);

initial begin
    $display(""d=%0d, w=%0d"", DEPTH, WIDTH);
    #5 $finish;
end

endmodule


Running a simulation will display this:

d=5, w=3


However, I do not know of a synthesis tool which supports $clog2.  If you need to synthesize your code, you can use a function.  This was copied from the IEEE 1364-2001 Std, but there are other versions floating around the web:

function integer clogb2;
    input [31:0] value;
    begin
        value = value - 1;
        for (clogb2 = 0; value &gt; 0; clogb2 = clogb2 + 1) begin
            value = value &gt;&gt; 1;
        end
    end
endfunction


My experience has been that using the function is more trouble than it's worth for synthesizable code. It has caused problems for other tools in the design flow (linters, equivalence checkers, etc.).",,,,,
"Is there a VHDL equivalent to Verilog's @(*), i.e., automatic process sensitivity list",It is easy to update a combinatorial process and forget to update the sensitivity list. In Verilog the @(*) was introduced to say the sensitivity list is what is used in this process. Is there an equivalent in VHDL?,"I found this thread in comp.lang.vhdl. Sounds like VHDL-2008 adds wildcard sensitivity with process(all), but tool support varies.",,,,,
How does signal assignment work in a process?,"I learned that a signal is not changed immediately when encountering an expression, but when the process ends. In this example here:

...
signal x,y,z : bit;
...
process (y)
begin
  x&lt;=y;
  z&lt;=not x;
end process;


The example says this:

If the signal y changes then an event will be scheduled on x to make it the same as y. Also, an event is scheduled on z to make it the opposite of x. The question is, will the value of z be the opposite of y? Of course, the answer is no, because when the second statement is executed, the event on x has not been processed yet, and the event scheduled on z will be the opposite of the value of x before the process begins.

Well, I need to understand some things:


From what I learned, signals values are updated only at the end of the process. Is this correct?
The signal x is updated as the first statement. This does not still change the value of x, this change is put in a queue to be executed after the process ends. So everything after this statement x &lt;= y will not see the change and will see x having its old value. Is this correct?
The second statement is an attempt to change the value of signal z. The same here, z will not change its value but it depends on the value of another process. The change on z will be put in queue to be executed at the end of the process. Is this correct?


What does happen at the end of the process?

Possibility number 1) The value in x is changed so x has its new value. The second signal z is updated, the first signal x was updated and, given that z depends on x, its value is changed basing on the NEW UPDATED value of x. And the example should work fine.

Possibility number 2) The value in x is changed so x has its new value. The second signal z is updated. Given that z was assigned an old value of x, that's the value that z will hold, the old value of x which was updated, but this update is not considered.

Could you please tell me which one is the correct way?","Variables get updated as you assign them. Signals get update in the next delta cycle (at the earliest). 

a := '1'; -- variable
assert a = 1;
b &lt;= '1'; -- signal
computationUsing(b); --reads old value of b
-- new value will be visible after this process ends or some time passes


Jan Decaluwe explains this stuff in more detail here: http://www.sigasi.com/content/vhdls-crown-jewel",,,,,
Does anybody have quantitative data on VHDL versus Verilog use?,"VHDL and Verilog serve the same purpose, but most engineers favor one of both languages. I want to find out who favors which language.

There are dozens of myths and common wisdoms about the separation between Verilog and VHDL. (ASIC / FPGA, Europe / USA, Commercial / Defense, etc.) If you ask around, people will tell you the same thing over and over, but I want to find out if these myths are based on reality. 

So my question: can anybody provide sources of quantitative data that indicate who uses VHDL and who uses Verilog? Again, Iâ€™m looking for numbers, not for gut feelings and general indications.","VHDL and Verilog are both fairly new and fairly specialized languages. Those two characteristics make their qualitative data hard to come by. On the other hand, we can use these characteristics to our advantage. We can attempt to infer the popularity of these languages based on the number of references that are available.

Amazon.com Book Listings By Subject

VHDL        315
Verilog     132


Google Trends: Verilog (red) vs VHDL (blue) - 
Source

By these numbers (and only these numbers) VHDL seems to be more widely-used than Verilog; however, there is no indication on the market share details of each.",,,,,
Using wire or reg with input or output in Verilog,"When you declare something as input or output, how do you know if you have to also declare it as a reg or a wire?","reg and wire specify how the object will be assigned and are therefore only meaningful for outputs.

If you plan to assign your output in sequential code,such as within an always block, declare it as a reg (which really is a misnomer for ""variable"" in Verilog). Otherwise, it should be a wire, which is also the default.",,,,,
Why is Verilog not considered a programming language?,In class the professor said that students shouldn't say that they learned to program in Verilog. He said something like Verilog isn't used to program it's used to design. So how is Verilog different from other programming languages?,"Verilog is a hardware definition language. Programming languages are generally understood to be languages for telling existing hardware what to do, not for reconfiguring said hardware.",,,,,
Instanciate the same device under test twice,"I want to instanciate two DUT (Device under test) in the same verilog testbench and compare their output signals.

Actually the two devices will have the same inputs but diffrent outputs.

Any help please?","you need to create a top module which would encapsulate both, dut and testbench. I guess under the testbench you meant a bfm model for your dut. You will need also to create a testbench module which will provide stimulus and  compare the resulting behavior somehow.

module top();
    // declare all your inputs needed to instantiate both models and tb
    // i.e.
    logic clk, in, out_dut, out_bfm;
    // instantiate your dut
    dut dut(clk, in, out_dut);

    // instantiate your bfm
    bfm bfm(clk, in , out_bfm);

    // instantiate your test bench module
    tb tb(clk, in, out_dut, out_bfm);

endmodule


tb would provide 'in' to both, and get 'outs' from both. you can compare the results in the testbench. 

and yes, you would also have to generate all clocks needed.

Of course this is just a top level schema for what has to be done. You need to consult your coding methodology guide for how to organize it and write test benches and duts. ",,,,,
"Relation between LUTs, logic cell, logic elements, system gates","My question is related to difference and relationship between these terminology:


LUTs
Logic Cell
Logic Elements(LE)
System Gates


I know that a lot depends on FPGA producer, but for example an FPGA vendor that state of one of it's products this: FPGA with 100.000 System Gates equivalent aprox. to 1.5k LE.

How I can relate this statement with equivalent FPGA vendor that use LUTs and Logic Cells?

I ask this question becouse I want to migrate some project from an FPGA that tell me System Gates number and LE to an FPGA that tell me it's LUTs number.","LUT, Logic Cell and Logic Element are all the same to me: the most basic FPGA general logic primitive. Xilinx use LUT, Altera LE, microsemi/lattice possibly something else.

The problem is, they are not the same. In their most recent architecture, Xilinx use 6-input LUT and altera 4-input LUT. They are aggregated in logic blocks which has other features like fast-carry chain, registers and distributed memory.

Converting to system gates is useful, but don't forget it's also a marketing war. A Xilinx FPGA should fit 1.5 times the logic of an Altera FPGA, since it's LUT have 6 instead of 4, right? Well, it largely depends on the design, if the design can't use 6-inputs much, the unused ones are wasted. Same with fast-carry logic, I don't know if they count that in equivalent gate number, but be advised that number is inflated.

System gates is a common measure of ASIC design complexity. The same design on two different foundries should have similar system gates number, as waste is not really an issue for ASIC.

If you're looking for an FPGA. I suggest you choose your vendor, port enough of your design to get an idea of how big a FPGA you need and choose a FPGA with an upgrade path (if you want to market). If it's for a single prototype, just use the biggest FPGA you can afford.",,,,,
"Assigning values in Verilog: difference between assign, <= and =","I have just started learning Verilog and I've seen these three lines from different sources. I am confused about the difference between the three:


c &lt;= a&b;
assign c = ~a;
c = 1'b0;


These lines seem to assign a value to c but what's the difference? Thanks.","1) &lt;=non-blocking and is performed on every positive edge of clock. these are evaluated in parallel so no guarantee of order. An example of this would be a register.

2) assign =continual assignment to wire outside an always statement. value of LHS is updated when RHS changes.

3) =blocking assignment, inside always statements enforces sequential order.",,,,,
Passing parameters to Verilog modules,"I am in the process of writing some Verilog modules for an FPGA design. I looked around the internet to find out how I best parametrize my modules. I see two different methods occurring often. I included an example hereunder of the two different methodologies.
Which of these methods is the best way to parametrize modules? 
What is the difference? 
Is it vendor-dependent (Altera vs Xilinx)? 

The first method:
Module definition:

module busSlave #(parameter DATA_WIDTH = 1) (
  input [DATA_WIDTH-1:0] bus_data,
  input                  bus_wr,
  ...
);
endmodule


Module instantiation:

module top;

  //DATA_WIDTH is 32 in this instance
  busSlave #(.DATA_WIDTH(32)) slave32(
    .bus_data(data_0),
    .bus_wr(wr_0),
    ...
    );

  //DATA_WIDTH is 64 in this instance
  busSlave #(.DATA_WIDTH(64)) slave64(
    .bus_data(data_1),
    .bus_wr(wr_1),
    ...
    );
endmodule


The second method:
Module definition:

module busSlave(
  parameter DATA_WIDTH = 1;
  input [DATA_WIDTH-1:0] bus_data,
  input                  bus_wr,
  ...
);
endmodule


Module instantiation:

module top;

  //DATA_WIDTH is 32 in this instance
  busSlave slave32(
    .bus_data(data_0),
    .bus_wr(wr_0),
    ...
    );
  defparam slave32.DATA_WIDTH = 32;

  //DATA_WIDTH is 64 in this instance
  busSlave slave64(
    .bus_data(data_1),
    .bus_wr(wr_1),
    ...
    );
  defparam slave32.DATA_WIDTH = 64;
endmodule


Thanks in advance

EDIT: a few corrections in the examples","The defparam statement is scheduled for deprecation.  The IEEE Std 1800-2012, Annex C (Deprecation), section ""C.4.1 Defparam statements"" states:


  users are strongly encouraged to migrate their code to use one of the
  alternate methods of parameter redefinition.


Many features of Verilog are vendor-dependent.",,,,,
"Difference between Behavioral, RTL and gate Level","I'm trying to fully understand the differences between the abstraction levels of Verilog, I get what the description of each level says but I still can't get it on the play.

For this case, I will paste some Verilog codes and what I think about them:


The following code is in Behavioral Level.

always  @ (a or b or sel)
  begin
    y = 0;
    if (sel == 0) begin
      y = a;
    end else begin
    y = b;
  end
end

This (just an example) is in Gate Level

module test(clk,  ready, next, Q);
  input clk, enable, next;
  output Q;

  \**SEQGEN** reg_1 (.clear(1'b0), .next_state(next), .clocked_on(clk), .Q(Q), .synch_enable(enable) );

endmodule

I don't know if this code is in RTL or Gate Level ( I expect that the always keyword make this RTL and not Gate Level )

module dff_from_nand();
  wire Q,Q_BAR;
  reg D,CLK;

  nand U1 (X,D,CLK) ;
  nand U2 (Y,X,CLK) ;
  nand U3 (Q,Q_BAR,X);
  nand U4 (Q_BAR,Q,Y);

  // Testbench of above code
  initial begin
    $monitor(""CLK = %b D = %b Q = %b Q_BAR = %b"",CLK, D, Q, Q_BAR);
    CLK = 0;
    D = 0;
    #3  D = 1;
    #3  D = 0;
    #3  $finish;
  end   

  always  #2  CLK = ~CLK;

endmodule



I already know that initial begin and end are not synthesizeable and just used for testing. Now I have 2 questions


Third (and second) code is RTL or Gate-Leve? What would be a good RTL code example? I found this RTL Code Example but is that really RTL? For me it looks like behavioral level.
What means Verilog netlist? Is it the same as gate level or it have a context base definition?


I'm confused because in some websites I don't know if they're saying 'this is a Verilog code that is using logic gates'  or 'this is a Verilog code in gate-level'

I will be very happy if somebody who wants to explain more details about this topic :)","RTL : Register-Transfer-Level, an abstraction hardware functionality written with always blocks and assign statements that are synthesizable (can be translated into gate level). Pure RTL does not instantiate sub-modules. RTL could contain sub-modules to guide the synthesizer. Structural RTL (ofter still called RTL) is a module that contains other RTL modules. Example: FSM (Finite-State-Machine)

always @* begin
  next_state = state;
  if (count&gt;0) next_count = count - 1;
  case (state)
  IDLE :
    if(do_start) begin
      next_state = START;
      next_count = 2;
    end
  START :
    if (do_wait) begin
      next_count = count;
    end
    else if (count==0) begin
      next_state = RUN;
      next_count = count_from_input;
    end
  RUN :
    if (do_stop) begin
      next_state = IDLE;
    end
    if (do_wait) begin
      next_count = count;
    end
    else if (count==0) begin
      next_state = IDLE;
    end
  endcase
end
always @(posedge clk, negedge rst_n) begin
  if (!rst_n) begin
    count &lt;= 0;
    state &lt;= IDLE;
  end
  else begin
    count &lt;= next_count;
    state &lt;= next_state;
  end
end


Behavioral : Mimics the desired functionality of the hardware but not necessarily synthesizable. There is no strict rules as long as the code generates the desired behavior. Guideline is to keep it simple and readable. Behavioral are often used to represent analog block, place holder code (RTL/gates not ready), and testbench code. Example: clock generator, delay cells.

always begin
  if (!clk_en &amp;&amp; clk==1'b1) begin
    wait (clk_en);
  end
  #5 clk = ~clk;
end


The key difference between RTL and Behavioral is the ability to synthesize. It is behavioral if you see # delay, wait statements, while loops, force/release statements, or hierarchical reference. Technically there are some rare excusable exceptions, but that is out of scope if this question. 

Gate-Level (aka Structural) : Logic described by gates and modules only. No always blocks or assign statements. This is a representative of the real gates in the hardware.

Verilog Netlist  is a collection of Verilog modules used in the design. It can be one or many files. It can be a mix of of RTL, Behavioral and Structural. Usually it is mostly Structural, especially for large designs.",,,,,
Way to initialize synthesizable 2D array with constant values in Verilog,"in VHDL, I can easily do this:

constant    cmdbytes       : bytearray(0 to Total) := (x""05"", x""00"", x...};


I want synthesizable constants so that when the FPGA starts, this array has the data I supplied.  These registers are wired to VCC or ground to represent 1 or 0.  I can then use them to generate a waveform.  Also I would like to have 2D byte array which is 3D in verilog world.  ","If you're just using the array to pull out one value at a time, how about using a case statement? Granted, it's a long-winded way of doing it, but you could always write a script to write the RTL for you.

reg [7:0] value;
reg [7:0] i;

always @(posedge clk or negedge rst_n) begin
    if(!rst_n)
        i &lt;= 8'd0;
    else
        i &lt;= i + 1;
end

always @(*) begin
    case(i) 
        8'h00: value = 8'd0;
        8'h01: value = 8'd34;
        ...
    endcase
endcase


Another way is to use an initial statement. As far as I'm aware, FPGA synthesis tools will allow you to set initial values for arrays in the following manner. Again, a script to write this may be the way to go.

reg [0:35][7:0] my_array;

initial begin
    my_array[0] = 8'd45;
    my_array[1] = 8'd26;
    ...
end


And if your FGPA synthesis tools support some SystemVerilog, you'll be able to initialise the array like so:

reg [0:34][7:0] my_array = '{ 8'd90, 8'd34, ... }; // note the '{
",,,,,
"proper use of ""disable fork"" in systemverilog","I've something similar to following pseudo code:

for (lets say 10 iterations)
begin
// Do some configuration changes
    fork
        begin
        ///apply input to design
        end
        begin
        while (1)
        /// at particular point update expected status / values
        end
        begin
        while (1)
        /// read status and verify with expected values
        end
    join_any
end


From code: only application of input can break fork, since other 2 threads are working under while (1) 
 I want to disable all threads between each iteration of for i.e. once stream of input is applied -- disable all spawned threads until next iteration starts (with new configuration)

so I modified above code to

 ....
 join_any
 disable_fork
 end


However this seems to disable for loop as well / or something similar which I don't understand but effect is test is hung up.
Can someone explain me the reason and solution?","""disable fork"" kills not only the processes launched by your fork...join_any, but also any other processes that are descendants of the same process that executes the disable-fork.  If you have launched any other processes (using, for example, fork...join_none) earlier in the life of this process, then those other processes will be killed too.

You can rather easily protect against this by causing your fork...join_any, and its later disable-fork, to run in a new child process of its own.  This limits the effect of your disable-fork so that it can affect only the newly launched processes that you care about, and is guaranteed to have no other unwanted effects.

Do this by enclosing the whole mess in ""fork begin...end join"" like this:

fork begin // isolate the following code as a single child process
  fork  // launch the processes you wish to manage
    apply_input();
    update_status();
    verify_status();
  join_any // kill off the *_status threads when apply_input terminates
  disable fork;
end join // end of child process isolation


This is a well-known issue with fork...join_any and fork...join_none.  It's been discussed recently on Verification Guild forum, and is described in sections #79 and #80 of the Sutherland and Mills book ""Verilog and SystemVerilog Gotchas"".

Putting ""fork begin"" and ""end join"" on single lines is unusual, but I like it as a way to make it very obvious that I'm synchronously forking exactly one child process.  Normally that would be a useless thing to do, but in this situation it's essential.

This idiom is so common, and so easy to get wrong, that you may prefer to encapsulate it in a pair of macros (I don't like this, but...):

`define BEGIN_FIRST_OF fork begin fork
`define END_FIRST_OF join_any disable fork; end join


Now you can write...

`BEGIN_FIRST_OF
    apply_input();
    update_status();
    verify_status();
`END_FIRST_OF


where the names ""...FIRST_OF"" are intended to reflect the similarity to the Specman (e) language construct that does the same thing.",,,,,
Multiple assignments to the same register in an RTL block with Kansas Lava,"I'm having trouble understanding Kansas Lava's behaviour when an RTL block contains  multiple assignments to the same register. Here's version number 1:

foo :: (Clock c) =&gt; Signal clk Bool
foo = runRTL $ do
    r &lt;- newReg True
    r := low    
    return $ var r


This behaves as I expected it:

*Main&gt; takeS 10 foo :: Seq Bool
low | low | low | low | low | low | low | low | low | low | ? .


The generated VHDL is:

architecture str of assignments is
  signal sig_2_o0 : std_logic;
begin
  sig_2_o0 &lt;= '0';
  OUTPUT &lt;= sig_2_o0;
end architecture str;


However, I hoped this other version would also work:

foo = runRTL $ do
    r &lt;- newReg True

    r := low
    r := high
    return $ var r


But it doesn't, and the second assignment isn't taken into account:

*Main&gt; takeS 10 foo :: Seq Bool
low | low | low | low | low | low | low | low | low | low | ? .


The reason I'm confused is because reg and var are defined in terms of a full clock cycle, so it's not like I could do impossible-to-synthesize things like branch based on r and then reassign a new value to it. So why doesn't this second form work?

It's not just a simulation issue either: the generated VHDL for the second version clearly shows that the second assignment is thrown away at generation time:

architecture str of assignments2 is
  signal sig_2_o0 : std_logic;
begin
  sig_2_o0 &lt;= '0';
  OUTPUT &lt;= sig_2_o0;
end architecture str;


So basically, I would have expected the output to be more like

architecture str of assignments2 is
  signal sig_2_o0 : std_logic;
begin
  sig_2_o0 &lt;= '0';
  sig_2_o0 &lt;= '1';
  OUTPUT &lt;= sig_2_o0;
end architecture str;


but I'm not sure what that would/should mean in VHDL.","The problem is that you are using multiple non-blocking statements to assign the signal.

  sig_2_o0 &lt;= '0';
  sig_2_o0 &lt;= '1';


This translates to:

at next event assign '0' to sig_2_o0.
at next event assign '1' to sig_2_o0.


This is different than using blocking assignments:

  sig_2_o0 := '0';
  sig_2_o0 := '1';


Which would translate to:

assign '0' to sig_2_o0.
assign '1' to sig_2_o0.


Blocking assignments

When you use blocking assignments the value is clearly defined. First it will set to '0', then override it with '1'. In this example there should be no effect from the first blocking assignment for either simulation or synthesized hardware. You can think of it as there is 0 delay between the first assignment and the second. This means you have a pulse of 0 width, which is actually nothing. It is equivalent to having just the last assignment, with the first omitted entirely. One caveat is that if you put a delay on the assignments, e.g. ""after 1 ns"" then you will notice the first assignment followed by the second in simulation. In hardware, delays are ignored and so there would be no change from adding delays. In fact, inserting delays in RTL that is intended to be synthesized is strongly discouraged for this reason. It is highly desirable that the hardware matches the simulation, and adding delays can introduce mismatches.

Non-blocking assignments

But when you use non-blocking assignments the simulator has two assignments scheduled for the next time event. Set the signal to '1' and at the same time, set it to '0'. So which scheduled assignment will the signal take? There is no way to know. It may be either value since it is incorrectly assigned. Every lint checker and synthesis tool on the planet should throw an error when encountering multiple non-blocking assignments like this. It may be possible to simulate it, but there is clearly a problem with the RTL.",,,,,
Is the ++ operator in System Verilog blocking or non-blocking?,"Good coding convention says that we should use blocking assignments in a combinational block, and non-blocking assignments in a sequential block.  I want to use the ++ operator in a combinatorial block, but I don't know if it is blocking.  So is this code:

input [3:0] some_bus;
logic [2:0] count_ones;
always_comb begin
  count_ones = '0;
  for(int i=0; i&lt;4; i++) begin
    if(some_bus[i])
      count_ones++;
  end
end


equivalent to this:

input [3:0] some_bus;
logic [2:0] count_ones;
always_comb begin
  count_ones = '0;
  for(int i=0; i&lt;4; i++) begin
    if(some_bus[i])
      count_ones = count_ones + 1;
  end
end


or this:

input [3:0] some_bus;
logic [2:0] count_ones;
always_comb begin
  count_ones = '0;
  for(int i=0; i&lt;4; i++) begin
    if(some_bus[i])
      count_ones &lt;= count_ones + 1;
  end
end


I did look in the 1800-2012 standard but could not figure it out.  An answer that points me to the appropriate section in the standard would be appreciated.","According to section 11.4.2 of IEEE Std 1800-2012, it is blocking.


  SystemVerilog includes the C increment and decrement assignment operators ++i , --i , i++ , and i-- . These do not need parentheses when used in expressions. These increment and decrement assignment operators behave as blocking assignments.
",,,,,
VHDL: Is there a convenient way to assign ascii values to std_logic_vector?,"
In verilog, I can assign a string to a vector like: 

wire [39:0] hello;
assign hello = ""hello""; 

In VHDL, I'm having difficulty finding a method like this:

SIGNAL hello : OUT std_logic_vector (39 DOWNTO 0);
...
hello &lt;= ""hello"";



I've been using:

hello &lt;= X""65_68_6c_6c_6f"";


which is unclear and time consuming for large strings.

I've looked at the textio package and thetxt_util package, but neither seem to be very clear on how to interpret a string and convert it to std_logic.

Is there a simple method of assigning ascii codes to std_logic in VHDL?

Here's a minimal example:

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY test IS
PORT(
   ctrl : IN std_logic;
   stdout : OUT std_logic_vector (39 DOWNTO 0)
);
END ENTITY;

ARCHITECTURE rtl OF test IS
   SIGNAL temp : std_logic_vector (39 DOWNTO 0);
BEGIN
   stdout &lt;= temp;
   PROCESS(ctrl)
   BEGIN
      IF (ctrl = '0') THEN
         temp &lt;= ""hello""; -- X""68_65_6C_6C_6F"";
      ELSE
         temp &lt;= ""world"";
      END IF;
   END PROCESS;

END rtl;
","This one varies little for Morten's answer - it only uses one multiply, it copies the string instead of creating an alias, it uses an additional variable and it returns a standard logic vector with an ascending index range.

From a package called string_utils:

library ieee; 
use ieee.numeric_std.all;
-- ...
    function to_slv(s: string) return std_logic_vector is 
        constant ss: string(1 to s'length) := s; 
        variable answer: std_logic_vector(1 to 8 * s'length); 
        variable p: integer; 
        variable c: integer; 
    begin 
        for i in ss'range loop
            p := 8 * i;
            c := character'pos(ss(i));
            answer(p - 7 to p) := std_logic_vector(to_unsigned(c,8)); 
        end loop; 
        return answer; 
    end function; 


You could add an argument with a default specifying ascending/descending index range for the return value.  You'd only need to provided the argument for the non default. ",,,,,
Assign a single bit from STD_LOGIC_VECTOR to STD_LOGIC,"It seems like I have done this plenty of times, but for some reason today it just doesn't want to work.

I would like to assign the MSB of a 16-bit vector to a single-bit variable.

Din : in  STD_LOGIC_VECTOR (15 downto 0);

...

signal signBit : std_logic;

begin
    signBit &lt;= Din(15 downto 15);


The error given is:

Type of signBit is incompatible with type of Din.


Yes I get it, vectors don't play nice with std_logic, but this is 1-bit, clearly denoted by (15 downto 15)","Din(15 downto 15);


is a std_logic_vector, 1 bit long

Din(15);


is one element of a std_logic_vector, i.e. a std_logic.",,,,,
Width independent functions,"Is it possible to write a function that can detect the input data width automatically? For example, consider the parity function below:


function parity;
  input [31:0] data;
  parity = ^ data;
endfunction


When parity(data) is called, the input data should be limited to 32 bits.

Alternatively, one could write a macro, such as  `PARITY(data) in which the system function $bits can detect the width of data and make the macro width-independent. Is it possible to have the same flexibility for functions?

Edit: I need my code to be synthesizable.","You can create a parameterized function. See section 13.8 in the LRM.  It looks like the function must be declared inside a class like this:

virtual class C #(parameter WIDTH=32);
   static function parity (input [WIDTH-1:0] data);
      parity=^data;
   endfunction
endclass


Then when you call the function parameterized it with the bits task:

assign parity_bit = C#($bits(data))::parity(data);


Working example on EDA Playground.",,,,,
Linux driver DMA transfer to a PCIe card with PC as master,"I am working on a DMA routine to transfer data from PC to a FPGA on a PCIe card. I read DMA-API.txt and LDD3 ch. 15 for details. However, I could not figure out how to do a DMA transfer from PC to a consistent block of iomem on the PCIe card. The dad sample for PCI in LDD3 maps a buffer and then tells the card to do the DMA transfer, but I need the PC to do this. 

What I already found out:


Request bus master

pci_set_master(pdev);

Set the DMA mask

if (dma_set_mask(&amp;(pdev-&gt;dev), DMA_BIT_MASK(32))) {
    dev_err(&amp;pdev-&gt;dev,""No suitable DMA available.\n"");
    goto cleanup;
}

Request a DMA channel

if (request_dma(dmachannel, DRIVER_NAME)) {
    dev_err(&amp;pdev-&gt;dev,""Could not reserve DMA channel %d.\n"", dmachannel);
    goto cleanup;
}

Map a buffer for DMA transfer

dma_handle = pci_map_single(pci_dev, buffer, count, DMA_TO_DEVICE);



Question:

What do I have to do in order to let the PC perform the DMA transfer instead of the card?

Thank your for your help!



First of all thank you for your replies. Maybe I should put my questions more precisely:


In my understanding the PC has to have a DMA controller. How do I access this DMA controller to start a transfer to a memory mapped IO region in the PCIe card?
Our specification demands that the PC's DMA controller initiates the transfer. However, I could only find examples where the device would do the DMA job (DMA_mapping.txt, LDD3 ch.15). Is there a reason, why nobody uses the PC's DMA controller (It still has DMA channels though)? Would it be better to request a specification change for our project?


Thanks for your patience.","Look up DMA_mapping.txt. There's a long section in there that tells you how to set the direction ('DMA direction', line 408).

EDIT

Ok, since you edited your question... your specification is wrong. You could set up the system DMA controller, but it would be pointless, because it's too slow, as I said in the comments. Read this thread.

You must change your FPGA to support bus mastering. I do this for a living - contact me off-thread if you want to sub-contract.",,,,,
Does VHDL have a ternary operator?,"I love the neatness of the ternary operator vs if clauses.

Does this operator exist in vhdl? My search was to the contrary. I also checked the when statement out, but it's not an operator, and I want to be able to use it in processes, too...","No. It was discussed for VHDL-2008, but didn't get in. You've got a couple of options. If your tools support VHDL-2008, conditional assignments are now supported as sequential statements (they were previously just concurrent), so you can write something like:

process(clock)
begin
  if rising_edge(clock) then
    q &lt;= '0' when reset else d; -- ie. much like q &lt;= reset? '0':d;
  end if;
end process;


If you haven't got 2008, just write a function (q &lt;= sel(reset, '0', d)). You have to write it for every type you're interested in, though.",,,,,
ModelSim-Altera error,"I'm using Ubuntu Linux 14.04 LTS with Altera Quartus 15.0 web-edition and I'm having a hard time simulate my design due to licensing errors. I'm designing an LCD_driver for the VEEK-MT's LCD touch screen by terasic with the Cyclone IV EP4CE115 by Altera.

Honestly, I don't have much of experience with simulation software like ModelSim-Altera but I do know how to use .vwf files and simulate with them, I know as well how to use signaltap logic analyzer. After creating the usinversity program .vwf files, I compile the project, I press run functional simulation and I get a window with the following content:



  Determining the location of the ModelSim executable...
  
  Using: /home/bdoronnb/Downloads/Quartus/15.0/ModelSim/modelsim_ase/bin
  
  To specify a ModelSim executable directory, select: Tools -> Options
  -> EDA Tool Options Note: if both ModelSim-Altera and ModelSim executables are available, ModelSim-Altera will be used.
  
  **** Generating the ModelSim Testbench ****
  
  quartus_eda --gen_testbench --check_outputs=on --tool=modelsim_oem
  --format=verilog --write_settings_files=off test5 -c test5 --vector_source=""/path/to/Altera/projects/test/5/test5.vwf""
  --testbench_file=""/path/to/Altera/projects/test/5/simulation/qsim/test5.vwf.vt""
  
  Inconsistency detected by ld.so: dl-close.c: 762: _dl_close: Assertion
  `map->l_init_called' failed! Info:
  *******************************************************************Info: Running Quartus II 64-Bit EDA Netlist Writer    Info: Version 15.0.0
  Build 145 04/22/2015 SJ Web Edition    Info: Copyright (C) 1991-2015
  Altera Corporation. All rights reserved.    Info: Your use of Altera
  Corporation's design tools, logic functions     Info: and other
  software and tools, and its AMPP partner logic     Info: functions,
  and any output files from any of the foregoing     Info: (including
  device programming or simulation files), and any     Info: associated
  documentation or information are expressly subject     Info: to the
  terms and conditions of the Altera Program License     Info:
  Subscription Agreement, the Altera Quartus II License Agreement,
  Info: the Altera MegaCore Function License Agreement, or other
  Info: applicable license agreement, including, without limitation,
  Info: that your use is for the sole purpose of programming logic
  Info: devices manufactured by Altera and sold by Altera or its
  Info: authorized distributors.  Please refer to the applicable
  Info: agreement for further details.    Info: Processing started: Sun
  Aug  9 22:18:46 2015Info: Command: quartus_eda --gen_testbench
  --check_outputs=on --tool=modelsim_oem --format=verilog --write_settings_files=off test5 -c test5 --vector_source=/path/to/Altera/projects/test/5/test5.vwf
  --testbench_file=/path/to/Altera/projects/test/5/simulation/qsim/test5.vwf.vtWarning
  (201007): Can't find port ""h_counter"" in designWarning (201007): Can't
  find port ""h_counter[10]"" in designWarning (201007): Can't find port
  ""h_counter[9]"" in designWarning (201007): Can't find port
  ""h_counter[8]"" in designWarning (201007): Can't find port
  ""h_counter[7]"" in designWarning (201007): Can't find port
  ""h_counter[6]"" in designWarning (201007): Can't find port
  ""h_counter[5]"" in designWarning (201007): Can't find port
  ""h_counter[4]"" in designWarning (201007): Can't find port
  ""h_counter[3]"" in designWarning (201007): Can't find port
  ""h_counter[2]"" in designWarning (201007): Can't find port
  ""h_counter[1]"" in designWarning (201007): Can't find port
  ""h_counter[0]"" in designWarning (201007): Can't find port ""v_counter""
  in designWarning (201007): Can't find port ""v_counter[9]"" in
  designWarning (201007): Can't find port ""v_counter[8]"" in
  designWarning (201007): Can't find port ""v_counter[7]"" in
  designWarning (201007): Can't find port ""v_counter[6]"" in
  designWarning (201007): Can't find port ""v_counter[5]"" in
  designWarning (201007): Can't find port ""v_counter[4]"" in
  designWarning (201007): Can't find port ""v_counter[3]"" in
  designWarning (201007): Can't find port ""v_counter[2]"" in
  designWarning (201007): Can't find port ""v_counter[1]"" in
  designWarning (201007): Can't find port ""v_counter[0]"" in
  designWarning (201007): Can't find port ""HSD_s"" in designWarning
  (201007): Can't find port ""VSD_s"" in designInfo (201000): Generated
  Verilog Test Bench File
  /path/to/Altera/projects/test/5/simulation/qsim/test5.vwf.vt
  for simulationInfo: Quartus II 64-Bit EDA Netlist Writer was
  successful. 0 errors, 25 warnings    Info: Peak virtual memory: 1088
  megabytes    Info: Processing ended: Sun Aug  9 22:18:47 2015    Info:
  Elapsed time: 00:00:01    Info: Total CPU time (on all processors):
  00:00:01 Completed successfully. 
  
  Completed successfully. 
  
  **** Generating the functional simulation netlist ****
  
  quartus_eda --write_settings_files=off --functional=on
  --flatten_buses=off --simulation --tool=modelsim_oem --format=verilog --output_directory=""/path/to/Altera/projects/test/5/simulation/qsim/""
  test5 -c test5
  
  Inconsistency detected by ld.so: dl-close.c: 762: _dl_close: Assertion
  `map->l_init_called' failed! Info:
  *******************************************************************Info: Running Quartus II 64-Bit EDA Netlist Writer    Info: Version 15.0.0
  Build 145 04/22/2015 SJ Web Edition    Info: Copyright (C) 1991-2015
  Altera Corporation. All rights reserved.    Info: Your use of Altera
  Corporation's design tools, logic functions     Info: and other
  software and tools, and its AMPP partner logic     Info: functions,
  and any output files from any of the foregoing     Info: (including
  device programming or simulation files), and any     Info: associated
  documentation or information are expressly subject     Info: to the
  terms and conditions of the Altera Program License     Info:
  Subscription Agreement, the Altera Quartus II License Agreement,
  Info: the Altera MegaCore Function License Agreement, or other
  Info: applicable license agreement, including, without limitation,
  Info: that your use is for the sole purpose of programming logic
  Info: devices manufactured by Altera and sold by Altera or its
  Info: authorized distributors.  Please refer to the applicable
  Info: agreement for further details.    Info: Processing started: Sun
  Aug  9 22:18:53 2015Info: Command: quartus_eda
  --write_settings_files=off --functional=on --flatten_buses=off --simulation=on --tool=modelsim_oem --format=verilog --output_directory=/path/to/Altera/projects/test/5/simulation/qsim/
  test5 -c test5Info (204019): Generated file test5.vo in folder
  ""/path/to/Altera/projects/test/5/simulation/qsim//""
  for EDA simulation toolInfo: Quartus II 64-Bit EDA Netlist Writer was
  successful. 0 errors, 0 warnings    Info: Peak virtual memory: 1093
  megabytes    Info: Processing ended: Sun Aug  9 22:18:55 2015    Info:
  Elapsed time: 00:00:02    Info: Total CPU time (on all processors):
  00:00:01 Completed successfully. 
  
  **** Generating the ModelSim .do script ****
  
  /path/to/Altera/projects/test/5/simulation/qsim/test5.do
  generated.
  
  Completed successfully. 
  
  **** Running the ModelSim simulation ****
  
  /home/bdoronnb/Downloads/Quartus/15.0/ModelSim/modelsim_ase/bin/vsim
  -c -do test5.do
  
  /home/bdoronnb/Downloads/Quartus/15.0/ModelSim/modelsim_ase/bin/../linux/vish:
  error while loading shared libraries: libXft.so.2: cannot open shared
  object file: No such file or directory Error.


Any help is appreciated.","Eureka! I've googled the following text: error while loading shared libraries: libXft.so.2: cannot open shared object file: No such file or directory Error. I've found out (thanks to Qiu as well) that I need to install 32bit packages for my 64bit OS that the ModelSim-Altera software uses. Here are is the proper command to enter to the Ubuntu terminal:

sudo apt-get install libxft2 libxft2:i386 lib32ncurses5

And problem solved!",,,,,
how to take /use serial input in verilog?,"I want to control a servo motor using an 8-bit input to generate a PWM. Here's my problem: I need to take the serial input through a MAX 232 from PC and I don't know how to do it. A sample code would be helpful too...
TNX","You just need to add a UART (a Universal Asynchronous Receiver/Transmitter) to your FPGA design. Connect the TX and RX signals from the UART to the MAX232, convert them to RS-232 voltage levels, and then connect to the PC. You should be able to find sample code on your own, now that you know what to search for.",,,,,
Using parameters to create constant in verilog,"I want to take in a parameter and assign a number of zeroes equal to the paramter to a constant, and use this constant for comparison. how do I do it ? 

For example, say parameter is 3, I want to create a constant 

n=3'b000;


and use this n in another statement. Only thing is, I don't know n. How do i initialize 'n' zeroes and to what verilog data type do I assign it to ?","Your looking for the replication operator. The syntax is {replication_constant{value}}.

An example of creating a bus of size WIDTH to all zeros.

parameter WIDTH = 3;
wire [WIDTH-1:0] n = {WIDTH{1'b0}};


For full description of the replication operator, see IEEE std 1800-2012 &sect; 11.4.12.1 ""Replication operator""",,,,,
efficient integration of FPGA into computer system,"FPGA's are used widely in the industry to gain better performance by implementing programs on the FPGA instead of software.

How do these companies efficiently integrate the FPGA's into their systems?

I have very limited experience with FPGA's and have only used them by hooking them up with USB and serial ports, which I guess isn't the best way to get the most out of your FPGA implementation. 

So what does these companies do?, Do they for example use some special FPGA's that can be inserted into a PCI slot in a computer system, or do they maybe buy some special SoC with integrated FPGA that can easily be overwritten by the programmers?

I have most experience with programming in high level languages very very far away from the hardware, so I'm sorry if the question sounds stupid -I just don't have much knowledge and experience with the lower layers :). But I once had a course in which we used FPGA's and it was a very mind opening experience. So now I'm dreaming of having a computer system where I can code up some parts in a high level language which then does some communication to an integrated FPGA on which I have uploaded some synthesized VHDL.

Maybe one could even code up programs consisting of both high level code and some VHDL which is automatically synthesized and uploaded to the FPGA board when the program is started... That would be so awesome!","FPGA System Integration

How companies integrate an FPGA into a system can vary a lot from one system to the next due to the flexible nature of an FPGA.  No 'special' FPGA is needed because the FPGA is inherently programmable.  A company is free to program into it whatever interface best suits their needs, whether that be a complex bus like PCI or a simple interface like SPI or I2C.  Some additional ICs may be needed external to the FPGA to support the desired interface, but this a meek point. 

The question is sort of like asking how software companies integrate they're software in an operating system.  Does it interfaces with a database?  If so maybe it will use SQL queries.  Does it have online capabilities?  If so, maybe it will access web services.  In any case, it's a very open-ended scenario.

The latest trend, however, is to integrate processors and FPGAs on the same SoC.  In this case an interface named AXI (Advanced eXtensible Interface) is used between the processor and programmable logic.  AXI uses a topology similar to PCIe but specialized for high-performance on-chip communication.

High-Level Programming

This is possible.  It's called high-level synthesis (HLS) and allows the programming of FPGAs from C code.  HLS, however, has it's limitations.  For one thing, it's been around for ten years now and only very recently starting to gain more traction.  But ultimately, systems with FPGAs will tend to use a combination of high-level languages (C/C++) and RTL (Verilog/VHDL).  High-level languages are used to program the processor while RTL is used to program the FPGA.  And now, optionally, C can also be used to program the FPGA through HLS.",,,,,
1 bit stream in verilog,"I have 6 gas sensors which are connected to an Arduino uno board which I use as an ADC. The output of each sensor will be a number between 0 and 1023. The data is transferred from the Arduino to an Altera FPGA for processing. 

I send the binary form of the number to the output pin of Arduino (serial data) and by receiving a 'write' signal from FPGA, this data will transmit serially to an input port of FPGA, at roughly 10kHz (0.1ms period). 

How can the original number be reconstructed in the FPGA after the serial transmission?","To convert Serial to Parallel, you need some way to identify the end or start of sequence. Something like the following should get you off to a start:

input            clk;
input            end_of_sequence;
input            sdata;
output reg [9:0] result;
//10 bit transmission

reg [9:0] pdata;

always @(posedge clk) begin
  // Shift serial data in
  pdata &lt;= {pdata[8:0, sdata};
end

always @(posedge clk) begin
  if (end_of_sequence ) begin
    // at end of shifted data store the full parallel word
    result &lt;= pdata;
  end
end
",,,,,
How to use clock gating in RTL?,"I am clock gating some latch and logic in my design. I don't have much experience in synthesis and place &amp; route. What is the proper way to implement clock gating in RTL? 

Example1:

always_comb begin
    gated_clk  = clk &amp; latch_update_en;
end

always_latch begin
    if(gated_clk) begin
         latch_data &lt;= new_data;
    end
end


Example2:
I stumbled into a RTL examples while doing some research about good practices in RTL clock gating. That example implemented the above code like this:

clock_gator cg_cell (.clk(clk), .en(latch_update_en), .scan_en(scan_en_in), .gated_clk(gated_clk));

always_latch begin
    if(gated_clk) begin
         latch_data &lt;= new_data;
    end
end


What is the purpose of using custom clock gating cell? Does the tool have hard time in synthesis if clk is directly ""and""-ed in a always_comb block with another enable signal? I am having a feeling that using special clock gating cell is a standard approach to generated gated clock signal. I am trying to understand why this is the case. ","What is the proper way to implement clock gating in RTL?

The clock gating signal should only toggle when the latch is closed, otherwise there is a chance for glitches and metastability issues. For an active high latch, the gating signal should toggle on the falling edge of the clock. Rising edge for active low latches.

Normally you would use an edge sensitive flop to hold latch_update_en to prevent noise on the gating signal.

always_ff @(negedge clk)
  latch_update_en &lt;= next_latch_update_en;

always_comb
    gated_clk = (* clock_gating = ""clk"" *) clk &amp; latch_update_en;

always_latch
    if(gated_clk)
         latch_data &lt;= new_data;


Reminder: if you have a latch only deign: edge trigger flops are just master/slave latches

always_latch 
    if (clk)
      sync_latch_update_en &lt;= next_latch_update_en;
always_latch 
    if (!clk)
      latch_update_en &lt;= sync_latch_update_en;


Does the tool have hard time in synthesis if clk is directly ""and""-ed in a always_comb block with another enable signal?

Most synthesis do have have issues with directly AND-ing a clocking. It is not always intuitive how the gating should be used. A synthesizer often has many AND gates in the library to choose from, each one has different slew, skew, and loading that very on input combinations. Though functionally the same, A &amp; B will get different time results then B &amp; A.

Instantiating an explicit cell from the synthesizer's library narrows the possibilities to know and anticipated behavior. A predefined clock gating cell also has attributes used by the synthesizer. Attributes include timing information for balancing the clock tree (buffer placement in the design for managing loads and parasitic).

Some synthesizers support setting attributes tags in RTL (ex: // synthesis attributes or (* attributes *)) instead of needing to explicitly instantiate a cell. There isn't a standard for how this is do so refer to your user manual. 

What is the purpose of using custom clock gating cell?

The custom cell is a per-defined cell in the synthesis library with know timing information, load balancing, and other attributes. With this information, the synthesizer knows where and how to add or calibrate the buffer delay in the clock tree. This making sure the non-gated flop doesn't see the clock edge before gated flop. 

                 _____       _____
IN -------------|D   Q|-----|D   Q|--- OUT
                |     |     |     |
       |\ |\    |     |     |     |
     +-| &gt;| &gt;---|&gt;    |   +-|&gt;    |
     | |/ |/    |_____|   | |_____|
     |  ___               |
CLK -+-|   \              |
       | &amp;  )-------------+   BALANCED CLOCK : correct data sampled
GATE --|___/


Without the guidance, the gated flop's could get a delayed clock. The skew would cause the wrong data to get sampled.

                 _____       _____
IN -------------|D   Q|-----|D   Q|--- OUT
                |     |     |     |
                |     |     |     |
     +----------|&gt;    |   +-|&gt;    |
     |          |_____|   | |_____|
     |  ___               |
CLK -+-|   \    |\ |\     |
       | &amp;  )---| &gt;| &gt;----+   UNBALANCED CLOCK : wrong data sampled
GATE --|___/    |/ |/
",,,,,
What is the difference between reg and wire in a verilog module?,"When are we supposed to use reg and when are we supposed to use wire in a verilog module?
I have also noticed sometimes that a output is declared again as a reg. E.g reg Q in a D flip flop. I have read this somewhere - &quot;The target output of procedural assignment statements must be of reg data type.&quot;
What are procedural assignment statements?
I have thoroughly googled this but was not able to find a clear explanation.","Wire:-
Wires are used for connecting different elements. They can be treated as physical wires. They can be read or assigned. No values get stored in them. They need to be driven by either continuous assign statement or from a port of a module.
Reg:-
Contrary to their name, regs don't necessarily correspond to physical registers. They represent data storage elements in Verilog/SystemVerilog. They retain their value till next value is assigned to them (not through assign statement). They can be synthesized to FF, latch or combinatorial circuit. (They might not be synthesizable !!!)
Wires and Regs are present from Verilog timeframe. SystemVerilog added a new data type called logic to them. So the next question is what is this logic data type and how it is different from our good old wire/reg.
Logic:-
As we have seen, reg data type is bit mis-leading in Verilog. System Verilog's logic data type addition is to remove the above confusion. The idea behind is having a new data type called logic which at least doesn't give an impression that it is hardware synthesizable. Logic data type doesn't permit multiple drivers. It has a last assignment wins behavior in case of multiple assignments (which implies it has no hardware equivalence). Reg/Wire data types give X if multiple drivers try to drive them with different values. Logic data type simply assigns the last assignment value. The next difference between reg/wire and logic is that logic can be both driven by assign block, output of a port and inside a procedural block like this
  logic a;
    assign a = b ^ c;                   // wire style 
    always (c or d) a = c + d;          // reg style
    MyModule module(.out(a), .in(xyz)); // wire style
",,,,,
VHDL multiple std_logic_vector to one large std_logic_vector,"I have four std_logic_vectors (15 downto 0) and want to stack them into a std_logic_vector (63 downt 0) so fare I have found one way of doing it but is it the correct way or is there a more optimal and correct way to do it?

signal slv16_1,slv16_2,slv16_3,slv16_4 : std_logic_vector(15 downto 0);
signal slv64 : std_logic_vector(63 downto 0);

slv64(15 downto 0) &lt;= slv16_1;
slv64(31 downto 16) &lt;= slv16_2;
slv64(47 downto 32) &lt;= slv16_3;
slv64(63 downto 48) &lt;= slv16_4;
","An easy way to accomplish this is to use the concatenation operator &amp;.  It achieves the same thing you did above, but with less code required.  

slv64 &lt;= slv16_4 &amp; slv16_3 &amp; slv16_2 &amp; slv16_1;
",,,,,
code breaks when trying to run any lwip function,"I am trying to run the sample code for tftp server. I get no complaints when synthesizing my hardware or compiling the code. However, when I add the lwip_init() statement, it seems to stop working (it doesn't output any of the print statements). This is very frustrating and I have no idea what is causing it. Any ideas? Thanks

#include &lt;stdio.h&gt;
#include ""xenv_standalone.h""
#include ""xparameters.h""
#include ""platform.h""
#include ""netif/xadapter.h""
#include ""lwip/init.h""

#define EMAC_BASEADDR  XPAR_LLTEMAC_0_BASEADDR 

int main()
{
    print(""-- Starting main() -- \r\n"");

    struct netif *netif, server_netif;
    struct ip_addr ipaddr, netmask, gw;

    /* the mac address of the board. this should be unique per board */
    unsigned char mac_ethernet_address[] = { 0x00, 0x0a, 0x35, 0x00, 0x01, 0x02 };

    netif = &amp;server_netif;

    microblaze_init_icache_range(0, XPAR_MICROBLAZE_0_CACHE_BYTE_SIZE);
    microblaze_init_dcache_range(0, XPAR_MICROBLAZE_0_DCACHE_BYTE_SIZE);

    /* enable caches */
    XCACHE_ENABLE_ICACHE();
    XCACHE_ENABLE_DCACHE();

    platform_setup_interrupts();

    /* initliaze IP addresses to be used */
    IP4_ADDR(&amp;ipaddr,  192, 168,   1, 10);
    IP4_ADDR(&amp;netmask, 255, 255, 255,  0);
    IP4_ADDR(&amp;gw,      192, 168,   1,  1);

    print_app_header();
    print_ip_settings(&amp;ipaddr, &amp;netmask, &amp;gw);

    lwip_init();

    ...
}


EDIT in response to vicky:

maybe you can explain something cause you might be right. When i compile it without lwip_init(), i get:

text data bss dec  hex
7214 356 1104 8674 21e2


and with lwip_init() i get:

text data bss   dec    hex
9726 356 559080 569162 8af4a


which is ALOT bigger. too bad it can't give a warning about this","Presumably (assuming you are doing a clean rebuild) it's linking in lots of new stuff when you start calling LWIP functions, so your image has changed. Has your image overflowed any of its constraints (program size, data size, stack size...)?",,,,,
Assigning wires deep in a nested set of modules,"I have a wire that is about 4 levels deep and I really don't want the hassle of having to propagate it up the hierarchy. Is there any way to assign the wire using some sort of referencing? I know I can access the wire by typing:

cca.cpu0.cca3_cpu.nc1_cp_checkpoint 


but 

assign cca.cpu0.cca3_cpu.nc1_cp_checkpoint = checkpoint;


doesn't work

Anyone know of any way to do it?","Since you have not shown sufficient code for anyone to reproduce your problem, nor have you revealed any details regarding your problem, all we can do is guess.

My guess is that nc1_cp_checkpoint is declared as a reg inside your cca3_cpu instance. You can not assign a value to a reg using a continuous assignment.  Try to use a procedural assignment (inside an initial or always block), for example:

initial begin
    cca.cpu0.cca3_cpu.nc1_cp_checkpoint = checkpoint;
end


If this doesn't solve your problem:


Show more relevant code 
Elaborate on ""doesn't work"".  Show your error message, if any.


Update:  Another potential issue arises if nc1_cp_checkpoint is a continuously-driven wire inside your cca3_cpu instance.  In that case, your second assign might cause contention, which would make the value go unknown (x).  You might be able to avoid that issue using force and release.",,,,,
Single Input to Array of Custom Modules in Verilog,"So I have an array of 4 RAM modules that I want to be able to read/write to based on two different selector signals. Right now I'm instantiating the RAM using intermediary signals:

    genvar i;
    generate
    for (i = 0; i &lt; regnum; i=i+1) begin: regs    
         rfram_generic rf (clk,rst,ce_a_int[i],addr_a_int[i],do_a_int[i],
                               ce_b_int[i],addr_b_int[i],do_b_int[i],
                               ce_w_int[i],we_w_int[i],addr_w_int[i],
                               di_w_int[i]);
    end
    endgenerate


And I want to select the RAM to use using either head or tail signals (2-bit vectors). Any ideas how to do this?","I'm new here and can't comment on questions yet, but in response to Marty: most FPGA synthesis tools will translate internal multisource signals with tristate values into MUX-like logic, where possible.  See, for instance: a description of old tristate-to-logic behaviour that sounds accurate to me.

As a recommendation to Adam, you're probably better off making this explicit in your code by performing the masking yourself rather than using the tristates.  This will improve portability, give you more predictable results, and serve as self-documentation if anybody ever has to revisit your code.

However, making some guesses based on your solution, it would probably make sense to simply mask off the clock enable on the write port and mux the output of the read port.  For instance:

reg [WIDTH-1:0] do_a,do_b;
always @(*) do_a = do_a_int[head];
always @(*) do_b = do_b_int[tail];
generate
   genvar i;
   for (i = 0; i &lt; regnum; i=i+1) begin: regs    
      rfram_generic rf (clk,rst,
                        ce_a,addr_a,do_a_int[i],
                        ce_b,addr_b,do_b_int[i],
                        ce_w,head==i?we_w:1'b0,addr_w,di_w);
   end
endgenerate


This will probably result in less complex logic (i.e., better area and delay) than your solution.",,,,,
SystemVerilog randc reinitialization,"I was wondering if there is a way to reinitialize a randc variable.  I am trying to set several registers, but need to make sure they can be set in arbitrary order.  This object may get re-randomized (there are some other random values in the class), and then the function may get called again.  My code looks something like this:

typedef enum bit[N:0] { REG1, REG2, REG3, REG4, ... } reg_order_e;
local randc reg_order_e reg_order;

function void set_regs();
    repeat( reg_order.num() ) begin
        case( reg_order )
            REG1: set_reg1();
            REG2: set_reg2();
            REG3: set_reg3();
            REG4: set_reg4();
        endcase
        assert(randomize( reg_order ));
    end
endfunction : set_regs


Alternatively, is there a way of calling std::randomize() on a variable to make it a randc? 
Thanks,
-Tim","I found the solution based on some comments on the verification academy forum where I posted the same question.  Basically, to achieve what I want, I need to create a new class with its own random variable

class helper;
     randc reg_order_e reg_order;
endclass : helper

task do_some_work();
    helper helper_inst = new();
    repeat( reg_order_e.num() ) begin
        assert( helper_inst.randomize() );
        case( helper_inst.reg_order )
            REG1: ...
            REG2: ...
        endcase
    end
endtask : do_some_work
",,,,,
Error during Netlist Generation in Simulink,"I was trying to generate a netlist from a simple Model in simulink. I can run the simulation (using  sysgen).

When I try to  create a netlist , it throws an error :


  ""
  * ERROR *
  
  Errors occurred during netlist
  generation. Error using ==>
  xlProcBlockElaborateBMM at 19 synopsis
  file 'C:\&lt;..>\timing\synopsis' not
  found  ""


So, I tried to create a synopsis folder manually, and then It started throwing following error:


  * ERROR *
  
  Errors occurred during netlist
  generation. Java exception occurred: 
  com.xilinx.sysgen.netlist.NetlistInternal:
  java.io.FileNotFoundException:
  C:\Kiran\timing\synopsis\synopsis
  (Access is denied)
      at com.xilinx.sysgen.netlist.XTable.valueOf(Unknown
  Source)
      at com.xilinx.sysgen.netlist.Block.fromXTable(Unknown
  Source)


I tried running Matlab as Administrator, but with same outcome. Kindly let me know if I am missing something here:

So, here are the config details :

Matlab version :  Version 7.10       (R2010a)
Xilinx System Generator                               Version 12.2       

I did not find any solutions in the Xilinx forums, so I am posting it here.

Thanks","Not come across that one - it sounds like a horrible internal error.  

It looks like you're creating a timing netlist - can you create any of the other option netlists?  It might provide different (more useful) error messages!

Other solutions are of the typically tedious form:


Re-run the Xilinx System Generator Configurator
try a different PC
reinstall the Xilinx tools
Log a WebCase


Sorry!",,,,,
how can one compile .vhd under ghdl?,"My first question :  I wonder how you compile your vhdl file under ghdl ?

In c/c++, we use 


-Werror
-Wunused-variable
-Wunused-value
-Wunused-function 
-Wfloat-equal -Wall


.My second question : are there a way one can use ghdl with those things ? ","The user manual for GHDL would be a good starting point, specifically sections 3.1 (building) and 3.4 (warnings).

It is difficult to compare a set of C/C++ compiler flags to that of a VHDL compiler, but there may be some similar functionality between them, such as warnings become errors and alerting the user to unused design components. For example (from the documentation):

--warn-unused
   Emit a warning when a subprogram is never used. 
--warn-error
   When this option is set, warnings are considered as errors.
",,,,,
VCD Dump of only a sub part of the design via modelsim,"I have a big design that includes a test-bench, some testing circuit and the circuit under test itself.
I use modelsim to simulate the design and I want to have a dump of the simulation. I was suggested to generate the dump using the command:

vcd file myvcd1.vcd
vcd add -r /sim_minimips/*


it seams to work but what i would like is to generate the dump only for the circuit under test.

i tried to use the same command in specifying just the name of the file i would like to be taken in consideration:

vcd file myvcd2.vcd
vcd add -r /minimips/*


but the following error was generated:

Error vsim 3561 No object matching minimips


I do not understand the error and i am not sure even if this is the correct procedure to isolate a subpart.

does anyone knows how to do or knows where could i get a decent simply tutorial about this Value Change Dump?

I attach my test bench entity:

library IEEE;
use IEEE.std_logic_1164.all;

library std;
use std.textio.all;

library work;
use work.pack_mips.all;

entity sim_minimips is
end;

architecture bench of sim_minimips is

  component minimips is
  port (
      clock    : in std_logic;
      reset    : in std_logic;

      ram_req  : out std_logic;
      ram_adr  : out bus32;
      ram_r_w  : out std_logic;
      ram_data : inout bus32;
      ram_ack  : in std_logic;

      it_mat   : in std_logic
  );
  end component;


  component ram is
    generic (mem_size : natural := 256;
             latency : time := 10 ns);
    port(
        req        : in std_logic;
        adr        : in bus32;
        data_inout : inout bus32;
        r_w        : in std_logic;
        ready      : out std_logic
  );
  end component;

  component rom is
  generic (mem_size : natural := 256;
           start : natural := 0;
           latency : time := 10 ns);
  port(
          adr : in bus32;
          donnee : out bus32;
          ack : out std_logic;
          load : in std_logic;
          fname : in string
  );
  end component;

  signal clock : std_logic := '0';
  signal reset : std_logic;

  signal it_mat : std_logic := '0';

  -- Connexion with the code memory
  signal load : std_logic;
  signal fichier : string(1 to 7);

  -- Connexion with the Ram
  signal ram_req : std_logic;
  signal ram_adr : bus32;
  signal ram_r_w : std_logic;
  signal ram_data : bus32;
  signal ram_rdy : std_logic;

begin

    U_minimips : minimips port map (
        clock =&gt; clock,
        reset =&gt; reset,
        ram_req =&gt; ram_req,
        ram_adr =&gt; ram_adr,
        ram_r_w =&gt; ram_r_w,
        ram_data =&gt; ram_data,
        ram_ack =&gt; ram_rdy,
        it_mat =&gt; it_mat
    );

    U_ram : ram port map (
        req =&gt; ram_req,
        adr =&gt; ram_adr,
        data_inout =&gt; ram_data,
        r_w =&gt; ram_r_w,
        ready =&gt; ram_rdy
    );

    U_rom : rom port map (
        adr =&gt; ram_adr,
        donnee =&gt; ram_data,
        ack =&gt; ram_rdy,
        load =&gt; load,
        fname =&gt; fichier
    );

    clock &lt;= not clock after 20 ns;
    reset &lt;= '0', '1' after 5 ns, '0' after 70 ns;
    ram_data &lt;= (others =&gt; 'L');

    process
        variable command : line;
        variable nomfichier : string(1 to 3);
    begin
        write (output, ""Enter the filename : "");
        readline(input, command);
        read(command, nomfichier);

        fichier &lt;= nomfichier &amp; "".bin"";

        load &lt;= '1';
        wait;
    end process;

    -- Memory Mapping
    -- 0000 - 00FF      ROM

    process (ram_adr, ram_r_w, ram_data)
    begin -- Emulation of an I/O controller
        ram_data &lt;= (others =&gt; 'Z');

        case ram_adr is
            when X""00001000"" =&gt; -- program an interrupt after 1000ns
                                it_mat &lt;= '1' after 1000 ns;
                                ram_rdy &lt;= '1' after 5 ns;
            when X""00001001"" =&gt; -- clear interrupt line on cpu
                                it_mat &lt;= '0';
                                ram_data &lt;= X""FFFFFFFF"";
                                ram_rdy &lt;= '1' after 5 ns;
            when others      =&gt; ram_rdy &lt;= 'L';
        end case;
    end process;

end bench;


Cheers,
Ste","The last parameter for vcd add is the design hierarchy path (using instance names) of the signal(s) you want to add (the * means all signals, though with the -r signal it also expands to all levels of the design below the hierarchy you've specified).

Thus, if your minimips is instantiated within sim_minimips using the instance name i_minimips, the correct way to add all signals in (that particular) minimips and any blocks it might instantiate is

vcd add -r /sim_minimips/i_minimips/*


If you want to restrict the items to add to the VCD a bit further, you could add one or more of the parameters -in, -inout, -out, -internal or -ports, which select only items of these types. Or leave out the -r to not descend into the hierarchy -- a common usage is vcd add -ports /sim_minimips/minimips/* which will add only the ports of the design top level, suitable for generating stimulus for many types of test benches.

It should be noted that vcd add works ""just"" like wave add, i.e. the object specification is in exactly the same format. Thus, often the simplest way to add items to a VCD is to add them to a wave in the Modelsim UI, copy-pasting the command from the transcript, and simply changing the wave add to a vcd add.

Also, file names are of no consequence here, only the structure of the design itself. For example, if you have something like:

entity sim_minimips is
    port (
        -- ...
    );
end sim_minimips;

entity minimips is
    port (
        -- ...
    );
end minimips;

architecture tb of sim_minimips is
    component minimips
        port (
            -- ...
        );
    end component;
begin
    I_MINIMIPS: minimips
        port map (
            -- ...
        );
end architecture tb;


In this case, the path to your minimips instance is /sim_minimips/I_MINIMIPS/.",,,,,
Integer to Binary Conversion in Simulink,"This might look a repetition to my earlier question. But I think its not. 
I am looking for a technique to convert the signal in the Decimal format to binary format.

I intend to use the Simulink blocks in the Xilinx Library to convert decimal to binary format.

So if the input is 3, the expected output should in 11( 2 Clock Cycles). I am looking for the output to be obtained serially.

Please suggest me how to do it or any pointers in the internet would be helpful.

Thanks","You are correct, what you need is the parallel to serial block from system generator.
It is described in this document:

http://www.xilinx.com/support/documentation/sw_manuals/xilinx13_1/sysgen_ref.pdf

This block is a rate changing block.  Check the mentions of the parallel to serial block in these documents for further descriptions:

http://www.xilinx.com/support/documentation/sw_manuals/xilinx13_1/sysgen_gs.pdf

http://www.xilinx.com/support/documentation/sw_manuals/xilinx13_1/sysgen_user.pdf",,,,,
VHDL: Errors in FlipFlop D code,"I am doing a D flip flop with VHDL
This is the code:

LIBRARY STD,WORK;
USE STD.standard.all;
entity FlipFlopD is 
port(
  input, clock :in bit;
  output :out bit
);
end FlipFlopD;

--Architecture of the entity
Architecture FlipFlopDfunc of FlipFlopD is 
begin 
  PROCESS (clock)
  BEGIN
    IF (clockâ€™EVENT AND clock=â€?â€? THEN 
      output &lt;= input; 
    END IF;
  END PROCESS;
end FlipFlopDfunc;


These are errors I get when I try to synthesize it:

Line 16. Unexpected symbol read: ?.
Line 16. Unexpected symbol read: ?.
Line 16. parse error, unexpected IDENTIFIER, expecting COMMA or CLOSEPAR


The error in line 16 is extrange to me because I donÂ´t see any '?' symbol in this line:

IF (clockâ€™EVENT AND clock=â€?â€? THEN 


Does anyone know how to correct it?
Does anyone know what to do with this error parse error, unexpected IDENTIFIER, expecting COMMA or CLOSEPAR?

By the way, I am doing my design using ISE 9.2
Thank you for your help.","Are you sure you use the correct type of single quote (') signs? If they are like this in your VHDL code I guess they are wrong.

IF (clock'EVENT AND clock='1') THEN
",,,,,
why my shift register show the result in one clock instead of 4?,"this is my code for dff and multiplexer and shift register, which should rich the output in 4 clocks but it does it in one clock and I could not fix it myself.
this is my dff code:
use IEEE.STD_LOGIC_1164.ALL;


entity DFLipFlop is
    Port ( d : in  STD_LOGIC;
           clock : in  STD_LOGIC;
              reset : in STD_LOGIC;
           q : out  STD_LOGIC);
end DFLipFlop;

architecture Behavioral of DFLipFlop is

begin
process(clock,reset)
begin
if(reset ='1')then
q &lt;= '0';
elsif(CLOCK='1' and CLOCK'EVENT)then
q &lt;= d;
end if;
end process;
end Behavioral;


this is my multiplexer code:
-- Company: 
-- Engineer: 
-- 
-- Create Date:    08:37:48 04/27/2022 
-- Design Name: 
-- Module Name:    multiplexer - Behavioral 
-- Project Name: 
-- Target Devices: 
-- Tool versions: 
-- Description: 
--
-- Dependencies: 
--
-- Revision: 
-- Revision 0.01 - File Created
-- Additional Comments: 
--
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity multiplexer is
    Port ( DataIn : in  STD_LOGIC;
           P_in : in  STD_LOGIC;
           Selector : in  STD_LOGIC;
           Output : out  STD_LOGIC);
end multiplexer;

architecture Behavioral of multiplexer is

begin

process(Selector)
begin 
   
    if Selector = '0' then
       Output &lt;= DataIn ;

    else        
        OutPut &lt;= P_in ;
   
    end if;
 end process;


end Behavioral;


this is my shift register code:
-- Company: 
-- Engineer: 
-- 
-- Create Date:    08:35:05 04/27/2022 
-- Design Name: 
-- Module Name:    shiftRegister - Behavioral 
-- Project Name: 
-- Target Devices: 
-- Tool versions: 
-- Description: 
--
-- Dependencies: 
--
-- Revision: 
-- Revision 0.01 - File Created
-- Additional Comments: 
--
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity shiftRegister is
    Port ( DataIn : in  STD_LOGIC;
           Selector : in  STD_LOGIC;
           P_in : in  STD_LOGIC_VECTOR (3 downto 0);
           Clk : in  STD_LOGIC;
           OutPut : out  STD_LOGIC);
end shiftRegister;

architecture structural of shiftRegister is

component DFLipFlop is
    Port ( d : in  STD_LOGIC;
           clock : in  STD_LOGIC;
              reset : in STD_LOGIC;
           q : out  STD_LOGIC);
end component DFLipFlop;

component multiplexer is
    Port ( DataIn : in  STD_LOGIC;
           P_in : in  STD_LOGIC;
           Selector : in  STD_LOGIC;
           Output : out  STD_LOGIC);
end component multiplexer;


signal DFFOutput :  STD_LOGIC_VECTOR(3 downto 0);
signal MuxOutput :  STD_LOGIC_VECTOR(3 downto 0);

begin 

multiplexer0 : multiplexer Port map( DataIn =&gt; DataIn , P_in =&gt; P_in(3) , Selector =&gt; Selector , Output =&gt;  MuxOutput(0) );
dff_interface0 : DFLipFlop port map( d =&gt; MuxOutput(0) , clock =&gt; Clk , reset =&gt; '0' , q =&gt; DFFOutput(0));

multiplexer1 : multiplexer Port map( DataIn =&gt; DFFOutput(0) , P_in =&gt; P_in(2) , Selector =&gt; Selector , Output =&gt;  MuxOutput(1) );
dff_interface1 : DFLipFlop port map( d =&gt; MuxOutput(1) , clock =&gt; Clk  , reset =&gt; '0' , q =&gt; DFFOutput(1));

multiplexer2 : multiplexer Port map( DataIn =&gt; DFFOutput(1) , P_in =&gt; P_in(1) , Selector =&gt; Selector , Output =&gt;  MuxOutput(2) );
dff_interface2 : DFLipFlop port map( d =&gt; MuxOutput(2) , clock =&gt; Clk  , reset =&gt; '0' , q =&gt; DFFOutput(2));

multiplexer3 : multiplexer Port map( DataIn =&gt; DFFOutput(2) , P_in =&gt; P_in(0) , Selector =&gt; Selector , Output =&gt;  MuxOutput(3) );
dff_interface3 : DFLipFlop port map( d =&gt; MuxOutput(3) , clock =&gt; Clk  , reset =&gt; '0' , q =&gt; Output);

end structural;


and this is my test bench:
-- Company: 
-- Engineer:
--
-- Create Date:   09:12:38 04/27/2022
-- Design Name:   
-- Module Name:   C:/Users/ABTIN/Documents/amirkabir un/term 4/Computer Architecture/Lab/HW8/HW8/TestBench.vhd
-- Project Name:  HW8
-- Target Device:  
-- Tool versions:  
-- Description:   
-- 
-- VHDL Test Bench Created by ISE for module: shiftRegister
-- 
-- Dependencies:
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
--
-- Notes: 
-- This testbench has been automatically generated using types std_logic and
-- std_logic_vector for the ports of the unit under test.  Xilinx recommends
-- that these types always be used for the top-level I/O of a design in order
-- to guarantee that the testbench will bind correctly to the post-implementation 
-- simulation model.
--------------------------------------------------------------------------------
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
 
-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--USE ieee.numeric_std.ALL;
 
ENTITY TestBench IS
END TestBench;
 
ARCHITECTURE behavior OF TestBench IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
 
    COMPONENT shiftRegister
    PORT(
         DataIn : IN  std_logic;
         Selector : IN  std_logic;
         P_in : IN  std_logic_vector(3 downto 0);
         Clk : IN  std_logic;
         OutPut : OUT  std_logic
        );
    END COMPONENT;
    

   --Inputs
   signal DataIn : std_logic := '0';
   signal Selector : std_logic := '0';
   signal P_in : std_logic_vector(3 downto 0) := &quot;1011&quot;;
   signal Clk : std_logic := '0';

    --Outputs
   signal OutPut : std_logic;

   -- Clock period definitions
   constant Clk_period : time := 5 ns;
 
BEGIN
 
    -- Instantiate the Unit Under Test (UUT)
   uut: shiftRegister PORT MAP (
          DataIn =&gt; DataIn,
          Selector =&gt; Selector,
          P_in =&gt; P_in,
          Clk =&gt; Clk,
          OutPut =&gt; OutPut
        );

   -- Clock process definitions
   Clk_process :process
   begin
        Clk &lt;= '0';
        wait for Clk_period/2;
        Clk &lt;= '1';
        wait for Clk_period/2;
   end process;
 

   -- Stimulus process
   stim_proc: process
   begin        
      -- hold reset state for 100 ns.


      wait for Clk_period*10;
      DataIn &lt;= '0' ; P_in &lt;= &quot;1011&quot; ; Selector &lt;= '1' ;wait for Clk_period*1;
      DataIn &lt;= '1' ; P_in &lt;= &quot;1001&quot;  ;wait for Clk_period*2;
      
      -- insert stimulus here 

      wait;
   end process;

END;

I can not figure out what the problem is.
please help.","Your data input signal is not propagated across the shift register in a single clock.
When looking at this simulation, you can see it is the upper bit of your preload data that gets loaded at the clock edge where the cursor is placed. The behavior is consistent with the code.
The detailled explanation is:

at the cursor, Selector is 1, which means the multiplexer will select the P_in value
because the DFF gets the P_in value, it loads it at the cursor and the bit 4 of P_in is 1 so DFFOutput becomes 1 too

If you wanted to propagate a 1 across the shift-register, you should first reset it (to set it to zero) and then give it a 1 on the input.
You should use a proper reset at the begin of the testbench. This way your design gets into a known state.
In your testbench, you assign initial values to the signals but use them in sensitivity lists (the main culprit is selector). Because of this, the output of the multiplexers are undefined as the process was not triggered by a change on the signal.
You should change the testbench to look like this:
-- hold reset state for 100 ns.
     wait for Clk_period * 10;
     selector &lt;= '0'; -- this assignment triggers the multiplexer processes
     p_in &lt;= &quot;1011&quot;;

I would also strongly suggest simulating your entire design and exploring the signals inside (I see you use Vivado, it has an integrated simulator; otherwise Intel provides a free Modelsim license if you need it).
If you want to use the Vivado simulator, have a look at UG937.

To get examples of how to implement a particular component in Vivado, you can also look at the Synthesis Guide (UG901). There is an example of the implementation to use for shift registers to make optimal use of the FPGA's resources (other FPGA manufacturers have similar guides, look for  synthesis guide in your favorite search engine).
For Vivado, there are also integrated code examples under Tools &gt; Language templates.",,,,,
VHDL - Vivado - Vivado Simulator retrieve old file instead of the newly generated one,"I am building a vhdl project within vivado 2020.2
My working directory is located at the local Desktop of my O.S. and it has the following structure:
script\
    datasets\
        gentestdata.py
        testdata\
            test_data.txt
src\
  &lt;&lt;source files here&gt;&gt;
tst\
  &lt;&lt;testbenches here&gt;&gt;
vivado\
  &lt;&lt;project directory here&gt;&gt;

I have the following impure function to load the data from a script-generated file test_data.txt :
impure function gen_datain(dataset_path: in string) return datain_type is

file text_header: text is in dataset_path;
variable text_line: line;
variable line_i: bit_vector(0 to neuron_rom_width-1);
variable dataset_content: datain_type;

begin
for i in dataset_content'range loop
    if i = 101 then
        readline(text_header, text_line);
        read(text_line, line_i);
    else
        readline(text_header, text_line);
        read(text_line, line_i);
    end if;
    dataset_content(i) := makesfixed(line_i);
end loop;
file_close(text_header);
return dataset_content;
end function;

The file test_data.txt is generated automatically by the Python script gentestdata.py. Every time I run this script the content of test_data.txt changes and so should the data which is loaded within the vivado environment, but somehow even if the old version of test_data.txt has been replaced by the newer one, the simulator still loads the old data. How can I fix this behaviour. I tried to close vivado and reboot the O.S.
My questions is, do you know the reason of such behavior, and how it can be corrected?
Thanks everyone","When adding files to the GUI project, Vivado allows the user to 'Copy file to project'; say no to the copy.  There is a check box or radio button involved.  Vivado will try to have its own local copy buried somewhere it its hierarchy. Vivado is free to remove and re-add its own folders and if your file is part of this it can become confusing.
You may need to start over with a fresh Gui project in order to have the project in a state where it is not modifying your files.
The ultimate solution is to use Vivado in non-project mode without the GUI.  This works better in a Linux based script driven environment than in Windows.  In non-project Vivado does not mess with your files.
See:
https://docs.xilinx.com/r/en-US/ug892-vivado-design-flows-overview
For more on the trade-offs between project and non-project build work flows.",,,,,
Identifier must be declared with a port mode error in verilog,"//3.v
module and3(x,y,z,w1,s);

input x,y,z;
wire w1;
output s;

assign w1=y&amp;z;
assign s=w1|x;

endmodule

I got error here. &quot;Identifier must be declared with a port mode error:w1&quot;. I searched similar errors but I think I declared it right. Or does my testbench wrong?
`timescale 1ns/1ns
module testbench;
reg x,y,z;
wire w1,s;

and3 and3(x,y,z,w1,s);

initial
begin
#250;x=0;y=0;z=0;
#250;x=0;y=0;z=1;
#250;x=0;y=1;z=0;
#250;x=0;y=1;z=1;
#250;x=1;y=0;z=0;
#250;x=1;y=0;z=1;
#250;x=1;y=1;z=0;
#250;x=1;y=1;z=1;
end

endmodule

How should I correct ?","Its telling you it wants the direction.
Like this:
module and3(x,y,z,w1,s);

input x,y,z;
output s,w1;

assign w1=y&amp;z;
assign s=w1|x;

endmodule

Port defaults are confusing, better to specify and make the design intent clear.  Don't count on the reader of your code knowing all the default rules for type, kind, direction etc.
See
https://www.edaboard.com/threads/default-type-of-a-systemverilog-port.390303/
Particularly the comments by dave_59",,,,,
Multiple assignments to function return value,"In a SystemVerilog function, is it legal to do multiple assignments to the implicitly-declared return variable? See the following function for an example:
  localparam int Q=1,I=0;
  function logic [1:0][Q:I][15:0] Cast24to16(input logic [1:0][Q:I][23:0] din);
    foreach (Cast24to16[n,iq])
      Cast24to16[n][iq] = din[n][iq][23 -: 8];
  endfunction

The language reference manual, IEEE Std 1800-2017, sec 13.4.1 states:

Function return values can be specified in two ways, either by using a return statement or by assigning a value to the internal variable with the same name as the function.

This seems a little unclear as to whether you can assign multiple times, like in my example. Furthermore, the example from the LRM directly after this statement and also all other examples I can find online all show the implicit return value only being assigned once. This makes me feel a bit unsettled.","The LRM also says just before the section you quoted

The function definition shall implicitly declare a variable, internal to the function, with the same name as the function.

I think you can safely assume that if there is no explicit return statement, it effectively inserts an implicit return (var_function_name);
Also, if you declare your function with a static lifetime (which is the implicit default lifetime in a module), that implicit return variable has a static lifetime as well. That means it retains its value from the last time you called the function regardless of whether you assign it or not.
module top;
  
  function int countme;
    countme++;
  endfunction
  
  initial repeat (10) $display(countme());
endmodule
",,,,,
understand Finite state machine in a verilog,"I am using an Artix 7 FPGA and writing my code in Xilinx ISE.
I already have the Verilog code for the project I am working on. Unfortunately, I am not able to understand this module- The full code is posted here.
My goal is to find out where these 6 states are defined in the FSM: Reset (000), Wait for password (010), Compare (100), Log in successful (110), Login failed (111), and Do operation (101) and change the encoding to 4 bits.
I don't understand how the FSM in the image is there in the code.
Is anyone generous enough to help, please? Can I get a description of what is being done here?","The posted code is not Verilog RTL (Register Transfer Level) source code.  Rather, its a post synthesis Verilog netlist.  It contains the vendors primitives, look up tables (LUTS, buffers, etc). There is no way to understand the correlation between the bubble diagram and a post synthesis netlist in code linked to, its machine generated by the FPGA build tool (ISE in this case).
To correlate the bubble diagram and code, locate the corresponding Verilog source code that was used to create the netlist.
You might be able to locate the source code like this:
If you are on Linux, cd to near where the code is located and run

find . -iname '*.*v' | xargs grep 'Compare'

Here is an example of what a Verilog RTL state machine would look like:
https://www.asic-world.com/tidbits/verilog_fsm.html
The state variables and related logic are represented as parameter names (Verilog) or enumerations (in SystemVerilog). The state names are searchable using a text editor.",,,,,
Meaning of |-> 1[0:$] in assertions in system verilog,"usage example
state==ACTIVE1 |-&gt; 1[0:$] ##1 state==ACTIVE2

The problem the assertion trying to solve is
if the state machine reaches state=ACTIVE1, it will eventually reach state=ACTIVE2
Any idea what  |-&gt; 1[0:$] this actually means?
Also, is there a better way to do the same?
Thanks!","In SVA 1 is effectively a wildcard, because it is, by definition, true. So it matches anything.
&lt;expression&gt;[&lt;number or range&gt;] is the SVA repetition operator.
$ means &quot;infinity&quot;.
So, 1[0:$] means &quot;anything zero or more times&quot;.
Is there a better way to do it? Yes. Here are some other ways to do it that suffer all suffer from the same problems that your example does:
state==ACTIVE1 |-&gt; ##[0:$] state==ACTIVE2
state==ACTIVE1 |-&gt; eventually state==ACTIVE2

What are these problems?
(i) If there are lots of ACTIVE1s and no ACTIVE2s then more and more checks will be started (ie threads spawned), which slows down your simulation. This is a problem with the use of $ or eventually on the right hand side (the consequent or condition).
(ii) Your assertion can never fail: it doesn't matter whether there has been no ACTIVE2 by the heat death of the universe, your assertion will not fail. Here is a compromise assertion, a so-called strong property:
state==ACTIVE1 |-&gt; s_eventually state==ACTIVE2

The s_ stands for &quot;strong&quot;. Now, if your assertion has not passed by the end of the simulation, that is considered  a fail.",,,,,
Signed or unsigned result of operation,"Let's consider three cases:
// case 1
reg [63:0] result;
reg [15:0] number1;
reg signed [31:0] number2;

number1 = 0;
number2 = -2147483648;

result = number1 | number2;  // result[63] == 0

// case 2
reg [63:0] result;
reg [15:0] number1;

number1 = 0;

result = number1 | -32'd2147483648;  // result[63] == 1

// case 3
reg [63:0] result;
reg [15:0] number1;

number1 = 0;

result = number1 | $signed(-32'd2147483648);  // result[63] == 0

Why result of case two is signed? Why verilog treat this equation in different way?","in this case the size of the operands are defined by the size of the lhs -- 64 bits. System verilog standard provides rules of calculating bit widths and types of expressions based on the width and types of the operands and lhs. In all cases the width of the '|' is context dependent and must have 64 bits (max width of all operands and lsh). As a result, it expects that all operands are matched the max width.
case 1:
result = number1 | number2;

The resulting expression is simply an 'or' of both 16-bit operands 0-extended to 64. So, bit 63 is 0. Note, there is no negation
case 2:
result = number1 | -32'd2147483648;  
result = number1 | -2147483648; // same as above
result = number1 | -number2; // same result  

The unary 'minus' is also a context-determined operator. What happens here, the '-' operator will extend its operand to 64 bits before negating it. As a result you will nave a 64-bit negative number with bit 63 set to 1.
case 3
result = number1 | $signed(-32'd2147483648); 

Here, the width of the context is not propagated through the  $signed function to its operand, which is 32 bit wide and is self-determined. The type of the context is always unsigned due to the operator '|'. As a result, the rhs is treated as unsigned even though you marked it as signed. So, it is also gets zero-extended to 64 bits and bit 63 is 0.
The difference between 2 and 3 is that negation works on the 64 bit value (in 2), versus 32-bit value (in 3). In both cases this operand is treated as unsigned.
perand to $signed a self-determined width of 32. Its negation makes it a positive number in the 32-bit context. So, after the $signed operator, it is a 32-bit positive number, which get 0-extended to 64 bits.",,,,,
Dual clock FIFO in vivado (verilog),"I want to use a FIFO in a project where a state machine buffers as much data as possible to a FIFO, which will then be processed by a DSP block. To maximize data throughput I want to use multiple QSPI nor flash modules as a ROM with a wide data bus. DSP blocks can perform 1 operation per cycle which means the data input width has to be larger than the output width (because it takes 8 clock cycles to transfer data). For example, I want a FIFO with 32-bit input and 8-bit output, but this is not supported in vivado as far as I can tell. I tried the various FIFO block generators and even tried using the macros but I'm not having much luck.
Please let me know how I can generate a dual clock FIFO with a larger input width than the output width.","Using FIFO Generator IP core in Vivado, choose Independent Clocks Block RAM for FIFO Implementation and then you will be able to set larger data width for write port than the read port.

",,,,,
How does streaming operator unpacking work?,"Consider the following code:
  wire unpacked_wire[3:0];
  wire [3:0] packed_wire;

  assign     unpacked_wire   = packed_wire; // Error: Cannot assign packed type to unpacked type
  assign {&gt;&gt;{unpacked_wire}} = packed_wire; // No errors

My first assignment statement errors out. However, the second one doesn't. However, according to the IEEE Std 1800-2017, sec 11.4.14:

When used in the left-hand side, the streaming operators perform the reverse operation, i.e., unpack a stream of bits into one or more variables.

So isn't the streaming operator on the LHS redundant since its converting an unpacked type... to an unpacked type? So shouldn't this second assignment still be illegal? To me, this code reads like the streaming operator is actually packing the data.","It is unpacking in the sense that it is taking a single integral packed value and breaking it up into the individual elements of an unpacked array. When it comes to the streaming operator, whether it is packing or unpacking is not so relevantâ€”it is reorganizing the layout of the bits.
You could also write this as
assign unpacked_wire   = {&gt;&gt;{packed_wire}};

When there is only one object on either side of the assignment, it doesn't matter which side you put the streaming operator on.
The LRM considers unpacked types a strong type. You can only make assignments from/to equivalent types. Packed types on the other hand are weak. You can make assignments between packed types of different sizes and it silently truncates or pads the data. The streaming operator is more like an explicit cast that facilitates assignments between unpacked and other packed or unpacked types.",,,,,
Defining void function in Verilog?,"I know that we can write functions in verilog just to display sth. like in the example below:
function ex_func;
    input op;
    input [1:0] in1;
    input [1:0] in2;
    input [1:0] out1;
    begin
        if(op)
            $display(&quot;%d &lt;-- %d, %d&quot;, out1, in1, in2);
        else 
            $display(&quot;%d --&gt; %d, %d&quot;, out1, in1, in2);
            
        ex_func = 0;
    end
endfunction

However I couldn't write this as void(not returning a value), so cannot use without equating to a temporary variable which is unnecessary. I can use in an ugly way:
// ...

reg temp; // temporary variable required for the function to work

initial begin
// ...

temp = ex_func(op[0], in1[0], in2[0], out1[0]);
#10;

// ...

temp = ex_func(op[1], in1[1], in2[1], out1[1]);
#10;

// ...
end

This works flawlessly, but as I said I want to write a function that does not return a value (void) and get rid of these ugly things. It seems that SystemVerilog supports void definition: https://verificationguide.com/systemverilog/systemverilog-functions/#Void_function , but same syntax does not work for Verilog (&quot;Error:'void' is an unknown type&quot;) and I cannot find any other way or documentation about in Verilog.
So, the question is: Is there a way to define void function in Verilog?","In your case, I would use a task rather than a function as you are using it to display information only.
task ex_task;
    input op;
    input [1:0] in1;
    input [1:0] in2;
    input [1:0] out1;
    begin
        if(op)
            $display(&quot;%d &lt;-- %d, %d&quot;, out1, in1, in2);
        else 
            $display(&quot;%d --&gt; %d, %d&quot;, out1, in1, in2);
    end
endtask

Then you would call the task as you were hoping:
ex_task(op[0], in1[0], in2[0], out1[0]);

You can even add the delay in the task itself, which is another difference between functions and tasks.
task ex_task;
    input op;
    input [1:0] in1;
    input [1:0] in2;
    input [1:0] out1;
    begin
        if(op)
            $display(&quot;%d &lt;-- %d, %d&quot;, out1, in1, in2);
        else 
            $display(&quot;%d --&gt; %d, %d&quot;, out1, in1, in2);
        #10;
    end
endtask
",,,,,
Unable to output data entered into a register,"I have a simple program. I am trying to input the counter output into a memory address register and output the data that is in the memory address register.
Memory Address Register Code:
library ieee;
use ieee.std_logic_1164.all;

entity mar is
port(
    mar_clk, mar_clr, mar_en : in std_logic;
    mar_datain : in std_logic_vector(3 downto 0);
    mar_dataout : out std_logic_vector(3 downto 0)
);
end entity;

architecture behavioral of mar is
begin
    process(mar_clk, mar_clr, mar_en, mar_datain)
        begin
        if(mar_clr = '1') then
            mar_dataout &lt;= (others =&gt; '0');
        elsif(mar_clk'event and mar_clk = '1') then
            if(mar_en = '0') then
                mar_dataout &lt;= mar_datain;
            end if;
        end if;
    end process;
end behavioral;

Buffer4 Code:
library ieee;
use ieee.std_logic_1164.all;

entity buffer4 is
port(
    buff4_en : in std_logic;
    datain : in std_logic_vector( 3 downto 0 );
    dataout : out std_logic_vector( 3 downto 0 )
);
end entity;

architecture behavioral of buffer4 is
begin
    process(buff4_en, datain)
    begin
        if(buff4_en = '1') then
            dataout &lt;= datain;
        else
            dataout &lt;= (others =&gt; 'Z');
        end if;
    end process;
end behavioral;

Program Counter Code:
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

entity pc is
    port(
        pc_ld, pc_en, pc_clk, pc_rst : in std_logic;
        pc_datain : in std_logic_vector(3 downto 0);
        pc_dataout : out std_logic_vector(3 downto 0)
    );
end entity;

architecture behave of pc is
    signal count : std_logic_vector(3 downto 0) := &quot;0001&quot;;
    signal temp : integer;
begin
    process(pc_clk, pc_rst)
    begin
        if(pc_rst = '1') then
            count &lt;= (others =&gt; '0');
        elsif(pc_clk'event and pc_clk = '1') then
            if(pc_ld = '1') then
                count &lt;= pc_datain;
            elsif(pc_en = '1') then
                count &lt;= count;
                temp &lt;= conv_integer(count);
                if(temp = 16) then
                    count &lt;= (others =&gt; '0');
                end if;
                count &lt;= count + 1;
            end if;
        end if;
    end process;
    pc_dataout &lt;= count;
end behave;

Test Program Code:
library ieee;
use ieee.std_logic_1164.all;

entity test is
end entity;

architecture behave of test is

component mar
    port(
        mar_clk, mar_clr, mar_en : in std_logic;
        mar_datain : in std_logic_vector( 3 downto 0 );
        mar_dataout : out std_logic_vector( 3 downto 0 )    
    );
end component;

component pc
    port(
        pc_ld, pc_en, pc_clk, pc_rst : in std_logic;
        pc_datain : in std_logic_vector(3 downto 0);
        pc_dataout : out std_logic_vector(3 downto 0)   
    );
end component;

component buffer4
    port(
        buff4_en : in std_logic;
        datain : in std_logic_vector( 3 downto 0 );
        dataout : out std_logic_vector( 3 downto 0 )    
    );
end component;

signal databus : std_logic_vector(7 downto 0);
signal addressbus : std_logic_vector(3 downto 0);

signal gclk : std_logic;
signal mar_clr, mar_en : std_logic;
signal pc_ld, pc_en, pc_rst : std_logic;

signal buff4_en : std_logic;
signal dataout : std_logic_vector(3 downto 0);

signal mar_datain, mar_dataout : std_logic_vector(3 downto 0);
signal pc_dataout : std_logic_vector(3 downto 0);

begin
    U1 : pc port map(pc_ld, pc_en, gclk, pc_rst, databus(3 downto 0), pc_dataout);
    U2 : buffer4 port map(buff4_en, pc_dataout, databus(3 downto 0));
    U3 : mar port map(gclk, mar_clr, mar_en, databus(3 downto 0), addressbus);

    stim_process : process
    begin
        gclk &lt;= '0';
        wait for 10 ns;
        pc_ld &lt;= '0';
        pc_en &lt;= '1';
        pc_rst &lt;= '0';
        buff4_en &lt;= '1';
        mar_clr &lt;= '0';
        mar_en &lt;= '0';
        gclk &lt;= '1';
        wait for 10 ns;
    
        gclk &lt;= '0';
        wait for 10 ns;
    
        assert false report &quot;Reached end of test. Start GTKWave&quot;;
        wait;
    end process;
end behave;

This is the output when I run the program

As seen the Memory Address Registers takes the input and doesn't output it on the address bus. How can I make the Memory Address Register output the data on the address bus?","This is the logic for writing to your memory address output register inside your 'MAR' component:
    if(mar_clr = '1') then
        mar_dataout &lt;= (others =&gt; '0');
    elsif(mar_clk'event and mar_clk = '1') then
        if(mar_en = '0') then
            mar_dataout &lt;= mar_datain;
        end if;
    end if;

If appears that at your rising edge of clock (mar_clk'event and mar_clk = '1') in the waveforms that mar_clr and mar_en are both undefined U's. They have not got their values yet when the rising edge occurs.
You need to redo your testbench to make sure input signals are stable+defined before the rising edge so they are sampled correctly. Then mar_dataout &lt;= mar_datain; should take correctly.
Could try moving initial wait statement like so:
gclk &lt;= '0';
pc_ld &lt;= '0';
pc_en &lt;= '1';
pc_rst &lt;= '0';
buff4_en &lt;= '1';
mar_clr &lt;= '0';
mar_en &lt;= '0';
wait for 10 ns;
gclk &lt;= '1';
wait for 10 ns;
",,,,,
String in VHDL Waveform,"How can I print a string in VHDL waveform?
-&gt; like here","A string is no different from other types of signals, so you can do like:
library ieee;
use ieee.std_logic_1164.all;

entity tb is
end entity;

architecture sim of tb is

  signal info : string(1 to 5);

begin

  process is
  begin
    info &lt;= &quot;Hello&quot;;
    wait for 1 us;
    info &lt;= &quot;VHDL &quot;;
    wait for 1 us;
    info &lt;= &quot;world&quot;;
    wait for 1 us;
    info &lt;= &quot;!!!  &quot;;
    wait for 1 us;
    wait;
  end process;

end architecture;

Simulation in Intel Quartus ModelSim Starter Edition (free) then gives:
",,,,,
Can signal in std_logic have other value than 0 and 1?,"I've been learning VHDL (mostly on my own) during my studies. I've heard that I should always cover all possible situations in case or if statements. My question is: is it technically possible for std_logic internal signal to have any other value than 0 or 1?
For example, is this possible:
signal or_gate : std_logic;

...
or_gate &lt;= input1 or input2;
...
if(or_gate = '1') then
--led blinks fast
elsif(or_gate = '0') then
--led blinks slow
else
--led off
end if;

or there can only be led blinks or led off?","for bit type we have just 0 and 1, but std_logic type except 0 and 1, support other values.
So the std_logic type can have the following values:

'1' : Logic 1
'0' : Logic 0
'Z' : High impedance
'W' : Weak signal, canâ€™t tell if 0 or 1
'L' : Weak 0, pulldown
'H' : Weak 1, pullup
'-' : Donâ€™t care
'U' : Uninitialized
'X' : Unknown, multiple drivers
",,,,,
Verilog: Understanding multiple driver on bidirectional signal,"I am debugging some Verilog code and I'm having some difficulty understanding a bidirectional signal with multiple drivers:
The verilog code looks like this:
inout a;

assign a = b ? c : 1'bz
       a=Stx b=St1  c=St0
assign (weak0, weak1) a = d ? 1'bz : (e ? 1'b0 : (f ? 1'b1 : 1'bz));
       a=Stx  d=St0 e=St0 f=St0

Signal c is the actual data that needs be transmitted to a (output pad). When I run the simulation using a commercial simulator, I get the values annotated above. I don't understand why a ends up being X throughout the simulation. b is toggling and c is also toggling. d/e/f are always 0. The 2nd statement is using a weak pull-up/pull-down but by setting it d/e/f=0, it should drive Z. So the other statement should win out?","With your code above, you are in essence creating a bidirectional buffer which is one input buffer from IO pad to internal signal, and an output buffer from internal signal to IO pad that is controlled by an enable. The b signal is the enable on one side and the d signal is the enable on the other side.

Remember that a bidirectional signal or bus must still have some kind of arbitration on it, something that understands the bidirectional transactions that are occurring as both sides should not be enabling their output buffers at the same time.",,,,,
Copying register value in Verilog behavioral modelling,"I'm working to design encryption module in Verilog using behavioral modelling approach, but i'm stuck in passing register value to Data_out port. I'm making little mistake to copy register p value in Data_out port. Testbench is also attached. expected output of the module should be Data_out = (Data_in + Key) MOD 26. but we can't use % operator because of systhesis issue.
Your answer will be valuable for me.
module encription(Start,Clk,Reset,Data_In, Key,Data_out,Done);

parameter M='d26;
parameter S0=0, S1=1, S2= 2;
input Clk,Reset,Start;
input [4:0] Data_In,Key;
output reg [4:0] Data_out;
output reg Done;
 reg [1:0] state;
 reg [4:0] p,q,r,s;
 
 always @ (posedge Clk)
 begin
 r &lt;= Data_In;
 s &lt;= Key;
 end
 
 
 always @ (posedge Clk )
    begin
      if(Reset=='b0)
        begin
            Done &lt;= 1'b0;
            p &lt;= M;
        end
        else if (Reset == 'b1)
        case (state)
         S0: 
         if (Start) begin
         q &lt;= r + s;
         
         state &lt;= S1;
         end
         S1: 
         if (p &gt;= q) begin
         p &lt;= p - q;
         state &lt;= S2;
         end
         S2:
         begin
               Data_out &lt;= p;
               Done &lt;= 1'b1;
               Done &lt;= 1'b0;
               end
               default:
               state &lt;= S0;
endcase

end
endmodule



module Encryption_tb();

reg Clk,Reset,Start;
reg [4:0] Data_In,Key;
wire [4:0] Data_out;
wire [4:0] q;
wire Done;

  encription DUT(Start,Clk,Reset,Data_In, Key,Data_out,Done);
initial
    begin
    Clk = 0;
    forever #5 Clk=~Clk;
    end
    
    initial
    begin
        #10 Start = 'b1;  Data_In = 'b000111; Key = 'b01110;
    #10 Start = 'b1;  Data_In = 'b000101; Key = 'b01100;
    #10 Start = 'b1;  Data_In = 'b000001; Key = 'b00110;
    #10 Reset = 'b1; Start = 'b1;
    //#10 Reset = 'b0;
    #10 Start = 'b1;  Data_In = 'b000111; Key = 'b01110;
    #10 Start = 'b1;  Data_In = 'b000101; Key = 'b01100;
    #10 Start = 'b1;  Data_In = 'b000001; Key = 'b00110;
    #10 $finish;
    end
endmodule
","This does not need a state machine just some flops.
RTL:
module encription(Start,Clk,Reset,Data_In, Key,Data_out,Done);

parameter M='d26;
parameter S0=0, S1=1, S2= 2;
input Clk,Reset,Start;
input [4:0] Data_In,Key;
output reg [4:0] Data_out;
output reg Done;
  
  reg [6:0] sum;

assign sum = Data_In + Key;
 
 always @ (posedge Clk )
    begin
      if(Reset=='b1)
        begin
            Data_out &lt;= 0;
            Done &lt;= 0;         
        end
        else
          begin
          if(sum &lt; M)
            Data_out &lt;= sum;
            else
              if(sum &lt; 2*M)
                Data_out &lt;= sum - M;
               else
                 Data_out &lt;= sum - 2*M ;
            
            Done &lt;= Start;
          end
    end

endmodule    

Testbench with meaningful vectors:
    module Encryption_tb();

reg Clk,Reset,Start;
reg [4:0] Data_In,Key;
wire [4:0] Data_out;
wire [4:0] q;
wire Done;

  encription DUT(Start,Clk,Reset,Data_In, Key,Data_out,Done);
  
  
initial
    begin 
    Clk = 0;
    forever #5 Clk=~Clk;
    end
    
    initial
    begin :initial_block
      
      $monitor(&quot;Data_In = %d,Key = %d, Data_out = %d&quot;,Data_In,Key,Data_out);
      
    Reset = 1;
    #20 Reset = 0;
      
    #10;
      
    #1;
    Start = 1;
      for(int i = 0; i &lt; 30; i++)
        begin
          @ (posedge Clk);
          #1;
          Key = i;
          Data_In = i;
        end

    #10 $finish;
    end :initial_block
  
  initial
    begin
      $dumpfile(&quot;dump.vcd&quot;);
      $dumpvars;
    end
  
endmodule    

Some of the outputs (note the answer is delayed by 1 clk because of the flops)
Data_In =  0,Key =  0, Data_out =  0
Data_In =  1,Key =  1, Data_out =  0
Data_In =  1,Key =  1, Data_out =  2
Data_In =  2,Key =  2, Data_out =  2
Data_In =  2,Key =  2, Data_out =  4
Data_In =  3,Key =  3, Data_out =  4
Data_In =  3,Key =  3, Data_out =  6
Data_In =  4,Key =  4, Data_out =  6
Data_In =  4,Key =  4, Data_out =  8
Data_In =  5,Key =  5, Data_out =  8
Data_In =  5,Key =  5, Data_out = 10
Data_In =  6,Key =  6, Data_out = 10
Data_In =  6,Key =  6, Data_out = 12
Data_In =  7,Key =  7, Data_out = 12
Data_In =  7,Key =  7, Data_out = 14
Data_In =  8,Key =  8, Data_out = 14
Data_In =  8,Key =  8, Data_out = 16
Data_In =  9,Key =  9, Data_out = 16
Data_In =  9,Key =  9, Data_out = 18
Data_In = 10,Key = 10, Data_out = 18
Data_In = 10,Key = 10, Data_out = 20
Data_In = 11,Key = 11, Data_out = 20
Data_In = 11,Key = 11, Data_out = 22
Data_In = 12,Key = 12, Data_out = 22
Data_In = 12,Key = 12, Data_out = 24
Data_In = 13,Key = 13, Data_out = 24
Data_In = 13,Key = 13, Data_out =  0
Data_In = 14,Key = 14, Data_out =  0
Data_In = 14,Key = 14, Data_out =  2
Data_In = 15,Key = 15, Data_out =  2
Data_In = 15,Key = 15, Data_out =  4
Data_In = 16,Key = 16, Data_out =  4
Data_In = 16,Key = 16, Data_out =  6
Data_In = 17,Key = 17, Data_out =  6
Data_In = 17,Key = 17, Data_out =  8
Data_In = 18,Key = 18, Data_out =  8
",,,,,
8 bit serial to parallel shifter in vhdl,"I programmed an 8-bit shifter in vhdl:
entity 8b is 
  port(s, clk : in std_logic; p : out std_logic_vector (7 downto 0)); 
end entity; 

architecture arch of 8b is 
  Signal iq : std_logic_vector (7 downto 0); 
begin 
  process(clk) 
  begin 
    if rising_edge(clk) then 
      iq(7) &lt;= s;
      iq(6 downto 0) &lt;= iq(7 downto 1); 
    end if; 
  end process; 
  p &lt;= iq; 
end architecture; 

The idea is that I'm taking input and giving it to my first D-FF.
Then over the next 7 cycles, the other Flip Flops get the other serial inputs which will be given to the parallel output p.
However, I'm not sure if this logic is flawed because this is the solution we got for this exercise:
architecture behavior of 8b is
  signal p_intern : std_logic_vector(7 downto 0);
begin
  P &lt;= p_intern;
  process(CLK)
  begin
    if rising_edge(CLK) then
      p_intern &lt;= p_intern(6 downto 0) &amp; S;
    end if;
  end process;
end architecture;

But I don't get the p_intern &lt;= p_inter(6 downto 0) &amp; S; part.
Can someone please explain the logic behind this and if my version is also valid?","The only difference between the two implementations seem to be the lines

iq(7) &lt;= s;
iq(6 downto 0) &lt;= iq(7 downto 1); 


vs.

p_intern &lt;= p_intern(6 downto 0) &amp; S;


and that iq is named p_intern. Let's assume they are both named iq for the sake of comparison.
Let's see what they are doing:
The first implementation (yours) assigns to the positions of iq:
7     6     5     ... 1     0
s     iq(7) iq(6) ... iq(2) iq(1)

The second implementation (the solution) assigns
7     6     5     ... 1     0
iq(6) iq(5) iq(4) ... iq(0) s

Where iq(6 downto 0) &amp; s means &quot;concatenate s to the right of iq(6 downto 0)&quot;.
So they are not equivalent. Your implementation shifts in the values from the left, and the solution shifts in the values from the right. Which one is correct depends on the specification (presumably the solution is correct).",,,,,
FSM enters impossible state,"I have a FSM consisting of 3 states: STATIC, UP and DOWN.
The FSM starts in the STATIC state and if I press the up arrow key, it will move to the UP state, thereafter returning to the STATIC state. Same thing for DOWN.
At first the FSM works well but suddenly after a random amount of key presses it will enter an unspecified state. The FSM consists of two processes:
type ALL_STATES is (STATIC, UP, DOWN);
signal STATE, NEXT_STATE: ALL_STATES;
signal posBarraYTOP, posBarraYBOT: std_logic_vector(11 downto 0);
signal movTeclado: std_logic_vector(1 downto 0);

-- ...
Keybd: keyboard port map (input, movTeclado); -- keyboard output
-- ...

bar_FSM_sincrono: process(CLK, RST) -- CLK is the FPGA's clock
begin
    if RST='1' then
        STATE &lt;= STATIC;
    elsif (CLK'event and CLK = '1') then
        STATE &lt;= NEXT_STATE; -- in each CLK cycle we move to the next state.
    end if;    
end process bar_FSM_sincrono;

bar_FSM_cambioest: process(STATE)
begin
    case STATE is
        when STATIC=&gt; 
            seg &lt;= &quot;1001001&quot;;
            if (movTeclado = &quot;01&quot; and posBarraYTOP &gt; 20) then
                NEXT_STATE &lt;= UP;
            elsif (movTeclado = &quot;10&quot; and posBarraYBOT &lt; 980) then
                NEXT_STATE &lt;= DOWN;
            else
                NEXT_STATE &lt;= STATIC;
            end if;
        when UP | DOWN =&gt;
            NEXT_STATE &lt;= STATIC;
            seg &lt;= &quot;1111110&quot;;
        when others =&gt;
            NEXT_STATE &lt;= STATIC;
            seg &lt;= &quot;0110111&quot;;
    end case;
end process bar_FSM_cambioest;

movTeclado is a 2-bit signal that shows when the user presses the up 01 or down 10 key. It's 00 if no key is pressed. movTeclado doesn't give me any problems.
posBarraYTOP and posBarraYBOT are two signals to describe a boundary, and these conditions are always met.
I use seg as a signal for the 7-segment display to debug and find out in what state the FSM is at. At first it always displays the STATIC seg, as it should since UP seg and DOWN seg are only displayed for one cycle. But then when the error happens it's when it starts displaying the others seg, as well as the STATIC seg. It's a back-and-forth between STATIC and others, which I don't understand since when STATE = STATIC, it should only transition to UP or DOWN.
Thank you for reading this far, does anyone know what's going on?","As other comments have suggested, you should never drive a signal from more than one process block. Personally I don't like writing state machines like this, with 2 process blocks, because I find it confusing.
But regardless, your 2nd process block (the combinational one) should only be assigning NEXT_STATE, it should never make an assignment to STATE since that's taken care of by the first process block.",,,,,
How to initialize unpacked array of unpacked union of unpacked structs?,"What is the legal method of initializing this?
module tb();
typedef struct {
    logic [3:0] A;
} a_t;
typedef struct {
    logic [7:0] B;
} b_t;
typedef union {
    a_t a;
    b_t b;
} a_b_t;
a_b_t a_b [8];
initial begin
    a_b &lt;= '{default: '{default: 0}};
end
endmodule

xrun gives this error:
xmelab: *E,APBLHS (./tmp.sv,14|23): Assignment pattern - LHS must be an array or structure [SystemVerilog].

I've tried a variety of other ways, and I can't quite get this right. I'm working around it right now by initializing each entry separately with 2 lines of initialization.","As the error message state, assignment patterns only work with struct and arrays, not unions. You would need to use a foreach loop to assign each union member.
initial 
  foreach (a_b[i]) begin
    a_b[i].a &lt;= '{default:0};
    a_b[i].b &lt;= '{default:0};
end

Note that unless you are using the DPI for C compatibility, unpacked unions have little usefulness in SystemVerilog. Use packed unions instead.",,,,,
How to pass interface modport signal into other module?,"I'm trying to implement an interface with modports.  I have 2 modules inside a testbench.
module test;
test_intf intf();

clk_reset u_clk_reset (
            intf.CLK_RESET
                );

mem u_mem(
        intf.MEM
    );
....
endmodule

This is the interface:
interface test_intf;
logic reset_n;
logic aclk;
logic bclk;
logic areset_n;

logic               wr_in;
logic               rd_en;
logic    [ 9:0]     wr_addr;
logic    [23:0]     wr_data;
logic    [ 9:0]     rd_addr;
logic     [23:0]    rd_data;

modport CLK_RESET (output aclk, bclk, areset_n);
modport MEM (output rd_data, input clk, reset_n, wr_in, rd_en, wr_addr, wr_data, rd_addr);

endinterface

This is the clk_reset module:
module clk_reset(
test_intf intf
);


always #(5) intf.aclk = ~intf.aclk;
initial begin
 intf.aclk = 0;
end

initial begin
 intf.areset_n = 1;
 #2000  intf.areset_n = 0;
 #2000  intf.areset_n = 1;
end

This is the mem module:
module mem
        (
test_intf intf
);

always @(posedge intf.clk or negedge intf.reset_n)
begin
    //end
end

I checked that the clk_reset interface ports are working (all outputs).
But, the problem is that the output clock signals from clk_reset can't reach the mem module by interface. So, intf.clk signal is 'x' in the mem module.
How do I pass some interface's signals into another interface (module)?","Your simulator should have given you a compile error.  The interface is missing the declaration of the clk signal.  Add it like this:
logic clk;

Since you want to use clk inside mem, you need to add clk to the CLK_RESET modport list:
modport CLK_RESET (output aclk, bclk, clk, areset_n);

Finally, you need to generate the clk signal so that it is not X.  Here are the required changes:
interface test_intf;
    logic reset_n;
    logic aclk;
    logic bclk;
    logic clk;
    logic areset_n;

    logic               wr_in;
    logic               rd_en;
    logic    [ 9:0]     wr_addr;
    logic    [23:0]     wr_data;
    logic    [ 9:0]     rd_addr;
    logic     [23:0]    rd_data;

    modport CLK_RESET (output aclk, bclk, clk, areset_n);
    modport MEM (output rd_data, input clk, reset_n, wr_in, rd_en, wr_addr, wr_data, rd_addr);
endinterface

module clk_reset(
    test_intf intf
    );

    always #(5) intf.aclk = ~intf.aclk;
    initial begin
     intf.aclk = 0;
    end

    always #(5) intf.clk = ~intf.clk;
    initial begin
     intf.clk = 0;
    end

    initial begin
     intf.areset_n = 1;
     #2000  intf.areset_n = 0;
     #2000  intf.areset_n = 1;
    end
endmodule
",,,,,
Want to use 1 Verilog module output for 2 inputs,"Everything in my project works perfectly. Basically I use a 2to1mux to determine which of two 7-bit inputs gets displayed on a hex display and 7 LEDs. It works perfectly, but I was wondering how I can use the one 7-bit output from my module for both the LEDs and the Hex display?
Here is my main file:
module Majority(SW, LEDR, KEY, HEX0);

    input [16:0] SW;
    
     input [3:3] KEY;
    output [6:0] LEDR;
     output [6:0] HEX0;
    
    my21mux m21m_inst(.sel(KEY[3]), .in0(SW[6:0]), .in1(SW[16:10]), .y(HEX0[6:0]));

endmodule





module my21mux(sel, in0, in1, y);
input sel, in0, in1;
output y;

wire nsel;
wire t1;
wire t2;



not n(nsel, sel);

and a1(t0, in0, sel);
and a2(t1, in1, nsel);

or o(y, t1, t2);

// y should determine which set of switches to display on the LEDs / Hex


endmodule

And here is my test bench:
`timescale 1 ns/1 ns

module TestBench();
 //stimulus connections   
    reg [3:3] KEY;
    reg [16:0] SW;
    wire [6:0] LEDR;
    wire [6:0] HEX0;
   my21mux S(KEY, SW[6:0], SW[16:10], HEX0[6:0]);
// Test Procedure
    initial begin
KEY[3]=0;SW[10]=0;SW[0]=0; #5;
KEY[3]=0;SW[10]=0;SW[0]=1; #5;
KEY[3]=0;SW[10]=1;SW[0]=0; #5;
KEY[3]=0;SW[10]=1;SW[0]=1; #5;
KEY[3]=1;SW[10]=0;SW[0]=0; #5;
KEY[3]=1;SW[10]=0;SW[0]=1; #5;
KEY[3]=1;SW[10]=1;SW[0]=0; #5;
KEY[3]=1;SW[10]=1;SW[0]=1; #5;
end
endmodule

Any ideas would be appreciated, thank you!","It is not clear how your main_file is structured, since there is an unmatched endmodule keyword that suggests that you wanted to create some sort of wrapper to your my21mux module. Probably that module is not used anyway since in TestBench you instantiate my21mux mux anyway.

Quick and dirty solution, 2 muxes:
  my21mux S_hex0(KEY, SW[6:0], SW[16:10], HEX0[6:0]);
  my21mux S_ledr(KEY, SW[6:0], SW[16:10], LEDR[6:0]);


With only one mux instance that has one output, which is assigned to both your signals:
  wire [6:0] mux_out;
  my21mux S_hex0(KEY, SW[6:0], SW[16:10], mux_out);
  assign HEX0 = mux_out;
  assign LEDR = mux_out;


In my opinion the following would be easier, with no need of a custom defined mux:
  wire [6:0] mux_out = KEY ? SW[6:0] : SW[16:10]; //ternary operator
  assign HEX0 = mux_out;
  assign LEDR = mux_out;



Please check out ternary operator usage.
Also, in your my21mux you associate in0 AND sel and in1 AND nsel, while the name obviously suggests that it should be the other way round.",,,,,
Simplest way to enforce that a module is only instanced once?,"Suppose I have a (not synthesizable) simulation-only Verilog module.
How can I detect/enforce if it is elaborated more than once anywhere in a simulation?
module Singleton();
  // I only want one of these...
endmodule

module GOOD_Design();
  Singleton singleton();
endmodule

module BAD_Design();
  Singleton singleton1();
  Singleton singleton2();
endmodule


My best thought is to create a static variable in a package and do something like this:

package SingletonPkg();
  static bit once = 1'b0;
endpackage

module Singleton();
  initial begin: singleton
    if (SingletonPkg::once == 1'b1)
      $fatal(2);
    SingletonPkg::once = 1'b1;
  end
  ...
endmodule: Singleton

Seems a lot of work (and I still have to make the test/set into an atomic operation).
I could use the same approach with a DPI function as well, and keep the bit in C instead of SV.
Nevertheless, is there a better/simpler way?","You can make it slightly simpler by using a class
package SingletonPkg;
 class C;
  static bit once = 1'b0;
  function new;
     if (once++ != 0) $fatal(2);
  endfunction
 endclass
endpackage

module Singleton();
  SingletonPkg::C = new; 
  ...
endmodule: Singleton

",,,,,
Difference between 1e12 and 1000000000000 in SystemVerilog,"I'm trying to calculate the baud rate of the data transaction by capturing the simulation time of two signal changes. I couldn't get the correct baud rate computed until I changed the 1000000000000 to 1e12 for the numerator of the division:
(produced wrong baud rate, baud rate = 411)
measured_baud_rate = (1000000000000)/(duration);

(produced correct baud rate, baud rate = 115207)
measured_baud_rate = (1e12)/(duration);

This is very strange to me as I see them representing the same number, just different format. Why 1e12 produces the correct result? Below shows the more complete version of my code.
longint unsigned start_time;
longint unsigned stop_time;
longint unsigned duration;
real measured_baud_rate;

// Get simulation time of the first signal change.
start_time = $time;
`uvm_info(get_type_name(), $sformatf(&quot;Start time: %d ps&quot;, start_time), UVM_NONE)

// Wait for next signal change.
wait (previous_tsr_value != sim_top.tb.uart_inst.uart_0._uart_0.uart_tx.tx_shift_register_contents_out);

stop_time = $stime; // Get simulation time of the second signal change.
`uvm_info(get_type_name(), $sformatf(&quot;Stop time: %d ps&quot;, stop_time), UVM_NONE)

// Calculate the period between two signal changes.
duration = ($stime - start_time);
`uvm_info(get_type_name(), $sformatf(&quot;Duration: %d ps&quot;, duration), UVM_NONE)

// Baud rate calculation, how many bits can be transferred in one second.
// Duration is in picoseconds, so 1 second = 1000000000000 ps.
measured_baud_rate = (1000000000000)/(duration);
// measured_baud_rate = (1e12)/(duration);

`uvm_info(get_type_name(), $sformatf(&quot;Measured baud rate: %f&quot;, measured_baud_rate), UVM_NONE)

Results:
When I use 1000000000000:

When I use 1e12:
","You should have received the error along the lines of

Unsized literal value 1000000000000 exceeds default size of literals which  is 32-bit. Either size the literal (i.e. 64'd1000000000000) or reduce the literal value to fit in 32 bits.

because all simple numeric literals are treated as decimal, signed 32-bit quantities.
Also, since duration is a longint, (64.d1000000000000)/(duration) would computed as an integral division. You can use a real number 1000000000000.0. But isn't 1e12 easier to read? And why not use reals for everything, and don't use $stime. use $realtime instead. Otherwise you loose fractional time units.",,,,,
SystemVerilog equivalent for specman's sys.tick_end,"I have a System Verilog code that does checking based on a reference model. The ref model is updated by several analysis ports (in a monitor) in parallel, and also being read by my checker.
The shared ref model holds many data objects and the checker needs to &quot;look&quot; on multiple objects  at the same cycle.
I need to somehow sync my checker to wait until all transactions from current cycle on the monitor's analysis ports will update the ref model. However, it is not guaranteed which task executes first : monitor's tasks or my checker tasks, so my checker may read stale (not updated) value from the reference model.
When I used to work with Specman, such issues could have been solved by using sys.tick_end() at the checker.  This guaranteed that checker code will execute &quot;at the end of the current cycle&quot; - after all ports monitors already updated the reference model.
Is there any SystemVerilog equivalent for Specman's sys.tick_end() ?
Alternatively, is there any other method to sync a checker to wait until &quot;all monitors did their updates for current cycle&quot; ?
Thanks,
Roi.","From the way you worded your question, it appears you might be using the UVM. If that is correct, the UVM has a method uvm_wait_for_nba_region() which under most circumstances gives you the behavior you are looking for. This assumes all the analysis ports are synchronized to the same clock. It effectively makes them behave like they were assigned using a non-blocking assignmentâ€”eliminating any race conditions.",,,,,
Declaring input port arrays in single statement vs. multiple statements,"My teacher told me that its good practice to declare packed input arrays in different statements rather than in one. For example:
input [3:0] a,b;   //create two inputs ports of 4 bits

vs.
input [3:0] a;    //create one port &quot;a&quot; of 4 bits           
input [3:0] b;    //create one port &quot;b&quot; of 4 bits

The teacher has told me the second style is more preferable; however, both work the same. Is there any reason for the second style of declaration? Does it help in synthesis or prevent errors while instantiating?","The second style is preferred because relying on all Verilog's implicit declaration rules leaves lots of room for mistakes. By putting each port on one line the intent is explicitly shown. Also, the ANSI style of port declarations is preferred so that each port name is listed only once
Fully explicit ANSI style from Verilog-2001 (wire logic would be implicit if left out)
module mod(
  input wire logic [3:0] a,    //create one input port &quot;a&quot; of 4 bits           
  input wire logic [3:0] b,    //create one input port &quot;b&quot; of 4 bits
  output var logic [3:0] c    //create one output port &quot;c&quot; of 4 bits
);

Non-ANSI style from Verilog-1995
module mod(a, b, c);
  input [3:0] a;    //create one input port &quot;a&quot; of 4 bits           
  input [3:0] b;    //create one input port &quot;b&quot; of 4 bits
  output [3:0] c;   //create one output port &quot;c&quot; of 4 bits
  logic [3:0] c; // port c listed 3 times
endmodule


",,,,,
SystemVerilog: String to Circuit Net,"Assuming that I set one environment variable before launching a logic simulation of my circuit wrapped in a testbench written in SystemVerilog, I want to check whether it is possible to read the variable and try to map it to a net of the circuit.
For instance:
#### from the bash script that invokes the logic simulator ####
export NET_A=tb_top.module_a.submodule_b.n1

//// inside the tb_top in system verilog ////

import &quot;DPI-C&quot; function string getenv(input string env_name);

always_ff @(posedge clk, nenedge rst_n) begin

    if (getenv(&quot;NET_A&quot;) == 1'b1) begin

        $display(&quot;Hello! %s has the value 1&quot;, getenv(&quot;NET_A&quot;));
    end 
end


In the example above I simply want to check whether the current net i.e., NET_Ais assigned at a certain point in the simulation the logic value of 1.
Thanks in advance","SystemVerilog has a C-based API (Verilog Procedural Interface VPI) that gives you access to a simulator's database. There are routines like vpi_get_handle_by_name which gives you a handle to an signal looked up by  a string name. And then you can use vpi_get_value the gives you the current value of that signal.
Use of the VPI needs quite a bit of additional knowledge and many simulators give you built-in routines to handle this common application without having to break into C code. In Modelsim/Questa, it is called Signal_Spy.
But regardless of whether you use the VPI or tool specific routines, looking up a signal by string name has severe performance implications because it prevents many optimizations. Unless a signal represents a storage element, it usually does not keep its value around for queries.
It would be much better to use the signal path name directly
vlog ... +define+NET_A=tb_top.module_a.submodule_b.n1

Then in your code
if (`NET_A == 1'b1) begin
",,,,,
How to determine direction of a vector in VHDL (downto vs to)?,"I need to write a function that will shift data into an input vector. The input could be of type signed or unsigned. In order to make the function robust, I need to know the direction of the input vector i.e range declared using downto vs to. This information will be used to determine what index has the least significant bit.
How do I find out how the range has been declared and choose the correct least significant and most significant bit based on that information?","Array types have the default attributes 'ascending and 'descending which are both functions that return true/false depending on whether the range is actually to (ascending) or downto (descending). Hence, you will likely need to have the following coding style if you explicitly need to investigate the direction:
if p'ascending then
  -- do code for to direction
else
  -- do code for downto direction
end if;

Alternatively, you can use an alias to &quot;normalise&quot; the direction inside the function, which means an if/else is not needed depending on direction, as you know the direction inside the function:
function do_something( p : bit_vector ) return bit_vector is
  alias p_a  : bit_vector(p'length-1 downto 0) is p;    -- normalise p
  variable r : p_a'subtype;
begin
   -- use p_a as a downto vector
   
   return r;
end function;
",,,,,
Start up behavior of moving average filter is different between pre and post synthesis functional simulation,"I've implemented a moving average filter (in Verilog), based on an article I read which performs differently pre and post synthesis. The design implements $y[n]=y[n-1]+x[n]-x[N-1]$.
module ma_width #(parameter WIDTH =16)(
    new_sample,
    en,
    sample_out, 
    clk,
    reset_b
    );

input   [15:0]  new_sample;
input   en;
input   clk;
input   reset_b;          //active low reset
output reg  [15:0]  sample_out;



 // ex. adding 16 16-bit numbers requires 20bits...

(*keep=&quot;true&quot;*) reg [15:0]sample_in_fifo[0:WIDTH-1];

// use generate to create fifo as a chain of sixteen 16-bit registers

genvar i;
generate
     for (i = 0; i &lt; WIDTH-1 ; i = i + 1) begin: gd
         always @(posedge clk) begin
            if(!reset_b)
            begin
                sample_in_fifo[i+1] &lt;=4'h0000 ;
            end
            else if (en)
            begin
                sample_in_fifo[i+1] &lt;= sample_in_fifo[i];
            end
         end
    end
endgenerate

always @(posedge clk) begin
    if(!reset_b)
    begin
        sample_in_fifo[0]&lt;=4'h0000;
    end
    else if (en)
    begin
        sample_in_fifo[0] &lt;= new_sample;
    end
end

(*keep = &quot;true&quot;*)reg  [19:0]prevout;
(*keep = &quot;true&quot;*)wire [19:0] currout;

assign currout = prevout + {4'b0000,new_sample} - {4'b0000,sample_in_fifo[WIDTH-1]}; 

always @(posedge clk) begin
    if (!reset_b)
    begin
        sample_out &lt;= 16'h0000;
        prevout &lt;= 20'h00000;
    end
    else if (en)
    begin
       sample_out &lt;= currout[19:4]; //divide by 16
       prevout[19:0] &lt;= currout[19:0];  //but don't lose precision....
    end
end

endmodule

I've run into two issues:

prevout was being synthesized down from a [19:0] register to a [3:0] register -I got around this by using the &quot;keep&quot; synthesis directive --but I'm not sure why it was being synthesized &quot;out&quot; like that ---I'm sure that is a clue to the other anomaly I'm seeing.

In the simulation, I expect prevout to latch the state of the currout signal prior to the rising clock edge.  However, for some reason, this is not the case until about 6 clock cycles, after which it then behaves as expected:


POST SYNTH SIM:

At this point I'm baffled w.r.t. to what synthesizer is doing.  This works fine in the behavioral simulation, and I can't figure out what in the code (always blocks) may be ambiguously defining the registers or the logic to &quot;confuse&quot; or mislead the synthesizer.  Any pointers on how to approach debugging this would help a lot.
In effect, the moving average filter does do what it is supposed to, except at start up.  And, since I don't understand what is happening at start up, it makes me not trust the design/synthesis/and perhaps the implementation fully.
Pre-synth SIM below:

per request in the comments, i'm including the 2 warnings (there were no errors) obtained from synthesis:

[Synth 8-2507] parameter declaration becomes local in ma_width with formal parameter declaration list [&quot;C:/Users/jorge.rive/ClampPWM/Vivado/cip_repo/ma-width/ma_width.v&quot;:44]

this is due to a parameter definintion, but it isn't used, so ignore.
and

[Constraints 18-5210] No constraint will be written out.

In short, these were benign warnings, as far as I can tell.","A possibility is that the entire part is held in reset by a hardware global reset built into the hardware/fabric for some number of clocks or some amount of time.
Try delaying the stimulus and user reset for 10 clocks to test this theory.
I have seen stuff like this where there are resets in hardware that are not well understood without some deep drilling.
Post-synthesis simulations execute the vendors simulation model (the users RTL that has been targeted to a vendor model by synthesis) rather than the users RTL.
It can behave in ways not known to the user.",,,,,
How do I code a basic flip flop in Verilog Pro?,"I tried to code a basic flip flop using NAND gates in Verilog Pro, but the waveform I'm getting is not correct. Please see what's wrong with it.

//design module
module rstt(s,r,q,qbar);
input r,s;
output q,qbar;
nand n1(q,r,qbar);
nand n2(qbar,s,q);
endmodule

//stimulus module 
module test;
reg r,s;
wire q,qbar;
initial begin
r=1'b1;
s=1'b0;
#25 r=1'b0;
  s=1'b1;
#25 r=1'b1;
  s=1'b1;
#100 $finish;
end
endmodule
","You did not instantiate your rstt module inside your test module.  This means that the wires (q and qbar) inside module test are undriven.  That is why they remain as straight lines instead of toggling.  According to the IEEE Verilog standard, a undriven wire will default to 1'bz.

Try something like this:

//design module
module rstt(s,r,q,qbar);
input r,s;
output q,qbar;
nand n1(q,r,qbar);
nand n2(qbar,s,q);
endmodule

//stimulus module 
module test;
reg r,s;
wire q,qbar;

rstt i0 (
    .s    (s),
    .r    (r),
    .q    (q),
    .qbar (qbar)
);

initial begin
r=1'b1;
s=1'b0;
#25 r=1'b0;
  s=1'b1;
#25 r=1'b1;
  s=1'b1;
#100 $finish;
end
endmodule


Note that your problem is not specific to any simulator.",,,,,
What is ModelSim output file and how to load hex file on a ROM?,"I want to simulate a microprocessor designed using VHDL in ModelSim. I wanted to know what the output file format of the simulation is?
I also want to load some HEX file on the ROM of this Microporcessor...what should I do?
Thanks.","When thinking about simulating things in VHDL or Verilog you need to think like if you had the hardware which you want to simulate physically in your hands.

So if you have a CPU in your hand you need to put it on some kind of a PCB which has clocks, power, the CPU's bus, memory and other hardware that the program which you will run on the cpu will use.

The VHDL CPU also needs all of this, but not in a physical sense. You make the ""PCB"" and other things in VHDL or Verilog. So before you can simulate it you need to write a test bench (the virtual environment for it). This is where you can put your ROM. You write your virtual ROM in VHDL so it will sit on the CPU's bus and give data to the CPU when it will try to read it.

The output of the simulation can be pretty much anything you like. Since you are making the testbench and the devices which are connected to the CPU's bus. Since you are writing the devices that the CPU will interact with you can make them output text or you can even make a virtual framebuffer which could emulate a graphics interface connected to the CPU's bus.

You can also look at the signals inside of the CPU and what it will be doing on the bus, but that will probably not help you much if you are not debugging the VHDL of the CPU itself.

Also keep in mind that simulations like this are very,very slow (depending on the complexity of the CPU) it can take several days to simulate a program running on a CPU like this. So if you are not interested in the inner workings of the CPU (signals inside it), you should really consider using an emulator (if one exists) for your CPU.

If you provide more details on the CPU and what kind of program you want to run on it, I can try to help ypu with more detailed information.",,,,,
how much for Sound (ADC) reading in 24khz?,"how much ""sound inputs"" of high fidelify (128K 44kH) may be made via ordinary FPGA (Xilinx Spartan 3, what-so-ever) without using external ADC converters (only voltage-balanced input optically taken from audio jack)?

Here, Generating a pure sine wave as output form FPGA using VHDL code , it is pointed that FPGA may not perform such a job itself.

However, there are still 4 inputs/4 outputs of this resolution in the proposed test project, and...

what is a possibilty/amount of gates required to implement pre-DAC/pre-ADC output?","No, you can't take analog signals.  All Xilinx FPGAs are fundamentally digital.  You need the ADC.",,,,,
Wrapping and switching between similar entities in VHDL,"I want to describe an entity that can either function normally or be put in a test mode. The general design I have is a top level entity that wraps the ""real"" entity and a test entity.

I am trying to figure out the best way to express this in VHDL, but I get the feeling I'm overcomplicating things.

Consider a small top-level entity (realistically, there are many more I/Os):

entity toplevelobject is
    port (
        in1 : inout std_logic;
        in2 : inout std_logic;
        out1 : out std_logic;
        out2 : out std_logic;
        testline : in std_logic;
        testclk : in std_logic;
    );

end toplevelobject;


This is supposed to switch between the real functionality and the test mode depending on the state of ""testline"" (high means test). Note that the test module actually uses everything but clk as an output, even in_*.

architecture test_passthrough of toplevelobject is
    -- This is the actual module
    component real_module
    port (
        in1 : in std_logic;
        in2 : in std_logic;
        out1 : out std_logic;
        out2 : out std_logic;
        clk : in std_logic;
        -- Note absence of ""testline""
    );
    end component;

    -- This is the test module, which will just put the clk
    -- signal out on all pins, or play a tune, or something
    component test_module
    port (
        in1 : out std_logic;
        in2 : out std_logic;
        out1 : out std_logic;
        out2 : out std_logic;
        testclk : in std_logic;
        -- Note absence of ""testline""
    );
    end component;

    signal real_in1, real_in2 : std_logic;
    signal real_out1, real_out2 : std_logic;

    signal test_in1, test_in2 : std_logic;
    signal test_out1, test_out2 : std_logic;

begin

    real_0 : real_module port map (
        in1 =&gt; real_in1,
        in2 =&gt; real_in2,
        out1 =&gt; real_out1,
        out2 =&gt; real_out2,
        clk =&gt; clk,
    );

    test_0 : test_module port map (
        in1 =&gt; test_in1,
        in2 =&gt; test_in2,
        out1 =&gt; test_out1,
        out2 =&gt; test_out2,
        testclk =&gt; clk,
    );

    -- Ports that are outputs on both don't need
    -- much special attention

    out1 &lt;= real_out1 when testline = '0' else test_out1;
    out2 &lt;= real_out2 when testline = '0' else test_out2;

end test_passthrough;


So I have a few questions:


For the inout ports, should I have one big process with a case ... when statement that switches on testline? Or a process for each I/O with an if statement? Theoretically I figure that many smaller processes are executed concurrently instead of sequentially, but will it actually make a difference to simulation or synthesis? For example:

passthrough_in1 : process(testline, in1, test_in1) is
begin
    if testline = '0' then
        real_in1 &lt;= in1;
    else
        in1 &lt;= test_in1;
    end if;
end process passthrough_in1;



...vs...

    passthrough_all : process(in1, test_in1, in2, test_in2, testline) is

        case testline is
            when '0' =&gt;
                real_in1 &lt;= in1;
                real_in2 &lt;= in2;
            when '1' =&gt;
                in1 &lt;= test_in1;
                in2 &lt;= test_in2;
        end case;

    end process passthrough_all;



Is this a sane approach or is there something simpler?
I'm confused about sensitivity â€?do I need passthrough_in1 (or even passthrough_all to be sensitive to anything other than testline?
Do I need the real_in1/test_in1 to select between the two wrapped entities? Or is there another way to say ""if testline is high, connect test_module output in_1 to the toplevelobject I/O in_1?
","If I understand you correctly your testmodule drives the (badly named - I assume in the real code they make more sense :) in1,2 ports?  

If so, you need to do something like this:

real_in1 &lt;= in1;
in1 &lt;= test_in1 when testline = '1' else 'Z';


That way in non-test-mode the in1 signal will be driven by a 'Z', so the external proper in1 signal can override it.

You can represent this in various other ways (like the processes that you described), all of which should come out being equal in the simulator.  The downside of the ""all in one process"" option is that you'll need to keep what might end up as an enormous sensitivity list up to date.  Doing it one process per signal is just a long winded way of what I did above.

To save some code and copy/paste effort, you could potentially push those two lines of code into an entity of their own and then instance it many times - in that case, I'd put the instance and port map all on one line, but that would offend some coding standards...

This all assumes I've understood the problem correctly!",,,,,
How can I run/control a Java program from within C?,"I am running System Verilog inside of an ASIC simulator.  SV has an import/export mechanism to call C functions from SV, and for SV functions to be called from within C.

I'd like to send realtime-ish (a very slow stream) data from the simulation to a charting program that I will write in Java.  What is the best way to call the Java with periodic updates from the simulator/C program?    ","After a quick glance here : http://java.sun.com/docs/books/jni/html/invoke.html, ...

Then consider this:

The simplest way is to write the data to a file, and write a java program 
to read from the file as it grows.  See this answer: Java IO implementation of unix/linux &quot;tail -f&quot;

Start them both separately, or use system() to start the java program from your plugin, passing the filename as an argument. ",,,,,
System verolog interface with parameters,"I'm trying to build an interface to connect two modules. the interface is in the next format:
interface my_if #( 
    parameter H_WIDTH = 64,
    parameter L_WIDTH = 8
);
logic [H_WIDTH -1:0]  a;
logic [L_WIDTH -1:0]  b;
logic                 ready;
modport in ( input a, input b, output valid);
modport out( output a, output b, input ready);
endinterface;

I need to connect two modules using this interface, while I have different parameters of address and index for every connection (for example, 3 my_if interfaces are connecting my two modules, but every one of them has a different address and index params). how I can make this work?","Your question sounds like you have two modules which connected by 3 interfaces with different params. If I am correct in this guess, the answer is simple.

To use any interface for connecting modules, it has to be instantiated with different correct params:

my_if #(64, 8) if64_8;
my_if #(32,4) if32_4;
my_if #(16,2) if16_2;

now the moduel must be used to handle an interface
module m1(my_if in1, my_if in2, my_if in3);
 // ...
endmodule
module m2(my_if out1, my_if out2, my_if out3);
  // ...
endmodule


and you can connect them:
  m1 m1 (if64_8.in, if32_4.in, if16_2.in);
  m2 m2 (if64_8.out, if32_4.out, if16_2.out);

Here is a compilable example
interface my_if #( 
    parameter H_WIDTH = 64,
    parameter L_WIDTH = 8
);
logic [H_WIDTH -1:0]  a;
logic [L_WIDTH -1:0]  b;
logic valid;
logic ready;
modport in ( input a, input b, output valid);
modport out( output a, output b, input ready);
endinterface

module top;
  my_if #(64, 8) if64_8();
  my_if #(32,4) if32_4();
  my_if #(16,2) if16_2();

  m1 m1 (if64_8.in, if32_4.in, if16_2.in);
  m2 m2 (if64_8.out, if32_4.out, if16_2.out);
endmodule

module m1(my_if in1, my_if in2, my_if in3);
  // ...
  initial begin
    $display(&quot;%0d, %0d, %0d&quot;, $bits(in1.a), $bits(in2.a), $bits(in3.a));
  end
endmodule
module m2(my_if out1, my_if out2, my_if out3);
  // ...
endmodule

The $display statement shows that the widths of the signals is different for every different 'in'.",,,,,
Passing full bus with high impedance on some lines VS passing part of the bus,"Do these codes are the same (in terms of functionality and number of gates) ?
module Test1(
    input enable,
    output [1:0] bus
);
    
    
    assign bus[1:0] = (enable) ? 2'b0 : 2'bZ;
    
endmodule

And this code :
module Test2(
    input enable,
    output [7:0] bus
);
    
    
    assign bus[1:0] = (enable) ? 2'b0 : 2'bZ;
    assign bus[7:2] = 6'bZ;
    
endmodule

If we call them like this :
module Test(
    input enable
);
    
    wire [7:0] bus;
    
    Test1 test1(.enable(enable), .bus(bus));
    // Or :
    Test2 test2(.enable(enable), .bus(bus));
    
endmodule
",Unconditionally assigning 'bZ to a net is essentially a NOP. So the two modules are identical in functionalty.,,,,,
Understanding Verilog Code with two Clocks,"I am pretty new to Verilog
and I use it to verify some code from a simulation program.
Right now I am struggeling if a verilog code snippet because the simulation programm uses 2 clocks ( one system clock and a pll of this ) where two hardware componentes work together, thus synchronize each other:
module something (input data)
reg vid;
always @(posegde sys_clk)
  vid &lt;= data;

always @(posegde pll_clk)
  if (vid)
    // do something

When reading about non blocking assignments it says the evaluation of the left-hand side is postponed until other evaluations in the current time step are completed.
Intuitive I thought this means they are evaluated at the end of the time step, thus if data changes from 0 to 1 in sys_clk tick &quot;A&quot;, this means at the end of &quot;A&quot; and the beginning of next sys_clk tick this value is in vid and so only after &quot;A&quot; the second always block ( of pll_clk) can read vid = 1
Is this how it works or did i miss something ?
Thank you :)","In this particular case it means that

if posedge sys_clk and pll_clk happen simultaneously then vid will not have a chance to update before it gets used in the pll_clk block. So, if vid was '0' before the clock edges (and is updated to '1' in the first block), it will still be '0' in the if statement of the second block. This sequence is guaranteed by use of the non-blocking assignment in the first block
if the posedges are not happening at the same time, then the value of vid will be updated at posedge sys_clk and picked up later at the following posedge of pll_clk.

In simulation non-blocking assignment guarantees that the assignment itself happens after all the blocks are evaluated in the current clock tick. It has nothing to do with the next clock cycle. However, the latter is often  used in tutorials to illustrate a particular single-clock situation, creating confusion.
Also being simultaneous is a simulation abstraction, meaning that both edges happen in the same clock tick (or within a certain small time interval in hardware).",,,,,
Connections between sub modules wrong,"My codes for Alu and Mux:
module alu(input logic [31:0]srca, srcb,
          input logic [2:0] alucontrol,
          output logic zero,
          output logic [31:0]aluout);

logic [31:0] addr, subr, sltr, Andr, Orr;
assign addr = srca + srcb;
assign subr = srca - srcb;
assign sltr = (srca &lt; srcb) ? 1 : 0;
assign Andr = srca &amp; srcb;
assign Orr = srca | srcb;
always_comb 
begin
case(alucontrol)
    3'b010: aluout = addr;
    3'b110: aluout = subr;
    3'b111: aluout = sltr;
    3'b000: aluout = Andr;
    3'b001: aluout = Orr;
    default: aluout = 32'bxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
endcase
zero = (subr == 0) ?  1 : 0;
end
endmodule


module mux2#(parameter WIDTH = 8)
                (input logic [WIDTH-1:0] d0, d1,
                 input logic                 s,
                 output logic [WIDTH-1:0] y);
always_comb
begin
y = s?d1 : d0;
end
endmodule

and their instantiation under the same top module:
alu         alu(srca, srcb, alucontrol, aluout, zero);

mux2 #(32) resmux(aluout, readdata, memtoreg, result);

When I try to connect my 2-1Mux resmux with my alu, the aluout doesn't get connected to resmux
aluout gets suspended
I could solve this by exchanging the order of aluout and zero, but could anybody explain why this happens and how to avoid? Thanks a lot!","There are a number of mechanisms for connecting ports in SystemVerilog. The mechanism you are using is positional. That means each signal connection has to go in the prescribed order that they appear in the module declaration of alu. The way your code is written, the signal zero in module top is connected to last port aluout declared in module alu.
SystemVerilog also has a by_name syntax .portname(signal). You can list all your port connections in any order that way.
alu   alu(.srca(srca), .srcb(srcb), .alucontrol(alucontrol), .alu(aluout), .zero(zero));

When the signal name you are connecting matches the declared port name, you can just use .portname.
alu alu(.alucontrol, .aluout, .zero, .srca, .srcb);

And finally, if all the port names match the signal names, you can use a wildcard, .* as well as list exceptions explicitly
alu alu(.*, .zero(my_zero));
",,,,,
Partitioning combination and sequential logic for reliable and low latency butterfly module for a 4 stage FFT design,"I am building a 4 stage FFT using a simple butterfly module to do the complex multiply and accumulate. I have build the simply butterfly module (see below). I need some input on having the minimal latency and at the same time have a stable design.
module simple_butterfly #(parameter WIDTH =16)(
    input clk, rst,
    input signed [WIDTH-1:0] a_real, a_imag,
    input signed [WIDTH-1:0] b_real, b_imag,
    input [WIDTH-1:0] w_real, w_imag,
    output reg [WIDTH-1:0] p_real, p_imag,
    output reg [WIDTH-1:0] q_real,q_imag
    );

   wire [2*WIDTH-1:0] bw_real_real, bw_imag_imag, bw_real_imag, bw_imag_real; // complex product outputs
   wire [WIDTH-1:0] bw_real, bw_imag;
   wire [WIDTH-1:0] p_real_w, p_imag_w, q_real_w, q_imag_w;


    assign bw_real_real = b_real * w_real; // ac
    assign bw_imag_imag = b_imag * w_imag; // bd
    assign bw_real_imag = b_real * w_imag; // ad
    assign bw_imag_real = b_imag * w_real; // bc 
 
    assign bw_real = bw_real_real[27:12] - bw_imag_imag[27:12] ;  // ac - bd
    assign bw_imag = bw_real_imag[27:12] + bw_imag_real[27:12] ;  // ad + bc 
   
    assign p_real_w = a_real + bw_real;
    assign p_imag_w = a_imag + bw_imag;

    assign q_real_w = a_real - bw_real;
    assign q_imag_w = a_imag - bw_imag;

    always@(posedge clk)
        if(rst) begin
            p_real &lt;= 16'b0;
            p_imag &lt;= 16'b0;
            q_real &lt;= 16'b0;
            q_imag &lt;= 16'b0;
        end else begin
            p_real &lt;= p_real_w;
            p_imag &lt;= p_imag_w;
            q_real &lt;= q_real_w;
            q_imag &lt;= q_imag_w;
        end
endmodule


My question is : Can I keep all the multiplication and vector extraction all as combinational logic and only register the output at each stage, in order to pipeline the design. Can the below be considered as a safe/reliable design, if not can anyone who have experience building DSP modules suggest things to improve in my design.","In FPGA, when designing modules that multiply and add you want those resources to synthesize as DSP blocks.  The DSP blocks have a built in multiply and accumulate.  In the code shown there are 4 multiplies and 4 adds, if this synthesizes as 4 DSP blocks this is the optimum result.   The 'pipeline' (registers) end up built into the DSP blocks, so they are somewhat free.
This is an optimal use of resources, however the part has a finite number of DSP blocks which will limit the size of the transform.
Another limitation is the bit width; the Xilinx DSP48 block max size for multiply is 25x18.  Check other vendors for different sizes.
The goal is to have the synthesis tool infer the DSP block during synthesis.  Generally, best practice is to NOT instantiate a DSP block in Verilog or VHDL RTL code.  There are exceptions, but start with an inference rather than instantiation workflow.
To that end, run the design thru the synthesis flow and look at the utilization.  Optimally 4 DSP blocks and a small number of LUTS would be inferred by synthesis for a 4-point transform.  If it does something else (example using a lot of LUTS and registers) then re-code to utilize the DSP blocks.
Each vendor has coding style recommendations with the goal of mapping to DSP blocks.
This Xilinx paper (DSP blocks used in Xilinx 7-Series) is somewhat helpful.  I say somewhat because it focus on FIR, but many of the same ideas apply to FFT.
https://www.xilinx.com/support/documentation/user_guides/ug479_7Series_DSP48E1.pdf
The clk-&gt;out delay (timing performance) of the DSP block is about that of a reg.
Generally, if a design meets the clock timing constraint after place &amp; route, you are good to go to the lab ( WRT timing :) ).  Some design organizations recommend/require that all module IO are registered.  This may be overkill.  I have found that with 7-series the designs meet timing over the years as the parts get fuller and fuller during development if the number of level of logic is about 10 or less.  This is a rule of thumb not a strict brick-wall rule.  With 12 levels of logic its starting to get marginal, at 15 it might be the critical path in the design.
To determine the levels of logic, open the timing analyzer, right click on the worst timing path on the clock, and 'analyze' or 'show schematic' for the path.  The analysis shows the number of levels of logic.  Vivado can show you a schematic view of the timing path so you can see if it spans several modules to help answer the question 'how much do I need to pipeline this module'.
It also depends on the clock rate, the device and the speed grade.  If you are doing anything &gt; 200MHz in a &gt; 50% utilized device, then additional pipelining and keeping the combinational logic down to 2-3 levels is needed.  This also is my experience and a rough guideline, not a rule or requirement.  There may be FPGAs that have generous timing margins for the fabric at 400 MHz, and are relatively full; I have not seen one though.",,,,,
Assign multiple values to one latch,"I need a latch which can take multiple bus with one enable signal for each and when this signal is high, the latch takes the value of the associated bus, something like this :

I tried this :
module Test (
    input [1:0] load,
    input [15:0] bus,
    output reg [7:0] value
);

    wire [7:0] temp;
    
    assign temp = (load[0]) ? bus[7:0] : (load[1]) ? bus[15:8] : 8'bZZ;
    
    always @(load or temp) begin
        // Latch value
        if (load) begin
            value &lt;= temp;
        end
    end
    
endmodule

and this :
module Test (
    input [1:0] load,
    input [15:0] bus,
    output reg [7:0] value
);
    
    always @(load or bus) begin
        // Latch value
        if (load[0]) begin
            value &lt;= bus[7:0];
        end
        else
        if (load[1]) begin
            value &lt;= bus[15:8];
        end
    end
    
endmodule

And this same warning appears on both (repeated for each bit) :

Warning (13012): Latch Test:test|value[0] has unsafe behavior
Warning (13013): Ports D and ENA on the latch are fed by the same signal load[0]

The only way that I found to avoid these warnings is like this :
module Test (
    input [1:0] load,
    input [15:0] bus,
    output [7:0] value
);
    
    reg [15:0] temp;
    reg index;
    
    always @(load or bus) begin
        if (load[0]) begin
            index &lt;= 0;
        end
        else
        if (load[1]) begin
            index &lt;= 1;
        end
        
        // Latch value
        if (load) begin
            temp &lt;= bus;
        end
    end
    
    assign value = temp[8*index+7 -:8];
    
endmodule

But it's a waste of memory because it saves the two buses instead of one, is it possible to do it with one reg and avoiding these warnings ?","I don't think you can get rid of the warnings in the first two examplesâ€”you have a bonafide race condition between the latch enable and the data feeding the latch. It is more obvious in your first example.
When load goes to 0, temp will be changing to Z ( a don't care most likely 0) at the same time the latch enable goes to 0. Which one happens first is clearly a race.",,,,,
What mechanism prevents System Verilog threads from obtaining a semaphore at the same time?,"There is definitely a good chance I am misunderstanding something. Since System Verilog is an event driven parallel language (with respect to verification), I have trouble understanding the underlying architecture. Mainly I wonder what stops two threads from acquiring the same semaphore at the same instant such that each doesn't &quot;realize&quot; the other has already acquired it. For a language like C, I can understand that (in an RTOS for example) each thread takes turns with the CPU to emulate parallel functionality despite being sequential in nature. Is the same true for System Verilog?
The IEEE standard is a great resource for using the language, but leaves a lot to be desired when it comes to understanding the bridge between hardware and software (when using the language as software for verification I mean).
Thanks for your time and knowledge.","RTOS as well as many other OSs can run multiple threads on multiple cores, so all threads are not necessarily sequential. But similar an RTOS, the concept of SystemVerilog &quot;time&quot; is a globally synchronized resource and is shared among all threads.
Because SystemVerilog is a Hardware Description Language hdl, there is a massive amount of thread parallelism, making multi-core execution a very difficult problem. And there are also multiple divisions of synchronization even within a single time unit (event regions). Although it's possible to disconnect this synchronization between threads for a certain period of time, (like a clock cycle or transaction level boundary) some master thread kernel has to coordinate when that synchronization happens.
The IEEE 1800-2017 SystemVerilog LRM
does not define whether threads execute sequentially or concurrently; only what ordering is guaranteed or not. (Sections 4.6 Determinism and 4.7 Nondeterminism). It's just that there are far more SystemVerilog threads than could every run all concurrently, and the scheduling semantics are written most optimally for the SystemVerilog simulation kernel to manage the threads as if they were all sequential.
Regardless of whether SystemVerilog threads are executing sequentially or concurrently, the handling of semaphore is request is the same. The thread requesting the a semaphore key asks the kernel for the key, and the thread asking for it firstâ€”gets it first. Since the kernel is operating as a single thread itself, it gets to decide who should get the key in a deterministic way.",,,,,
iceprog - Can't find iCE FTDI USB device with Alchitry CU,"I'm trying to upload my build code to my alchitry-CU FPGA board threw apio using iceprog on windows.
apio upload

which then executes
iceprog -d i:0x0403:0x6010:0 hardware.bin

And the output is
init..
Can't find iCE FTDI USB device (device string i:0x0403:0x6010:0).
ABORT.
scons: *** [upload] Error 2

I have installed the libusbk driver and also tested uploading with the same cable on another pc with the standard drivers and the provided IDE Alchitry Labs in combination with iceCube2 but I really wanted to use the open source alternative instead.","Never mind I found the fix. The problem was that the Alchistry CU shows up as two different devices in Zodic when installing the drivers, one as Interface 0 and one as Interface 1 and I didn't see the other one and only installed the libUsbK driver on one of them.",,,,,
How to create a named constant in the SystemVerilog generate block?,"I need to transmit a set of values between the SystemVerilog and VHDL code. To do that, I have to flatten the SV structures into the bit vectors, transmit the bit vectors, and rebuild the structures at the VHDL side.
Unfortunately, I have faced a serious problem at the SV side. My &quot;flattener&quot; has the following code:
   generate
    for(genvar i=0;i&lt;nlinks;i++)
      for(genvar j=0;j&lt;2;j++)
        begin
        const int base = 2 * i + j;
           assign vf[base] = lct_aligned[i][j].vf;
           assign hs[(8*base+7):8*base] = lct_aligned[i][j].hs;
           assign wg[(7*base+6):7*base] = lct_aligned[i][j].wg;
           assign ql[(4*base+3):4*base] = lct_aligned[i][j].ql;
           assign cp[(4*base+3):4*base] = lct_aligned[i][j].cp;
           assign lr[base] = lct_aligned[i][j].lr;
           assign bc0[base] = lct_aligned[i][j].bc0;
           assign bx0[base] = lct_aligned[i][j].bx0;
           assign ser[base] = lct_aligned[i][j].ser;
           assign cid[(4*base+3):4*base] = lct_aligned[i][j].cid;          
        end 
     endgenerate   

Unfortunately, it gives &quot;base is not a constant error&quot; in each &quot;assign&quot; line.
When I replace &quot;base&quot; with &quot;(2*i+j)&quot; the code compiles correctly, but is significantly less visible and mantainable.
   generate
    for(genvar i=0;i&lt;nlinks;i++)
      for(genvar j=0;j&lt;2;j++)
        begin
           //const int base = 2 * i + j;
           assign vf[(2*i+j)] = lct_aligned[i][j].vf;
           assign hs[(8*(2*i+j)+7):8*(2*i+j)] = lct_aligned[i][j].hs;
           assign wg[(7*(2*i+j)+6):7*(2*i+j)] = lct_aligned[i][j].wg;
           assign ql[(4*(2*i+j)+3):4*(2*i+j)] = lct_aligned[i][j].ql;
           assign cp[(4*(2*i+j)+3):4*(2*i+j)] = lct_aligned[i][j].cp;
           assign lr[(2*i+j)] = lct_aligned[i][j].lr;
           assign bc0[(2*i+j)] = lct_aligned[i][j].bc0;
           assign bx0[(2*i+j)] = lct_aligned[i][j].bx0;
           assign ser[(2*i+j)] = lct_aligned[i][j].ser;
           assign cid[(4*(2*i+j)+3):4*(2*i+j)] = lct_aligned[i][j].cid;        
        end 
     endgenerate   

Is there any way to define constants for complex expressions in the SystemVerilog generate blocks?",A const variable is not really a constant. It's a variable with a write once at run-time value. A parameter or localparam is a compile time constant. Simply replace const with parameter.,,,,,
How to check in SystemVerilog that signal went high during simulation using ModelSim,"I need to check, whether during the testbenching the particular signal went at least for a single clock cycle to logic 1.
I've tested following asserts, which shall be equivalent:
    initial assert property (
        @(posedge clk_tree_x.ClkRsBST_ix.clk)
            s_eventually TS.TSUpdated) else
      $error(&quot;Was not active&quot;);

and
   initial begin
      assert property (@(posedge clk_tree_x.ClkRsBST_ix.clk)
               strong(##[*] TS.TSUpdated)) else
    $error(&quot;Was not active&quot;);
   end

In simulation using Mentor ModelSim SE64 2021.1 the results are extremely weird.
On first simulation pass the simulation completely ignores this assert. On  second simulation pass ModelSim apparently uses results of previous simulation to announce before even the newly run simulation happens that the assert triggered:
#    Time: 2005087500 ps Started: 5 ns  Scope: tb_bst_provider.DUT.fook File: bst_provider.sv Line: 669
# ** Warning: (vsim-8777) Breakpointing based on severity while evaluating concurrent assertion is not supported.
#    Time: 2005087500 ps  Iteration: 0  Region: /tb_bst_provider/DUT File: bst_provider.sv

Not sure whether this is consistent behaviour to all strong properties, but it is hardly useful for any sort of unit testing, as the tests never run twice using the same parameters.
Is there any way how to assert that 'signal is not present through the simulation run', which actually works with modelsim?","I am not sure if you can do it with an assertion. You can detect not active signal using an assertion coverage. In any case you should not place an assertion in the initial block.
Potentially checking for activity can be done without using an assertion as in the following example.
  always @(posedge clk) begin
    if (sig == 1)
      active &lt;= 1;
  end

  final begin
    if (!active)
       $error(&quot;was not active&quot;);
    else
      $info (&quot;it was active&quot;);
  end

Just make sure that you have a normal exit from simulation or final might not be executed at all in case of interrupts.",,,,,
How to use regs to modify wires?,"I am kind of new to Verilog and was wondering how I can modify wires. I know that you cannot modify wires inside always blocks.
I've seen something like this where you can declare some regs and assign the wire to those regs (which you can then modify the reg to modify the wire?)
module something
#(parameter D_W = 8)
(
    input  wire clk,
    input  wire rst,

    output wire valid,
    output wire [D_W-1:0] data,
);

reg valid_rg = 0;
reg [D_W-1:0] data_rg = 0;
    
assign valid = valid_rg;
assign data  = data_rg;

I was wondering how to do something like that for a wire like:
wire    [7:0] wire_a  [7:0];

Initially my guess would be to have something like this
reg [7:0] wire_a_rg [7:0];
assign wire_a[7:0] = wire_a_rg[7:0];

But I have a feeling it might be wrong. How could I approach this?","There's no need to use wires in SystemVerilog unless you need to model bi-directional buses, or any kind of circuitry with multiple drivers. You can write
module something
#(parameter D_W = 8)
(
    input  logic clk,
    input  logic rst,

    output logic valid,
    output logic [D_W-1:0] data,
);

And then you can make procedural assigmemnts to valid/data in an always block, or a continuous assign statement (but not both).
BTW, SystemVerilog prefers the use of logic keyword over synonym reg.
You should read my post about the difference between nets and variables.",,,,,
"Different struct elements ""written by continuous and procedural assignments""","Why do I get :
# ** Error (suppressible): testbench.sv(27): (vopt-12003) Variable 'ar[0].subar[0]' written by continuous and procedural assignments. See testbench.sv(19). 
# ** Error (suppressible): testbench.sv(27): (vopt-12003) Variable 'ar[0].subar[1]' written by continuous and procedural assignments. See testbench.sv(19). 
# ** Error (suppressible): testbench.sv(27): (vopt-12003) Variable 'ar[0].subar[2]' written by continuous and procedural assignments. See testbench.sv(19). 
# ** Error (suppressible): testbench.sv(27): (vopt-12003) Variable 'ar[0].subar[3]' written by continuous and procedural assignments. See testbench.sv(19). 
# ** Error (suppressible): testbench.sv(27): (vopt-12003) Variable 'ar[1].subar[0]' written by continuous and procedural assignments. See testbench.sv(19). 
# ** Error (suppressible): testbench.sv(27): (vopt-12003) Variable 'ar[1].subar[1]' written by continuous and procedural assignments. See testbench.sv(19). 
# ** Error (suppressible): testbench.sv(27): (vopt-12003) Variable 'ar[1].subar[2]' written by continuous and procedural assignments. See testbench.sv(19). 
# ** Error (suppressible): testbench.sv(27): (vopt-12003) Variable 'ar[1].subar[3]' written by continuous and procedural assignments. See testbench.sv(19). 

for this code:
module tb;

logic clk;

struct {
  struct {
    logic seq;
    logic assig;
    logic seq2;
  } subar [4];
} ar [2];


always_ff @(posedge clk) begin
  for (int i=0; i&lt;2; i++) begin
    for (int j=0; j&lt;4; j++) begin
      ar[i].subar[j].seq &lt;= '1;
    end
  end
end

generate
  for (genvar i=0; i&lt;2; i++) begin
    for (genvar j=0; j&lt;4; j++) begin
      assign ar[i].subar[j].assig = '1;
    end
  end
endgenerate

always_ff @(posedge clk) begin
  for (int i=0; i&lt;2; i++) begin
    for (int j=0; j&lt;4; j++) begin
      ar[i].subar[j].seq2 &lt;= '1;
    end
  end
end

endmodule

All the three logics are independent inside the structure and they aren't assigned in two different blocs.
EDA Playground: https://www.edaplayground.com/x/qYZ9
Replacing the generate/assign with always_comb
always_comb begin
  for (int i=0; i&lt;2; i++) begin
    for (int j=0; j&lt;4; j++) begin
      ar[i].subar[j].assig = ar[i].subar[j].seq;
    end
  end
end

Replacing the generate with assign with an always_comb bloc gives a different result because all the *.seq signals are X.
Each assig = seq are all independent between each i and j iteration.
Why is this invalid?
Not being able to use a structure to group signals is excessively annoying...","The error message is because of the rather pessimistic definition of Longest static prefix in section 11.5.3 of the IEEE 1800-2017 SystemVerilog LRM. Basically, since i is a variable index, the long static prefix of ar[i] is ar and any array or struct selects succeeding that are irrelevant. Tools have been treating this more optimistically, but that has been a gradual process.
You can either suppress the error globally, or rewrite the code moving the for loop out of the block into a generate-for loop.
module tb;

logic clk;

struct {
  struct {
    logic seq;
    logic assig;
    logic seq2;
  } subar [4];
} ar [2];

for (genvar  i=0; i&lt;2; i++) begin
  for (genvar  j=0; j&lt;4; j++) begin
always_ff @(posedge clk) begin
      ar[i].subar[j].seq &lt;= '1;
    end
  end
end

  for (genvar i=0; i&lt;2; i++) begin
    for (genvar j=0; j&lt;4; j++) begin
      assign ar[i].subar[j].assig = '1;
    end
  end

for (genvar  i=0; i&lt;2; i++) begin
  for (genvar  j=0; j&lt;4; j++) begin
    always_ff @(posedge clk) begin
      ar[i].subar[j].seq2 &lt;= '1;
    end
  end
end

endmodule
",,,,,
Not a valid resolution function for type bit_vector,"I need to write a resolution function for a bit_vector. I understand that bit and bit_vector are unresolved types in VHDL, and thus whenever you have multiple drivers for one of these signals, a resolution function is required.
I've successfully implemented a resolution function for a bit, however am struggling to implement for a bit_vector. This is the error I receive when performing a syntax check: Line 44: resolve_result is not a valid resolution function for type bit_vector.
Here is the resolution function:
function resolve_result(d: bit_vector) return bit_vector is
    variable combined: bit_vector(15 downto 0) := &quot;0000000000000000&quot;;   
    begin 
        combined(7 downto 0) := d(7 downto 0);
        combined(15 downto 8) := d(15 downto 8);
        return combined;
end function resolve_result;

subtype resolve_result_bit_vector is resolve_result bit_vector;
signal rResult: resolve_result_bit_vector;

The error, Line 44, is on the subtype declaration. This is within the architecture definition of a testbench.
I understand that the std_ulogic_vector type will automatically resolve; is changing the type of this signal all that is required? I don't need the functionality of std_ulogic_vector hence why I am only using bit_vector.
Thank you.","As you already wrote a resolution function for type bit you probably know what resolution functions look like, what parameter they take and what value they return. And you probably understand that your function cannot be a resolution function for the unconstrained bit_vector type. For instance it always returns a 16-bits bit_vector and can thus not be used for, let's say, an 8-bits bit_vector. It is not the only reason: for such a function the parameter should be an unconstrained array of bit_vector, that is, an array of arrays.
Anyway, you don't really need all this. If you already have a resolution function foobar for type bit simply declare:
subtype resolved_bit_vector is (foobar) bit_vector;

If you really want to define a resolution function for 16-bits bit_vector, let's say an or-like one, you can try something like:
subtype b16 is bit_vector(15 downto 0);
type b16_array is array(natural range &lt;&gt;) of b16;

function foobar(v: b16_array) return b16 is
  constant n: natural := v'length;
  constant c: b16_array(0 to n - 1) := v;
begin
  if n = 0 then
    return (15 downto 0 =&gt; '0');
  elsif n = 1 then
    return c(0);
  else
    return foobar(c(0 to n - 2)) or c(n - 1);
  end if;
end function foobar;

subtype resolved_b16 is foobar b16;
",,,,,
Rising Edge Led Counter Problems in VHDL,"I'm new to fpga and VHDL in general (I'm using a fpga aprox. 2 weeks now). I am trying to create a project that lights up LEDs in order. First of all I made a falling edge detector for the button. And then I created a std_logic_vector for LEDs. But I can't detect a signal change in fallen edge detection. Because of that I can't change LED state. There is my testbench for simulation. I don't have any idea what's going on. Thanks for your answers and sorry for my bad English.
Code:
library ieee;
use ieee.std_logic_1164.all;

entity sequential_led is
end sequential_led;

architecture seq_led of sequential_led is
    signal clk : std_logic := '0';
    --signal rst : std_logic := '1';
    --signal rstb : std_logic := '1';
    signal i : natural := 0;
    signal dus_next : std_logic := '0';
    signal dusen : std_logic := '0';    
    signal button : std_logic := '0';
    signal led : std_logic_vector(7 downto 0);
begin
    clk &lt;= not clk after 1 ns;
    button &lt;= not button after 2 ns;
    falling: 
    process begin
    if rising_edge(clk) then
        dus_next &lt;= button;
    end if;
    wait for 100 ns;
    end process falling;
    dusen &lt;= (not button) and dus_next;
    
    led_changes:
    process begin
    if dusen = '1' then
        i &lt;= i + 1;
        if i = 7 then
            i &lt;= 0;
        end if;
    end if;
    led(7-i) &lt;= '0';
    led(i) &lt;= '1';
    wait for 100 ns;
    end process led_changes;
    
end architecture;
","UPDATE: First of all very big thanks to DomasAquinas and Martin Thompson! After 3 days of work, I finally finished my little LED project.
Change: I've made sure all of processes has a sensivity trigger.

For falling process I've included 'clk' signal for sensivity.


For led_change process I've included 'dusen' signal for sensivity.

Code:
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity sequential_led is
    port(
        clk     : in std_logic;
        button  : in std_logic;
        led     : out std_logic_vector(7 downto 0) := (others =&gt; '0') 
    );
    signal dus_next : std_logic;
    signal i        : natural range 0 to 7;
    signal dusen    : std_logic := '0';

end sequential_led;

architecture seq_led of sequential_led is
begin
    falling: 
    process(clk) begin
    if rising_edge(clk) then
        dus_next &lt;= button;
    end if;
    end process falling;
    dusen &lt;= (not button) and dus_next;
    
    led_changes:
    process(dusen) begin
    if dusen = '1' then
        i &lt;= i + 1;
        if i = 7 then
            i &lt;= 0;
        end if;
        led(i) &lt;= '1';
        led(i+7) &lt;= '0';

    end if;
    end process led_changes;
    
end architecture;   
",,,,,
system verilog interface in module port list,"I want to have the system verilog interface in a seperate file with different modports.
The interface has to be used by sv modules in other files.
Just like packages can be imported into module files, how can this be done for interfaces?
Thanks","You don't need any import like you do with packages.
Just compile interface with modports in the same library of other sv modules.

Edit to add file examples:
iface.sv
interface iface (input logic clk);
  logic s;
  modport slave (
    input s
  );
endinterface

ab.sv
module ab( iface.slave ins0 ); 
endmodule
",,,,,
"Will 'typedef logic' generate a register when using it instead of a 'wire', in SystemVerilog?","Having the following SystemVerilog code:
module my_module(
  input  wire [31:0] my_net
);
  ...
endmodule
...
...
wire [31:0] my_net;

assign my_net = ...;

my_module m(my_net);

What are the consequences (at synthesis time) of change the my_net declaration by:
typedef logic [31:0] my_net_t; // This is actually no longer a net, but a variable.

module my_module(
  input  my_net_t my_net
);
  ...
endmodule

my_module m(my_net);
...
...
wire [31:0] my_net;

assign my_net = ...;

my_module m(my_net);

I mean, logic is a variable, not a net, therefore, will the synthesizer generate a register for my_net?","Incorrect. logic is a data type that can be applied to a variable or net.
input  wire [31:0] my_net
input  my_net_t my_net

are implicitly the same as
input  wire logic [31:0] my_net
input  wire my_net_t my_net

When internal to a module
logic v;
wire w;

are implicitly
var logic v;
wire logic W;

But regardless of my_net being a variable or net, a continuous assignment to my_net does not create a register.",,,,,
Scala Chisel. BlackBox with 2-d verilog ports,"In my scala chisel project I need to insert system-verilog blackbox with 2-d arrays of ports. For example:
module something_bb(
  input  [`somtething_width-1     :0] something_i      [`somtething_num-1    :0],
  output [`somtethingelse_width-1 :0] somethingelse_o  [`somtethingelse_num-1:0]
)

---
endmodule

Can you tell me the easiest way to do it?","Unfortunately that is not supported by Chisel. You will have to write a Verilog wrapper, that exposes your 2D ports as 1D ports and then instantiate the wrapper as a Chisel blackbox.",,,,,
How to get rid of truncate warnings when initializing a parameter-sized array?,"I am aware that I can use '1, 'b1100, 'd12, ... ,  to create arrays with sizes based on context, and if I initialize the array with a constant, there are no warnings. For example
wire[DEPTH-1:0] read_addr_next = 'd1;

However, if I write instead
wire[DEPTH-1:0] read_addr_next = read_addr + 'd1;

Triggers the following warning on quartus
Warning (10230): Verilog HDL assignment warning at fifo_controller.sv(9): truncated value with size 32 to match size of target (4)

Is there a straightforward way to fix the warning without creating a new constant or resorting to {DEPTH-1{0},1'b1}?
Something like
wire[DEPTH-1:0] read_addr_next = read_addr + DEPTH'd1;
","In System Verilog 'd1 is a 32-bit constant. So, the message is reasonable. Should quartus print it or not in this case is another question. Other compilers are silent here.
Your concat example is a good one and it is a usual way to handle this kind of issues. However, in this case you should be able to use a single-bit constant: read_addr_next = read_addr + 1'd1;. I hope it will make the message go away.
Another way is utilizing text macros:
`define DEPTH 4
...
read_addr_next = read_addr + `DEPTH'd1;

In SystemVerilog you can use typedefs to handle it, but it is not the best way either and I do not know if quartus will be silent in this case or not.
  typedef logic [DEPTH-1:0] dtype;
  wire[DEPTH-1:0] read_addr_next = read_addr + dtype'('d1);

And finally, there might be a way in quartus to turn off this message.",,,,,
"How to pass ""with clause"" to a function in systemverilog","I have a templated class that contains a queue and has implemented similar queue functions like &quot;push_back, pop_front, delete, etc.&quot; Basically I want this class to behave like a queue, but also do some additional bookkeeping (coverage and some checking) when adding or removing elements from the queue. When I'm using objects of this class, I need to perform a &quot;find_index&quot; on the queue, so I'm trying to implement a &quot;find_index&quot; function in my class that does the same, but I'm not able to figure out the syntax to pass a &quot;with clause&quot; to the function. I'm not sure if this is even possible in SystemVerilog. If not, is there a different solution I could use to achieve this behavior?
class my_queue #(type T);
    typedef T queue_t[$];
    typedef int int_q[$];
    protected queue_t m_queue;

    void push_back(T item);
        m_queue.push_back(item);
        //Other stuff
    endfunction

    function T pop_front();
       //Other stuff
       return m_queue.pop_front();
    endfunction

    //TODO: Get this working
    //function int_q find_index(/*with_clause_t with_clause*/);
    //    return m_queue.find_index(x) with (with_clause);
    //endfunction
endclass
","You can implement what is called a policy class or decorator design pattern. Basically it is a class whose only purpose is to act as virtual method that you pass as an argument to a function.
You know that function will be passed an item of the array and return true or false. That becomes the prototype
interface class find_index_policy#(typeT);
  pure virtual function bit f(T item);
endclass
...
function int_q find_index(find_index_policy fip);
       return m_queue.find_index(x) with (fip.f(item));
endfunction


Then you implement that class, construct an object of it and pass it to the find_index method of your class
class lt_policy#(type T = int) implements find_index_policy#(T);
  int limit;
  function new(int l); limit = l; endfunction 
  function bit f(T item);
    return item &lt; limit; // equation you want your queue class to use
  endfunction
endclass

lt_policy lt= new(5);

q = my_q.find_index(lt);
",,,,,
how does phase mechanism works in UVM?,"I'm trying to understand UVM phasing mechanism especially in connect_phase().
UVM_INFO testbench.sv(14) @ 0: e2.c1.gc1 [connect] phase
UVM_INFO testbench.sv(14) @ 0: e2.c1.gc2 [connect] phase
UVM_INFO testbench.sv(39) @ 0: e2.c1 [connect] phase
UVM_INFO testbench.sv(14) @ 0: e2.c2.gc1 [connect] phase
UVM_INFO testbench.sv(14) @ 0: e2.c2.gc2 [connect] phase
UVM_INFO testbench.sv(39) @ 0: e2.c2 [connect] phase
UVM_INFO testbench.sv(62) @ 0: e2 [connect] phase

Not like build phase, in connect_phase, the connect phase executed from bottom-up.
Someone says that it's not the matter after build_phase() done. But in hte every single simulation, I can see the bottom-up way.
I think there is some special or inevitable reason to do that, would you please help me for understand Why a connect phase and else phase in a UVM execute from bottom-up except build and finish phase?","Technically the build_phase is a breadth-first ordering. The ordering of the build_phase is dictated by the fact that the parent's build_phase creates its children, so naturally the parent must execute its phase before the children's phase.
You should only concern yourself with the ordering between phases, not ordering between components within the same phase. The connect_phase only requires that the components you are connecting have been constructed first and does not care about the order you make connections.
You might want to read this discussion about phase ordering with an attached example for more details.",,,,,
wire output can be used as an inside variable?,"i am learning verilog and i am doing practice questions on https://hdlbits.01xz.net/wiki.
one of the questions is:
picture of the question
so my answer was:
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out,
    output out_n   ); 
    
    wire and_ab;
    wire and_cd;
    wire or_out;
    and(and_ab,a,b);
    and(and_cd, c, d);
    or(or_out, and_ab, and_cd);
    assign out= or_out;
    not(out_n,or_out);
endmodule

which is correct without any doubt, but their answer is:
module top_module (
    input a,
    input b,
    input c,
    input d,
    output out,
    output out_n );
    
    wire w1, w2;        // Declare two wires (named w1 and w2)
    assign w1 = a&amp;b;    // First AND gate
    assign w2 = c&amp;d;    // Second AND gate
    assign out = w1|w2; // OR gate: Feeds both 'out' and the NOT gate

    assign out_n = ~out;    // NOT gate
    
endmodule

my question is how can it be possible they use 'output' wire as an 'input' to an assign in the same module? its not reg to hold it value, not that i know if you can do it with reg as an 'output' type.","Verilog and SV allow the reading of outputs from within a module.
It is different than VHDL which does not allow the same.",,,,,
Adding large numbers in FPGA in one clock cycle,"If I have a VHDL adder which adds two numbers together:
entity adder is
    port(
        clk : in std_logic;
        sync_rst : in std_logic;
        signal_A_in : in signed(31 downto 0);
        signal_B_in : in signed(31 downto 0);
        result_out : out signed(31 downto 0)
    );
end adder;

I have two options, one is to concurrently sum signal_A_in and signal_B_in together as so:
architecture rtl of adder is

begin

result_out &lt;= signal_A_in + signal_B_in;

end rtl;

The other is to perform the addition in a clocked process as so:
architecture rtl of adder is

begin

myproc1 : process(clk, sync_rst)
begin
    if clk = '1' and clk'event then
        if sync_rst='1' then
            result_out &lt;= (others=&gt;'0');
        else
            result_out &lt;= signal_A_in + signal_B_in;
        end if;
    end if;
end process;

end rtl;

So option B will have a single clock cycle delay compared to option A. However does it guarantee that the result will be ready in one clock cycle (i.e. to meet timing).
The reason I am asking this is because I am getting a timing failure on my design which utilises option A; concurrent summation. I believe that such a methodology is OK for smaller size numbers because the combinatorial logic delay is lower but when the numbers start getting larger the delay increases and the design fails timing. How does the synthesis tool cope with this and does putting the expression in a clocked process solve the issue?","When you write something like signal_A_in + signal_B_in; that is combinatorial logic for an adder. Each FPGA will have different amount of time it takes for signals propagate through wires to+from the adder, and the adder itself.
When you do something like
if clk = '1' and clk'event then
    result_out &lt;= signal_A_in + signal_B_in;

As you noted you are now creating a 1 cycle delay by inferring a register.
So now, no matter what your path ends right after your adder sending the result into a register called result_out. Which is why your timing improved. Ex. as shown the path is likely just for your adder - giving you plenty of time and you pass timing. (but be careful adding a register != guaranteed to meet timing).
Timing is worse in your first example and fails because it does not infer a register.
Now not only does your signal need to get across the signal_A_in + signal_B_in adder logic in the clock cycle time - BUT ALSO needs to get across whatever result_out is driving (maybe more adders, other logic somewhere else etc). Your timing path is AT LEAST as long you adder - and probably longer since you didnt break up the path with a register.
Often times even larger adders are done not in 0 cycles (comb. logic) or 1 cycle(with a register output) but over N cycles as a pipelined operation.
This is mostly for you the human to fix - but some synthesis tools can do small retiming of circuits to help.",,,,,
non-blocking assignment to a variable twice in a always block gives unexpected answer,"I'm trying to write a Verilog module and a section of code is something like this:
input wire [7:0] data_in
reg [199:0] buffer;
.
.
.
always @(posedge clk) begin
    buffer[119:112] &lt;= data_in; //place data_in to a specific part of buffer
    buffer &lt;= buffer &lt;&lt; 8; //logical left shift the buffer
end


but the problem is the first line of always block is ignored (after each clk posedge)! in another word, data_in doesn't place in buffer[119:112] and buffer always remain 200'b0!
the first question is what is the the cause?
and the second question is how can i do that what i want?","You have to look at this from the point of view of the hardware design. always @(posedge clk) represents a flop. The only thing it does, is saving values at the clock edge. The data itself is prepared with some combinatorial logic before. In your case, assigning data_in to some bits as well, as the shift are the parts of the combinatorial world.
Saying that, you can write your model as the following:
   reg [199:0] buffer_in, buffer_shifted;
   reg [7:0]   data_in;
   reg         clk;   

   always @* begin
      buffer_in = buffer;
      buffer_in[119:112] = data_in;
      buffer_shifted = buffer_in &lt;&lt; 8;
   end
   always @(posedge clk)
     buffer &lt;= buffer_shifted;

First two statements in the above always block are really the same as the following
      buffer_in = {buffer[199:120], data_in[7:0], buffer[111:0]};

And now you can collapse all of this and even move it to the statement which models the flop itself. The nature of these statements will still be the same, combinatorial logic, but you can get rid of intermediate variables:
   always @(posedge clk)
     buffer &lt;= {buffer[199:120], data_in[7:0], buffer[111:0]} &lt;&lt; 8;

Adding a testcase
module top;
   reg [7:0]   data_in;
   reg         clk;
   reg [199:0] buffer;
   
   always @(posedge clk)
     buffer &lt;= {buffer[199:120], data_in[7:0], buffer[111:0]} &lt;&lt; 8;
   
   initial begin
      clk = 0;
      buffer = 0;
      data_in = 4'h1;
      #13
        data_in = 4'h2;
   end
   
   always 
     #5 clk = ~clk;
   
   initial 
     #20 $finish;
   
   always @*
     $display(&quot;%3t&gt; %h_%h&quot;, $time, buffer[199:112], buffer[111:0]);
endmodule
",,,,,
"This performs the Or8Way function, Why is the or1out[1] 0?","Shouldn't it be 1 ( 1or1 = 1; 1or0 = 1)
","Or8way takes a 8bit bus as input and outputs a single bit bus. That bit is 1 if any of the bits in the input are 1, and 0 if all of the bits in the input are 0. Thus, there really is no or1out[1]. There is only or1out, a single-bit signal.
You can confirm this by looking at the definition comment for Or8Way:
/**

8-way Or:
out = (in[0] or in[1] or ... or in[7])
*/
",,,,,
Can't output results of calculations,"I'm trying to output the result of some multiplications and adders. As far as I can tell I've coded everything correctly (system compiles, seems consistent with examples I've seen) but it doesn't output the values of any assigned/calculated variables. Clearly there is something wrong or missing.
I've pasted my code below:

module multiplier_4x4(

logic [1:0] a,b,
output logic [3:0] c,
logic [3:0] p,
input logic cin = 0,
output logic cout = 0
);

assign a = 2'b11;
assign b = 2'b11;

assign c[0] = a[0] &amp; b[0];
fulladder FA1(a[1]&amp;b[0], a[0]&amp;b[1], 1'b0, c[1], p[0]);
fulladder FA2(b[1]&amp;a[1], 1'b0, cin, c[2], p[1]);
assign c[3] = p[1];

initial begin

    $display(&quot;Output %d&quot;, c[1]);
    $display(&quot;Output %d&quot;, c);
    $display(&quot;Output %d&quot;, a);
    $display(&quot;Output %d&quot;, a[0]);
    $display(&quot;Output %d&quot;, 1'b1);
end

endmodule


module fulladder(input logic a, b, cin,
                 output logic s, cout);
  wire p, g;
  assign p = a ^ b;
  assign g = a &amp; b;
  assign s = p ^ cin;
  assign cout = g | (p &amp; cin);
endmodule


The display lines output the following (in order of appearance):
x
x
x
x
1

I would have expected the x values to represent actual numbers/variables. Where did I go wrong?","The simulation in the post does nothing because it was running for 0 time.
Make this change so that it runs for at least a single time step before displaying the results:
initial begin
    #1;
    $display(&quot;Output %d&quot;, c[1]);
    $display(&quot;Output %d&quot;, c);
    $display(&quot;Output %d&quot;, a);
    $display(&quot;Output %d&quot;, a[0]);
    $display(&quot;Output %d&quot;, 1'b1);
end

Produces:
# Output 0
# Output  5
# Output 3
# Output 1
# Output 1
",,,,,
Packed array declaration in system verilog,"I came across the below syntax while declaring the packed array .
bit arr [bit[3:0];

My understanding is, Depth of this arr is 16 and width is 1 bit.
But When i try printing the values using the below loop, it doesn't print anything :
foreach(arr[ii])
    $display(&quot;arr[%0d] = %0d&quot;,ii,arr[ii]);

Also, I can able to write &amp; read to any of the indexes like arr[56] = 1 and able to print the same as well without any errors.
Can someone please explain the logic behind this ?","This is an unpacked associative array whose elements are a single bit, and the the index(key) type is a packed array of 4-bits.
Associative array elements do not get allocated until you make an assignment to a particular key index. So the foreach loop will not iterate until there are allocated elements.",,,,,
Can't figure out the correct amount of bits for an output,"Well, my task is to create a n(n is a multiple of 4) bit cla (carry lookahead adder) using 4 bit cla and multiplexers. Specifically, I have to implement the following:

The part that is in brackets has to be repeated as many times as need for the parameter n that is given. My Question is: how should I define the wires r,t and c?
At first I thought the following:
wire [3n/4-3-1:0] c; // without considering the first wire that comes out of the right most cla4
wire [n - 4 - 1:0] r,t;

This does indeed work for n&gt;4 (8,12,16...) but there is an obvious problem when n=4 ([-1:0]).
Is there a way I can get around this? One simple solution would be to have these wires be more bits that needed, but I am stuck trying to think of another solution.","Try this.
localparam M = (N&gt;4) ? (3*N)/4 - 3 : 1;
localparam L = (N&gt;4) ? N-4 : 1;

wire [M-1:0] c;
wire [L-1:0] r,t; 
",,,,,
does statements with in generate block(generate-----end generate) will execute sequentially or concurrently?,"I have used two different modules  in generate loop statement both are inter dependent. so, I want to know to how to execute them sequentially.","Verilog describes behavior of hardware. The hardware is a set of connected devices which all function in parallel. However, connections guarantee that eventually (takes some time) outputs of devices will propagate to the inputs of driven devices which outputs will be updated accordingly, and which will drive their fanout devices.
Verilog simulates this behavior by using event-driven simulation. If an output of a device changes, it will evaluate (or re-evaluate) the devices driven by this output.
Synthesis generates those connected hardware devices from verilog description.
So, no matter in which order you instantiate your modules, the order of evaluation is only defined by their connections. It does not matter if modules are in generate blocks or not. Just make sure that they are connected correctly.",,,,,
Multiply and shift the result in VHDL,"I have two 8-bit unsigned vectors named a and b, and 16-bit unsigned vector called result. I want to compute a * b * 4 and assign it to result. I do not care about overflow because I know that it will not happen for some reason, it is not important. Is the following way correct?
result &lt;= a * b;
result &lt;= result(13 downto 0) &amp; &quot;00&quot;;

(Assume these two lines are in a clocked process.)","No, this will not work. It will just assign to result its previous value left-shifted by 2 positions. This is due to the simulation semantics. To make it short, if you assign several times the same signal in a process, during the same simulation step, the last assignment overrides the others, just like if they did not exist. In your case you can delete the result &lt;= a * b; line, it will behave the same. And of course, synthesizers implement something that has the same behaviour.
Use an intermediate variable, maybe:
process(...)
  variable tmp: unsigned(15 downto 0);
begin
  ...
  tmp := a * b;
  result &lt;= tmp(13 downto 0) &amp; &quot;00&quot;;
  ...
end process;

Variant:
process(...)
  variable tmp: unsigned(17 downto 0);
begin
  ...
  tmp := (a &amp; '0') * (b &amp; '0');
  result &lt;= tmp(15 downto 0);
  ...
end process;

And I recommend finding and reading a good book about VHDL that explains the semantics of the language, especially the difference between variables and signals, the delayed assignment of signals... Note that understanding this will also be very helpful to program with other HDLs like SystemVerilog or SystemC.",,,,,
"Lattice ECP5 UART, no signal on terminal emulator","I followed this tutorial to the letter, but I'll to explain in detail what steps I took exactly. I have an ECP5-evaluation 85k board.

I soldered bridges on R34/R35 (RX/TX) and R21 (connects LED D1 to RXD)
I used my windows installation to run the latest version of FT_PROG. In FT_PROG I went to FT_EEPROM -&gt; Hardware Specific -&gt; Port B -&gt; Hardware and set it to RS232 and hit program. It completed succesfully according to the software.
Then I forwarded the USB port to my virtual box linux machine. It recognizes the board and I can succesfully run verilog files on it.
I ran ./raw_serial.sh to upload raw_serial.v to my board which is supposed to repeatedly print A to the serial monitor.
I then opened minicom on /dev/ttyUSB1 and it recognizes the device, baudrate is set correctly.
I then tried to use cu as follows: sudo chmod 666 /dev/ttyUSB1 &amp;&amp; sudo cu -l /dev/ttyUSB2 -s 115200. It opens a terminal and says it is connected.

Led D1 is lighting up and both terminal programs indicate that the connection is succesful (I tried one of them at a time of course). Nothing is printed to the screen. When I use minicom and reupload raw_serial.v some &lt;?&gt; signs are printed to the screen but that's it. I tried turning echo on and off but nothing seems to work.","The following worked for me and it will probably work for others too. I'm assuming you're using openocd.

Do not use FT_PROG in windows, it doesn't seem to actually flash the FTDI chip. However, it lets you read back the hex dump that was supposed to be flashed to the chip. The hex dump for the unchanged EEPROM as it comes out of the box is as follows:
00000000  01 08 03 04 10 60 00 07 C0 FA 08 00 11 11 9A 10  .....`..Ã€Ãº....Å¡.
00000010  AA 3C E6 12 00 00 00 00 56 00 00 00 00 00 00 00  Âª&lt;Ã¦.....V.......
00000020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000050  00 00 00 00 00 00 02 03 00 00 00 00 00 00 00 00  ................
00000060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000070  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000080  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000090  00 00 00 00 00 00 00 00 00 00 10 03 4C 00 61 00  ............L.a.
000000A0  74 00 74 00 69 00 63 00 65 00 3C 03 4C 00 61 00  t.t.i.c.e.&lt;.L.a.
000000B0  74 00 74 00 69 00 63 00 65 00 20 00 45 00 43 00  t.t.i.c.e. .E.C.
000000C0  50 00 35 00 20 00 45 00 76 00 61 00 6C 00 75 00  P.5. .E.v.a.l.u.
000000D0  61 00 74 00 69 00 6F 00 6E 00 20 00 42 00 6F 00  a.t.i.o.n. .B.o.
000000E0  61 00 72 00 64 00 12 03 46 00 54 00 32 00 55 00  a.r.d...F.T.2.U.
000000F0  59 00 54 00 4A 00 56 00 00 00 00 00 00 00 FC 27  Y.T.J.V.......Ã¼'

I just post this here for future reference, we're not going to use the stock eeprom.

We need to flash the eeprom to RS232-HS mode. To do so, we must first change the hex dump of the eeprom accordingly. To put channel B in RS232-HS mode we need to change the last column of the last row from ' to |. Create a hex file called eeprom_RS232.bin with the following contents:
00000000  01 08 03 04 10 60 00 07 C0 FA 08 00 11 11 9A 10  .....`..Ã€Ãº....Å¡.
00000010  AA 3C E6 12 00 00 00 00 56 00 00 00 00 00 00 00  Âª&lt;Ã¦.....V.......
00000020  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000030  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000040  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000050  00 00 00 00 00 00 02 03 00 00 00 00 00 00 00 00  ................
00000060  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000070  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000080  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00000090  00 00 00 00 00 00 00 00 00 00 10 03 4C 00 61 00  ............L.a.
000000A0  74 00 74 00 69 00 63 00 65 00 3C 03 4C 00 61 00  t.t.i.c.e.&lt;.L.a.
000000B0  74 00 74 00 69 00 63 00 65 00 20 00 45 00 43 00  t.t.i.c.e. .E.C.
000000C0  50 00 35 00 20 00 45 00 76 00 61 00 6C 00 75 00  P.5. .E.v.a.l.u.
000000D0  61 00 74 00 69 00 6F 00 6E 00 20 00 42 00 6F 00  a.t.i.o.n. .B.o.
000000E0  61 00 72 00 64 00 12 03 46 00 54 00 32 00 55 00  a.r.d...F.T.2.U.
000000F0  59 00 54 00 4A 00 56 00 00 00 00 00 00 00 FC 27  Y.T.J.V.......Ã¼|

Now, we need to flash this eeprom to our ECP5 using Anton's method. To do this, first create a file ftdi_RS232.conf with the following contents:
vendor_id=0x403
product_id=0x6010
filename=&quot;eeprom_RS232.bin&quot;
flash_raw=true

With the following command we can flash to our ECP5: ftdi_eeprom --flash-eeprom ftdi_RS232.conf. Should we ever want to revert back to the stock eeprom, we can easily repeat this method with the hex dump given in step 1.

Now it's time to flash the verilog file. However, the device description of the ECP5 has changed from Lattice ECP5 Evaluation Board to Dual RS232-HS. We need to tell openocd to look for that specific device. Start by creating a file ecp5.cfg with the following contents:
# this supports ECP5 Evaluation Board

interface ftdi
ftdi_device_desc &quot;Dual RS232-HS&quot;
ftdi_vid_pid 0x0403 0x6010
# channel 1 does not have any functionality
ftdi_channel 0
# just TCK TDI TDO TMS, no reset
ftdi_layout_init 0xfff8 0xfffb
reset_config none

# default speed
adapter_khz 5000

# ECP5 device - LFE5UM5G-85F
jtag newtap ecp5 tap -irlen 8 -expected-id 0x81113043

Then, create your svf file as you usually do and flash it with the following command:
sudo --preserve-env=PATH env openocd -f ./ecp5.cfg -c &quot;transport select jtag; init; svf raw_serial.svf; exit&quot;


Finally, we can open a terminal to read the serial output of the ECP5. Personally, I like to use minicom: sudo chmod 666 /dev/ttyUSB0 &amp;&amp; minicom -D /dev/ttyUSB0.

One more problem with the raw_serial.v example was that it doesn't use a baudrate of 115200 as the readme suggests but 19200. The clock that is connected to the FTDI chip runs at 12 MHz. If you want a baudrate of 115200 you need to send a bit every 12,000,000 / 115,200 ~= 104 ticks. This means you need to change line 14 to   if (counter == 104) begin.

",,,,,
Is there a way in VHDL to make a series of components?,"Simply put, I have a component &quot; X &quot; and I want to connect 24 of them in a row; obviously means that the output of one is the input of the next one; I could just write them myself with copypaste and link them but I wonder if there is a way to do this elegantly.
I know the instruction for I in N downto 0 generate  but I don't think I can use it to create components in series, it only creates components in parallel, where each one works on a different value of the I parameter, or not ?","The generate statement is indeed what you need. Example if your X component has one input a and one output b of type bit:
entity bar is
end entity bar;

architecture rtl of bar is
  signal c: bit_vector(0 to 24);
  component x is
    port(
      a: in  bit;
      b: out bit
    );
  end component x;
begin
  u0: for i in 0 to 23 generate
    x0: x
    port map(
      a =&gt; c(i),
      b =&gt; c(i+1)
    );
  end generate u0;
end architecture rtl;

The input of the first X instance is c(0) and the output of the last one is c(24).",,,,,
Vitis PetaLinux build cant fetch required files while building an application project,"I want to build a PetaLinux Image for my Ultra96v2.
I followed this guide up until building my application project in Vitis. It looks promising but then while building the application project for my custom platform, Vitis throws this error:
18:08:28 **** Incremental Build of configuration Debug for project dpu_appl_system ****
make all 
Generating bif file for the system project
Executing command '::scw::generate_bif -xpfm /media/user/6b04b610-ff80-4702-a575-b0b1a78fbafb/dpu_pkg/dpu_demo/export/dpu_demo/dpu_demo.xpfm -domains linux_domain -bifpath /media/user/6b04b610-ff80-4702-a575-b0b1a78fbafb/dpu_pkg/dpu_appl_system/Debug/system.bif' on XSCT
sdcard_gen --xpfm /media/user/6b04b610-ff80-4702-a575-b0b1a78fbafb/dpu_pkg/dpu_demo/export/dpu_demo/dpu_demo.xpfm --sys_config dpu_demo --bif /media/user/6b04b610-ff80-4702-a575-b0b1a78fbafb/dpu_pkg/dpu_appl_system/Debug/system.bif --bitstream /media/user/6b04b610-ff80-4702-a575-b0b1a78fbafb/dpu_pkg/dpu_appl/_ide/bitstream/dpu_hardware.bit --sd_file /media/user/6b04b610-ff80-4702-a575-b0b1a78fbafb/dpu_pkg/dpu_appl/Debug/dpu_appl.elf
creating BOOT.BIN using /media/user/6b04b610-ff80-4702-a575-b0b1a78fbafb/dpu_pkg/dpu_appl/_ide/bitstream/dpu_hardware.bit
Running /home/user/Xilinx/Vitis/2021.2/bin/bootgen -arch zynqmp -image /media/user/6b04b610-ff80-4702-a575-b0b1a78fbafb/dpu_pkg/dpu_appl_system/Debug/sd_card_temp/boot.bif -w -o i BOOT.BIN
ERROR:BootGen - syntax error
   Line #13, &quot;/media/user/6b04b610-ff80-4702-a575-b0b1a78fbafb/dpu_pkg/dpu_appl_system/Debug/sd_card_temp/boot.bif&quot;.
... emo/sw/atf,dpu_demo/boot/bl31.elf
              ^
 
[ERROR]  : BIF file parsing failed with code 1
Error writing SD card data : Error when running '/home/user/Xilinx/Vitis/2021.2/bin/bootgen -arch zynqmp -image /media/user/6b04b610-ff80-4702-a575-b0b1a78fbafb/dpu_pkg/dpu_appl_system/Debug/sd_card_temp/boot.bif -w -o i BOOT.BIN'
make: *** [makefile:42: package] Error 1
 
18:08:36 Build Finished (took 7s.643ms)

It specifically shows me, that there is a comma in the path where it searches for the file. The files are available

at the &quot;normal&quot; location, without the &quot;atf,&quot;, &quot;dtb,&quot;, etc

at the &quot;weird&quot; location. I created the path so the requested path exists for every file that throws an error message, like
 /media/user/6b04b610-ff80-4702-a575-b0b1a78fbafb/dpu_pkg/dpu_appl_system/Debug/sd_card_temp/boot.bif&quot;. ... emo/sw/atf,dpu_demo/boot/bl31.elf



I created the path with the weird artefact &quot;arf,dpu_demo&quot;, with the komma in the path, but still it wont work. Is this some kind of problem with Vitis, like some env variables not set correctly, or is the building mechanism just acting weird? I cant resolve this issue, because I am not able to change the paths it is supposed to look for the files. This hinders me in advancing my project. I work on Ubuntu 20.04.
Can anyone help me out here, please? I would really appreciate it!
I asked this question in the Xilinx Community, too, but unfortunately there was no resonance at all.
Thank you so much in advance!","PLEASE READ THE WHOLE ANSWER FOR ACTUAL SOLUTION
I think I got it now, though I did not verify whether the image actually works on my Ultra96v2, yet.
I noticed, that the weird path with commata is inside of the boot.bif and system.bif.
So the first time I tried to build it, the bif wasnt there, but got created (I assume). The bif was ready then but only had a weird path inside, so I took the makefile (you can find it in debug/sd_card), copied it, and just commented out the line GENERATE_BIF_XSCT_CMD = ${GENERATE_BIF} -xpfm ${XPFM_PATH} -domains ${DOMAINS} -bifpath ${BIF_PATH}.
Then I edited the boot.bif and system.bif and changed the atf,boot, uboot,boot, and dts,boot to just boot, so the BootGen wouldnt look into the directories with the commata anymore, but only the boot-directory which was specified.
Once that was set up, I executed the edited makefile in my console, by going into the sd_card-directory and executing the following command:
make -f &lt;your_edited_makefile&gt;

This means, that you cant press &quot;build&quot; in Vitis, it wont work. You build the content on your own and wont get a green check mark beside the project! Then the sd_card-directory was populated with (I assume) all necessary data to boot the Ultra96v2 from SD card. This was the content:

boot.scr
BOOT.BIN
dpu_appl.elf (your application project name, I guess)
README.txt
system.dtb

The underlying issue seem to have been that the ::scw::generate_bif created a path to look after, which didnt exist. Really weird issue, in my opinion.

UPDATE:
I just made some changes to the PetaLinux config with the petalinux-config command and rebuilt everything. Once I go to the Vitis part, I changed the system.bif within Vitis itself, and the project compiled successfully, also populating the sd_card directory, as it seems.

UPDATE 2:
Everything failed, so I tried to get to the *.bif of the Application System project. I opened it (linux.bif) and edited the &quot;atf,&quot;, &quot;dtb,&quot; and &quot;uboot,&quot; out of it. Since this is only created once and references by the following files, this fixed my issue and the build was completed successfully in Vitis. So just ignore my originial answer and update.

I hope this is working and hope it will help some of you.",,,,,
The easiest way to read uvm_object from file given by uvm_object sprint method,"While verrifying VDU(video display unit) I faced next issue.
The VDU gets its settings from uvm_object class and I write thees settings into file using sprint method. Can you recommend me the best way to read this file back into uvm_object. In other words are there a methods inside UVM to read object properties back from the file with uvm_printer format? Or I need to implement this kind of functionality from scratch.
Thank you in advanced.",The UVM provides no mechanism to read back settings output to a file from sprint()â€”you will have to implement this from scratch. You might consider outputting in a simpler format to make reading back easier.,,,,,
Array methods for nested list of class objects,"I've recently transitioned from Specman/e to SystemVerilog and I'm struggling with the limitations of the array methods in SystemVerilog.
I have an array of class objects, which themselves have an array of class objects inside each one.
I want to check if the array has an item, whose sub-array has an item with a certain value.
In Specman this would be simple as so:
struct axi_beat_s {
   addr : int;
};

struct axi_trans_s {
   beat_list : list of axi_beat_s;
};

var axi_trans_list : list of axi_trans_s;
//Populate axi_trans_list, not shown here

//Check if the axi trans list has a trans with a beat with address 0
if (axi_trans_list.has(it.beat_list.has(it.addr == 0))) { //This is the line I want to replicate
    //do something
} else {
    //do something else
};

What is the best way to achieve the same in SystemVerilog?
This is my attempt below, but it involves creating 2 temporary arrays, and several more lines of code. Is there an easier way of doing this?
class axi_beat_s;
    int addr;
endclass

class axi_trans_s;
    axi_beat_s beat_list [$];
endclass

axi_trans_s axi_trans_list [$];
//Populate axi_trans_list, not shown here

axi_trans_s axi_trans_list_temp [$];
axi_beat_s axi_beat_list_temp [$];

foreach(axi_trans_list[idx]) begin
    axi_beat_list_temp = axi_trans_list[idx].beat_list.find with (item.addr == 0);
    if (axi_beat_list_temp.size() &gt; 0)
        axi_trans_list_temp.push_back(axi_trans_list[idx]);
    if (axi_trans_list_temp.size() &gt; 0)
        $display(&quot;Found item with addr 0&quot;);
    else
        $display(&quot;Did not find item with addr 0&quot;);
end


Working example here:
https://www.edaplayground.com/x/RFEk
Similarly Specman has a method 'all' which can be used to collect all matching items, similar to 'find' in SystemVerilog. But again, I can't find based on a nested class object.","You want to use the array reduction methods, not the find method.
The find method returns an array of the same type with the selected set of elementsâ€”it cannot be nested.  If you just want to get a true or false result, the array reduction methods return a single value and can be nested.
initial begin
 // populate list not shown here
  
  if (axi_trans_list.or() with (item.beat_list.or() with (item.addr==0)))
        $display(&quot;Found item with addr 0&quot;);
    else
        $display(&quot;Did not find item with addr 0&quot;);
end 
",,,,,
SystemVerilog Dataflow Modeling Ripple-Adder with array instances,"I've implemented a (working) ripple-carry adder using generation to create 16 different full_adder instances (the full_adder works as intended):
module ripple_adder16 (a, b, cin, sum, cout);

input [15:0] a, b; input cin;
output [15:0] sum; output cout;
wire [15:0] a, b; wire [15:0] sum; wire cout;

// intermediate nets.
// Since the carries cascade, we have to tell
// verilator that it can't &quot;flatten&quot; or whatever.
/* verilator lint_off UNOPTFLAT */
wire [16:0] carries;
/* verilator lint_on UNOPTFLAT */

assign carries[0] = cin;
assign cout = carries[16]; // output.

genvar i;
generate for(i=0; i &lt; 16; i = i + 1)
  begin
    full_adder adder (
      .a(a[i]),
      .b(b[i]),
      .sum(sum[i]),
      .cin(carries[i]),
      .cout(carries[i+1])
    );
  end
endgenerate

endmodule

Now I'm trying to modify the adder so that I can keep an array of adders. Below is an example of the code I'm trying to get working:

input [15:0] a, b; input cin;
output [15:0] sum; output cout;
wire [15:0] a, b; wire [15:0] sum; wire cout;

full_adder adders [15:0] (
  .a(a),
  .b(b),
  .cin(),
  .sum(sum), // output.
  .cout()
);

// DIFFERENCES START HERE
assign adders[0].cin = cin;
assign cout = adders[15].cout; // output.

genvar i;
generate
for(i=0; i &lt; 15; i = i + 1)
  assign adders[i+1].cin = adders[i].cout;
endgenerate
// DIFFERENCES END HERE

endmodule

However, I get a ASSIGNIN error from Verilator (documentation says &quot;Error that an assignment is being made to an input signal. This is almost certainly a mistake, though technically legal.&quot;) on the lines assign adders[0].cin = cin; and assign adders[i+1].cin = adders[i].cout;. I have two questions:

What am I doing wrong here and how can I fix it? The error doesn't make sense to me since the left hand side of both assign equations is an input to a submodule, not an argument to the ripple_adder16 module.
I want to ideally replace the for loop with the following line assign adders[15:1].cin = adders[14:0].cout;, though this is a syntax error by itself. Is there any way to do something like this without straight-up inlining the full_adder?

Thank you!
PS. If it's relevant, the full_adder is implemented entirely with wires.","Array of instances in verilog is a type of a generate block and instantiates a module several times, adding array index to its name and doing some job with ports. Array of instances are usually not well understood and seldom used in behavioral verilog.
Since it is a generate block, you cannot use ranges on array instances. 'adders[15:1]' is illegal. You need to use a generate loop to access them instance by instance. Also 'assign adders[15:1].cin' represents a connection to an internal signal of the submodule instance, not to its input port. So, the compiler is absolutely correct.
You left unconnected ports of the module instances and trying to access their internal signals. It is a bad practice in the first place. To fix it you should figure out how to use port connections instead. An extra code will be needed to reassign vector to satisfy your algorithm, at least around 'carries'.",,,,,
Systemverilog: assignment between unpacked arrays of different order (downto vs. upto),"Assuming two (edit: unpacked) arrays of int are defind with different index ordering (downto vs. upto) but the same size, like
int  a [10:1];
int  b [1:10];

would an assignment between these,
assign b = a;


be illegal, or
result in a &quot;same index&quot; assignment (b[1]=a[1] ... b[10]=a[10]), or
result in a &quot;mirrored index&quot; assignment (b[1]=a[10] ... b[10]=a[1])?

I have not been able to find information in the language reference manual, and two commercial tools are behaving differently.","This is legal code and you are showing an unpacked array, not a packed array. However either way, the range goes from left to right. So your option 3 is the correct behavior. See section 6.22.2 Equivalent types and 7.6 Array assignments in the IEEE 1800-2017 SystemVerilog LRM",,,,,
Encounter [0]: sub bus of an internal node may not be used when implementing Not16 with Not,"When I was implementing Not16 with Not gates:
CHIP Not16 {
    IN in[16];
    OUT out[16];
  
    PARTS:
        Not(in=[0], out=out[0]);
        Not(in=[1], out=out[1]);
        Not(in=[2], out=out[2]);
        Not(in=[3], out=out[3]);
        // ...
        Not(in=[15], out=out[15]);

I got an error &quot;[0]: sub bus of an internal node may not be used&quot; on the first part.
However, implementing this with 16 Nand gates is fine:
Nand(a=in[0], b=in[0], out=out[0]);
// ...

Can someone please point to the issue and difference.
p.s. Using HardwareSimulator from Nand2Tetris","I believe you have typos in your Not components. The in should be in the form in=in[x], not in=[x] as you have it currently.
Conversely, your Nand components are properly formatted.",,,,,
Undeclared identifier in Verliog,"I'm doing some projects in Verilog and I got some problems with this part of the code.
'''
parameter OP_mode = 2'b01;

if(OP_mode == 2'b00)
  parameter k=4;
else if(OP_mode == 2'b01)
  parameter k=8;
      .
      .
      .
reg [k-1:0] inputs;

'''

In this case, the compiler gives me the error &quot;Undeclared Identifier: k&quot; How can I solve this error?","You are declaring your parameters inside an unnamed block of code that cannot be referenced from outside (IEEE 1800-2017 SystemVerilog LRM)

27.5 Conditional generate constructs
Generate blocks in conditional generate constructs can be named or unnamed, and they may consist of only one item, which need not be surrounded by begin-end keywords. Even if the begin-end keywords are absent, it is still a generate block, which, like all generate blocks, comprises a separate scope and a new level of hierarchy when it is instantiated.

parameter OP_mode = 2'b01;
if(OP_mode == 2'b00) begin: block
  parameter k=4;
end
else if(OP_mode == 2'b01) begin : block
  parameter k=8;
end
logic [k-1:0] inputs;

A better way is using a function call:
module top;
  
  parameter OP_mode = 2'b01;
  
  function int f_k;
    if(OP_mode == 2'b00)
       return 4;
    else if(OP_mode == 2'b01) 
       return 8;
    return 0;
  endfunction
  
  parameter k = f_k();
  logic [k-1:0] inputs;
",,,,,
VHDL: How can I execute the for loop once in process statement,"I am new to vhdl and FPGA. For my project I need to use for loop. When I simulate my code it keeps counting and not stopping. I want my code to execute only once, my point is when the loop reaches it's limit code will stop executing. Here is my code.
process(clk)
begin
        
        report &quot;Hello&quot;;
      
        for j in 0 to 3 loop 
            if (j&lt;4) then
              cA &lt;= cA + 1;
              report &quot;middle&quot;;
              exit;

            end if;
        end loop;  
        
        report &quot;done&quot;;
      
 end process;
","As probably explained in your textbook, a VHDL process is an infinite loop. After the last instruction has been executed, the first one executes.
A process with sensitivity list (clk in your case) is equivalent to the same process without sensitivity list but with a final wait statement on the list. Your process is thus equivalent to:
process
begin    
  report &quot;Hello&quot;;
  for j in 0 to 3 loop 
    if (j&lt;4) then
      cA &lt;= cA + 1;
      report &quot;middle&quot;;
      exit;
    end if;
  end loop;  
  report &quot;done&quot;;
  wait on clk;
end process;

So, your loop executes a first time at the very beginning of the simulation and the process suspends, waiting for a clk change. It resumes each time clk changes, executes the loop again, and suspends. If your clock never stops, your process will always be resumed twice a clock period (once on the rising edge and once on the falling edge).
If you want to execute this loop only once at the very beginning of the simulation, remove the sensitivity list and add wait as last statement. A simple wait means &quot;wait forever&quot;. It suspends the process definitely:
process
begin    
  report &quot;Hello&quot;;
  for j in 0 to 3 loop 
    if (j&lt;4) then
      cA &lt;= cA + 1;
      report &quot;middle&quot;;
      exit;
    end if;
  end loop;  
  report &quot;done&quot;;
  wait;
end process;

If, instead, you want to execute the loop and stop only after a particular event happened, say a rising edge of the clock where signal go is asserted high, add another wait statement at the beginning of the process:
process
begin
  wait until rising_edge(clk) and go = '1';
  report &quot;Hello&quot;;
  for j in 0 to 3 loop 
    if (j&lt;4) then
      cA &lt;= cA + 1;
      report &quot;middle&quot;;
      exit;
    end if;
  end loop;  
  report &quot;done&quot;;
  wait;
end process;
",,,,,
Designing T-Flipflop on Quartus,"I'm new to VHDL, and I wanna design a T Flip-Flip that toggles and change Q based on T input, and here is what I have
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;


entity T_flipflop is

   Port ( T : in std_logic;
         CLK : in std_logic;
         Q : out std_logic ); 

end T_flipflop;


architecture Behavioral of T_flipflop is
 begin
  process (CLK) 
  --- The error in the following line
    if (CLKâ€™event and CLK = â€?â€?)then
        Q &lt;= Q when T = '0';
       Q &lt;= not Q when T = '1';
    end if;
end process;
end Behavioral;

But every time I run it on Quartus, I get the following errors, what am I doing wrong?  Thanks in advance
Info: *******************************************************************
Info: Running Quartus Prime Analysis &amp; Synthesis
    Info: Version 18.1.0 Build 625 09/12/2018 SJ Lite Edition
    Info: Processing started: Sun Dec 05 19:20:03 2021
    Info: Version 18.1.0 Build 625 09/12/2018 SJ Lite Edition
    Info: Processing started: Sun Dec 05 19:20:03 2021
Info: Command: quartus_map --read_settings_files=on --write_settings_files=off T_FlipFlop2 -c T_FlipFlop2
Warning (18236): Number of processors has not been specified which may cause overloading on shared machines.  Set the global assignment NUM_PARALLEL_PROCESSORS in your QSF to an appropriate value for best performance.
Info (20030): Parallel compilation is enabled and will use 6 of the 6 processors detected
Error (10500): VHDL syntax error at T_FlipFlop2.vhd(19) near text &quot;if&quot;;  expecting &quot;begin&quot;, or a declaration statement
Error (10500): VHDL syntax error at T_FlipFlop2.vhd(19) near text 
Error (10500): VHDL syntax error at T_FlipFlop2.vhd(19) near text 
Error (10500): VHDL syntax error at T_FlipFlop2.vhd(19) near text 
Info (12021): Found 0 design units, including 0 entities, in source file t_flipflop2.vhd
Error: Quartus Prime Analysis &amp; Synthesis was unsuccessful. 4 errors, 1 warning
    Error: Peak virtual memory: 4836 megabytes
    Error: Processing ended: Sun Dec 05 19:20:11 2021
    Error: Elapsed time: 00:00:08
    Error: Total CPU time (on all processors): 00:00:18
    Error: Peak virtual memory: 4836 megabytes
    Error: Processing ended: Sun Dec 05 19:20:11 2021
    Error: Elapsed time: 00:00:08
    Error: Total CPU time (on all processors): 00:00:18
Error (293001): Quartus Prime Full Compilation was unsuccessful. 6 errors, 1 warning
","process (CLK) needs an is begin.
Change line 19 to:
process (CLK) is begin
Here is a reference for more info:  https://fpgatutorial.com/using-vhdl-process-blocks-to-model-sequential-logic/",,,,,
Left-justify and pad with zeros one input to the size of another input,"I want to compare the size of two inputs in bits, say N and x. I would subtract the number of bits (m = size(N) - size(x)) and concatenate m zeros to the LSB of x. How can I work this out, using Verilog?
For example, the size of N is 16 bits and say x is 1011 (i.e., size of x is 4 bits). So m is 12 bits. The output I want to get is by concatenating 12 bits of 0's to LSB. Output would be 1011000000000000.","I think your use of the word &quot;compare&quot; is confusing. It's sounds like you want to left-justify the assignment of x to N, padding 0's on the right. Normally Verilog right-justifies and 0-pads on the left.
There is no way of doing this readily in Verilog unless you used parameters to declare the sizes of N and x in the first place. Then you could have written:
reg [sizeN-1:0] N;
reg [sizex-1:0] x;
...
N = {x,{sizeN-sizex{1'b0}}};

If you can use SystemVerilog, it has the $bits system function that gives you the introspection on the vectors that Verilog does not have.
N = {x,{$bits(N)-$bits(x){1'b0}}};

It also has a streaming operator that left-justifies assignments directly
N = {&gt;&gt;{x}};
",,,,,
Is it okay to use module's output as an input of submodule in Verilog?,"Hi I'm neophyte in Verilog and I have some question about designing module.
Is it okay to use top module's output as an input of submodule (Taking both module as sequentional logic)?
To my intuition about flip-flop, it seems to be okay but I'm not sure if this kind of approach is acceptable in verilog coding (anyway in logical or conventional). Should this kind of coding be avoided ?
module sample_top(
    input a,
    input b,
    input c,
    output d,
    output e
    );
    
    //sequential
    sample_submodule_1 SAMPLE_SUBMODULE_1(
        //input of submodule
        .A(a),
        .B(b),
        //output of submodule
        .D(d)
        );

    //sequential
    sample_submodule_2 SAMPLE_SUBMODULE_2(
        //input of submodule
        .C(c),
        .D(d),
        //output of submodule
        .E(e)
        );

Thanks for your answer.","The Verilog language does not really care about port directions. Hierarchy is just for creating namespaces and containers of behaviors. A port connection becomes a symbolic naming of a and A to a single wire object.
Other HDLs like VHDL do place restrictions on reading the values outputs. The difference between these HDLs is an artifact of how these languages resolve multiple drivers (which would take too much time to get into here). In Verilog you can see the effect of multiple driver resolution if one side of the port is a variable(reg), and the other side is a wire. Only the wire side of the port gets to see the resolved value of multiple drivers.",,,,,
Make a delay after falling edge of signal and then do something in VHDL,"I would like to know how I can do the following operations in this order:
First detect the falling edge of an input signal (rd), then wait for 15 ns and finally make the necessary changes in the variables, for example store the db_input 8bits vector into db_output 8bits vector.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity ent1 is
    port
    (
        -- Input ports
        rd              : in std_logic;
        db_input        : in std_logic_vector (7 downto 0);

        -- Output ports
        db_output   : out std_logic_vector (7 downto 0) := (others =&gt; '0')
    );
end ent1;

architecture arch1 of ent1 is
begin

    process(rd)
    begin
        if (falling_edge(rd)) then
            -- Wait for 15 ns
            -- After the 15 ns save db_input into db_output
        end if;
    end process;
    
end arch1;
","The following does what you asked for:
process
begin
  wait until falling_edge(rd);
  wait for 15 ns;
  db_output &lt;= db_input;
end process;
",,,,,
Issues in compact 1-bit ALU behavior,"I tried to write a compact code for a 1-bit ALU that implements logic operations, a full adder, and a full subtractor. The compilation looks fine, but it does not assert the message &quot;Test done.&quot; at the end of the testbench. Moreover, the change of logic values in variables, such as A, B and F that should lead to error in the testbench are unvariedness to the program as it does not report any error. Something is certainly wrong in the main design, but I couldn't find the problem.
In the testbench, I just tested some cases of each function.
library IEEE;
use IEEE.std_logic_1164.all;

entity ALU is
port(A,B :  in bit;                         -- operands
    S :       in bit_vector(2 downto 0);  
    F:        out bit;                      -- output
    carryIn:  in bit;   
    carryOut: out bit);
end ALU;


architecture behavior of ALU is
begin 
    process(S)
    begin   
    case (S) is
    when &quot;000&quot; =&gt; if carryIn = '1' then F &lt;= A XOR B XOR carryIn;       -- Full Adder
                                        carryOut &lt;= (A AND B) OR (carryIn AND A) OR (carryIn AND B);  
                                        end if;
    when &quot;001&quot; =&gt; if carryIn = '1' then F &lt;=  (A XOR B) XOR carryIn;    -- Full Subtractor
                                        carryOut &lt;= ((NOT A) AND (B OR carryIn)) OR (B AND carryIn);  
                                        end if; 
    when &quot;010&quot; =&gt; F &lt;= A AND B;
    when &quot;011&quot; =&gt; F &lt;= A OR B;
    when &quot;100&quot; =&gt; F &lt;= A NAND B;
    when &quot;101&quot; =&gt; F &lt;= A NOR B;
    when &quot;110&quot; =&gt; F &lt;= A XOR B;
    when &quot;111&quot; =&gt; F &lt;= A XNOR B;
    end case;   
    end process;

end behavior ;

Testbench
library IEEE;
use IEEE.std_logic_1164.all;

entity testbench is             
end testbench;

architecture tb of testbench is
component ALU is
port(A,B :    in bit;                                                        
    S :       in bit_vector(2 downto 0);     
    F:        out bit;                        
    carryIn:  in bit;   
    carryOut: out bit);
end component;

signal A, B, F, carryIn, carryOut: bit;
signal   S : bit_vector(2 downto 0);

begin
DUT: ALU port map (A =&gt; A, B =&gt; B, F =&gt; F, carryIn =&gt; carryIn, carryOut =&gt; carryOut, S =&gt; S);
process
begin

-- AND
S &lt;= &quot;010&quot;; 
A &lt;= '0';
B &lt;= '0';
carryIn &lt;= '0';
assert(F ='0' and carryOut = '0') report &quot;Fail AND1&quot; severity error;
wait;
S &lt;= &quot;010&quot;; 
A &lt;= '0';
B &lt;= '1';
carryIn &lt;= '0';
assert(F ='0' and carryOut = '0') report &quot;Fail AND2&quot; severity error;
wait;

-- OR
S &lt;= &quot;011&quot;; 
A &lt;= '0';
B &lt;= '0';
carryIn &lt;= '0';
assert(F ='0' and carryOut = '0') report &quot;Fail OR1&quot; severity error;
wait;
S &lt;= &quot;011&quot;; 
A &lt;= '0';
B &lt;= '1';
carryIn &lt;= '0';
assert(F ='1' and carryOut = '0') report &quot;Fail OR2&quot; severity error;
wait;

-- NAND
S &lt;= &quot;100&quot;; 
A &lt;= '0';
B &lt;= '0';
carryIn &lt;= '0';
assert(F ='1' and carryOut = '0') report &quot;Fail NAND1&quot; severity error;
wait;
S &lt;= &quot;100&quot;; 
A &lt;= '1';
B &lt;= '1';
carryIn &lt;= '0';
assert(F ='0' and carryOut = '0') report &quot;Fail NAND2&quot; severity error;
wait;

-- NOR
S &lt;= &quot;101&quot;; 
A &lt;= '0';
B &lt;= '0';
carryIn &lt;= '0';
assert(F ='1' and carryOut = '0') report &quot;Fail NOR1&quot; severity error;
wait;
S &lt;= &quot;101&quot;; 
A &lt;= '1';
B &lt;= '0';
carryIn &lt;= '0';
assert(F ='0' and carryOut = '0') report &quot;Fail NOR2&quot; severity error;
wait;

-- XOR
S &lt;= &quot;110&quot;; 
A &lt;= '0';
B &lt;= '1';
carryIn &lt;= '0';
assert(F ='1' and carryOut = '0') report &quot;Fail XOR1&quot; severity error;
wait;
S &lt;= &quot;110&quot;; 
A &lt;= '1';
B &lt;= '0';
carryIn &lt;= '0';
assert(F ='1' and carryOut = '0') report &quot;Fail XOR2&quot; severity error;
wait;


-- XNOR
S &lt;= &quot;111&quot;; 
A &lt;= '0';
B &lt;= '1';
carryIn &lt;= '0';
assert(F ='0' and carryOut = '0') report &quot;Fail XNOR1&quot; severity error;
wait;
S &lt;= &quot;111&quot;; 
A &lt;= '1';
B &lt;= '0';
carryIn &lt;= '0';
assert(F ='0' and carryOut = '0') report &quot;Fail XNOR2&quot; severity error;
wait;

-- Full Adder
S &lt;= &quot;000&quot;; 
A &lt;= '0';
B &lt;= '0';
carryIn &lt;= '1';
assert(F ='1' and carryOut = '0') report &quot;Fail FullAdder1&quot; severity error;
wait;
S &lt;= &quot;000&quot;; 
A &lt;= '1';
B &lt;= '1';
carryIn &lt;= '1';
assert(F ='1' and carryOut = '1') report &quot;Fail FullAdder2&quot; severity error;
wait;

-- Full Subtractor
S &lt;= &quot;000&quot;; 
A &lt;= '0';
B &lt;= '1';
carryIn &lt;= '1';
assert(F ='0' and carryOut = '1') report &quot;Fail Subtractor1&quot; severity error;
wait;
S &lt;= &quot;000&quot;; 
A &lt;= '1';
B &lt;= '1';
carryIn &lt;= '1';
assert(F ='1' and carryOut = '1') report &quot;Fail Subtractor2&quot; severity error;
wait;

assert false report &quot;Test done.&quot; severity note;
wait;
end process; 
end tb;


Edit
library IEEE;
use IEEE.std_logic_1164.all;

entity testbench is             
end testbench;

architecture tb of testbench is
component ALU is
port(A,B :    in bit;                                                        
    S :       in bit_vector(2 downto 0);     
    F:        out bit;                        
    carryIn:  in bit;   
    carryOut: out bit);
end component;

signal A, B, F, carryIn, carryOut: bit;
signal   S : bit_vector(2 downto 0);

begin
DUT: ALU port map (A =&gt; A, B =&gt; B, F =&gt; F, carryIn =&gt; carryIn, carryOut =&gt; carryOut, S =&gt; S);
process
begin

-- AND
S &lt;= &quot;010&quot;; 
A &lt;= '0';
B &lt;= '0';
wait for 20 ns;
assert(F ='0') report &quot;Fail AND1&quot; severity error;

wait for 20 ns;
S &lt;= &quot;010&quot;; 
A &lt;= '0';
B &lt;= '1';
assert(F ='0') report &quot;Fail AND2&quot; severity error;
wait for 20 ns;

-- OR
S &lt;= &quot;011&quot;; 
A &lt;= '0';
B &lt;= '0';
wait for 20 ns;
assert(F ='0') report &quot;Fail OR1&quot; severity error;

wait for 20 ns;

S &lt;= &quot;011&quot;; 
A &lt;= '0';
B &lt;= '1';
wait for 20 ns;
assert(F ='1') report &quot;Fail OR2&quot; severity error;
wait for 20 ns;

-- NAND
S &lt;= &quot;100&quot;; 
A &lt;= '0';
B &lt;= '0';
wait for 20 ns;
assert(F ='1') report &quot;Fail NAND1&quot; severity error;

wait for 20 ns;
S &lt;= &quot;100&quot;; 
A &lt;= '1';
B &lt;= '1';
wait for 20 ns;
assert(F ='0') report &quot;Fail NAND2&quot; severity error;
wait for 20 ns;

-- NOR
S &lt;= &quot;101&quot;; 
A &lt;= '0';
B &lt;= '0';
wait for 20 ns;
assert(F ='1') report &quot;Fail NOR1&quot; severity error;

wait for 20 ns;
S &lt;= &quot;101&quot;; 
A &lt;= '1';
B &lt;= '0';
wait for 20 ns;
assert(F ='0') report &quot;Fail NOR2&quot; severity error;
wait for 20 ns;

-- XOR
S &lt;= &quot;110&quot;; 
A &lt;= '0';
B &lt;= '1';
wait for 20 ns;
assert(F ='1') report &quot;Fail XOR1&quot; severity error;

wait for 20 ns;
S &lt;= &quot;110&quot;; 
A &lt;= '1';
B &lt;= '0';
wait for 20 ns;
assert(F ='1') report &quot;Fail XOR2&quot; severity error;
wait for 20 ns;


-- XNOR
S &lt;= &quot;111&quot;; 
A &lt;= '0';
B &lt;= '1';
wait for 20 ns;
assert(F ='0') report &quot;Fail XNOR1&quot; severity error;
wait for 20 ns;
S &lt;= &quot;111&quot;; 
A &lt;= '1';
B &lt;= '0';
wait for 20 ns;
assert(F ='0') report &quot;Fail XNOR2&quot; severity error;
wait for 20 ns;

-- Full Adder
S &lt;= &quot;000&quot;; 
A &lt;= '0';
B &lt;= '0';
carryIn &lt;= '1';
wait for 20 ns;
assert(F ='1') report &quot;Fail FullAdder1&quot; severity error;
wait for 20 ns;
S &lt;= &quot;000&quot;; 
A &lt;= '1';
B &lt;= '1';
carryIn &lt;= '1';
wait for 20 ns;
assert(F ='1') report &quot;Fail FullAdder2&quot; severity error;
wait for 20 ns;

-- Full Subtractor
S &lt;= &quot;000&quot;; 
A &lt;= '0';
B &lt;= '1';
carryIn &lt;= '1';
wait for 20 ns;
assert(F ='0') report &quot;Full Subtractor 1&quot; severity error;
wait for 20 ns;
S &lt;= &quot;000&quot;; 
A &lt;= '1';
B &lt;= '1';
carryIn &lt;= '1';
wait for 20 ns;
assert(F ='1') report &quot;Full Subtractor 2&quot; severity error;

wait for 20 ns;
assert false report &quot;Test done.&quot; severity note;

wait;

end process; 
end tb;

In the current program, I have got the following execution errors:
# EXECUTION:: ERROR  : Fail OR2
# EXECUTION:: Time: 120 ns,  Iteration: 0,  Instance: /testbench,  
Process: line__21.
# EXECUTION:: ERROR  : Fail NAND2
# EXECUTION:: Time: 200 ns,  Iteration: 0,  Instance: /testbench,  
Process: line__21.
# EXECUTION:: ERROR  : Fail NOR2
# EXECUTION:: Time: 280 ns,  Iteration: 0,  Instance: /testbench,  
Process: line__21.
# EXECUTION:: ERROR  : Fail Subtrator1
# EXECUTION:: Time: 560 ns,  Iteration: 0,  Instance: /testbench,  
Process: line__21.
# EXECUTION:: NOTE   : Test done.
# EXECUTION:: Time: 620 ns,  Iteration: 0,  Instance: /testbench,  
Process: line__21.
# KERNEL: Simulation has finished. There are no more test vectors to 
simulate.
# VSIM: Simulation has finished.

It seems to be somethin related to the main program, but I am not sure why it shows these errors because the logic in the testbench seems correct.
I also changed the following part
when &quot;000&quot; =&gt; F &lt;= A XOR B XOR carryIn;       -- Full Adder
              carryOut &lt;= (A AND B) OR (carryIn 
AND A) OR (carryIn AND B);  
                                   
when &quot;001&quot; =&gt; F &lt;=  (A XOR B) XOR carryIn;    -- Full Subtractor
              carryOut &lt;= ((NOT A) AND (B OR 
carryIn)) OR (B AND carryIn);  

and then get the carryIn in the testbench.","First, you have issues with your process in architecture behavior of ALU:

The process shall be sensitive to all inputs, not just S:
process(S, A, B, carryIn)

This way, if S does not change but the input data change, the outputs are re-computed instead of keeping their previous value.

The carryOut output shall always be assigned a value, not just when it is an arithmetic operation. Else, when you will try to synthesize this you will have latches inferred to store its value.

For the additions and subtractions you model only the case where carryIn = '1'. What about the other case?


Example of solution to all problems:
```vhdl
process(S, A, B, carryIn)
begin
  carryOut &lt;= '0';
  case (S) is
    when &quot;000&quot;  =&gt; -- Full Adder
      F &lt;= A XOR B XOR carryIn;
      carryOut &lt;= (A AND B) OR (carryIn AND A) OR (carryIn AND B);  
    when &quot;001&quot;  =&gt; -- Full Subtractor
      F &lt;= A XOR B XOR carryIn;
      carryOut &lt;= ((NOT A) AND (B OR carryIn)) OR (B AND carryIn);  
    when &quot;010&quot;  =&gt; F &lt;= A AND B;
    when &quot;011&quot;  =&gt; F &lt;= A OR B;
    when &quot;100&quot;  =&gt; F &lt;= A NAND B;
    when &quot;101&quot;  =&gt; F &lt;= A NOR B;
    when &quot;110&quot;  =&gt; F &lt;= A XOR B;
    when others =&gt; F &lt;= A XNOR B;
  end case;   
end process;
```

(note the use of when others to guarantee that we do not forget a single case).
Then you also have issues with your simulation environment. You wrote:
process
begin
  -- AND
  S &lt;= &quot;010&quot;; 
  A &lt;= '0';
  B &lt;= '0';
  carryIn &lt;= '0';
  assert(F ='0' and carryOut = '0') report &quot;Fail AND1&quot; severity error;
  wait;
  ...

This will not work for two reasons: you check the effect of your test vector before it had any effect. As no time elapses between the signal assignments and the assertion, the F and carryOut values did not change yet. You check the values they had before the changes of the inputs.
The second issue is that wait; means wait forever. It definitely suspends your process. The other statements will never be executed and the simulation will stop because in your case there is nothing else to be done.
To solve these two issues write:
process
begin
  -- AND
  S &lt;= &quot;010&quot;; 
  A &lt;= '0';
  B &lt;= '0';
  carryIn &lt;= '0';
  wait for 1 ns;
  assert (F = '0') and (carryOut = '0') report &quot;Fail AND1&quot; severity error;
  S &lt;= &quot;010&quot;;
  A &lt;= '0';
  B &lt;= '1';
  carryIn &lt;= '0';
  wait for 1 ns;
  assert (F = '0') and (carryOut = '0') report &quot;Fail AND2&quot; severity error;
  ...

Note that you could simplify a bit by not re-assigning the signals that don't change:
process
begin
  -- AND
  S &lt;= &quot;010&quot;; 
  A &lt;= '0';
  B &lt;= '0';
  carryIn &lt;= '0';
  wait for 1 ns;
  assert (F = '0') and (carryOut = '0') report &quot;Fail AND1&quot; severity error;
  B &lt;= '1';
  wait for 1 ns;
  assert (F = '0') and (carryOut = '0') report &quot;Fail AND2&quot; severity error;
  ...

One last note: VHDL is a high level programming language. You could use some of its features to simplify your testbench. For example you could use the ieee.numeric_bit_unsigned package that allows arithmetic operations on vectors and conversions between vectors and integers. Something like (not tested):
...
use ieee.numeric_bit_unsigned.all;
...
process
begin
  for i in 0 to 7 loop -- loop over the 8 possible values of (A,B,carryIn)
    (A, B, carryIn) &lt;= to_bitvector(i, 3);
    -- AND
    S &lt;= &quot;010&quot;;
    wait for 1 ns;
    assert F = ((A and B)) and (carryOut = '0') report &quot;Fail AND&quot; severity error;
    -- OR
    S &lt;= &quot;011&quot;;
    wait for 1 ns;
    assert (F = (A or B)) and (carryOut = '0') report &quot;Fail OR&quot; severity error;
    ...
    ...
    -- Full Adder
    S &lt;= &quot;000&quot;;
    wait for 1 ns;
    assert carryOut &amp; f = ('0' &amp; A) + ('0' &amp; B) + carryIn
      report &quot;Fail FullAdder&quot; severity error;
    -- full subtractor
    S &lt;= &quot;001&quot;;
    wait for 1 ns;
    assert carryOut &amp; F = ('0' &amp; A) - (('0' &amp; B) + carryIn)
      report &quot;Fail FullSubtractor&quot; severity error;
  end loop;
  assert false report &quot;Test done.&quot; severity note;
  wait;
end process;
",,,,,
VHDL: using only portion of outport,"I have an entity instantiated that has an out port of 32 bits.  I only need bits 4 through 15 which will go into some signal s_a.  I thought I could instantiate it this way but Vivado does not like it:
WHATEVER: entity work.example_entity
  port map(
    o_port( 15 downto 4 ) =&gt; s_a
  );

I know you can do something analogous with in ports and Vivado seems ok with that so long as I set all the bits to something like so:
WHATEVER2: entity work.other_entity
  port map(
    i_port( 7 downto 4 ) =&gt; ( others =&gt; '0' ),
    i_port( 3 downto 0 ) =&gt; s_b
  );

where i_port is an in port and s_b is some appropriately sized and typed signal.
Is there some way to only extract a subset of bits from an out port without connecting the entire port to a full-width signal and extracting the bits from that?","Like user16145658 said, the answer is &quot;no.&quot;  The open keyword only works on a whole out port, all bits included, and cannot be used on individual bits.  If you use any of the bits in an out port then they all have to go somewhere.",,,,,
Concatenation VHDL (2 8-bit vectors),"I was just wondering, how could I concatenate two 8 bit vectors together into a 16-bit vector with odata_H having the MSB and odata_L having the LSB? Any help would be appreciated. The vectors are data points given off from an ADT7420 temperature sensor.
signal BCD:             std_logic_vector(11 downto 0);
signal Bin_Temp:        std_logic_vector(7 downto 0);
signal Bin_Acc:         std_logic_vector(7 downto 0);
signal Buff_Temp:     std_logic_vector(7 downto 0);
signal Buff_Acc:      std_logic_vector(7 downto 0);
signal odata_L:         std_logic_vector(7 downto 0);
signal odata_H:         std_logic_vector(7 downto 0);
signal notEN:           std_logic;
signal odataT:          std_logic_vector(15 downto 0);
   begin
odataT &lt;= odata_H &amp; odata_L;
Bin_Temp &lt;= odataT(8 downto 1);
notEN &lt;= not(EN);
","I don't know why in this case the concatenation apparently doesn't work. Nevertheless, another way of achieving it is by using the resize() function of the numeric_std library.
library ieee;
use ieee.numeric_std.all;

[...]
odataT &lt;= std_logic_vector(resize(signed(odata_H), odata_L'length));

The concatenation (odata_H, odata_L) will be resized with a length of length (16 in this case).
Of course unsigned instead of signed is possible, if applicable.",,,,,
How can I add these STD_LOGIC_VECTORs for my homework?,"After debugging my code, I've gotten to the point where the complier accepts it, but it throws a simulator exception.

The main problems I've had are with initializing the temp arrays and adding the vectors at the end.

The method used for adding is one I found in a reference since you can't add STD_LOGIC_VECTORs

Thanks,
Buzkie

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.numeric_std.all;

entity signedmult is 
port (cand, lier: in std_logic_vector (4 downto 0);
    pro: out std_logic_vector (9 downto 0)); 

end signedmult;     


architecture synth of signedmult is
      --temp arrays
      signal a,b,c,d,e: std_logic_vector(9 downto 0); 

begin
process (a,b,c,d,e)
        variable j:integer;
begin

for j in 0 to 9 loop
a(j) &lt;= '0';
b(j) &lt;= '0';
c(j) &lt;= '0';
d(j) &lt;= '0';
e(j) &lt;= '0';

end loop;

end process;

process (cand, lier,a,b,c,d,e)      
        variable i:integer;     
begin
    for i in 0 to 4 loop
     a(i) &lt;= cand(0) and lier(i);
     b(i+1) &lt;= cand(1) and lier(i);
        c(i+2) &lt;= cand(2) and lier(i);
        d(i+3) &lt;= cand(3) and lier(i);
        e(i+4) &lt;= cand(4) and lier(i);
    end loop;

end process;

  a(5) &lt;= a(4); a(6) &lt;= a(4); a(7) &lt;= a(4); a(8) &lt;= a(4);

  b(6) &lt;= b(5); b(7) &lt;= b(5); b(8) &lt;= b(5);

  c(7) &lt;= c(6); c(8) &lt;= c(6);

  d(8) &lt;= d(7);

  pro &lt;= std_logic_vector(unsigned(a) + unsigned(b)); -- + c + d + e;


end synth;
","First you should remove std_logic_arith to avoid conflict with numeric_std.

Once that is done I can't see why your addition shouldn't work.

What error do you get when running?

Also, you drive your signals from multiple processes, likely
getting garbage in a and b.  Is that what causes the error?
Try putting all assignment to your temp arrays into one process.",,,,,
how to delete xilinx from my linux mint permanently,"
I had to manually delete all Xilinx files on my Linux Mint and now every time I open terminal this shows up.I don't know what is the cause. Does anyone now how to get rid of it? Thanks in advance.","Looks like your bash environment still tries to source Xilinx ISE.
Please open your .bashrc located at /home/$USER/.bashrc and find a line which looks something like
. /opt/Xilinx/14.7/ISE_DS/settings64.sh

or
source /opt/Xilinx/14.7/ISE_DS/settings64.sh

Bash might also source a file which sources a file. You might want to post the contents of /home/$USER/.bashrc in your question so we can give you better advice.
Other places to look might include /home/$USER/.bash_profile and /home/$USER/.bash_aliases, though I think it's rather unlikely you will find it there.",,,,,
Is it possible to update variable location within loop in verilog/system verilog?,"I am not sure about the term which is used to refer to the sizing of the variable. I will try to give as much details in the question as I can.
I am working on a generalized implementation of a verilog code where, I want to update the pointer location that my code refers to in a for loop. For example:
lets say I have a variable which can take in 8 bits values at a time
x[7:0] = some value;

I have a for loop which is initialized by an integer value, for e.g.
integer i;
for (i=large number; i&gt;=1;i= i+1)
begin
  x = [(i*8)-1:i*(8-1)];
end 

I am trying to make an assignment to x as shown in the code snippet above, but I get an error saying illegal operand for constant expression. Am I doing something fundamentally wrong or is there a way to achieve this?","Yes. Your code is illegal in (System)Verilog if i is a variable. Instead you need
some_varaible = some_other_variable[index-:width];

which is equivalent to
some_varaible = {some_other_variable[index],some_other_variable[index-1],...,some_other_variable[index-width+1]};

or
some_varaible = some_other_variable[index+:width];

which is equivalent to
some_varaible = {some_other_variable[index+width-1],some_other_variable[index+width-2],...,some_other_variable[index]};
",,,,,
is this syntax correct for unpacked array index-wise initialization in system verilog,"I have used previously unpacked arrays in different context where every index is initialized in for loop, but now i need to initialize them in module header and got stuck how to initialize only few indices and remaining should be default
module phy #(
 parameter NUM_HB = 12
,parameter string STROBE_LOC [NUM_HB-1:0][04-1:0] = '{[0][0]:&quot;TRUE&quot;,[0][2]:&quot;TRUE&quot;,[1][0]:&quot;TRUE&quot;,[1][2]:&quot;TRUE&quot;,default:&quot;FALSE&quot;};
)(
   input clk,rst
);
","The syntax for an assignment pattern of a multidimensional array is not straightforward. You need to provide a nested set of arrays fore each dimension.
module phy #(
 parameter NUM_HB = 12
  ,parameter string STROBE_LOC [NUM_HB-1:0][04-1:0] = '{
    0:'{0:&quot;TRUE&quot;,2:&quot;TRUE&quot;,default:&quot;&quot;},
    1:'{0:&quot;TRUE&quot;,2:&quot;TRUE&quot;,default:&quot;&quot;},
    default:'{default:&quot;&quot;} 
  }
)(
   input clk,rst
);
",,,,,
Synthesis for condition with never executing statements,"Will these two code examples have the same synthesis result? Does the result depend on the compiler?
First example, &quot;do something B&quot; will never be executed (specified under clock)
localparam a = 0;
always @(posedge CLK) begin
    if (a &lt; 5) 
        // do something A
    else
        // do something B
end

Second example: &quot;do something B&quot; will never be executed, but now it is specified under generate block.
localparam a = 0;
generate
    if (a &lt; 5) begin
        always @(posedge CLK) begin
            // do something A
        end
    end else begin
        always @(posedge CLK) begin
            // do something B
        end
    end
endgenerate
","Any good compiler tool has an optimization called constant propagation or  constant folding which eliminates the code for unreachable branches when there are expressions that can be completely evaluated as part of the compilation process. Using the generate construct shows your intent and is a guarantee that only one branch will be taken, however it involves more code.
So, yes, they should produce the same synthesis result.",,,,,
"Module output becomes ""x""","I'm writing a 3-way comparator which takes two inputs, a and b, and returns output 0 if a&lt;b, 1 if a==b, 2 if a&lt;b
I have written code of the comparator, but I came across its incomprehensible behavior. Its output is always &quot;x&quot;.
I would appreciate if someone help me find out what is wrong with my code.
This is my code.
module test_bench;
  logic a, b, out;

  compare compare (
      .a  (a),
      .b  (b),
      .out(out)
  );

  initial begin
    a = 1;
    b = 0;
    $display(&quot;a&gt;b =&gt; out=%d&quot;, out);

    a = 1;
    b = 1;
    $display(&quot;a=b =&gt; out=%d&quot;, out);

    a = 1;
    b = 2;
    $display(&quot;a&lt;b =&gt; out=%d&quot;, out);
  end
endmodule

// maybe something is wrong in this module?
module compare (
    input  logic a,
    b,
    output logic out
);

  always_comb begin
    if (a &gt; b) out = 0;
    else if (a == b) out = 1;
    else out = 2;
  end

endmodule

and this is what I got in display.
a&gt;b =&gt; out=x
a=b =&gt; out=x
a&lt;b =&gt; out=x
","The problem is with your test_bench stimulus. You apply values to the inputs with 0 delay and that does not give any chance for the values to propagate through the compare module.
Add some delay between each group of stimulus.
 initial begin
    a = 1;
    b = 0;
    #5  $display(&quot;a&gt;b =&gt; out=%d&quot;, out);

    a = 1;
    b = 1;
    #5 $display(&quot;a=b =&gt; out=%d&quot;, out);

    a = 1;
    b = 2;
    #5 $display(&quot;a&lt;b =&gt; out=%d&quot;, out);
  end
endmodule
",,,,,
How to connect analysis_port to sequence,"I have a sequence that needs to know when certain things have happened in the DUT to decide when to send the next item in the sequence, and I'm trying to find the best way to get that information to the sequence. I wanted to connect an analysis_port to the sequence since my testbench already has an analysis_port with the information I need, but my understanding is that analysis_ports need to be connected in the connect_phase, but uvm_sequence doesn't have a connect_phase. So is there anyway to connect an analysis_port to a uvm sequence? Or is there any other way to get the information from an analysis_port to a sequence?
My use case is the following:
I am verifying a write-through cache and writing a sequence that sends some stores to the input of the cache. Due to ordering requirements of the DUT and the intention of this sequence, this sequence needs to wait until each store is seen on the output of the cache (written-through) before sending the next one.","You mean an analysis_export or analysis_imp...
How about doing this: extend your uvm_sequenceR and add the analysis_imp to that and implement a write function there. The write function needs to store the received information somehow, eg by writing it to a queue (which would also be a data member of your extended sequencer class).
Your sequence can then access that store easily, because it can get easily get a pointer to the sequencer using p_sequencer or get_sequencer().",,,,,
SystemVerilog assign derived class handle to base class object,"This seems like a simple thing I should be able to do but I guess I don't fully understand polymorphism. I get a base class object from a monitor's analysis port and want to create a derived class object from this base class object, and then set extra members of the derived class (for coverage). What's the simplest way to go about doing this?
class BasePkt extends uvm_object;
  //...
endclass
.
class CovPkt extends BasePkt;
  //more members...
endclass
.
task process_pkt();
  forever begin
    BasePkt base_pkt;
    CovPkt cov_pkt;
    pkt_ap.get(base_pkt);
    cov_pkt = base_pkt; // Compile error
  end
endtask

I could create a function that performs a deep copy of BasePkt into a CovPkt object, but that doesn't seem like the right thing to do. Since CovPkt contains all the members of BasePkt, why can't I just assign it to a BasePkt class and then let the members of CovPkt that aren't in BasePkt be their default value?","
Why can't I just assign it to a BasePkt class and then let the members
of CovPkt that aren't in BasePkt be their default value?

Because you can't.
When you make an assignment from one class variable to another, you are copying a class handle, not the class object itself. A handle is a reference to a constructed object. In your example, I presume base_pkt contains a handle to a BasePkt class object. The object only contains the space to hold the BasePkt members. If you were allowed to directly make an assignment of a BasePkt object to a CovPkt class variable, references to CovPkt members would be outside that space.
You were correct in needing to construct a CovPkt class object first, and then copying the base_pkt members. However, since you are using the UVM, a better approach is to simply create a CovPkt at the source in the Monitor by using the factory. You can override BasePkt with CovPkt without changing any code in the Monitor. Then you will be able to perform a dynamic cast in your task.
if (!$cast(cov_pkt,base_pkt)) `uvm_fatal(...);

You might want to take a look at my course on SystemVerilog OOP for UVM.",,,,,
Handle implementation error with Vivado TCL,"I have several implementation (each with a different strategy) and I automate running them in  Vivado with the following script:
reset_run synth_1

launch_runs synth_1 -jobs 16
wait_on_runs synth_1

# Run all implementations
launch_runs impl_1 -jobs 16
launch_runs impl_2 -jobs 16
launch_runs impl_3 -jobs 16
launch_runs impl_4 -jobs 16
launch_runs impl_5 -jobs 16
launch_runs impl_6 -jobs 16

However sometimes one of them fails (low memory or bug in the tools, this is known) and I would like to catch it and do something, maybe try running it again or stop the next steps (for instance if implementation has failed I don't want to export the hardware, because it would lead to another error because it can't find the bitstream).
Do you know how can I catch this problem within my tcl script?","I have found a solution, but for some reason the result is not among the first ones when googling for words like &quot;vivado catch run failure&quot; and similar, so I'll post an answer:
Based on this Answer Record we can do:
set isAllOk false

set outputOfSynthRun [launch_runs synth_1]

set runStatus [get_property STATUS [get_runs synth_1]

set runProgress [get_property PROGRESS [get_runs synth_1\\]]

if { $outputOfSynthRun == 0 &amp;&amp; $runStatus == &quot;XST Complete!&quot; &amp;&amp; $runProgress == &quot;100%&quot;} {

set isAllOk true

} else {

set isAllOk false

}
",,,,,
How to reverse code this linear transformation algorithm?,"I am writing a module of an encryption function.
The algorithm XOR the input with 6-bit left shift and 10-bit left shift of the input itself.
Below is the code of the linear transformation.
algorithm
module linear_transform_enc (
input   wire    [15:0] m,
output      [15:0] L);

wire [15:0] m6, m10;

assign m6 [15:0] = {m[9:0],m[15:10]};
assign m10[15:0] = {m[5:0],m[15:6]};

assign L = m ^ m6 ^ m10;

endmodule  

Now, I would like to write the reverse of it as the decryption function.
The solution I found from Internet is as shown as below. I dont understand why it need to XOR with 2, 4, 12 and 14 bit shift of the input.... Can anyone explain it ?
Much appreciate!!
module linear_transform_dec(
input   wire    [15:0] L,
output      [15:0] m);

wire [15:0] L2, L4, L12, L14;

assign L2 [15:0] = {L[13:0],L[15:14]};
assign L4 [15:0] = {L[11:0],L[15:12]};
assign L12 [15:0] = {L[3:0],L[15:4]};
assign L14 [15:0] = {L[1:0],L[15:2]};

assign m = L ^ L2 ^ L4 ^ L12 ^ L14;

endmodule
","EDIT: I have also asked basically the same question on the cryptography stack exchange forum and we now have a strong mathematical proof of how this cipher works!
Your question got me curious, so I looked into it and I have found an explanation for your case, although I wasn't able to find a generalization of the rule.
We need to know only three things to understand why this works:
XOR properties 

XORing a number with itself gives 0. And 0 is the identity element for the XOR operation. This gives us the nice property: a^b^b=a
XOR operation is commutative, meaning you can rearrange all the terms of a sequence of operations and you get the same result: a^b^c = c^b^a = b^c^a
XOR works at the single bit level with no effects on adjacent bits.

 Cipher 
Now we can look into the cipher algorithm, and we can analyse a bit at a time. Let's focus on what is happening at bit 0.
We should find a formula that gives the index of the bit we receive after left rotating by r bits. For B bits, the formula is the following (I coded my attempts in python):
# returns index i after rotating by r

# Example with 5 bits
# x[4]x[3]x[2]x[1]x[0]
# rotate by 3. 
# x[1]x[0]x[4]x[3]x[2]

# At index 0 we there is x[2]. (5-3+0)%5 = 2
# At index 1 we there is x[3]. (5-3+1)%5 = 3
# At index 2 we there is x[4]. (5-3+2)%5 = 4
# At index 3 we there is x[0]. (5-3+3)%5 = 0
# At index 4 we there is x[1]. (5-3+4)%5 = 1
 
def ri(i,r):
    return (B - r + i ) % B #B is global

Now we can use this formula to find all the bits of the encoded value, because we know that
#L[i] = m[i] ^ m[ri(i,6] ^ m[ri(i,10)] 

    for idx in range(bits):
        
        s = &quot;L[{}] = m[{}] ^ m[{}] ^ m[{}]&quot;.format(idx,
            idx,
            ri(idx,6),
            ri(idx,10))
        print(s)


Gives:
L[0] = m[0] ^ m[10] ^ m[6]
L[1] = m[1] ^ m[11] ^ m[7]
L[2] = m[2] ^ m[12] ^ m[8]
L[3] = m[3] ^ m[13] ^ m[9]
L[4] = m[4] ^ m[14] ^ m[10]
L[5] = m[5] ^ m[15] ^ m[11]
L[6] = m[6] ^ m[0] ^ m[12]
L[7] = m[7] ^ m[1] ^ m[13]
L[8] = m[8] ^ m[2] ^ m[14]
L[9] = m[9] ^ m[3] ^ m[15]
L[10] = m[10] ^ m[4] ^ m[0]
L[11] = m[11] ^ m[5] ^ m[1]
L[12] = m[12] ^ m[6] ^ m[2]
L[13] = m[13] ^ m[7] ^ m[3]
L[14] = m[14] ^ m[8] ^ m[4]
L[15] = m[15] ^ m[9] ^ m[5]

And this scrambles the data with itself, making it difficult to guess. However we don't have a key, so the original information is still inside, it's just mixed with other original bits.
Let's now see what the decoded functions does. When we say L rotated by r we need to remember that L is just m all mixed up. So when we say L rotated by 2 XOR L rotated by 4 we can substitute that by the equivalent expression in ms.
Again, we can help printing the expression with python:
    # Returns the i-th bit of L expressed in terms of m
    def L_(i):
        return &quot;m[{}] ^ m[{}] ^ m[{}]&quot;.format(ri(i,0),ri(i,6),ri(i,10))

    #print m as the decipher says, but with all Ls expanded
    for idx in range(bits):
        
        s = &quot;m[{}] = {} ^ {} ^ {} ^ {} ^ {}&quot;.format(idx,
            L_(ri(idx,0)),
            L_(ri(idx,2)),
            L_(ri(idx,4)),
            L_(ri(idx,12)),
            L_(ri(idx,14))
            )
        
        print(s) 


Which gives:
m[0] = m[0] ^ m[10] ^ m[6] ^ m[14] ^ m[8] ^ m[4] ^ m[12] ^ m[6] ^ m[2] ^ m[4] ^ m[14] ^ m[10] ^ m[2] ^ m[12] ^ m[8]
m[1] = m[1] ^ m[11] ^ m[7] ^ m[15] ^ m[9] ^ m[5] ^ m[13] ^ m[7] ^ m[3] ^ m[5] ^ m[15] ^ m[11] ^ m[3] ^ m[13] ^ m[9]
m[2] = m[2] ^ m[12] ^ m[8] ^ m[0] ^ m[10] ^ m[6] ^ m[14] ^ m[8] ^ m[4] ^ m[6] ^ m[0] ^ m[12] ^ m[4] ^ m[14] ^ m[10]
m[3] = m[3] ^ m[13] ^ m[9] ^ m[1] ^ m[11] ^ m[7] ^ m[15] ^ m[9] ^ m[5] ^ m[7] ^ m[1] ^ m[13] ^ m[5] ^ m[15] ^ m[11]
m[4] = m[4] ^ m[14] ^ m[10] ^ m[2] ^ m[12] ^ m[8] ^ m[0] ^ m[10] ^ m[6] ^ m[8] ^ m[2] ^ m[14] ^ m[6] ^ m[0] ^ m[12]
m[5] = m[5] ^ m[15] ^ m[11] ^ m[3] ^ m[13] ^ m[9] ^ m[1] ^ m[11] ^ m[7] ^ m[9] ^ m[3] ^ m[15] ^ m[7] ^ m[1] ^ m[13]
m[6] = m[6] ^ m[0] ^ m[12] ^ m[4] ^ m[14] ^ m[10] ^ m[2] ^ m[12] ^ m[8] ^ m[10] ^ m[4] ^ m[0] ^ m[8] ^ m[2] ^ m[14]
m[7] = m[7] ^ m[1] ^ m[13] ^ m[5] ^ m[15] ^ m[11] ^ m[3] ^ m[13] ^ m[9] ^ m[11] ^ m[5] ^ m[1] ^ m[9] ^ m[3] ^ m[15]
m[8] = m[8] ^ m[2] ^ m[14] ^ m[6] ^ m[0] ^ m[12] ^ m[4] ^ m[14] ^ m[10] ^ m[12] ^ m[6] ^ m[2] ^ m[10] ^ m[4] ^ m[0]
m[9] = m[9] ^ m[3] ^ m[15] ^ m[7] ^ m[1] ^ m[13] ^ m[5] ^ m[15] ^ m[11] ^ m[13] ^ m[7] ^ m[3] ^ m[11] ^ m[5] ^ m[1]
m[10] = m[10] ^ m[4] ^ m[0] ^ m[8] ^ m[2] ^ m[14] ^ m[6] ^ m[0] ^ m[12] ^ m[14] ^ m[8] ^ m[4] ^ m[12] ^ m[6] ^ m[2]
m[11] = m[11] ^ m[5] ^ m[1] ^ m[9] ^ m[3] ^ m[15] ^ m[7] ^ m[1] ^ m[13] ^ m[15] ^ m[9] ^ m[5] ^ m[13] ^ m[7] ^ m[3]
m[12] = m[12] ^ m[6] ^ m[2] ^ m[10] ^ m[4] ^ m[0] ^ m[8] ^ m[2] ^ m[14] ^ m[0] ^ m[10] ^ m[6] ^ m[14] ^ m[8] ^ m[4]
m[13] = m[13] ^ m[7] ^ m[3] ^ m[11] ^ m[5] ^ m[1] ^ m[9] ^ m[3] ^ m[15] ^ m[1] ^ m[11] ^ m[7] ^ m[15] ^ m[9] ^ m[5]
m[14] = m[14] ^ m[8] ^ m[4] ^ m[12] ^ m[6] ^ m[2] ^ m[10] ^ m[4] ^ m[0] ^ m[2] ^ m[12] ^ m[8] ^ m[0] ^ m[10] ^ m[6]
m[15] = m[15] ^ m[9] ^ m[5] ^ m[13] ^ m[7] ^ m[3] ^ m[11] ^ m[5] ^ m[1] ^ m[3] ^ m[13] ^ m[9] ^ m[1] ^ m[11] ^ m[7]

As you can see, by properties (1) and (2), we can rearrange all the terms and each of them cancel out, except for the first term, which is the original bit itself.
And the data is decoded!!",,,,,
Multiple variables in Verilog case structure control expression,"I am using case statement to write my Verilog logic. I wanted to know if we can AND multiple variables in the case's control expression.
reg a;
reg [5:0] b;
reg c;
case(a &amp; b)
    1'b0 &amp; 6'd0: c &lt;= 1'b1;
    1'b1 &amp; 6'd1: c &lt;= 1'b0;
    default: c &lt;= 1'b0;
endcase
","What you want is a concatenation {} not and &amp;
case({a,b})
    {1'b0 , 6'd0}: c &lt;= 1'b1;
    {1'b1 , 6'd1}: c &lt;= 1'b0;
    default: c &lt;= 1'b0;
endcase
",,,,,
SV/Verilog timing of sampling and driving signals,"I have a class driver (coded in UVM) and a module sampler_n_dummy_gnt as follows (simplified for the purpose of this question):
class driver extends uvm_driver #(bus_trans);
    ...
    task run_phase();
        forever begin
            seq_item_port.get_next_item(bus_trans_h);
            drive_item(bus_trans_h);
            ...
        end
    ...
    endtask

    task drive_item();
        vif.sel = 1;
        vif.req = 0;
        @(posedge vif.clk);
        vif.req = 1;
        // #1; // this delay needed to prolong req for 1 clock
        if (vif.gnt == 1)
            @(posedge vif.clk);
        else begin
            while (vif.gnt == 0)
                @(posedge vif.clk);
            end
        end
        vif.req = 0;
    endtask
endclass

module sampler_n_dummy_gnt;
    logic clk, rstn;
    int rdelay;

    bus_interface vif(clk, rstn);

    always #10ns clk = ~clk;

    always @(posedge vif.req) begin
        rdelay = $urandom_range(0,5);
        if (rdelay != 0) begin
          for (int i=0; i&lt;rdelay; i=i+1) begin
            vif.gnt = 0;
            @(posedge vif.clk);
          end
        end
        vif.gnt = 1;
    end
endmodule

Basically, the driver emulates a protocol that specifies that it should assert sel whenever there's a new transaction. One cycle after, it should assert req. It then waits until gnt is high and only deasserts req one cycle after.
The sampler waits for the assertion of req and based on the randomly generated number waits for a certain number of clock cycles before it asserts gnt. So either there's no delay or a few delays with maximum 5 cycles.
The first transaction is OK until I run into the 2nd transaction. At posedge of clock 7, the gnt deasserted and so req should remain high until it sees the gnt assert at clock 8. However, I never saw req assert anymore from clock 7 onwards (i.e. it stayed 0). I suspected that at posedge of clock 7, it sees gnt = 1 but skipped the if-else condition and goes straight to drive req = 0. So I have to add the line I commented above in order to get the expected scenario. Could someone help explain why the delay is needed?
                (Expected)                               (Actual)
        1   2   3   4   5   6   7   8          1   2   3   4   5   6   7   8
       _   _   _   _   _   _   _   _          _   _   _   _   _   _   _   _  
clk  _| |_| |_| |_| |_| |_| |_| |_| |_      _| |_| |_| |_| |_| |_| |_| |_| |_
       _______________     ___________        _______________     ___________
sel  _|               |___|                 _|               |___|
           ___________         _______            ___________         
req  _____|           |_______|             _____|           |_______________   
                   ___________     ___                    ___________     ___
gnt  _____________|           |___|         _____________|           |___|

","I'm assuming clk, vif.clk, vif.pclk are really all the same signal.
Your code has a number of problems with dealing with synchronous signals.

You should only use one clock edge event, and never an edge of another signal unless you are dealing with asynchronous logic.
When making assignments to synchronous signals, always use nonblocking assignments &lt;=
Make sure the first call to a task is synchronized to a clock edge

Since you did not post the complete code, I can only make this a suggestion
class driver extends uvm_driver #(bus_trans);
    ...
    task run_phase();
       @(posedge vif.clk; // initial sync
       forever begin
            while (!seq_item_port.try_next_item(bus_trans_h)
               @(posedge vif.clk;
            drive_item(bus_trans_h);
            ...
        end
    ...
    endtask

    task drive_item();
        vif.sel &lt;= 1;
        vif.req &lt;= 0;
        @(posedge vif.clk);
        vif.req &lt;= 1;
        @(posedge vif.clk iff vif.gnt);
        vif.req &lt;= 0;
    endtask
endclass
",,,,,
How to connect a modport interface to a module that wasn't originally declared using the modport,"I have a module that I wrote originally like so:
module design_name #(
  parameter AWIDTH = 32,
  parameter DWIDTH = 32,
  ...
  ) (
  input wire clk,
  input wire rst,
  input wire [AWIDTH-1:0] write_addr,
  ...
);
// logic, etc.
endmodule

I now, of course, want to test this block in a test bench. I want to use an interface so I have created an interface like so:
interface design_name_if #(
  parameter AWIDTH = 32,
  ...
) (
  input clk
);
  logic rst;
  logic [AWIDTH-1:0] write_addr;
  ...
  
  modport des (
    input rst,
    input write_addr,
    ...
  );
endinterface
  

I guess my question starts now; how do I use this interface in my test bench? I currently have:
module tb;

  reg clk;

  design_name_if intf (clk);

  design_name dut (
    .clk        (intf.clk),
    .rst        (intf.ndm.rst),
    .write_addr (intf.ndm.write_addr),
    ...
// I don't think the above is correct

  initial begin
    clk = 0; // or intf.clk = 0; ?
    rst = 0;
    forever #1 clk = ~clk;
    #10
    rst = 1;
  end
endmodule

I've also tried some other simple logic, like just trying to assert certain signals and other things, but I can't even get the clk to start, nor can I ever get rst to assert when running the simulation. If it matters, the interface is declared above the tb in the same file. The module I'm testing is, probably obviously, in a different file. I can get the test bench to work without an interface by declaring all the signals as reg and wire within the test bench normally but I wanted to use an interface with tasks, functions, etc. Any help appreciated, thank you!","You were very close. Just get rid of the modport in the referenceâ€”a modport is not a scope, it is a set of access rights for a port connection or virtual interface reference.
 design_name dut (
    .clk        (intf.clk),
    .rst        (intf.rst),
    .write_addr (intf.write_addr),
    ...
",,,,,
Verilog module generates impossible data when running on FPGA,"Iâ€™m developing a boolean data logger on a ZYNQ 7000 SoC. The logger takes a boolean input from GPIO and logs the inputâ€™s value and the time it takes to flip.
I use a 32-bit register as a log entry, the MSB bit is the boolean value. The 30:0 bits is an unsigned integer which records the time between last 2 flips. The logger should work like the following picture.

Here's my implementation of the logger in Verilog. To read the logged data from the processor, I use an AXI slave interface generated by vivado and inline my logger in the AXI module.
module BoolLogger_AXI #(
    parameter BufferDepth = 512
)(
    input wire data_in, // boolean input
    input wire S_AXI_ACLK, // clock
    input wire S_AXI_ARESETN, // reset_n
    // other AXI signals
);
wire slv_reg_wren; // write enable of AXI interface
reg[31:0] buff[0:BufferDepth-1];

reg[15:0] idx;
reg[31:0] count;
reg last_data;
always @(posedge S_AXI_ACLK) begin
    if((!S_AXI_ARESETN) || slv_reg_wren) begin
        idx &lt;= 0;
        count &lt;= 1;
        last_data &lt;= data_in;
    end else begin
        if(last_data!=data_in) begin // add an entry only when input flips
            last_data &lt;= data_in;
            if(idx &lt; BufferDepth) begin // stop logging if buffer is full
                buff[idx] &lt;= count | (data_in &lt;&lt; 31);
                idx &lt;= idx + 1;
            end
            count &lt;= 1;
        end else begin
            count &lt;= count + 1;
        end
    end
end

//other AXI stuff
endmodule


In the AXI module, the 512*32bit logged data is mapped to addresses from 0x43c20000 to 0x43c20800.
In the Verilog code, the logger adds a new entry only when the boolean input flips. In simulation, the module works as expected. But in the FPGA, sometimes the logged data is not valid. There are successive 2 data and their MSB bit is the same, which means the entry is added even when the boolean input stays the same.

The invalid data appear from time to time. I've tried reading from the address programmatically (*(u32*)(0x43c20000+4*idx)), and there are still invalid data. I watch idx in a ILA module and idx is 512, which means the logging finishes when I read the data.
The FPGA clock is 10 MHz. The input signal is 10 Hz. So the typical period is 10e6/10/2=0x7A120, which most of the data is close to, except the invalid data.
I think if the Verilog code is implemented well, there should be no such invalid data. What may be the problem? Is this an issue about timing?
The code","First off, are you absolutely sure you are not issuing an accidental write on the AXI bus, resetting the registers?
If so, have you tried inserting a so-called double-flop on data_in (two flip-flops, delaying the signal two clock ticks)? I suppose that your data_in is not synchronous to the FPGA clock, which will lead to metastability and you having bad days if not accounted for. Have a look here for information by NANDLAND.
Citing the linked source:

If you have ever tried to sample some input to your FPGA, such as a button press, or if you have had to cross clock domains, you have had to deal with Metastability. A metastable state is one in which the output of a Flip-Flop inside of your FPGA is unknown, or non-deterministic. When a metastable condition occurs, there is no way to tell if the output of your Flip-Flop is going to be a 1 or a 0. A metastable condition occurs when setup or hold times are violated.
Metastability is bad. It can cause your FPGA to exhibit very strange behavior.

In that source there is also a link to a white paper from Altera about the topic of metastability, linked here for reference.
Citing from that paper:

When a metastable signal does not resolve in the allotted time, a logic failure can result if the destination logic observes inconsistent logic states, that is, different destination registers capture different values for the metastable signal.

and

To minimize the failures due to metastability in asynchronous signal transfers, circuit designers typically use a sequence of registers (a synchronization register chain or synchronizer) in the destination clock domain to resynchronize the signal to the new clock domain. These registers allow additional time for a potentially metastable signal to resolve to a known value before the signal is used in the rest of the design.

Basically having the asynchronous signal routed to two flip-flops might for example lead to one FF reading a 1 and one FF reading a 0. This in turn could lead to the data point being saved, but the counter not being reset to 0 (hence doubling the measured time) and the bit being saved as 0.
Finally, it seems to me, that you are using the Vivado-generated example AXI core. Dan Gisselquist simply calls it &quot;broken&quot;. This might not be the problem here, but you might want to have a look at his posts and his AXI core design.",,,,,
alias argument in hierarchy in system verilog,"Is there way to make this alias statement work , as iob is bidirectional we cannot use assign statement. out of all the available iob pins only specific pins are connected to ddr memory dq bus. the other way we are doing is include iob.svh during instantiation of child module below is the snippets of required and implemented
   module top(
      input [63:0] ddr_dq
    );
    localparam NUM_HB = 24;
    
    logic [NUM_HB-1:0][4-1:0][8-1:0] iob;
      alias iob[0][0][0] = ddr_dq[0];
    
     phy u_phy (
      . iob (iob)
     );
    endmodule
    
    module phy (
      inout [NUM_HB-1:0][4-1:0][8-1:0] iob
    );
    endmodule

this is the work around implemented, but to get a the location of pin at single glance above alias statement will be useful
module top(
  input [63:0] ddr_dq
);
localparam NUM_HB = 24;

logic [NUM_HB-1:0][4-1:0][8-1:0] iob;
  //alias iob[0][0][0] = ddr_dq[0];

 phy u_phy (
  `include iob.svh
 );
endmodule

Contents of include iob.svh file is captured below
.iob( {
         nc_iob_pin[0]
        ,ddr_dq[0]
        ,ddr_dq[1]
        ,ddr_dq[2]
        ,ddr_dq[3]
        ,ddr_dq[4]
        ,ddr_dq[5]
})
","I am not sure which problem you saw. Alias statements only work with 'nets', so declaring iob as just logic, meaning var logic prevents it from being compiled. I did modify your code to make it compilable:
parameter NUM_HB = 24;

module top(
      input [63:0] ddr_dq
    );
    
    wire logic [NUM_HB-1:0][4-1:0][8-1:0] iob; // 'logic' is optional here
      alias iob[0][0][0] = ddr_dq[0];
    
     phy u_phy (
      . iob (iob)
     );
endmodule
    
module phy (
      inout [NUM_HB-1:0][4-1:0][8-1:0] iob
    );
endmodule
",,,,,
Verilog / Vivado digital clock launching error,"I'm currently trying to write digital clock code &amp; simulate in vivado with verilog. There are 2 versions of code first one is working as I expected but second one (modified one) is not launching with the error code
`timescale 1ns / 1ps



module watch(

  input            CLK,  

  input            rst_n, // Active-low reset

  output reg [4:0] HRS,

  output reg [5:0] MINS,SECS

);

always @ (posedge CLK or negedge rst_n) begin

  if (~rst_n) begin

    SECS &lt;= 'b0;

    MINS &lt;= 'b0;

    HRS  &lt;= 'b0;

  end

  else begin   

    if (SECS == 59) begin

        MINS &lt;= MINS + 1;

        SECS &lt;= 0;

    end else begin

        SECS &lt;= SECS + 1;

    end    

  end



end

endmodule

Basically it counts only minutes and seconds. First code working with simulation. I tried to modify the code like this,
`timescale 1ns / 1ps
module watch(
  input            CLK,  
  input            rst_n, // Active-low reset
  output reg [4:0] HRS,
  output reg [5:0] MINS,SECS
);
always @ (posedge CLK or negedge rst_n) begin
  if (~rst_n) begin
    SECS &lt;= 'b0;
    MINS &lt;= 'b0;
    HRS  &lt;= 'b0;
 end else begin  
   if (SECS == 59)
    begin
    MINS &lt;= MINS + 1;
 SECS &lt;= 0;
  end else begin
        SECS &lt;= SECS + 1;
        begin  
    if (MINS == 59) begin
        HRS &lt;= HRS + 1;
        MINS &lt;= 0;
    end else begin
        MIN &lt;= MIN + 1; 
        end
       else begin
if ( HRS == 23) begin
HRS &lt;= 0 ;

   
    end    
  end
end
endmodule

It's not launching the simulation with coding errors. Can someone explain how can I fix the issue
screenshot of error","The error is pretty clear, there is a syntax error. This is probably due to messed up if-elses. Look here for a guide on how to use if-else in Verilog.
I fixed you if-else structures, not the logic.
`timescale 1ns / 1ps;
module watch(
  input            CLK,  
  input            rst_n, // Active-low reset;
  output reg [4:0] HRS,
  output reg [5:0] MINS,SECS
);
  always @ (posedge CLK or negedge rst_n) begin
    if (~rst_n) begin
      SECS &lt;= 'b0;
      MINS &lt;= 'b0;
      HRS  &lt;= 'b0;
    end else begin  

      if (SECS == 59) begin;
        MINS &lt;= MINS + 1;
        SECS &lt;= 0;
      end else begin;
        SECS &lt;= SECS + 1;
      end  

      if (MINS == 59) begin
        HRS &lt;= HRS + 1;
        MINS &lt;= 0;
      end else begin
        MIN &lt;= MIN + 1; ;
      end

      if ( HRS == 23) begin
        HRS &lt;= 0 ;
      end    
      
    end
  end
endmodule
",,,,,
aocl command not working correctly when run from github actions,"I'm trying to get github actions to work with Intel FPGAs in a self hosted runner. Any time communication from the host to the FGPA is attempted there are errors like these ones:
Error initializing DMA: invalid parameter
Error initializing DMA: invalid parameter
Error closing DMA
Error closing DMA
...
aocl mmd alloc failed: Resource temporarily unavailable
aocl mmd alloc failed: Resource temporarily unavailable
aocl mmd alloc failed: Resource temporarily unavailable

If I run any aocl command or run any application that uses the OpenCL runtime environment normally in the system it works fine. It is only when it's running through github actions that it fails.","The problem is the memlock limit. The default value of a systemd service is 64k. It needs to be a large number. Add LimitMEMLOCK=infinity to the service file as shown below.
[username@mysystem ~]$ cat /etc/systemd/system/actions.runner.runner-name.mysystem.service
[Unit]
Description=GitHub Actions Runner (runner-name.mysystem)
After=network.target

[Service]
ExecStart=/home/username/.local/bin/myrunner/001/runsvc.sh
User=username
LimitMEMLOCK=infinity
WorkingDirectory=/home/username/.local/bin/myrunner/001
KillMode=process
KillSignal=SIGTERM
TimeoutStopSec=5min

[Install]
WantedBy=multi-user.target

Then reboot the service.",,,,,
Delay counter not incrementing? FSM,"I was writing a code for DAC register and there is delay required. However, in the delay state, the DAC_counter_2 is not incrementing, and delay is not being achieved. I have copied the code to different project and tried to check. The problem still exists. Any help would be great.
module dac_card
(   output reg DAC_SCLK,
    output reg SYNC,
    output reg SDIN,
    input MHZ_50_CLK,
    input RST,
    output reg [7:0] DAC_counter_1,
    output reg [7:0] DAC_counter_2
    );
    
    reg [7:0] pst_state, nxt_state;
    
    reg [23:0] DAC_reg;
    
    always @(posedge MHZ_50_CLK)
    begin
        if (RST)
        begin
            DAC_reg &lt;= 24'hEEEEEE;
            SYNC &lt;= 1'b1;
            DAC_SCLK &lt;= 1'b0;
            SDIN &lt;=1'b0;
            DAC_counter_1 &lt;= 8'd0;
            DAC_counter_2 &lt;= 8'd0;
            pst_state &lt;= 8'd0;
        end
        else
        begin
            pst_state &lt;= nxt_state;
            DAC_counter_1 &lt;= DAC_counter_1 + 1'b1;
        end
    end
    
    always @(pst_state or DAC_counter_2)
    begin
        case (pst_state)
            8'd0            :   begin
                                    if (DAC_counter_2 == 8'd24)
                                    begin
                                        DAC_counter_2 = 8'd0;
                                        SYNC = 1'b1;
                                        SDIN = 1'b0;
                                        nxt_state = 8'd2;
                                    end
                                    else
                                    begin
                                        SYNC = 1'b0;
                                        DAC_SCLK = 1'b1;
                                        DAC_counter_2 = DAC_counter_2 + 1'b1;
                                        SDIN = DAC_reg [23];                         //Writing DAC register
                                        DAC_reg = DAC_reg &lt;&lt; 1;
                                        nxt_state = 8'd1;
                                    end
                                end
            8'd1            :   begin
                                    DAC_SCLK = 1'b0;
                                    nxt_state = 8'd0;
                                end
            8'd2            :   begin
                                    if (DAC_counter_2 == 8'd10)                      //Minimum delay for SYNC to be low for write mode
                                    begin
                                        SYNC = 1'b1;
                                        DAC_counter_2 = 8'd0;
                                        nxt_state = 8'd3;
                                    end
                                    else
                                    begin
                                        SYNC = 1'b0;
                                        //Not incrementing
                                        DAC_counter_2 = DAC_counter_2 + 1'b1;
                                    end                                   
                                end
            8'd3            :   begin
                                    nxt_state = 8'd0;
                                end
            default         :   begin
                                    nxt_state = 8'd0;
                                end
        endcase
    end
endmodule

Here is the test bench
module test_bench
();
//Analog Card DAC wires and registers
    reg MHZ_50_CLK;
    reg RST;
    wire DAC_SCLK;
    wire SYNC;
    wire SDIN;
    wire [7:0] DAC_counter_1;
    wire [7:0] DAC_counter_2;
    
    //Instatntiate DAC
    dac_card dc (.DAC_SCLK(DAC_SCLK),
                 .SYNC(SYNC),
                 .SDIN(SDIN),
                 .MHZ_50_CLK(MHZ_50_CLK),
                 .RST(RST),
                 .DAC_counter_1(DAC_counter_1),
                 .DAC_counter_2(DAC_counter_2)
                 );
    initial
    begin
        MHZ_50_CLK = 1'b0;
        #10 RST = 1'b1; 
        #20 RST = 1'b0;
    end
    
    always
    begin
        #10 MHZ_50_CLK &lt;= ~MHZ_50_CLK;
    end
endmodule

Here is the waveform. After 24 counts of DAC_counter_2, delay for 8'd10 is not achieved.
","You need to make an assignment to nxt_state in all branches of your case statement.  This also avoids inferring unintended latches. For example, refer to the line //  MISSING nxt_state = below:
        8'd2            :   begin
                                if (DAC_counter_2 == 8'd10)                      //Minimum delay for SYNC to be low for write mode
                                begin
                                    SYNC = 1'b1;
                                    DAC_counter_2 = 8'd0;
                                    nxt_state = 8'd3;
                                end
                                else
                                begin
                                    SYNC = 1'b0;
                                    //Not incrementing
                                    DAC_counter_2 = DAC_counter_2 + 1'b1;
                                    //  MISSING nxt_state =
                                end                                   
                            end

As your waves show, once you enter state 2, you remain in state 2.  Since DAC_counter_2 is not 10 in state 2, you always execute the else clause, which does not change nxt_state.

There are a couple other issues which may also be causing problems.
Good coding practices recommend making assignments to a reg from a single always block.  DAC_counter_2 is assigned in 2 different blocks.
Also, the same signal should not appear on both the LHS and RHS of an assignment in a combinational always block since it creates a feedback loop.  For example, DAC_counter_2 = DAC_counter_2 + 1 should probably be in a sequential always block like DAC_counter_1.",,,,,
Implement a state machine in Verilog using a 2D array as transition table,"I'm trying to implement a very simple Mealy state machine in Verilog. I have already done it with case and if statements, but I want to be able to do the same using a 2D array as transition table, for clarity.
Here is the code:
module ex10_1_2(
  // output
  output reg o,
  
  // debug output to see the current state
  output [1:0] s,
  
  // input, clk signal
  input i, clk);
  
  // states
  localparam A = 2'b00, B=2'b01, C = 2'b10, D = 2'b11;
  
  // transition table
  reg [3:0] ttable [1:0][2:0];
  
  // current state
  reg [1:0] cs;
  
  initial begin
    
    // initial values: state A, output 0.
    cs &lt;= A;
    o &lt;= 0;
    
    // curr. state|input|next st.|output
    ttable[A][0] = {B, 1'b0};
    ttable[A][1] = {A, 1'b1};
    ttable[B][0] = {C, 1'b1};
    ttable[B][1] = {A, 1'b0};
    ttable[C][0] = {D, 1'b0};
    ttable[C][1] = {C, 1'b0};
    ttable[D][0] = {A, 1'b1};
    ttable[D][1] = {C, 1'b0};
  end
  
  always @ (posedge clk)
    begin
      cs &lt;= ttable[cs][i][2:1];
      o &lt;= ttable[cs][i][0];
    end
  
  assign s = cs;
  
endmodule

As you can see, the transition table is 4 rows * 2 columns. Each cell contains 3 bits, the 2 MSBs indicate the next state and the LSB is the next output.
I have tried this implementation both with blocking and non-blocking assignments, but it still doesn't work.
I'm using EPWave and EDAPlayground  with Icarus Verilog as simulator. What I'm getting is  that o (the output) is undetermined most of the time, and r (which is a debug wire used to see the internal current state goes like 0, 1, 2, X and remains in X for the rest of the simulation)
What am I missing?
PD.: simulation
Here is a link that should allow you to simulate the code: edaplayground. Notice there are two modules: the first one is the case/if one, which already works. The module I'm trying to debug is ex10_1_2.","I have replaced the matrix declaration by the followin:
reg [2:0] ttable [3:0][1:0];

it seems that I had an out-fo-bounds error because of the previous [1:0]. I was confused because I though I would have enough with 2 bits, since that is what the state codes need. However this is an array index, therefore I need 4 positions, one for each state.",,,,,
"I need to convert this VHDL code to MyVHDL Python, how to?","i need to convert this code to myhdl in python for my school work, anyone can help me?
library ieee;
use ieee.std_logic_1164.all;

entity simple_example is
    port (
        a : in std_logic;
        b : in std_logic;
        o : out std_logic   
    );
end simple_example;

architecture simple_example of simple_example is
    signal s : std_logic;
begin

    s &lt;= a and b;
    o &lt;= s or b;

end simple_example;
","You may refer to the docs at: http://docs.myhdl.org/en/stable/manual/preface.html#
You may find the below helpful:
from myhdl import *

@block
def simple_example(a , b, o):
    &quot;&quot;&quot;
        input: a, b
        output: o
    &quot;&quot;&quot;
    @always_comb
    def behave():
        s = a and b
        o = s or b
    return instances()


&quot;&quot;&quot;
Verification
&quot;&quot;&quot;

x = Signal(bool(0))
y = Signal(bool(0))
z = Signal(bool(0))

test = simple_example(x, y, z)
test.convert(hdl=&quot;VHDL&quot;, initial_values=True)
",,,,,
What does [-1:0] mean in Verilog?,"In my code i wrote:
output [numSize-1:0] index;

numSize is a parameter that can be zero. What is the meaning of this? What is this gonna be synthesized to?","The assignment of output [-1:0] index would allow you to access index[-1] and index[0].
There is no preclusion to using negative values in the range of a vector in Verilog.",,,,,
How to do Down casting between same extended classes in systemverilog?,"I'm trying to understand about case between same extended class in uvm as example below,
  module test_module ();
  
class A; endclass
class B extends A; endclass
class C extends A; endclass

A a_h;
B b_h;
C c_h;

  initial begin

    c_h = new();
    b_h = c_h;
    $cast(c_h, b_h); 
  end
endmodule : test_module

I got xrun: 20.09-s003: (c) Copyright 1995-2020 Cadence Design Systems, Inc.
b_h = c_h;
|
xmvlog: *E,TYCMPAT (testbench.sv,20|12): assignment operator type check failed (expecting datatype compatible with 'class test_module::B' but found 'class test_module::C' instead).
Error message.
I thought b_h and c_h are extended by same class.
But b_h and c_h are not same class type so.
I assign b_h = c_h;
But why does assign make error?","you have the following scheme:
     /---&gt;B
A---&gt;
     \---&gt;C


There is direct dependency between A and B or A and C (A is a superclass for B and C). There is no direct dependency between B and C.
Therefore you can easily do:
a_h = b_h; // no casting needed to assign to superclass-A-type
$cast(b_h, a_h); // you need a cast to upcast the base pointer.

But casting $cast(b_h, c_h) is not possible because they are not related.
more formal:

When $cast is applied to class handles, it succeeds in only three cases:

The source expression and the destination type are assignment compatible, that is, the destination is
the same type or a superclass of the source expression.
The type of the source expression is cast compatible with the destination type, that is, either:
â€?the type of the source expression is a superclass of the destination type, or
â€?the type of the source expression is an interface class (see 8.26)
and the source is an object that is assignment compatible with the destination type. This type of
assignment requires a run-time check as provided by $cast.
The source expression is the literal constant null.

",,,,,
Why is my counter out value producing StX?,"I made a simple counter that goes to 32 and a testbench for it. I'm not sure why the value for the output (co) is still coming out as StX. I've been trying to debug this for many hours now and I'm not sure of the issue.

","co is X (unknown) because it is a continuous assignment to an expression dependent on current, which is X.  current is X because you declared it as a reg, and reg types default to X at time 0, and then you never assign it to a known value.
Your testbench always drives rst as 0.  This means line 8 is never executed.  Line 10 will be executed at every rising clk edge, but current will remain at X.  X+1 returns X.
You need to reset your design properly.  At time 0, you should assert the reset by setting rst=1.  After a delay, you should release the reset setting rst=0.
initial begin
    clk = 0;
    rst = 1; // Assert reset

    #20;
    rst = 0; // Release reset

    #10;
    en = 1;
    init = 1;
end
",,,,,
Why does signal assignment not execute on the first iteration? VHDL,"I'm new to VHDL. I heard that signal assignment only updates at the end of a process and will only use the most recent assignment, so I wanted to test it out. How come the value for temp did not update at the end of the first process(i=0) even though I already have an initial value for a,b,c? It only started updating the value for temp on the second iteration(i=1).
Code I used to test:
architecture Behavioral of test is
    signal a    : integer := 1;
    signal b    : integer := 2;
    signal c    : integer := 3;
    signal i    : integer := 0;
    signal temp, temp2  : integer;
begin
    process is
    begin
        report &quot;-----Start Here-----(&quot; &amp; integer'image(i) &amp; &quot;)&quot;;
        temp &lt;= a;      report &quot;1:&quot; &amp; integer'image(temp);
        temp &lt;= b;      report &quot;2:&quot; &amp; integer'image(temp);
        temp &lt;= c;      report &quot;3:&quot; &amp; integer'image(temp);

        temp2 &lt;= a;     report &quot;4:&quot; &amp; integer'image(temp2);
        temp2 &lt;= temp;  report &quot;5:&quot; &amp; integer'image(temp2);
        report &quot;-----End Here----------------------------&quot;;
        
        i &lt;= i + 1;
        wait for 10ns;
    end process;
end architecture;

OUTPUT:
-----Start Here-----(0)
1: -2147483648                  
2: -2147483648
3: -2147483648
4: -2147483648
5: -2147483648
-----End Here----------------------------
-----Start Here-----(1)
1: 3
2: 3
3: 3
4: -2147483648
5: -2147483648
-----End Here----------------------------
-----Start Here-----(2)
1: 3
2: 3
3: 3
4: 3
5: 3
-----End Here----------------------------
","When a signal assignment occurs, it schedules the value to be updated when a process hits a wait statement (when there is no sensitivity list) or when the process completes (when there is a sensitivity list).
In your process, at time 0, The process starts. temp has the initial value integer'low. You assign a, then b, then finally c (which wins, and temp will be scheduled to have c assigned). Remember, there is no wait statement hit by this point, so the signal assignments will not have occured yet. Hence why the report all report the initial value for temp.
If you move the report statments to be after the wait statement, you would see the updated values.",,,,,
System Verilog: Check if Signal stays high,"is there a simple way to check if a given signal stays high for a few microseconds. As far as I understood, in SVA we can only check if the signal is high at a certain timestamp.","If this signal is a module port, you can use the $width timing check.
module desgin(input wire signal);
  specify
    $width(posedge signal, 2us);
  endspecify
  ...
endmodule

If this is an arbitrary signal, you can use the bind statement to insert this module anywhere in your design
module widthcheck #(real limit) (input signal);
  specify
    $width(posedge signal, limit);
  endspecify
endmodule

module testbench;
  bind target_instance widthcheck#(2us) (target_signal);
  ...
endmodule

Of course, there is always the brute force approach
real rise, fall, width;
always begin
  wait(signal)  rise = $realtime;
  wait(!signal) fall = $realtime;
  width = fall - rise;
  if (width&lt;limit)
     $error(&quot;signal width(%t) less than limit(%t)&quot;, width, limit);
end
",,,,,
Error (10500): VHDL syntax errors in quartus (VHDL),"So this is a hw assignment in VHDL. We are comparing the first 2 bits and last 2 bits of a 4 bit binary number and when the first two are greater than the last two it should output a 1 to gt. However, I'm getting 2 errors and I have no clue how to fix them. We aren't using a process statement for this assignment.
----------------------------------
--Written by K Moore
--HW 2
--9/8/2021
-----------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
--import libraries

entity HW_two is
   port (a1    :in std_logic;
         a0    :in std_logic;
         b1    :in std_logic;
         b0    :in std_logic;
         gt    :out std_logic);
end HW_two;

--Unsimplified equation
 --A1'A0B1'B0'+ A1A0'B1'B0' + A1A0'B1'B0 + A1A0B1'B0' + A1A0B1'B0 + A1A0B1B0' = gt
--Simplified equation =&gt; gt= A0B1' + A0B1'B0' + A1A0B0'


architecture compare of HW_two is

begin
   gt &lt;= (a1 not and a0 and b1 not and b0 not) or (a1 and a0 not and b1 not and b0 not) or (a1 and a0 not and b1 not and b0) or
   (a1 and a0 and b1 not and b0 not) or (a1 and a0 and b1 not and b0) or (a1 and a0 and b1 and b0 not);
    
end compare;


Error (10500): VHDL syntax error at hw_two_kmoore.vhd(28) near text
&quot;not&quot;;  expecting &quot;)&quot;, or &quot;,&quot;
Error (10500): VHDL syntax error at hw_two_kmoore.vhd(29) near text
&quot;not&quot;;  expecting &quot;)&quot;, or &quot;,&quot;
","There is no not and operator. not expects a value to the right of it.
Acceptable logic operators are:

not
and
or
xor
nand
nor
xnor
",,,,,
Cascading of structural Model in verilog using generate and For Loop,"I am stuck in a very difficult problem. I am new to Verilog. I am not able to cascade a circuit multiple times using a for loop and generate a statement.
I am trying to generate a circuit as shown below:

The code I have written to implement is as follows:
module rightShift(
input [3 : 0] right_data_input,
output [3 : 0] right_data_output
);

assign right_data_output = right_data_input &gt;&gt; 1;
endmodule
module adder(
input [7 : 0] adder_in1,
input [7 : 0] adder_in2,
output [7 : 0] adder_out
);

assign adder_out = adder_in1 + adder_in2;
endmodule
module Mult_1(
input [3 : 0] input1,
input [7 : 0] input2,
output wire [3 : 0] output1,
output wire [7 : 0] output2
);

rightShift rs_obj(.right_data_input(input1), .right_data_output(output1));
adder add_obj(.adder_in1(output1), .adder_in2(input2), .adder_out(output2));
endmodule

module multiply(
input wire [3 : 0] in_a,
output wire [7 : 0] OUT
);

genvar i;

wire [3 : 0] x1 = 8'b0;

GENERATE

    FOR(i = 0;
        i &lt; 4;
        i = i + 1)
    BEGIN
        Mult_1 mult_obj1(
        .input1(in_a), // Need Help IN the FOR LOOP
        .input2(x1),
        .output2(OUT)
        );

    END

    endgenerate

    endmodule



    

It would be very kind if I can be helped in correcting the For loop to execute the attached circuit.","Ok with a generate loop it could look like the following with fake modules.
Supposedly you have to instantiate a module with a single input and output which you want to cascade.
module buffer(input [3:0] in, output [3:0] out); 

Your top-level module has similar inputs and outputs. In order to connect several instances of modules you need to declare connection wires. I suggest that for this scheme you create an array of them.
module top(input [3:0] in, output [3:0] out);

wire [3:0] connector [5]; // an array of 5 elements. 

now the first module is instantiated with 'in' as its input. My solution is the following here:
assign connector[0] = in; 

genvar i;
for (i = 1; i &lt;= 4; i++) begin: cascade
   buffer buf(.in(connector[i-1]), .out(connector[i]));
end

With the above scheme you instantiated 4 buffers. It is equivalent to the following.
   buffer buf(.in(connector[0]), .out(connector[1])); // [0] is the same as 'in'
   buffer buf(.in(connector[1]), .out(connector[2]));
   buffer buf(.in(connector[2]), .out(connector[3]));
   buffer buf(.in(connector[3]), .out(connector[4])); // i need connector[5] for this. [4] will go to out

and finally, you need to assign you output of the top module:
assign out = connector[4];

endmodule: top

This is one of the possible scenarios. You can come up with a different one and adapt it to your model needs.",,,,,
VHDL Modelsim: Array lengths do not match (null array vs array of length 8),"I was wondering why I am some of my std_logic_vectors are showing up as null vectors especially when I specified the length already. I'd appreciate any help possible
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.ALL;
entity counter8bits is
port(counter_enable, rst, clk : IN std_logic; counter_out : OUT std_logic_vector(7 to 0));
end entity counter8bits;

architecture counting_arc of counter8bits is
signal current_count : std_logic_vector(7 to 0);
type jstate is (nullState, start0, start1, change01, change10);
signal present_state : jstate;
signal next_state: jstate := nullState;



signal int_count: integer := 0;
begin

present_state &lt;= next_state when clk'event and clk = '1';

current_count &lt;= std_logic_vector(to_unsigned(int_count, 8)) when rising_edge(clk);
counter_out &lt;= current_count;
stacking: process(present_state)
begin

next_state &lt;= present_state;
int_count &lt;= 0 when int_count = 255;    
                    case present_state is
                    
                        when nullState =&gt;
                            if counter_enable = '0' then
                                next_state &lt;= start0;
                            else
                                next_state &lt;= start1;
                            end if;
                        
                        when start0 =&gt;
                            if counter_enable = '1' then
                                next_state &lt;= change01;
                                int_count &lt;= int_count + 1;
                            else
                                next_state &lt;= start0;
                            end if;
                        
                        when start1 =&gt;
                            if counter_enable = '0' then
                                next_state &lt;= change10;
                                int_count &lt;= int_count + 1;
                            else
                                next_state &lt;= start1;
                            end if;
                        
                        when change01 =&gt;
                            if counter_enable = '0' then
                                next_state &lt;= change10;
                                int_count &lt;= int_count + 1;
                            else
                                next_state &lt;= start1;
                            end if;
                        
                        when change10 =&gt;
                            if counter_enable = '1' then
                                next_state &lt;= change01;
                                int_count &lt;= int_count + 1;
                            else
                                next_state &lt;= start0;
                            end if;
                        when others =&gt;
                            next_state &lt;= nullState;                    

end case;

end process stacking;
end architecture counting_arc;

Here is the error: Fatal: (vsim-3420) Array lengths do not match. Left is 0 (7 to 0 (null array)). Right is 8 (7 downto 0).
Left refers to current_count and counter_out","A null range occurs when you specify the values in the wrong direction.  Here you have specified both current_count and counter_out as 7 to 0. Using to is an ascending range,  hence the first number should be the lower one.  Similarly,  downto is a descending range and should have the higher value on the left.
Here,  I suggest you replace  to with downto, as this is generally convention.",,,,,
How to fix [Common 17-1293] error in Xilinx Vivado?,"I was trying to run some simple behavioral simulations in Xilinx Vivado, but then I got the error -
[Common 17-1293] The path 'D:/Deepan/Text Books/internship/test/test.cache/wt' already exists, is a directory, but is not writable.
The Verilog files that I wanted to run used to work perfectly before, but suddenly it broke.
I made sure that the directory has proper access and was not stuck at read-only, still, I kept getting the error.
I kept getting the same error for both v2021.1 and v2020.3.
The files I wanted to run -
`timescale 1ns / 1ps

module Mealy_Sequence(
        input wire clk,
        input wire reset,
        input wire level,
        output reg tick
    );
    
    localparam  //The Mealy states
        zero = 1'b0,
        one = 1'b1;
    
    reg current_state, next_state;
    
    always  @(posedge clk, posedge reset)
    begin
        if(reset)
            current_state &lt;= zero;
        else
            current_state &lt;= next_state;
    end
    
    always  @(current_state, level)
    begin
        case(current_state)
            zero:   begin
                    if(level)
                        begin
                            next_state &lt;= one;
                            tick &lt;= 1;
                        end
                    else
                        begin
                            next_state &lt;= current_state;
                            tick &lt;= 0;
                        end
                    end
            one:    begin
                    if(level)
                        begin
                            next_state &lt;= one;
                            tick &lt;= 0;
                        end
                    else
                        begin
                            next_state &lt;= zero;
                            tick &lt;= 0;
                        end
                    end
        endcase
    end
    
endmodule

test bench -
`timescale 1ns / 1ps

module Sequence_Test_Mealy;

    reg clk;
    reg reset;
    reg level;
    wire tick;

    Mealy_Sequence x(
        .clk(clk),
        .reset(reset),
        .level(level),
        .tick(tick)
    );

    always #5 clk = ~clk;
    always #15 level = ~level;

    initial
    begin
        clk &lt;= 0;
        level &lt;= 0;
        reset &lt;= 1;
        #10 reset &lt;=0;
    end

endmodule
","Even though I had no spaces in the path names but I was still getting this error.
I solved this by making the path extremely small e.g., D:/a/a/a.xpr",,,,,
Verilog test bench for 4-bit adder with Carry Lookahead,"I'm still honestly a bit unfamiliar with Verilog especially with test benches, considering I've only created a childishly simple project once. I'm not sure how to make a test bench for a Verilog file I've made and so I can't test if it works. Here's my code:
`timescale 1ns/1ps

module adder_4bit_cla(sum, Cout, A, B, S);

    input [3:0] A, B;
    input S;
    output [3:0] sum;
    output Cout;
    
    wire P0, G0, P1, G1, P3, G3;
    wire C4, C3, C2, C1;
    
    assign
        P0 = A[0] ^ B[0],
        P1 = A[1] ^ B[1],
        P2 = A[2] ^ B[2],
        P3 = A[3] ^ B[3];
        
    assign
        G0 = A[0] &amp; B[0],
        G1 = A[1] &amp; B[1],
        G2 = A[2] &amp; B[2],
        G3 = A[3] &amp; B[3];
        
    assign
        C1 = G0 | (P0 &amp; S),
        C2 = G1 | (P1 &amp; G0) | (P1 &amp; P0 &amp; S),
        C3 = G2 | (P2 &amp; G1) | (P2 &amp; P1 &amp; G0) | (P2 &amp; P1 &amp; P0 &amp; S),
        C4 = G3 | (P3 &amp; G2) | (P3 &amp; P2 &amp; G1) | (P3 &amp; P2 &amp; P1 &amp; G0) | (P3 &amp; P2 &amp; P1 &amp; P0 &amp; S);
        
    assign
        sum[0] = P0 ^ S,
        sum[1] = P1 ^ C1,
        sum[2] = P2 ^ C2,
        sum[3] = P3 ^ C3;
        
    assign Cout = C4;
    
endmodule

Honestly, what I really need to do is a 4-bit adder-subtractor using carry lookahead, but I have no idea how to implement a carry lookahead to begin with so here I am. If anyone could help me that would be really great :&lt;
Edit: I have calmed down and I can finally pinpoint the exact problem: the values of A and B for the test bench. While I could brute force it, how can I make use of loops to increment A and B so that it would be like this:
0000
0001
0010
0011
0100
0101
0110
0111
1000
1001
1010
1011
1100
1101
1110
1111

While also updating M?","Use the following to improve your testbench.
`timescale 1ns / 1ps

module adder_4bit_cla_tb();

// inputs - keep them having reg as the data type 
reg [3:0] A, B;
reg S;

// outputs - keep them having wire as the data type 
wire [3:0] sum;
wire Cout;


adder_4bit_cla adder_4bit_cla_inst
                  (
                 .sum(sum), .Cout(Cout), .A(A), .B(B), .S(S)
                  );

initial begin
       
    A = 4'd1; B = 4'd2; S = 1'd1;
    
    #10 A = 4'd2; B = 4'd5; S = 1'd0;
    
    #10 A = 4'd5; B = 4'd6; S = 1'd0;

    #50 $stop;
    
end
endmodule

Waveform results

Inputs can be fed using for loops as follows.

`timescale 1ns / 1ps

module adder_4bit_cla_tb();

// inputs - keep them having reg as the data type 
reg [3:0] A, B;
reg S;

// outputs - keep them having wire as the data type 
wire [3:0] sum;
wire Cout;

reg [3:0] i; 

adder_4bit_cla adder_4bit_cla_inst
                  (
                 .sum(sum), .Cout(Cout), .A(A), .B(B), .S(S)
                  );

initial begin
     
    for(i = 4'd0; i &lt; 4'd15; i = i + 4'd1) begin  
    
    A = i; B = i; S = 1'b0;
    
    #10;
    
    end
    
    #200 $stop;
    
end
endmodule


Waveform Results
",,,,,
Basic questions about Verilog,"Why adding the concatenation operator can rand a postive value from 0~59?
reg [23:0] rand;
rand = {$random} % 60;

Why the concatenation operator {} can make such difference?","from IEEE-1364

17.9.1 $random function. The system function $random provides a mechanism for generating random numbers. The function returns a new 32-bit random number each time it is called. The random number is a signed integer; it can be positive or negative.

Result of concatenation {} is always an unsigned number. This is not spelled explicitly in the standard, but even the example (from the standard) which you cited implies it.
There is no difference between signed and unsigned numbers in their bit representations. Only certain operation care about the signs of the operands, including %.
A 32-bit signed integer can represent values between -2,147,483,648 and 2,147,483,647, therefore the results of $random % 60 will be between -59 and 59.
A 32 bit unsigned integer can represent values between 0 and 4,294,967,295, therefore the result of {$random} % 60 will be from 0 to 59.",,,,,
How to set frequency in vhdl at 0.01 Hz?,"I need to divide frequency in vhdl so the resulting frequency will be 0.01 Hz,but I Don't know how to do it. I tried by using generic map, but then I got error. I am using Nexys3. I know Nexys3's frequency is 100 MHz, so I tried to divide it to 0.01.
entity stotinkasekunde is
port (
    izlaz: out std_logic_vector(3 downto 0);
    led: out std_logic_vector(6 downto 0);
    clk, ss: in std_logic
);
end stotinkasekunde;

architecture Behavioral of stotinkasekunde is
signal clk_o: std_logic;
signal temp: std_logic_vector(3 downto 0);
begin
s1: entity work.frekdiv generic map(10000000000) port map(clk, clk_o);
process (clk_o)
begin
    if (clk_o'event and clk_o='1') then
        if (ss='1') then
            temp &lt;= temp+1;
            if (temp &gt;= 1010) then
                temp &lt;= &quot;0000&quot;;
            end if;
        end if;
    end if;
end process;

ERROR: Line 18: Literal 10000000000 exceeds maximum integer value.","For 100Mhz specifically start by a break down of the problem into two parts

Divide the frequency by a highest divisible power of 2 so that it divides the input clock to an integer highest power of 2 by using an approach from here using a bit magic expression (n &amp; (~(n - 1))) to find that number or trying all series from 1st power till the 26th power of 2 closest to the number but off by a factor below 2, in other words 100000000 / 2^26 = 1.490116 as the upper bound of the series ( https://www.geeksforgeeks.org/highest-power-of-two-that-divides-a-given-number/ )

Then by non integer power of 2 ( https://www.slideshare.net/DeepakFloria/divide-by-n-clock, https://en.wikipedia.org/wiki/Frequency_divider )

By dividing by powers of 25
Then by a power of 10



So, the resulting clock frequency division calculation could be written as 100000000 Hz / ((2^8)* (25 ^ 4) * (10)) which exactly equals 0.1 Hz
Notes:
How do we find a number that has same rightmost set bit and all other bits as 0?
Remember: The overall scheme  is to take 100000000Hz  then divide by largest even power of 2 (why even, since power of 2 are already even, hint base 2...)
Then proceed to divide 390625 Hz which is its self a power of 25, specifically because of 625 as the lowest portion of the number 625, 25^2, and 2 390000, the upper remaining portion when you subtract 25, a nice power of 625 itself, making the original divisible by 25.
Take that divide 25, divide by 25, divide by 25, divide by 25
And then divide by 10 to get 0.1 Hz
How to implement:
Divide by 2
can be done by using mod-n counter where n is a power of 2 in our case, or some sort of shift register, Johnson Counter, etc...
Divide by either 25 (or powers of 25), or Divide by 10
Both use example scheme seen below in the link, but not using same numbers though
https://electronics.stackexchange.com/a/61607/20332
Or, use the Xilinx Clocking wizard to generate this block
https://electronics.stackexchange.com/a/61620/20332
Divide by 25 might be available as an existing resource on the FPGA, but if not refer to wiki (https://en.wikipedia.org/wiki/Frequency_divider) for more information.
Finally, make sure to run a behavioral simulation to find the markers to place on the zoomed out resulting clock rising edge, to next rising edge to be able to measure the period of the resulting clock generated in your output waveform, and verify it is correct, based on your VHDL time scale if I am using the right terminology since this is a terminology in Verilog HDL,  for sure when I was using Verilog.",,,,,
Is it reasonable to use a static member function within another static member function contained within the same class?,"I am attempting to reorganize some code such that it is self-documenting. If I have a class that I don't intend to instantiate, but rather want to call to perform various tasks all related to the same idea, can I create simple static member functions that are then called by later static member functions (Or tasks in my case)?
class foo;
  
  static protected bit [7:0] Data_A;
  static protected bit [7:0] Data_B;

  static task bar();
    /* Use to print out info. in Data_A and Data_B. */
  endtask : bar

  static task FooBar();
    /* Perform some manipulations on Data_A and Data_B. */
    bar();
  endtask : FooBar

endclass : foo


Then in my program I would do something like:
program automatic main();
  initial
    begin
    foo::FooBar();
    $finish;
    end
endprogram

Does this seem sound? Thank you for your time. I have been reading the IEEE System-Verilog standard, but this situation does not seem to come up.
Edit: Do I need to use the &quot;this&quot; keyword, or is that reserved for instantiated classes to refer to the self?","It is perfectly appropriate to be able to call one static method of a class from another. You do not use the this prefix to call a static method. You could prefix your call with foo::bar() just to make it clearer to the reader that you are calling a static method, but the language does not need it.
Any class you do not want constructed should be declared as
virtual class foo;

You can even go further by declaring the constructor as
local function new; endfunction

That keeps people from extended it and constructing, but that might be an overkill.
And finally a suggestion: what you are doing might be better suited for a package
package automatic foo;
  
  bit [7:0] Data_A;
  bit [7:0] Data_B;

  task bar();
    /* Use to print out info. in Data_A and Data_B. */
  endtask : bar

  task FooBar();
    /* Perform some manipulations on Data_A and Data_B. */
    bar();
  endtask : FooBar

endpackage : foo


module automatic main();
  initial
    begin
    foo::FooBar();
    $finish;
    end
endmodule
",,,,,
What does the double slash(transition 0 --> 1) mean in SRAM datasheet?,"The following image is from the datasheet of SRAM IS64WV51216BLL(page 15).
It is a SRAM's write timing diagram.I don't know the meaning of double transitions for WE signal.I have circled it in red.
SRAM write timing diagram

Timing Diagram Basics


Understanding Timing diagrams of digital systems


How to Read Timing Diagrams: A Makerâ€™s Guide 

Acturally I have searched many material,but nothing I wanted.Please help me!Thank you very much.","That is not multiple transitions, rather it is a timing window where the transition can happen which is bounded by two timing constraints: tSA and tPWE.
tSA is the Address Setup time which is the earliest that WÌ„ can be asserted. tPWE is the latest WÌ„ can be asserted and not violate the Pulse Width.",,,,,
What purpose does a queue serve in System Verilog?,"
They are not used for RTL but rather verification, correct? They would not be synthesizable.

Do they have better memory management features in turn optimizing program time? If I recall
correctly, System Verilog has an automatic garbage collector, so there is no need to deallocate memory.

The official IEEE documentation does a great job of explaining how they work. I am just wondering in what scenarios I would use one vs an array. One guess would be that they have associated methods that allow for easier data manipulation?


Thank you in advance for your knowledge and expertise.","
A queue can be synthesisable if it has a bounded maximum size. Only a few synthesis tools support it, probably none of the FPGA synthesis tools.
The key advantage with a queue is in efficiency adding/removing one element from the array, especially when accessed at the head or tail of the queue. A dynamic array may require reallocation and copying the entire array when modifying its size. The penalty for a queue is the extra time it takes to access elements in the middle of the queue, and extra space compared with the same number of element of a dynamic array.
I hope that 2 answers this question.
",,,,,
incrementing mod counter every n clock cycle,"This is the verilog code for mod 64 counter, incrementing every clock cycle
module modulus64counter
#(parameter N=64,
parameter WIDTH=5)
(input clk,
input rstn,
output reg[WIDTH-1:0] out);
integer i;
always @(posedge clk) begin
if(!rstn) begin
out&lt;=0;
end
else begin
if(out==N-1)
out&lt;=0;
else 
out&lt;= out+1;
end
end
endmodule

and the test bench is
module modulus64countertb;

    // Inputs
    reg clk;
    reg rstn;

    // Outputs
    wire [4:0] out;

    // Instantiate the Unit Under Test (UUT)
    modulus64counter uut (
        .clk(clk), 
        .rstn(rstn), 
        .out(out)
    );
    always #10 clk = ~clk;
    initial begin
        // Initialize Inputs
        clk = 1;
        rstn = 0;

        $monitor (&quot;T=%0t rstn=%0b out=0X%h&quot;, $time,rstn,out);
repeat(2) @(posedge clk);
rstn &lt;=1;
repeat(50) @(posedge clk);
$finish;
end
endmodule

Now if i want to increment the value of out every &quot;n&quot; clock cycle instead of consecutive clock cycle , how can i modify the program
Kindly help","Updated 20220131
Updated the code to produce output after every 2 clock cycles. Similarly, if you wish to delay for even more clock cycle, the simplest way is to continuously flopping it.
For a better implementation, you can try out a shift register.
module modulus64counter #(
    parameter               N=64,
    parameter               WIDTH=8,
    parameter               DELAY_CYCLE=2
)(
    input                   clk,
    input                   rstn,
    output reg[WIDTH-1:0]   out,
    output reg[WIDTH-1:0]   actual_out
);
    integer                 i;
    reg       [WIDTH-1:0]   cntr;
  
    reg       [WIDTH-1:0]   dly1clk;
    
    always @(posedge clk) begin
        if(!rstn) begin
            out &lt;= 0;
            dly1clk &lt;= 0;
        end else if(out == DELAY_CYCLE-1) begin
            out &lt;= 0;
            dly1clk &lt;= dly1clk + 1;
        end else begin
            out &lt;= out + 1;
        end
    end
  
    always @(posedge clk) begin
        if(!rstn) begin
            actual_out &lt;= 0;
        end else begin
            actual_out &lt;= dly1clk;
        end
    end
endmodule



The code below should work for you. You can always swap the out and actual_out if you insist on using out as the final counting variable.
Also, removing the out on the monitor line in the testbench will only print the value when it reaches mod n. I kept both out and actual_out on testbench's monitor to ease debugging purpose.
Verilog code
module modulus64counter #(
    parameter               N=64,
    parameter               WIDTH=8
)(
    input                   clk,
    input                   rstn,
    output reg[WIDTH-1:0]   out,
    output reg[WIDTH-1:0]   actual_out
);
    integer                 i;
    reg       [WIDTH-1:0]   cntr;
    
    always @(posedge clk) begin
        if(!rstn) begin
            out &lt;= 0;
            actual_out &lt;= 0;
        end else if(out == N-1) begin
            out &lt;= 0;
            actual_out &lt;= actual_out + 1;
        end else begin
            out &lt;= out + 1;
        end
    end
endmodule


Testbench
module modulus64countertb;

    // Inputs
    reg         clk;
    reg         rstn;

    // Outputs
    wire [7:0]  out;
    wire [7:0]  actual_out;

    // Instantiate the Unit Under Test (UUT)
    modulus64counter uut (
        .clk(clk), 
        .rstn(rstn), 
        .out(out),
        .actual_out(actual_out)
    );
  
    always #10 clk = ~clk;
    initial begin
        // Initialize Inputs
        clk  = 1;
        rstn = 0;

        $monitor (&quot;T=%0t rstn=%0b out=%d actual_out=%d&quot;, $time,rstn,out,actual_out);
        repeat(2) @(posedge clk);
        rstn &lt;=1;
        repeat(200) @(posedge clk);
        $finish;
    end
endmodule

Output result simulated using edaplayground:
",,,,,
Why does the order of the lines of code not matter in Hardware Description Language?,"Per the nand2tetris course material, &quot;Since the language is designed to describe connections rather than processes, the order of the PARTS statements is insignificant: as long as the chip-parts are connected correctly, the chip will function as stated.&quot;
How does the sequence of the code below not matter though given that the carry bits are calculated using the carry bits of previous bit calculations?
/**
 * Adds two 16-bit values.
 * The most significant carry bit is ignored.
 */

CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    HalfAdder(a=a[0], b=b[0], carry=carry0, sum=out[0]);
    FullAdder(a=a[1], b=b[1], c=carry0, carry=carry1, sum=out[1]);
    FullAdder(a=a[2], b=b[2], c=carry1, carry=carry2, sum=out[2]);
    FullAdder(a=a[3], b=b[3], c=carry2, carry=carry3, sum=out[3]);
    FullAdder(a=a[4], b=b[4], c=carry3, carry=carry4, sum=out[4]);
    FullAdder(a=a[5], b=b[5], c=carry4, carry=carry5, sum=out[5]);
    FullAdder(a=a[6], b=b[6], c=carry5, carry=carry6, sum=out[6]);
    FullAdder(a=a[7], b=b[7], c=carry6, carry=carry7, sum=out[7]);
    FullAdder(a=a[8], b=b[8], c=carry7, carry=carry8, sum=out[8]);
    FullAdder(a=a[9], b=b[9], c=carry8, carry=carry9, sum=out[9]);
    FullAdder(a=a[10], b=b[10], c=carry9, carry=carry10, sum=out[10]);
    FullAdder(a=a[11], b=b[11], c=carry10, carry=carry11, sum=out[11]);
    FullAdder(a=a[12], b=b[12], c=carry11, carry=carry12, sum=out[12]);
    FullAdder(a=a[13], b=b[13], c=carry12, carry=carry13, sum=out[13]);
    FullAdder(a=a[14], b=b[14], c=carry13, carry=carry14, sum=out[14]);
    FullAdder(a=a[15], b=b[15], c=carry14, carry=carry15, sum=out[15]);
","Because all the calculations are being computed concurrently. In an  hdl each instance of a block/entity/module create an instance of all the behaviors inside. You didn't specify which one you're using, but almost all behave the same.",,,,,
How to parameterize verilog attribute (* *)?,"How can I declare a signal with a verilog attribute depending on module's parameter?
I tried:
if (KEEP_VERILOG) begin
  (*keep=&quot;true&quot;*)reg mysig;
end else begin
  reg mysig;
end

// doing something with mysig

I get a synthesis error: mysig is not declared","Attribute spec allows using constant expressions. Therefore you can use module parameter directly in the attribute:
(*keep=KEEP_VERILOG*) reg mysig;

The value of the attribute will have the value of the parameter.",,,,,
Are SystemVerilog packed arrays row or column major for literal assignment?,"I want to use multi-dimensional arrays for some SystemVerilog code that I intend to synthesize. My understanding is that packed arrays are essentially a big vector that can be indexed slice or element-wise in the code.
So, is the following allowed?
logic [4:0] [2][2] my_array;

assign my_array = '{ 4'd1, 4'd2, 4'd3, 4'd4 };

And if it is, is the literal interpreted as row or column major? I know I can manually separate the literals into a hierarchy that matches the 2x2 array, but these modules will be instantiated in auto-generated code from a high level language. I'd like to orient my arrays so it matches the column major orientation of the high level language.","There are a couple of problems with your code. The use of the single number range [2] is not allowed and the 1800-2023 LRM will be more explicit about why this is not allowed. Some tools have allowed it but implemented the range in the reverse endianness of what most people expect for packed ranges.
If you wanted a 3-dimensional packed array of 2 rows by 3 columns by 5 bits, you would use
logic [0:1][0:2][4:0] my_array;

And finally, there is no type safety with packed arrays. When writing a literal concatenation, if you get the number of elements wrong or have the wrong size of an element, you get silent truncation or padding of bits. If you had the following
logic [0:1][0:2][4:0] my_array;

my_array = {4'd1,4'd2,4'd3,  4'd4,4'd5,4'd6};

# my_array is '{'{5'h00, 5'h01, 5'h04}, '{5'h0d, 5'h02, 5'h16}}

You need to write it as
my_array = {5'd1,5'd2,5'd3,  5'd4,5'd5,5'd6};
",,,,,
Verilog tasks yielding different results compared to direct coding,"The two simplified code sections yield different results (this is the only difference)

Wihtout task decleration
...
if (A) wait (flagA);
if (B) wait (flagB);
...

with task decleration
...
task test(input flag)
begin
wait(flag);
end
endtask
if (A) test(flagA);
if (B) test(flagB);
...


Would very much appreciate any insights - what is the difference between the two?
Thanks!","The problem is that input arguments to tasks are by default copied by value upon entry to the task. If the actual argument changes while the task is suspended (i.e. the wait) the task does not see the updated value of the argument.
One way to accomplish what you want in SystemVerilog is passing the argument by reference ref:
task test(ref logic flag);
  if (A) test(flagA); if (B) test(flagB); ...

Passing by ref has some stricter type requirement, and you cannot pass a wire by reference.
The other way is globally referencing flag the same as you are doing with signals A and B",,,,,
VHDL Increment Signal doesn't work properly,"I have a problem with my vhdl code. I have a signal whitch I want to increment every phase. So i wrote this code:
--module.vhd
enter image description here
library ieee; 

use ieee.std_logic_1164.all; 

--use ieee.numeric_std.all;     

use ieee.std_logic_unsigned.all;   



entity module is 

  port( CLK, RESET: in std_logic; 

    MODE: in  std_logic_vector(1 downto 0); 

    Q: out std_logic_vector(3 downto 0)); 

end; 

 

architecture arch of module is 

--##INSERT YOUR CODE HERE 

signal Q_INT : std_logic_vector(3 downto 0); --local signal 

begin 



process(RESET,CLK)

begin

if CLK = '1' and CLK'event then

    if RESET ='1' then

      Q &lt;= (others =&gt; '0');

 else

    Q &lt;= Q_INT;

    

 case MODE is

    when &quot;00&quot; =&gt; Q_INT&lt;= Q_INT + &quot;0001&quot;;

    when &quot;01&quot; =&gt; Q_INT&lt;= Q_INT +&quot;0010&quot;;

    when &quot;10&quot; =&gt; Q_INT&lt;= Q_INT +&quot;0011&quot;;

    when &quot;11&quot; =&gt; Q_INT&lt;= Q_INT +&quot;0100&quot;;

    when others =&gt; null;

    end case;

    Q &lt;= Q_INT;       

end if;

end if;

end process;





    --if (MODE = &quot;00&quot;) then

     --Q_INT &lt;= Q_INT + &quot;0001&quot;;

     --elsif (MODE = &quot;01&quot;) then

     --Q_INT &lt;=Q_INT + &quot;0010&quot;;

     --elsif (MODE = &quot;10&quot;) then

     --Q_INT &lt;=Q_INT + &quot;0011&quot;;

     --elsif (MODE = &quot;11&quot;) then

     --Q_INT &lt;=Q_INT + &quot;0100&quot;;

     --end if;

     --Q &lt;= Q_INT;

--end process;

--##INSERT YOUR CODE HERE 

end;

And the testbench look like this:
library ieee;

use ieee.std_logic_1164.all;



entity TB_MODULE is

end TB_MODULE;



architecture TESTBENCH of TB_MODULE is

  constant tbase: time:=10 ns;

  constant tcheck: time:=1 ns;

  signal TB_CLK: std_logic;



  component MODULE

    port( CLK, RESET: in std_logic; 

      MODE: in  std_logic_vector(1 downto 0); 

      Q: out std_logic_vector(3 downto 0)); 

  end component;

  signal TB_RESET: std_logic;

  signal TB_MODE: std_logic_vector(1 downto 0);

  signal TB_Q: std_logic_vector(3 downto 0);

  signal expTB_Q: std_logic_vector(3 downto 0);

begin



  CLOCK: process 

    begin 

     TB_CLK &lt;='1';

     wait for tbase/2;

     TB_CLK &lt;='0';

     wait for tbase/2;

  end process CLOCK;



  DUT: MODULE port map(TB_CLK, TB_RESET, TB_MODE, TB_Q);



  STIMULI: process 

  begin

    TB_RESET&lt;='1','0' after 1*tbase, '0' after 2*tbase;



    TB_MODE&lt;=&quot;00&quot;, &quot;00&quot; after 1*tbase, &quot;01&quot; after 2*tbase, &quot;10&quot; after 3*tbase, 

         &quot;11&quot; after  4*tbase, &quot;00&quot; after  5*tbase; 

     

    expTB_q&lt;=x&quot;0&quot;, x&quot;1&quot; after 1*tbase, x&quot;3&quot; after 2*tbase, x&quot;6&quot; after 3*tbase, 

         x&quot;A&quot; after  4*tbase, x&quot;B&quot; after  5*tbase, x&quot;C&quot; after  6*tbase; --then incrementing

    wait; -- end simulation

  end process STIMULI;  



  --simmuli templates

  --STIMULI: process 

  --begin

  --  TB_RESET&lt;='1','0' after 1*tbase, '0' after 2*tbase;

  --

  --  TB_A&lt;='0', '0' after 1*tbase, '1' after 2*tbase, '0' after 3*tbase, 

  --       '0' after  4*tbase, '1' after  5*tbase; 

  --  TB_B&lt;='0', '0' after 1*tbase, '0' after 2*tbase, '0' after 3*tbase, 

  --       '1' after  4*tbase, '1' after  5*tbase;

  --

  --  expTB_q&lt;='0', '0' after 1*tbase, '0' after 2*tbase, '0' after 3*tbase, 

  --       '0' after  4*tbase, '1' after  5*tbase; 

  --  wait; -- end simulation

  --end process STIMULI;  

  --STIMULI: process 

  --begin

      --TB_A&lt;=0', '0' after 1*tbase, '0' after 2*tbase, '0' after 3*tbase, 

      --     '0' after  4*tbase, '0' after  5*tbase, '0' after  6*tbase, '0' after  7*tbase,

      --     '1' after  8*tbase, '1' after  9*tbase, '1' after 10*tbase, '1' after 11*tbase,

      --     '1' after 12*tbase, '1' after 13*tbase, '1' after 14*tbase, '1' after 15*tbase; 

      --TB_B&lt;='0', '0' after 1*tbase, '0' after 2*tbase, '0' after 3*tbase, 

      --     '1' after  4*tbase, '1' after  5*tbase, '1' after  6*tbase, '1' after  7*tbase,

      --     '0' after  8*tbase, '0' after  9*tbase, '0' after 10*tbase, '0' after 11*tbase,

      --     '1' after 12*tbase, '1' after 13*tbase, '1' after 14*tbase, '1' after 15*tbase;

      --TB_C&lt;='0', '0' after 1*tbase, '1' after 2*tbase, '1' after 3*tbase, 

      --     '0' after  4*tbase, '0' after  5*tbase, '1' after  6*tbase, '1' after  7*tbase,

      --     '0' after  8*tbase, '0' after  9*tbase, '1' after 10*tbase, '1' after 11*tbase,

      --     '0' after 12*tbase, '0' after 13*tbase, '1' after 14*tbase, '1' after 15*tbase;

      --TB_D&lt;='0', '1' after 1*tbase, '0' after 2*tbase, '1' after 3*tbase, 

      --     '0' after  4*tbase, '1' after  5*tbase, '0' after  6*tbase, '1' after  7*tbase,

      --     '0' after  8*tbase, '1' after  9*tbase, '0' after 10*tbase, '1' after 11*tbase,

      --     '0' after 12*tbase, '1' after 13*tbase, '0' after 14*tbase, '1' after 15*tbase;

      --expTB_bus&lt;=&quot;0000&quot;, &quot;0001&quot; after 1*tbase, &quot;0010&quot; after 2*tbase, 

      --   &quot;0011&quot; after  3*tbase, &quot;0100&quot; after  4*tbase, &quot;0101&quot; after  5*tbase, 

      --   &quot;0110&quot; after  6*tbase, &quot;0111&quot; after  7*tbase, &quot;1000&quot; after  8*tbase, 

      --   &quot;1001&quot; after  9*tbase, &quot;1010&quot; after 10*tbase, &quot;1011&quot; after 11*tbase,

      --   &quot;1100&quot; after 12*tbase, &quot;1101&quot; after 13*tbase, &quot;1110&quot; after 14*tbase, 

      --   &quot;1111&quot; after 15*tbase;

      --expTB_buxhex&lt;=x&quot;0&quot;, x&quot;1&quot; after 1*tbase, x&quot;2&quot; after 2*tbase, x&quot;3&quot; after 3*tbase, 

      --   x&quot;4&quot; after  4*tbase, x&quot;5&quot; after  5*tbase, x&quot;6&quot; after  6*tbase, x&quot;7&quot; after  7*tbase,  

      --   x&quot;8&quot; after  8*tbase, x&quot;9&quot; after  9*tbase, x&quot;A&quot; after 10*tbase, x&quot;B&quot; after 11*tbase,

      --   x&quot;C&quot; after 12*tbase, x&quot;D&quot; after 13*tbase, x&quot;E&quot; after 14*tbase, x&quot;F&quot; after 15*tbase;

  --end process STIMULI;  



end TESTBENCH;

Now my Problem is that i don't get the right values for Q_Int. It's always an 'X'. (But i want to get a number. Thanks for the enter image description herehelp","Your code is syntactically correct, and will increment Q_int by the required amount. The problem is that Q_int is initialised to &quot;UUUU&quot; and is not assigned a value on reset. And when you add anything to &quot;UUUU&quot;, you get &quot;UUUU&quot;.
The answer here is to either:
Give Q_int and initial value:
eg.
signal Q_int : std_logic_vector(3 downto 0) := &quot;0000&quot;;

or assign Q_int a value when reset occurs
if RESET ='1' then
  Q_int &lt;= &quot;0000&quot;;
  --etc

The second case will also avoid the reset-&gt;clock enable connection you will have created by not resetting Q_int when Q is reset.
On a side note, you are using non-standard VHDL library std_logic_unsigned . It is recommended that you stick to standard vhdl library numeric_std and use the unsigned type, or with VHDL 2008 you can use the ieee.numeric_std_unsigned package, that allows you to use std_logic_vector as a numerical unsigned value.",,,,,
problem compiling a switch case statement in chisel,"I was writing a simple switch-case for my state machine. However, after calling sbt test I receive the following error:
","It's very important to include the version of Chisel and your code when asking a question, but fortunately this one rings a bell as https://github.com/chipsalliance/chisel3/pull/1595.
You can workaround this by importing chisel3.util._. The better solution would be to update your version of Chisel, this bug is fixed in versions v3.2.8, v3.3.3, and v3.4.0 (and newer).",,,,,
Is it allowed to use #1step as a procedural delay?,"I am not sure if the LRM is clear about the #1step usage, but I have a case of creating a smallest possible delay a simulator could detect. So, I have written the following code:
virtual task drive_signal();
      // Initialise mysignal to a value of '1'.
      m_vif.mysignal= 1;
      #1step; // Advance with 1 time step
      m_vif.mysignal= 0;
      #m_cfg.configured_delay; //Delay by configured value
      m_vif.mysignal= 1;

endtask

Is this a valid way to do so?
I did however use #0 instead of #1step but it did not create any runtime delay.","This is currently an open issue in the IEEE 1800-2017 SystemVerilog LRM, but the intent was not to allow it.
The use of simple delays like #0 or #1 is a bad practice as they increase the potential for race conditions. Since you tagged this question with UVM, the use of any delays in a driver is highly discouraged and instead you should use synchronous clock edge in an interface or top-level testbench.",,,,,
Is the For loop a software for loop instead of the hardware for loop in verilog in the intial block,"The for loop outside the intial block generates hardware (with genvar), but the for loop in intial block in verilog works like the software for loop right?
The intial block is ofcourse only for simulation purposes so the software for loop makes sense.
One example is here. The test bench from that example that displays the use of the for loops in discussion is shown below:
module fsm_test;

reg  clk, rst, inp;
wire outp;
reg[15:0] sequence;
integer i;

fsm dut( clk, rst, inp, outp);

initial
begin

   clk = 0;
        rst = 1;
        sequence = 16'b0101_0111_0111_0010;
   #5 rst = 0;

   for( i = 0; i &lt;= 15; i = i + 1)
   begin
      inp = sequence[i];
      #2 clk = 1;
      #2 clk = 0;
      $display(&quot;State = &quot;, dut.state, &quot; Input = &quot;, inp, &quot;, Output = &quot;, outp);

   end
        test2;
end
task test2;
   for( i = 0; i &lt;= 15; i = i + 1)
   begin
      inp = $random % 2;
      #2 clk = 1;
      #2 clk = 0;
      $display(&quot;State = &quot;, dut.state, &quot; Input = &quot;, inp, &quot;, Output = &quot;, outp);

   end
endtask


endmodule
","All code that you write in Verilog can be simulated (assuming no syntax or semantic errors). Only a subset of the code you write and simulate can be synthesized into hardware. The simulator has no knowledge of what subset will eventually be synthesized, the executional behavior is the same.
A simulator executes a procedural-for loop the same way it would in almost any software programming langauge in 3-steps

Initialize the loop variable.
Test the condition; if true, procedurally execute the loop body statements; if false, proceed to the statement following the for loop.
Increment the loop variable (or whatever needs to be done) at the end of the loop and go back to step 2.

A simulator unrolls a generate-for loop prior to execution. It simply replicates the code inside the loop replacing the loop variable with. different constant loop value for each replication of the loop. And the code inside a generate-for loop is not procedural statements; the code will be instances of structure that could be other always or initial blocks.
A synthesis tool never executes procedural code. From its perspective, there is no difference between a generate-for and a procedural-for; it unrolls both loops into a replications of the loop with a different constant loop value of each iteration of the loop.",,,,,
Applying Modulo To a Negative Number In Verilog,"In general math and software programming, -4 mod 5 = 1. But in Verilog, the answer turns out to be 2. The reason for this seems to be because of division happening in binary. How do I properly handle this calculation? Following is a Verilog code that reproduces this behaviour.
module test (a,b,c);

input [0:3]a,b;
output [0:3]c;

assign a = -4'd4;
assign b = 4'd5;
assign c = a%b;

endmodule
","Your code does % operation on unsigned data. In this scheme -4 is just the same as 12 unsigned and the result of modulo is 2.
You need to use signed data as in here:
module test (
input signed [0:3]a,b, // &lt;&lt;&lt;&lt; signed
output signed [0:3]c   // &lt;&lt;&lt;&lt; signed
):
assign a = -4'd4;
assign b = 4'd5;
assign c = a%b;

always @*
  $display(a,b,c);
  
endmodule

And the result is -4, as expected from general programming rules.",,,,,
My VDHL code runs incorrectly - square root in vhdl,"library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity RaccinCarreSequentielle is

generic(    
    N: natural:= 16
    );
port(
    X: unsigned(2*N-1 downto 0);
    reset : in std_logic; --clear signal
    clk : in std_logic;
    state_done :  in std_logic; --start
    result_done : out std_logic;
    result :      out unsigned(2*N-1 downto 0)
    );
end entity;

architecture state_machine_raccincarre_arc of RaccinCarreSequentielle is
    type state is (s0_wait,s1_init,s2_calcul,s3_fini);
    signal pre_state,next_state: state;
begin
    state_register:process(reset,clk)
    begin
        if reset = '1' then
            pre_state &lt;= s0_wait;
        elsif rising_edge(clk) then
            pre_state &lt;= next_state;
        end if;
    end process state_register;

state_machine: process(pre_state,state_done)
    variable rx,rz,rv : unsigned(2*N-1 downto 0);
    variable ri: unsigned(N-1 downto 0);
begin
    case pre_state is
        when s0_wait =&gt;
            if state_done = '1' then
                next_state &lt;= s1_init;
            else 
                next_state &lt;= s0_wait;
            end if;
        when s1_init =&gt; 
            next_state &lt;= s2_calcul;
            rx := x;
            rz := (others =&gt; '0');
            rv := (2*N-2 =&gt; '1', others =&gt; '0');
            ri := to_unsigned(N-1,N);
        when s2_calcul =&gt;
            if ri &gt; 0 then
                    ri := ri - 1;
                    rz := rz + rv;
                    if rx &gt; rz then
                         rx := rx - rz;
                         rz := rz + rv;
                    else 
                         rz := rz - rv;
                    end if;
                    rz := '0' &amp; rz(2*N-1 downto 1);
                    rv := &quot;00&quot; &amp; rv(2*N-1 downto 2);
                    next_state &lt;= s2_calcul;
                 else
                    next_state &lt;= s3_fini;
            end if;
        when s3_fini =&gt;
            result &lt;= rz;           
            if state_done = '0' then
                next_state &lt;= s0_wait;
            else 
                next_state &lt;= s3_fini;
            end if;
        when others =&gt;
            null;
    end case;
end process state_machine;
                
result_proc: process(pre_state)
begin
    if pre_state = s3_fini then
        result_done &lt;= '1';
    else 
        result_done &lt;= '0';
    end if;
end process result_proc;
end architecture; 

When i use the for loop inside state2, my code will run correctly and my result is good. For example when i want to find the square root of 255, i will have 15. But when I dont want to use For loop in state2_calcul as you see. So i did a if statement to reduce the variable RI each time i go to state2 like below. I did a simulation but the state always stops at state2, it can not go through like my link.

when s2_calcul =&gt;
    if ri &gt; 0 then
            ri := ri - 1;
            rz := rz + rv;
            if rx &gt; rz then
                 rx := rx - rz;
                 rz := rz + rv;
            else 
                 rz := rz - rv;
            end if;
            rz := '0' &amp; rz(2*N-1 downto 1);
            rv := &quot;00&quot; &amp; rv(2*N-1 downto 2);
            next_state &lt;= s2_calcul;
         else
            next_state &lt;= s3_fini;
    end if;

I think that problem is the nested IF, but when i change that, nothing change. Could someone helps me explain that problem and how can i solve it. thanks","You cannot memorize anything in a combinatorial part of your design. So you need registers for ri, rx, rv and rz. These registers are somehow part of your global state which is indeed a combination of them, and of the pre_state register.
Let's continue with the style you already use: one synchronous process for the registers, another for the combinatorial part, and a next_xxx signal for the input of each xxx register.
architecture state_machine_raccincarre_arc of RaccinCarreSequentielle is
    type state is (s0_wait, s1_init, s2_calcul, s3_fini);
    signal pre_state, next_state: state;
    signal rx, rz, rv, next_rx, next_rz, next_rv: unsigned(2*N-1 downto 0);
    signal ri, next_ri: unsigned(N-1 downto 0);
begin
    state_register:process(reset,clk)
    begin
        if reset = '1' then
            pre_state &lt;= s0_wait;
            rx &lt;= (others =&gt; '0');
            rz &lt;= (others =&gt; '0');
            ri &lt;= (others =&gt; '0');
            rv &lt;= (others =&gt; '0');
        elsif rising_edge(clk) then
            pre_state &lt;= next_state;
            rx &lt;= next_rx;
            rz &lt;= next_rz;
            ri &lt;= next_ri;
            rv &lt;= next_rv;
        end if;
    end process state_register;

    state_machine: process(pre_state, state_done, x, rx, rz, rv, ri)
        variable tmpz : unsigned(2*N-1 downto 0);
    begin
        next_state &lt;= pre_state;
        next_rx    &lt;= rx;
        next_rz    &lt;= rz;
        next_rv    &lt;= rv;
        next_ri    &lt;= ri;
        tmpz       := (others =&gt; '0');
        case pre_state is
            when s0_wait =&gt;
                if state_done = '1' then
                    next_state &lt;= s1_init;
                end if;
            when s1_init =&gt;
                next_state &lt;= s2_calcul;
                next_rx &lt;= x;
                next_rz &lt;= (others =&gt; '0');
                next_rv &lt;= (others =&gt; '0');
                next_rv(2*N-2) &lt;= '1';
                next_ri &lt;= to_unsigned(N-1,N);
            when s2_calcul =&gt;
                if ri &gt; 0 then
                    next_ri &lt;= ri - 1;
                    tmpz := rz + rv;
                    if rx &gt; tmpz then
                        next_rx &lt;= rx - tmpz;
                        tmpz := tmpz + rv;
                    else
                        tmpz := tmpz - rv;
                    end if;
                    next_rz &lt;= '0' &amp; tmpz(2*N-1 downto 1);
                    next_rv &lt;= &quot;00&quot; &amp; rv(2*N-1 downto 2);
                else
                    next_state &lt;= s3_fini;
                end if;
            when s3_fini =&gt;
                if state_done = '0' then
                    next_state &lt;= s0_wait;
                end if;
        end case;
    end process state_machine;

    result &lt;= rz;
    result_done &lt;= '1' when pre_state = s3_fini else '0';
end architecture;

See? The sensitivity list of the combinatorial process contains all signals that the process reads, the signals it assigns are always assigned (thanks to the default assignments at the very beginning), and the only variable is always assigned before it is used (thanks also to the default assignment at the very beginning).
Note that, thanks to the default assignments at the very beginning, there is no risk to get latches at synthesis. By default these:
next_xxx &lt;= xxx;

assignments say that by default the xxx register shall not change. An interesting side effect is that you do not need any more some of your else statements. You can replace:
        when s0_wait =&gt;
            if state_done = '1' then
                next_state &lt;= s1_init;
            else 
                next_state &lt;= s0_wait;
            end if;

by:
        when s0_wait =&gt;
            if state_done = '1' then
                next_state &lt;= s1_init;
            end if;

because the else clause is already what happens by default.
Of course, it could be that it does not work exactly as you would like because the structure is totally different. But at least this should be a good starting point for your debugging. Just remember the main principles of combinatorial processes for synthesis:

the sensitivity list must contain all signals that the process reads (the all keyword of the VHDL 2008 standard is helpful, if your tools support it),
the signals it assigns (its outputs) must be assigned each time the process resumes (default assignments at the very beginning can be handy for beginners),
the variables must always be assigned before they are used (default assignments at the very beginning can be handy for beginners).

Be careful, these 3 golden rules are not that easy to check, especially in complicated nested if and case statements. This is why I always suggest to beginners to use the trick of default assignments at the very beginning. Rules #2 and #3 become trivial. For rule #1, if your tools support the all keyword of the VHDL 2008 standard, use it for all combinatorial processes (not for synchronous processes):
state_machine: process(all)
",,,,,
"Why does this Verilog module show ""invalid module item"" on the 9th line?","I was learning about loops in Verilog and wanted to create a simple clock with time period of 20ns. I am getting the error below whenever I am trying to run the code in EDA Playground.
module Pulse(clock);
  output reg clock;
  
  initial
    begin
      clock = 1'b0;
    end
  
  forever #10 clock = ~clock;      //Error is here
endmodule

design.sv:9: syntax error
design.sv:9: error: invalid module item.","forever cannot be used outside of a procedural block. It will work if you put it the initial block:
initial
   begin
      clock = 1'b0;
      forever #10 clock = ~clock;  
   end
",,,,,
HLS: How to separate AXI4 signals,"I am trying to write a module that uses the AXI4 streaming protocol to communicate with the previous and next modules. The modules use the following communication signals:

TDATA, which is 16 bits,
TKEEP, which is 2 bits,
TUSER, which is 1 bit,
TVALID, which is 1 bit,
TREADY, which is 1 bit and goes towards the previous module, and
TLAST, which is 1 bit.

These all need to be separate signals. I tried to implement it using the following code:
#include &quot;core.h&quot;

void core_module(hls::stream&lt;ap_axis_str&gt; &amp;input_stream, hls::stream&lt;ap_axis_str&gt; &amp;output_stream){
#pragma HLS INTERFACE axis port=input_stream
#pragma HLS INTERFACE axis port=output_stream
#pragma HLS INTERFACE s_axilite port=return bundle=CTRL
    ap_axis_str strm_val_in;
    ap_axis_str strm_val_out;
    for (int i = 0; i&lt;NDATA; i++){
        strm_val_in = input_stream.read();
        strm_val_out.data = strm_val_in.data * 2;
        strm_val_out.keep = 3;
        strm_val_out.valid = 1;
        strm_val_in.ready = 1;
        strm_val_out.user = ((i%2)==0);
        strm_val_out.last = (i == NDATA-1) ? 1:0;
        output_stream.write(strm_val_out);
    }
}

where the header file is
#ifndef core_h
#define core_h

#include &lt;ap_int.h&gt;
#include &lt;ap_axi_sdata.h&gt;
#include &lt;hls_stream.h&gt;

typedef ap_uint&lt;16&gt; word;

#define NDATA 10

struct ap_axis_str {
    word    data;
    ap_uint&lt;2&gt;    keep;
    bool    user;
    bool    last;
    bool    ready;
    bool    valid;
};

void core_module(hls::stream&lt;ap_axis_str&gt; &amp;input_stream, hls::stream&lt;ap_axis_str&gt; &amp;output_stream);

#endif

The problem is that this doesn't separate the signals. When I synthesise it and run it in the co-simulation (giving it values from 0 to 9), even if the result is what I expect it to be, the waveform produced looks like this:

We can see that TREADY, TVALID, and TDATA are there, but not the other 3. Furthermore, looking at the contents of TDATA (which for some reason are 64 bits) we notice that they contain all the signals. They are the following:
0001000001030000,
0001000000030002,
0001000001030004,
0001000000030006,
...
000100000003000c, (they are in base 16)
0001000001030010,
0001000100030012.

From which we can see that the 3 in position 12 is probably what was intended to be TKEEP, the 1 in position 8 which only appears in the last case is probably what was intended to be TUSER, the last 4 digits are what was supposed to be TDATA, etc. Additionally, the program drops TREADY when it isn't ready to receive data, which is what is intended of TREADY, but I didn't program it to work this way, which means that it's automatically generated and probably has nothing to do with the TREADY I told it to have.
So my question is: How do I make a module that gives out the correct 6 separate signals for the version of the AXI4 protocol that we are using?","Well, according to the Xilinx Documentation,

If you specify an hls::stream object with a data type other than ap_axis or ap_axiu, the tool will infer an AXI4-Stream interface without the TLAST signal, or any of the side-channel signals. This implementation of the AXI4-Stream interface consumes fewer device resources, but offers no visibility into when the stream is ending.

Now I had already imported the needed module with#include &lt;ap_axi_sdata.h&gt;, all I needed to do was actually use it by removing
struct ap_axis_str {
    word    data;
    ap_uint&lt;2&gt;    keep;
    bool    user;
    bool    last;
    bool    ready;
    bool    valid;
};

and replacing it with
typedef ap_axiu&lt;16, 1, 0, 0&gt; ap_axis_str;

Additionally, I needed to remove my manual attempt to control TREADY and TVALID, as those are done automatically.",,,,,
How to boot ddr memory of an FPGA?,"I have nexys 4 ddr board which has 128MiB on board memory and I access it via IP inside Vivado named Memory Interface Generator. But for example unlike BRAM IP which has a .coe file that initialize BRAMs of the board, here for ddr memory of the board I cannot find a way to initialize it with some data. I have a Ibex processor that utilize this memory as its main memory but now I don't know how to put compiled codes that I have written inside this ddr2 memory. Can anyone help? Is there a way to boot these memories with some initial data easily like BRAMs?","For using an external memory like DDR2 as your processor main memory, you have to use a boot loader. Boot loader programs are small and can be run on the BRAM inside the FPGA. When the board is powered up, it reads the main program from external non-volatile memory (like SPI Flash) and loads it on the external DDR2.
I am not familiar with the processor you are using, but Xilinx has a template SREC-Bootloader in Vitis for its Microblaze processors. You can use that as start point and write your own bootloader.",,,,,
Cascading BRAM in iCE40 FPGA,"I'm really new to FPGA and Verilog. I've been working on the Tri-SPI PHY controlling Noritake Itron VFD Display. One of the feature I want to implement is the framebuffer memory on the FPGA itself. I'm using the iCE40LP1K which has 64kbit BRAM (8Kbytes). But the Verilog BRAM Primitive is 4kbit and I required 3003 bytes for buffer.
The question is how can I cascade the BRAM ? in the datasheet (refer to iCE40 LP/HX Family Data Sheet, page 2-6) mentioned about using multiple BRAM. Is there a way that I can use multiple instance of SB_RAM40_4K? and the later treat as a one large mem array.","I be able to successfully use the BRAM as I wanted. It turns out that I just declare the register as 8bit array. And just make sure that there're input and output to/from that register array. Since I need 3004 bytes, this code below is how I make it work: (Note: names aren't important, Yosys is smart enough to map to SB_RAM40_4k. Also you change the array size and address bit width).
module BRAM(
input R_CLK,
input W_CLK,

input [7:0]BRAM_IN,
output reg [7:0]BRAM_OUT,

input [11:0] BRAM_ADDR_R,
input [11:0] BRAM_ADDR_W,

input B_CE_W,
input B_CE_R);

reg [7:0] mem [3003:0];

always@(posedge R_CLK) begin// reading from RAM sync with system clock 
if(!B_CE_R)
    BRAM_OUT &lt;= mem[BRAM_ADDR_R];   
end 

always@(posedge W_CLK) begin// writing to RAM sync with Slave SPI clock.
if(!B_CE_W)
    mem[BRAM_ADDR_W] &lt;= BRAM_IN;
end

endmodule
",,,,,
Why output is in unknown state?,"I want to make a serial comparator using a dff with async reset base on  with continuous assignment. but output will come in unknown (x) state I don't know why. I checked every wire and assigned each of them an expression
dff code (verilog):
module comparator (input a, input b, input reset, input clk, output [1:0] o);

wire q0_p, q0_n, q1_p, q1_n, d0, d1;
wire s0, r0, w01, w02, s1, r1, w11, w12;

assign d0 = (q1_n &amp; q0_p) | (q0_p &amp; ~a &amp; b) | (q1_n &amp; ~a &amp; b);
assign d1 = (q1_p &amp; q0_n) | (q0_n &amp; a &amp; ~b) | (q1_p &amp; a &amp; ~b); 

assign w01 = ~(w02 &amp; s0);
assign s0 = ~(w01 &amp; reset &amp; clk);
assign r0 = ~(s0 &amp; clk &amp; w02);
assign w02 = ~(r0 &amp; d0 &amp; reset);
assign q0_p = ~(s0 &amp; q0_n);
assign q0_n = ~(q0_p &amp; r0 &amp; reset);

assign w11 = ~(w12 &amp; s1);
assign s1 = ~(w11 &amp; reset &amp; clk);
assign r1 = ~(s1 &amp; clk &amp; w12);
assign w12 = ~(r1 &amp; d1 &amp; reset);
assign q1_p = ~(s1 &amp; q1_n);
assign q1_n = ~(q1_p &amp; r1 &amp; reset);

assign o[0] = q0_p;
assign o[1] = q1_p;

endmodule

testbench:
module test();

reg a, b, reset, clk = 0;
wire [1:0] o;

comparator cmp(a, b, reset, clk, o);

always #1 clk &lt;= ~clk;

initial begin
  $monitor(&quot;%b    %b    %b&quot;, a, b, o);

  reset = 0;
  reset = 1;

  // a = 1110, b = 1011
  #1 a = 1; b = 1;
  #1 a = 1; b = 0;
  #1 a = 1; b = 1;
  #1 a = 0; b = 1;

  $finish();
end

endmodule

output:
1    1    xx
1    0    xx
1    1    xx
0    1    xx
","if 'D' is in 'x' state, as soon as you deassert reset, the outputs will become 'x' again. You need to set a known value to 'D' before deassert. Also, you need a delay between assert and deassert of reset.
For example,
initial begin
  $monitor(&quot;%b    %b    %b&quot;, a, b, o);

  reset = 0;
  #1
  a = 0; b = 0;
  reset = 1;

  ...
",,,,,
Which HDL (hardware description language) Tesla is using to program the chips for their cars?,"I am learning VHDL at a university in Vivado and heard that in America there are using Verilog. So I wonder, which Hardware description language is using Tesla for programming it's chips?",You can try to find what kind of workers they are looking for in Tesla. Five minute search in google tells that they hire both VHDL and Verilog engineers.,,,,,
Is there a verilog function to iterate over multiple input files for validation?,"I can open a file with
integer fd;
fd = $fopen (&quot;file_to_open.txt&quot;, &quot;r&quot;);

But if i have multiple files in a directory such as
f1.txt
f2.txt
f3.txt

How can I iterate over these files without explicitly defining their name in my verilog testbench?
In bash, this would be done with:
for f in ./*.txt; do
    ...
done
","Verilog does not have a way of directly interacting with the Operating System a simulation is running on, so it cannot expand file names.
Two alternatives you have in Verilog are:

writing some C code that does this and linking that code through the VPI (difficult)
Creating a bash script that builds your list of files into a text file, then reading that list one line at a time with $fgets or $fscanf. (cumbersome)

This would be much easier if you were using SystemVerilog because it has string data types, and a direct interface to C (DPI)",,,,,
"Verilator, running simulator gives: Invalid argument","I'm following this tutorial. On page 24 I don't get the Makefile the tutorial talks about. When I run ./thruwire it says: bash: ./thruwire: Invalid argument.
This is my thruwire.v:
module thruwire(i_sw, o_led);
    input   wire    i_sw;
    output  wire    o_led;
    
    assign o_led = i_sw;
endmodule

After having generated this verilog file I ran these commands to create the obj_dir directory:
verilator -Wall -cc thruwire.v
cd obj_dir
make -f Vthruwire.mk

I then created a file thruwire.cpp in my main directory (so the one above obj_dir) that looks like this:
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;Vthruwire.h&quot;
#include &quot;verilated.h&quot;

int main(int argc, char **argv)
{
    Verilated::commandArgs(argc, argv);
    
    Vthruwire *tb = new Vthruwire;
    
    for(int k = 0; k &lt; 20; k++)
    {
        tb-&gt;i_sw = k&amp;1;
        
        tb-&gt;eval();
        
        printf(&quot;k = %2d, &quot;, k);
        printf(&quot;i_sw = %2d, &quot;, tb-&gt;i_sw);
        printf(&quot;led = %2d, &quot;, tb-&gt;o_led);
    }
}

I went back one directory and compiled everything like this:
cd ..
g++ -I /usr/share/verilator/include -I obj_dir /usr/share/verilator/include/verilated.cpp thruwire.cpp obj_dir/Vthruwire__ALL.a -o thruwire

By now, I've done everything that the tutorial says up till slide 24. However, there is no Makefile in my project directory, as should be the case according to the tutorial. When I run ./thruwire I get said error.
I'm new to all this, please help me out. Am I missing something?
I tried using the --exe flag, since the documentation says a simulation executable will be generated for me. But it gives me the same error upon running. I tried specifying arguments myself and removing the arguments from the main function alltogether but it keeps giving me that error.
I'm running the simulation in a virtual box image. I recently shrunk the .vdi using this guide. I don't know if that could have anything to do with it.",My toolbox was broken. A working toolbox does not give these errors as has been discussed in the comments (unfortunately the user deleted them). I guess trying to build the whole toolsuite yourself is not a good idea unless you really know what you are doing. I found a cad suite that can be readily used without problems. It has all the needed tools precompiled and working.,,,,,
Signed and Unsigned Multiplication Problem in Verilog,"I have been working on approximate multiplication recently and I want to write a Verilog code for dynamic segment multiplication (DSM) . It suggest that you find the first index in you number which has a value of 1 and then take other 3 indexes next to it to form a 4 bit number that represent an 8 bit number then you should multiply these 4 bit numbers instead of 8 bits then some shifts to have the final result it helps a lot on hardware actually.. but my problem is about multiplication of these segments because sometimes they should be considered signed and some time unsigned I have the last 3 lines of my code: (a and b are input 8 bit numbers) and m1 and m2 are segments I wrote m,m2 as reg signed [3:0] and a and b as input signed [7:0]
Here is my code:
    assign out = ({a[7],b[7]}==2'b11)||({a[7],b[7]}==2'b00) ? ($unsigned(m1)*$unsigned(m2)) &lt;&lt; (shift_m1+shift_m2) : 16'dz;
assign out = ({a[7],b[7]}==2'b01) ? ($signed({1'b0,m1})*$signed(m2)) &lt;&lt; (shift_m1+shift_m2) : 16'dz;
assign out = ({a[7],b[7]}==2'b10) ? ($signed(m1)*$signed({1'b0,m2})) &lt;&lt; (shift_m1+shift_m2) : 16'dz;

But in simulation Verilog always considers segments as unsigned and does unsigned multiplication even though I noted signed or unsigned mark...
Can anyone help? I read all of the questions about this problem in stackoverflow and other places but still cannot solve this issue...","The rules for non-self determined operands say that if one operand is unsigned, the result is unsigned. 16'dz is unsigned.
The conditional operator i ? j : k has the condition operand i self-determined, but the two selections j and k are in a context based on the assignment or expression it is a part of. The shift operator i &lt;&lt; j has the shift amount operand j self-determined.
All of the context rules are explained in section 11.6.1 Rules for expression bit lengths in the IEEE 1800-2017 SystemVerilog LRM.
You can get your desired result by using the signed literal 16'sdz.
However the logic you wrote may not be synthesizable for certain technologies that do not allow using a z state inside your device. The correct and more readable way is using a case statement:
alway @(*) case({a[7],b[7]})
  2'b00, 
  2'b11: out = $unsigned(m1)*$unsigned(m2) &lt;&lt; shift_m1+shift_m2;
  2'b01: out = $signed({1'b0,m1})*m2       &lt;&lt; shift_m1+shift_m2;
  2'b10: out = m1*$signed({1'b0,m2})       &lt;&lt; shift_m1+shift_m2;
endcase
",,,,,
clock switching in systemverilog test-bench,"In order to verify my block's DVFS feature, the clock to DUT should switch based on one event.
for example, if the control register updated to fast mode, my TB need increase the clock frequency, if the control register updated to slow mode, my TB need decrease the clock frequency.
How can I do this with systemverilog in TB?
In my simple TB, the clock is always at a fixed frequency.","You can control your clock frequency with a variable period in your testbench
bit clk;
real period = 10ps;
initial forever
   #(period/2.0) clk = !clk;

If your testbench is updating the control register, then it can also the period. Since you tagged this with UVM what people normally do is create an interface for driving the clock and reset, and a sequence to control the frequency and apply reset. Then put the code I wrote above in an interface, and the driver can set the period through a virtual interface.",,,,,
Verilog - How to plug values from an output register in a testbench module?,"So we were provided with a sequential module in Verilog and have been tasked to create a testbench to show the difference between non-blocking and blocking assignments.
Provided code:
module sequential_module (A, B, C, D, clk);
input clk;

output A, B, C, D;
reg A, B, C, D;

always @(posedge clk)
begin
   A = B;
   B = A;
end

always @(posedge clk)
begin
   C &lt;= D;
   D &lt;= C;
end

endmodule

I can't seem to plug any values to any of the variables (A, B, C, D) in the testbench because I get the &quot;Illegal output or inout port connection&quot; error.
The testbench I've managed to create:
module testbench_sequential;
reg clk;
wire A, B, C, D;

sequential_module test(A, B, C, D, clk);
always
   #5 clk = ~clk;
 
initial
   begin
      clk = 1'b0; 
      $display (&quot;Simulating output for Activity 3a&quot;);
      $monitor ($time,,, &quot;clk = %b A = %b B = %b C = %b D = %b &quot;, clk, A, B, C, D);      
      #25 $finish;
   end

endmodule

The only output I get from the testbench above is that the clock seems to be working, but the other variables have &quot;Don't care&quot; values on them (1'bx). I'm sort of new to using this application and any help would be appreciated.","
You defined all your signals (A-D) as outputs.
In your assignments e.g. A = B (it should be &lt;=), all regs have actually no value. You didn't initialize them. Thus, they are showed as 1'bx in your testbench.

To achieve what you want you can simply modify the declaration of your regs, e.g.:
reg A = 1'b0, B = 1'b1, C = 1'b0, D = 1'b1;

The result:

Simulating output for Activity 3a
0  clk = 0 A = 0 B = 1 C = 0 D = 1
5  clk = 1 A = 1 B = 1 C = 1 D = 0
10  clk = 0 A = 1 B = 1 C = 1 D = 0
15  clk = 1 A = 1 B = 1 C = 0 D = 1
20  clk = 0 A = 1 B = 1 C = 0 D = 1
",,,,,
Changing to automatic clock causes output to go blank,"Trying to automate the clock for Delay Flip Flop in the testbench, because I don't want always do it manually like this:
clock = 0
#5 clock = 1
#10 clock = 0

But suddenly, my code (below) doesn't work.
module d_flip_flop
(
    input [bit:0] a,
    input clock,
    output reg [bit:0] out
);
    parameter bit = 4 - 1;
    always @(posedge clock)
        begin
            out = a;
        end
endmodule

Testbench
module d_flip_flop_tb;
    reg [bit:0] a;
    reg clock;
    wire [bit:0] out;
    
    parameter bit = 4 - 1;

    d_flip_flop FLIP1
    (
        a,
        clock,
        out
    );

    initial
        begin
            clock = 0;
            forever
                begin
                    #5 clock = ~clock;
                end
            #1 assign a = 4'b0000;
            $display(&quot;INPUT  | %b&quot;, a);
            $monitor(&quot;OUTPUT | %b&quot;, out);
            #15 assign a = 4'b1111;
        end
endmodule

The output seems to be blank, so I don't know what to change while it's not outputting any error (using Icarus v10). Also when I tick-tock the clock manually, it was working alright.","The main problem is that the forever loop prevents the $display and $monitor code from executing.  You should separate the clock out into its own initial block.  I also added a $finish statement to cleanly terminate the simulation.
I had to move your parameter declarations above their usage because I got compile errors with your code on different simulators.
module d_flip_flop
#(    parameter bit = 4 - 1)
(
    input [bit:0] a,
    input clock,
    output reg [bit:0] out
);
    always @(posedge clock)
        begin
            out = a;
        end
endmodule

module d_flip_flop_tb;
    parameter bit = 4 - 1;
    reg [bit:0] a;
    reg clock;
    wire [bit:0] out;
    

    d_flip_flop FLIP1
    (
        a,
        clock,
        out
    );

    initial begin
            clock = 0;
            forever
                begin
                    #5 clock = ~clock;
                end
    end

    initial begin
            #1 a = 4'b0000;
            $display(&quot;INPUT  | %b&quot;, a);
            $monitor(&quot;OUTPUT | %b&quot;, out);
            #15 a = 4'b1111;
            #100 $finish;
    end
endmodule

Now I see the output change:
INPUT  | 0000
OUTPUT | xxxx
OUTPUT | 0000
OUTPUT | 1111


Other notes:
You should not use assign inside an initial block.
bit is a reserved keyword for SystemVerilog.  Once iverilog supports that syntax, you might get compile errors.  You could change bit to something conventional like WIDTH.",,,,,
What are PIP alternative in arachne-pnr?,"While going through the router.cc the file of arcahne-pnr, I am unable to understand, how are the programmable interconnect pins PIPs routed? Does it seem PLL is representing the PIPs in the code? Could somebody help to make me clear, what corresponds to PIP in arachne-pnr?
Thanks","They are called switches in the chip database, although I think the router expands this to its own structure.
Certainly nothing to do with PLL (phased locked loops) which are a clocking primitive.",,,,,
What is doing kill() in the examples code,"I am reading the UVM examples, shipped with UVM package, and have one question from
simple/basci_examples/pkg/test.v
Following lines exist there:
  initial begin
    set_config_int(&quot;mu.*&quot;, &quot;data&quot;, 101);
    set_config_string(&quot;mu.*&quot;, &quot;str&quot;, &quot;hi&quot;);
    set_config_int(&quot;mu.l1&quot;, &quot;data&quot;, 55);
    set_config_object(&quot;mu.*&quot;, &quot;obj&quot;, bar);
    mu.print_config_settings(&quot;&quot;, null, 1);
    uvm_default_printer = uvm_default_tree_printer;
    mu.print();
    factory.print(1);
    run_test();
    mu.print();
  end
  initial
    #5 mu.l1.kill(); // &lt;- this line meaning
endmodule

Can someone please explain what is doing #5 mu.l1.kill(); line?
Thanks
Hayk","The uvm_component::kill() method has been removed from the UVM 1.2 and later. It was leftover from the OVM (the predecessor to the UVM), and even then the documentation recommended against using kill().
Also, the examples released with the UVM are not very good for learning the UVM. They are mostly quick tests used by the UVM developers to check features. The README.txt file even says this. A much better place is https://verificationacademy.com/cookbook/uvm",,,,,
SystemVerilog - How to get the number of enumerated types at compile time,"I trying to find a way to get the number of possible enumerations in an enum type at compile time. I need this for initializing a templated class that uses enumerated types.
I am curious if there is a utility function (or system task) that gives this. It would be similar to $size() but for enumerated types. However, I can't seem to find a function for that. After doing a lot of research, it doesn't seem to be possible.
Here is an example I am trying to do:
typedef enum {RANDOM, STICKY, SWEEP} bias_t;

// can be parameterized to pick another enum type at random
class enum_picker #(type T = bias_t); //type must be an enumerated type
    local T current_type;
    local const int weights[$size(T)]; //&lt;--- How do I get the number of enumerated types?

    function T pick_type();
        ... some code ...
    endfunction
endclass

So for the variable weights, it is an array of weights in which its size is the number of enumerated types. Right now it is 32 because of the $size() call but that is wrong; in this particular code example, the array size should be 3.
Is there a way to do this? Or is this simply not allowed in SystemVerilog?","You probably don't want to set up weights as a const; you would not be able to set values into it. You can use the num() method to get the number of enumerations.
class enum_picker #(type T = bias_t); //type must be an enumerated type
  local T current_type;
  local int weights[]; 
  function new;
    weights = new[current_type.num()];
    foreach (weights[i]) weights[i] = $urandom_range(10);
  endfunction

    function T pick_type();
       
    endfunction
endclass
",,,,,
values are partially propagated to intermediate signal,"I have an entity called inbound that includes another entity called entity_A and a testbench tb for inbound.
I have an alias in tb to the output of entity_A so I can have access to it as below:
ALIAS alias_entity_A_out IS
  &lt;&lt;SIGNAL .tb.inbound_inst.entity_A_inst.entity_A_out : INBOUND_RECORD_TYPE&gt;&gt;; 

my problem is that the output intermediate signal (entity_A_out_inst) that used for instantiating entity_A in inbound is getting part of the values of entity_A_out output port, only two-bit are getting assigned and the rest are uninitialized, as below:
-- Instantiate entity_A
      entity_A_inst : ENTITY work.entity_A(rtl)
        PORT MAP(
          clk          =&gt; clk,
          reset        =&gt; reset,
          entity_A_in  =&gt; entity_A_in_inst,
          entity_A_out =&gt; entity_A_out_inst); -- here only part of the values are propogated
    

 # ** Note: rx_data in entity_A_out output port = 00000000
 # ** Note: rx_data in entity_A_out_inst intermediate signal = 00UUUUUU
 # ** Note: alias_rx_data = 00000000

 # ** Note: rx_data in entity_A_out output port = 00000001
 # ** Note: rx_data in entity_A_out_inst intermediate signal = 00UUUUUU
 # ** Note: alias_rx_data = 00000001

here is my code for inbound:
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;

PACKAGE inbound_pkg IS

  TYPE RX_PORT_RECORD IS RECORD
    rx_data : UNSIGNED(7 DOWNTO 0);
    valid   : STD_LOGIC;
  END RECORD RX_PORT_RECORD;
  
  TYPE INBOUND_RECORD_TYPE IS RECORD
    rx_port : RX_PORT_RECORD;
  END RECORD INBOUND_RECORD_TYPE;
  
END PACKAGE inbound_pkg;

-----------------------------------------------------------
-----------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;
USE work.inbound_pkg.ALL;

ENTITY entity_A IS
  PORT(clk          : IN  STD_LOGIC;  -- Main clock 
       reset        : IN  STD_LOGIC;  -- reset, active
       entity_A_in  : IN  INBOUND_RECORD_TYPE;
       entity_A_out : OUT INBOUND_RECORD_TYPE);
END ENTITY entity_A;

ARCHITECTURE rtl OF entity_A IS
BEGIN
seq_proc: PROCESS (clk, reset)
  BEGIN -- for seq_proc
    IF (reset = '1') THEN
      entity_A_out.rx_port.rx_data &lt;= (OTHERS =&gt; '0');
      entity_A_out.rx_port.valid   &lt;= '0';
    ELSIF rising_edge(clk) THEN
      entity_A_out &lt;= entity_A_in;
    END IF;
  END PROCESS seq_proc;
END ARCHITECTURE;

-----------------------------------------------------------
-----------------------------------------------------------

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;
USE work.inbound_pkg.ALL;

ENTITY inbound IS
  PORT(clk         : IN  STD_LOGIC;  -- Main clock 
       reset       : IN  STD_LOGIC;  -- reset, active
       inbound_in  : IN  INBOUND_RECORD_TYPE;
       inbound_out : OUT INBOUND_RECORD_TYPE);
END ENTITY inbound;

ARCHITECTURE rtl OF inbound IS

  -- INTERNAL SIGNALS DECLARATION --
  SIGNAL entity_A_in_inst  : INBOUND_RECORD_TYPE; 
  SIGNAL entity_A_out_inst : INBOUND_RECORD_TYPE; -- this is the signal that is not working

BEGIN  -- start of architecture --
  -- for entity_A_in
  entity_A_in_inst.rx_port &lt;= inbound_in.rx_port;
  -- for entity_A_out 
  inbound_out.rx_port &lt;= entity_A_out_inst.rx_port;

  -- Instantiate entity_A
  entity_A_inst : ENTITY work.entity_A(rtl)
    PORT MAP(
      clk          =&gt; clk,
      reset        =&gt; reset,
      entity_A_in  =&gt; entity_A_in_inst,
      entity_A_out =&gt; entity_A_out_inst
    );
END ARCHITECTURE;

here is my code for tb:
LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;
USE work.inbound_pkg.ALL;

ENTITY tb IS
END ENTITY tb;

ARCHITECTURE sim OF tb IS
  SIGNAL clk   : STD_LOGIC := '0';
  SIGNAL reset : STD_LOGIC := '1';
  SIGNAL inbound_in_inst  : INBOUND_RECORD_TYPE := (rx_port =&gt; ((others =&gt; '0'), '0')); 
  SIGNAL inbound_out_inst : INBOUND_RECORD_TYPE;

ALIAS alias_entity_A_out IS
  &lt;&lt;SIGNAL .tb.inbound_inst.entity_A_inst.entity_A_out : INBOUND_RECORD_TYPE&gt;&gt;; 
  
BEGIN  -- start of architecture --
  
  inbound_inst : ENTITY work.inbound(rtl)
  PORT MAP(
    clk         =&gt; clk,
    reset       =&gt; reset,
    inbound_in  =&gt; inbound_in_inst,
    inbound_out =&gt; inbound_out_inst); 
      
  clk   &lt;= NOT clk after 10 ns;
  reset &lt;= '0' after 30 ns;
  
  test : PROCESS 
  begin
    WAIT UNTIL reset = '0'; 
    inbound_in_inst.rx_port.valid   &lt;= '0';
    inbound_in_inst.rx_port.rx_data &lt;= x&quot;01&quot;;
    WAIT UNTIL rising_edge(clk);
    
    report &quot;rx_data in entity_A_out output port = &quot; &amp; to_string(alias_entity_A_out.rx_port.rx_data);
    report &quot;rx_data in entity_A_out_inst intermediat signal = &quot; &amp; to_string(&lt;&lt;SIGNAL .tb.inbound_inst.entity_A_out_inst : INBOUND_RECORD_TYPE&gt;&gt;.rx_port.rx_data);
    report &quot;alias_rx_data = &quot; &amp; to_string(alias_entity_A_out.rx_port.rx_data);

    inbound_in_inst.rx_port.rx_data &lt;= x&quot;02&quot;;
    WAIT UNTIL rising_edge(clk);
    
    report &quot;rx_data in entity_A_out output port = &quot; &amp; to_string(alias_entity_A_out.rx_port.rx_data);
    report &quot;rx_data in entity_A_out_inst intermediat signal = &quot; &amp; to_string(&lt;&lt;SIGNAL .tb.inbound_inst.entity_A_out_inst : INBOUND_RECORD_TYPE&gt;&gt;.rx_port.rx_data);
    report &quot;alias_rx_data = &quot; &amp; to_string(alias_entity_A_out.rx_port.rx_data);
    
    WAIT UNTIL rising_edge(clk);
    
    wait for 100 ns;
  END PROCESS test;
END ARCHITECTURE sim;

I don't understand what is the problem here but when I don't use Alias and declare a signal for entity_A_out in tb and use external name to assign to it, it works fine as below:
SIGNAL entity_A_out: INBOUND_RECORD_TYPE;
entity_A_out &lt;= &lt;&lt;SIGNAL .tb.inbound_inst.entity_A_inst.entity_A_out : INBOUND_RECORD_TYPE&gt;&gt;; 

here you can see it in EDA
https://www.edaplayground.com/x/2CMT",Your code looks valid so this must be a bug with the simulator. If you switch to Riviera-PRO in EDA Playground it works as expected.,,,,,
How to access a variable in child class from an obj in parent class object in systemverilog,"So I want to modify a variable which is not directly in parent class but is in a class which is instantiated in parent class. for eg.
class cfg;

    int a  

endclass

class parent;

    cfg cfg1

endclass
class child extends parent;

    &lt;how to change variable &quot;a&quot; here which is declared in cfg?&gt;

endclass
","Your first problem is using the terms parent and child with respect to inheritance. Those terms imply two separate objects. What you have is a base class type and an derived class type. When constructing a derived class object, you have access to everything in the base class as if it were all in the same class.
class cfg;

    int a  

endclass

class base;

    cfg cfg1

endclass
class derived extends base;

    //&lt;how to change variable &quot;a&quot; here which is declared in cfg?&gt;
    //Answer: Just use cfg1.a
endclass
",,,,,
Why do I get Syntax Error in Assignment statement l-value?,"I cannot find the syntax error in this code of a MIPS decoder. I am currently inside of the default case, and it gives me the errors

Decoder.v:104: syntax error.


Decoder.v:106: Syntax in assignment statement l-value

Here is the code:
module Decoder(
    input     [31:0] instr,      // Instruktionswort
    input            zero,       // Liefert aktuelle Operation im Datenpfad 0 als Ergebnis?
    output reg       memtoreg,   // Verwende ein geladenes Wort anstatt des ALU-Ergebis als Resultat
    output reg       memwrite,   // Schreibe in den Datenspeicher
    output reg       dobranch,   // FÃ¼hre einen relativen Sprung aus
    output reg       alusrcbimm, // Verwende den immediate-Wert als zweiten Operanden
    output reg [4:0] destreg,    // Nummer des (mÃ¶glicherweise) zu schreibenden Zielregisters
    output reg       regwrite,   // Schreibe ein Zielregister
    output reg       dojump,     // FÃ¼hre einen absoluten Sprung aus
    output reg [2:0] alucontrol  // ALU-Kontroll-Bits
);
    // Extrahiere primÃ¤ren und sekundÃ¤ren Operationcode
    wire [5:0] op = instr[31:26];
    wire [5:0] funct = instr[5:0];

    always @*
    begin
        case (op)
            6'b000000: // Rtype Instruktion
                begin
                    regwrite = 1;
                    destreg = instr[15:11];
                    alusrcbimm = 0;
                    dobranch = 0;
                    memwrite = 0;
                    memtoreg = 0;
                    dojump = 0;
                    case (funct)
                        6'b100001: alucontrol = 101; // TODO // Addition unsigned
                        6'b100011: alucontrol = 001; // TODO // Subtraktion unsigned
                        6'b100100: alucontrol = 111; // TODO // and
                        6'b100101: alucontrol = 110; // TODO // or
                        6'b101011: alucontrol = 000; // TODO // set-less-than unsigned
                        default:   alucontrol = 011; // TODO // undefiniert
                    endcase
                end
            6'b100011, // Lade Datenwort aus Speicher
            6'b101011: // Speichere Datenwort
                begin
                    regwrite = ~op[3];
                    destreg = instr[20:16];
                    alusrcbimm = 1;
                    dobranch = 0;
                    memwrite = op[3];
                    memtoreg = 1;
                    dojump = 0;
                    alucontrol = 011; // TODO // Addition effektive Adresse: Basisregister + Offset
                end
            6'b000100: // Branch Equal
                begin
                    regwrite = 0;
                    destreg = 5'bx;
                    alusrcbimm = 0;
                    dobranch = zero; // Gleichheitstest
                    memwrite = 0;
                    memtoreg = 0;
                    dojump = 0;
                    alucontrol = 001; // TODO // Subtraktion
                end
            6'b001001: // Addition immediate unsigned
                begin
                    regwrite = 1;
                    destreg = instr[20:16];
                    alusrcbimm = 1;
                    dobranch = 0;
                    memwrite = 0;
                    memtoreg = 0;
                    dojump = 0;
                    alucontrol = 101; // TODO // Addition
                end
            6'b000010: // Jump immediate
                begin
                    regwrite = 0;
                    destreg = 5'bx;
                    alusrcbimm = 0;
                    dobranch = 0;
                    memwrite = 0;
                    memtoreg = 0;
                    dojump = 1;
                    alucontrol = 011; // TODO
                end
            6'b001111: //Load upper immediate
                begin
                    regwrite = 1;
                    destres = intsr[20:16];
                    alusrcbimm = 1;
                    dobranch = 0;
                    memwrite = 1;
                    memtoreg = 0;
                    dojump = 0;
                    alucontrol = 011; // Bitshift.
                end
            6'b001101: //Bitwise or immediate
                begin
                    regwrite = 1;
                    destreg = instr[20:16];
                    alusrcbimm = 1;
                    dobranch = 0;
                    memwrite = 0;
                    memtoreg = 0;
                    dojump = 0;
                    alucontrol = 110; //Bitwise or.
            default: // Default Fall
                begin
                    regwrite = 1'bx;
                    destreg = 5'bx;
                    alusrcbimm = 1'bx;
                    dobranch = 1'bx;
                    memwrite = 1'bx;
                    memtoreg = 1'bx;
                    dojump = 1'bx;
                    alucontrol = 011; // TODO
                end
        endcase
    end
endmodule

","I get 2 compile errors.
The 1st is due to a missing end statement before the default:
        6'b001101: //Bitwise or immediate
            begin
                regwrite = 1;
                destreg = instr[20:16];
                alusrcbimm = 1;
                dobranch = 0;
                memwrite = 0;
                memtoreg = 0;
                dojump = 0;
                alucontrol = 110; //Bitwise or.
            end  //  &lt;-------- This was missing.
        default: // Default Fall

The 2nd compile error is fixed by changing:
                destres = intsr[20:16];
                //    ^     ^

to:
                destreg = instr[20:16];
",,,,,
16 -bit CLA instantiation,"DO I need anything else to make a 16bit CLA ??????
so far I instantiated 4 (4 bit CLA to make a 16 bit CLA)
but I think I am missing about the carry I just don't understand how to add it to what I have since the 8 bit CLA was just instantiating 2 (4 bit CLA) I don't understand why can't just instantiate 4 (4 bit CLA together to get 16 bit CLA). Can someone help me figure out how to complete the 16bit CLA?
//CLA16Top.sv

module CLA4Bit(ain, bin, cin, sum, cout);
timeunit 1ns/1ns;
input [3:0] ain,bin;
input cin;
    output logic [3:0] sum;
    output logic cout;

  logic [3:0] G,P,C;

// Carry propagate 
assign P = ain ^ bin;

//Carry generate
assign G = ain &amp; bin;

// Calculating each stage of the carry out 
assign    C[0] = cin;
assign #4 C[1] = (G[0] | (C[0] &amp; P[0]));
assign #6 C[2] = (G[1] | (G[0] &amp; P[1]) | (C[0] &amp; P[1] &amp; P[0]));
assign #8 C[3] = (G[2] | (G[1] &amp; P[2]) | (G[0] &amp; P[1] &amp; P[2]) | (C[0] &amp; 
                  P[2] &amp; P[1] &amp; P[0]));

 assign sum = P ^ C;

assign #13 cout= (G[3] | (G[2]&amp;P[3]) | (G[1]&amp;P[2]&amp;P[3]) | 
                  (G[0]&amp;P[1]&amp;P[2]&amp;P[3]) | (C[0]&amp;P[0]&amp;P[1]&amp;P[2]&amp;P[3])); 

endmodule                                    


/*
   module CLA16Top;
  timeunit 1ns/1ns;
  parameter nBITS = 16;
  logic [nBITS - 1 : 0] ain, bin, sum;
  logic in;
  logic cout;

  logic c4, c8, c12, c16;

  assign cout = c16;

  // instantiating the 16 bit CLA
    
  CLA4Bit uut1(
    .ain(ain[3:0]),
    .bin(bin[3:0]),
    .cin(cin),
    .sum(sum[3:0]),
    .cout(c4)
    );

    CLA4Bit uut2(
    .ain(ain[7:4]),
    .bin(bin[7:4]),
    .cin(c4),
    .sum(sum[7:4]),
    .cout(c8)
    );

    CLA4Bit uut3(
    .ain(ain[11:8]),
    .bin(bin[11:8]),
    .cin(c8),
    .sum(sum[11:8]),
    .cout(c12)
     );

     CLA4Bit uut4(
    .ain(ain[15:12]),
    .bin(bin[15:12]),
    .cin(c12),
    .sum(sum[15:12]),
    .cout(c16)
    );
    

    // SIMULATE (CLA16Top)
    //
    test #(16) TB(.*);
    
    endmodule: CLA16Top
","I get compile errors in your test module.  Change:
  output in;

to:
  output cin;

Also, the double-quoted string must be on one line:
$display(&quot;For inputs: ain = %b, bin = %b, cin = %b :: Actual outputs: cout = %1b, sum = %b :: Expected outputs: cout = %1b, sum = %b&quot;, ain, bin, cin, cout, 

test_count could be too big to fit into an int variable.  Use real and %g:
  real test_count;

    $display(&quot;***Congratulations, No errors found after %g tests***&quot;, test_count);

After those changes, the code compiles and runs for me.  It took about 2 hours before the nested loops completed, and only the final message displays:
***Congratulations, No errors found after 8.58993e+09 tests***

This indicates that the adder works properly.
If you want to see more intermediate results, add more displays in the loops.

Note: The test module code was removed from the Question after I posted this Answer.",,,,,
What logic will be created if variables in the sensitivity list are missing,"This was an interview question asked by a top 10 company of US.
Code 1:
always @(a or b or sel) begin 
  if (sel == 1)
  c = a; 
  else if (sel == 0) 
  c =b; 
end 

This will create a mux.
Code 2: Now &quot;SEL&quot; is removed from sensitivity. Will it still create mux?
For  the code below? If not, what logic will be created?
always @(a or b) begin 
  if (sel == 1)
  c = a; 
  else if (sel == 0) 
  c =b; 
end 
","Yes, this will still synthesize to a multiplexer1. A synthesis tool will interpret this RTL as if the sensitivity list were complete.
However, a large issue here arises because you will see different behaviour in your RTL simulations compared to the gate-level simulations/the actual silicon. In your RTL simulation, c will only change if a or b change. If only the select-signal sel of the multiplexer changes, your output c will not change in RTL simulations.
When intending to create combinatorial logic, it is generally advisable to use
always @(*)

or
always_comb

if you can use SystemVerilog. This has the advantage that you never run into sensitivity-list related simulation/synthesis mismatches. The latter keyword furthermore has the advantage that you explicitly tell tools that you want to create combinatorial logic (rather than unintended latches, for example).
Finally: Mills &amp; Cummings wrote a great paper on RTL Coding Styles That Yield Simulation and Synthesis Mismatches. This issue, among many others, is described here very well. I can greatly recommend to take a look at this paper!

Bonus: X-Propagation and simulation mismatches with actual silicon
As you indicated in your comment, you were wondering what would happen is sel === 1'bx. To better understand this matter, I highly recommend reading I'm  Still In Love With My X! by Stuart Sutherland. I will give a very brief summary on your particular example here.
Conditional blocks in SystemVerilog are prone to X-optimism, which is defined in the aforementioned paper as:

X-optimism  has  been  defined  [...]  as  any  time  simulation converts an X value on the input to an operation or logic gate into a 0 or 1 on the output. [...] SystemVerilog  can  be  overly  optimistic,  meaning  an  X  propagates as a 0 or 1 in simulation when actual silicon is still  ambiguous.

When looking at your code, we will see that an sel === 1'bx will not propagate to c. Rather, the simulator will hold the previous value of c and mimic a latch. This is overly X-optimistic and is a simulation mismatch with actual silicon, since the select line will not be X here: a signal is either 1 or 0. In other words, this will not be a latch in silicon!
One solution could be to make the multiplexer X-pessimistic in simulation, so that we would detect this undetermined state. To do so, we assign X to c when sel is neither 0, nor 1:
always_comb
    if (sel)
        c = a; 
    else if (!sel) 
        c = b; 
`ifndef SYNTHESIS // see footnote 2
    else
        c = 'x;
`endif

This has the problem, however, that it is overly pessimistic. When both a and b have the same value, we would unambiguously know what value c would have in actual silicon (regardless of the value of sel).
The aformentioned paper gives the conditional operator (? :) as a possible solution:

condition ? expression1 : expression2;
If the condition evaluates to unknown, the operator does a bit-by-bit comparison of the values of expression1 and expression2. For each bit position, if that bit is 0 in both expressions, then a 0 is returned for that bit. If both bits are  1,  a  1  is  returned.  If  the  corresponding  bits  in  each  expression are different, or Z, or X, then an X is returned for that bit

So, by using the code below, we would have a compromise between the two aforementioned solutions:
always_comb
    c = sel ? a : b;

The downside here is that the conditional operator is not suited for more complex expressions.
The three approaches summarized:
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¥â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•?     
â”?  input   â•?                    sel(t)                      â”?â”œâ”€â”€â”€â•¥â”€â”€â”€â•¥â”€â”€â”€â•«â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”?â”‚selâ•?a â•?b â•?optimistic â”?pessimistic â”?compromise â”?silicon â”?â•žâ•â•â•â•¬â•â•â•â•¬â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•¡â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•?â”?X â•?0 â•?0 â•? sel(t-1)  â”?     X      â”?    0      â”?   0    â”?â”?X â•?0 â•?1 â•? sel(t-1)  â”?     X      â”?    X      â”?  0/1   â”?â”?X â•?1 â•?0 â•? sel(t-1)  â”?     X      â”?    X      â”?  0/1   â”?â”?X â•?1 â•?1 â•? sel(t-1)  â”?     X      â”?    1      â”?   1    â”?â””â”€â”€â”€â•¨â”€â”€â”€â•¨â”€â”€â”€â•¨â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”?
In his paper, Sutherland gives another solution with which I agree: It is best to use assertions to detect design issues which cause X, instead of letting X propagate through the design and spending a lot of time finding the root cause. For your particular code, this could look like this:
always_comb
begin
    assert (!$isknown(sel))
    else $error(&quot;sel = X!&quot;);

    if (sel)
        c = a; 
    else if (!sel) 
        c = b; 
 end


1: I assume here that sel is a 1-bit signal. Otherwise, you would end up with a latch
2: See my answer here for some more information on the SYNTHESIS macro identifier.",,,,,
How to specify sample delay in SystemVerilog covergroup,"I need to sample signals in a cover group 1 nanosecond after posedge clock. What is the syntax to do that?
My MWE is as follows:
covergroup DEBUG_CG @ (posedge tb_clock);
  debug_IR : coverpoint dutDevKit.System.debug_1.dmOuter.dmOuter.auto_int_out_0
  {
    bins debug_IR_1 = {1'b1}; 
  }
  debug_ndreset : coverpoint dutDevKit.debug_1.dmOuter.dmOuter.io_ctrl_ndreset
  {
    bins debug_ndreset_1 = {1'b1}; 
  }
endgroup :DEBUG_CG
","How about:
always @(tb_clock)
  #1 delayed_tb_clock = tb_clock;

covergroup DEBUG_CG @(posedge delayed_tb_clock);

or:
always @(posedge tb_clock) 
  #1 DEBUG_CG0.sample();

covergroup DEBUG_CG;
...
DEBUG_CG DEBUG_CG0 = new();
",,,,,
What happens if you add a default case to a full case statements?,"As stated in the title, What happens if a default statement is added to a full case statement? Will this cause any issue in simulation/synthesis? If not, what is the purpose of adding this default statement to a full case?
For example,
'''
enum logic [1:0] {Reset, A, B, C} state, nstate;

always_comb
begin
    case(state)
        Reset:
            if(expr)
                nstate = A;
            else
                nstate = Reset;
        A:
            if(expr)
                nstate = B;
            else
                nstate = A;
        B:
            if(expr)
                nstate = C;
            else
                nstate = B;
        C:
            nstate = A
        
        default:
            nstate = Reset;
'''
","A default statement will be triggered when the current value for state is not present in any other case statement. This may happen during simulation, as some (or all) bits of state may be undetermined or high impedance.
If no default statement is provided, during simulation nstate will become a latch, keeping its previous value if the current value of state is not covered in the case block. In synthesis, a full case will behave the same, regardless of having a default statement or not, although providing a default case, specially in clocked always blocks, may help the synthesizer to decide if a clock enable feature should be used.
So, if no default statement is provided, simulation and synthesis behaviour may mismatch as simulation cover more logic levels for the case variable than synthesis.",,,,,
Counting down unsigned numbers is missing the 9 and 8 every 10,"I don't know where I am going wrong, or how to fix it.  I am basically building a state counter and it starts at 33 and counts down to 0 before resetting but 29,28,19,18,9 and 8 all miss.  I am stuck on where I am going wrong.
library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;


entity sequencer is
 PORT(clk:      IN  std_logic;             
        count   : out unsigned (5 downto 0)); 
End sequencer;

ARCHITECTURE behavior OF sequencer IS
SIGNAL dSig, qSig   : unsigned (5 downto 0);

BEGIN

    PROCESS (clk, dSig)  
    BEGIN 
     
     dSig &lt;= &quot;011011&quot;;

    if rising_edge(clk) Then
        qSig &lt;= dSig;
    end if;
     
     if qSig = &quot;000000&quot; then 
       dSig &lt;= &quot;011011&quot;; 
    else
       dSig &lt;= qSig - 1 ; 
    End if;
     
     count &lt;= qSig;
     
    End Process;
END behavior; 
","The whole process can be simplified to
process (clk, reset)  
begin 
    if reset then -- use an asynchronous reset for initial value
        dSig &lt;= &quot;011011&quot;;

    elsif rising_edge(clk) Then -- keep everything else within the synchronized block
        count &lt;= dSig;
        if dSig = &quot;000000&quot; then
            dSig &lt;= &quot;011011&quot;;
        else
            dSig &lt;= dSig - 1 ; 
        end if;
    end if;
end process;

Work with one counter signal and keep everything within the synchronized block of your process, or is there a reason for the async output evaluation?",,,,,
"How to add all, except one file in iverilog command line instruction from a folder?","I understand that if I want to include all the Verilog files I can do so by adding files like this:
iverilog /Users/kp/Desktop/all_new2/*.v -s testbench.v

which takes all files in all_new2 folder and sets testbench.v as the top module. However, I wish to exclude a file c_functions.v file from this folder. How do I do it?","One way is to use the -y &lt;libdir&gt; option, which is common among other simulators as well.  This is described in the iverilog Command Flags/Arguments document.
iverilog -y /Users/kp/Desktop/all_new2 testbench.v

This will compile only those modules that are needed in the directory.  There is no need to explicitly list out all files.",,,,,
system verilog variables in extended class,"When I run below example, disp() function is displaying &quot;value from class1&quot;. I am trying to understand
why is it not displaying &quot;value from class2&quot;. Can anyone help me understand the concept here.
class class1;
    string reg_name = &quot;value from class1&quot;;

    function new(string name=&quot;class1&quot;);
    endfunction

    function void disp();
        $display(&quot;disp: reg_name=%p&quot;, reg_name);
    endfunction
endclass                                                                                                                                                                

class class2 extends class1;
    string reg_name = &quot;modified value&quot;; 
    function new(string name=&quot;class2&quot;);
        reg_name = &quot;value from class2&quot;;
    endfunction
endclass

program if_p;
    class2 c2;
    initial
    begin
        c2 = new();
        c2.disp();
    end
endprogram
","The reason you see the behavior of your example of displaying &quot;value from class1&quot; is because of two principles

When declaring variables in extended classes with the same name as a variable in a base class, you hide the base class variable from that extended class. If would have to reference super.reg_name from the extended class to access the base class variable.
With the exception of virtual methods, base classes have no knowledge of anything in extended classes. All references to reg_name from class1 will be to the variable in class1

Even though the language allows it, a general rule is never to name variables with the same name in base and extended class. I've never seen a good reason to do this.",,,,,
"Synthesis for statements of wait, infinite loop, while loop, and for loop in VHDL","I hardly use any loops in Verilog for the synthesis purpose except &quot;for&quot; loops on the initialization of memories.
In VHDL, it is advised that wait statement usage should be limited in synthesis. Then, under what conditions that the wait statement usage can be synthesized? How about other loop statements, such as infinite loop ([loop_label]LOOP ... END LOOP), while loop, and for loop?","You can use a loop to iterate over arrays or vectors.
Wait statements are not synthesizable and are only used for simulation. Usually wait a x amount of time or wait until y happens is done by implementing counters and/or a state machine.
Infinite loops cannot work as you would need an infinitely big chip to create the hardware.",,,,,
"""ERROR: multiple drivers on net"" when setting a register on both positive and negative edges","I was following a tutorial on SPI master in Verilog. I've been debugging this for about three hours now and cannot get it to work.
I've been able to break down the issue into a minimum representative issue. Here are the specifications:
We have two states, IDLE and COUNTING. Then, on the clock positive edge, we check:

If the state is IDLE, then the counter register is set to 0. If while in this state the dataReady pin is high, then the state is set to COUNTING and the counter is set to all 1s.

If the state is COUNTING, the state remains COUNTING as long as counter is not zero. Otherwise, the state is returned to IDLE.


Then, we count on the negative edge:

On the negative edge of clock if state is COUNTING, then decrement counter.

Here's the code I came up with to fit this specification:
// look in pins.pcf for all the pin names on the TinyFPGA BX board
module top (
    input CLK,    // 16MHz clock
    input PIN_14,
    output LED,   // User/boot LED next to power LED
    output USBPU  // USB pull-up resistor
);
    // drive USB pull-up resistor to '0' to disable USB
    assign USBPU = 0;

    reg [23:0] clockDivider;
    wire clock;

    always @(posedge CLK)
        clockDivider &lt;= clockDivider + 1;

    assign clock = clockDivider[23];

    wire dataReady;
    assign dataReady = PIN_14;


    parameter IDLE = 0, COUNTING = 1;
    reg state = IDLE;

    reg [3:0] counter;

    always @(posedge clock) begin
        case (state)
            IDLE: begin
                if (dataReady)
                    state &lt;= COUNTING;
            end
            COUNTING: begin
                if (counter == 0)
                    state &lt;= IDLE;
            end
        endcase
    end

    always @(negedge clock) begin
        if (state == COUNTING)
            counter &lt;= counter - 1;
    end

    always @(state) begin
        case (state)
            IDLE:
                counter &lt;= 0;
            COUNTING:
                counter &lt;= counter;
        endcase
    end

    assign LED = counter != 0;
endmodule


With this, we get the error:
ERROR: multiple drivers on net 'LED' (LED_SB_DFFNE_Q.Q and LED_SB_DFFNE_Q_1.Q)

Why? There is literally only one assign statement on the LED.","First of all it would not be easy to come up with a synthesizable model in such a case. But, you do not need any negedge logic to implement your model. Also you made several mistakes and violated many commonly accepted practices.
Now about some problems in your code.

By using non-blocking assignment in the clock line you created race condition in the simulation which will probably cause incorrect simulation results:

always @(posedge CLK)
        clockDivider &lt;= clockDivider + 1; // &lt;&lt;&lt; this is a red flag!
assign clock = clockDivider[23];
...
always @(posedge clk)


you incorrectly used nbas in your always block

always(@state)
... counter &lt;= conunter-1; // &lt;&lt;&lt; this is a red flag again!


your state machine has no reset. Statements like reg state = IDLE; will only work in simulation and in some fpgas. It is not synthesizable in general.  I suggest that you do not use it but provide a reset signal instead.

Saying that, i am not aware of any methodology which would use positive and negative edges in such a case. So, you should not. All your implementation can be done under the posedge, something like the following. However
always @(posedge clock) begin
   if (reset) begin  // i suggest that you use reset in some form.
      state &lt;= IDLE;
      counter &lt;= 0;
   end
   else begin
        case (state)
            IDLE: begin
                if (dataReady) begin
                    state &lt;= COUNTING;
                    counter &lt;= counter - 1; 
                end
            end
            COUNTING: begin
                if (counter == 0) 
                    state &lt;= IDLE;
                else 
                    counter &lt;= counter - 1;
            end

        endcase
    end
end

I hope i did it right, did not test.
Now you do not need the other two always blocks at all.",,,,,
What could cause this pointer to be corrupted?,"First of all, this code is running without any issue on my linux desktop pc (x86_64) but on my Cyclone v (arm cpu/fpga), I have a segmentation fault because the value of the pointer is changing. The relevant line is the last one, during the for loop, the value of &quot;layer-&gt;filename&quot; is changing, it is correct during the first iteration (the address given by malloc) but it changes on the second one.
Basically, this bit of code is copying character from &quot;buff&quot; to &quot;layer-&gt;filename&quot;, as you can see in the output file, the value of buff[i] is a valid character so it should not corrupt layer-&gt;filename.
If you have an idea of what could cause this issue, please let me know.
Thank you for your help.
typedef enum 
{ 
    CONV,
    BN, 
    FC, 

} layer_type;

typedef struct layer{
    layer_type layer_type;
    int shape[3];
    char *filename;
} layer;

...

layer *layer=malloc(sizeof(layer));

char buff[30];

int i;
...

layer-&gt;filename = malloc(sizeof(char)*(n+1));

if(buff[0]=='b')
    layer-&gt;layer_type=BN;
else if(buff[0]=='c')
    layer-&gt;layer_type=CONV;
else
    layer-&gt;layer_type=FC;
for(i=0; i&lt;n ; i++)
    *(layer-&gt;filename+i)=buff[i]; 

values of buff[i] and layer-&gt;name during the loop","Using this code
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef enum 
{ 
    CONV,
    BN, 
    FC, 

} layer_type;

typedef struct layer{
    layer_type layer_type;
    int shape[3];
    char *filename;
} layer;

size_t test(size_t x) {
    printf(&quot;%d\n&quot;, (int)x);
    return x;
}

int main(void) {
    layer *layer=malloc(test(sizeof(layer)));
    return 0;
}

You can see that sizeof(layer) in the line
layer *layer=malloc(sizeof(layer));

is not the size of a structure but the size of a pointer.
This is because the name of variable is the same as the type name and the compiler treated layer in sizeof as the variable (pointer) name.
To avoid this and have it allocate the size of structure, you should change the name of type or variable to avoid confusion.
Dereferincing the pointer
layer *layer=malloc(sizeof(*layer));

also can solve this problem, but I think renaming is better.",,,,,
Concatenating bit vector and hex in VHDL,"Here's a quick problem for you guys. I am getting the standard &quot;0 definitions for operator &amp;&quot; in this line:
if(unsigned(counter) &gt; to_unsigned(&quot;000&quot; &amp; x&quot;8000000&quot;)) then

I know there are far simpler workarounds including just adding a bit to &quot;counter&quot; and using x&quot;08000000&quot; but I'd like to know the right way to deal with this particular situation for concatenation in the future.","As highlighted in the comments, the reason you get the error is because to_unsigned expects an argument of type natural, whereas you are giving it a vector literal that is of unspecified type.
To me, the real solution here is general coding practice. For the sake of readability and maintainability, you should not have 'magic numbers' in your code, as you do in your example. In two year's time, someone might come along and think &quot;what the hell is the significance of 0x08000000!?&quot;. Something like the following would completely avoid the scenario in your question:
constant COUNTER_WIDTH : natural := 30;
-- Some comment explaining why the following is a concatenation of two things
constant COUNTER_THRESHOLD : unsigned(COUNTER_WIDTH-1 downto 0) := &quot;000&quot; &amp; x&quot;8000000&quot;;
signal counter : unsigned(COUNTER_WIDTH-1 downto 0);

...
if(counter &gt; COUNTER_THRESHOLD) then


Used a constant to set the width that is then used for the constant and signal declarations
Moved the magic number threshold to a constant that could have a more meaningful name again if the context was given
Gave the counter type unsigned in the first place, to avoid a conversion

Note that I would probably give counter a more meaningful name as well, for example in a UART, it might be called rx_bit_counter.

A huge number of questions on this site have more than one possible solution, so I don't think that makes them all 'opinion based' in the sense that we use that phrase in the question guidelines.",,,,,
Shifting in Verilog for multiplication,"How does this line of code below works as the multiplication of (1024-31)?
The code is intended to be synthesized for FPGA, so shifting is used instead of direct division.
But what I do not understand is that how such shifting mimics the multiplication of the value of reg_acc * (1024-31).
reg [27:0] reg_adj;
reg [27:0] reg_acc;

...
    reg_adj &lt;= ((reg_acc[11:0] &lt;&lt; (20)) - ((reg_acc[11:0] &lt;&lt; (15)) - (reg_acc[11:0] &lt;&lt; (10)))) // x (1024-31)
...

","Remember that the (n &lt;&lt; k) = n * 2**k (the double * denoting power)
Then
(n &lt;&lt; 20) - ((n &lt;&lt; 15) - (n &lt;&lt; 10)) =
(n * 2**20) - ((n*2**15) - (n*2**10)) =
(n * 2**10)*2**10 - ((n*2**5) - n)*2**10 =
2**10*(n*(2**10-(2**5-1)))

2**10 = 1024, 2**5=32, so the expression is multiplying 1024*(1024-(32-1)), but the result will be almost always wrong because when you shift bits out they will become zero, e.g. you are shifting a 12-bit number by 15 positions.
I would simply write (reg_acc &lt;&lt; 10) - ((reg_acc &lt;&lt; 5) - reg_acc),
if the additional 10 shifting is necessary you can wrap this whole expression in another shift.",,,,,
"How to get rid of illegal operand error in always_comb block when used ""=="" operator in SystemVerilog","I keep getting the error
illegal operand for operator &quot;==&quot; at the code block below
module ALU(input logic oppCode[2:0], input logic [3:0] rf1, input logic [3:0] rf2
    ,output logic [3:0] result, output logic EQ );
    
    
    
    always_comb begin 
        if(oppCode == 3'b010) begin // Problem
            result &lt;= rf1 - rf2;
        end
        
        else if(oppCode == 3'b101) begin // Problem 
            result &lt;= rf1 + rf2;
        end
        
        else if(oppCode == 3'b111) begin // Problem
            EQ &lt;= (rf1 == rf2);
        end 
    end
endmodule

What I want to do here, is comparing the oppCode with hard coded instruction types. But I keep getting the Illegal operand for &quot;==&quot; error.
&quot;==&quot; is logical comparison operator so why it is not comparing?
How can I get rid of this?","In your code, oppCode is unpacked (logic oppCode[2:0]).
You can't compare an unpacked value with a packed value (3'b010).
Either make oppCode packed logic [2:0] oppCode or add an intermediate signal to convert the unpacked oppCode to a packed version with an always_comb and a for loop or just manually.
logic [2:0] oppCode_packed;
always_comb begin
  for (int i=0; i&lt;3; i++) begin
    oppCode_packed[i] = oppCode[i];
  end
end

and then use oppCode_packed in your comparisons.
Piece of advice: when you declare an unpacked signal, use the number of bits/elements you want: logic oppCode[3]. That's more lisible and you'll be less likely to confuse them.",,,,,
Entity port declaration without direction: Why is it allowed and what did I create here?,"I just had to check something in an older module and found the following entity declaration:
entity myOldModule is
  port 
  (
    clk:   in std_logic;
    reset: in std_logic;
    data:  in std_logic;
    valid: std_logic;
    ...
  );
end myOldModule;

Note the missing in in the valid port declaration. It's also missing in the component declaration in the higher level module. It does however compile and behave as expected. So my questions are:
a) Why is this allowed by the VHDL syntax? I thought port list syntax was: port_name: mode data_type;
b) What is the equivalent structure created by this statement? Does the port just default to in? I'm guessing, non-toplevel entity ports just flatten out to regular signals but nothing ever works in VHDL if not done the correct way. So what happened here?
Using LatticeDiamond 12.3 or ModelSim 2020.3 and compiling using VHDL2002 and neither ever complained (at least not with an error).","As one source (VHDL 2000) of the standard says in chapter 4.3.2, or another source (VHDL 2008) in chapter 6.5.2:

If no mode is explicitly given in an interface declaration other than an interface file declaration, mode in is assumed.
",,,,,
"Loop operator ""For"" to fill an array in VHDL","I want to understand and improve an VHDL code I got.
In the VHDL implementation there is the following part:
m1(000) &lt;=          MetricA(000)    + BrMet(3);
m1(001) &lt;=          MetricA(001)    + BrMet(1);
m1(002) &lt;=          MetricA(002)    + BrMet(0);
m1(003) &lt;=          MetricA(003)    + BrMet(2);
m1(004) &lt;=          MetricA(004)    + BrMet(0);
m1(005) &lt;=          MetricA(005)    + BrMet(2);
m1(006) &lt;=          MetricA(006)    + BrMet(3);
m1(007) &lt;=          MetricA(007)    + BrMet(1);
m1(008) &lt;=          MetricA(008)    + BrMet(2);
m1(009) &lt;=          MetricA(009)    + BrMet(0);
m1(010) &lt;=          MetricA(010)    + BrMet(1);
m1(011) &lt;=          MetricA(011)    + BrMet(3);
m1(012) &lt;=          MetricA(012)    + BrMet(1);
m1(013) &lt;=          MetricA(013)    + BrMet(3);
m1(014) &lt;=          MetricA(014)    + BrMet(2);
m1(015) &lt;=          MetricA(015)    + BrMet(0);

where
type   BRANCH_METRIC is array (3 downto 0) of STD_LOGIC_VECTOR (7 downto 0);
signal BrMet:   RANCH_METRIC        :=  (OTHERS =&gt;(OTHERS =&gt; '0'));


type   PATH_METRIC is array (15downto 0) of STD_LOGIC_VECTOR (7 downto 0);
signal MetricA: PATH_METRIC     :=  (OTHERS =&gt;(OTHERS =&gt; '0'));


My questions:
1.  m1(001), ....   m1(015) ,  MetricA(001), ....   MetricA(015)  mean a value in a position:
m1(001) means a value on the first cell,  m1(015) is on the 15th cell.
Can BrMet(0) mean something else?
2. My task is to rewrite code above using for-loop.
I can write :
for i in 1 to 15 loop 
m1(i) &lt;=          MetricA(i)    + BrMet(?);

How can I add  BrMet  in this loop?
I was thinking to create a table as:
Tab = {3,1,0,2,0,2...}

{3,1,0,2,0,2...} expresses BrMet(3), BrMet(1), BrMet(0) and so on
and the I would write the loop as
for i in 1 to 15 loop 
m1(i) &lt;=          MetricA(i)    + Tab(i);

But unfortunately I didnt find any information how to create a table in VHDL. There is LUT table , bit It doesnt pass for it.","&quot;m1(001) means a value on the first cell, m1(015) is on the 15th cell&quot;
If by &quot;first cell&quot; you mean the cell with the smallest index then no, m1(1) is not the &quot;first&quot; cell, it is the &quot;second&quot; (and m1(15) is the &quot;sixteenth&quot;) because you declared your array type with 0 as the &quot;first&quot; index, not 1. Note that, according these array definitions your loops are probably wrong: they should start at index 0, not 1.
&quot;Can BrMet(0) mean something else?&quot;
Else than what? BrMet(0) is the cell of array BrMet with the smallest index.
&quot;How can I add BrMet in this loop?&quot;
You apparently know how to declare array types and use them. This is no different. Just declare an array type and a constant of this type:
type BrMetIdx_t is array(0 to 15) of integer;
constant BrMetIdx: BrMetIdx_t := (3, 1, 0, 2, 0, 2, 3, 1, 2, 0, 1, 3, 1, 3, 2, 0);
...
for i in 0 to 15 loop 
  m1(i) &lt;= MetricA(i) + BrMet(BrMetIdx(i));
end loop;
...

Note: it would probably be safer to restrict the type of elements of BrMetIdx_t arrays to integers in the 0 to 3 range:
type BrMetIdx_t is array(0 to 15) of integer range 0 to 3;

This way, if there is a typo with, e.g., value 4, in your constant declaration you will get a clear error message from the compiler.
Note: you don't have to declare your array types with a &quot;downto&quot; index range. This is a common practice for vectors of bits because indexing them from right to left is also common but for your m1, MetricA and BrMet arrays you could probably as well index them in a more &quot;natural&quot; way:
type   BRANCH_METRIC is array (0 to 3) of STD_LOGIC_VECTOR (7 downto 0);
type   PATH_METRIC is array (0 to 15) of STD_LOGIC_VECTOR (7 downto 0);

This would probably help the global understanding.
Note: I doubt that you will ever use multiple drive for the path and branch metrics of your (Viterbi?) decoder. It would thus be safer to use an unresolved type like std_ulogic_vector instead of std_logic_vector. This way, if by accident you create a multiple drive situation, you will get a clear error message from the compiler instead of spending hours trying to understand why you see all these X values during simulation.",,,,,
Xilinx PLanAhead crashing,"I have installed xilinx ISE 10.1, 13.2 and 14.7.My code synthesizes but PlanAhead not opening on windows 10 64-bit.I googled and find a solution of replacing rdiArgs.bat file present in bin folder.I did that but still unable to launch Xilinx PlanAhead.Kindly suggest me the possible way to overcome this.","PlanAhead will not open when you are running 64-bit Project Navigator (e.g. for I/O Pin Planning), it just displays the splash screen but never opens.
To fix it, we have to force PlanAhead to always run in 32-bit mode.
Open C:\Xilinx\14.7\ISE_DS\PlanAhead\bin and rename rdiArgs.bat to rdiArgs.bat.orig
Download the zip file from here:
https://www.eevblog.com/forum/fpga/guide-getting-xilinx-ise-to-work-with-windows-8-64-bit/?action=dlattach;attach=102040
Extract it. You should now have a file named rdiArgs.bat
Copy the new rdiArgs.bat file to C:\Xilinx\14.7\ISE_DS\PlanAhead\bin
DONE!",,,,,
FPGA LUTs for combinational logic,"I'm having trouble finding direct answers to how FPGA-level LUTs are accessed/implemented in simple modules (I'll provide an example below). Referring to the top answer on this post, https://electronics.stackexchange.com/questions/163961/creating-a-verilog-code-for-4-bit-multiplier-using-lookup-table, the type of LUT I'm trying to understand is the first one listed (FPGA-level).
For example, let's say I had the following module:
module RightRotation
{
  input logic clk
  input logic [2:0] din
  output logic [2:0] dout
};

always@(clk) begin
  dout[0] &lt;= din[2];
  dout[1] &lt;= din[0];
  dout[2] &lt;= din[1];
end
endmodule

If I were to implement this module with a FPGA-level LUT with 3 inputs and 1 output, how many lookups would it take (for instance, is a value looked up every time a value is assigned with a nonblocking statement in the always@)? How would this answer change if I had 4, or 5, or 6 inputs?","After fixing syntax errors, Vivado produces these results for utilization and implementation.
N inputs would use N flops in your design.

Vendor datasheets can help understand look up tables, CLBs, slices etc.
Example here:
https://www.xilinx.com/support/documentation/user_guides/ug474_7Series_CLB.pdf",,,,,
Declaration of an enumeration type in a package,"I prefer to declare an enumeration type in a package so that I can use it in multiple entities. Here is my simplified code:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_SIGNED.ALL;
use work.polar_package;

entity Decoder is
    port (
        clk : in std_logic;
        reset : in std_logic
    );
end entity Decoder;

architecture behavioral of Decoder is
    signal state : polar_package.state_type;
begin
    top_modul : process (clk)
    begin
        if clk = '1' and clk'event then
            if reset = '1' then
                state &lt;= p0;
            else

            end if;
        end if;
    end process top_modul;
end architecture behavioral;

And I have declared and defined &quot;state_type&quot; in package &quot;polar_package&quot; as follows:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

package polar_package is
    type state_type is (p0 , p1 , p2);
end package polar_package;

package body polar_package is

end package body polar_package;

However, I see the below compilation error:
Unknown identifier &quot;p0&quot;
is there any workaround for this?","please try:
state &lt;= polar_package.p0;",,,,,
how to fix this verilog part-select error: Illegal operand for constant expression,"So I'm having a input called tx_empty, and 255 bits data, my code is :
assign lastIndex  = (tx_eop)?  (tx_empty + 3'd4)*8 : lastIndex_xq;
wire [255:0] tmp1 = tx_data_xq[(tx_empty - 5'd16)*8-1 : 0];
wire [255:0] tmp2 = tx_data_xq[255:lastIndex];
wire [255:0] tmp3 = tx_data_xq[lastIndex +: 7'd96];

tx_empty is the input signal of this module, and &quot;lastIndex_xq&quot; is just the output of the D register of lastIndex. I want to change the index value when tx_eop is high.
tmp3 works fine, I'm getting error like &quot;Illegal operand for constant expression&quot; for tmp1 and tmp2, I know tmp2 is wrong because I cannot have a variable on the right hand side of a : in a part select. But how about tmp1? I have to use this part-select logic, is there any other way to do it?
Thanks in adv","verilog does not allow you to use variable widths in part select. Width must always be a constant. In your case it is not, because of tx_emtpty and last_index.
However, you can use bit shifts, masks and loops to handle it. Something like the following.
reg [255:0] mask1, mask2;
reg [255:0] tmp1, tmp2;
always @* begin
    // create mask of '1' of the required width
    mask1 = (256'b1 &lt;&lt; (tx_empty - 5'd16)*8) - 1;
    tmp1 = tx_data_xq &amp; mask1;
    mask2 = ~((256'b1 &lt;&lt; lastIndex) - 1);
    tmp2 = (tx_data_xq &amp; mask2) &gt;&gt; lastIndex;
end

",,,,,
What is the best way to implement a DEMUX using VHDL?,"Well, I am learning some basics about digital circuits, and suffice to say I am just a beginner. For my final project, I have to implement some components and one of them is a demultiplexer.
Actually, I think there must be better ways to implement it and I think my code is not clean. Is there a way to implement it using a for loop or a while?
Here is my code:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity Demux17 is
    Port ( I : in  STD_LOGIC;
           SEL : in  STD_LOGIC_VECTOR (4 downto 0);
           O : out  STD_LOGIC_VECTOR (16 downto 0));
end Demux17;

architecture Behavioral of Demux17 is

begin
    O(0) &lt;= (I AND NOT SEL(0) AND NOT SEL(1) AND NOT SEL(2) AND NOT SEL(3) AND NOT SEL(4));
    O(1) &lt;= (I AND SEL(0) AND NOT SEL(1) AND NOT SEL(2) AND NOT SEL(3) AND NOT SEL(4));
    O(2) &lt;= (I AND NOT SEL(0) AND SEL(1) AND NOT SEL(2) AND NOT SEL(3) AND NOT SEL(4));
    O(3) &lt;= (I AND SEL(0) AND SEL(1) AND NOT SEL(2) AND NOT SEL(3) AND NOT SEL(4));
    O(4) &lt;= (I AND NOT SEL(0) AND NOT SEL(1) AND SEL(2) AND NOT SEL(3) AND NOT SEL(4));
    O(5) &lt;= (I AND SEL(0) AND NOT SEL(1) AND SEL(2) AND NOT SEL(3) AND NOT SEL(4));
    O(6) &lt;= (I AND NOT SEL(0) AND SEL(1) AND SEL(2) AND NOT SEL(3) AND NOT SEL(4));
    O(7) &lt;= (I AND SEL(0) AND SEL(1) AND SEL(2) AND NOT SEL(3) AND NOT SEL(4));
    O(8) &lt;= (I AND NOT SEL(0) AND NOT SEL(1) AND NOT SEL(2) AND SEL(3) AND NOT SEL(4));
    O(9) &lt;= (I AND SEL(0) AND NOT SEL(1) AND NOT SEL(2) AND SEL(3) AND NOT SEL(4));
    O(10) &lt;= (I AND NOT SEL(0) AND SEL(1) AND NOT SEL(2) AND SEL(3) AND NOT SEL(4));
    O(11) &lt;= (I AND SEL(0) AND SEL(1) AND NOT SEL(2) AND SEL(3) AND NOT SEL(4));
    O(12) &lt;= (I AND NOT SEL(0) AND NOT SEL(1) AND SEL(2) AND SEL(3) AND NOT SEL(4));
    O(13) &lt;= (I AND SEL(0) AND NOT SEL(1) AND SEL(2) AND SEL(3) AND NOT SEL(4));
    O(14) &lt;= (I AND NOT SEL(0) AND SEL(1) AND SEL(2) AND SEL(3) AND NOT SEL(4));
    O(15) &lt;= (I AND SEL(0) AND SEL(1) AND SEL(2) AND SEL(3) AND SEL(4));
    O(16) &lt;= (I AND NOT SEL(0) AND NOT SEL(1) AND NOT SEL(2) AND NOT SEL(3) AND SEL(4));
end Behavioral;

I will be grateful for any help or advice.
Thanks.","Try something with a generate-statement using your SEL input as an address for the O output
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;

entity Demux17 is
    Port ( I : in  STD_LOGIC;
           SEL : in  STD_LOGIC_VECTOR (4 downto 0);
           O : out  STD_LOGIC_VECTOR (16 downto 0));
end Demux17;

architecture Behavioral of Demux17 is

begin
   gen_label: for J in 0 to 16 generate
      O(J) &lt;= I when to_integer(unsigned(SEL)) = J else '0';
   end generate gen_label;
end Behavioral;
",,,,,
Unwanted Asynchronous Reset,"I have written the following VHDL code with the assumption that it will generate a counter with a synchronous reset! however, when I looked at the elaborated design in Vivado 2020.2, the counter has an ASYNCHRONOUS reset! The process should not get evaluated without seeing the rising/falling edges of the clock! How did the tool infer an asynchronous reset?!
PS. count is defined as an unsigned signal (not std_logic_vector)
Any explanation is greatly appreciated!
process(clk)
    begin
        if rst='1' then
            count &lt;= (others =&gt; '0');
        elsif rising_edge(clk) then
            count &lt;= count + 1;
        end if;
end process;
","Synthesis tools generally ignore the sensitivity list, and create the logic from design patterns in the code. In your code, the rst branch overrides the clock branch, hence it creates an asynchronous reset. In addition, the reset is not reliant on clk.
To create a synchronous reset, the rst branch should be inside the clock branch as the reset should only occur on a clock edge.
process(clk)
begin
  if rising_edge(clk) then
    count &lt;= count + 1;

    if rst = '1' then 
      count &lt;= (others =&gt; '0');
    end if;
  end if;
end process;
",,,,,
Program counter error while implement single cycle mips processor,"I'm trying to implement single cycle mips processor using Verilog and I'm facing a problem while trying to test the code, it seems like the program counter isn't increasing after the first cycle but I can't figure out what is wrong.
This is my component code of the Program counter and Instruction Memory
Program Counter
module ProgramCounter(
input CLK,
input reset,
input [31:0]PCin,
output reg [31:0]PCout
);

always @(posedge CLK, posedge reset)
    begin
    PCout &lt;= PCin+4;
        if(reset)
            PCout &lt;= 0;
    end
endmodule

Instruction Memory
module InstructionMemory(
input CLK,
input [31:0] Address,
output reg [31:0] Instr
);

reg [31:0] RAM[16:0];
initial 
    begin
        RAM[0]  &lt;= 32'h22300004; //addi
        RAM[4]  &lt;= 32'h22310003; //add
        RAM[8]  &lt;= 32'h02119020; //and
        RAM[12]  &lt;= 32'h0250a824; //or
        RAM[16]  &lt;= 32'h0211b822; //sub
    end
always @(posedge CLK)
    begin
        Instr &lt;= RAM[Address];
    end
endmodule

And this is the MIPS code that have all the components
    module MIPS(
    input  CLK,
    input  reset,
    output wire [31:0] PCin, 
    output wire [31:0] PCout,
    output wire [31:0] instruction,
    output wire memtoreg,memwrite,branch,alusrc,regdst,regwrite,jump,
    output wire [2:0] alucontrol,
    output wire [4:0] WriteReg,
    output wire[31:0] ReadData1,
    output wire[31:0] ReadData2,
    output wire[31:0] WriteDataReg,
    output wire[31:0] SignExtend,
    output wire[31:0] ALU_B,
    output wire[31:0] ShiftOut,
    output wire[31:0] ALUOut,
    output wire Zero,
    output wire [31:0]Add_ALUOut,
    output wire AndOut,
    output wire [31:0] ReadData
    );
    
//Program Counter
ProgramCounter pc(
    //inputs
        .CLK(CLK),
        .reset(reset),
        .PCin(PCin),
    //outputs
        .PCout(PCout)
);

//Instruction Memory
InstructionMemory instrmem(
    //inputs
    .CLK(CLK),
    .Address(PCout),
    //outputs
    .Instr(instruction)
);

//Control Unit
Control Controller
( 
    //inputs
    .OPcode(instruction[31:26]),
    .func(instruction[5:0]),
    //outputs
    .memtoreg(memtoreg),
    .memwrite(memwrite),
    .branch(branch),
    .alusrc(alusrc),
    .regdst(regdst),
    .regwrite(regwrite),
    .jump(jump),
    .alucontrol(alucontrol)
);

//MUX between instr and reg
MUX1 mux1
(
    //inputs
    .instr1(instruction[20:16]),
    .instr2(instruction[15:11]),
    .regdst(regdst),
    //output
    .WriteReg(WriteReg)
);

//Register File
RegisterFile regfile
(
    //inputs
    .CLK(CLK),
    .WE3(regwrite),
    .RA1(instruction[25:21]),
    .RA2(instruction[20:16]),
    .WA3(WriteReg),
    .WD3(WriteDataReg),
    //outputs
    .RD1(ReadData1),
    .RD2(ReadData2)
);

//Sign Extend
signextend sign_extend
(
    //inputs
    .A(instruction[15:0]),
    //outputs
    .Y(SignExtend)
);

//MUX between reg and ALU
MUX2 mux2
(
    //inputs
    .alusrc(alusrc),
    .RA2(ReadData2),
    .Extend(SignExtend),
    //outputs
    .ALU2(ALU_B)
);

//Shift Left
ShiftLeft Shift_Left
(
    //inputs
    .ShiftIn(SignExtend),
    //outputs
    .ShiftOut(ShiftOut)
);

//ALU
ALU mainALU
(
    //inputs
    .A(ReadData1),
    .B(ALU_B),
    .ALUcontrol(alucontrol),
    //outputs
    .ALUOut(ALUOut),
    .Zero(Zero)
);

//Addition ALU
ALUaddition addALU
(
    //inputs
    .PCout(PCout),
    .ShiftOut(ShiftOut),
    //outputs
    .Add_ALUOut(Add_ALUOut)
);

//And Gate
AND andGate
(
    //inputs
    .Branch(branch),
    .Zero(Zero),
    //outputs
    .Out(AndOut)
);

//MUX for PC
MUX4 mux4
(
    //inputs
    .PCout(PCout),
    .ADD_ALUOut(Add_ALUOut),
    .ANDOut(AndOut),
    //outputs
    .PCin(PCin)
);

//DataMemory
DataMemory datamemory
(
    //inputs
     .CLK(CLK),
     .WE(memwrite),
     .WD(ReadData2),
     .A(ALUOut),
    //outputs
    .RD(ReadData)
);

//MUX after DataMemory
MUX3 mux3
(
    //inputs
    .RD(ReadData),
    .ALUOut(ALUOut),
    .memtoreg(memtoreg),
    //outputs
    .WriteData(WriteDataReg)
);
endmodule

And this is the test bench that I wrote
module Test();
reg CLK;                                                        
reg reset;                                                      
wire [31:0] PCin;                                           
wire [31:0] PCout;                                          
wire [31:0] instruction;                                    
wire memtoreg;
wire memwrite;
wire branch;
wire alusrc;
wire regdst;
wire regwrite;
wire jump;  
wire [2:0] alucontrol;                                      
wire [4:0] WriteReg;                                        
wire[31:0] ReadData1;                                       
wire[31:0] ReadData2;                                       
wire[31:0] WriteDataReg;                                    
wire[31:0] SignExtend;                                      
wire[31:0] ALU_B;                                           
wire[31:0] ShiftOut;                                        
wire[31:0] ALUOut;                                          
wire Zero;                                                  
wire [31:0]Add_ALUOut;                                      
wire AndOut;                                                
wire [31:0] ReadData;

MIPS mips(CLK,reset,PCin,PCout,instruction,memtoreg,memwrite,branch,alusrc,regdst,regwrite,jump,alucontrol,WriteReg,ReadData1,ReadData2,WriteDataReg,SignExtend
,ALU_B,ShiftOut,ALUOut,Zero,Add_ALUOut,AndOut,ReadData);

initial
begin
    CLK = 0;
    reset = 1;
    #5 
    reset = 0;
    #5
    forever #5 CLK = ~CLK;
end                                 
endmodule

Now when I look at the simulation, this is how at looks, the program counter only gets initialized the first cycle and then it becomes don't care
","In the following PCout &lt;= PCin+4; â€?where is PCin given a value?Â  I don't see that anywhere.
PCin looks to me like an uninitialized variable, so PCout becomes uninitialized + 4, which is still unknown.Â  I would have expected to see something like PCin &lt;= PCout somewhere.
Though alternately, I'm also not sure why there's both PCin and PCout everywhere instead of just one PC.Â  Sure you may want to differentiate between the in and the out in some modules, but in other cases I'm thinking its one and the same register.",,,,,
overwrite package struct in systemverilog design,"I try to overwrite package struct by declare another packad struct outside the module
and overwrite it as parameter
Here is RTL code.
Top Module
module test_top 
#()
();

//Module A
A#()
u0
();


//Module B
B#()
u1
(); 

endmodule

Module A
module A 
#()
();

typedef struct packed
{
 logic [31:0]    addr    ;       
 logic [3:0]     tag     ;       
} a_cmd_t;

target
#(
  .CNT    (4),
  .CMD_T  (a_cmd_t   )   
)
u0
(
 .cmd() 
); 

endmodule

Module B
module B 
#(
)
(
);

typedef struct packed
{
 logic [31:0]    addr    ;       
 logic [7:0]     tag     ;       
} b_cmd_t;

target
#(
   .CNT(5),         
   .CMD_T (b_cmd_t) 
)
u0
(
  .cmd() 
);

endmodule

Module Target
module target
import target_pkg::*;
 #(
 parameter CNT = 1,             
 parameter type CMD_T     = target_cmd_t      
)
(
 output CMD_T cmd
);

localparam WIDTH = $bits(cmd.tag);  
localparam ZERO_FILL_WIDTH = (WIDTH - CNT);

wire [ZERO_FILL_WIDTH-1:0] test;
assign test = {ZERO_FILL_WIDTH{1'b0}};

endmodule

Package
package target_pkg;

typedef struct packed
{
 logic [31:0]   addr  ;       
 logic [7:0]    tag   ; 
} target_cmd_t;

endpackage

But when I do compile (w/ VCS) , it seems the number can not overwrote as my expectation
Because I will get compile error as following:
Error-[ZMMCM] Zero multiconcat multiplier
~/target.sv, 15
&quot;{ZERO_FILL_WIDTH {1'b0}}&quot;
  Zero multiconcat multiplier cannot be used in this context. (Target as 
  above)
  A replication with a zero replication constant is considered to have a size 
  of zero and is ignored. Such a replication shall appear only within a 
  concatenation in which at least one of the operands of the concatenation has
  a positive size.
  Please use -error=noZMMCM to get around this error.
  Instance stack trace:
      target#(4, a_cmd_t, , )   
~/A.sv, 21
      A#()   
~/test_top.sv, 14
      test_top  
~/test_top.sv, 2
  

Error-[NMCM] Negative multiconcat multiplier
~/target.sv, 15
  Multiconcat multiplier cannot be negative value.
  Source info: {ZERO_FILL_WIDTH {1'b0}}
  Instance stack trace:
      target#(5, b_cmd_t, , )   
~/B.sv, 23
      B#()   
~/test_top.sv, 21
      test_top  
~/test_top.sv, 2
  Please refer LRM(1364-2005) section 5.1.14.

For the first error message &quot;zero multiconcat multiplier&quot; I think it's reasonable, because for module A (hierarchy:test_top.u0.u0)
parameter CNT is 4, WIDTH = $bits(cmd.tag) = 4
So the parameter ZERO_FILL_WIDTH= (WIDTH - CNT) = 0.
But for the other error message &quot;Negative multiconcat multiplier&quot;
which come from module B (hierarchy:test_top.u1.u0) is unreasonable for me.
because for module B (hierarchy:test_top.u1.u0)
parameter CNT is 5, WIDTH = $bits(cmd.tag) = 8
So the parameter ZERO_FILL_WIDTH= (WIDTH - CNT) = 3 is a positive value.
I try to modify Module B like this:
module B 
#(
)
(
);

typedef struct packed
{
 logic [31:0]    addr    ;       
 logic [7:0]     tag     ;       
} b_cmd_t;

target
#(
   .CNT(3),         
   .CMD_T (b_cmd_t) 
)
u0
(
  .cmd() 
);

endmodule

let parameter CNT=5, and compile again the error message
&quot;Negative multiconcat multiplier&quot; is disappear.
So it seems the value  WIDTH = $bits(cmd.tag) is 4 instead of 8.
But I expect the value should come from b_cmd_t
So I'm wondering is there anything wrong in this RTL code that I can not overwrite the packed struct successfully?","The messages you saw are correct. Look at the instance from the error message:
 target#(4, a_cmd_t, , )  

in the above CNT == 4 and width of the tag in the a_cmd_t is 4 as well: logic [3:0]     tag 
The expression localparam ZERO_FILL_WIDTH = (WIDTH - CNT); is evaluated to 0, which is illegal in the following replicator: {ZERO_FILL_WIDTH{1'b0}};.
With the second issue (negative number) the problem is different. There is apparently a bug in vcs. For whatever reason vcs does not do correct job there and does not do correct override. It looks into a correct struct but does not pick up correct field and fails to recognize it width being 8. I suggest that you report it to synopsys.
However, if you get rid of localparams and use the following, it will work:
  wire [$bits(cmd.tag) - CNT -1:0] test;
  assign test = {$bits(cmd.tag) - CNT{1'b0}};
",,,,,
how to trigger a process when a signal is affected even with the same value as the old?,"I want a process to be triggered whenever a signal is affected even with the same value as the old one.
If I use wait on 'signal'; if the signal is affected with '1' when it will be again affected with '1' it will not trigger the process because it has not changed the value to '0'. I want the process to be triggered each time the signal gets a value even if it is the same.
does anyone have any Idea how to do it ?
thank you for the help","You can use the 'transaction attribute. 'transaction is a signal of type bit that toggles whenever a signal assignment occurs. hence you can use
wait on some_sig'transaction;

to halt a process and wait for a signal assignment.
This will only be suitable for simulation, as this make no sense in any current form of hardware.",,,,,
ModelSim Simulation Stops Earlier than Expected,"I am trying to run a testbench on ModelSim. I successfully compile and analyze my circuit code with only one warning:
Warning (20028): Parallel compilation is not licensed and has been disabled

This is my testbench scenario:
initial begin
   clk = 0;
end
        
initial begin 
    forever begin
        #1; 
        clk = ~clk;
    end 
end
        
initial begin
    inc_or_res = 1;
    ld_reg8 = 1;
    #10;
        
    inc_or_res = 0;
    #90;
end

As you can see it must run for at least 100ps with the delays I defined.

This is the simulation result I get. As you can see, it stops at 11ps. So I can't test my scenarios. What is the reason? It doesn't give me such error in my other testbenches.","Ok guys I found and solved the problem.
I was trying to implement a sequential circuit and it consists of a register for sure. The problem was I implemented this register by creating structural D flip flops and that created a combinational loop. This loop then caused the (vsim-3601) iteration limit reached error.
Here is how a register should be implemented:
https://www.intel.com/content/www/us/en/programmable/quartushelp/13.0/mergedProjects/hdl/vlog/vlog_pro_registers.htm",,,,,
Vivado: Mismatch between behavioral simulation and post-synthesis functional simulation,"I have a strange problem in Vivado. The goal is to initialize spi for an adc with the Xilinx Artix-100T FPGA in VHDL. But, there is a mismatch between the behavioral simulation and post-synthesis functional simulation in Vivado 2021.1.
In the behavioral simulation, the signal reset_n is 0 for one clock cycle and then rises to 1 (as it should). But, in the post-synthesis functional simulation, it is always 0. Is there any explanation for this? I also tried synthesis attributes like KEEP, DONT_TOUCH, but with no luck.
I reduced the whole logic to a few lines of code to show the part where this happens.
The Main file:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;

entity Main is

    port(
        clock   : IN     STD_LOGIC;                      --system clock;
        res : out std_logic := '0';
        reset_done : out std_logic := '0');

    signal init_done :boolean := false;
    --    signal res : std_logic := '0';

end Main;

architecture Behavioral of Main is

begin

    test: process is
    begin
        if (reset_done = '0') then
            res &lt;= '0';
            wait until rising_edge(clock);
            res &lt;= '1';
            reset_done &lt;= '1';
        else
            wait until rising_edge(clock);
        end if;
    end process test;

end Behavioral;

The test bench file:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity Main_tb is
end Main_tb;

architecture Behavioral of Main_tb is

component Main is

port(
    clock   : IN     STD_LOGIC;                             
    res : out std_logic := '0';
    reset_done : out std_logic := '0');                            
end component;

--signals
signal clock : std_logic := '1';
signal res :std_logic := '0';
signal reset_done : std_logic := '0';

begin

    simulation: Main
        port map (clock, res, reset_done);
        
    --100 MHz clock
    clk_stimulus: process
    begin
        wait for 5 ns;
        clock &lt;= not clock;
    end process clk_stimulus;

end Behavioral;

Behavioral simulation:

Post-synthesis functional simulation:

New working code:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;

entity Main is

    port(
        clock   : IN     STD_LOGIC;     --system clock;
        res : out std_logic := '0';     --init signal
        reset_done : out std_logic := '0');     --init signal
end Main;

architecture Behavioral of Main is

begin

    test: process(clock) is 
    begin
        if (rising_edge(clock)) then -- preferred syntax
            res &lt;= '1';
            reset_done &lt;= '1';
        end if;
    end process test;

end Behavioral;
","A mismatch means that the synthesizer could not infer the correct logic form your VHDL description: the synthesis doesn't understand the entirety of VHDL. You have to program it in a specific way, as described in the HDL coding guidelines.
That's the whole reason we do post-synthesis simulation: to verify that the synthesizer understood our code.
Due to signal initialization, power-on-reset is rarely needed in good designs.
Anyhow, if you strip your code down to the core, it says:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Main is
    port(
        clock : in std_logic;
        res : out std_logic;
        reset_done : out std_logic);
end Main;

architecture Behavioral of Main is
    signal i_res : std_logic := '0'; -- initialize
    signal i_reset_done : std_logic := '0';
begin
    test: process(clk) is 
    begin
        if (rising_edge(clk)) then -- preferred syntax
            i_res &lt;= i_reset_done;
            i_reset_done &lt;= '1'; -- set once.
        end if;
    end process test;
    res &lt;= i_res;
    reset_done &lt;= i_reset_done;
end Behavioral;

I don't get why reset_done has to be asserted one clock before res, but anyhow.
You could also infer a shift-register to realize a multi-clock cycle reset.",,,,,
Verilog Parameter & using \r\n,"How do you enter a carriage-return and new-line? I can't see to find anything online that suggests this needs something unique. For example, if I do...
parameter [x:x] myString = &quot;Hello \r\n world&quot;;
What actually ends up being put into myString is something like &quot;Hello r\n world&quot;
Does SystemVerilog need a special notation to handle something like this?","Table 5-1 in the SystemVerilog 1800-2017 LRM does not list \r (carriage return) as one of the available special characters. This character is ignored by most display clients, but if you really need it you can use the hex code \x0d instead.",,,,,
Why is logic right shift behaving like arithmetic right shift in this code?,"Im building a  floating point adder module and part of it requires 2s complementing and shifting value. The main module code is
module backup (x, y, z, clk);
input [7:0] x,y;
output reg [7:0] z;
input clk;
integer i;
reg [1:0] a;
reg unsigned [7:0] temp;
reg unsigned [8:0] temp2;
always @ (posedge clk) begin
a = 2'b00;
temp = 8'b00111100; 
temp = ((~temp)+1) &gt;&gt; 2;
$display(&quot;temp = %b&quot;, temp);
end
endmodule

module backup_tb();
reg [7:0] x,y;
wire [7:0] z;
reg clk;

backup m1 (.x(x),.y(y),.z(z),.clk(clk));

always #10 clk = ~clk;
initial begin
clk = 0;
#50
$finish;
end
endmodule

The output for this code is  temp = 11110001 while intended output is temp = 00110001. Please explain what am i missing here, or how can i fix it?","The problem is not with the shift right; it's with the expression ((~temp)+1). You are adding an 8-bit operand to a 32-bit operand, and operands get extended before performing any operations. Numeric literals are implicitly 32-bits. So the bitwise ~ operation inverts 32'b00000000_00000000_00000000_00111100 and then shifts it right. To fix it, yo can write:
temp = ((~temp)+1'b1) &gt;&gt; 2;
",,,,,
false result when adding two unsigned (8-bit) and storing the result in a 9-bit unsigned,"I tried to implement a simple 8 bit adder with carry to test GHDL and gtkwave.
Unfortunately, the addition is somehow performed wrongly the VHDL code for the adder and the tb as well as the console output is attached.
Has anybody an idea why that error occurs?
if I remove the resize function and carry bit and shrink &quot;myBuffer&quot; to 8-bits the error still occurs.
Regards
adder:
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity adder is
    port(
    clk : in std_logic;
    opA, opB :in std_logic_vector(7 downto 0);
    c :out std_logic;
    result :out std_logic_vector(7 downto 0)
    );
end entity adder;

architecture rtl of adder is
    --signals
    signal myBuffer : unsigned(8 downto 0);
begin
    add : process(clk, opA, opB)
    variable c_buf : std_logic := '0';
    begin  
        --on rising edge
        if(clk'event and clk = '1') then
            myBuffer &lt;= resize(unsigned(opA) + unsigned(opB), myBuffer'length);
            --result &lt;= myBuffer(7 downto 0);
            c_buf := myBuffer(8);
            assert c_buf = '1' report &quot;carry detected&quot; severity note;
            report &quot;opA = &quot;&amp;positive'image(to_integer(unsigned(opA)));
            report &quot;opB = &quot;&amp;positive'image(to_integer(unsigned(opB)));
            report &quot;expected result = &quot;&amp;positive'image(to_integer(unsigned(opA)+unsigned(opB)));
            report &quot;myBuffer = &quot;&amp;positive'image(to_integer(myBuffer));
            c &lt;= c_buf;
        end if;
    end process;

end architecture;

adder TB:
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

--library adderLib;

entity adder_tb is
end entity;

architecture rtl of adder_tb is

    type data is array(3 downto 0) of std_logic_vector(7 downto 0);

    --components
    component adder is
        port(
        clk : in std_logic;
        opA, opB :in std_logic_vector(7 downto 0);
        c :out std_logic;
        result :out std_logic_vector(7 downto 0)
        );
    end component;

    --for all: adder use entity adderLib.adder;

signal clk : std_logic := '0';
signal c : std_logic;
signal result : std_logic_vector(7 downto 0);
signal InOpA : std_logic_vector(7 downto 0);
signal InOpB : std_logic_vector(7 downto 0);
constant opA : data :=(0=&gt;x&quot;08&quot;,1=&gt;x&quot;09&quot;,2=&gt;x&quot;0A&quot;,3=&gt;x&quot;0B&quot;);
constant opB : data :=(0=&gt;x&quot;FF&quot;,1=&gt;x&quot;01&quot;,2=&gt;x&quot;02&quot;,3=&gt;x&quot;03&quot;);


begin

    --apply test signals &amp; gen clock
   process
    variable iteration :integer := 0;
    begin
        for i in opA'range loop
            InOpA &lt;= opA(i);
            InOpB &lt;= opB(i);
            clk &lt;= not clk;
            wait for 5 ns;
            clk &lt;= not clk; 
            wait for 5 ns;
            report &quot;iteration&quot;;
        end loop;
        
    end process;

    --connect component
    adierer: adder
        port map(
        clk =&gt; clk,
        opA =&gt; InOpA,
        opB =&gt; InOpB,
        c =&gt; c,
        result =&gt; result
        );

end rtl ;

TB output:
adder.vhd:26:13:@0ms:(assertion note): carry detected
adder.vhd:27:13:@0ms:(report note): opA = 11
adder.vhd:28:13:@0ms:(report note): opB = 3
adder.vhd:29:13:@0ms:(report note): expected result = 14
../../../src/ieee/numeric_std-body.v93:2098:7:@0ms:(assertion warning): NUMERIC_STD.TO_INTEGER: metavalue detected, returning 0
adder.vhd:30:13:@0ms:(report note): myBuffer = 0
adder_tb.vhd:48:13:@10ns:(report note): iteration
adder.vhd:26:13:@10ns:(assertion note): carry detected
adder.vhd:27:13:@10ns:(report note): opA = 10
adder.vhd:28:13:@10ns:(report note): opB = 2
adder.vhd:29:13:@10ns:(report note): expected result = 12
adder.vhd:30:13:@10ns:(report note): myBuffer = 14
adder_tb.vhd:48:13:@20ns:(report note): iteration
adder.vhd:26:13:@20ns:(assertion note): carry detected
adder.vhd:27:13:@20ns:(report note): opA = 9
adder.vhd:28:13:@20ns:(report note): opB = 1
adder.vhd:29:13:@20ns:(report note): expected result = 10
adder.vhd:30:13:@20ns:(report note): myBuffer = 12
adder_tb.vhd:48:13:@30ns:(report note): iteration
adder.vhd:26:13:@30ns:(assertion note): carry detected
adder.vhd:27:13:@30ns:(report note): opA = 8
adder.vhd:28:13:@30ns:(report note): opB = 255
adder.vhd:29:13:@30ns:(report note): expected result = 7
adder.vhd:30:13:@30ns:(report note): myBuffer = 10
adder_tb.vhd:48:13:@40ns:(report note): iteration
adder.vhd:26:13:@40ns:(assertion note): carry detected
adder.vhd:27:13:@40ns:(report note): opA = 11
adder.vhd:28:13:@40ns:(report note): opB = 3
adder.vhd:29:13:@40ns:(report note): expected result = 14
adder.vhd:30:13:@40ns:(report note): myBuffer = 7
adder_tb.vhd:48:13:@50ns:(report note): iteration
adder.vhd:26:13:@50ns:(assertion note): carry detected
adder.vhd:27:13:@50ns:(report note): opA = 10
adder.vhd:28:13:@50ns:(report note): opB = 2
adder.vhd:29:13:@50ns:(report note): expected result = 12
adder.vhd:30:13:@50ns:(report note): myBuffer = 14
adder_tb.vhd:48:13:@60ns:(report note): iteration
adder.vhd:26:13:@60ns:(assertion note): carry detected
adder.vhd:27:13:@60ns:(report note): opA = 9
adder.vhd:28:13:@60ns:(report note): opB = 1
adder.vhd:29:13:@60ns:(report note): expected result = 10
adder.vhd:30:13:@60ns:(report note): myBuffer = 12
adder_tb.vhd:48:13:@70ns:(report note): iteration
adder.vhd:26:13:@70ns:(assertion note): carry detected
adder.vhd:27:13:@70ns:(report note): opA = 8
adder.vhd:28:13:@70ns:(report note): opB = 255
adder.vhd:29:13:@70ns:(report note): expected result = 7
adder.vhd:30:13:@70ns:(report note): myBuffer = 10
adder_tb.vhd:48:13:@80ns:(report note): iteration
adder.vhd:26:13:@80ns:(assertion note): carry detected
adder.vhd:27:13:@80ns:(report note): opA = 11
adder.vhd:28:13:@80ns:(report note): opB = 3
adder.vhd:29:13:@80ns:(report note): expected result = 14
adder.vhd:30:13:@80ns:(report note): myBuffer = 7
adder_tb.vhd:48:13:@90ns:(report note): iteration
adder.vhd:26:13:@90ns:(assertion note): carry detected
adder.vhd:27:13:@90ns:(report note): opA = 10
adder.vhd:28:13:@90ns:(report note): opB = 2
adder.vhd:29:13:@90ns:(report note): expected result = 12
adder.vhd:30:13:@90ns:(report note): myBuffer = 14
adder_tb.vhd:48:13:@100ns:(report note): iteration
adder.vhd:26:13:@100ns:(assertion note): carry detected
adder.vhd:27:13:@100ns:(report note): opA = 9
adder.vhd:28:13:@100ns:(report note): opB = 1
adder.vhd:29:13:@100ns:(report note): expected result = 10
adder.vhd:30:13:@100ns:(report note): myBuffer = 12
./adder_tb:info: simulation stopped by --stop-time
","There are a few issues heres

You are seeing the reported mybuffer to be one calculation behind because of the way signals are assigned. When you assign a signal eg:a &lt;= b; You are only sheduling the assignment to occur at the end of the current delta cycle. Until then, all reads will return the current value of the signal, and not the new one. Variables, however, are updated immediately. If you want to check the expected result in the same delta cycle, you should use a variable instead. (also ideally, you would report the actual and expected values in the testbench, not the DUT).

You are getting no carry because an 8bit + 8bit unsigned returns an 8 bit result. In your code you have done


myBuffer &lt;= resize(unsigned(opA) + unsigned(opB), myBuffer'length);

This is an 8 bit result extended to 9 bits, hence the MSB will always be 0. To implement the carry, you need to extend at least one operand to the length of the result. Addition in VHDL will always extend all operands to the length of the longest. the simpliest way is to append a '0' to the front of one operands because this is unsigned:
myBuffer &lt;= unsigned('0' &amp; opA) + unsigned(opB);

You are using positive'image. If the result or any of the value are 0 then the simulation will throw an error. Use integer or natural instead.
",,,,,
why are icarus verilog specify times not respected?,"My understanding of &quot;specify&quot; is that it controls the propagation delay from input to output.
So ..
I expect the code below to show 'o' changing at 118 - ie 10 time units after 108 when 'b' changed
but instead the 'b' change is incorporated at 115 which is 10 units after a changed.
&gt;A T=   0  a  0  b  0  o  x
&gt;B T=   0  a  0  b  0  o  x
 O T=  10  a  0  b  0  o  0
&gt;A T= 105  a  1  b  0  o  0
&gt;B T= 108  a  1  b  1  o  0
 O T= 115  a  1  b  1  o  2

I expected this ....
&gt;A T=   0  a  0  b  0  o  x
&gt;B T=   0  a  0  b  0  o  x
 O T=  10  a  0  b  0  o  0
&gt;A T= 105  a  1  b  0  o  0
&gt;B T= 108  a  1  b  1  o  0
 O T= 115  a  1  b  1  o  1
 O T= 118  a  1  b  1  o  2

Have I misunderstood 'specify'?
See https://www.edaplayground.com/x/eBUY
module check(a,b,o);
  output wire [1:0] o;
  input [1:0]  a,b;

specify
    ( a =&gt; o ) = 10;
    ( b =&gt; o ) = 10;
endspecify

  assign o = a + b;

  always @ (a)
    $display (&quot;&gt;A T=%4t  a %2d  b %2d  o %2d &quot;, $time, a, b, o);
  always @ (b)
    $display (&quot;&gt;B T=%4t  a %2d  b %2d  o %2d &quot;, $time, a, b, o);
  always @ (o)
    $display (&quot; O T=%4t  a %2d  b %2d  o %2d &quot;, $time, a, b, o);

endmodule

module test;

  wire [1:0] o;
  logic [1:0] a,b;

  check t1(.a,.b,.o);


  initial begin
    a = 0;
    b = 0;
  end
  initial begin
    #105 a = 1;
  end
  initial begin
    #108 b = 1; // I EXPECT o TO CHANGE AS 108+10 BUT IT CHANGES AT 115
  end

endmodule

=========
Updated ...
Two alternatives that seem to work the way I expected
See below and https://www.edaplayground.com/x/P7kB
module check(a,b,o);
  output reg [1:0] o;
  input [1:0]  a,b;

  // OPTION 1 - put the delays on the individual wires
  wire #10 a_delayed = a;
  wire #10 b_delayed = b;
  assign o = a_delayed + b_delayed;

  
  // OPTION 2
  // Use non-blocking with RHS delay as per https://www-inst.eecs.berkeley.edu/~cs152/fa06/handouts/CummingsHDLCON1999_BehavioralDelays_Rev1_1.pdf
  //  always @* 
  //    o &lt;= #10 a + b;
  
  always @ (a)
    $display (&quot;&gt;A T=%4t  a %2d  b %2d  o %2d &quot;, $time, a, b, o);
  always @ (b)
    $display (&quot;&gt;B T=%4t  a %2d  b %2d  o %2d &quot;, $time, a, b, o);
  always @ (o)
    $display (&quot; O T=%4t  a %2d  b %2d  o %2d &quot;, $time, a, b, o);

endmodule

Both option 1 nd 2 produce the same output ...
&gt;A T=   0  a  0  b  0  o  x 
&gt;B T=   0  a  0  b  0  o  x 
 O T=  10  a  0  b  0  o  0 
&gt;A T= 105  a  1  b  0  o  0 
&gt;B T= 108  a  1  b  1  o  0 
 O T= 115  a  1  b  1  o  1 
 O T= 118  a  1  b  1  o  2 

Is there a better way to get the individual input to output propagation delays to work?
BTW This quesiton is actually part of a more complictated usecase that this question was motivated by.
I am creating a timed model of a 74HCT151 and wanted the timings to be accurate as I want to generate the settling glitches that the published timing implies.
Should I create a separate question for that?","Specify path delays come in two forms; Parallel connection a=&gt;o and Full connection a*&gt;o. A parallel connection is the same as writing a[0] =&gt; o[0] and a[1] =&gt; o[1]. There is no path from a[0] =&gt; o[1], same for b[0]=&gt;o[1].
In your testcase, you are changing a[0] and b[0], but o[1] is changing, since there is no path, there is 0 delay. Also, the LRM section 30.7 says

Two consecutive scheduled transitions closer together in time than the
module path delay are deemed a pulse. By default, pulses on a module
path output are rejected.

That is why o goes directly from 0 to 2. You need use a Full connection.
BTW, I could not get Icarus Verilog on EDAPlayground to match your results or give me the correct results when changing =&gt; to *&gt;, but all the other simulators worked.

Update
Your option 1 filters input glitches. If a or b have glitches less than 10 time units, those get filtered out. Your option 2 passes all output glitches through, even 0 delay glitches. If you want realistic pulse filtering, you must use specify path delays with $PATHPULSE and apparently iverilog does not implement correctly.",,,,,
Evaluation of SystemVerilog assign statements in RTL simulation,"I'm trying to understand why the statement coverage of two SystemVerilog assign statements could differ from each other when the condition expression is the same for both of the statements.
Consider the following:

As shown, the condition expression is same for these two statements, i.e., _T_6.
However, the number of hits (i.e., statement coverage) for the statements are different (notice the numbers on the far left).
I was expecting that RTL simulator should evaluate both statements equal number of times whenever the value of _T_6 changes. How does the RTL simulator handle these statements during simulation?","The continuous assignment statement gets evaluated anytime a signal on the right-hand-side changes. So even when _T_6 does not change, changes on the inactive branch of the conditional expression still cause an evaluation.
If _T_6 was a parameter and not a signal, there are some optimizations that might reduce the conditional expression and eliminate some evaluations.",,,,,
To make output LED blink in moore machine,"What I'm designing is a moore machine that gives particular color for each state.
Here's a part of my code.
    always @(*) begin            
        case (state)
            S0 : led = 6'b111111;
            S1 : led = 6'b010100;  // have to blink //
            S2 : led = 6'b100010;
            S3 : led = 6'b110110; 
            default : led_output = 6'b000000;
        endcase
    end
    

endmodule
Before the code shown above, there are codes about assigning state corresponding to the input.
The code shown above is to determine the output value of moore machine. (Therefore the condition is *)
What I left is to assign led output value for each state.
However the condition for S1 is not only particular color but it has to 'blink' for period of 1s.
I already googled for 'blink LED' verilog code but they were little bit different from my situation.
I have no idea of coding block that is needed.
Can you give me some advice or answer for what to add to make S1 to blink?","To make it blink, you need to distinguish 2 states. So create a 1-bit signal, say sel, which toggles in S1 state, and its toggle speed as well as its duty meet your requirement in 'blink' for period of 1s. This is basically implemented with the help of a counter.
reg [3:0] cnt; // assume 4-bit long
reg sel;

// counter to determine the HIGH / LOW time of sel.
always@(posedge clk or negedge resetn)begin
    if(!resetn)begin
        cnt &lt;= 4'h0;
    end
    // since you can exit S1 state at any time using push_button,
    // make sure cnt is always ZERO when entering S1 state next time.
    // also to save power when using clock gating, because this statement
    // is only active for 1 cycle.
    else if((state == S1) &amp; ((push_button == 2'b01) | (push_button == 2'b10)))begin  // S1 exit condition
        cnt &lt;= 4'h0;
    end
    else if(state == S1)begin
        // sel HIGH lasts &lt;HIGH_MAX_VAL&gt;+1 cycles
        // sel LOW lasts &lt;LOW_MAX_VAL&gt;+1 cycles
        if(cnt == (sel ? &lt;HIGH_MAX_VAL&gt; : &lt;LOW_MAX_VAL&gt;))begin
            cnt &lt;= 4'h0;
        end
        else begin
            cnt &lt;= cnt + 4'h1;
        end
    end
end

always@(posedge clk or negedge resetn)begin
    if(!resetn)begin
        sel &lt;= 1'h0;
    end
    else if((state == S1) &amp; ((push_button == 2'b01) | (push_button == 2'b10)))begin
        sel &lt;= 1'h0;
    end
    else if(state == S1)begin
        if(cnt == (sel ? &lt;HIGH_MAX_VAL&gt; : &lt;LOW_MAX_VAL&gt;))begin
            sel &lt;= ~sel;
        end
    end
end

Use sel to select between 2 led values.
always@(*)begin            
    case(state)
        ....
        S1 : led = sel ? 6'b010100 : &lt;ANOTHER_VALUE&gt;;
        ....
    endcase
end
",,,,,
How to go through multiple input combinations with a for loop in a testbench VHDL?,"I'm new to VHDL and I'm writing a test bench for an XNOR gate. The simple solution was to manually go through each combination of the two inputs but with more inputs this will take too long. How can I write this as a for loop in VHDL?
process
begin
p0 &lt;= '1';
p1 &lt;= '0';
wait for 1 ns;
if (pout = '1') then
    error &lt;= '1';
end if;
wait for 200 ns;
p0 &lt;= '1';
p1 &lt;= '1';
wait for 1 ns;
if (pout = '0') then
    error &lt;= '1';
end if;
wait for 200 ns;
p0 &lt;= '0';
p1 &lt;= '1';
wait for 1 ns;
if (pout = '1') then
    error &lt;= '1';
end if;
wait for 200 ns;
p0 &lt;= '0';
p1 &lt;= '0';
wait for 1 ns;
if (pout = '0') then
    error &lt;= '1';
end if;
wait for 200 ns;
end process;
","If p0 and p1 are inputs to the device under test and their base type is compatible with the element type of type unsigned:
library ieee;
use ieee.std_logic_1164.all;

entity xnor2 is
    port (
        p0:     in  std_logic;
        p1:     in  std_logic;
        pout:   out std_logic
    );
end entity;

architecture foo of xnor2 is
begin
    pout &lt;= not (p0 xor p1);
end architecture;

library ieee;
use ieee.std_logic_1164.all;

entity inputs is
end entity;

architecture foo of inputs is
    signal p0, p1, pout:    std_logic;
    signal error:           std_logic := '0';
begin
DUT:
    entity work.xnor2
        port map (
            p0 =&gt; p0,
            p1 =&gt; p1,
            pout =&gt; pout
        );

    process
        use ieee.numeric_std.all;  -- for example, if not already visible
        variable elements: unsigned (1 downto 0);
    begin
        elements := (others =&gt; '0');
        for i in 0 to 2 ** elements'length  - 1 loop
            
            p0 &lt;= elements(0);
            p1 &lt;= elements(1);
            wait for 1 ns;
            report LF &amp; &quot;i = &quot; &amp; integer'image(i) &amp;
                LF &amp; HT &amp; &quot;p0 = &quot; &amp; std_ulogic'image(p0) &amp; 
                         &quot; p1 = &quot; &amp; std_ulogic'image(p1) &amp;
                         &quot; error = &quot; &amp; std_ulogic'image(error);
            if pout = '0' then
                error &lt;= '1';
            end if;
            wait for 200 ns;
            elements := elements + 1;
        end loop;
        wait;
    end process;
end architecture;

Which reports:
ghdl -r inputs
inputs.vhdl:45:13:@1ns:(report note):
i = 0
    p0 = '0' p1 = '0' error = '0'
inputs.vhdl:45:13:@202ns:(report note):
i = 1
    p0 = '1' p1 = '0' error = '0'
inputs.vhdl:45:13:@403ns:(report note):
i = 2
    p0 = '0' p1 = '1' error = '1'
inputs.vhdl:45:13:@604ns:(report note):
i = 3
    p0 = '1' p1 = '1' error = '1'

Where we also see error has no obvious meaning.
Without providing a minimal, complete, and verifiable example in the question there's some risk an answer may have one or more errors and future readers can't as easily verify the solution.
The idea here is to use a binary representing counter with as many bits (elements) as inputs and assign the value of bits (elements) to respective inputs in each loop iteration.
That binary value can also be provided directly from the integer value of the loop parameter. See How to easily group and drive signals in VHDL testbench which also uses aggregate assignment:
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity agg_assign is
end entity;

architecture foo of agg_assign is
    signal A, B, C: std_logic;
begin
    process
    begin
        wait for 10 ns;
        for i in 0 to 7 loop
            (A, B, C) &lt;= std_logic_vector(to_unsigned(i, 3));
            wait for 10 ns;
        end loop;
        wait;
    end process;
end architecture;

You can also create a record subtype to mix element and array assignments:
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity aggr_rec_assign is
end entity;

architecture foo of aggr_rec_assign is
    signal A, B, C: std_logic;
    signal D:       std_logic_vector (2 downto 0);
    
    function to_string (inp: std_logic_vector) return string is
        variable image_str: string (1 to inp'length);
        alias input_str:  std_logic_vector (1 to inp'length) is inp;
    begin
        for i in input_str'range loop
            image_str(i) := character'VALUE(std_ulogic'IMAGE(input_str(i)));
        end loop;
        return image_str;
    end function;
begin
    process
        type inputs_rec is
        record
                A:  std_logic;
                B:  std_logic;
                C:  std_logic;
                D:  std_logic_vector (2 downto 0);
            end record;
            variable elements:  unsigned (5 downto 0);
    begin
        wait for 10 ns;
        for i in 0 to 2 ** elements'length - 1 loop
            elements := to_unsigned(i, elements'length);
            (A, B, C, D) &lt;= 
                inputs_rec'(
                    elements(5),
                    elements(4),
                    elements(3),
                    std_logic_vector(elements(2 downto 0))
                );
            wait for 10 ns;
            report LF &amp; HT &amp; &quot;i =  &quot;&amp; integer'image(i) &amp; &quot; (A, B, C, D) = &quot; &amp; 
                std_ulogic'image(A) &amp; &quot; &quot; &amp;
                std_ulogic'image(B) &amp; &quot; &quot; &amp;
                std_ulogic'image(C) &amp; &quot; &quot; &amp;
                to_string(D);
        end loop;
        wait;
    end process;
end architecture;

where in both cases the aggregate assignment would be the place to select the order inputs are extracted from the binary value.",,,,,
Is it possible to use $display to print some values when proving with yosys-smtbmc?,"In verilog $display() function is usefull in simulation to see the value of constants or macro like this example :
/* Display parameters in simulation */
initial
begin
    $display(&quot;CLK_PER_NS     : %d&quot;, CLK_PER_NS );
    $display(&quot;PULSE_PER_NS   : %d&quot;, PULSE_PER_NS);
    $display(&quot;MAX_COUNT      : %x&quot;, `MAX_COUNT);
    $display(&quot;MAX_COUNT_SIZE : %x&quot;, `MAX_COUNT_SIZE);
end

But when I launch  yosys-smtbmc with cover, bmc or prove, nothing is displayed in console.
Is it possible to do it ?
My sby script (example is from my github project here):
[options]
#mode cover
mode bmc
#mode prove
depth 150

[engines]
smtbmc

[script]
read -formal per2bpm.v
prep -top per2bpm

[files]
../../hdl/per2bpm.v
","No, this isn't supported at the moment. In general formal verification with Yosys gives you a similar feature set to synthesis (what it presents to the solver is essentially a circuit) with the addition of assert/assume/cover etc. Adding display would be possible using something that read the solver output, but would also be quite a substitantial piece of work to implement properly.",,,,,
Error compiling model with Vitis-AI : Data value is out of range,"I'm building a simple custom Keras model shown below:
model = Sequential()
model.add(Conv2D(16, (16, 1), activation='relu', input_shape=(300,2,1) ))   
model.add(Dropout(0.1))

model.add(Conv2D(32, (16, 1), activation='relu'))                               
model.add(Dropout(0.2))

model.add(Flatten())

model.add(Dense(32, activation='relu'))
model.add(Dropout(0.5))

model.add(Dense(3, activation='softmax'))

The Keras model needs to be compiled using Xilinx's Vitis-AI to be ran on an FPGA. We're following the steps outlined by Xilinx's Vitis AI tutorials to compile the model.
However, we're running into the following error during the compilation stage:
[VAI_C-BACKEND][Check Failed: (kernel_h - stride_h) &lt;= 3 * pixel_parallel * stride_h][/home/xbuild/conda-bld/dnnc_1592904456005/work/submodules/asicv2com/src/Operator/OperatorConv.cpp:53][DATA_OUTRANGE][Data value is out of range!]

Any ideas on what this error message could mean? Or even, how we can get more debugging information?
We've successfully trained and ran inference using this model before in a python environment.","THE INPUTS TO THE CNN MODEL NEED TO BE SQUARE FOR VITIS AI. There was nothing incorrect or unsupported about the model presented in the question above.
The compile step will fail if the input images are not square as shown below:
[VAI_C-BACKEND][Check Failed: (kernel_h - stride_h) &lt;= 3 * pixel_parallel * stride_h][/home/xbuild/conda-bld/dnnc_1592904456005/work/submodules/asicv2com/src/Operator/OperatorConv.cpp:53][DATA_OUTRANGE][Data value is out of range!]

If the input isn't square it must be padded to make a square.
padding = int(input_shape[0] - input_shape[1])
model.add(Conv2D(16, (16, 1), activation='relu', input_shape=(300,2+padding,1) )) 

I hope that this answer helps someone.",,,,,
Is it possible to create separate bin for each cross product in a cross coverage bin,"I have two coverpoints that I want to cross as shown in the code below. In the cross coverage, I want to organize the cross values into different bins based on the value of one of the coverpoints, cp_a in this case. For example cr.a1 is the cross products of all values of b when a is 1. The example below makes one unified bin for all of the crosses that satisfies this condition. Is it possible to make one separate bin for each cross product axb where a is 1? In this case it will be 10 different bins, one for each value of b while a is 1.
For a coverpoint bin you would use bins b [] = {[0:10]}, but it looks like that does not work for cross.
module top {
  int a;
  int b;
  covergroup CG;
    cp_a : coverpoint a {
      bins a1 = {1};
      bins a2 = {2};
      bins a3 = {3};
    }
    cp_b : coverpoint b {
      bins b [] = {[0:10]};
    }
 
    cr : cross cp_a, cp_b {
      bins a1 = binsof(cp_a.a1);
      bins a2 = binsof(cp_a.a2);
      bins a3 = binsof(cp_a.a3);
    }
  endgroup
endmodule
","Organizing bins of a cross is very different from a coverpoint. You generally want to ignore bins you don't want or change the way you collect the coverpoints. In this case I think you want to break up cp_a into three coverpoints and create three crosses.
module top {
  int a;
  int b;
  covergroup CG;
    cp_a1 : coverpoint a { bins a1 = {1}; }
    cp_a2 : coverpoint a { bins a1 = {2}; }
    cp_a3 : coverpoint a { bins a1 = {3}; }
    cp_b : coverpoint b {
      bins b [] = {[0:10]};
    }
 
    cr_a1 : cross cp_a1, cp_b;
    cr_a2 : cross cp_a2, cp_b;
    cr_a3 : cross cp_a3, cp_b;
  endgroup
endmodule
",,,,,
Use alias-like variable in for loops,"Is it possible to create an alias variable/signal to improve readability of for loops in VHDL processes?
For instance, consider the following module which contains a process with inner for loops (code is for example purpose, I haven't test it):
library ieee;
use ieee.std_logic_1164.all;

entity MyModule is
  port (
    clk                 : in  std_logic;
    inData              : in  std_logic_vector(7 downto 0);
    outData             : out std_logic_vector(7 downto 0));
end MyModule;

architecture functional of MyModule is
  type sample_vector  is array (natural range &lt;&gt;) of std_logic_vector(9 downto 0);
  type data_t is record
    samples     : sample_vector(3 downto 0);
    -- other elements...
  end record data_t;
  type data_vector  is array (natural range &lt;&gt;) of data_t;
  signal data  : data_vector(1 downto 0);

begin  -- functional
  process (clk)
  begin  -- process
    if clk'event and clk = '1' then
      -- Set outData(N) to '1' if at least 1 of the last 10 values of inData(N) was '1'
      for d in data'RANGE loop
        for s in data(0).samples'RANGE loop
          data(d).samples(s)(9 downto 1) &lt;= data(d).samples(s)(8 downto 0);
          data(d).samples(s)(0) &lt;= inData(d * 4 + s);
          outData(d * 4 + s) &lt;= '0';
          for b in data(d).samples(s)'RANGE loop
            if data(d).samples(s)(b) = '1' then
              outData(d * 4 + s) &lt;= '1';
            end if;
          end loop;
        end loop;
      end loop;
    end if;
  end process;

end functional;

Having to use data(d).samples(s) every time I need to reference that signal is cumbersome, so I'd rather use an alias-like variable, something like that instead (inspired from generate syntax, idx part is just a bonus):
      -- Set outData(N) to '1' if at least 1 of the last 10 values of inData(N) was '1'
      for d in data'RANGE loop
        for s in data(0).samples'RANGE loop
          alias sample  : std_logic_vector(9 downto 0) is data(d).samples(s);
          constant idx  : integer := d * 4 + s;
        begin
          sample(9 downto 1) &lt;= sample(8 downto 0);
          sample(0) &lt;= inData(idx);
          outData(idx) &lt;= '0';
          for b in sample'RANGE loop
            if sample(b) = '1' then
              outData(idx) &lt;= '1';
            end if;
          end loop;
        end loop;
      end loop;

Of course, this does not work. So, is there any way to achieve something like that in VHDL, or do we always have to specify the full signal &quot;path&quot; each time?
I could replace the loop body with a procedure, but having to declare the procedure code in a (far away) different place of the file reduces readability even more. I could also use a for ... generate construct, but this will create 1 process for each iteration and prevent me from using common process variables inside the iteration.","As indicated in question comments, this can be achieve using process variables:
  process (clk)
    variable sample : std_logic_vector(9 downto 0);
    variable idx    : integer;
  begin  -- process
    if clk'event and clk = '1' then
      -- Set outData(N) to '1' if at least 1 of the last 10 values of inData(N) was '1'
      for d in data'RANGE loop
        for s in data(0).samples'RANGE loop
          -- Helpers
          sample := data(d).samples(s);
          idx := d * 4 + s;

          outData(idx) &lt;= '0';
          for b in sample'RANGE loop
            if sample(b) = '1' then
              outData(idx) &lt;= '1';
            end if;
          end loop;
          sample(9 downto 1) &lt;= sample(8 downto 0);
          sample(0) &lt;= inData(idx);

          -- Do not forget to apply changes
          data(d).samples(s) &lt;= sample;
        end loop;
      end loop;
    end if;
  end process;

Of course, using process variables implies changing the operations order to get the same behavior.
Since process variables are read and written in the loops, I was worried the synthesis tools would believe the result of iteration N was dependent on the result of iteration N-1, and make implements the iterations in series (instead of in parallel). However, after unrolling the loop (which is what synthesis tools do), it gets clear the synthesis tools will see sample and idx values are not re-used between iterations.",,,,,
How to find dot product of two vectors in vhdl?,"I am new to VHDL. I am trying to design a generic code for vectors dot or scalar product on Xilinx FPGA. Suppose we have a vector two vectors of
V1=[1,4,5,1] and V2=[3,6,9,1].

We can find it using
V1.V2=(1x3)+(4x6)+(5x9)+(1x1)=73

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.ALL;

entity dot_product is
    Port ( vector_x : in STD_LOGIC_VECTOR (3 downto 0);
           vector_y : in STD_LOGIC_VECTOR (3 downto 0);
           r0 : out STD_LOGIC_VECTOR (3 downto 0);
           r1 : out STD_LOGIC_VECTOR (3 downto 0);
           r2 : out STD_LOGIC_VECTOR (3 downto 0);
           result : out STD_LOGIC_VECTOR (7 downto 0));
end dot_product;

architecture Behavioral of dot_product is

begin
r0 &lt;= std_logic_vector(signed(vector_x(0)* vector_y(0)));
r1 &lt;= std_logic_vector(signed(vector_x(1)* vector_y(1)));
r2 &lt;= std_logic_vector(signed(vector_x(2)* vector_y(2)));
r3 &lt;= std_logic_vector(signed(vector_x(3)* vector_y(3)));
result&lt;=r0+r1+r2+r3;

end Behavioral;

How can we find its dot product in VHDL and later I can change vector size according to my requirement. Please help. Thanks:)","These are some notes:


vector_x : in STD_LOGIC_VECTOR (3 downto 0);


this is not a vector as in math. It is a an array of bits zeros and ones. so you can use it to represent numbers from 0 (0000) to 15 (1111).
if you want to have a vector, consider declaring an array of std_logic_vector.

type t_vector is array (integer range &lt;&gt;) of std_logic_vector(3 downto 0);

consider reading this: https://www.nandland.com/vhdl/examples/example-array-type-vhdl.html
then you declare your vectors as an array with type t_vector.
after that, you can use for loop in a process to do the multiplication and addition.
consider reading this: http://habeebq.github.io/writing-a-2x2-matrix-multiplier-in-vhdl.html
to have a generic array size, consider using an unconstrained array or generic for the size.
entity dot_product is
    generic (width : positive := 8);
    port (vector_x : in t_vector (width downto 0);
          vector_y : in t_vector (width downto 0);
            result : out STD_LOGIC_VECTOR (7 downto 0));
end dot_product ;
",,,,,
UVM error when using multiple sequencers using for loop construct,"I have a sort of following code in the body of my UVM virtual seq:
begin:
  for(int x=0; x&lt;8; x++) begin
    
    fork begin
      automatic int x_idx = x;
        for(int i=0; i&lt;100; i++) begin
          if(!my_sequence[x_idx].randomize() with {...}
          my_sequence[x_idx].start(p_sequencer.my_sequencer[x_idx];
        end
    end join_none
  end
end

Code information:

I have 8 sequencers each receiving its own sequence. Hence the first &quot;for loop&quot; with 8 iterations.
After going through some tutorials I understood that using fork-join I can run the 8 sequences to the 8 sequencers in parallel.

But when I run the code I get error on the &quot;if(!my_sequence...&quot; line of code. Error being:
The object is being used before it was constructed/allocated.

I also tested the code by getting rid of the outer for loop and instead using index numbers as follows:
    fork begin
      automatic int x_idx = x;
        for(int i=0; i&lt;100; i++) begin
          if(!my_sequence[0].randomize() with {...}
          my_sequence[0].start(p_sequencer.my_sequencer[0];
        end
    end join_none

    fork begin
      automatic int x_idx = x;
        for(int i=0; i&lt;100; i++) begin
          if(!my_sequence[0].randomize() with {...}
          my_sequence[1].start(p_sequencer.my_sequencer[1];
        end
    end join_none
    ...

This seems to work. But I want to write better code with for loop.
Another info: While debugging using DVE I saw the x_idx value to be 8. Not sure why it is showing as 8 and also not sure if that's the reason for the bug.","Your problem is you placed the x_idx declaration inside the begin/end block that is inside the fork/join_none. You don't want the initialization to happen when the parallel threads start executing; you want it to happen as each iteration of the for loop executes. You should write it as
begin
  for(int x=0; x&lt;8; x++)
    fork
      int x_idx = x;
      for(int i=0; i&lt;100; i++) begin
         if(!my_sequence[x_idx].randomize() with {...}
         my_sequence[x_idx].start(p_sequencer.my_sequencer[x_idx];
      end
   join_none
end

Also, there's no need to use the automatic keyword inside a classâ€”all variables declared inside a class method have an implicit automatic lifetime.
Note that declarations inside fork/join's initialize upon hitting the fork block, not when the statements inside the fork begin their threads. The declarations are not separate threads. You could also write as:
begin
  for(int x=0; x&lt;8; x++) begin
    int x_idx = x;
    fork
      for(int i=0; i&lt;100; i++) begin
         if(!my_sequence[x_idx].randomize() with {...}
         my_sequence[x_idx].start(p_sequencer.my_sequencer[x_idx];
      end
   join_none
  end
end

In both cases, there is a new instance of x_idx for every loop iteration, but the statements inside the fork/join_none don't begin executing until after all iterations complete.",,,,,
Performing arithmetic on parameters to initialize other constants,"I have a design that takes a few essential parameters. It needs to do some arithmetic (comparisons, additions etc.) on the given essential parameters, then initialize other parameters (or constants) based on the results. For instance, look at the code below,
module foo(a,b);

parameter wl_in = 8;
parameter sc_in = 3;
parameter wl_out = 9;
parameter sc_out = 2;

parameter big_wl = //to be determined...
parameter big_sc = //to be determined...

//some logic

endmodule

I want to determine which of the two wls is greater, then assign it to big_wl. Likewise for sc. I will then use these parameters to define arrays, define array boundaries etc.
I tried using if/else statements, but I've gotten errors with that approach.
How can I do this in Verilog-2001?","You can use the conditional operator a ? b : c for this
parameter big_wl = wl_in &gt; wl_out ? wl_in : wl_out;

For more complex operations, you can use a constant function. That kind of function is restricted to having an output solely defined by its inputs, and no references to anything outside the function.
function integer max(integer v1,v2);
begin
  if (v1 &gt; v2)
     max = v1;
  else
     max = v2;
end
endfunction

parameter big_wl = max(wl_in, wl_out);

In SystemVerilog, you can use the let construct
let max(v1,v2) = v1&gt;v2 ? v1 : v2;

The benefit of this is the arguments are typeless, not fixed to an integer.",,,,,
Importing values from external file using `include,"I want to define a set of global parameter values in an external file and import them into a Verilog (not SystemVerilog) file. How can I do that? I know this can be done using pkg in VHDL, and I am expecting something similar.
I am trying this:
For the main module:
        module temp (
        `include &quot;file.vh&quot;
        input [WIDTH:0] data_in,
        output reg [WIDTH:0] data_out,
        input clk
    );
        always @(posedge clk) begin
            data_out &lt;= data_in;
        end
    endmodule


and a file.vh file:
    `define WIDTH = 12;

Please correct me here as this code is not working.","You have a few syntax errors in your code.  You are confusing define macro syntax with parameter syntax.  I'll assume you want macros.  These changes will fix the errors.
For file file.vh, use:
`define WIDTH 12

For the module, use:
`include &quot;file.vh&quot;

module temp (
        input      [`WIDTH:0] data_in,
        output reg [`WIDTH:0] data_out,
        input clk
    );
        always @(posedge clk) begin
            data_out &lt;= data_in;
        end
endmodule

define macros use simple text substitution.  You want to replace the WIDTH text with only the number 12; you do not want to use = or ;.
When you use the macro in the module, you need to prepend the backtick:
`WIDTH
",,,,,
VHDL: Case Statement choices must cover all possible values of expression,"I'm working on project which should convert data from analog to digital with approximation and I have error when i try compile code in Quartus II 9.1sp2 Web Edition which is shown in title with Case Statement in the code below:
architecture behavior of adc is
type state is (reset, state1, state2, state3, state4, state5, state6, state7, state8, state9, state10);
signal nx_state : state;

begin
    process (in_clk, rst_n, start)
begin
    if(rst_n'event and rst_n='0') then
        B_hold &lt;= &quot;1111&quot;;
        D_out &lt;= &quot;0000&quot;;
        data_out &lt;= &quot;0000&quot;;
        hold &lt;= '1';
        sample &lt;= '0';
        eoc &lt;= '0';
        
        if start = '1' then
            nx_state &lt;= state1;
        else
            nx_state &lt;= reset;
        end if;

    elsif(in_clk'event and in_clk='1') then
        case nx_state is
            when state1 =&gt; nx_state &lt;= state2;
                B_hold &lt;= &quot;0000&quot;;
                hold &lt;= '0';
                sample &lt;= '1';
            
            when state2 =&gt; nx_state &lt;= state3;
                B_hold &lt;= &quot;1111&quot;;
                D_out &lt;= &quot;0000&quot;;
            
            when state3 =&gt; nx_state &lt;= state4;
                B_hold(3) &lt;= '0';
                D_out(3) &lt;= '1';
                data_out(3) &lt;= '1';
            
            when state4 =&gt; nx_state &lt;= state5;
                if comp_in = '1' then
                    B_hold(3) &lt;= '0';
                    D_out(3) &lt;= '1';
                    data_out(3) &lt;= '1';
                else
                    B_hold(3) &lt;= '1';
                    D_out(3) &lt;= '0';
                    data_out(3) &lt;= '0';
                end if;
            
            when state5 =&gt; nx_state &lt;= state6;
                B_hold(2) &lt;= '0';
                D_out(2) &lt;= '1';
                data_out(2) &lt;= '1';
            
            when state6 =&gt; nx_state &lt;= state7;
                if comp_in = '1' then
                    B_hold(2) &lt;= '0';
                    D_out(2) &lt;= '1';
                    data_out(2) &lt;= '1';
                else
                    B_hold(2) &lt;= '1';
                    D_out(2) &lt;= '0';
                    data_out(2) &lt;= '0';
                end if;
            
            when state7 =&gt; nx_state &lt;= state8;
                B_hold(1) &lt;= '0';
                D_out(1) &lt;= '1';
                data_out(1) &lt;= '1';
            
            when state8 =&gt; nx_state &lt;= state9; 
                if comp_in = '1' then
                    B_hold(1) &lt;= '0';
                    D_out(1) &lt;= '1';
                    data_out(1) &lt;= '1';
                else
                    B_hold(1) &lt;= '1';
                    D_out(1) &lt;= '0';
                    data_out(1) &lt;= '0';
                end if;
                
            when state9 =&gt; nx_state &lt;= state10; 
                B_hold(0) &lt;= '0';
                D_out(0) &lt;= '1';
                data_out(0) &lt;= '1';
            
            when state10 =&gt; nx_state &lt;= reset;
                if comp_in = '1' then
                    B_hold(0) &lt;= '0';
                    D_out(0) &lt;= '1';
                    data_out(0) &lt;= '1';
                else
                    B_hold(0) &lt;= '1';
                    D_out(0) &lt;= '0';
                    data_out(0) &lt;= '0';
                end if;
                eoc &lt;= '1';
        end case;
    end if;
end process;
end behavior;

I'm new newbie at vhdl and I don't know what exactly is wrong with the conditions shown above.","Reset is level sensitive.  So change
if(rst_n'event and rst_n='0') then

to
if(rst_n='0') then

It is also unusual to have a condition within the reset condition
    if start = '1' then
        nx_state &lt;= state1;
    else
        nx_state &lt;= reset;
    end if;

Hence, you probably just want:
    nx_state &lt;= reset;
",,,,,
What is the difference between SDF Annotation and SDF back annotation?,"what is the difference between SDF annotation and SDF back annotation?
I am seeing both of these in gatelevel simulations.","People use these terms interchangeably. However the IEEE 1800-2017 LRM uses the term SDF annotation when talking about the data in the SDF file, which is actually defined in another standard, 1497-2001. The terms back-annotation and forward-annotation refer to a process for using that data.

SDF contains constructs for the description of computed timing data
for back-annotation and the specification of timing constraints for
forward-annotation. There is no restriction on using both sets of
constructs in the same file. Indeed, some design synthesis tools (such
as floorplanners) may need access to computed timing data as well as
the timing constraints intended to be meet.
",,,,,
How do I design Serial to Parallel Buffer in Verilog only using clocks?,"I am looking to design a serial to parallel converter in Verilog which converts a fast clock serial input to a slower clock parallel input. I tried the following code which works in RTL but does not verify on Cadence Conformal. nclk is 16 times faster than clk. The serial data comes in at nclk and the parallel data is intended to come out at clk rate.
sEEG - Serial Input
eegOut - Parallel output
I can only have clk and nclk as my operation references due to tape-out bond pad limitations.
Following is the code that I have come up with which works well in functional simulation but Formal Verification fails.
module deserializer(sEEG, nclk, clk, eegOut);
    input sEEG;
    input nclk,clk;
    reg [15:0] temp;
    output reg [15:0] eegOut;
    reg [4:0] i;
    
    always @(negedge nclk) begin
        temp[i] = sEEG;
        i = i + 1;
    end

    always@(posedge clk) begin
        i&lt;=0;
        eegOut &lt;= temp;
    end
endmodule
","I feel you should use four bits in order to index 16 elements. If you parameterize the module, this could be done with:
# (parameter WIDTH = 16)

then later use it as:
localparam BIT_SEL = $clog2(WIDTH); //..this should give you &quot;4&quot; if WIDTH = 16
reg [BIT_SEL-1:0] i;

Also, you might want to include a clock synchronizer, you don't want metastability problems, an easy way to do this is to include &quot;double-triggers&quot;, practically is to buffer the data and replicate it to the next slow clock cycle (adds 1 slow clock cycle latency). So, maybe this works:
module deserializer
# (parameter WIDTH = 16)
(sEEG, nclk, clk, eegOut);
    input sEEG;
    input nclk,clk;
    reg [WIDTH-1:0] temp;
    reg [WIDTH-1:0] temp_reg; //..synchronizer
    output reg [WIDTH-1:0] eegOut;
    
    always @(negedge nclk) begin
        temp[WIDTH-2:0] &lt;= temp[WIDTH-1:1];
        temp[WIDTH-1]   &lt;= sEEG;
    end

    always@(posedge clk) begin
        temp_reg &lt;= temp;
        eegOut   &lt;= temp_reg;
    end
endmodule
",,,,,
#NAME?,"I am using modlesim for my design and in this we are passing an option -svinputport=var, what is the use of this option? we are passing `default_nettype none before compiling each design files. Does these both are dependent? Could anyone help me with an example.
The description is as below for the option
svinputport=net|var|compat|relaxed
                     Select the default kind for an input port that is
                     declared with a type, but without the var keyword.
                     Select 'net' for strict LRM compliance, where the
                     kind always defaults to wire. Select 'var' for
                     non-compliant behavior, where the kind always defaults
                     to var. Select 'compat', where only types compatible with
                     net declarations default to wire. The default is 'relaxed',
                     where only a type that is a 4-state scalar or 4-state single
                     dimension vector type defaults to wire.

Question (2)
Thank you very much for the detailed explanation. I have one more doubt related to this. I am getting a warning when I run the following code:
`default_nettype none

module test(
input  reg sig1,
output logic sig2);
reg [1:0] ab;
endmodule

xmvlog: *W,NODNTW (test.sv,4|14): Implicit net port (sig1) is not allowed since `default_nettype is declared as 'none'; 'wire' used instead [19.2(IEEE 2001)]. why it is referring input reg sig1 as an implicit net port, I already explicitly declared it as reg? As per the message it is changing to wire so will the statement be like &quot;input wire reg sig1&quot; ?
Can we declare input reg a; in systemverilog(input port with reg type) ? Is this implicitly equivalent to input wire reg a; (if I dont use `default_nettype none)","Verilog is littered with implicit defaults all over the place. When you write
module m(a);
  initial $disaply(a);
endmodule

this is implicitly the same as
   //    direction kind type  range  signal
module m(inout     wire logic [0:0]  a);
  initial $disaply(a);
endmodule

For inout and input directions, if you omit the kind the default is wire or taken from the `default_nettype setting. The none setting generates an error. However, the default kind for an output is different. As soon as you add a datatype to an output, the default kind goes to var, which is similar to non-port declarations. See this post for more details and examples.
However, very early versions of SystemVerilog/Superlog had input and inout with the same kind default as output. The -svinputport=var switch was added for a very large microprocessor developer customer whose name I cannot mention who did not want to change their code. The =net options is the behavior I mentioned above and is the way current LRM is defined.
The other two options are hybrids between the var/net options, mainly for lazy people using the default_nettype none options and don't want to see errors in their port declarations.",,,,,
How to compile UVM library for Questa Modelsim 2020?,"I downloaded Modelsim from Intel, the free version (Modelsim-Intel FPGA editition). The free verison is the 32-bit version of Modelsim on Ubuntu 64-bit LTS. I implemented the workaround for this by installing the apt pkg's for i386 arch.
I want to create a testbench in SV using UVM.
This modelsim seems to only have compiled libraries for device support primitives. So I then downloaded UVM 2017-1.1 (IEEE 1800.2) from Accellera.
The documentation only instructs on how to unzip the tar.gz. Once unzipped, I see the source files with uvm.sv &amp; uvm_pkg.sv and the many svh files for the class files (reg, tlm, macros, drivers, monitors, env, etc.).
I do not see any additional makefile or instructions on how to compile for Modelsim.
I then created my own compile script:
vlog -64 -lint -modelsimini $(MSI_FILE) -quiet -sv17compat -work $(LIB_UVM) ~/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/uvm_pkg.sv
vlog -64 -lint -modelsimini $(MSI_FILE) -quiet -sv17compat -work $(LIB_UVM) ~/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/uvm.sv

I also set up UVM_HOME environment variable to point to the directory that contains the src folder in it.
The error I get on my compile script is this:
Error: ** while parsing file included at /home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/uvm_pkg.sv(26)
** while parsing file included at /home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/uvm_macros.svh(82)
** at /home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/macros/uvm_tlm_defines.svh(642): Cannot open `include file &quot;tlm1/uvm_tlm_imps.svh&quot;.
** Error: ** while parsing file included at /home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/uvm_pkg.sv(30)
** at /home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/dpi/uvm_dpi.svh(40): Cannot open `include file &quot;dpi/uvm_hdl.svh&quot;.
** Error: ** while parsing file included at /home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/uvm_pkg.sv(30)
** at /home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/dpi/uvm_dpi.svh(41): Cannot open `include file &quot;dpi/uvm_svcmd_dpi.svh&quot;.

I can see the svh files within the src folder, they are nested within the folders indicated. I can only assume the vlog compiler is looking at my local project folder and not the folder where uvm_pkg.sv is located in.
I then tried to use the +incdir+$(UVM_HOME) flag which points to the src file. I still get the same errors.
** Error: ** while parsing file included at /home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/uvm_pkg.sv(35)
** at /home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/seq/uvm_seq.svh(32): Cannot open `include file &quot;/home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1//seq/uvm_sequence.svh&quot;.
** Error: ** while parsing file included at /home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/uvm_pkg.sv(35)
** at /home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1/src/seq/uvm_seq.svh(33): Cannot open `include file &quot;/home/deadsupra/rtl_lib/UVM-18002-2017-11tar/1800.2-2017-1.1//seq/uvm_sequence_library.svh&quot;.

Any help would be appreciated. I have searched for any proper method to compile UVM, a lot of it seems to point to +incdir. But a lot of examples are for older versions of modelsim and older UVM 1.1 or 1.2.","I found the issue. In my compile script I gave it the right path to the .sv files. However, my earlier version of the path in the environment variable UVM_HOME did not set the directory including the src folder. Once I reran my source.sh script and updated the environment variable, the .svh files were able to locate the dependency files appropriately.
It was in front of me the whole time as well with the error message showing no src folder in the path it was looking in: ..../1800.2-2017-1.1//seq/uvm_sequence.svh",,,,,
Can I add a module in a package? Or how to write relative modules?,"It's pretty common to have the exact same name for modules (such as arbiter, fifo and so on). Or when using open-source project.

Is there a way to make a module relative?
Can I add a module in a package?
Is there a better way to handle that other than renaming and changing ALL the files?

Edit:
Library and config aren't supported by Vivado.

Keywords marked with an asterisk (*) are
reserved by Verilog and are not supported by Vivado synthesis.

UG901 (v2020.1) June 24, 2020:
","You cannot declare modules in a package.
SystemVerilog has a way of nesting module declarations so that you can define module A that contains a declaration of module B. That makes module B private to module A, and only A can instantiate B.
For an open-source project, or any project for that matter, you can compile modules into separate libraries (lib1, lib2, etc.). Then you can have modules with the same name (fifo) in each library, and any module in lib1 that instantiates a fifo will pick it up from the same library. If it there is no fifo in the same library, you can specify a library search order that instructs where to pick the fifo. You can even have a module with two instances of a fifo and have one instance come from lib1 and the other come from lib2.
This is explained in section 33. Configuring the contents of a design in the IEEE 1800-2017 SystemVerilog LRM. The details of how libraries are managed is tool specific. Please read you tool's user manual or contact your tool vendor directly for support.",,,,,
Same sequence to multiple sequencers in UVM,"I have a DUT with 2 Interfaces of the same type. I have created 2 agents to drive the two interfaces. My idea is to drive the same signals on the interface ports to test a specific scenario. Hence, I thought of creating a sequence and driving it to the two sequencers of the agents. But I get an error. The code is something as follows:
my_sequencer m_seqr[2];
my_sequence m_seq;

for(int i=0; i&lt;2; i++) begin
  fork
    int idx = i;
      m_seq.start(p_sequencer.m_seqr[i];
  join_none
end  

I haven't shown the complete code for keeping the post short. I think my declarations and initializations are correct because I have a similar test with 2 sequences feeding into 2 sequencers working correctly.
My question is how can I achieve my objective of driving the same sequence into 2 or more sequencers?
Error is as follows(Haven't added the complete line of error):
uvm_test_top.m_env.m_my_agent_env.m_my_agent[1].m_seqr@@m_in_seq%0d[SEQ_NOT_DONE] Sequuence .... already started
","You need to construct a new object for each sequence you want to start. Also, you need to reference [idx] not [i].
my_sequencer m_seqr[2];
...
for(int i=0; i&lt;2; i++) 
  fork
    int idx = i;
    my_sequence m_seq = my_sequence::type_id::create(...);
    
    m_seq.start(p_sequencer.m_seqr[idx];

  join_none 
",,,,,
How to fill-up a dual port ROM in Quartus,"Below is my ROM, and I have binary values in a .txt file, but I'm not sure how to initialize the ROM with those values. I've done some research, and it seems like a .mif file is one way of doing it (but seems a little complicated, procedurally) and I've found $readmemb as another option but it seems like that's only for simulations? Any help/clarification would be appreciated!
module dual_port_rom (clk, addr_1, addr_2, data_1, data_2);
        
    input clk;
    input [7:0] addr_1;
    input [7:0] addr_2; //check address width!!! and also see how to fill -_-
    output [7:0] data_1;
    output [7:0] data_2;
    reg [7:0] rom [5122:0];
    reg [7:0] read_a1;
    reg [7:0] read_a2;
        
    always @(posedge clk) begin
        read_a1 &lt;= addr_1;
        read_a2 &lt;= addr_2;
    end
    
    assign data_1 = rom[read_a1];
    assign data_2 = rom[read_a2];
    
endmodule
","You can use $readmemb or $readmemh to initialize the contents of a ROM in Quartus. Look at Section 1.4.2, Example 20 in the Recommended HDL Coding Styles for the suggested Verilog for inferring a dual ported ROM: https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug-qpp-design-recommendations.pdf ; for reference heres how your code would look:
module dual_port_rom (clk, addr_1, addr_2, data_1, data_2);

  input clk;
  input [7:0] addr_1;
  input [7:0] addr_2;
  output reg [7:0] data_1; // Can declare these as reg type directly rather than have an intermediate
  output reg [7:0] data_2;
  reg [7:0] rom [5122:0];

  // From the example, initialize the ROM with $readmemb; which is compatible with simulation making trying out the ROM easier
  initial begin
    $readmemb(&quot;init_file.txt&quot;, rom);
  end

  always @(posedge clk) begin
    data_1 &lt;= rom[addr_1]; // Following the style from the example, the data should be put into a register once read from the ROM rather than the address. This shouldnt effect the timing of your system since you were putting the address into a register though
    data_2 &lt;= rom[addr_2];
  end
endmodule

Be sure that your file follows the proper format for files expected by those functions, you can learn more here:
How to initialize contents of inferred Block RAM (BRAM) in Verilog",,,,,
"How to solve ""Unresolved defparam reference"" Error in ModelSIM?","I've generated a reciprocal ROM using Quartus II and I've developed a circuit that calculates the hyperbolic tangent. I'm facing the following error when I try to simulate a testbench of my circuit. Note that I've used the ROM as an instantiate in my circuit.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.address_aclr_a.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.clock_enable_input_a.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.clock_enable_output_a.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.init_file.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.intended_device_family.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.lpm_hint.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.lpm_type.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.numwords_a.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.operation_mode.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.outdata_aclr_a.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.outdata_reg_a.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.widthad_a.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.width_a.
Unresolved defparam reference to 'altsyncram_component' in altsyncram_component.width_byteena_a.

and this is the Verilog output of the ROM that I've generated in Quartus II:
// megafunction wizard: %ROM: 1-PORT%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: altsyncram 

// ============================================================
// File Name: RecipROM.v
// Megafunction Name(s):
//          altsyncram
//
// Simulation Library Files(s):
//          altera_mf
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 12.1 Build 177 11/07/2012 SJ Web Edition
// ************************************************************

    
//Copyright (C) 1991-2012 Altera Corporation
//Your use of Altera Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Altera Program License 
//Subscription Agreement, Altera MegaCore Function License 
//Agreement, or other applicable license agreement, including, 
//without limitation, that your use is for the sole purpose of 
//programming logic devices manufactured by Altera and sold by 
//Altera or its authorized distributors.  Please refer to the 
//applicable agreement for further details.


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module RecipROM (
    address,
    clock,
    q);

    input   [2:0]  address;
    input     clock;
    output  [15:0]  q;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
    tri1      clock;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

    wire [15:0] sub_wire0;
    wire [15:0] q = sub_wire0[15:0];

    altsyncram  altsyncram_component (
                .address_a (address),
                .clock0 (clock),
                .q_a (sub_wire0),
                .aclr0 (1'b0),
                .aclr1 (1'b0),
                .address_b (1'b1),
                .addressstall_a (1'b0),
                .addressstall_b (1'b0),
                .byteena_a (1'b1),
                .byteena_b (1'b1),
                .clock1 (1'b1),
                .clocken0 (1'b1),
                .clocken1 (1'b1),
                .clocken2 (1'b1),
                .clocken3 (1'b1),
                .data_a ({16{1'b1}}),
                .data_b (1'b1),
                .eccstatus (),
                .q_b (),
                .rden_a (1'b1),
                .rden_b (1'b1),
                .wren_a (1'b0),
                .wren_b (1'b0));
    defparam
        altsyncram_component.address_aclr_a = &quot;NONE&quot;,
        altsyncram_component.clock_enable_input_a = &quot;BYPASS&quot;,
        altsyncram_component.clock_enable_output_a = &quot;BYPASS&quot;,
        altsyncram_component.init_file = &quot;../initROM.mif&quot;,
        altsyncram_component.intended_device_family = &quot;Cyclone IV GX&quot;,
        altsyncram_component.lpm_hint = &quot;ENABLE_RUNTIME_MOD=NO&quot;,
        altsyncram_component.lpm_type = &quot;altsyncram&quot;,
        altsyncram_component.numwords_a = 8,
        altsyncram_component.operation_mode = &quot;ROM&quot;,
        altsyncram_component.outdata_aclr_a = &quot;NONE&quot;,
        altsyncram_component.outdata_reg_a = &quot;CLOCK0&quot;,
        altsyncram_component.widthad_a = 3,
        altsyncram_component.width_a = 16,
        altsyncram_component.width_byteena_a = 1;


endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: PRIVATE: ADDRESSSTALL_A NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: AclrAddr NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: AclrByte NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: AclrOutput NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: BYTE_ENABLE NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: BYTE_SIZE NUMERIC &quot;8&quot;
// Retrieval info: PRIVATE: BlankMemory NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: CLOCK_ENABLE_INPUT_A NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: CLOCK_ENABLE_OUTPUT_A NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: Clken NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: IMPLEMENT_IN_LES NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: INIT_FILE_LAYOUT STRING &quot;PORT_A&quot;
// Retrieval info: PRIVATE: INIT_TO_SIM_X NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING &quot;Cyclone IV GX&quot;
// Retrieval info: PRIVATE: JTAG_ENABLED NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: JTAG_ID STRING &quot;NONE&quot;
// Retrieval info: PRIVATE: MAXIMUM_DEPTH NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: MIFfilename STRING &quot;../initROM.mif&quot;
// Retrieval info: PRIVATE: NUMWORDS_A NUMERIC &quot;8&quot;
// Retrieval info: PRIVATE: RAM_BLOCK_TYPE NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: RegAddr NUMERIC &quot;1&quot;
// Retrieval info: PRIVATE: RegOutput NUMERIC &quot;1&quot;
// Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING &quot;1&quot;
// Retrieval info: PRIVATE: SingleClock NUMERIC &quot;1&quot;
// Retrieval info: PRIVATE: UseDQRAM NUMERIC &quot;0&quot;
// Retrieval info: PRIVATE: WidthAddr NUMERIC &quot;3&quot;
// Retrieval info: PRIVATE: WidthData NUMERIC &quot;16&quot;
// Retrieval info: PRIVATE: rden NUMERIC &quot;0&quot;
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: CONSTANT: ADDRESS_ACLR_A STRING &quot;NONE&quot;
// Retrieval info: CONSTANT: CLOCK_ENABLE_INPUT_A STRING &quot;BYPASS&quot;
// Retrieval info: CONSTANT: CLOCK_ENABLE_OUTPUT_A STRING &quot;BYPASS&quot;
// Retrieval info: CONSTANT: INIT_FILE STRING &quot;../initROM.mif&quot;
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING &quot;Cyclone IV GX&quot;
// Retrieval info: CONSTANT: LPM_HINT STRING &quot;ENABLE_RUNTIME_MOD=NO&quot;
// Retrieval info: CONSTANT: LPM_TYPE STRING &quot;altsyncram&quot;
// Retrieval info: CONSTANT: NUMWORDS_A NUMERIC &quot;8&quot;
// Retrieval info: CONSTANT: OPERATION_MODE STRING &quot;ROM&quot;
// Retrieval info: CONSTANT: OUTDATA_ACLR_A STRING &quot;NONE&quot;
// Retrieval info: CONSTANT: OUTDATA_REG_A STRING &quot;CLOCK0&quot;
// Retrieval info: CONSTANT: WIDTHAD_A NUMERIC &quot;3&quot;
// Retrieval info: CONSTANT: WIDTH_A NUMERIC &quot;16&quot;
// Retrieval info: CONSTANT: WIDTH_BYTEENA_A NUMERIC &quot;1&quot;
// Retrieval info: USED_PORT: address 0 0 3 0 INPUT NODEFVAL &quot;address[2..0]&quot;
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT VCC &quot;clock&quot;
// Retrieval info: USED_PORT: q 0 0 16 0 OUTPUT NODEFVAL &quot;q[15..0]&quot;
// Retrieval info: CONNECT: @address_a 0 0 3 0 address 0 0 3 0
// Retrieval info: CONNECT: @clock0 0 0 0 0 clock 0 0 0 0
// Retrieval info: CONNECT: q 0 0 16 0 @q_a 0 0 16 0
// Retrieval info: GEN_FILE: TYPE_NORMAL RecipROM.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL RecipROM.inc TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL RecipROM.cmp TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL RecipROM.bsf TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL RecipROM_inst.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL RecipROM_bb.v TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL RecipROM_syn.v TRUE
// Retrieval info: LIB_FILE: altera_mf

How can I solve this error?","Probably you just need to load the Altera libraries in Modelsim:

using GUI: Simulate &gt; Start Simulation &gt; Libraries &gt; Add &gt; altera_mf_ver
using console: add -L altera_mf_ver to your command.
",,,,,
.sum() and .max() not included in Systemverilog?,"Why does the error say sum/max &quot;is not declared under this prefix&quot;? I thought Systemverilog had these array reduction functions included. Do I need to add a library or something to use them?
Code below:
module compare_block (clk, result, data, led);

    parameter taps = 50; //number of fir filter taps
    parameter data_width = 8; //width of data input including sign bit
    parameter coeff_width = 32; //width of coefficients including sign bit
    parameter size = 4096;

    
    input clk;
    input [(data_width + coeff_width + $clog2(taps) - 1):0] result; //from filter
    input [(data_width-1):0] data; //precalculated 1 Hz sine wave
    output led;
    
    reg [(data_width + coeff_width + $clog2(taps) - 1):0] filt_sig;
    reg [(data_width-1):0] comp_sig;
    reg [(data_width-1):0] ans_sig;
    
    integer i;
    integer ii;
    integer sum_array;
    integer array_avg;

        
    always @(posedge clk)
        begin
        filt_sig [(data_width + coeff_width + $clog2(taps) - 1):0]&lt;= result[(data_width + coeff_width + $clog2(taps) - 1):0];
        comp_sig [(data_width-1):0]&lt;= data[(data_width-1):0];
        end
        
    always @(*)
        begin
        for (i=0; i &lt; size; i=i+1)
            ans_sig[i] = filt_sig[i] - comp_sig[i]; 
        end
        assign sum = ans_sig.sum(); //with (int'(item)) 
        assign array_avg = sum &gt;&gt; 'd12; //dividing by 4096 (size) to get mean of signal deviation
        
    integer max_array = ans_sig.max();
    integer error_val = 0.5*max_array;  
    always @(*)
        begin 
        if (array_avg &lt; error_val) begin
            led &lt;= 'b1; 
        end else begin
            led &lt;= 'b0;
        end
    end
endmodule
","The array reduction methods are defined for unpacked arrays. Instead of sum(), you can use $countones(ans_sig). I'm not sure what you are trying to compute with max(). Maybe you meant to declare ans_sig as an unpacked array.",,,,,
How can I import parameters from external file using `include?,"I want to import a set of parameter values from an external file into my Verilog source files (not System Verilog).
I am trying this:
For the main module:
        module temp (
        `include &quot;file.vh&quot;
        input [WIDTH:0] data_in,
        output reg [WIDTH:0] data_out,
        input clk
    );
        always @(posedge clk) begin
            data_out &lt;= data_in;
        end
    endmodule


and a file.vh file:
    parameter WIDTH = 12;

Please correct me here as this code is not working.","Parameters are either declared in the module body or in a separate part of the header:
module temp(...);
`include &quot;parameters.vh&quot;
...
endmodule

parameters.vh:
parameter WIDTH = 12; // Use semicolons to terminate the lines
parameter ANOTHER = 4;

Or:
module temp #(`include &quot;parameters.vh&quot;) (...);
...
endmodule

parameters.vh:
parameter WIDTH = 12, // Use commas on each line except the last one
parameter ANOTHER = 4

Since including a file is just like a copy paste of the code from the included file, you need to be sure the code at the end is valid Verilog.",,,,,
Convert std_logic_vector to enum type in VHDL,I want to create verilog testbench for the vhdl designs but my vhdl design source contains some enum type cannot accept by Vivado's  mixed language boundary Ref. So I create a VHDL wrapper to convert enum type to std_logic_vector type or convert std_logic_vector to enum type. There are some elegant way to converting enum type to std_logic_vector Convert enum type to std_logic_vector VHDL. But How to converting std_logic_vector to enum type in VHDL?,"As you are mentioning Vivado I guess you are more interested in synthesis semantics than simulation semantics. I will thus assume that your std_logic_vector objects carry information that can be considered as the binary representation of integers, and that you are not interested in std_logic values other than '0' and '1'.
To convert std_logic_vector values to an enumerated type you will first need a large enough enumerated type. So, if your vectors are N bits long you will need a 2^N values enumerated type, for instance, if N=16:
type s2e_t is (s2e0, s2e1,... , s2e65535);

(lot of typing but as you asked for it...) Then, you can simply convert your vector values to non-negative integer values and pick the corresponding enumerated type value with the val type attribute (dual of the pos attribute):
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
...
type s2e_t is (s2e0, s2e1,... , s2e65535);
signal e: s2e_t;
signal s: std_logic_vector(15 downto 0);
...
e &lt;= s2e_t'val(to_integer(unsigned(s));
",,,,,
Does SystemVerilog Generate support delays?,"I thought of generating clock using genvar like below:
        reg [7:0]clk;  
      
     genvar i;
        generate
          for (i=0; i &lt; 7; i++) begin
              #1 clk[i]=~clk[i];
            end
        endgenerate

I am getting an error:

error: near &quot;#&quot;: syntax error, unexpected '#'

How can we resolve it?  Can I use delays inside generate block?","Yes, generate blocks support delays.  To fix your problem, use a procedural always block:
reg [7:0] clk;  

genvar i;
generate
    for (i=0; i &lt; 7; i++) begin
        always #1 clk[i]=~clk[i];
    end
endgenerate
",,,,,
Assigning values to parametrized arrays in Verilog,"Suppose I have the following module definition,
module foo(b)
input b;
parameter length = 8;

reg [length-1:0] dummy ;

Now, I want to assign values to this dummy array. For instance I want to make it all 1s. If the length was not parameterized, I could do this,
always @(posedge b)
 dummy &lt;= 8'hFF;

But when the length is parameterized, I would hope to do this,
always @(posedge b)
 dummy &lt;= length'hFFFF //won't even compile. even if it did, how many F's should there be?

How can I assign ones (or zeroes) to an entire array whose length is parameterized? Or more generally, how can I assign values while specifing the length of a parameterized array?","You can write
always @(posedge b)
 dummy &lt;= ~1'b0;

This takes advantage of the fact that Verilog extends operands before applying operators when they are in context-determined expressions.
In SystemVerilog, you can write
always @(posedge b)
 dummy &lt;= '1;
",,,,,
"ice40 clock delay, output timing analysis","I have an ice40 that drives the clock and data inputs of an ASIC.
The ice40 drives the ASIC's clock with the same clock that drives the ice40's internal logic. The problem is that the rising clock triggers the ice40's internal logic and changes the ice40's data outputs a few nanoseconds before the rising clock reaches the ASIC, and therefore the ASIC observes the wrong data at its rising clock.
I've solved this issue by using an inverter chain to delay the ice40's internal clock without delaying the clock driving the ASIC. That way, the rising clock reaches the ASIC before the ice40's data outputs change. But that raises a few questions:

Is my strategy -- using an inverter chain to delay the ice40 internal clock -- a good strategy?

To diagnose the problem, I used Lattice's iCEcube2 to analyze the min/max delays between the internal clock and output pins:



Notice that the asic_dataX delays are shorter than the clk_out delay, indicating the problem.
Is there a way to get this information from yosys/nextpnr?
Thank you for any insight!","Instead of tinkering with the delays I would recommend to use established techniques. For example SPI simple clocks the data on the one edge and changes them on the other: .
The logic to implement that is rather simple. Here an example implementation for an SPI slave:
module SPI_slave #(parameter WIDTH = 6'd16, parameter phase = 1'b0,
                   parameter polarity = 1'b0, parameter bits = 5) (
    input wire rst,
    input wire CS,
    input wire SCLK,
    input wire MOSI,
    output reg MISO,  
    output wire data_avbl,
    input wire [WIDTH-1:0] data_tx,
    output reg [WIDTH-1:0] data_rx
    );

reg [bits:0]    bitcount;
reg [WIDTH-1:0] buf_send;            

assign clk          = phase ^ polarity ^ SCLK;
assign int_rst      = rst | CS;
assign tx_clk       = clk | CS;
assign data_avbl    = bitcount == 0;            
                               
always @(negedge tx_clk or posedge rst) begin
    MISO &lt;= rst ? 1'b0 : buf_send[WIDTH-1];
end

always @(posedge clk or posedge int_rst) begin  
    if (int_rst) begin
        bitcount    &lt;= WIDTH;
        data_rx     &lt;= 0;
        buf_send    &lt;= 0;
    end else begin    
        bitcount    &lt;= (data_avbl ? WIDTH : bitcount) - 1'b1;                
        data_rx     &lt;= { data_rx[WIDTH-2:0], MOSI };
        buf_send    &lt;= bitcount == 1 ? data_tx[WIDTH-1:0] : { buf_send[WIDTH-2:0], 1'b0};
    end   
end

endmodule

As one can see the data are captured at the positive edge and changed on the negative edge. If one wants to avoid the mixing of edge sensistivies a doubled clock can be used instead.",,,,,
Interrupt Handler Stops Working After Kernel Module Reload (Xilinx FPGA / PCIe),"I am currently working on a PCI driver for the Xilinx Kintex 7 board using the Xilinx PCI IP core (AXI Memory Mapped to PCIe).
One problem is, that the interrupt handler stops working when I reload the kernel module. In more detail:

Fresh boot of my machine
Load the kernel module and monitor the kernel messages with dmesg
/proc/interrupts shows the expected interrupt ids
I trigger the HW interrupt and everything works as expected; I can see the interrupt handler working.
rmmod my_module
/proc/interrupts removed the interrupt ids as expected
insmod my_module and trigger interrupt
Now the interrupt handler is silent and /proc/interrupts does not increase the counter

I reboot my machine and everything works again. The fact that I do not have to restart the FPGA lets me assume that I do something wrong in the kernel module and its probably not an HW problem.
I've already used /sys/pci/devices/.../reset, /sys/bus/pci/devices/.../remove and /sys/bus/pci/rescan to try to reach a state which is equivalent to freshly booted machine. But nothing worked.
Relevant module code:
#define VENDOR_ID 0x10EE
#define DEVICE_ID 0x7024

static dev_t pci_dev_number;
static struct cdev * driver_object;
static struct class * pci_class;
static struct device * pci_prc;
static struct device * pci_irq_0;
static struct device * pci_irq_1;

static int msi_vec_num = 2; // Number of requested MSI interrupts
static int msi_0 = -1;
static int msi_1 = -1;

// Used for poll and select
static DECLARE_WAIT_QUEUE_HEAD(queue_vs0);
static DECLARE_WAIT_QUEUE_HEAD(queue_vs1);

static irqreturn_t pci_isr_0(int irq, void * dev_id) {
  printk(KERN_NOTICE &quot;codec IRQ: interrupt handler 0. IRQ: %d\n&quot;, irq);
  wake_up_interruptible(&amp;queue_vs0);
  return IRQ_HANDLED;
}

static irqreturn_t pci_isr_1(int irq, void * dev_id) {
  printk(KERN_NOTICE &quot;codec IRQ: interrupt handler 1. IRQ: %d\n&quot;, irq);
  wake_up_interruptible(&amp;queue_vs1);
  return IRQ_HANDLED;
}

static void* bars[PCIE_BARS] = {0};

static int device_init(struct pci_dev * pdev, const struct pci_device_id * id) {
  int i = 0; // loop var
  if (pci_enable_device(pdev))
    return -EIO;

  // Request memory regions for bar 0 to 2
  for (i = 0; i &lt; PCIE_BARS; i++) {
    if (pci_request_region(pdev, i, &quot;codec_pci&quot;) != 0) {
      dev_err( &amp; pdev - &gt; dev, &quot;Bar %d - I/O address conflict for device \&quot;%s\&quot;\n&quot;, i, pdev - &gt; dev.kobj.name);
      return -EIO;
    }
  }

  // DEBUG: Check if we are in memory space (which we should) or io space
  if ((pci_resource_flags(pdev, 0) &amp; IORESOURCE_IO)) {
    printk(KERN_NOTICE &quot;codec INIT: in io space\n&quot;);
  } else if ((pci_resource_flags(pdev, 0) &amp; IORESOURCE_MEM)) {
    printk(KERN_NOTICE &quot;codec INIT: in mem_space\n&quot;);
  }

  // This request enables MSI_enable in the hardware
  msi_vec_num = pci_alloc_irq_vectors(pdev, 1, msi_vec_num, PCI_IRQ_MSI);

  // msi_N will contain the IRQ number - see /proc/interrupts
  msi_0 = pci_irq_vector(pdev, 0);
  msi_1 = pci_irq_vector(pdev, 1);
  printk(KERN_NOTICE &quot;codec INIT: nvec: %d\n&quot;, msi_vec_num);
  printk(KERN_NOTICE &quot;codec INIT: msi_0: %d\n&quot;, msi_0);
  printk(KERN_NOTICE &quot;codec INIT: msi_1: %d\n&quot;, msi_1);

  if (request_irq(msi_0, pci_isr_0, IRQF_SHARED, &quot;codec_pci&quot;, pdev)) {
    dev_err( &amp; pdev - &gt; dev, &quot;codec INIT: IRQ MSI %d not free.\n&quot;, msi_0);
    goto cleanup;
  };
  if (request_irq(msi_1, pci_isr_1, IRQF_SHARED, &quot;codec_pci&quot;, pdev)) {
    dev_err( &amp; pdev - &gt; dev, &quot;codec INIT: IRQ MSI %d not free.\n&quot;, msi_1);
    goto cleanup;
  };

  for (i = 0; i &lt; PCIE_BARS; i++) {
    // Last parameter is the address space/length of each bar. Defined in the PCIe core.
    bars[i] = pci_iomap(pdev, i, pci_resource_len(pdev, i));
    if (bars[i] == NULL) {
      printk(KERN_ERR &quot;codec INIT: bar %d allocation failed\n&quot;, i);
      goto cleanup;
    }
    printk(KERN_NOTICE &quot;codec INIT: bar %d pointer: %p\n&quot;, i, bars[i]);
  }

  printk(KERN_NOTICE &quot;codec INIT: loaded\n&quot;);

  return 0;
cleanup:
    for (i = 0; i &lt; PCIE_BARS; i++) {
      if (bars[i] != NULL)
        pci_iounmap(pdev, bars[i]);
      pci_release_region(pdev, i);
    }
    
  return -EIO;
}

static void device_deinit(struct pci_dev * pdev) {
  int i = 0; // loop var

  if (msi_0 &gt;= 0)
    free_irq(msi_0, pdev);

  if (msi_1 &gt;= 0)
    free_irq(msi_1, pdev);

  pci_free_irq_vectors(pdev);

  // release bar regions
  for (i = 0; i &lt; PCIE_BARS; i++)
    pci_release_region(pdev, i);

  for (i = 0; i &lt; PCIE_BARS; i++) {
    if (bars[i] != NULL)
      pci_iounmap(pdev, bars[i]);
  }
  pci_disable_device(pdev);
}

// File operations not in this snipped
static struct file_operations fops = {
  .owner = THIS_MODULE,
  .open = device_open,
  .read = device_read,
  .write = device_write,
  .poll = device_poll
};

static struct pci_device_id pci_drv_tbl[] = {
  {
    VENDOR_ID,
    DEVICE_ID,
    PCI_ANY_ID,
    PCI_ANY_ID,
    0,
    0,
    0
  },
  {
    0,
  }
};

static struct pci_driver pci_drv = {
  .name = &quot;codec_pci&quot;,
  .id_table = pci_drv_tbl,
  .probe = device_init,
  .remove = device_deinit
};

static int __init mod_init(void) {
  int i = 0;
  if (alloc_chrdev_region( &amp; pci_dev_number, 0, MAX_DEVICES, &quot;codec_pci&quot;) &lt; 0)
    return -EIO;
  driver_object = cdev_alloc();
  if (driver_object == NULL)
    goto free_dev_number;
  driver_object - &gt; owner = THIS_MODULE;
  driver_object - &gt; ops = &amp; fops;
  if (cdev_add(driver_object, pci_dev_number, MAX_DEVICES))
    goto free_cdev;
  pci_class = class_create(THIS_MODULE, &quot;codec_pci&quot;);
  if (IS_ERR(pci_class)) {
    pr_err(&quot;codec MOD_INIT: no udev support available\n&quot;);
    goto free_cdev;
  }

  pci_prc = device_create(pci_class, NULL, MKDEV(MAJOR(pci_dev_number), MINOR(pci_dev_number) + 0), NULL, &quot;%s&quot;, &quot;codec_prc&quot;);
  pci_irq_0 = device_create(pci_class, NULL, MKDEV(MAJOR(pci_dev_number), MINOR(pci_dev_number) + 1), NULL, &quot;codec_irq_%d&quot;, 0);
  pci_irq_1 = device_create(pci_class, NULL, MKDEV(MAJOR(pci_dev_number), MINOR(pci_dev_number) + 2), NULL, &quot;codec_irq_%d&quot;, 1);

  if (pci_register_driver( &amp; pci_drv) &lt; 0) {
    for (i = 0; i &lt; MAX_DEVICES; i++)
      device_destroy(pci_class, MKDEV(pci_dev_number, i));
    goto free_dev_number;
  }

  return 0;
free_cdev:
    kobject_put( &amp; driver_object - &gt; kobj);
free_dev_number:
    unregister_chrdev_region(pci_dev_number, MAX_DEVICES);
  return -EIO;
}

static void __exit mod_exit(void) {
  int i = 0;
  pci_unregister_driver( &amp; pci_drv);
  device_unregister(pci_prc);
  device_unregister(pci_irq_0);
  device_unregister(pci_irq_1);
  for (i = 0; i &lt; MAX_DEVICES; i++) {
    device_destroy(pci_class, MKDEV(pci_dev_number, i));
  }
  class_destroy(pci_class);
  cdev_del(driver_object);
  unregister_chrdev_region(pci_dev_number, MAX_DEVICES);
}

module_init(mod_init);
module_exit(mod_exit);

Error handling routines could be better, but they don't get triggered anyway.","I guess I found the cause of my problem. I took a look at the PCI configuration space while executing each of the steps of my original post. The configuration space when interrupts are working:
# lspci -xxx | grep Xilinx
23:00.0 Memory controller: Xilinx Corporation Device 7024
00: ee 10 24 70 *07* 04 10 00 00 00 80 05 10 00 00 00
. . .

And when it's broken:
# lspci -xxx | grep Xilinx
23:00.0 Memory controller: Xilinx Corporation Device 7024
00: ee 10 24 70 *03* 04 10 00 00 00 80 05 10 00 00 00
. . .

What I found is that the command register value changes after the kernel module reload (marked with *). When the interrupt works the command register value is 0x0407, after the module reload it is 0x0403. Why? I don't know. It is probably just the way the Xilinx AXI Memory Mapped to PCIe core is implemented.
Anyway, you can set the values of the PCI configuration space using setpci(8).
The wanted value of the command register is 0407 so you execute:
# setpci -d &lt;vendor_id&gt;:&lt;device_id&gt; command=0407

#read back to check if it worked
# sudo setpci -d &lt;vendor_id&gt;:&lt;device_id&gt; command
0407

Afterwards the interrupts are working again, and I do not need to reboot.
Within the kernel module you can e.g. use pci_write_config_byte(...) to set the command register (or any other) to the required value. The corresponding functions to access the configuration space can be found here: Linux Device Drivers - Accessing the Configuration Space",,,,,
"near ""loop"": expecting IF; near ""process"": expecting LOOP","This is the error

Error: C:/modeltech64_10.5/examples/zarb.vhd(51): near &quot;loop&quot;: (vcom-1576) expecting IF.

Error: C:/modeltech64_10.5/examples/zarb.vhd(56): near &quot;process&quot;: (vcom-1576) expecting LOOP.


library IEEE;

use IEEE.std_logic_1164.all;

use IEEE.std_logic_signed.all;

use IEEE.numeric_std.all;

entity MULT is

GENERIC(n:integer:=4);

 port(A,B: in  std_logic_vector(n-1 downto 0);
       P : out std_logic_vector(2*n-1 downto 0)); -- PRODUCT

end entity;


architecture BOOTH of MULT is

begin

BOOTH:process(A,B)

 variable X:std_logic_vector(2*n downto 0); 

 variable Y:std_logic_vector(n-1 downto 0); 

 variable Z:std_logic_vector(n-1 downto 0); 

 variable U:std_logic_vector(n-1 downto 0); 

begin

for J in 0 to n-1 loop

 U(j):='0';

end loop;

 X:=U &amp; A &amp; '0';

 Y:=B;               
 
for I in 0 to n-1 loop

 if(X(1)='1' and X(0)='0') then

  Z:=X(2*n downto n+1);

   X(2*n downto n+1):= Z-Y;

    X(2*n-1 downto 0):=X(2*n downto 1);


 else if(X(1)='0' and X(0)='1') then

  Z:=X(2*n downto n+1);

   X(2*n downto n+1):= Z+Y;

    x(2*n-1 downto 0):=X(2*n downto 1);


 else

  X(2*n-1 downto 0):=X(2*n downto 1);

end if;

end loop;

P(2*n-1 downto 0) &lt;= X(2*n downto 1);


end process;

end architecture BOOTH;
","Let's try to understand what the compiler is telling you here. At the end loop it was expecting an end if. That means that you are actually inside another if when you try to close your loop. The next error is just a consequence of the first.
Why is that so?
Let's check where the starts of the blocks in question could possibly be. At the end if above the end loop, you are obviously closing one if successfully, yet you are still inside another one, according to the compiler. You think you close the if(X(1)='1' and X(0)='0') then, but obviously you don't, otherwise we wouldn't have that error.
Is there another if between that one and the end if? Yes! It is in this line: else if(X(1)='0' and X(0)='1') then.
You obviously thought that this counts as part of the original if, but the compiler thinks otherwise, so that's the point where you would google else if vhdl. You would then find that the correct syntax is actually elsif, because otherwise you do else plus a new, separate if inside of the else, which is what happened here.
To visualize what happened, by using the indentation that would match what the compiler sees right now:
for I in 0 to n-1 loop
 if(X(1)='1' and X(0)='0') then
   ...
 else
   if(X(1)='0' and X(0)='1') then
    ...
   else
    ...
   end if;
 ??? (end if missing here)
end loop; &lt;&lt;&lt; error, end if expected, end loop found

With elsif, it would be like this instead:
for I in 0 to n-1 loop
 if(X(1)='1' and X(0)='0') then
   ...
 elsif(X(1)='0' and X(0)='1') then
  ...
 else
  ...
 end if;
end loop;

Bottom line: You need elsif instead of else if.
By the way: Your indentation makes no sense. You have subsequent lines always indented one space further, even though they are on the same block level. This is only going to confuse you. Make sure you indent your code properly - there are also editor plugins out there that can help you with that.",,,,,
how to reduce integer bit size in vivado,"I have to implementation my design to board nexys 4. In my design, I have 4 inputs with integer data types. The integer in vivado default has 32 bits data length, meanwhile in board nexys 4 only can process integer with maximum data length 16 bits to set in GPIO ports. so I want to know how can I reduce the data length of the integer from 32 bits to 16 bits, can you help me, please? Thank you","Use a standard vector type and convert it internally to integer:
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity my_design is
port(
  v1, v2, v3, v4: in std_ulogic_vector(15 downto 0);
  ...
);
end entity my_design;

architecture rtl of my_design is
  signal i1, i2, i3, i4: natural range 0 to 2**16 - 1;
  ...
begin
  i1 &lt;= to_integer(unsigned(v1));
  i2 &lt;= to_integer(unsigned(v1));
  i3 &lt;= to_integer(unsigned(v1));
  i4 &lt;= to_integer(unsigned(v1));
  ...
  -- use signals i1, i2, i3, i4
  ...
end architecture rtl;

In case your integers are signed use:
  signal i1, i2, i3, i4: integer range -2**15 to 2**15 - 1;

and:
  i1 &lt;= to_integer(signed(v1));
",,,,,
Vhdl: unconstrained arrays and size instaniation,"I am attempting to pass an array size ( integer ArraySize) from a Top-level file to a component, but get the error:
[Synth 8-561] range expression could not be resolved to a constant [/UnconArray.vhd&quot;:39]
I am wondering if there is a way to do this. Also, if a unconstrained array has to be defined as a constant, then what's the point?
UnconstrainedTest.vhd
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity UnconstrainedTest is
  Port ( clk  : in std_logic;
         reset: in std_logic;
         LED0 : out std_logic := '0';
         LED1 : out std_logic := '0'
        );

end UnconstrainedTest;

architecture Behavioral of UnconstrainedTest is

 component UnconArray is
 port( clk_1 : in std_logic; 
          ArraySize : in integer;
          LED_0 : out std_logic
      ); 

 end component;

begin

 A1: UnconArray port map (
                  clk_1 =&gt; clk,
                  ArraySize =&gt; 12,
                  LED_0 =&gt; LED0
                  );

 A2: UnconArray port map (
                  clk_1 =&gt; clk,
                  ArraySize =&gt; 8,
                  LED_0 =&gt; LED1
                  );
                  
end Behavioral;

The component UnconArray.vhd
begin

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity UnconArray is

--  generic (depth : integer := 2);

  Port ( clk_1     : in std_logic;
         ArraySize : in integer;
         LED_0     : out std_logic
        );
end UnconArray;

architecture Behavioral of UnconArray is

 type Array_type is array (integer range &lt;&gt;) of integer;
 signal MyUnconArray : Array_type (0 to ArraySize);
-- type Array_type is array (0 to ArraySize) of integer;
-- signal MyUnconArray : Array_type;

begin

MyUnconArray &lt;= (1, 2, 3); 

    process (clk_1)
      begin
       if rising_edge(clk_1) then   
          if ( MyUnconArray(0) = 1 )then
              LED_0 &lt;= '1';
           else
              LED_0 &lt;= '0';
           end if;
       end if;
    end process;


end Behavioral;
","You have to use a constant size for your arrays as you are writing a model of actual hardware in VHDL. The signal is like a wire on a circuit board - you can't add or remove them dynamically.
If you wanted to use this code you would have to use a generic (which is a local constant) to declare the size of the vector. You've actually already commented this out in your code but it should look this:
entity UnconArray is
    generic (
        depth : integer := 2
    );
    port ( 
        clk_1 : in std_logic;
        LED_0 : out std_logic
    );
end UnconArray;

architecture Behavioral of UnconArray is

    type Array_type is array (integer range &lt;&gt;) of integer;
    signal MyUnconArray : Array_type (0 to depth);

    ...

Then when you instantiate the component:
A1: UnconArray 
    generic map (
        depth =&gt; 2    
    )
    port map (
        clk_1 =&gt; clk,
        LED_0 =&gt; LED0
    );

However, if you don't set the depth generic to 3 you will get still get errors as you are treating it as a fixed size when you assign data. You also only use element 0 so the rest of the array will be removed during synthesis minimisation.
The point of unconstrained arrays is that you can set the size of them when declaring signals which potentially reduces the number of types you need to declare.
For example, suppose you wanted to use 2 different integer arrays in your code with a different number of elements in them. You can either declare 2 constrained array types with different sizes or 1 unconstrained array.",,,,,
Systemverilog recursion update value for next stage,"I am trying to create a recursive logic in Systemverilog but I seem to be missing the right logic to carry the output of one iteration to the next.
Here is an example of the problem:
parameter WIDTH=4;
module test_ckt #(parameter WIDTH = 4)(CK, K, Z);

input CK;
input [WIDTH-1:0] K;
output reg Z;

wire [WIDTH/2-1:0] tt;
wire [WIDTH-1:0] tempin;
assign tempin  = K;
genvar i,j;
generate
    for (j=$clog2(WIDTH); j&gt;0; j=j-1)
    begin: outer
        wire [(2**(j-1))-1:0] tt;
        for (i=(2**j)-1; i&gt;0; i=i-2)
        begin
            glitchy_ckt #(.WIDTH(1)) gckt (tempin[i:i], tempin[(i-1):i-1], tt[((i+1)/2)-1]);
        end
        // How do I save the value for the next iteration?
        wire [(2**(j-1))-1:0] tempin;
        assign outer[j].tempin = outer[j].tt;
    end
endgenerate

always @(posedge CK)
begin
    // How do I use the final output here?
    Z &lt;= tt[0];
end

endmodule

module glitchy_ckt #(parameter WIDTH = 1)(A1, B1, Z1);
input [WIDTH-1:0] A1,B1;
output Z1;
assign Z1 = ~A1[0] ^ B1[0];
endmodule

Expected topology:
                S1              S2
K3--&lt;inv&gt;--|==
           |XOR]---&lt;inv&gt;----|
K2---------|==              |
                            |==
   &lt;--gckt---&gt;              |XOR]
                            |==
K1--&lt;inv&gt;--|==              |
           |XOR]------------|
K0---------|==    &lt;-----gckt----&gt;

Example input and expected outputs:
Expected output:

A - 1010
    ----
 S1  0 0 &lt;- j=2 and i=3,1.
 S2    1 &lt;- j=1 and i=1.

Actual output:

A - 1010
    ----
 S1  0 0 &lt;- j=2 and i=3,1.
 S2    0 &lt;- j=1 and i=1. Here, because tempin is not updated, inputs are same as (j=2 &amp; i=1).

Test-bench:
`timescale 1 ps / 1 ps
`include &quot;test_ckt.v&quot;

module mytb;

reg CK;
reg [WIDTH-1:0] A;
wire Z;

test_ckt #(.WIDTH(WIDTH)) dut(.CK(CK), .K(A), .Z(Z));

always #200 CK = ~CK;
integer i;
initial begin
    $display($time, &quot;Starting simulation&quot;);
    #0 CK = 0;
    A = 4'b1010;
    #500 $finish;
end

initial begin
    //dump waveform
    $dumpfile(&quot;test_ckt.vcd&quot;);
    $dumpvars(0,dut);
end

endmodule

How do I make sure that tempin and tt get updated as I go from one stage to the next.","Your code does not have any recursion in it. You were trying to solve it using loops, but generate blocks are very limited constructs and, for example, you cannot access parameters defined in other generate iterations (but you can access variables or module instances).
So, the idea is to use a real recursive instantiation of the module. In the following implementation the module rec is the one which is instantiated recursively.  It actually builds the hierarchy from your example (I hope correctly).
Since you tagged it as system verilog, I used the system verilog syntax.
module rec#(WIDTH=1) (input logic [WIDTH-1:0]source, output logic result);
   
   if (WIDTH &lt;= 2) begin
     always_comb
       result = source; // &lt;&lt; generating the result and exiting recursion.
   end
   else begin:blk
      localparam REC_WDT = WIDTH / 2;
      logic [REC_WDT-1:0] newSource; 
   
      always_comb // &lt;&lt; calculation of your expression
        for (int i = 0; i &lt; REC_WDT; i++)
          newSource[i] = source[i*2] ^ ~source[(i*2)+1]; 
   
      rec #(REC_WDT) rec(newSource, result); // &lt;&lt; recursive instantiation with WIDTH/2
   end // else: !if(WIDTH &lt;= 2)

   initial $display(&quot;%m: W=%0d&quot;, WIDTH);  // just my testing leftover
endmodule

The module is instantiated first time from the test_ckt:
module test_ckt #(parameter WIDTH = 4)(input logic CK, input logic [WIDTH-1:0] K, output logic Z);
   logic                 result;
   rec#(WIDTH) rec(K, result); // instantiate first time )(top)
   always_ff @(posedge CK)
     Z &lt;= result;  // assign the results  
endmodule // test_ckt

And your testbench, a bit changed:
module mytb;

   reg CK;
   reg [WIDTH-1:0] A;
   wire        Z;

   test_ckt #(.WIDTH(WIDTH)) dut(.CK(CK), .K(A), .Z(Z));

   always #200 CK = ~CK;
   integer     i;
   initial begin
      $display($time, &quot;Starting simulation&quot;);
      CK = 0;
      A = 4'b1010;
      #500 
      A = 4'b1000;
      #500 $finish;
   end

   initial begin
      $monitor(&quot;Z=%b&quot;, Z);     
   end
endmodule // mytb

Use of $display/$monitor is more convenient than dumping traces for such small examples.
I did not do much testing of what I created, so there could be issues, but you can get basic ideas from it in any case. I assume it should work with any WIDTH which is power of 2.",,,,,
How to Model a delay in Verilog without # ? That can be synthesized,"I am looking to create an AND gate which gets the result after a delay of lets say 10ns an my clock is 500 ps. How will i delay the assignment without using # delays ?

I have tried to make a counter which increments but how to model it so that it only starts when my input changes. Also the input won't change till the first output is evaluated and assigned. Initial Counter is 0 and lets say delay is 3'b111 so i want the counter to go from 1 to 3'b111 and then assign it to y. Inputs are a and b to the and gate.

always@(posedge clk)begin
  if (!reset) begin y &lt;=0; counter &lt;=0; end
  else begin
   counter &lt;= counter +1'b1;
   if(counter==delay)begin
     y &lt;= a &amp; b;
     counter &lt;=0;
  end
end
","Well if your clock cycle is 500 ps then you will need to count to a higher value to reach 10ns. I rewrote your code and also added a testbench for you to try. It's kind of sloppy, I usually write vhdl and not verilog. Hope this helps.

//Module

module count_and (
    input clk,
    input reset,
    input a,
    input b,
    output reg y,
    output reg [4:0] counter
);

reg ready;

always@(posedge clk)begin
  if (!reset) begin 
    y &lt;=0; 
    counter &lt;=0; 
    ready &lt;= 0;
  end
  else if (ready == 1'b1) begin
   counter &lt;= counter +1'b1;
   if (counter==5'b10011) begin
     y &lt;= a &amp; b;
     counter &lt;=0;
     ready &lt;= 0; //turn it off after passing to y
   end
  end
 end

always @(a,b) begin
  ready &lt;= 1'b1;
 end

endmodule

    //TestBench
`timescale 1ps/1ps
module tb_count ();

reg a,b;
reg clk;
reg reset;
wire [4:0] counter;
wire y;

initial begin
clk = 1'b1;
reset = 1'b0;
a = 1'b0;
b = 1'b0;
end

always begin
reset &lt;= #50 1'b1;
clk = #250 ~clk;


a &lt;= #1000 1'b1;
b &lt;= #1000 1'b1;
end


count_and count_and_inst (
    .clk(clk),
    .reset(reset),
    .a(a),
    .b(b),
    .y(y),
    .counter(counter)
);

endmodule
",,,,,
why the LEDS remain the initial state after programming a flowing-light program while the simulation went no wrong?,"I am a FPGA beginner and recently I tried a very simple flowing-light program that went well on my computer. However, the LEDs on my Zybo remain the initial state(only the leftmost LED lights up) no matter how long I wait. I searched for the solution for a week and tried any way I can think of even borrowed another board from my friend, yet the problem just exists.

Here's my verilog code

top.v

module top(
input clk,

output [3:0] led
);
reg [23:0] cnt_reg;
reg [3:0] led_reg;

initial begin 
        cnt_reg &lt;= 0;
        led_reg &lt;= 4'b1000;
end

always @(posedge clk)begin
    if(cnt_reg == 24'h00000f)
    begin
        if(led_reg == 4'b0001)
            led_reg &lt;= 4'b1000;
        else
            led_reg &lt;= led_reg&gt;&gt;1;
     end
     else
     cnt_reg &lt;= cnt_reg + 1;
end


assign led = led_reg;

endmodule

Here's my constraint

set_property -dict { PACKAGE_PIN M14   IOSTANDARD LVCMOS33 } [get_ports { led[0] }]; #IO_L23P_T3_35 Sch=LED0
set_property -dict { PACKAGE_PIN M15   IOSTANDARD LVCMOS33 } [get_ports { led[1] }]; #IO_L23N_T3_35 Sch=LED1
set_property -dict { PACKAGE_PIN G14   IOSTANDARD LVCMOS33 } [get_ports { led[2] }]; #IO_0_35=Sch=LED2
set_property -dict { PACKAGE_PIN D18   IOSTANDARD LVCMOS33 } [get_ports { led[3] }]; #IO_L3N_T0_DQS_AD1N_35 Sch=LED3

set_property -dict { PACKAGE_PIN L16   IOSTANDARD LVCMOS33 } [get_ports { clk }]; #IO_L11P_T1_SRCC_35 Sch=sysclk


Here's my testbench

`timescale 1ns/1ps
module tb();
reg clk;
wire [3:0] led;
top U0 (.clk(clk), .led(led));
parameter Period = 10;
always begin
    clk = 1'b0;
    #(Period/2) clk=1'b1;
    #(Period/2);
end
initial begin
    clk = 1'b0;
    #1000000;
end
endmodule


And the simulation result shows below:
the simulation result

After programming my device
LEDs just remain the initial state","
  After programming my device LEDs just remain the initial state


Your LEDS do not remain in the init state because all four of them light up. In the init state you have ""1000"". Which would be one on and three off (or vice versa depending on on how they are connected).

What is happening is that you board behave just like your simulation result shows you: every clock cycle the next LED lights up. Your clock is probably around 10MHz or 100MHz so you don't see that.

To fix this you need two things:


You need to count longer. How big depends on your clock frequency so find out what it is. 
Fix your counter code. Once the counter value is reached it no longer counts. It stays at 24'h00000F. You waveform does not show that but your code is obvious. 
",,,,,
How to display decimal equivalent (0-63) on two 7-segment displays using 6 switches as bits?,"I recently did a skills test wherein the problem was described as: 
""Create a .v (verilog hdl) file that uses sw [6:1] to represent 0 to 63  in the 7-segment displays hex2 and hex1 while showing ""--"" for any number divisible by 4.""

I finished it by hardcoding (since I was under a time limit) all the values using a case statement from 0-63 taking note of those divisible by 4 to show just ""--""

Of course that isn't the optimal solution and I hate to leave a problem solved by means of hardcoding values. 

This is for a Cyclone-II FPGA (what we have in university) and am using Quartus II to compile. For the ""--"" for every number divisible by 4, I solved it by adding a conditional operator and did ""(sw % 4) == 0 ? n : ..."". I've done the hardcoding and my attempt to solve it another way by taking note of the pattern for every 16 intervals and ""shifting up"" the value of the 7-segment display to what '0000' is for that value (at 16, 10000 = h6, 17 10001 = h7, etc.):

module sk10(sw,hex1,hex2,hex3,hex0);
input [5:0] sw;
output [6:0] hex1,hex2,hex3 = 7'h7F, hex0 = 7'h7F; 

reg [6:0] hex1;

parameter h0 = 7'b0000001; 
parameter h1 = 7'b1001111;
parameter h2 = 7'b0010010; 
parameter h3 = 7'b0000110;
parameter h4 = 7'b1001100;
parameter h5 = 7'b0100100;
parameter h6 = 7'b0100000;
parameter h7 = 7'b0001111;
parameter h8 = 7'b0000000;
parameter h9 = 7'b0000100;
parameter n =  7'b1111110;

assign hex2 = (sw % 4 == 0) ? n :
                    (sw &lt; 10) ? h0 : 
                    (sw &lt; 20 &amp;&amp; sw &gt;= 10) ? h1 :
                    (sw &lt; 30 &amp;&amp; sw &gt;= 20) ? h2 :
                    (sw &lt; 40 &amp;&amp; sw &gt;= 30) ? h3 :
                    (sw &lt; 50 &amp;&amp; sw &gt;= 40) ? h4 :
                    (sw &lt; 60 &amp;&amp; sw &gt;= 50) ? h5 :
                    (sw &lt; 70 &amp;&amp; sw &gt;= 60 ) ? h6 : n;

always @ (sw)
begin
    if (sw &lt; 16) begin 
            case (sw[3:0])
            0 : hex1 = h0; 
            1 : hex1 = h1;
            2 : hex1 = h2; 
            3 : hex1 = h3;
            4 : hex1 = h4;
            5 : hex1 = h5;
            6 : hex1 = h6;
            7 : hex1 = h7;
            8 : hex1 = h8;
            9 : hex1 = h9;
            10 : hex1 = h0;
            11 : hex1 = h1;
            12 : hex1 = h2;
            13 : hex1 = h3;
            14 : hex1 = h4;
            15 : hex1 = h5;
            endcase
            end
    else if (sw &gt;= 16 &amp;&amp; sw &lt; 32) begin
            case (sw[3:0])
            0 : hex1 = h6; 
            1 : hex1 = h7;
            2 : hex1 = h8; 

... and so on for every 16 intervals until 64


It works but it is hardly optimal and I might as well have hardcoded all 64 case statements since this new, alternative code I made is longer than that. I'd like to ask for help for a better alternative than hardcoding each one or my attempt above. Any answer is much appreciated!","Since the result is for displaying, it should be acceptable to spend some clock cycles to get the result.

Check the ""double dabble"" algorithm.

Nanland site has some examples too: https://www.nandland.com/vhdl/modules/double-dabble.html",,,,,
Bitwise operation between scalar and vector,"I am struggling to find a way to apply the bitwise operator between scalar and vector e.g:

logic [7:0] vec ;
logic scal;
logic [7:0] ans;
assign ans= vec | scal; // scal extend by appending zeros.  


here only ans[0] is modified and rest a[7:1] have zeros. I need to apply the bitwise operator on the whole vec

Thanks","There are many ways to skin a rabbit. I'll open with the replication operator:

{  &lt;N&gt;  { &lt;some value&gt; } }


which replicates &lt;some value&gt; N times. So you'll need:

assign ans= vec | {8{scal}}; 
",,,,,
Understanding the Verilog Stratified Event Queue,"I'm trying to understand how the Verilog scheduling algorithm works. The below example outputs 0, xxxx and not 1010. I'm not clear why. If I do put a delay before $display, it would output 1010.

module test;
  reg [3:0] t_var;
  initial begin
    t_var &lt;= 4'b1010;
    $display(""%0t, %b"", $realtime, t_var);
  end
endmodule


Same output, 0, xxxx, for the below example:

module test;
  reg [3:0] t_var;
  wire [3:0] y;
  assign y = ~t_var;
  initial begin
    t_var = 4'b1010;
    $display(""%0t, %b, %b"", $realtime, t_var, y);
  end
endmodule


Based on the examples, it seems that nonblocking assignment and continuous assignment are both two-step processes where the RHS is evaluated at the current time step and the LHS is scheduled to happen at the next time step (if no delay is specified) or at a later time step (if a delay is specified). 

Can someone please confirm and explain to me a step-by-step flow of the algorithm below (from Clifford Cummings) as it applies to the examples above?

Thanks!

","You are correct in saying that the non-blocking assignment(NBA) and continuous  assignment(CA) act like two-step processes, because they are. The problem is what you are calling ""the next time-step"" is not an advance in time; it is an iteration of the while() loop without advancing time. This is usually referred to as a delta-step. 

When using an NBA, the LHS gets scheduled as an NBA update event, but right after that, the $display is the next active event to execute. It prints the value of y before the NBA update events have a chance to execute. As soon as you introduce a delay, the NBA has a chance to execute before advancing to the next event time.

When using a CA, you are creating a separate process that activates anytime the RHS changes it makes an assignment to the LHS in the same active region. The initial and CA are two independent processes, and the ordering between statements in the active region is non-deterministic. So whether you see the old uninitialized value of y of updated value of y is a race condition. And you will see differences between simulators depending on how they optimize this code.",,,,,
Force internal signal of a module - Verilog,"I have a verilog testbench in order to perform gate level simulation of a module. I want to inject a transient voltage at the output of specific gates inside the module but can't find a way to do it. I can insert transient voltages (like glitches) at the inputs (example below), but I need to inject on internal signals. Can anyone shed a light on the issue?

Example: glitch in a clock signal (source)

always begin: inject_clk_glitch
    #1 force clk = 1;
    #1 force clk = 0;
    #1 release clk;
end
",force DUT.internal_path.internal_signal = 1;,,,,,
How to match `an array of struct` with `arrays of signals`? (unpacked),"I have a module:

module test(
    inout logic [3:0] data [NUM],
    ...
    inout logic       anything [NUM]
);


by

struct {
  logic [3:0] data; // tri-states, can't use tri in struct
  ...
  logic       anything; 
} dut [NUM];

test test_i(
  .data     (dut.data), // should be same as [3:0] data [NUM]
  ...
  .anything (dut.anything)
);


I get: Cannot select data in dut due to dimension mismatch.

Why? What can I do to match my unpacked struct to the  modport?

There are a lot of signals, that's why I'd like to use struct instead of several logic array signals.","You can use a struct as a datatype for a wire, you just need a typedef

typedef struct {
  logic [3:0] data;
  ...
  logic       anything; 
} dut_t;
tri dut_t dut[NUM];


(See this post for a more detailed explanation)

But the bigger problem is you cannot slice an array of a struct to get an array of struct members. You can only select an element of the array, and then select a member, i.e. dut[0].data

You would have to do

typedef struct {
  logic [3:0] data[NUM];
  ...
  logic       anything[NUM]; 
} dut_t;
tri dut_t dut;


Which probably defeats the purpose of what you wanted to do. ",,,,,
Creating multiport block ram in Vivado + Verilog,"I want to do convolution in my FPGA.
I do have an array, where the image is stored, which then is clocked out to a screen via VGA.
I want to compute the convolution the moment a pixel is clocked out, such that I only need multipliers the size of the convolution kernel.

However, I don't know how I can create a block ram, such that I can access for example 9 addresses (if I was using a 3x3 convolution kernel) at the same time. Is that possible in Vivado? I am currently using the Block Ram Generator.","The best you can do is read two values from two different addresses and for that you have to use dual-ported RAM.

But most of the time you need one port for writing the video data and the second port for reading it.

To read 9 location you have to either:


Have 9 different memories
Make sure all the data is in one address and make the memory 9 times as wide.


But there is still hope.
In video you get the horizontal pixels one after another. This means that for a 3x3 convolution you can build three small 3-stage pixel pipelines from registers:



(Yes, I put some code in Vivado and use the elaborated schematic for that)

Now you have access to the data of 9 pixels at a time. You could even omit one stage but that might upset your convolution timing.

The final dampener
This looks so simple but for this you need to have access to the data of three video lines at a time. Thus ""all"" you need to do now is build a system which remember the data for two lines and once you get to line three, re-read the data from the previous two lines and put them with the data of line 3 in the little system shown above. Thus you need at least 2 independent dual-ported memory banks which can each hold one line of video data.

I know this works because I built something just like that last week. ",,,,,
"How can I fix this ""syntax error, unexpected '=' "" problem?","I was working on my homework to design the air conditioner by Verilog coding on modelsim, and it keeps failing to compile with a syntax error.

I'm using ModelSim PE Student Edition 10.4a.

module air (rst, power, cooling, dehumidification, ventilation, cl_switch, cl_button, clk, cooler, outdoor_fan, dehumidifier, ventilator, cooling_level);

input rst, power, cooling, dehumidification, ventilation, cl_switch, cl_button, clk;
output reg cooler, outdoor_fan, dehumidifier, ventilator;
output reg [2:0] cooling_level;

parameter OFF = 1'd0;
          ON = 1'd1;


And here's the error message.


  ** Error: (vlog-13069) C:/Modeltech_pe_edu_10.4a/examples/air.v(8): near ""="": syntax error, unexpected '='.
  
  ** Error: C:/Modeltech_pe_edu_10.4a/examples/air.v(8): (vlog-13205) Syntax error found in the scope following 'ON'. Is there a missing
  '::'?


air.v(8) is this

ON = 1'd1;


part.  I couldn't figure out what's wrong with my code.","If you define more then one parameter value, you should separate them with commas:

parameter OFF = 1'd0,
          ON = 1'd1;
",,,,,
Color to grayscale conversion,"Im using a C++ openCV program for first principles Algorithm development for HDL(Verilog) image object detection.  I've finally managed to get HDL version up to the point of canny detection.  In order to validate the two,  both need to have identical output.  I have found their are subtle differences that I thing are being contributed to by the openCV imread colour to grayscale conversion biasing green. The smoothed image is overall brighter in the openCV C++ method.  From looking at the rgb2gray method it appears openCV used a bias ie (RX+GY+B*Z)/3 while in HDL I have been using (R+G+B)/3 as I require it to complete Gaussian, Sobel and Canny filters.  Human visualisation is secondary and multiplication by a non-int is undesirable.

Is there a standard linear grayscale conversion for conversion or a means to override the existing method?
...

int main()
{
            int thold = 15;

            clock_t start;
            double duration;
            const int sobelX[3][3] = { {-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1} };  //Where origionally floats in python
            const int sobelY[3][3] = { {-1, -2, -1}, {0, 0, 0}, {1, 2, 1} }; //Where origionally floats in python
            const int kernel[5][5] = { {1,6,12,6,1},
                                                                                                {6,42,79,42,6},
                                                                                                                        {12,79,148,79,12},
                                                                                                                        {6,42,79,42,6},
                                                                                                                        {1,6,12,6,1} };// 1/732
            // Above normalised kernal for smoothing,  see origional python script for method 
            start = std::clock();
            int height, width, intPixel, tSx, tSy, tS, dirE, dirEE, maxDir, curPoint, contDirection, cannyImgPix, nd, tl, tm, tr, mr, br, bm, bl, ml = 0;
            int contNum = 128;
            int contPixCount = 0;
            int curContNum = 0;
            int contPlace = 0;
            int oldContPlace = 0;
            int g = 0;
            bool maxPoint;
            struct pixel {
                        int number;
                        int h;
                        int w;

            };
            std::vector&lt;pixel&gt; contourList;
            //double floatPixel = 0.0;
            int kernalCumulator = 0;
            const int mp = 3;
        //  Scalar color(0, 0, 255);
            //          duration = ((clock()) - start) / (double)CLOCKS_PER_SEC;
            //          start = clock();
            //          cout &lt;&lt; ""Start image in"" &lt;&lt; duration &lt;&lt; '\n';
            //          Mat dst;
            Mat rawImg = imread(""C:\\Users\\&amp;&amp;&amp;\\Documents\\pycode\\paddedGS.png"",0);
            printf(""%d"",rawImg.type());

//          Mat rawImg = imread(""C:\\Users\\&amp;&amp;&amp;\\Documents\\openCV_Master\\openCVexample\\openCVexample\\brace200.jpg "", 0);
            height = rawImg.rows;
            width = rawImg.cols;
            cout &lt;&lt; ""Height of image "" &lt;&lt; height &lt;&lt; '\n';
            cout &lt;&lt; ""Width of image "" &lt;&lt; width &lt;&lt; '\n';
            Mat filteredImg = Mat::zeros(height, width, CV_8U);
            printf(""%d"", filteredImg.type());
            Mat sobelImg = Mat::zeros(height, width, CV_8U);
            Mat directionImg = Mat::zeros(height, width, CV_8U);
            Mat cannyImg = Mat::zeros(height, width, CV_8U);
            Mat contourImg = Mat::zeros(height, width, CV_16U);

//          rawImg.convertTo(rawImg, CV_8UC1);

            duration = ((clock()) - start) / (double)CLOCKS_PER_SEC;
            start = clock();
            cout &lt;&lt; ""Start image in"" &lt;&lt; duration &lt;&lt; '\n';
            // Loop to threshold already grayscaled image           
            /*
            for (int h = 0; h &lt; (height); h++)
            {
                        for (int w = 0; w &lt; (width); w++)
                        {
                                    g = (int)rawImg.at&lt;uchar&gt;(h, w,0);
                                    cout &lt;&lt; g &lt;&lt; ""g"";
                                    g+= (int)rawImg.at&lt;uchar&gt;(h, w, 1);
                                    cout &lt;&lt; g &lt;&lt; ""g"";
                                    g+= (int)rawImg.at&lt;uchar&gt;(h, w, 2);
                                    cout &lt;&lt; g &lt;&lt; ""g"";
                                    g = g/3;
                                    rawGImg.at&lt;uchar&gt;(h,w) = g;
                        }
            }

            */
            //          imshow(""thresholded Image"", rawImg);
            //          waitKey();
            // Loop to smooth using Gausian 5 x 5 kernal

//          imshow(""raw Image"", rawImg);


            for (int h = 3; h &lt; (height - 3); h++)
            {
                        for (int w = 3; w &lt; (width - 3); w++)
                        {
                                    if (rawImg.at&lt;uchar&gt;(h, w) &gt;=6 )//Thresholding included
                                    {
                                                for (int xk = 0; xk &lt; 5; xk++)
                                                {
                                                            for (int yk = 0; yk &lt; 5; yk++)
                                                            {
                                                                        intPixel = rawImg.at&lt;uchar&gt;((h + (xk - mp)), (w + (yk - mp)));
                                                                        kernalCumulator += intPixel*(kernel[xk][yk]);//Mutiplier required as rounding is making number go above 255,  better solution?
                                                            }
                                                }
                                    }
                                    else
                                                kernalCumulator = 0;

                                    kernalCumulator = kernalCumulator / 732;
                                    if (kernalCumulator &lt; 0 || kernalCumulator &gt; 255)
                                    {
        //                                      cout &lt;&lt; ""kernal Value: "" &lt;&lt; kernalCumulator;
            //                                  cout &lt;&lt; "" intPixel:"" &lt;&lt; intPixel &lt;&lt; '\n';
                                    }
                                    filteredImg.at&lt;uchar&gt;(h, w) = (uchar)kernalCumulator;
                                    kernalCumulator = 0;
                        }
            }
","Our vision does not perceive linearly the brightness, so it makes sense for usual applications to use some sort of transformation that tries to mimic the human perception.

For your application, you have 2 options: either use a similar transformation in HDL (which might not be easy or desired), or make a custom rgb to grayscale for OpenCV which uses the same transformation you use.

A short snippet (more like pseudocode, you'll have to figure out the details) for this would be something like:

cv::Mat linearRgbToGray(const cv::Mat &amp;color) {
    cv::Mat gray(color.size(), CV_8UC1);
    for (int i = 0; i &lt; color.rows; i++)
        for (int j = 0; j &lt; color.cols; j++)
           gray.at(i, j) = (color.at(i, j)[0] + color.at(i, j)[1] + color.at(i, j)[2]) / 3;
}
",,,,,
Python regex to catch Verilog port names,"I have some output port statements in verilog text file as shown below and I want to capture Just port names.

Example sample:

output Y;
output Y1,Y2,Y3;
output Z;
output Q, QN;


Expected output I want is a list with output port names

(Y)
(Y1, Y2, Y3)
(Z)
(Q,QN)


I tried below code but it doesn't give me the list quite I want.

outputPortListPattern=re.compile(r'^\s*(output)\s+(.*);',flags=re.M)
with open(fileA) as fh_in:
    with open(fileB, ""w"") as fh_out:
        for line in fh_in:
            match=outputPortListPattern.match(line)
            if match:
                matchlist = match.group(2)
                print(""Output port list={}"".format(matchlist))
","If it is a list of port names you want, then:

import re

text = """"""output Y;
output Y1,Y2,Y3;
output Z;
output Q, QN;""""""

[re.split(r',\s*', m.group(1))
    for m in re.finditer(r'^output\s+(([^,;]+)(\s*,([^,;]+))*);$', text, flags=re.M)
]


Prints:

[['Y'], ['Y1', 'Y2', 'Y3'], ['Z'], ['Q', 'QN']]
",,,,,
VHDL integers counting all over the place when incremented or decremented,"I've written a simple VHDL clock-gated process containing two variables, an integer counting up (counter_up) and an integer counting down (counter_down), tied to an LED output each.

The goal of this test system is to simply have the outputs asserted whenever the counters reach a target value from a set starting value. counter_up starts at 10 and outputs its LED at 20. counter_down starts at 25 and outputs its LED at 5. These will continue to count and over/under flow respectively. Both counters range from 0 to 31 (5 bits).

The 'counting all over the place' happens when I test this on modelsim with a simulated clock as shown below:



The counters do give an output after 10 and 20 steps respectively, but nothing along the way seems to make any sense and I'm not sure how it would behave if I were to try any arithmetic on the counter values (eg. with the numeric_std library). 

What is the cause of this issue and is it possible to force them to be simulated with expected values?

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;

ENTITY test IS PORT(

    clk: IN STD_LOGIC;
    led_1,led_2: OUT STD_LOGIC
    );
END;

ARCHITECTURE arch_test OF test IS

BEGIN
    PROCESS(clk)
        VARIABLE counter_up: INTEGER RANGE 0 TO 31 := 10;
        VARIABLE counter_down: INTEGER RANGE 0 TO 31 := 25;
    BEGIN
        IF clk'EVENT AND clk = '1' THEN

            counter_up := counter_up + 1;

            IF counter_up = 20 THEN
                led_1 &lt;= '1';
            ELSE
                led_1 &lt;= '0';
            END IF;

            counter_down := counter_down - 1;

            IF counter_down = 5 THEN
                led_2 &lt;= '1';
            ELSE
                led_2 &lt;= '0';
            END IF;

        END IF;
    END PROCESS;
END;
","They're not exactly all over the place, note that if you invert counter_up bits 1, 3 and 4 you'll get a perfect sequence of incremental values and something similar seemingly happens with counter_down. It's as if the tool interpreted a constrained range of integers as an enumeration and then decided to encode it on this weird pattern, but like @Brian said, this is not something a simulator would do, so I'm guessing this is likely a post synth simulation.

Try using unsigned(4 downto 0) instead of integers, you'll need to change the initial value of conter_up and counter_down to to_unsigned(10, 5) and to_unsigned(25, 5) respectively.",,,,,
Efficient way to loop letters through 7-seg LEDs,"I'm trying to scroll through the words 'Happy Bday' on four 7-seg LEDs on my FPGA board. On each cycle, the words would move left by one letter. I've been able to do this so far by defining a state for each combination and just cycling through the states. I'm wondering if there is a better way to do this, since if I ever wanted to scroll through many more words, I would have to have a lot of states.

module bday (
    input rst_b, clk, start,
    output logic [6:0] led [3:0]
);
    logic clk_d;
    logic [25:0] count;
    state_t state; // state enum

    always @(posedge clk) begin
       count &lt;= count + 1;
       if (count == 10000000)
       begin
          count &lt;= '0;
          clk_d &lt;= !clk_d; // divide clock down from 50MHz source
       end
    end

    always_ff @ (posedge clk_d, negedge rst_b)
    begin
        if (!rst_b)
        begin
            state &lt;= S_idle;
            for (int i = 0; i &lt; 4; i++) led[i] &lt;= '1;
        end
        else // letters below are 7-bit parameters to light up the 7-seg LED correctly
            case (state)
                S_idle : if (start) state &lt;= S_1; else state &lt;= S_idle;
                S_1 : begin state &lt;= S_2; led[0] = H; led[1] = A; led[2] = P; led[3] = P; end
                S_2 : begin state &lt;= S_3; led[0] = A; led[1] = P; led[2] = P; led[3] = Y; end
                S_3 : begin state &lt;= S_4; led[0] = P; led[1] = P; led[2] = Y; led[3] = BLANK; end 
                S_4 : begin state &lt;= S_5; led[0] = P; led[1] = Y; led[2] = BLANK; led[3] = B; end
                S_5 : begin state &lt;= S_6; led[0] = Y; led[1] = BLANK; led[2] = B; led[3] = D; end
                S_6 : begin state &lt;= S_7; led[0] = BLANK; led[1] = B; led[2] = D; led[3] = A; end
                S_7 : begin state &lt;= S_8; led[0] = B; led[1] = D; led[2] = A; led[3] = Y; end
                S_8 : begin state &lt;= S_9; led[0] = D; led[1] = A; led[2] = Y; led[3] = BLANK; end
                S_9 : begin state &lt;= S_10; led[0] = A; led[1] = Y; led[2] = BLANK; led[3] = H; end
                S_10 : begin state &lt;= S_11; led[0] = Y; led[1] = BLANK; led[2] = H; led[3] = A; end
                S_11 : begin state &lt;= S_1; led[0] = BLANK; led[1] = H; led[2] = A; led[3] = P; end
                default : state &lt;= S_idle;
            endcase
    end
endmodule
","Two things you can do. 

Separate the scrolling behavior from the message you want to display

always_ff @ (posedge clk_d, negedge rst_b)
        if (!rst_b)
            for (int i = 0; i &lt; 3; i++) led[i] &lt;= '1;
        else
            for (int i = 0; i &lt; 3; i++) led[i] &lt;= led[i+1];


Then use an array and a counter to pick the letters from your message

parameter logic [6:0] message[15] = {H,A,P,P,Y,BLANK,B,I,R,T,H,D,A,Y,BLANK};
logic [7:0] counter;
always_ff @ (posedge clk_d, negedge rst_b)
        if (!rst_b)
        begin
            counter &lt;=0;
            led[3] &lt;= '1;
        end
        else
            led[3] &lt;= message[counter];
            if (counter &lt; 15) 
               counter &lt;= counter+1;
            else
               counter &lt;= 0;
",,,,,
SystemVerilog/Verilator WIDTH parameter and case structure indexing out of bounds,"I'm currently implementing a PRNG in SystemVerilog using an LFSR as described here. The width should be variable using a parameter. I reach a construct of:

module PRNG
#(
    parameter WIDTH = 32,
    parameter SEED = 1
)
(
    input clk,
    input update,
    output reg [WIDTH-1:0] prng
);

reg [WIDTH-1:0] lastRng = WIDTH'(SEED);

always_comb begin
    var tap;

    case (WIDTH)
        default: tap = 0;
        3: tap = lastRng[2] ^~ lastRng[1];
        [...]
        168: tap = lastRng[167] ^~ lastRng[165] ^~ lastRng[152] ^~ lastRng[150];
    endcase

    if (update) begin
        prng = {lastRng[WIDTH-2:0], tap};
    end else begin
        prng = lastRng;
    end
end

always_ff @(posedge clk) begin
    lastRng &lt;= prng;
end

endmodule


Now, while simulating this module using Verilator it complains of selection indices out of range for every case &gt; WIDTH-1, even though (I think that) these cases should clearly be optimized out, since WIDTH is a constant:

Selection index out of range: 167:167 outside 31:0


Is there a simple way around this error, without eg. bit shifting logic just to index the nth bit?","To do this, you need to use a generate.

Try this


Move the case statement block outside of the always_comb (you can't use generate in an always block, someone correct me if that does not stand for always_comb
Change the tap = statements to be assign tap =.
(optional) Surround the case block with generate/endgenerate. This isn't required but you might find it helps readability.
",,,,,
Giving User-Defined properties for a signal,"Disclaimer: I'm not super familiar with Scala. I have used Spinal/Chisel some to test out what I want to do, as well as create some simple HW, so please forgive me if these questions are ""entry-level"" from a Scala perspective.

I'm planning to use SpinalHDL for some connection automation. We have a bunch of IP that we can't/won't convert to SpinalHDL and much of it is mixed-signal. Because of this, I have some situations where additional signal information would allow me to further automate the design process. As an example, there are cases where some signals are on various power domains and their connections either need to be limited to said specific power domain or we would have to insert some logic like a level shifter.

Let's say I have a bundle of signals for some IP (this Bundle is on one of my BlackBoxes)

class MyBundle extends Bundle{
  val data     = in UInt(8 bits)
  val valid    = in Bool
  val pwr800mV = in Bool
  val pwr1800mv= in Bool
  val gnd      = in Bool
}


MyBundle is on a BlackBox, and I instantiate several of these in a Component. My idea is to be able to walk through the IOs/Signals in the Bundle and connect them to the appropriate higher level power/ground signal. Example:

class PwrSignal(v : Double = 1.8) extends Bool{
  val voltage = v
}
class MyBundle extends Bundle{
  val data     = in UInt(8 bits)
  val valid    = in Bool
  val pwr800mV = in PwrSignal(0.8)
  val pwr1800mv= in PwrSignal(1.8)
  val gnd      = in Bool
}

class MyComponent extends Component{
  //IO creation
  //pseudo...
  walkBundleSignals{
    if (signal.voltage == 1.8){ signal := top_level_power_1p8v}
  }
}


At first I tried to create a PwrSignal class that extends Bool, however this fails since PwrSignal is not a part of spinal.core.in. 

Is there anyway to go about doing this? 

Thanks","Derp Alert: Since the default data types override the constructor, you just need to ""new"" the user defined data type.

class PwrSignal(v : Double = 1.8) extends Bool{
  val voltage = v
}
class MyBundle extends Bundle{
  val data     = in UInt(8 bits)
  val valid    = in Bool
  val pwr800mV = in (new PwrSignal(0.8))
  val pwr1800mv= in (new PwrSignal(1.8))
  val gnd      = in Bool
}
",,,,,
Newbie question: VHDL best practice/Efficiency,"I have recently started to teach myself VHDL. Being an embedded systems programmer the language itself and its constructs are not much of a problem. My problem is the development of the intuitive knowledge how my code is mapped onto the silicon. When I write C code for an embedded processor I have a fairly good idea how the code gets translated (compiled) and how it is run within the processor. This is what I want to develop for my VHDL authoring.
I am reading sample programs (which I found is usually not a good idea as it only shows you what can be done, not necessarily how things should be done)

I hereby present a snippet of an example program and the same snippet after my C-brain has moulded it into something which I can be better understand.

My questions are; ""Does what I did translate into a more or a less efficient implementation on silicon. Did I or did I not violate best practices.""

Example

    -- Create a delay pulse of 16us when a key is pressed
    PROCESS( clk, rst )
    BEGIN
        IF( NOT rst = '1' ) THEN
            cnt_delay &lt;= ""00000000000000000000"";
            start_delaycnt &lt;= '0';
        ELSIF( clk'EVENT AND clk='1' ) THEN
            IF( start_delaycnt = '1' ) THEN
                IF (cnt_delay /= ""11000011010100000000"") THEN   -- 800.000 -&gt; cnt_delay pulse is 16us long
                    cnt_delay &lt;= cnt_delay + ""00000000000000000001"";
                ELSE
                    cnt_delay &lt;= ""00000000000000000000"";
                    start_delaycnt &lt;= '0';
                END IF;
            ELSE
                IF( (NOT key_input='1') AND (cnt_delay = ""00000000000000000000"") ) THEN
                    start_delaycnt &lt;= '1';
                END IF;
            END IF;
        END IF;
    END PROCESS;


My attempt:

    -- Create a delay pulse of 16us when a key is pressed
    PROCESS( clk, rst )
    BEGIN
        -- in reset -&gt; reset our output signal and reset the counter
        IF( NOT rst = '1' ) THEN
            cnt_delay &lt;= ""00000000000000000000"";
            start_delaycnt &lt;= '0';
-- Edit Fixed bug. Cannot invert EVENT attribute
--      -- No clock transition -&gt; do nothing
--      ELSIF( NOT( clk'EVENT AND clk='1' ) ) THEN

--      -- Key pressed and not currently in a delay -&gt; start the delay
--      ELSIF( (NOT key_input='1') AND (start_delaycnt = '0') ) THEN

        -- On positive clock edge -&gt; do work
        ELSIF( clk'EVENT AND clk='1' ) THEN

            -- Key pressed and not currently in a delay -&gt; start the delay
            IF( (NOT key_input='1') AND (start_delaycnt = '0') ) THEN

            start_delaycnt &lt;= '1';

        -- If we are currently in a delay and we have not reached the end it yet -&gt; increase the counter
        ELSIF( (start_delaycnt = '1') AND (cnt_delay /= ""11000011010100000000"") ) THEN  -- 800.000 -&gt; cnt_delay pulse is 16ms long
            cnt_delay &lt;= cnt_delay + ""00000000000000000001"";

        -- If we are currently in a delay and we have reached the end -&gt; reset our output signal and reset the counter
        ELSIF( start_delaycnt = '1' ) THEN
            cnt_delay &lt;= ""00000000000000000000"";
            start_delaycnt &lt;= '0';
        END IF;

        END IF;

    END PROCESS;


I know a string of elsifs is not quite ideal, but as I said I am still learning VHDL and I need to get a bit better acquainted with the constructs to get rid of these eyesores. However maybe this is the most efficient/best practice way.

I am looking forward to any critique of this snippets.

Thank you in advance for taking the time to read and respond.

edit: Fixed calculation mistake. The delay is 16us not 16ms.
2nd edit: Fixed bug. Cannot invert EVENT attribute.

Addendum:
This was my first question on stack overflow and I noticed that it has been down voted quite heavily. Can someone tell me what I did wrong so I can avoid it in future questions.

Ok, ok. Just read Good subjective, Bad subjective and I realise I should have posed the question somewhere else. How do I close this question?","Think of a clocked PROCESS as a Central PROCESSing Unit. Now replace ""Central"" with ""Distributed Parallel"", i.e. akin to multiple parallel cores.

In the example you gave, the delay is implemented by counting clock cycles (800 in this case).

The conditional test IF (clk'EVENT AND clk='1') creates a positive edge detection circuit in the silicon. In this case it looks for rising edges of the clk signal. Then you need to decide what to do on those rising edges to implement your clocked process.

Note: Negative edge detection is implemented by IF (clk'EVENT AND clk='0')",,,,,
Could not locate C:\Xilinx\xic\bin\xic.bat,"I used Xilinx to install Vivado, for a college project, but then after uninstalling it I was unable to get rid of this error that pops up every time I start my laptop. Has anyone else been in this situation?


This is how it looks","It's most likely in the 'Startup' folder of your start menu. Start Task Manager and click on the Startup tab and disable it from there, or delete it from your profile directory in C:\Users\&lt;username&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup.",,,,,
Variable length register slices in Verilog,"I need to concatenate a register, and a variable-length part of another. I have register offset which counts how many bits of the variable-length register I need. 

I would like to do something like this:

A &lt;= {B[offset:0], A};

However, this is a compilation error. 
I could write a mux that chooses different assignment for A, for different values of offset: i.e:

if (offset == 1) 
   A &lt;= {B[1:0], A};
else if (offset == 2)
   A &lt;= {B[2:0], A};


etc. This is cumbersome, ugly and not extensible for new values of offset. Are there any better ideas?

Thank you","Use a mask

A &lt;= { B &amp; (2**(offset+1)-1)}


Note that in your example, A&lt;= {whatever,A} will always be just A.",,,,,
Verilog module parameters in seperate config file?,"The Lattice FPGA I am using has embedded RAMs, which can be preloaded with data through the configuration binary.

The predefined Verilog modules for these RAMs implement this by providing Parameters named INIT_0 , INIT_1 , INIT_2 , ... , each a 256-bit value, to do this.

So my code to instantiate the RAM looks like this:

        SB_RAM40_4KNRNW #(
                .INIT_0(256'h00000FA00BB807D003E859E905E2F529486300000000000059E099E3404219E2),
                .INIT_1(256'h0123456701234567012345670123456701234567012345670123456701234567),
                .READ_MODE(0) ,
                .WRITE_MODE(0)
        ) buf0L
        (
                .RDATA(readline0[15:0]),
                .RADDR({3'b0,RAMadr[7:0]}),
                ......
        );



While it works, I would like to pull in the data from some other file as it is generated by other programs in the make process. Modifying the .v file in the build is not nice as it is git-tracked.

Is there a way to pull in module parameters from another file or some other way to feed them into the compiler?

Currently I generate the data, paste it into the .v source, and then build and load it. It works for now but is not nice.

Of course, there are several instances of this SB_RAM40_4KNRNW module. The device has 30 of them.

(I am using the open-source tools yosys/nextpnr/icepack)

Thanks for your help!","
  Is there a way to pull in module parameters from another file or some other way to feed them into the compiler?


Variations on `include, param, localparam  is what I think you want.
To give an example: Assume data can be generated on the following form:

// Generated from an assembler or whatever
localparam prg0 = 256'hdeadbeef;
localparam prg1 = 256'h0;
// etc ...


and written to the file from_other_programs.hv. Assume the following test program in a  git-traced file:

module top
  (
   input         clk,
   input [7:0]   RAMadr,
   output [15:0] readline0
   );
`include ""from_other_programs.hv""

   SB_RAM40_4KNRNW #(.INIT_0(prg0), .INIT_1(prg1),
                     .READ_MODE(0),.WRITE_MODE(0)
                     ) buf0L
     (  .RDATA(readline0[15:0]),
        .RADDR({3'b0,RAMadr[7:0]}));
endmodule


This is but one of possible variations on this theme.",,,,,
verilog sync issue with counter,"i'm trying to create a 8 bit parallel to serial component that send the data and bit number.
the bit number and the transmitted serial data is not sent at the right time, 
please see wave form

module counter
(
input clk,rst,
input [7:0]data,
output reg [7:0]cnt,
output reg data_Tx
);

parameter lim = 7;


always @(posedge clk or negedge rst)
if (!rst)
begin
    cnt &lt;= 0;
    data_Tx &lt;= 1'b1;
end

else
begin
    if (clk)
    begin
    if (cnt &lt; lim)
    begin
        data_Tx &lt;= data[cnt];
        cnt &lt;= cnt +1;
    end
    else
        cnt &lt;= 0;
    end
end

endmodule


please see wave form here

i have marked on the waveform (in blue) the bit numbers that supposed to be transmitted, as you can see they are shifted.

also, in red circle, the data_Tx needs to be '0' when transmitting the first bit from the parallel inputs, but i'ts '1'because of the rst line, how can i fix this situation? 

should i use a state machine???

thank you","You have fallen into the standard trap all beginners with HDL have: your signals change after the clock edge. Take a few months of coding and dealing with this becomes second nature. 

But before I deal with that: follow Greg's advice and remove the if (clk) from the code.

The first, simple solution, is to move the data_Tx &lt;= data[cnt]; outside the clocked section:

assign data_Tx = data[cnt];


But beware that makes that after a reset (when cnt is zero) the data_Tx bit reflects your data[0] bit. So there is no guarantee that it is 1. Also it will change as soon as a new value is assigned to data.

If you want a synchronous data_Tx output and want the cnt to be inline you have to delay your cnt by a clock cycle:

....
reg [2:0] early_cnt;
always @(posedge clk or negedge rst)
if (!rst)
begin
    cnt &lt;= 0;
    early_cnt &lt;= 8'h00;
    data_Tx &lt;= 1'b1;
end
else
begin
    cnt  &lt;= early_cnt;
    if (early_cnt &lt; lim)
    begin
        data_Tx &lt;= data[early_cnt];
        early_cnt &lt;= early_cnt + 8'h01;
    end
    else
        early_cnt &lt;= 0;
end
",,,,,
most optimal way to implement special function registers in Systemverilog,"I am implementing my Special Function Registers using structures, I can choose between packed structures and unpacked structures, the advantage of the packed structures is that they allow me to be able to treat my structure as a vector, but the downside is that from a synthesis point of view, unpacked structures are better, because ""synthesis compilers might be able to optimize unpacked structures better than packed structures"".

I am wondering if it would make sense to use unpacked structures at all, even for the above synthesis considerations.

Thanks.

Quote from the book ""RTL modeling with SystemVerilog"", Stuart Sutherland.","It's not the packed or unpacked declaration that matters, it the operations you wind up performing on the structures. If you write the exact same code using packed or unpacked, it won't matter to synthesis. But like you say, if you want to perform bitwise operations like xor on the entire struct, than it becomes more difficult using an unpacked struct. ",,,,,
Verilog - Shifting a register,"I'm trying to write a parameter dependant FIFO using verilog. 

To be specific, it depends on a word width M and queue length N.
I've started with implementing a 1 bit wide fifo.

I'm having trouble debugging it at the moment (which is the reason it's a bit messy, apologies!), when the main issue arises from dealing with the register bit_list.

while implementing this register I wish to shift it in order to pop out the value in bit_list[N-1], along with moving the rest of the register 1 bit towards N-1. 

Unfortunately my implementation does not work and results with the errors: 
""Memory or an array reference requires an index [3.8][4.2.2(IEEE)]"", along with 
""&lt;&lt; (left shift) operator left operand type illegal""
both in regards to the lines

bit_list=bit_list&lt;&lt;1;


(side comment: the first error also appeared regarding my commented ""else"" lines - before I commented them of course)

My code:

module single_fifo(clk,reset,in_bit,push,pop,out_bit,full);
   parameter N=4; // determines the maximum number of words in queue.
   input clk, reset, push, pop;
   input in_bit;
   output out_bit;

   reg bit_list [N-1:0];
   reg [N-1:0] n; 
   reg out_bit;
   output full;
   reg full;

   always @(posedge clk) 
   begin
    if (reset==1) begin
        n=0;
        bit_list=0;

    end
    else begin //reset==0
        if (n==0) begin             //n=0
            if (push==1) begin
                bit_list[N-1-n]=in_bit;
                n=n+1;
            end
            //else //push==0
            //  bit_list=bit_list;
        end else if ((n&gt;0) &amp;&amp; (n&lt;N)) begin  //0&lt;n&lt;N
            if (pop==1) begin
                bit_list=bit_list&lt;&lt;1; //SHIFT DIREDCTION MIGHT BE FLIPPED
                n=n-1;
            end
            //else //pop==0
            //  bit_list=bit_list;

            if (push==1) begin
                bit_list[N-1-n]=in_bit;
                n=n+1;
            end
            //else //push==0
            //  bit_list=bit_list;
        end else begin              //n==N
            if (pop==1) begin
                bit_list=bit_list&lt;&lt;1; //SHIFT DIREDCTION MIGHT BE FLIPPED
                n=n-1;
                if (push==1) begin
                    bit_list[N-1-n]=in_bit;
                    n=n+1;
                end
            //  else //push==0
            //      bit_list=bit_list;
            end
            //else //pop==0
            //  bit_list=bit_list;
        end     
    end //reset==0

    if (n==N)
        full=1;
    else //n&lt;N
        full=0;
    out_bit=bit_list[N-1];


    end
endmodule


As you might be able to tell I'm quite new to verilog, so sorry if this question seems noobish. Help will be greatly appriciated!","You approach is rather unorthodox.

The most common and easy way to make a FIFO is using a memory, a read and a write pointer. 

Most obvious deficiencies: 


In your code you start to look at 'push' but ignore that at the same time there could be a 'pop'.
On a 'pop' you shift the list one location but you need N cycles for it to fall trough. 
You probably need some 'data valid' flag which each FIFO entry.
You have a 'full' status but no 'empty' status. A receiver would not know when it can start reading 
I see no protection against writing to a full FIFO or reading from an empty one.
This bit_list=bit_list&lt;&lt;1; will not work when you have wider data. You need a for-loop. 


It is probably not what you want to hear, but I would recommend you abandon this approach and have a look at an existing FIFO with read and write pointers

Besides all that you should use non-blocking assignments in you @(posedge clk) section.",,,,,
"Verilog: Always statement, trigger on positive edge for 3 bit variable","My project is to use a CPDL, which I am programming in verilog to commutate a BLDC motor. Part of that process is to read in hall sensors A,B,C. 

I want to count the amount of positive edges on A,B or C. I have a 3 bit variable [2:0] hallIn to store these inputs. The code below works in a modelsim simulation but not on an actual chip. How come? What is the proper way to do this? The error message I get is: 73:12:73:55|Can't mix posedge/negedge use with plain signal references

always @ (posedge hallIn[2] or hallIn[1] or hallIn[0])
","Synthesize code is a subset of what Verilog will let you do. Synthesizable code requires a coding structure that can be mapped to logic cells. Non-synthesizable code is intended for behavior modeling and test benches. 

Flip-flops should normally be synchronized by a common clock source; not data.  With a clock, you could detect the posedge data by comparing the inputs current value against it previous value.

Example:

assign posedge_detected = |(hallIn &amp; ~prev_hallIn);

always @(posedge clock) begin
  if (reset) begin
    prev_hallIn &lt;= 3'b000;
    count &lt;= 16'h0000;
  end
  else begin
    prev_hallIn &lt;= hallIn;
    count &lt;= count + posedge_detected;
    end
  end
end
",,,,,
Verilog - Getting a mismatch error trying to replicate output of another module,"I'm trying to design a fifo that accepts a maximum of N=4 words and has a M=2 bit width of each word.
I first designed a 1 bit width word fifo and I'm trying to use it for the wider one. I'm having an issue debugging the line 

single_fifo fArr[M-1:0]({M*{clk}},{M*{reset}},in,{M*{push}},{M*{pop}},out,full_string);


While getting the following error:


  ncelab: *E,PCAVDM (./fifo.v,85|27): Vector length of port connection expression (32) in array of instances does not match product of number of instances (2) and port length (1).
     single_fifo fArrM-1:0;


My code has nothing that's 32 bits long so I'm quite confused by this error.

My code:

 module fifo(clk, reset, in, push, pop, out, full);
   parameter N=4; // determines the maximum number of words in queue.
   parameter M=2; // determines the bit-width of each word, stored in the queue.

   input clk, reset, push, pop;
   input [M-1:0] in;
   output [M-1:0] out;

   wire [M-1:0] full_string;
   output full;
   wire full;

   single_fifo fArr[M-1:0]({M*{clk}},{M*{reset}},in,{M*{push}},{M*{pop}},out,full_string);

   assign full=|full_string;

endmodule



I'll also add the list of ports for single_fifo in case it's required:

module single_fifo(clk,reset,in_bit,push,pop,out_bit,full);
   parameter N=4; // determines the maximum number of words in queue.
   input clk, reset, push, pop;
   input in_bit;
   output out_bit;

   reg [N-1:0] bit_list;
   reg [N-1:0] n; 
   reg out_bit;
   output full;
   reg full;


Sorry if my question seems noobish, I'm still new to verilog. Help will be appriciated!","Although you probably meant to use replication {M{clk}} instead of multiplication {M*{clk}}, there is no need for any of this with an array of instances. Verilog automatically replicates the signals you connect to an array of instances so you can just write

single_fifo fArr[M-1:0](clk,reset,in,push,pop,out,full_string);


P.S. I should know because I was responsible for added this feature to Verilog way back in 1990. 
See section 23.3.3.5 Unpacked array ports and arrays of instances in the IEEE 1800-2017 LRM",,,,,
Verilog execution parallel or sequential if block along with another statement,"The following is a verilog code
I'm trying to understand the working of statements inside an always block.
I know the rule that blocking statements are written using = and non blocking use &lt;= in verilog.I know the working of these.

What will happen if an if statement(with blocking statements) come in between blocking statements?

always(@posedge clk)
begin
  if(en1)
  begin
      out1=c;   //statement 1
      out2=c+1; //statement 2
      if(out2&gt;5)
      begin
      out3=out1+out2;//statement 3
      end
      else
      out3=0;
      out4=out1-out2;
  end
end


The 'if statement' was synthesized into a multiplexer. Will it use the values updated in the previous statement1  ???Requirement is -The output should be such that the three statements were executed sequentially.

But when this is implemented in hardware the mux for ' if ' will be separate from the other adders.So I thought the if statement3 in between will work in parallel with statement 1 and 3. 

I checked in simulation and the value taken is the latest value-ie as if it works sequentially.

My questions are
1.Is it correct to use 'if statements' in between other assignments. 
   or should I use another method of programming.Will it run sequentially when blocking statements are used?
2.Will this work in all conditions as if sequentially? ","The story here is very simple. In simulation all statements inside an always block are always executed sequentially, as in any programming language. The if statement will be executed after the assignment, as in the order given below. 

  1&gt; out1=c;   //statement 1
  2&gt; out2=c+1; //statement 2
  3&gt; if(out2&gt;5)
       begin
  3a&gt;      out3=out1+out2;//statement 3
     end
     else
  3b&gt;     out3=0;
  4&gt; out4=out1-out2;


The above will work as in any generic programming language. The if will be taken if out1 &gt; 5.

The confusion is in in the blocking/non-blocking assignments. Verilog has a very special semantic for the &lt;=, non-blocking assignment. Actually it is just a simulation artifact. It means that the rhs value will not be assigned to the lhs inside this particular always block. It will be done later, after all always blocks are evaluated.

So, consider the following:

  out1=c;   //statement 1
  out2 &lt;= c+1; //&lt;&lt;&lt;&lt; non blocking, assignment here, statement 2
  if(out2&gt;5)
       begin


Now, if c is 4 and the result of the rhs c+1 is 5, the if statement will still be taken, because out2 is not yet updated in this block. It will still have the previous value of 4. But the value of 5 will be assigned to it at the very end, after all the statements are evaluated. It will not be seen by the if statement till the next posedge of your clock.


  1.Is it correct to use 'if statements' in between other assignments. or should I use another method of programming.Will it run sequentially when blocking statements are used?


it depend on what you are trying to achieve here. Could be correct or not


  
  Will this work in all conditions as if sequentially?
  


As i explained above. You have to understand one thing though. Verilog is not a hardware description language. It is a language for describing desired behavior of hardware and gets interpreted by synthesis tools. Therefore you can run into a situation when your simulation results will not match behavior of the synthesized schematic. To minimize this possibility you should use verilog programming practices accepted in the industry. One of them: use non-blocking assignments for the real outputs of the edge-controlled blocks. There are compelling reasons for doing so. From this perspective your example is completely wrong. ",,,,,
how to optimize (reduce) the latency in the verilog HDL code (hardware) generated by the MATLAB HDL CODER add-on from a given Simulink model?,"Thanks in advance,

I am having a simple Simulink model, that takes in a 32-bit number in the IEEE-754 format and adds the same number, which gives the output again in the 32-bit wide IEEE-754 format. I used MATLAB's HDL CODER add-on and generated the Verilog HDL code for the same. When I wrote a testbench for the same, I found the latency I get from this code is 100ns. But is there a way I can reduce this to even further, say some 10ns.

Below I am attaching the Simulink model I used to generate the Verilog HDL code, along with the generated Verilog files. Also, I am attaching a screenshot of the simulation in case you don't want to waste your time running the scripts



Link to download the files","
  my point is how to use pipeline settings before conversion


I am assuming that ""pipeline settings"" is a MATLAB HDL generator parameter.

Basically what you do is ""try"": use a pipeline setting and synthesize the code. If you have slack you can:


Reduce the number of pipeline stages. 

or 
Increase the clock frequency.


(For negative slack you use the inverse methods) 

Now here is where things get tricky:
Most of the time you can't really speed things up. A certain functionality needs a time to calculate. Some algorithms can be sped up by using more parallel resources but only up tot a limit. An adder is good example: you can have ripple carry, carry look-ahead and more advanced techniques, but you can not speed up infinitely. (Otherwise CPUs these days would be running at Terra Hz)

I suspect in the end you will find that it takes T time to do your IEEE-754 adder. That can be X clock cycles of an A MHz. clock or  Y clock cycles of B MHz. But X times A is about the same as Y times B. 

What you can do is pump lots of calculations into your pipe so a new one comes out every clock cycle. But the latency will still be there.",,,,,
"Type error resolving infix expression ""or"" as type std.STANDARD.BOOLEAN","I am having trouble understanding the error. For the most part, I understand the issue is in regard to the type of data. Why are some of my data defaulting to BOOLEAN? When it does A AND B it should return a std_logic value correct? Can someone explain what's happening?

library ieee;
use ieee.std_logic_1164.all;

entity Majority is port (
    A, B, C : in std_logic;
    Y: out std_logic);

end Majority;


architecture behavioral of Majority is
    begin
    Y &lt;= '1' when ((A AND B) OR (A AND C) OR (B AND C)) else
         '0';

end architecture behavioral;
","The and and or operators returns a std_logic when an std_logic operand is passed to them and not a boolean (as I had thought in my deleted answer). when-else requires that the conditions are booleans.

So, as stated in the comment, you can do Y &lt;= '1' when ((A AND B) OR (A AND C) OR (B AND C)) = '1' else '0'; to convert the expression that returns a std_logic into boolean so that it can be used in a when-else structure.

However, that structure is redundant. You can just go with:
Y &lt;= (A AND B) OR (A AND C) OR (B AND C);. The condition returns a std_logic so you can assign it directly.

Or additionally with the VHDL 2008 ""??"" operator:


  VHDL-2008 introduces a new operator, ??. It â€™s called the condition operator and it converts a STD_LOGIC expression to a BOOLEAN one: '1' and 'H' are considered TRUE and everything else FALSE. (It also converts BIT to BOOLEAN .)


The ?? operator is applied automatically in the when-else structure, so using VHDL 2008, your code should work.",,,,,
Importing Custom VHDL IP but not able to use or view IP,"I'm new to VHDL, and currently am working on applying a few filters to a hdmi pass through example code I found. I managed to get everything working (HDMI Pass Through with RGB Switch Filter) so I'm trying to migrate the code over to a piece of IP using Vivado. 

I declared the component and instance like so:

component TestIP
        port (
            vid_pData         : in std_logic_vector(23 downto 0);
            vid_pData_new     : out std_logic_vector(23 downto 0);
            aRst              : in std_logic;
            PixelClk    : in std_logic;

            sw0               : in std_logic;
            sw1               : in std_logic;
            sw2               : in std_logic;
            sw3               : in std_logic   
            );




TestIP_inst : TestIP
port map(
    vid_pData =&gt; vid_pData_new,
    aRst      =&gt; async_reset_i,
    PixelClk      =&gt; pixelclk,

    sw0       =&gt; sw0,
    sw1       =&gt; sw1,
    sw2       =&gt; sw2,
    sw3       =&gt; sw3
    );


The rest of the code was kept the same. I packaged the IP using the IP wizard, and exported it to the default IP repository. It created a file called TestIP_0, with two files, TestIP_0 and Top_IP, both are .vhd files. 

In the source hierarchy in vivado, I can see in the IP my instance, TestIP_inst: TestIP(Behavioral)(TestIP_0.vhd)

The issue is I cannot find this in my IP catalogue, and even though I can create a bitstream successfully on my schematic I was expecting to find my IP inbetween the DVI2RGB and RGB2DVI block, but instead my IP doesnt appear and the data stream isn't connecting the input to the output so when I program the board the screen is just black.

I apologise in advance for what is probably a stupid question, but any idea how to correct this?

Thanks

EDIT
Here is my entity declaration of TestIP

entity TestIP is
Port ( vid_pData : in STD_LOGIC_Vector(23 downto 0);
       vid_pData_new : out STD_LOGIC_Vector(23 downto 0);
       aRst              : in std_logic;
       PixelClk    : in std_logic;

       sw0 : in STD_LOGIC;
       sw1 : in STD_LOGIC;
       sw2 : in STD_LOGIC;
       sw3 : in STD_LOGIC);
end TestIP;
","The correct way to initiate the component was by defining a new set of variables, it must've been getting mixed up as there were multiple instances of vid_pData and vid_pData new, so there was no ""order"" to the flow of data.

TestIP_inst : TestIP
port map(
    vid_pData1  =&gt; vid_pData,
    vid_pData2 =&gt; vid_pData_new,
    aRst      =&gt; async_reset_i,
    PixelClk      =&gt; pixelclk,

    sw0       =&gt; sw0,
    sw1       =&gt; sw1,
    sw2       =&gt; sw2,
    sw3       =&gt; sw3
    );
",,,,,
Pass 2D real array to a function in System Verilog,"I am trying to pass 2D real array to an SV function and return the same but I'm not able to execute this task successfully. Here is a simple reproducible code:
module Two_d_array_pass();

real x[2][2]='{'{1.0,2.0},'{3.0,4.0}};
real y[2][2]='{'{2.0,2.0},'{2.0,2.0}};
real z[2][2];
int i,j;

initial begin
    foreach(x[i,j]) $display(&quot;x[%0d][%0d]=%0f&quot;,i,j,x[i][j]);
    foreach(y[i,j]) $display(&quot;y[%0d][%0d]=%0f&quot;,i,j,y[i][j]);
    z=mult(x,y);
end

function real mult(x,y);
    real c[2][2];
    int i,j;    
    foreach(c[i,j]) 
        c[i][j]=x[i][j]*y[i][j];
    return c;
endfunction

endmodule

and here is the error I get:
file: Two_d_array_pass.sv
                c[i][j]=x[i][j]*y[i][j];
                        |
xmvlog: *E,DIMERR (Two_d_array_pass.sv,18|10): Bit-select or part-select dimensions do not match declaration.
                c[i][j]=x[i][j]*y[i][j];
                                |
xmvlog: *E,DIMERR (Two_d_array_pass.sv,18|18): Bit-select or part-select dimensions do not match declaration.

Can anyone correct the code to achieve this task?","You need to change the arguments to be 2x2 dimensional as well.
function real mult(real x[2][2],y[2][2]);

But you also need to do it for the return type, but because of syntax limitations, unpacked array need a typedef for the return type.
typedef real real2x2[2][2];
function real2x2 mult(real x[2][2],y[2][2]);

Then you might as well use the typedef everywhere
module Two_d_array_pass();
  typedef real real2x2[2][2];
  real2x2 x='{'{1.0,2.0},'{3.0,4.0}};
  real2x2 y='{'{2.0,2.0},'{2.0,2.0}};
  real2x2 z;

initial begin
    foreach(x[i,j]) $display(&quot;x[%0d][%0d]=%0f&quot;,i,j,x[i][j]);
    foreach(y[i,j]) $display(&quot;y[%0d][%0d]=%0f&quot;,i,j,y[i][j]);
    z=mult(x,y);
end

  function real2x2 mult(real2x2 x,y);  
    foreach(x[i,j]) 
        mult[i][j]=x[i][j]*y[i][j];
  endfunction

endmodule

P.S. you do not declare the iterating variables i and j separately, they are implicit and local to the scope of the foreach statement. If you declare them separately, they become extra variables unused by the foreach loop.",,,,,
recomend the way to write a monitor in UVM with defferent event polarity,I am trying to implement a monitor for VDU(Video display unit) and the way the VDU can be programmed says that sync signals have controllable polarity. This means than according to VDU settings monitor should react on @posedge or @negedge event. Is there any way to pass the type (means posesge or negedge) via configuration data base or do something like this. Instead of write if(truth) @posedge else @negedge. And assertion also needs to be controlled this way but assertion at list designed to take event type as an argument but I am no sure config data base calls are allowed inside interface.,"You should write your code assuming positive polarity, but feed them through an xor operator.
logic signal;           // your signal from DUT
logic signal_corrected; // signal with positive polarity
bit signal_polarity;  // 0 = positive ; 1 = negative
assign signal_corrected = signal ^ signal_polarity;

Now you can use signal_corrected in your assertions. You can certainly call uvm_config_db#(bit)::get() from the interface if it has been set in your testbench. You might need to use uvm_config_db#(bit)::wait_modified() to wait for it to be set before you get it.",,,,,
iCE40 Ultra Plus 5k -- how to set PLL (without propietary GUI tools),"Is there any way to configure the iCE40 Ultra Plus 5k PLL without using the fancy propietary tools like Lattice Icecube2 / Radiant software.
Official PLL programming guide (source) only shows how to use mentioned propietary GUI tools (ch. 4)","Those tools simple generate the files needed. In the end it looks like this:
module main_pll(REFERENCECLK,
            PLLOUTCORE,
            PLLOUTGLOBAL,
            RESET);

input REFERENCECLK;
input RESET;    /* To initialize the simulation properly, the RESET signal (Active Low) must be asserted at the beginning of the simulation */ 
output PLLOUTCORE;
output PLLOUTGLOBAL;

SB_PLL40_CORE main_pll_inst(.REFERENCECLK(REFERENCECLK),
                            .PLLOUTCORE(PLLOUTCORE),
                            .PLLOUTGLOBAL(PLLOUTGLOBAL),
                            .EXTFEEDBACK(),
                            .DYNAMICDELAY(),
                            .RESETB(RESET),
                            .BYPASS(1'b0),
                            .LATCHINPUTVALUE(),
                            .LOCK(),
                            .SDI(),
                            .SDO(),
                            .SCLK());

//\\ Fin=13.56, Fout=40.68;
defparam main_pll_inst.DIVR = 4'b0000;
defparam main_pll_inst.DIVF = 7'b0101111;
defparam main_pll_inst.DIVQ = 3'b100;
defparam main_pll_inst.FILTER_RANGE = 3'b001;
defparam main_pll_inst.FEEDBACK_PATH = &quot;SIMPLE&quot;;
defparam main_pll_inst.DELAY_ADJUSTMENT_MODE_FEEDBACK = &quot;FIXED&quot;;
defparam main_pll_inst.FDA_FEEDBACK = 4'b0000;
defparam main_pll_inst.DELAY_ADJUSTMENT_MODE_RELATIVE = &quot;FIXED&quot;;
defparam main_pll_inst.FDA_RELATIVE = 4'b0000;
defparam main_pll_inst.SHIFTREG_DIV_MODE = 2'b00;
defparam main_pll_inst.PLLOUT_SELECT = &quot;GENCLK&quot;;
defparam main_pll_inst.ENABLE_ICEGATE = 1'b0;

endmodule

However, the use of the tools is recommended to correctly set all the parameters. Any reason against using the freely available tools to generate the files and then use it elsewise?",,,,,
In SystemVerilog testbench generator class - how to generate infinitely long data stream,"In all the SystemVerilog test benches I could find on the internet the generator class always generates a fixed amount of samples and sends them to the mailbox. Driver reads the mailbox and generates an appropriate sequence by manipulating interface signals
One such generator, taken from [1] (chapter 1.3, paragraph 4) and reduced to essentials, is for example this:
    class generator;
      rand transaction trans;
      mailbox gen2driv;
      int  repeat_count; 
     
      function new(mailbox gen2driv);
        this.gen2driv = gen2driv;
      endfunction
       
      task main();
        repeat(repeat_count) begin
          trans = new();
          if( !trans.randomize() ) $fatal(&quot;Gen:: trans randomization failed&quot;);
          gen2driv.put(trans);
        end
      endtask
       
    endclass

This one generates repeat_count samples and sends them to the mailbox.
There are however situations, where user wants to generate infinite stream of data, because the testbench simulation is not terminated by a lack of input data, but rather by validation of a condition which happens somewhere in the future, at unknown time.
Extending the above example to replace repeat(repeat_count) begin by forever begin won't work. The simulator freezes in the loop as it tries to put infinite amount of samples to the mailbox. As the execution of main task is a blocking action, driver's signal generator never get executed, and the entire simulation stalls.
So my question is: How to define correctly a generator class, which can send infinite stream of data?
I'm looking for a behaviour similar to pythonic yield and generator function. This however requires some communication between driver and generator. So such generator model is probably not very suitable for SV?
[1] https://verificationguide.com/systemverilog-examples/systemverilog-testbench-example-01","What you are asking for is exactly how the UVM sequence/driver mechanism works. The generator does not do any randomization until the driver is ready and asks for an item to drive.
But you can get close to what the UVM does simply by constructing your mailbox with a bound of 1. Then the put(trans) in the main loop blocks until after the driver has performed a get(). Then there will always be one transaction in the mailbox waiting for the next drive cycle.",,,,,
"Error: ""Failed to find 'return' in hierarchical name 'return"" when simulate in ModelSim","i'm writing a verilog program. When i compile, there is no error. But when i simulate this program, there is an error: &quot;MixColumns.v(14): (vopt-7063) Failed to find 'return' in hierarchical name 'return'.&quot;
What should i do to fix this problem ? Thank you very much
Here is my Verilog code
module MixColumns(
  input        [127:0] before_MixColumns,
  output  reg  [127:0] after_MixColumns
);

function  [7:0] mul_2;
  input [7:0] a;
  begin
  mul_2 = (a[7] == 1) ? ((a &lt;&lt; 1) ^ 8'b00011011) : (a &lt;&lt; 1);
  end
endfunction

function reg [7:0] mul_3 (input [7:0] a);
  return (a ^ mul_2(a));
endfunction

function reg [31:0] matrix_mul_word (input [31:0] a);
  begin
  matrix_mul_word[31:24] = mul_2(a[31:24]) ^ mul_3(a[23:16]) ^       a[15:8]  ^       a[7:0]  ;
  matrix_mul_word[23:16] =       a[31:24]  ^ mul_2(a[23:16]) ^ mul_3(a[15:8]) ^       a[7:0]  ;
  matrix_mul_word[15:8]  =       a[31:24]  ^       a[23:16]  ^ mul_2(a[15:8]) ^ mul_3(a[7:0]) ;
  matrix_mul_word[7:0]   = mul_3(a[31:24]) ^       a[23:16]  ^       a[15:8]  ^ mul_2(a[7:0]) ;
  end
endfunction

always @*
begin
  after_MixColumns[127:96] = matrix_mul_word(before_MixColumns[127:96]);
  after_MixColumns[95:64]  = matrix_mul_word(before_MixColumns[95:64] );
  after_MixColumns[63:32]  = matrix_mul_word(before_MixColumns[63:32] );
  after_MixColumns[31:0]   = matrix_mul_word(before_MixColumns[31:0]  );
end

endmodule
","Your filename &quot;MixColumns.v&quot; is being interpreted as Verilog, but the return statement is a feature of SystemVerilog. Also, Verilog requires the use of begin/end bracketing around the procedural blocks of functions and tasks.
Change your filename to have a *.sv file extension.",,,,,
Verilog multiplexer,"Help me to solve this problem, for following question
Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.
Solution:
module top_module( 
input [15:0] a,b, c, d, e, f, g, h, i,
input [3:0] sel,
output [15:0] out );
always@(*) begin
    case(sel)
        0:
            out = a;
        1:
            out = b;
        2:
            out = c;
        3:
            out = d;
        4:
            out = e;
        5:
            out = f;
        6:
            out = g;
        7:
            out = h;
        8:
            out = i;
          
        default:
            out = 1;
       
    endcase
end

endmodule
I don't know what wrong in this code. may be the whole thing.
Note : https://hdlbits.01xz.net/wiki/Mux9to1v","module top_module( 
input [15:0] a,b, c, d, e, f, g, h, i,
input [3:0] sel,
output reg [15:0] out
);
always @(*) begin
    case(sel)
        0: out = a;
        1: out = b;
        2: out = c;
        3: out = d;
        4: out = e;
        5: out = f;
        6: out = g;
        7: out = h;
        8: out = i;
        default: out = {16{1'b1}}; //..'1 is not the same in every compiler
    endcase
end
endmodule
",,,,,
What causes 'interface resolution' compilation error when working with classes and virtual interfaces,"I have declared in a design file following interfaces:
interface t_clocks;
   ckrs_t ClkRs125MHz_ix;
   ckrs_t ClkRs160MHz_ix;
   ckrs_t [3:0] ClkRsLink_ixb;
   ckrs_t ClkRsLinkx2_ixb;
   logic tdclk_sampling;

   modport producer(output ClkRs125MHz_ix,
            output ClkRs160MHz_ix,
            output ClkRsLink_ixb,
            output tdclk_sampling);

   modport consumer(input ClkRs125MHz_ix,
            input ClkRs160MHz_ix,
            input ClkRsLink_ixb,
            input tdclk_sampling);
endinterface // clocks

interface t_bst(input ckrs_t ClkRs_ix);
   tb_t mark;

   modport consumer(input ClkRs_ix, input mark);
   modport producer(output ClkRs_ix, output mark);
endinterface // t_bst

and in a package classes working with those interfaces:
package clspkg;
   import DefinitionsPkg::*;

class bst_generator;
   virtual t_bst.producer bst_master;
   ....
endclass // bst_generator

class clock_generator;
   virtual t_clocks.producer clk_tree;
   ....
endclass // clock_generator
endpackage // clspkg

I have glued all together in the testbench, using only clock_generator class from the package:
module tb_turn_emulator;
   import clspkg::*;

   t_clocks clk_tree();
   clock_generator cgen;

   // ???????????????
   //t_bst blast_radius(clk_tree.ClkRs160MHz_ix);

   default clocking cb @(posedge clk_tree.ClkRs160MHz_ix.clk); endclocking

   `TEST_SUITE begin

      `TEST_SUITE_SETUP begin
         cgen = new;
         cgen.clk_tree = clk_tree;
         cgen.run();
         ##10;
      end

....

endmodule

Now, when I try to compile such example, it FAILS with Virtual interface resolution cannot find a matching instance for 'virtual t_bst.producer'
It took me quite some time to find out, that if I instantiate as well the t_bst interface in the testbench module (uncommenting the t_bst line in the code above), everything goes smoothly, no compilation error and the testbench passes as usual.
I don't understand why the t_bst interface has to be instantiated as it is not at all used in code. It is true that I am importing the entire clspkg package, but nothing changes when I cherry pick by importing only the clock_generator by import clspkg::clock_generator.
What is wrong? I'm using Mentor Modelsim","First about using packages:
Once you import one identifier or every identifier from a package in a design, the entire package exists in your design. That means all the static variables get allocated and initialized, as well as all the code for tasks and functions get generated. If static variable initializations call functions like class constructors, that implies executing procedural code without ever referencing it directly. (For those of you familiar with the factory design pattern and UVM, this is exactly how factory registration works.)
Next about using interfaces:
Like a module, an interface is a design element containing definitions of lots of different things. They can define variables, routines, import other packages, and have port connections. But nothing inside an interface exists or generates any code in a design until other design unit instantiates it, or in the case of a module, gets established as a top-level instance.
Now about using virtual interfaces:
Virtual interface are the primary method used to bridge the two kingdoms of the dynamic class based testbench world with the static instance based design world. Virtual interfaces behave much like a class type, except that there is no rule to have seen a definition of the interface before using it in your code. Hierarchical reference also have this capability of referencing something that does not exist at the point of compilation, but must be resolved later in the elaboration phase of compilation.
To summarize, the compiler generates code for a virtual interface once it sees a reference to it whether you actually think you are using it or not. I would try to align packages with specific interfaces they are associated with.",,,,,
How to simplify sequential logic design by eliminating nested if-else statements,"I have a design I've implemented using vhdl that is triggered based on a clock that sends an input signal to one of 8 output channels based on the sel input and also another 2 bit input. The elaborated design shows a lot of nesting due to the many if-else statements. So, I'm curious as to if there's a way to alleviate the nesting using case statements or some other method. I'm unfamiliar with doing this using case statements because I have two inputs that determine the output channel. The code that I currently have is displayed below.
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


--Inputs and outputs to entity 
entity DSA_Worker is
    Port ( DB_Select : in STD_LOGIC;
           Atten : in STD_LOGIC_VECTOR ( 7 downto 0);
           enable : in STD_LOGIC;
           clk: in STD_LOGIC;
           reset: in STD_LOGIC;
           chip_select : in STD_LOGIC_VECTOR (1 downto 0);
           DBA_TX1_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBA_TX2_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBA_RX1_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBA_RX2_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBB_TX1_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBB_TX2_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBB_RX1_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBB_RX2_DSA : out STD_LOGIC_VECTOR (7 downto 0));
end DSA_Worker;

architecture Behavioral of DSA_Worker is

begin
process(clk)
begin
  if rising_edge(clk) then
  --if reset is high, all outputs go to 0
     if reset = '1'then
       DBA_TX1_DSA &lt;= (others =&gt;'0');
       DBA_TX2_DSA &lt;= (others =&gt;'0');
       DBA_RX1_DSA &lt;= (others =&gt;'0');
       DBA_RX2_DSA &lt;= (others =&gt;'0');
       DBB_TX1_DSA &lt;= (others =&gt;'0');
       DBB_TX2_DSA &lt;= (others =&gt;'0');
       DBB_RX1_DSA &lt;= (others =&gt;'0');
       DBB_RX2_DSA &lt;= (others =&gt;'0');
        
          
      -- attenuation values sent to channels based on DB_select value(0/1) and chip select value
       --DB_select - 0 is for DB-A and 1 for DB- B and chip_select determines the channel 
       elsif enable = '1'then
             if(DB_Select='0' and chip_select = &quot;00&quot;) then -- attenuation value sent to first channel
             DBA_TX1_DSA(0) &lt;= Atten(0);
             DBA_TX1_DSA(1) &lt;= Atten(1);
             DBA_TX1_DSA(2) &lt;= Atten(2);
             DBA_TX1_DSA(3) &lt;= Atten(3);
             DBA_TX1_DSA(4) &lt;= Atten(4);
             DBA_TX1_DSA(5) &lt;= Atten(5);

             elsif (DB_Select='0' and chip_select = &quot;01&quot;) then 
             DBA_TX2_DSA(0) &lt;= Atten(0);
             DBA_TX2_DSA(1) &lt;= Atten(1);
             DBA_TX2_DSA(2) &lt;= Atten(2);
             DBA_TX2_DSA(3) &lt;= Atten(3);
             DBA_TX2_DSA(4) &lt;= Atten(4);
             DBA_TX2_DSA(5) &lt;= Atten(5);
        
             elsif (DB_Select='0' and chip_select = &quot;10&quot;) then
             DBA_RX1_DSA(0) &lt;= Atten(0);
             DBA_RX1_DSA(1) &lt;= Atten(1);
             DBA_RX1_DSA(2) &lt;= Atten(2);
             DBA_RX1_DSA(3) &lt;= Atten(3);
             DBA_RX1_DSA(4) &lt;= Atten(4);
             DBA_RX1_DSA(5) &lt;= Atten(5);
  
            elsif (DB_Select='0' and chip_select = &quot;11&quot;) then
            DBA_RX2_DSA(0) &lt;= Atten(0);
            DBA_RX2_DSA(1) &lt;= Atten(1);
            DBA_RX2_DSA(2) &lt;= Atten(2);
            DBA_RX2_DSA(3) &lt;= Atten(3);
            DBA_RX2_DSA(4) &lt;= Atten(4);
            DBA_RX2_DSA(5) &lt;= Atten(5);
      
            -- Attenuation values being set for DB-B
            elsif (DB_Select='1' and chip_select = &quot;00&quot;) then 
            DBB_TX1_DSA(0) &lt;= Atten(0);
            DBB_TX1_DSA(1) &lt;= Atten(1);
            DBB_TX1_DSA(2) &lt;= Atten(2);
            DBB_TX1_DSA(3) &lt;= Atten(3);
            DBB_TX1_DSA(4) &lt;= Atten(4);
            DBB_TX1_DSA(5) &lt;= Atten(5);
       
            elsif (DB_Select='1' and chip_select = &quot;01&quot;) then 
            DBB_TX2_DSA(0) &lt;= Atten(0);
            DBB_TX2_DSA(1) &lt;= Atten(1);
            DBB_TX2_DSA(2) &lt;= Atten(2);
            DBB_TX2_DSA(3) &lt;= Atten(3);
            DBB_TX2_DSA(4) &lt;= Atten(4);
            DBB_TX2_DSA(5) &lt;= Atten(5);
 
            elsif (DB_Select='1' and chip_select = &quot;10&quot;) then 
            DBB_RX1_DSA(0) &lt;= Atten(0);
            DBB_RX1_DSA(1) &lt;= Atten(1);
            DBB_RX1_DSA(2) &lt;= Atten(2);
            DBB_RX1_DSA(3) &lt;= Atten(3);
            DBB_RX1_DSA(4) &lt;= Atten(4);
            DBB_RX1_DSA(5) &lt;= Atten(5);
       
         else 
         DBB_RX2_DSA(0) &lt;= Atten(0);
         DBB_RX2_DSA(1) &lt;= Atten(1);
         DBB_RX2_DSA(2) &lt;= Atten(2);
         DBB_RX2_DSA(3) &lt;= Atten(3);
         DBB_RX2_DSA(4) &lt;= Atten(4);
         DBB_RX2_DSA(5) &lt;= Atten(5);
            
            end if; 
        end if;
     end if;

end process;

end Behavioral;

I did try to produce a simplified design using case statements as illustrated below
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity dsa_case is
   Port ( 
           DB_Select : in STD_LOGIC;
           Atten : in STD_LOGIC_VECTOR ( 7 downto 0);
           enable : in STD_LOGIC;
           clk: in STD_LOGIC;
           reset: in STD_LOGIC;
           chip_select : in STD_LOGIC_VECTOR (1 downto 0);
           DBA_TX1_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBA_TX2_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBA_RX1_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBA_RX2_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBB_TX1_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBB_TX2_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBB_RX1_DSA : out STD_LOGIC_VECTOR (7 downto 0);
           DBB_RX2_DSA : out STD_LOGIC_VECTOR (7 downto 0));
end dsa_case;

architecture Behavioral of dsa_case is

begin

process(clk)
begin

    if rising_edge(clk) then
       if reset = '1' then
        DBA_TX1_DSA &lt;= (others =&gt;'0');
        DBA_TX2_DSA &lt;= (others =&gt;'0');
        DBA_RX1_DSA &lt;= (others =&gt;'0');
        DBA_RX2_DSA &lt;= (others =&gt;'0');
        DBB_TX1_DSA &lt;= (others =&gt;'0');
        DBB_TX2_DSA &lt;= (others =&gt;'0');
        DBB_RX1_DSA &lt;= (others =&gt;'0');
        DBB_RX2_DSA &lt;= (others =&gt;'0');
       
       
     elsif enable = '1'then
        --    DB_Select &lt;='0';
            case chip_select is
             when &quot;00&quot;=&gt;   -- attenuation value sent to first channel
             DBA_TX1_DSA(0) &lt;= Atten(0);
             DBA_TX1_DSA(1) &lt;= Atten(1);
             DBA_TX1_DSA(2) &lt;= Atten(2);
             DBA_TX1_DSA(3) &lt;= Atten(3);
             DBA_TX1_DSA(4) &lt;= Atten(4);
             DBA_TX1_DSA(5) &lt;= Atten(5);

             when &quot;01&quot;=&gt;
             DBA_TX2_DSA(0) &lt;= Atten(0);
             DBA_TX2_DSA(1) &lt;= Atten(1);
             DBA_TX2_DSA(2) &lt;= Atten(2);
             DBA_TX2_DSA(3) &lt;= Atten(3);
             DBA_TX2_DSA(4) &lt;= Atten(4);
             DBA_TX2_DSA(5) &lt;= Atten(5);
        
            when &quot;10&quot;=&gt;
             DBA_RX1_DSA(0) &lt;= Atten(0);
             DBA_RX1_DSA(1) &lt;= Atten(1);
             DBA_RX1_DSA(2) &lt;= Atten(2);
             DBA_RX1_DSA(3) &lt;= Atten(3);
             DBA_RX1_DSA(4) &lt;= Atten(4);
             DBA_RX1_DSA(5) &lt;= Atten(5);
  
            when &quot;11&quot;=&gt;
            DBA_RX2_DSA(0) &lt;= Atten(0);
            DBA_RX2_DSA(1) &lt;= Atten(1);
            DBA_RX2_DSA(2) &lt;= Atten(2);
            DBA_RX2_DSA(3) &lt;= Atten(3);
            DBA_RX2_DSA(4) &lt;= Atten(4);
            DBA_RX2_DSA(5) &lt;= Atten(5);
      
            -- Attenuation values being set for DB-B
      --      DB_Select &lt;= '1';
            when &quot;00&quot;=&gt;
            DBB_TX1_DSA(0) &lt;= Atten(0);
            DBB_TX1_DSA(1) &lt;= Atten(1);
            DBB_TX1_DSA(2) &lt;= Atten(2);
            DBB_TX1_DSA(3) &lt;= Atten(3);
            DBB_TX1_DSA(4) &lt;= Atten(4);
            DBB_TX1_DSA(5) &lt;= Atten(5);
       
      --      DB_Select &lt;= '1';
            when &quot;01&quot; =&gt;
            DBB_TX2_DSA(0) &lt;= Atten(0);
            DBB_TX2_DSA(1) &lt;= Atten(1);
            DBB_TX2_DSA(2) &lt;= Atten(2);
            DBB_TX2_DSA(3) &lt;= Atten(3);
            DBB_TX2_DSA(4) &lt;= Atten(4);
            DBB_TX2_DSA(5) &lt;= Atten(5);
 
     --       DB_Select &lt;= '1';
            when &quot;10&quot;=&gt; 
            DBB_RX1_DSA(0) &lt;= Atten(0);
            DBB_RX1_DSA(1) &lt;= Atten(1);
            DBB_RX1_DSA(2) &lt;= Atten(2);
            DBB_RX1_DSA(3) &lt;= Atten(3);
            DBB_RX1_DSA(4) &lt;= Atten(4);
            DBB_RX1_DSA(5) &lt;= Atten(5);
       
         when others=&gt;
         DBB_RX2_DSA(0) &lt;= Atten(0);
         DBB_RX2_DSA(1) &lt;= Atten(1);
         DBB_RX2_DSA(2) &lt;= Atten(2);
         DBB_RX2_DSA(3) &lt;= Atten(3);
         DBB_RX2_DSA(4) &lt;= Atten(4);
         DBB_RX2_DSA(5) &lt;= Atten(5);
         
        end case;
        
      end if;
    end if; 
 end process;


end Behavioral;

However, it did fail to produce an elaborated design due to 5 errors, all like this
[Synth 8-517] overlapping choice 2'b00 in case statement [&quot;/home/n310-osp/case_statement_design/case_statement_design.srcs/sources_1/new/dsa_case.vhd&quot;:108]
","Personally I don't mind your if-else structure. I think you mostly have a readability issue, with a lot of redundancy (in this case the check on DB_Select inside each case) and inconsistent indentation.
This is how I'd improve the code inside the process:
process(clk)
begin
  if rising_edge(clk) then
    --if reset is high, all outputs go to 0
    if reset = '1' then
      DBA_TX1_DSA &lt;= (others=&gt;'0');
      DBA_TX2_DSA &lt;= (others=&gt;'0');
      DBA_RX1_DSA &lt;= (others=&gt;'0');
      DBA_RX2_DSA &lt;= (others=&gt;'0');
      DBB_TX1_DSA &lt;= (others=&gt;'0');
      DBB_TX2_DSA &lt;= (others=&gt;'0');
      DBB_RX1_DSA &lt;= (others=&gt;'0');
      DBB_RX2_DSA &lt;= (others=&gt;'0');
         
    -- attenuation values sent to channels based on DB_select value(0/1) and chip select value
    -- DB_select - 0 is for DB-A and 1 for DB- B and chip_select determines the channel 
    elsif enable = '1'then
      if DB_Select = '0' then
        if chip_select = &quot;00&quot; then -- attenuation value sent to first channel
          DBA_TX1_DSA(5 downto 0) &lt;= Atten(5 downto 0);
        elsif chip_select = &quot;01&quot; then 
          DBA_TX2_DSA(5 downto 0) &lt;= Atten(5 downto 0);
        elsif chip_select = &quot;10&quot; then
          DBA_RX1_DSA(5 downto 0) &lt;= Atten(5 downto 0);
        else
          DBA_RX2_DSA(5 downto 0) &lt;= Atten(5 downto 0);
        end if;
      else -- Attenuation values being set for DB-B
        if chip_select = &quot;00&quot; then 
          DBB_TX1_DSA(5 downto 0) &lt;= Atten(5 downto 0);
        elsif chip_select = &quot;01&quot; then 
          DBB_TX2_DSA(5 downto 0) &lt;= Atten(5 downto 0);
        elsif chip_select = &quot;10&quot; then 
          DBB_RX1_DSA(5 downto 0) &lt;= Atten(5 downto 0);
        else 
          DBB_RX2_DSA(5 downto 0) &lt;= Atten(5 downto 0);
        end if;
      end if;
    end if;
  end if;
end process;

end Behavioral;

You could replace the if-else structure with when-else, but that's just a matter of preference.",,,,,
visualizing yosys output not working,"I'm using the (probably incorrect!) command 

yosys -f verilog -p ""prep; show stretch count.dot"" count.v


for the following simple example

module count(input clk,output [7:0] LEDS);

reg [26:0] count;
assign LEDS = count[26:19];

always @(posedge clk) begin
    count &lt;= count + 1;
end

endmodule


Its not working as I'd expect giving no output to a file name I don't want...

3. Generating Graphviz representation of design.
Writing dot description to `/home/chris/.yosys_show.dot'.
ERROR: Nothing there to show.


Whats the correct way to do this?","The command line your are apparently looking for is:

yosys -p ""prep; show -stretch -prefix count -format dot"" count.v
",,,,,
Errors about using buffer in VHDL project,"I am a beginner to VHDL. I am trying to implement a simple project but I got some errors. The first one is about using buffers.

This is my entity code:

entity Demultiplexer is
Port ( A : in  STD_LOGIC;
       S : in  STD_LOGIC_VECTOR (2 downto 0);
       I0 : out  STD_LOGIC;
       I1 : out  STD_LOGIC;
       I2 : out  STD_LOGIC;
       I3 : out  STD_LOGIC;
       I4 : out  STD_LOGIC;
       I5 : out  STD_LOGIC;
       I6 : out  STD_LOGIC;
       I7 : out  STD_LOGIC);
end Demultiplexer;


and this is my architecture:

architecture Behavioral of Demultiplexer is
begin
    I0 &lt;= A WHEN S = ""000"" ELSE
    I1 &lt;= A WHEN S = ""001"" ELSE
    I2 &lt;= A WHEN S = ""010"" ELSE
    I3 &lt;= A WHEN S = ""011"" ELSE
    I4 &lt;= A WHEN S = ""100"" ELSE
    I5 &lt;= A WHEN S = ""101"" ELSE
    I6 &lt;= A WHEN S = ""110"" ELSE
    I7 &lt;= A WHEN S = ""111"";
end Behavioral;


This the error list

ERROR:HDLCompiler:288 - ""H:\SetUpSoftwares\XilinxProjects\Assignments- 1\Demultiplexer.vhd"" Line 49: Cannot read from 'out' object i1 ; use   'buffer' or 'inout'
ERROR:HDLCompiler:1731 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 49: found '0' definitions of operator ""&lt;="", cannot determine exact overloaded matching definition for ""&lt;=""
ERROR:HDLCompiler:288 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 50: Cannot read from 'out' object i2 ; use 'buffer' or 'inout'
ERROR:HDLCompiler:1731 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 50: found '0' definitions of operator ""&lt;="", cannot determine exact overloaded matching definition for ""&lt;=""
ERROR:HDLCompiler:288 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 51: Cannot read from 'out' object i3 ; use 'buffer' or 'inout'
ERROR:HDLCompiler:1731 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 51: found '0' definitions of operator ""&lt;="", cannot determine exact overloaded matching definition for ""&lt;=""
ERROR:HDLCompiler:288 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 52: Cannot read from 'out' object i4 ; use 'buffer' or 'inout'
ERROR:HDLCompiler:1731 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 52: found '0' definitions of operator ""&lt;="", cannot determine exact overloaded matching definition for ""&lt;=""
ERROR:HDLCompiler:288 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 53: Cannot read from 'out' object i5 ; use 'buffer' or 'inout'
ERROR:HDLCompiler:1731 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 53: found '0' definitions of operator ""&lt;="", cannot determine exact overloaded matching definition for ""&lt;=""
ERROR:HDLCompiler:288 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 54: Cannot read from 'out' object i6 ; use 'buffer' or 'inout'
ERROR:HDLCompiler:1731 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 54: found '0' definitions of operator ""&lt;="", cannot determine exact overloaded matching definition for ""&lt;=""
ERROR:HDLCompiler:288 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 55: Cannot read from 'out' object i7 ; use 'buffer' or 'inout'
ERROR:HDLCompiler:1731 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 55: found '0' definitions of operator ""&lt;="", cannot determine exact overloaded matching definition for ""&lt;=""
ERROR:HDLCompiler:854 - ""H:\SetUpSoftwares\XilinxProjects\Assignments-1\Demultiplexer.vhd"" Line 45: Unit &lt;behavioral&gt; ignored due to previous   errors.
","You have your conditional assignments wrong. The syntax is

i0 &lt;= a when s = ""000"" else other_value;  -- whatever your code is supposed to do
i1 &lt;= a when s = ""001"" else other_value;
...


The (a little misleading) error message is caused by the i1 assignment in the next line:

i0 &lt;= a when s = ""000"" else i1 ...


This is as the code was understood (until it completely bailed out) and this would mean you are trying to read from an out signal which is not supported until VHDL 2008.",,,,,
Petalinux 2014.4 build error with board_f file,"I am trying to build a petalinux kernel for a project. 
The bitstream in vivado compiles just fine, there are a few warnings but they are intended (implied latches, things not in sensitivity lists, etc).

When I get the HDF everything is fine as well, the project is initialized just fine. When I configure the the project everything goes smoothly as well. Nothing out of the ordinary, I am instantiating the basic setup, no changes. 

Now when i run petalinux-build -v , everything is fine until I get to the board_f files. These fail due to this error. 

[ALL  ] /home//Desktop/NIX_SNES/build/linux/u-boot/src/u-boot-plnx/common/board_f.c: In function 'init_baud_rate':
[ALL  ] /home//Desktop/NIX_SNES/build/linux/u-boot/src/u-boot-plnx/common/board_f.c:143:46: error: 'CONFIG_BAUDRATE' undeclared (first use in this function)
[ALL  ]   gd-&gt;baudrate = getenv_ulong(""baudrate"", 10, CONFIG_BAUDRATE);
[ALL  ]                                               ^
[ALL  ] /home//Desktop/NIX_SNES/build/linux/u-boot/src/u-boot-plnx/common/board_f.c:143:46: note: each undeclared identifier is reported only once for each function it appears in
[ERROR] make[4]: *** [common/board_f.o] Error 1
[ALL  ] make[4]: *** Waiting for unfinished jobs...


I have tried in both Ubuntu 14.04 and 15.10 , the errors are both the same. 

I cant post the entire build log, but here a link to the log on pastebin
[the error occours on line 2375]
http://pastebin.com/zFkXs8wb","It turns out the ZYNQ block I was using didn't instantiate the tcl file from the BSP that I got from the Diligent website. Thus none of the UARTS or any other peripherals were described at all. So I made this manually using a base system template and tested it out, it all works. 

In case anyone else comes across this problem.

http://pastebin.com/pE6gRGJ2",,,,,
Designing a 3-bit counter using T-flipflop,"module tff(t,i,qbprev,q,qb);
input t,i,qbprev;
output q,qb;
wire q,qb,w1;
begin
assign w1=qbprev;
if(w1==1)begin
not n1(i,i);
end
assign q=i;
not n2(qb,i);
end
endmodule

module counter(a,b,c,cin,x0,x1,x2);
input a,b,c,cin;
output x0,x1,x2;
reg a,b,c,x0,x1,x2,temp,q,qb;
always@(posedge cin)
begin
tff t1(.t(1) ,.i(a),.qbprev(1),.q(),.qb());
x0=q;
temp=qb;
tff t2(.t(1) ,.i(b),.qbprev(temp),.q(),.qb());
x1=q;
temp=qb;
tff t3(.t(1) ,.i(c),.qbprev(temp),.q(),.qb());
x2=q;
a=x0;
b=x1;
c=x2;
end
endmodule


This is my code in verilog. My inputs are - the initial state - a,b,c  and cin

I get many errors with the first of them being ""w1 is not a constant"" What doesn this mean?

I also get error ""Non-net port a cannot be of mode input""  But I want a to be an input!

Thank you.","Modules are instantiated as pieces of hardware. They are not software calls, and you can not create and destroy hardware on the fly therefore:

if(w1==1)begin
  not n1(i,i);
end


With that in mind I hope that you can see that unless w1 is a constant parameter, and this is a 'generate if' What your describing does not make sense. 

instance n1 is not called or created as required, it must always exist.

Also you have the input and output connected to i. i represent a physical wire it can not be i and not i. these need to be different names to represent different physical wires.

In your second module you have :

input a,b,c,cin;
// ...
reg a,b,c; //...


Inputs can not be regs as the warning says, just do not declare them as regs for this.

input  a,b,c,cin;
output x0,x1,x2;
reg    x0,x1,x2,temp,q,qb;
",,,,,
passing multidimensional array passing in systemverilog,"I knew that in verilog, multidimensional array cannot be passed through the module port. I heard this is allowed in systemverilog, and it is the very reason I started to use systemverilog. However, for the following code, I still encounter the error shown below for both x and y.

A reference to an entire array is not permitted in this context [Systemverilog] 


Here is the code.

module Chien(p, clk, reset, load);
        wire [`m - 1 : 0] x [0 : `t - 1];
        wire [`m - 1 : 0] y [0 : `t - 1][0 : `col];
        mul_array mularray0(x, y);
endmodule


I am using ncverilog for simulation, and I take the -sv option. Is there any problem with my code, or it is the simulator's problem?

Thanks","Works fine for me in Modelsim/Questa, except you are required to declare the ports in your port list and not just have a positional list of ports.

module Chien(input wire p, clk, reset, load);


Also since I have your attention, try not to use macros in your type declarations. Better to have parameters and typedefs

package pkg;
  parameter int col = 4, m = 5, t = 6;
  typedef logic [m-1:0] array_t[t];
endpackage 

module Chien(input p, clk, reset, load);
        import pkg::*;
        wire array_t x;
        wire array_t y [col];
        mul_array mularray0(x, y);
endmodule
",,,,,
Verilog Build System for Sublime Text 3,"I am trying to implement a simple build system for Verilog in Sublime Text, but I am getting the following error when I build:

[Errno 2] No such file or directory: 'iverilog'
[cmd: ['iverilog', '-o', 'iverilog/compiled', '/Users/ryanbeltran/Documents/Programming/Verilog/testing/test.v']]
[dir: /Users/ryanbeltran/Documents/Programming/Verilog/testing]
[path: /usr/bin:/bin:/usr/sbin:/sbin]
[Finished]


My build system is supposed to be using the Icarus Verilog Compiler, the command for which is:

iverilog -o outputfile inputfile.v


When I run that command from shell I have no problems, and it works exactly how I intend it.

My Verilog.sublime-build build system uses the following JSON:

{
    ""cmd"": [""iverilog"", ""-o"", ""iverilog/compiled"", ""$file""],
    ""selector"": ""source.v""
} 


If someone could offer me any insight into what I may doing wrong here I would appreciate it enormously. If it makes any difference, I am running from OS X, and using Sublime Text 3.  ","I ended up figuring this one out after some more experimentation. It turns out what I needed was 

{
    ""shell"":true,

    ""cmd"": [ ""mkdir -pv $file_path/iverilog_compiled &amp;&amp; touch $file_path/iverilog_compiled/$file_base_name &amp;&amp; /usr/local/bin/iverilog -o $file_path/iverilog_compiled/$file_base_name $file &amp;&amp; /usr/local/bin/vvp $file_path/iverilog_compiled/$file_base_name""],

    ""selector"": ""source.v""
}


Well, that also runs it, and so a more minimal approach could leave off the final &amp;&amp; /usr/local/bin/vvp $file_path/iverilog_compiled/$file_base_name, but that is besides the point. 

The takeaway here, is that even with shell set to true, the cmd command is not run in a full shell environment with access to the user's path variables, and so a lot of builtins and especially installed programs that you can call directly from shell will not work in there without being sourced to directly. 

If anyone gets a similar error in the future on their build, my recommendation would be to use:

which command_name


To find where your command is located, and then include your entire path.",,,,,
Accessing register depending their address,"Does anyone know the Verilog code to select single register from the register list depending on the address of the register?

For Example

+------+--------------+---------+
| Name | Offset_value | Address |
+------+--------------+---------+
| Reg1 |           01 | 0x00    |
| Reg2 |           00 | 0x04    |
| Reg3 |           00 | 0x08    |
| Reg4 |           00 | 0x0C    |
+------+--------------+---------+


If I give address as 0x08, then I can read/write from Reg3 and so on.
Each register is 32 bits.","From your description you have multiple flip-flops or registers that you want to update based on a write address.

always @(posedge clk) begin
  case ( address )
    8'h00 : Reg1 &lt;= data;
    8'h04 : Reg2 &lt;= data;
  endcase
end


If however you wanted to uses memory structure instead of REG1/2/3

reg [7:0] Reg_dat [0:254]; //255 8bit locations
always @(posedge clk) begin
  Reg_dat[address] &lt;= data;
end
",,,,,
Verilog: Altenative way for indexing signal on the LHS,"I'm using Xilinx that uses XST to synthesize my design. I ran into trouble when I write something like someReg[offest*index+:constant] &lt;= someOtherReg;. The error given is 'Variable index is not supported in signal.' What I've gathered after searching online is that indexing a signal that is on the left hand side is not supported by XST synthesis tool.



What I'm wondering is how to realize that logic of indexing the signal without using that syntax. In the example below I'm creating a Matrix multiplier that reuses a 'rowByColumn' multiplier. 



Basically at every rising clock edge I'm loading new values to the input of the 'rowByColumn' multiplier and at the next rising clock edge I'm saving the result at a new register. Saving the result at a new register is the main problem I have.



Here is the code that gives the error. Could you give suggestions on ways to solve or work around the problem.

module MatrixSeq(clk,A,B,C);
    // param
    parameter WIDTH = 32;
    parameter ROW_A  = 2;
    parameter COL_A  = 2;
    parameter ROW_B  = 2;
    parameter COL_B  = 2;
    //ports
    input clk;
    input [WIDTH*COL_A*ROW_A-1:0] A;
    input [WIDTH*COL_B*ROW_B-1:0] B;
    output [WIDTH*ROW_A*COL_B-1:0] C;

    // inputs to rowBycol 
    reg signed [WIDTH*COL_A-1:0] currentRowA;
    reg signed [WIDTH*ROW_B-1:0] currentColB;
    reg signed [WIDTH-1:0] rowByColOut;
    wire signed [WIDTH-1:0] rowByColOutWire; // wire to connet to rowByColOut

    // A,B matrix holders
    reg signed [WIDTH*COL_A*ROW_A-1:0] AsigHolder;
    reg signed [WIDTH*COL_B*ROW_B-1:0] BsigHolder;
    reg signed [WIDTH*ROW_A*ROW_B-1:0] CsigHolder; // C = A*B

    // reg signed [WIDTH-1:0] count;
    integer idxA = 0;       // iterates through the rows of A
    integer idxB = 0;       // iterates through the 'rows' of B

    // Indexing Syntax:
    //  signalAdd[some_expression +: some_range];
    //  Resolves to
    //  signalAdd[some_expression + (some_range - 1) : some_expression];

    always @(posedge clk) begin     // assume we have the transpose of matrix B
        currentRowA &lt;= AsigHolder[WIDTH*COL_A*idxA+:WIDTH*COL_A];
        currentColB &lt;= BsigHolder[WIDTH*COL_B+idxB+:WIDTH*COL_B];
        CsigHolder[WIDTH*(idxA*ROW_A+idxB)+:WIDTH] &lt;= rowByColOut;  // Error: 'Variable index is not supported in signal.'
        idxB &lt;= idxB +1;
        if(idxB == ROW_B) begin     // multiply each row of A with every 'row' B
            idxA &lt;= idxA + 1;
            idxB &lt;= 0;
        end else if(idxA == ROW_A) begin
            idxA &lt;= 0;
            idxB &lt;= 0;
        end
    end
    assign rowByColOutWire = rowByColOut;
    rowBycol rowMultColumn (.CLK(clk), .a(currentRowA), .b(currentColB), .y(rowByColOutWire));  // row by column multiplier
    assign C = CsigHolder;

endmodule


Just to be clear the problem is the third line inside the always block that gives the error 'Variable index is not supported in signal.'","If XST doesn't support part-select (+:/-:) and you cannot upgrade to something complaint with IEEE Std 1364-2001, then you will need to do it the 1995 method; bit assignment:

for(bit_idx = 0; bit_idx &lt; WIDTH*COL_A; bit_idx=bit_idx+1) begin
  currentRowA[idx] &lt;= AsigHolder[WIDTH*COL_A*idxA + bit_idx];
end


Or two dimensional arrays:

reg signed [WIDTH*COL_A-1:0] AsigHolder [0:ROW_A-1];
...

always @(posedge clk) begin     // assume we have the transpose of matrix B
  currentRowA &lt;= AsigHolder[idxA];


I noticed your idxA and idxB can go out of range. All registers assigned with non-blocking (&lt;=) are updated after evaluation. This means idxB==ROW_B will be evaluated before idxB &lt;= idxB +1 is updated.
You should have something more like the following:

if (idxB &lt; ROW_B-1) begin
  idxB &lt;= idxB + 1;
end
else begin
  idxB &lt;= 0;
  if (idxA &lt; ROW_A-1) begin
    idxA &lt;= idxA + 1;
  end
  else begin
    idxA &lt;= 0;
  end
end


Note: by fixing the index assignments, the part-select (+:/-:) may work as the the design cannot reach an out of bound index.",,,,,
VHDL : process and counter does not work,"I am trying to program in vhdl  using the process statement. Below is my vhdl code

begin

dcm_clk PORT MAP(
    CLKIN1_IN =&gt; clk,
    RST_IN =&gt; reset,
    CLKOUT0_OUT =&gt; clk0_fast,
    CLKOUT1_OUT =&gt; clk0_dac,
    CLKOUT2_OUT =&gt; clk90_fast, --13.33MHz ; div =60
    CLKOUT3_OUT =&gt; clk_mux      --26.67MHz ; div =30 
);


process(clk_mux, reset)
begin
if (reset = '0') then
    if rising_edge(clk_mux) then
        if count_m = 0 then -- 0
            MUX_0 &lt;= '1';
            count_m &lt;= count_m + 1;
        elsif count_m = 29 then
            MUX_0 &lt;= '0';
            count_m &lt;= count_m + 1;
        elsif count_m = 57 then
            MUX_0 &lt;= '1';
            count_m &lt;= count_m + 1;
        elsif count_m = 86 then
            MUX_0 &lt;= '0';
            count_m &lt;= count_m + 1;
        elsif count_m = 115 then
            count_m &lt;= (others =&gt; '0');         
    end if; -- end count_m
  end if; -- end clock

end if; -- end reset


The value of count_m seems to be stuck at the value '1'. I do not understand why there is no increment for the counter. Any help is much appreciated. The output from the testbench is shown below

","Your unlabelled process is only incrementing count_m for four specific values of count_m, and count_m = 1 is not one of them.

Try:

UNLABELLED_PROCESS:
    process (clk_mux, reset)
    begin
        if (reset = '0') then
            if rising_edge(clk_mux) then
                count_m &lt;= count_m + 1;
                if count_m = 0 then -- 0
                    MUX_0 &lt;= '1';
                   --  count_m &lt;= count_m + 1;
                elsif count_m = 29 then
                    MUX_0 &lt;= '0';
                    count_m &lt;= count_m + 1;
                elsif count_m = 57 then
                    MUX_0 &lt;= '1';
                    -- count_m &lt;= count_m + 1;
                elsif count_m = 86 then
                    MUX_0 &lt;= '0';
                    -- count_m &lt;= count_m + 1;
                elsif count_m = 115 then
                    count_m &lt;= (others =&gt; '0');         
            end if; -- end count_m
          end if; -- end clock

        end if; -- end reset
    end process;


And what this does is increment count_m every clk_mux and when the value is 115 assigns it to all '0's.

And that gives something like:



if I got your clock period arithmetic right.  Note that the assignment of count_m + 1 to count_m is overridden by the if statement for count_m = 115. You can also see that MUX_0 is a flip flop and it's output changes after the next clk_mux rising edge for a count_m value specifying a change.

Help for debugging should provide the answering reader the ability to recreate a specific error by supplying a Minimal, Complete, and Verifiable example. 

In this case it was matter of a second process for clk_mux, four signal declarations with necessary initial values (missing any reset action) all in an entity and architecture pair:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity no_mcve is
end entity;

-- dcm_clk PORT MAP(
--     CLKIN1_IN =&gt; clk,
--     RST_IN =&gt; reset,
--     CLKOUT0_OUT =&gt; clk0_fast,
--     CLKOUT1_OUT =&gt; clk0_dac,
--     CLKOUT2_OUT =&gt; clk90_fast, --13.33MHz ; div =60
--     CLKOUT3_OUT =&gt; clk_mux      --26.67MHz ; div =30
-- );

architecture foo of no_mcve is
    signal count_m: unsigned (9 downto 0) := (others =&gt; '0');
    signal clk_mux: std_logic := '0'; -- clock
    signal mux_0:   std_logic := '0';
    signal reset:   std_logic := '0';
begin

UNLABELLED_PROCESS:
    process (clk_mux, reset)
    begin
        if (reset = '0') then
            if rising_edge(clk_mux) then
                count_m &lt;= count_m + 1;
                if count_m = 0 then -- 0
                    MUX_0 &lt;= '1';
                   --  count_m &lt;= count_m + 1;
                elsif count_m = 29 then
                    MUX_0 &lt;= '0';
                    count_m &lt;= count_m + 1;
                elsif count_m = 57 then
                    MUX_0 &lt;= '1';
                    -- count_m &lt;= count_m + 1;
                elsif count_m = 86 then
                    MUX_0 &lt;= '0';
                    -- count_m &lt;= count_m + 1;
                elsif count_m = 115 then
                    count_m &lt;= (others =&gt; '0');         
            end if; -- end count_m
          end if; -- end clock

        end if; -- end reset
    end process;
CLOCK:
    process
    begin
        wait for 19.25 ns;
        clk_mux &lt;= not clk_mux;
        if now &gt; 7.3 us then
            wait;
        end if;
    end process;
end architecture;
",,,,,
Declaring task in same verilog file,"I'm trying to declare a simple clock wiggle task in a testbench, but ModelSim is claiming that no design element of my task's type exists. What's the problem with this code:

`timescale 1 ns/1 ns

module at25320a_tester();
    reg clk, s_in, s_out, chip_select, write_protect, hold;

    // Instantiate at25320a module
    at25320a EEPROM (.SCK(clk), .SI(s_in), .CSNeg(chip_select), .HOLDNeg(hold), .WPNeg(write_protect), .SO(s_out));

    run_clk(15);

    task run_clk;
        input [3:0] cycles;
        output reg clk;

        integer i;

        for (i=0;i&lt;cycles;i=i+1) begin
            #100 clk = 1;
            #100 clk = 0;
        end
    endtask

endmodule 
","Tasks must be called from a procedural block, such as always or initial. In your case, youll want to run the task in an initial block with a few modifications:

`timescale 1 ns/1 ns

module at25320a_tester();
    reg clk, s_in, s_out, chip_select, write_protect, hold;

    // Instantiate at25320a module
    at25320a EEPROM (.SCK(clk), .SI(s_in), .CSNeg(chip_select), .HOLDNeg(hold), .WPNeg(write_protect), .SO(s_out));

    initial begin
        run_clk(15);
    end

    task run_clk;
        input integer cycles; // Might as well not have this be bigger
        // No clock, you want to use the clock from the module
        integer i;

        for (i=0;i&lt;cycles;i=i+1) begin
            #100 clk = 1;
            #100 clk = 0;
        end
    endtask

endmodule 
",,,,,
Can the different PR regions of FPGA be simultaneously reconfigured? (Parallel Partial Reconfiguration),"Suppose,I have a FPGA with 4 partially re-configurable regions, can I simultaneously partially reconfigure these 4 tiles at a time? is any FPGA support this scheme or any reference in which this model has been discussed.. Due to lack of reconfig port (ICAP), should it be serially? i.e. I have to partially reconfigure these 4 PR regions one by one?

Please, share your views

regards",There is no way to reconfigure PR regions simultaneously due to a single PL configuration Module (which is a doorway to the PL Fabric). The COnfig. Module is either accessible by ICAP or PCAP or TAP Controller at a single time. ,,,,,
Can I use generate-endgenerate block inside initial in SystemVerilog?,"For e.g.

initial
begin

generate
for(genvar i; i &lt; 4; i++)
//Code
endgenerate

end //initial


I'm getting error using QuestaSim with the concept. ""Near generate: syntax error, unexpected generate ""","No. generate blocks are evaluated during elaboration time. While initial,always and other procedural blocks start at zero simulation time, that is, run-time. Referring to Systemverilog IEEE 1800-2012 : 


  Generate schemes are evaluated during elaboration of the design.
  Although generate schemes use syntax that is similar to behavioral
  statements, it is important to recognize that they do not execute at
  simulation time. 
  
  They are evaluated at elaboration time, and the
  result is determined before simulation begins. Therefore, all
  expressions in generate schemes shall be constant expressions,
  deterministic at elaboration time.


In Verilog, instantiating a module means adding extra hardware to the board. 

This hardware must be added before simulation starts(i.e. at compile time). You can not add/remove hardware during run time. You can either conditionally instantiate a module or multiply instantiate it, but never at run time.

Refer generate block syntax error question for an idea about your error. Also, refer this question for generate and genvar understanding. Referring IEEE 1800-2012 Chapter 27 for more information.



EDIT: 

To create and pass multiple interface instances, the total number of interface instances must be governed by some parameter or macro. You can use this parameter in for loop in generate block to create distinct instances and set each of them using different key as follows:

  // Generate multiple instances of interface
  genvar i;
  generate
    for(i=0;i&lt;NUM_OF_INTERFACES;i++)
    begin
      // Generate clk with different period for each instance
      always #(i+1) clk[i] = ~clk[i];

      inter in(clk[i]);  // Create multiple instances here

    initial
      begin
        // Set each and every instance
        uvm_config_db#(virtual inter)::set(null,""*"",$sformatf(""in_%0d"",i),in);
      end
    end
  endgenerate


A complete example is created at EDAPlayground Multiple Interface link. Creating multiple instances can be referred from this question.",,,,,
instancing modules verilog,"I have created two verilog modules which I would now like to instance in a third module. I would like the inputs of the third module to feed into the first, and then the outputs of the first to be the inputs of the second module and then finally the outputs of the second module to be the outputs of the overall module, if anyone could show an example of how I could do this in a generic manner it would be really appreciated.
thanks
Art","It's as easy as this:

module one (input I, output O);
  assign O = I;
endmodule

module two (input I, output O);
  assign O = I;
endmodule

module top (input I, output O);

  wire W;

  one inst1 (.I(I), .O(W));
  two inst2 (.I(W), .O(O));

endmodule


http://www.edaplayground.com/x/2Mca

By default, inputs and outputs are wires. You can just connect them straight up to module inputs and outputs. You need one or more internal wires for the internal connection(s).",,,,,
Value changes based on clk doesn't work for random numbers,"I am coding that put the value of 'd' into 'z' whenever 'clk' is changed to '1'.

For example,

clk=0 d=        15, z=         x
clk=1 d=        20, z=        20
clk=0 d=        25, z=        20
clk=1 d=        30, z=        30


it put value of 'd' into 'z' whenever clk is '1'.

So below is code that does repeat it for 20 times for random numbers.

module lab9;
reg [31:0] d;
reg clk, enable, flag;
wire [31:0] z;
reg [31:0] e;
register #(32) mine(z, d, clk, enable);

always begin
#5 clk = ~clk;

end

initial
#1 $monitor(""%5d: clk=%b,d=%d,z=%d,expect=%d"", $time,clk,d,z, e);

initial begin 
clk=0;
flag = $value$plusargs(""enable=%b"", enable);

repeat (20) begin
#2 d = $random;
end
$finish; 

end 

endmodule 


And the output I get:

    1: clk=0,d=         x,z=         x,expect=         x
    2: clk=0,d= 303379748,z=         x,expect=         x
    4: clk=0,d=3230228097,z=         x,expect=         x
    5: clk=1,d=3230228097,z=3230228097,expect=         x
    6: clk=1,d=2223298057,z=3230228097,expect=         x
    8: clk=1,d=2985317987,z=3230228097,expect=         x
   10: clk=0,d= 112818957,z=3230228097,expect=         x
   12: clk=0,d=1189058957,z=3230228097,expect=         x
   14: clk=0,d=2999092325,z=3230228097,expect=         x
   15: clk=1,d=2999092325,z=2999092325,expect=         x
   16: clk=1,d=2302104082,z=2999092325,expect=         x
   18: clk=1,d=  15983361,z=2999092325,expect=         x
   20: clk=0,d= 114806029,z=2999092325,expect=         x
   22: clk=0,d= 992211318,z=2999092325,expect=         x
   24: clk=0,d= 512609597,z=2999092325,expect=         x
   25: clk=1,d= 512609597,z= 512609597,expect=         x
   26: clk=1,d=1993627629,z= 512609597,expect=         x
   28: clk=1,d=1177417612,z= 512609597,expect=         x
   30: clk=0,d=2097015289,z= 512609597,expect=         x
   32: clk=0,d=3812041926,z= 512609597,expect=         x
   34: clk=0,d=3807872197,z= 512609597,expect=         x
   35: clk=1,d=3807872197,z=3807872197,expect=         x
   36: clk=1,d=3574846122,z=3807872197,expect=         x
   38: clk=1,d=1924134885,z=3807872197,expect=         x
   40: clk=0,d=3151131255,z=3807872197,expect=         x


On Line 6 of this output need to be '2223298057' but still have value of previous 'z' even though its clk is set to '1'.

How can I fix this?","It would seem from the behaviour of the outputs you have presented that

register #(32) mine(z, d, clk, enable);


is a set of 32 D-type flip-flops, which given its name and the names of the signals you have connected also seems to be the case. It would have been easier to answer your question if you had provided the code for register.

So, if register is indeed a set of 32 D-type flip-flops, you would not expect z to change at time 6. That is not how any kind of flip-flop behaves: the output of a flip-flop only changes on one (rising or falling) edge of a clock. 

Given these D-type flip-flops were present before you started this exercise, it would seem that you are changing d far too quickly. You ought to be changing it once per clock (clk) cycle, ie once every #10. In other words, try chaninging

#2 d = $random;


to

#10 d = $random;
",,,,,
Why couldn't I convert this integer into a logic_vector?,"I have been trying to convert this Signal of type integer into an std_logic vector and assign the converted value into another signal that has the same width as a VHDL integer 

signal temp : std_LOGIC_VECTOR(31 downto 0) := (others =&gt; '0'); 
signal FrameCumulative : integer :=0;

temp &lt;= to_stdlogicvector(to_unsigned(FrameCumulative));


However I get this error:


  Error (10346): VHDL error at vga.vhd(107): formal port or parameter
  ""SIZE"" must have actual or default value


I am using use IEEE.NUMERIC_STD.ALL; and use IEEE.STD_LOGIC_1164.ALL;

First I made the mistake of not checking the integer size within VHDL and tried to assign an integer into a 14-bit vector but after I gave it some thought I relised my mistake.

Now according to many on-line resources, what I am doing should work but my synthesiser complains about it.

If you do know the cause for this would you mind ellaborating on your answer rather than just posting the correct code, Thanks!","The function to_unsigned must be provided with a parameter specifying the width of the vector that you want it to produce. The function to_stdlogicvector is also not the correct thing to be using. Your line should look like this:

temp &lt;= std_logic_vector(to_unsigned(FrameCumulative, temp'length));


The function to_unsigned is a conversion function, it must be provided with the target width. Here, as suggested by @BrianDrummond, the width is specified by taking the length attribute from the target vector itself (temp). The std_logic_vector is a type cast, where the unsigned value is simply interpreted directly as an std_logic_vector.",,,,,
Shift Register for std_logic_vector,"I saw the same question here and i tried to follow the example but i ran into errors when declaring my signals. In specific:

#Error: COMP96_0015: Pipeline.vhd : (52, 44): ';' expected.


Here is my code:

library IEEE;
use IEEE.STD_LOGIC_1164.all;

entity Pipeline isgeneric (
    VECTOR_WIDTH: natural := 128;
    VECTOR_DEPTH: natural := 7
); port(
     ImVal : in STD_LOGIC_VECTOR(9 downto 0);
     RA : in STD_LOGIC_VECTOR(127 downto 0);
     RB : in STD_LOGIC_VECTOR(127 downto 0);
     RC : in STD_LOGIC_VECTOR(127 downto 0);
     OpCode : in STD_LOGIC_VECTOR(10 downto 0);
     RT : in STD_LOGIC_VECTOR(127 downto 0);
     Clk: in STD_LOGIC;
     Reset: in STD_LOGIC;
     OutVal : out STD_LOGIC_VECTOR(127 downto 0)
 );
end Pipeline;

architecture Behavioral of Pipeline is
    type shift_reg_type1 is array (natural range&lt;&gt;) of std_logic_vector(127 downto 0);
    type shift_reg_type2 is array (natural range&lt;&gt;) of std_logic_vector(10 downto 0);
    type shift_reg_type3 is array (natural range&lt;&gt;) of std_logic_vector(9 downto 0);
    signal shift_regA: shift_reg_type1(0 to 6)(127 downto 0);
    signal shift_regB: shift_reg_type1(0 to 6)(127 downto 0);
    signal shift_regC: shift_reg_type1(0 to 6)(127 downto 0);
    signal shift_regT: shift_reg_type1(0 to 6)(127 downto 0);
    signal OpCode_reg: shift_reg_type2(0 to 6)(10 downto 0);
    signal ImVal_reg: shift_reg_type3(0 to 6)(9 downto 0);

begin

end Behavioral;


It is complaining about my signal declarations but i do not understand why.","The signal declarations are wrong as the error message say. Moreover it expects a semicolon because the statement is complete, but your code has two range constraints per signal...

signal shift_regA: shift_reg_type1(0 to 6);   
signal shift_regB: shift_reg_type1(0 to 6);  
signal shift_regC: shift_reg_type1(0 to 6);   
signal shift_regT: shift_reg_type1(0 to 6);   
signal OpCode_reg: shift_reg_type2(0 to 6);    
signal ImVal_reg: shift_reg_type3(0 to 6);


shift_reg_type1 is already constraint to 127..0. So can't constraint shift_regA again in the second dimension. Btw. there is no second dimension, because it's a 1 dimensional  array of 1 dimensional elements.",,,,,
How to get the first 3 values of an array using VHDL?,"How to get the  first 3 values out of an array?

Example :

a [0,0,2,2,3,0];

sel_x &lt;= "" ...."";
sel_y &lt;= ""    "";


These are the signal declarations:

a : in std_logic_vector(5 downto 0);

sel_x : out std_logic_vector(2 downto 0);
sel_y : out std_logic_vector(2 downto 0);
","Depending on what you mean with ""first"", but to assign the 3 leftmost entries if a to sel_x, you can do:

sel_x &lt;= a(5 downto 3);


and in a more general way:

sel_x &lt;= a(a'left downto a'left - 2);


Hope this can get you started, and maybe you should try using a simulator to validate the code, since the a [0,0,2,2,3,0]; is not valid VHDL syntax.",,,,,
Checking if all values are equal in two vectors,"I have two std_logic_vectors RA and RB and I want to perform the following algorithm on them:

for i = 0 to 15 loop
    if RA(i) = RB(i) then RT(i) &lt;= 0xFFFFFFFF;
    else RT(i) &lt;= 0x00000000;
    end if;
end loop;


Basically, i want to compare the two vectors with each other (in this case, bit by bit) and see they are equal. If yes, then i set my output vector RT to be all ones, else, RT is all zeros.

What's a good way of doing this? I could probably brute force some implementation but i'd rather do it a smart way.

Thanks,","How about

if (RA = RB) then
    RT &lt;= (others =&gt; '1');
else
    RT &lt;= (others =&gt; '0');
end if;


Assuming RT is a subtype of std_logic_vector as well. No need for a loop, the comparison operator is defined for std_logic_vectors (of equal dimension).",,,,,
How to connect output of a module to its input?,"How to tell in SystemVerilog that one of the module's outputs is directly connected to one of it's inputs?

Does it depend on the modeling level used? If yes, what is the right way for switch level?

module abc (input in1, in2, output out1, out2, out3);

// out3 needs to be directly connected to in1
// ...

endmodule
","There are a number of ways to do this. But not all downstream tools like synthesis physical tools may support it.

This is the way to do it in SystemVerilog

module abc (input in1, in2, output out1, out2, out3);
// out3 needs to be directly connected to in1
// ...
alias out3 = in1;
endmodule


In Verilog

module abc (input .in1(sig), in2, output out1, out2, .out3(sig));
wire sig;
// out3 needs to be directly connected to in1
// ...
endmodule
",,,,,
How can I compile Xilinx Vivado's simulation libraries for e.g. QuestaSim?,"I want to compile the Xilinx Vivado simulation primitives for QuestaSim (ModelSim). The documentation lists a TCL command, but I would like to use a common shell command like the old one for ISE:

&lt;ISEDirectory&gt;\bin\nt64\compxlib.exe -family all - language all -library all -simulator questa ....


As far as I can see, the TCL command should be entered in the Vivado GUI.

How can I run the compilation from an user defined PowerShell or Bash script?","Just to answer my own question for completeness ...

There is no other way then running the compile command from the Vivado Tcl shell, either in the GUI or on command line.

Compiling Vivado libraries from Bash:

VSimBinDir=/opt/questasim/10.4d/bin
DestDir=xilinx-vivado

Simulator=questa
Language=vhdl
Library=all
Family=all

CommandFile=vivado.tcl

echo ""compile_simlib -force -library $Library -family $Family -language $Language -simulator $Simulator -simulator_exec_path $VSimBinDir -directory $DestDir"" &gt; $CommandFile
if [ $? -ne 0 ]; then
  echo 1&gt;&amp;2 -e ""${COLORED_ERROR} Cannot create temporary tcl script.${ANSI_NOCOLOR}""
  exit -1;
fi
echo ""exit"" &gt;&gt; $CommandFile

# compile common libraries
$Vivado_tcl -mode tcl -source $CommandFile
if [ $? -ne 0 ]; then
  echo 1&gt;&amp;2 -e ""${COLORED_ERROR} Error while compiling Xilinx Vivado libraries.${ANSI_NOCOLOR}""
  exit -1;
fi
",,,,,
Modelsim break on one gen instance,"I have a module which is being replicated inside a gen block. To debug the replicated module I insert a breakpoint on one of the statements. However Modelsim breaks on the same statement for all of the instances in the gen block. How can I make modelsim break only once for a certain gen block and not for all of them?

To be specific I picked a particular generate instance from the sim window to place my breakpoint, but the simulator still breaks at all the generate instances.

I am using Modelsim Altera Student Edition on CentOS 6.7","Goto Tool->Breakpoints. Select the breakpoint you just added and hit ""modify"".
There is an instance name field that you can fill in to the generated instance name.",,,,,
Can't get VHDL Sequential Multiplier to Multiply correctly,"I have a School Lab that I must do pertaining to creating a sequential multiplier in VHDL. My issues is happening before making the finite state machine for the sequential multiplier. I can not get the base model to multiply correctly, I think I have a issue in my test bench but am not 100% sure of this. I still have doubt that the issue is in my code.

Top Design (basically calling the D-Flip-Flops, MUX and Adder)

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
--use ieee.std_logic_arith.all;
--use ieee.std_logic_unsigned.all;
entity toplvds is

    port( A,B: in std_logic_vector(3 downto 0);
            Zero: in std_logic_vector(3 downto 0);
            clk, clr, load, loadP, sb: in std_logic;
            Po: out std_logic_vector(7 downto 0));

end toplvds;

architecture Behavioral of toplvds is

component dffa
    port( dina: in std_logic_vector(3 downto 0);
            clr, clk, load: in std_logic;
            q: out std_logic_vector(3 downto 0));
end component;

component dffb
    port( dinb: in std_logic_vector(3 downto 0);
            clr, clk, load, sb: in std_logic;
            qb0: out std_logic);
end component;

component mux
    port( d0,d1: in std_logic_vector(3 downto 0);
            s: in std_logic;
            y: out std_logic_vector(3 downto 0));
end component;

component adder
    port( a,b: in std_logic_vector(3 downto 0);
            cry: out std_logic;
            r: out std_logic_vector(3 downto 0));
end component;

component dffP
    port( dinp: in std_logic_vector(3 downto 0);
            carry: in std_logic;
            clr, clk, loadP, sb: in std_logic;
            PHout: out std_logic_vector (3 downto 0);
            P: out std_logic_vector(7 downto 0));
end component;

signal Wire1: std_logic_vector(3 downto 0);
signal Wire2: std_logic_vector(3 downto 0);
signal Wire3: std_logic;
signal Wire4: std_logic_vector(3 downto 0);
signal Wire5: std_logic_vector(3 downto 0);
signal Wire6: std_logic_vector(3 downto 0);
signal Wire7: std_logic;

begin

    Wire1 &lt;= Zero;

    u1: dffa port map (dina=&gt;A,clr=&gt;clr,clk=&gt;clk,load=&gt;load,q=&gt;Wire2);
    u2: dffb port map (dinb=&gt;B,clr=&gt;clr,clk=&gt;clk,load=&gt;load,sb=&gt;sb,qb0=&gt;Wire3);
    u3: mux port map (d0=&gt;Wire2,d1=&gt;Wire1,s=&gt;Wire3,y=&gt;Wire4);
    u4: adder port map (a=&gt;Wire6,b=&gt;Wire4,cry=&gt;Wire7,r=&gt;Wire5);
    u5: dffp port map (dinp=&gt;Wire5,carry=&gt;Wire7,clr=&gt;clr,clk=&gt;clk,loadP=&gt;loadP,sb=&gt;sb,PHout=&gt;Wire6,P=&gt;Po);

end Behavioral;


D-Flip-Flop for Multiplicand

library ieee;
use ieee.std_logic_1164.all;
entity dffa is 
    port( dina: in std_logic_vector(3 downto 0);
            clr, clk, load: in std_logic;
            q: out std_logic_vector(3 downto 0));
end dffa;

architecture beh of dffa is
begin
    process(clk,clr)
    begin 
        if(clr = '1') then
            q &lt;= ( others =&gt; '0');
        elsif (rising_edge(clk)) then
            if(load = '1') then
                q &lt;= dina;
            end if;
        end if;
    end process;
end beh;


D-Flip-Flop for Multiplier

library ieee;
use ieee.std_logic_1164.all;
entity dffb is 
    port( dinb: in std_logic_vector(3 downto 0);
            clr, clk, load, sb: in std_logic;
            qb0: out std_logic);
end dffb;
architecture beh of dffb is
signal q: std_logic_vector(3 downto 0);
begin
    qb0 &lt;= q(0);
    process(clk,clr, load, sb)
    begin 
        if(clr = '1') then
            q &lt;= ( others =&gt; '0');
        elsif (rising_edge(clk)) then
            if(load = '1') then
                q &lt;= dinb;
            elsif (sb = '1') then
                q &lt;= '0' &amp; q ( 3 downto 1); 
            end if;
        end if;
    end process;        
end beh;


MUX

library ieee;
use ieee.std_logic_1164.all;
entity mux is 
    port( d0,d1: in std_logic_vector(3 downto 0);
            s: in std_logic;
            y: out std_logic_vector(3 downto 0));

end mux;

architecture beh of mux is  

begin

    y &lt;= d0 when s = '1' else d1;

end beh;


Adder

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_arith.all;

entity adder is 
    port( a,b: in std_logic_vector(3 downto 0);
            cry: out std_logic;
            r: out std_logic_vector(3 downto 0));
end adder;

architecture beh of adder is
    signal temp : std_logic_vector(4 downto 0); 
begin
    temp &lt;= ('0' &amp; a) + ('0' &amp; b);

   r &lt;= temp(3 downto 0); 
   cry &lt;= temp(4);
end beh;


D-Flip-Flop for Product

library ieee;
use ieee.std_logic_1164.all;

entity dffp is 
    port( dinp: in std_logic_vector(3 downto 0);
            carry: in std_logic;
            clr, clk, loadP, sb: in std_logic;
            PHout: out std_logic_vector (3 downto 0);
            P: out std_logic_vector(7 downto 0));
end dffp;

architecture beh of dffp is
signal q: std_logic_vector(7 downto 0);
begin
    --qp0 &lt;= q(0);
    process(clk,clr, loadP, sb)
    begin 
        if(clr = '1') then
            q &lt;= ( others =&gt; '0');
        elsif (rising_edge(clk)) then
            if(loadP = '1') then
                --q &lt;= ""00000000"";
                q(7 downto 4) &lt;= dinp;
            elsif (sb = '1') then
                q &lt;= carry &amp; q ( 7 downto 1);   
            --else 
                --q(7 downto 4) &lt;= dinp;
            end if;
        end if;
    end process;

    PHout &lt;= q(7 downto 4); 
    P &lt;= q;

end beh;


TEST-BENCH Code

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--USE ieee.numeric_std.ALL;

ENTITY toplvds_tb IS
END toplvds_tb;

ARCHITECTURE behavior OF toplvds_tb IS 

    -- Component Declaration for the Unit Under Test (UUT)

    COMPONENT toplvds
    PORT(
         A : IN  std_logic_vector(3 downto 0);
         B : IN  std_logic_vector(3 downto 0);
         Zero : IN  std_logic_vector(3 downto 0);
         clk : IN  std_logic;
         clr : IN  std_logic;
         load : IN  std_logic;
         loadP : IN  std_logic;
         sb : IN  std_logic;
         Po : OUT  std_logic_vector(7 downto 0)
        );
    END COMPONENT;


   --Inputs
   signal A : std_logic_vector(3 downto 0) := (others =&gt; '0');
   signal B : std_logic_vector(3 downto 0) := (others =&gt; '0');
   signal Zero : std_logic_vector(3 downto 0) := (others =&gt; '0');
   signal clk : std_logic := '0';
   signal clr : std_logic := '0';
   signal load : std_logic := '0';
   signal loadP : std_logic := '0';
   signal sb : std_logic := '0';

    --Outputs
   signal Po : std_logic_vector(7 downto 0);

   -- Clock period definitions
   constant clk_period : time := 10 ns;

BEGIN

    -- Instantiate the Unit Under Test (UUT)
   uut: toplvds PORT MAP (
          A =&gt; A,
          B =&gt; B,
          Zero =&gt; Zero,
          clk =&gt; clk,
          clr =&gt; clr,
          load =&gt; load,
          loadP =&gt; loadP,
          sb =&gt; sb,
          Po =&gt; Po
        );

   -- Clock process definitions
   clk_process :process
   begin
        clk &lt;= '0';
        wait for clk_period/2;
        clk &lt;= '1';
        wait for clk_period/2;
   end process;


   -- Stimulus process
   stim_proc: process
   begin

        A &lt;= ""1011"";
        B &lt;= ""1101"";
        Zero &lt;=""0000"";

        load &lt;= '0';
        sb &lt;= '0';
        clr &lt;= '1';
        wait for 12 ns;
        clr &lt;= '0'; load &lt;= '1';

        wait for 12 ns;
        load &lt;= '0'; sb &lt;= '1';
        wait for 12 ns;
        sb &lt;= '0'; loadP &lt;= '1';

        wait for 12 ns;
        loadP &lt;= '0'; sb &lt;= '1';
        wait for 12 ns;
        sb &lt;= '0'; loadP &lt;= '1';

        wait for 12 ns;
        loadP &lt;= '0'; sb &lt;= '1';
        wait for 12 ns;
        sb &lt;= '0'; loadP &lt;= '1';

        wait for 12 ns;
        loadP &lt;= '0'; sb &lt;= '1';
        wait for 12 ns;
        sb &lt;= '0'; loadP &lt;= '1';

        wait for 12 ns;
        loadP &lt;= '0'; sb &lt;= '1';

        wait for 20 ns;
        loadP &lt;= '0'; sb &lt;= '0';


      wait;
   end process;

END;


Sorry that I have not commented the code for better understanding. I know this will be hard to follow but I hope someone will. I will also attach an image of the figure of the sequential multiplier I am following, the circuit design.

4 by 4 binary sequential multiplier circuit

4 by 4 binary sequential multiplier circuit - more","Well it was indeed something in the testbench that was giving issues. I worked it out in the lab with fellow classmates. Thank You for your help anyways it is much appreciated.

p.s. All I did was changed some timing values in the testbench at the very bottom to when the load and shift bit would happen and I got it to work.",,,,,
Blind/ground unused testbench ports,"I got top module including sub-modules instantiated in testbench file. The sub-modules are pretty free on their own, therefore when I am testing the top module, I need to introduce only few signals and track few outputs, but the top module has many other ports. 

May I provide some ""default""/""undefined"" signal (and sink) to those pins (not regarding their size, type)?

There are 2 ways I solve that right now, either take out the sub-module to test it (well, but I want to test it within top module) or write appropriate ""zero"" inputs for inputs and introduce signals for outputs (lot of work as well).

using VHDL with Vivado 2015

alright, so this is the testbench 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;

entity tb_FIR_v0_3 is
end tb_FIR_v0_3;

architecture Behavioral of tb_FIR_v0_3 is   
shared variable C_S00_AXI_DATA_WIDTH : integer := 32;
shared variable C_S00_AXI_ADDR_WIDTH : integer := 7;

component FIR_v0_3 is
    generic (
        C_S00_AXI_DATA_WIDTH    : integer   := 32;
        C_S00_AXI_ADDR_WIDTH    : integer   := 7
    );
    port (
        fir_clk     : in  std_logic;
        fir_x_in    : in  std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
        fir_y_out   : out std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
        fir_d_out   : out std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
        -- User ports ends

        s00_axi_aclk    : in std_logic;
        s00_axi_aresetn : in std_logic;
        s00_axi_awaddr  : in std_logic_vector(C_S00_AXI_ADDR_WIDTH-1 downto 0);
        s00_axi_awprot  : in std_logic_vector(2 downto 0);
        s00_axi_awvalid : in std_logic;
        s00_axi_awready : out std_logic;
        s00_axi_wdata   : in std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
        s00_axi_wstrb   : in std_logic_vector((C_S00_AXI_DATA_WIDTH/8)-1 downto 0);
        s00_axi_wvalid  : in std_logic;
        s00_axi_wready  : out std_logic;
        s00_axi_bresp   : out std_logic_vector(1 downto 0);
        s00_axi_bvalid  : out std_logic;
        s00_axi_bready  : in std_logic;
        s00_axi_araddr  : in std_logic_vector(C_S00_AXI_ADDR_WIDTH-1 downto 0);
        s00_axi_arprot  : in std_logic_vector(2 downto 0);
        s00_axi_arvalid : in std_logic;
        s00_axi_arready : out std_logic;
        s00_axi_rdata   : out std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
        s00_axi_rresp   : out std_logic_vector(1 downto 0);
        s00_axi_rvalid  : out std_logic;
        s00_axi_rready  : in std_logic
    );
end component FIR_v0_3;

signal e_clk     : std_logic := '1' ;
signal e_reset   : std_logic := '1' ;
signal e_x_in    : std_logic_vector (31 downto 0);
signal e_y_out   : std_logic_vector (31 downto 0);
signal e_d_out   : std_logic_vector (31 downto 0);

signal s00_axi_awready   : std_logic;
signal s00_axi_wready    : std_logic;
signal s00_axi_bresp     : std_logic_vector(1 downto 0);
signal s00_axi_bvalid    : std_logic;
signal s00_axi_arready   : std_logic;
signal s00_axi_rdata     : std_logic_vector(32-1 downto 0);
signal s00_axi_rresp     : std_logic_vector(1 downto 0);
signal s00_axi_rvalid    : std_logic;

signal s00_axi_aclk     : std_logic := '0';
signal s00_axi_aresetn  : std_logic;
signal s00_axi_awaddr   : std_logic_vector(C_S00_AXI_ADDR_WIDTH-1 downto 0);
signal s00_axi_awprot   : std_logic_vector(2 downto 0);
signal s00_axi_awvalid  : std_logic := '0';
signal s00_axi_wdata    : std_logic_vector(C_S00_AXI_DATA_WIDTH-1 downto 0);
signal s00_axi_wstrb    : std_logic_vector((C_S00_AXI_DATA_WIDTH/8)-1 downto 0);
signal s00_axi_wvalid   : std_logic := '0';
signal s00_axi_bready   : std_logic := '0';
signal s00_axi_araddr   : std_logic_vector(C_S00_AXI_ADDR_WIDTH-1 downto 0);
signal s00_axi_arprot   : std_logic_vector(2 downto 0);
signal s00_axi_arvalid  : std_logic := '0';
signal s00_axi_rready   : std_logic := '0';

begin   
inst_FIR_v0_3 : FIR_v0_3
generic map (
    C_S00_AXI_DATA_WIDTH =&gt; 32,
    C_S00_AXI_ADDR_WIDTH =&gt; 7
)
port map (
    -- Users to add ports here
    fir_clk     =&gt; e_clk,
    fir_x_in    =&gt; e_x_in,
    fir_y_out   =&gt; e_y_out,
    fir_d_out   =&gt; e_d_out,

    -- Ports of Axi Slave Bus Interface S00_AXI
    s00_axi_aclk     =&gt; s00_axi_aclk,
    s00_axi_aresetn  =&gt; e_reset,
    s00_axi_awaddr   =&gt; ( others =&gt; '0' ),
    s00_axi_awprot   =&gt; ( others =&gt; '0' ),
    s00_axi_awvalid  =&gt; s00_axi_awvalid,
    s00_axi_awready  =&gt; s00_axi_awready,
    s00_axi_wdata    =&gt; ( others =&gt; '0' ),
    s00_axi_wstrb    =&gt; ( others =&gt; '0' ),
    s00_axi_wvalid   =&gt; s00_axi_wvalid,
    s00_axi_wready   =&gt; s00_axi_wready,
    s00_axi_bresp    =&gt; s00_axi_bresp,
    s00_axi_bvalid   =&gt; s00_axi_bvalid,
    s00_axi_bready   =&gt; s00_axi_bready,
    s00_axi_araddr   =&gt; ( others =&gt; '0' ),
    s00_axi_arprot   =&gt; ( others =&gt; '0' ),
    s00_axi_arvalid  =&gt; s00_axi_arvalid,
    s00_axi_arready  =&gt; s00_axi_arready,
    s00_axi_rdata    =&gt; s00_axi_rdata,
    s00_axi_rresp    =&gt; s00_axi_rresp,
    s00_axi_rvalid   =&gt; s00_axi_rvalid,
    s00_axi_rready   =&gt; s00_axi_rready
);

process
    variable count : integer := 0;
begin

    if ( count = 0 ) then
        -- e_reset &lt;= '0'; -- VALUES NOT INITIATED PROPERLY, FUCKER ? ... With the non-stop, pop pop and stainless steel (DMX)
        e_x_in &lt;= x""00000000"";
    end if;

    if ( count = 3 ) then
        -- e_reset &lt;= '1';
    end if;

    if ( count = 3 ) then
        e_x_in &lt;= x""00000001"";
    end if;

    if ( count = 5 ) then
        e_x_in &lt;= x""00000000"";
    end if;

    if ( count = 8 ) then
        e_x_in &lt;= x""00000000"";
    end if;

    e_clk &lt;= not(e_clk);
    wait for 0.5 ns;
    count := count + 1;
    if( (count = 60) ) then
        count := 0;
    end if;
end process;


end Behavioral;


I am too lazy to create signal for every AXI input/output ports and then connect them one by one. May I avoid somehow creating those 21 signals ...

signal s00_axi_awready   : std_logic;
signal s00_axi_wready    : std_logic;
signal s00_axi_bresp     : std_logic_vector(1 downto 0);
signal s00_axi_bvalid    : std_logic;
signal s00_axi_arready   : std_logic;
....
...


and then connecting them ? Like this ...

s00_axi_wvalid   =&gt; s00_axi_wvalid,
s00_axi_wready   =&gt; s00_axi_wready,
s00_axi_bresp    =&gt; s00_axi_bresp,
s00_axi_bvalid   =&gt; s00_axi_bvalid,
s00_axi_bready   =&gt; s00_axi_bready,


Is there any ""universal"" in/out signal that I would tie to pins that are not important, because I cant leave the ports of an instance unconnected (as far as I know and tried).","If I understand the question correctly, inputs in your port definition can have default values, and outputs can be left unconnected in an instantiation. For example:

entity ShiftRegister is
    Generic (
        WIDTH : integer
    );
    Port (
        clk : in  STD_LOGIC;
        enable : in  STD_LOGIC := '1';
        serial_in : in  STD_LOGIC := '0';
        parallel_out : out  STD_LOGIC_VECTOR (WIDTH-1 downto 0);
    );
end ShiftRegister;


...

    SR : entity work.ShiftRegister
    Generic map (
        WIDTH : integer =&gt; 8
    )
    Port map(
        clk =&gt; serial_clk,
        serial_in =&gt; serial_data_in
    );


In this example, the register will always be enabled, and the entity does not output anything. Not a very useful instantiation in this case, but I think this answers your question!",,,,,
"VHDL integer'image(some_int) results in ""Expression is not constant"" error","What is the correct way to convert an always changing integer variable to a string (to be displayed on a VGA monitor)? I have a series of if statements that take care of padding (so that the resulting string is always a certain length but as soon as I change:

resulting_string &lt;= integer'image(87465);


to:

resulting_string &lt;= integer'image(some_int_var);


I get an ""Expression is not constant"" error. What is the correct way to convert an always changing integer variable (that could be any int within the integer limits) to a string?

edit: not duplicate of the other question","I went at it from every direction and finally found that I had to make a giant case block to get it to work. Now I can finally display rapidly changing variables that are really helpful for debugging. It's unfortunate that the solution had to be so retarded though..

(I already have a ROM for displaying text that the resulting string is sent to.)

function int_to_str(int : integer) return string is
    variable a : natural := 0;
    variable r : string(1 to 11);

begin
    a := abs (int);

    case a is
        when 0    =&gt; r := ""0          "";
        when 1    =&gt; r := ""1          "";
        when 2    =&gt; r := ""2          "";
        when 3    =&gt; r := ""3          "";
        .
        .
        .
        when 1000 =&gt; r := ""1000       "";

        when others =&gt; r := ""???????????"";
    end case;

    if (int &lt; 0) then
        r := '-' &amp; r(1 to 10);
    end if;

    return r;
end int_to_str;
",,,,,
"""expected type void"" - VHDL function error","I've written a simple function which does log2 computation of any integer number and then ""ceils"" it to the next integer:

function log2ceil(intVal: integer) return natural is
    variable i        : natural;
    variable bitCount : natural;
begin

    i := (intVal - 1);
    bitCount := 0;

    while (i &gt; 0) loop
        bitCount := bitCount + 1;
        i:=shiftRightInt(i,1);
    end loop;

    return bitCount;
end log2ceil;




function shiftRightInt(ValueToShift: integer; NrToShift:natural) return integer is
begin
    return to_integer(shift_right(to_unsigned(ValueToShift, 32), NrToShift));
end shiftRightInt; 


Works, fine. The problem is with the simulation. Every time I try to simulate it with a simple function call in a test bench:

stim: process
begin
    wait for 10 ns;
    log2ceil(3);
    wait;
end process;


it gives me following error:

ERROR: [VRFC 10-1472] type error near log2ceil ; expected type  void 


Why does it expect type Void? And how can I avoid getting this error?","The code:

stim: process
begin
  wait for 10 ns;
  log2ceil(3);
  wait;
end process;


is describing a procedure call, but log2ceil is a function. Procedures have a return type of void, whereas your function returns an integer.

You need to provide a dummy variable to collect the return value:

stim: process
  variable dummy : natural;
begin
  wait for 10 ns;
  dummy := log2ceil(3);
  wait;
end process;


The error message is a bit cryptic, but correct!",,,,,
Designing a FSM in VHDL using 2 processes,"I tried to design a FSM using 2 processes though i have too many syntax errors.
I can't understand what is wrong .
The most of the errors are like this ""syntax error near if/else"" etc.

entity myFSM is
    Port ( CLK : in  STD_LOGIC;
           RST : in  STD_LOGIC;
           IN0 : in  STD_LOGIC;
           IN1 : in  STD_LOGIC;
           IN2 : in  STD_LOGIC;
           LED : out  STD_LOGIC_VECTOR (7 downto 0));
end myFSM;

architecture Behavioral of myFSM is
        type state is (A, B, C);
        signal currentS, nextS: state;
myFSM_comb: process (currentS, IN0, IN1, IN2)
begin
    case currentS is
        when A =&gt;   LED &lt;= ""11111111"";
                        if IN0 = '1' then nextS&lt;=B;
                        else if IN1 = '1' then nextS&lt;=C;
                        else            nextS&lt;=A;
                        end if;
        when B =&gt;   LED &lt;= ""11000011"";
                        if IN0 = '1' then nextS&lt;=C;
                        else if IN1 = '1' then nextS&lt;=A;
                        else nextS&lt;=B;
                        end if;
        when C =&gt;   LED &lt;= ""00111100"";
                        if IN0 = '1' then nextS&lt;=A;
                        else if IN1 = '1' then nextS&lt;=B;
                        else nextS&lt;=C;
                        end if;
    end case;
end process;

myFSM_synch: process(CLK,RST)
begin 
    if (RST='1')        then    currentS&lt;=A;
    elsif (rising_edge(CLK)) then; currentS&lt;= nextS;
    end if;
end process ;

end Behavioral;
","I can see the following faults:


The keyword for else if is elsif.
There is a missing begin before the first process.
The FSM has no initial state

signal currentS : state := A;



This is a fixed and improved version of your code. It uses a default assignment for nextS.

myFSM_comb: process (currentS, IN0, IN1, IN2) -- IN2 is unused
begin
   nextS &lt;= currentS;
   LED   &lt;= ""11111111"";

  case currentS is
    when A =&gt;
      LED &lt;= ""11111111"";
      if IN0 = '1' then
        nextS&lt;=B;
      elsif IN1 = '1' then
        nextS&lt;=C;
      end if;
    when B =&gt;
      LED &lt;= ""11000011"";
      if IN0 = '1' then
        nextS&lt;=C;
      elsif IN1 = '1' then
        nextS&lt;=A;
      end if;
    when C =&gt;
      LED &lt;= ""00111100"";
      if IN0 = '1' then
        nextS&lt;=A;
      elsif IN1 = '1' then
        nextS&lt;=B;
      end if;
  end case;
end process;
",,,,,
VHDL: Signal defined in the architecture not taking the assigned value,"I'm trying to write VHDL code for a 3 input simple adder. When I type the following code, S gets the correct output value but S1 gets zero, and hence add_out also gets the wrong value.

library ieee;
use ieee.std_logic_1164.all;

entity adder is
    port( A,B : in std_logic_vector(3 downto 0);
            C : in std_logic;
    carry_out : out std_logic;
            S : out std_logic_vector(3 downto 0);
       addOut : out std_logic_vector(4 downto 0));
end adder;

architecture behavioral of adder is
signal S1 : std_logic_vector(3 downto 0);
begin
    proc : process(A,B,C) is
    variable carry : std_logic;
    begin
    carry := C;
    for i in 0 to 3 loop
    S(i) &lt;= A(i) xor B(i) xor carry;
    S1(i) &lt;= A(i) xor B(i) xor carry;
    carry := (A(i) and B(i)) or (B(i) and carry) or (A(i) and carry);
    end loop;
    carry_out &lt;= carry;
    addOut &lt;= carry &amp; S1;
    end process proc;
end behavioral;


Why is the signal S1 not getting the same value as S?","S1 probably (almost certainly) DOES get the same value as S.

However you wouldn't expect to see that value of S1 on addOut, thanks to the mistake in the process sensitivity list. Study the semantics of signal assignment, (aka ""postponed assignment"") and delta cycles, and all will become clear. (My usual explanation on this topic, if you'll excuse some self publicity) 

Specifically, you have a new value on S1, but no means to wake up the process again to propagate it to any other signal.

The best fix is probably to move the addOut and carryOut assignments outside the process, where they will immediately reflect any changes on their own inputs, and reduce the likelihood of sim/synth mismatches.",,,,,
"""If"" inside an always OR condition in the sensitivity list of the always block?","Is these two codes behave in the same way ?

always @(a == 1'b1) // I guess for this one, it's like a combinational if (AND gate logic : a AND 1).
    // code


and

always @(a) begin // I guess for this one, if a= 1 from the time 0,
                  // it won't go inside since there wouldn't be any change.
    if (a == 1) begin
    // code
    end
end


Is it true ?

It's a basic question but I'd like to know if I miss something, thank you!","Nope, both are not same.


  Note that variables in the sensitivity list are considered as an event
  and hence they are not executed, rather just change in the variable is
  considered as a trigger to that event.


So the 1st always block 

always @ (a==1'b1)


is same as : 

always @ (a)


So 1st always block will execute with both a = 1 &amp; 0, whereas in 2nd case, because of ""if"" condition, it will be executed only with a = 1",,,,,
What is the tip for change the value of a reg in 2 always block?,"I have 2 always blocks, and a finish_bcd wire signal in order to detect only when a conversion is done or not.
After the conversion, I'd like to put it at 0 but it's in another always block...

wire finish_bcd;

bin2bcd BinTBcd (
 .binary(data),
 .thousands(w1),
 .hundreds(w2),
 .tens(w3),
 .ones(w4),
 .finish(finish_bcd)  //################ line 53
);

always @(posedge finish or posedge finish_bcd) begin
    if (finish_bcd == 1) begin
        case(enable)
            5'b00000: enable &lt;= 5'b00001; //send the thousands
            5'b00001: enable &lt;= 5'b00010; //send the hundreds
            5'b00010: enable &lt;= 5'b00100; //send the tens
            5'b00100: enable &lt;= 5'b01000; //send the ones
            5'b01000: enable &lt;= 5'b10000; //send a "";""
            5'b10000: enable &lt;= 5'b00000; // Everything is sent, I would like to do 'finish_bcd = 0;' here, at the end of the process in this always block.
            default: enable &lt;= 5'b00000;
        endcase 
    end
end


The bin2bcd module is :

module bin2bcd (
    input [10:0] binary,
    output reg [3:0] thousands,
    output reg [3:0] hundreds,
    output reg [3:0] tens,
    output reg [3:0] ones,
    output reg finish);

integer i;

always @(binary) begin
    // set 100's, 10's, and 1's to zero
   thousands = 4'b0;
   hundreds = 4'b0;
   tens = 4'b0;
   ones = 4'b0;

   for (i=10; i&gt;=0; i=i-1) begin
       // add 3 to columns &gt;= 5
       if (thousands &gt;= 5)
           thousands = thousands + 3;         
       if (hundreds &gt;= 5)
           hundreds = hundreds + 3;
       if (tens &gt;= 5)
           tens = tens + 3;
       if (ones &gt;= 5)
           ones = ones + 3;
        // shift left one
       thousands = thousands &lt;&lt; 1;
       thousands[0] = hundreds[3];
       hundreds = hundreds &lt;&lt; 1;
       hundreds[0] = tens[3];
       tens = tens &lt;&lt; 1;
       tens[0] = ones[3];
       ones = ones &lt;&lt; 1;
       ones[0] = binary[i];
   end

     finish &lt;= 1;  //############ line to detect when the conversion is done

end
endmodule


Another question: Why I cannot just change ""reg finish_bcd;"" in the top module ?

I got this error line 53 Reference to scalar reg 'finish_bcd' is not a legal net lvalue

I will synthesize this code for a Xilinx FPGA.

Edit:

I have a binary word, I want to send it by serial communication then I convert this binary (11bits) to BCD in order to send ASCII numbers.
And I want to send everytime when ""binary"" changes.
finish_bcd is used for detecting when the conversion is done in order to start sending data.
The always @(posedge finish or posedge finish_bcd) begin block is used to change the state (in order to send the thousands then hundreds etc...

Then, binary changes, the conversion is done, finish_bcd = 1, it starts to send the data (thousands etc...) the end of each send is detected with finish
Everything is working in simulation but since finish_bcd doesn't go to 0, when it sent all numbers, it stops. I need to reset finish_bcd at the end in order to detect a new binary change and start to send new values.

Thank you.","always @* is combinatorial, this need to simulate in zero time. For a state machine you need to use a clock and imply flip-flops for state. 

Combinatorial logic can not hold state, therefore is no good on its own for state machines. Combinatorial sections are often used in Moore FSM to decode state in to outputs (based on state).

bin2bcd module is combinatorial because there is no clock or flip-flops used to make it take more than 1 clock cycle, that means it takes 0 clock cycles. You have used a for loop, you may be referring to how many loops it takes to execute, the for loop specifies 10. But this is combinatorial so your implying loads of parallel hardware, just because it is a loop in verilog does not mean it reuses the comparators. If you want to minimise the hardware and take 10 clock cycles to compute the result you need to build a state machine to control and sequence it.

Part 2

posedge finish or posedge finish_bcd is not really implying a valid hardware structure.

In part you have two posedges in the sensitivity list, one is not being used a async reset or set. which means you have created a flip-flop with two clock inputs. This hardware structure simply does not exist.

In addition to this Using a data signal (finish) as a clock will lead to all sorts of timing issues at synthesis. Image this design as part of a bigger system and you have to balance all the clock trees, this becomes very difficult to almost impossible if you do not keep data and clocking separate.",,,,,
How to use axi dma kernel module in custom application in petalinux?,"I am trying to build the axidma-benchmark application with the Xilinx-axidma driver (Github repo) provided by bperez77.
I am using Petalinux 20.2 to build Linux for my custom project.
In the new version of the kernel, some functions are changed and I get some errors when running petalinux-build. I changed the driver files as mentioned here and build the kernel module successfully.
In the following, I create the custom application by running:
petalinux-create -t apps --name axidma-benchmark --enable 

Then I copy the application files into the recipes-apps directory and append all C and header files to the SRC_URI List in the axidma-benchmark.bb as:
SRC_URI = &quot;file://axidma-benchmark.c \
       file://axidma_ioctl.h \
       file://conversion.h \
       file://libaxidma.h \
       file://util.c \
       file://util.h \
       file://Makefile \
      &quot;

Then I add APP_OBJS += util.o to the Makefile and build the application by running:
petalinux-build -c axidma-benchmark

But I got these errors:

ERROR: axidma-benchmark-1.0-r0 do_compile: oe_runmake failed
ERROR: axidma-benchmark-1.0-r0 do_compile: Execution of '/media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/temp/run.do_compile.21635' failed with exit code 1:
aarch64-xilinx-linux-gcc  -march=armv8-a+crc -mtune=cortex-a72.cortex-a53 -fstack-protector-strong  -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security --sysroot=/media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot -o axidma-benchmark axidma-benchmark.o util.o -Wl,-O1 -Wl,--hash-style=gnu -Wl,--as-needed -fstack-protector-strong -Wl,-z,relro,-z,now
/media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: axidma-benchmark.o: in function main': /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:491: undefined reference to axidma_init'
/media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:499: undefined reference to axidma_malloc' /media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:505: undefined reference to axidma_malloc'
/media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:514: undefined reference to axidma_get_vdma_tx' /media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:515: undefined reference to axidma_get_vdma_rx'
/media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: axidma-benchmark.o: in function single_transfer_test': /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:396: undefined reference to axidma_twoway_transfer'
/media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: axidma-benchmark.o: in function main': /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:558: undefined reference to axidma_free'
/media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:560: undefined reference to axidma_free' /media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:562: undefined reference to axidma_destroy'
/media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:519: undefined reference to axidma_get_dma_tx' /media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:520: undefined reference to axidma_get_dma_rx'
/media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/recipe-sysroot-native/usr/bin/aarch64-xilinx-linux/../../libexec/aarch64-xilinx-linux/gcc/aarch64-xilinx-linux/9.2.0/ld: axidma-benchmark.o: in function time_dma': /usr/src/debug/axidma-benchmark/1.0-r0/axidma-benchmark.c:426: undefined reference to axidma_twoway_transfer'
collect2: error: ld returned 1 exit status
make: *** [Makefile:12: axidma-benchmark] Error 1
WARNING: /media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/temp/run.do_compile.21635:1 exit 1 from 'exit 1'
ERROR: Logfile of failure stored in: /media/fpgaws/projects/DevelopmentLab/build/apu/ultrazed7ev/build/tmp/work/aarch64-xilinx-linux/axidma-benchmark/1.0-r0/temp/log.do_compile.21635

What is my mistake?","I have forgotten to add the libaxidma.c files into the file directory. By adding this file application was built successfully.
Update:
You can access the final version of my code via this link.
If you have any problems, please let me know.",,,,,
Operands in verilog,"I am trying to implement a PID controller using Verilog, but I faced some problems in the coding.
I try to set the position as a parameter like shown in the screens shot:

but, I faced an error which I am not aware of:

Error1:-
Error (10170): Verilog HDL syntax error at Verilog1.v(16) near text: &quot;[&quot;;  expecting an operand. Check for and fix any syntax errors that appear immediately before or at the specified keyword. The Intel FPGA Knowledge Database contains many articles with specific details on how to resolve this error. Visit the Knowledge Database at https://www.altera.com/support/support-resources/knowledge-base/search.html and search for this specific error message number.


Error2:-
Error (10170): Verilog HDL syntax error at Verilog1.v(34) near text: &quot;[&quot;;  expecting &quot;@&quot;, or an operand. Check for and fix any syntax errors that appear immediately before or at the specified keyword. The Intel FPGA Knowledge Database contains many articles with specific details on how to resolve this error. Visit the Knowledge Database at https://www.altera.com/support/support-resources/knowledge-base/search.html and search for this specific error message number.

I also tried the like integer position=  [0*IRL+1000*CIR+2000*IRR];, but still, I face the same problem.  How do I fix this syntax error?","After compiling, parameter values can only be read; not modified. They are runtime constants.   An integer type can only be assigned within an procedural block. You can give it an initial value at declarations, but it will not auto update. So you want a procedure assignment or a net type with continuous assignment.
Square brackets ([]) are used for indexing an array or slice of a vector. They cannot be used like parentheses (()) or curly brackets ({}). In your case non are needed.
Change:
integer position=  [0*IRL+1000*CIR+2000*IRR];

To:
wire [31:0] position=  0*IRL+1000*CIR+2000*IRR;

Or:
wire [31:0] position;
assign position=  0*IRL+1000*CIR+2000*IRR;

Or:
integer position;
always @* begin
  position=  0*IRL+1000*CIR+2000*IRR;
end


Also change:
Proportional&lt;= [position/IRL+CIR+IRR]-1000;

To:
Proportional&lt;= (position/IRL+CIR+IRR)-1000;
",,,,,
Verilog compiler errors in Modelsim when simulating register file,"I'm trying to write some verilog code to create a register file containing 32 32-bit registers.
Register File Input/Output
Here is my code below:
module regfile (clk, we, ra1, ra2, wa, wd, rd1, rd2);

    
    input  logic        we, 
    input  logic        clk, 
    input  logic [4:0]  ra1, ra2, wa, 
    input  logic [31:0] wd, 
    output logic [31:0] rd1, rd2;

    logic [31:0]     rf[31:0];

    always @ (posedge clock) 
        begin
            rd1 = rf[ra1];
            rd2 = rf[ra2];
        end  
  
    always_comb
        begin
            if(we == 1)
                rf[wa] = wd;
                
            rf[0] = 0;
        end

endmodule

I modeled the code above based on some tutorial files, so I am very confused why Modelsim gives compilation errors.
Are there any obvious mistakes with the syntax?
When running the command in the CMD: vsim -do regfile.do
How can I get it to output the verbose warnings so I can actually see what is causing the problem?","You are using a bizarre combination of pre-2001 and post-2001 syntax. I recommend post-2001 syntax for your ports:
module regfile (
    input  logic        we, 
    input  logic        clk, 
    input  logic [4:0]  ra1, ra2, wa, 
    input  logic [31:0] wd, 
    output logic [31:0] rd1, rd2
    );
",,,,,
32-bit adder subtractor model compile error: Illegal Lvalue,"I am designing a 32 adder/subtractor using the following specification.
Inputs are connected to FFs with synchronous reset and an enable signal.  The output from these registers are connected to the add/subtract. The output from the add/subtract goes to another set of FFs whose output is connected to the output port. Now when the inputs are given to the module, outputs are generated after 2 clock cycles.
Here is my design.

    module adder(A,B,Add_Sub,Out);
      input [31:0]A;
      input [31:0]B;
      input Add_Sub;
      output [32:0]Out;
      reg [32:0]Out;
      always @( A or B or Add_Sub)
        begin
          if(Add_Sub == 1)
            Out = A + B;
          else
            Out = A -B;
        end
    endmodule
    
    module DFF(D,clk,reset,enable, Q);
      input[31:0] D; // Data input
      input clk,reset,enable;
      output[31:0] Q; // output Q
      reg[31:0] Q;
    always @(posedge clk or posedge reset)
    begin
        if(reset)
            Q &lt;= 32'b0;
        else if (enable)
            Q &lt;= D;
    end
    endmodule
      
    module register_adder(A,B,CLK,RST,ADD_SUB,EN,OUT,OUT_READY);
      input [31:0]A,B;
      input CLK,RST,ADD_SUB,EN;
      output [32:0]OUT;
      reg [32:0]OUT;
      wire [31:0]Q1,Q2;
      wire[32:0]Q3;
      output OUT_READY;
      always @(posedge CLK or A or B or ADD_SUB)
        begin
          DFF F1(A,CLK,RST,EN,Q1);
          DFF F2(B,CLK,RST,EN,Q2);
          adder A1(Q1,Q2,ADD_SUB,Q3);
          DFF F3(Q3,CLK,RST,EN,OUT);
          OUT_READY &lt;=1'b1;
        end
    endmodule


While compiling the model, I'm getting the following errors.
Compiling source file : q6.v

    q6.v: L42: error: Illegal Lvalue
    q6.v: L42: error: syntax error, unexpected IDENTIFIER, expecting LE or '='
    q6.v: L43: error: Illegal Lvalue
    q6.v: L43: error: syntax error, unexpected IDENTIFIER, expecting LE or '='
    q6.v: L44: error: Illegal Lvalue
    q6.v: L44: error: syntax error, unexpected IDENTIFIER, expecting LE or '='
    q6.v: L45: error: Illegal Lvalue
    q6.v: L45: error: syntax error, unexpected IDENTIFIER, expecting LE or '='
    8 errors in compilation


I cannot find the issue on analysis.","Your module instances should not be inside an always block.
OUT_READY should not be inside the always either, and it should use the assign keyword and the blocking assignment operator (=).
I no longer get compile errors with the following code:
module register_adder(A,B,CLK,RST,ADD_SUB,EN,OUT,OUT_READY);
  input [31:0]A,B;
  input CLK,RST,ADD_SUB,EN;
  output [32:0]OUT;
  reg [32:0]OUT;
  wire [31:0]Q1,Q2;
  wire[32:0]Q3;
  output OUT_READY;

  DFF F1(A,CLK,RST,EN,Q1);
  DFF F2(B,CLK,RST,EN,Q2);
  adder A1(Q1,Q2,ADD_SUB,Q3);
  DFF F3(Q3,CLK,RST,EN,OUT);

  assign OUT_READY = 1'b1;
endmodule

Here is the fixed code on edaplayground (you need to create an account if you don't already have one -- it's free).

The code generates warning messages on some simulators.  For example, with Cadence I see:
      DFF F3(Q3,CLK,RST,EN,OUT);
              |
xmelab: *W,CUVMPW (./testbench.sv,42|14): port sizes differ in port connection(33/32) for the instance(register_adder) .

You need to decide if you really want 32 or 33 bits.",,,,,
Casting wire vector to integer in verilog,"In an example like this
function module(
    input [3:0] in
    output out); 
    for(integer i = in; i &lt; in+10; i += 1) begin
        // do stuff
    end
endfunction

How would in be cast to i?
From what I understand an integer is a 32-bit bit vector, interpreted in 2's complement.
So does verilog pad the bit vector with 28{in[3]}?","From LRM

If needed, extend the size of the right-hand side, performing sign extension if, and only if, the type of the right-hand side is signed.

So, in your case i will be padded with '0', not with in[3], because in is not signed.
To do sign extension, you will need to make in signed: input signed [3:0] in;",,,,,
SystemVerilog Merging Events,"I was reading about SV Merging events from this website. The code is as follows:
module events_ex;

  event ev_1; //declaring event ev_1
 
  initial begin
    fork
      //process-1, triggers the event
      begin
        #40;
        $display($time,&quot;\tTriggering The Event&quot;);
        -&gt;ev_1;
      end
     
      //process-2, wait for the event to trigger
      begin
        $display($time,&quot;\tWaiting for the Event to trigger&quot;);
        #60;
        @(ev_1.triggered);
        $display($time,&quot;\tEvent triggered&quot;);
      end
    join
  end
  initial begin
    #100;
    $display($time,&quot;\tEnding the Simulation&quot;);
    $finish;
  end
endmodule

The result for the same is:
0  Waiting for the Event to trigger
40  Triggering The Event
100 Ending the Simulation

In this particular code, the trigger is being executed first at 40 time units, then the waiting is applied at 60 time units. It is known that, if the trigger executes first, then the waiting process remains blocked. If I use #60 wait(ev_1.triggered); in the line 17 this can be resolved. However, it is still showing the same result? I want to know the concept behind this.","Mechanism is pretty simple: value of event.triggered is only set in the same simulation tick as when it was triggered. It is not sticky and becomes 0 in the next tick.

It is known that, if the trigger executes first, then the waiting process remains blocked.

Yes, because the unblocking event has already passed and #60 is too late for it to be detected. So, it cannot be detected any longer neither by @ nor by wait.
Now, what you can do is to set a sticky variable at the event, for example as triggered in the following:
module events_ex;

  event ev_1; //declaring event ev_1
  logic triggered = 1'b0;
  
  initial begin
    fork
      //process-1, triggers the event
      begin
        #40;
        $display($time,&quot;\tTriggering The Event&quot;);
        -&gt;ev_1;
      end
     
      begin 
        @(ev_1)
        triggered = 1'b1; // &lt;&lt; set the sticky var
      end
      
      //process-2, wait for the event to trigger
      begin
        $display($time,&quot;\tWaiting for the Event to trigger&quot;);
        #60;
        wait(triggered); // &lt;&lt; wait for sticky var value of 1
        $display($time, &quot;\tEvent triggered&quot;);
      end
    join
  end
  

  initial begin
    #100;
    $display($time,&quot;\tEnding the Simulation&quot;);
    $finish;
  end
endmodule

There however, you can see a difference in semantics between @ and  wait operators. @ waits for a change of the value, which happened at #40 and it will not be able to catch it at #60 as well. wait on the other hand, waits for a level, for triggered to become 1'b1. So, it will work here since the sticky var has been already set.",,,,,
Connecting output of 4-bit counter to Hex to 7-Seg decoder and creating testbench,"I have the general abstract idea, but doing it in Verilog is very hard for me. I know I have to connect the two and then make a testbench.  Would that require 2 more modules? I have trouble understanding how to declare inputs and outputs correctly, and that makes it hard to make the testbench.
The input of the counter is a clock, and the output is 4 bits. That 4 bit connects to the 4 bit input of the decoder. The testbench needs to display the clock input, 4 counter outputs, and the 7 outputs of the decoder.
One thing that is unclear is whether I need one more module to connect the two modules, or can I just implement this functionality into one testbench?
//4-bit counter counting from 0000 to 1111

module lab_x_counter (clk, cnt);

input clk;   
output reg[3:0] cnt;

always @(posedge clk) begin
cnt &lt;= cnt + 1;
end

initial
cnt &lt;= 0;
endmodule


//Hex to 7-seg
module lab_x_behavioral (SW, HEX0);

   input [3:0] SW;
   output [6:0] HEX0;  
  
   bcd_behavioral u0 (SW[3:0], HEX0[6:0]);
endmodule


module bcd_behavioral (bcd, HEX0);
input [3:0] bcd;
output reg [6:0] HEX0;

always @(bcd) begin
   case (bcd)

4'b0000: HEX0 &lt;= ~7'b0111111;
4'b0001: HEX0 &lt;= ~7'b0000110;
4'b0010: HEX0 &lt;= ~7'b1011011;
4'b0011: HEX0 &lt;= ~7'b1001111;
4'b0100: HEX0 &lt;= ~7'b1100110;
4'b0101: HEX0 &lt;= ~7'b1101101;
4'b0110: HEX0 &lt;= ~7'b1111101;
4'b0111: HEX0 &lt;= ~7'b0000111;
4'b1000: HEX0 &lt;= ~7'b1111111;
4'b1001: HEX0 &lt;= ~7'b1101111;

4'b1010: HEX0 &lt;= ~7'b1110111;
4'b1011: HEX0 &lt;= ~7'b1111100;
4'b1100: HEX0 &lt;= ~7'b0111001;
4'b1101: HEX0 &lt;= ~7'b1011110;
4'b1110: HEX0 &lt;= ~7'b1111001;
4'b1111: HEX0 &lt;= ~7'b1110001;
endcase
end
endmodule
","Instead of your lab_x_behavioral module, I created a tb module without ports.  Then I instantiated the counter, added a clock, and made the connections.  There is no need for the port names to match.  Here is one way to code a quick testbench:
module tb;
   wire [3:0] cnt;
   wire [6:0] HEX0;
   reg clk = 0;

   bcd_behavioral u0 (cnt, HEX0);
   lab_x_counter  u1 (clk, cnt);

always #5 clk = ~clk;

initial begin
     #500 $finish;
end
endmodule

See also Testbench 101",,,,,
"I have the following errors appearing on my code, I don't know what they mean neither know how to fix them","So I am trying to write the VHDL for a 32-bit ALU on EDA PLayground, but I get some error messages that I don't quite get, and I don't know how to fix them, can someone please help?
I cannot understand where the mistakes are, and I don't know what to change in my code to fix them.
The following is the VHDL code:
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_signed.ALL;

entity alu is
    port(
    A, B: in std_logic_vector(31 downto 0);
            opcode: in std_logic_vector(2 downto 0);
            Result: in std_logic_vector(31 downto 0) 
            );
end entity alu;

architecture dataoperations of alu is
begin 
    Result &lt;= A + B when opcode=&quot;1010&quot; 
    else    A - B when opcode=&quot;1000&quot;
    else    abs(A) when opcode=&quot;1011&quot;
    else    -A  when opcode=&quot;1101&quot;
    else    abs(B) when opcode=&quot;0001&quot;
    else    -B when opcode=&quot;1001&quot;
    else    A or B when opcode=&quot;0110&quot;
    else    not A when opcode=&quot;1111&quot;
    else    not B when opcode=&quot;0101&quot;
    else    A and B when opcode=&quot;1100&quot;
    else    A xor B when opcode=&quot;0010&quot;;
end architecture dataoperations;

Here is the testbench code:
library IEEE;
use IEEE.std_logic_1164.all;

entity mytestbench is
end entity mytestbench;

architecture test of mytestbench is
    signal in1, in2, out1: std_logic_vector (31 downto 0);
    signal in3: std_logic_vector (2 downto 0);
begin
    g1: entity work.alu(dataoperations)
        port map (A &lt;= in1, B &lt;= in2; opcode &lt;= in3, Result &lt;= out1);
    in1 &lt;= &quot;0001&quot;, &quot;0FAF&quot; after 20 ns, &quot;F000&quot; after 40 ns;
    in2 &lt;= &quot;0100&quot;, &quot;7FFF&quot; after 10 ns, &quot;FFFF&quot; after 30 ns;
    in3 &lt;= &quot;00&quot;;
end architecture test;  

And here are the error messages:
COMP96 File: design.vhd
COMP96 Compile Architecture &quot;dataoperations&quot; of Entity &quot;alu&quot;
COMP96 ERROR COMP96_0143: &quot;Object &quot;Result&quot; cannot be written.&quot; &quot;design.vhd&quot; 15 2
COMP96 File: testbench.vhd
COMP96 ERROR COMP96_0724: &quot;',' or ')' expected.&quot; &quot;testbench.vhd&quot; 12 28
COMP96 ERROR COMP96_0015: &quot;';' expected.&quot; &quot;testbench.vhd&quot; 12 31
COMP96 ERROR COMP96_0019: &quot;Keyword 'when' expected.&quot; &quot;testbench.vhd&quot; 12 65
COMP96 ERROR COMP96_0015: &quot;';' expected.&quot; &quot;testbench.vhd&quot; 12 65
COMP96 ERROR COMP96_0019: &quot;Keyword 'end' expected.&quot; &quot;testbench.vhd&quot; 12 65
COMP96 ERROR COMP96_0016: &quot;Design unit declaration expected.&quot; &quot;testbench.vhd&quot; 12 66
COMP96 ERROR COMP96_0019: &quot;Keyword 'of' expected.&quot; &quot;testbench.vhd&quot; 16 22
COMP96 ERROR COMP96_0018: &quot;Identifier expected.&quot; &quot;testbench.vhd&quot; 16 22
","The last 8 errors are a semicolon used where a comma separator should be in the g1 port map.
-- port map (A &lt;= in1, B &lt;= in2; opcode &lt;= in3, Result &lt;= out1);
port map (A =&gt; in1, B =&gt; in2, opcode =&gt; in3, Result =&gt; out1);

A list is separated by commas, except a list of interface declarations which are separated by semicolons. This is a lost of port associations in a port map aspect (which isn't a declaration, while a port clause is).
(NOTE port map associations use the compound delimiter =&gt; and not &lt;= between the formal port and actual signal. This would have been another dozen or so errors.)
The first error is because the alu port Result has the wrong mode (should be mode out).
These are typographic errors.
There are as yet undisclosed errors in mytestbench.
The string values assigned to in1, in2 should be bit strings (e.g. x&quot;7FFF&quot;) where hex digits represent 4 elements each, and you show 16 elements when there should be 32 (e.g. x&quot;00007FFF&quot;). The value assigned to in3 doesn't have enough elements.  As poor examples:
-- in1 &lt;= &quot;0001&quot;, &quot;0FAF&quot; after 20 ns, &quot;F000&quot; after 40 ns;
    -- in2 &lt;= &quot;0100&quot;, &quot;7FFF&quot; after 10 ns, &quot;FFFF&quot; after 30 ns;
    -- in3 &lt;= &quot;00&quot;;
    in1 &lt;= x&quot;00000001&quot;, x&quot;00000FAF&quot; after 20 ns, x&quot;0000F000&quot; after 40 ns;
    in2 &lt;= x&quot;00000100&quot;, x&quot;00007FFF&quot; after 10 ns, x&quot;0000FFFF&quot; after 30 ns;
    in3 &lt;= &quot;000&quot;;

It isn't a bad first effort. The volume of errors from the semicolon where a comma is expected is surprising and reflects on the parser architecture found in ALDEC's tool. A parser with a lookahead of 1 would have (should have) quit sooner. Syntax errors can be hard to provide useful error messages for, they are detected before any semantic analysis. Your last recourse may be in examining the syntax (described in the LRM, IEEE Standard 1076).
The first error on the same line:
OMP96 ERROR COMP96_0724: &quot;',' or ')' expected.&quot; &quot;testbench.vhd&quot; 12 28

where the last two numbers are line number and character position is the one needing attention first. You'd almost think quitting after the first error would be better to 'teach' you the language syntax.
There's also an undisclosed simulation error where for example when opcode=&quot;1010&quot; has a mismatch between the string literal length and number of elements in opcode (3, 2 downto 0). The equality operator will always evaluate to FALSE. Either fix the string literals or have a matching number of elements in opcode.",,,,,
SV Assertion: Check Signal is High for a particular State and does not change during that State,"I want to check If my Signal A is high as long as I am in the FSM 'FSM_WAIT' State. If A goes low anywhere in this State I should flag an error. The Assertion should check that A goes High during the state and stays High throughout.
I tried a sample Code somewhat like this.
        @(posedge clk )
        disable iff (!reset)
        (fsm_state==  FSM_WAIT ) &amp;&amp; A |-&gt; ##Duration A;
    endproperty : p_try  

Doesn't see correct to me though, please help. Thanks

","(fsm_state==FSM_WAIT ) &amp;&amp; A |-&gt; A until (fsm_state!=FSM_WAIT )
",,,,,
How do I remove the errors in the following code:,"Every time I try to compile, it would show the following error on line 7 and 13 of my code.
i.e. near [2:0] funct and near [31:0] Data_in. The compiler gives the following error:
near &quot;[&quot;: syntax error, unexpected '[', expecting IDENTIFIER or TYPE_IDENTIFIER or NETTYPE_IDENTIFIER.
What should I do?
module rv32i(clk, reset);// Input is read from files
input clk, reset;
//Wires are defined to connect to various components

// ALU wires
wire rz;
wire [2:0] funct, [31:0] v1, [31:0] v2, [31:0] result;

// Instruction Memory Wires
wire [31:0] ins;

// Register File Wires
wire [31:0] Data_in, [31:0] Data_Out2, [4:0] Write_Addr;

// Data Memory Wires
wire [31:0] read_data;
wire write_en, read_en;

// Controller Wires
wire reg_dst, jump, branch, mem_read, mem_to_reg,
 alu_op, mem_write, alu_src, reg_write;

// Immediate instruction wires
wire [31:0] imm_ext;

//Connections of the processor
memory m(
    .ins(ins),
    .imm(imm_ext[6:0]),
    .branch(branch),
    .rz(rz),
    .jump(jump),
    .clk(clk)
    );

controller c(
    .clk(clk),
    .reset(reset),
    .opcode(ins[6:0]),
    .reg_dst(reg_dst),
    .jump(jump),
    .branch(branch),
    .mem_read(mem_read),
    .mem_to_reg(mem_to_reg),
    .alu_op(alu_op),
    .mem_write(mem_write),
    .alu_src(alu_src),
    .reg_write(reg_write)
    );

data_mem d(
    .d_addr(result),
    .write_en(write_en),
    .read_en(read_en),
    .write_data(Data_Out2),
    .read_data(read_data),
    .clk(clk)
    );

mux2_1 mem_reg(
    .a(result),
    .b(read_data),
    .s(mem_to_reg),
    .c(Data_in)
    );

mux2_1_5 ins_reg(
    .a(ins[24:20]),
    .b(ins[11:7]),
    .s(reg_dst),
    .c(Write_Addr)
    );

Registers r(
    .Data_in(Data_in),
    .Data_Out1(v1),
    .Data_Out2(Data_Out2),
    .Read_Addr_1(ins[19:15]),
    .Read_Addr_2(ins[24:20]),
    .Write_Addr(Write_Addr),
    .Write_Enable(reg_write),
    .clk(clk)
    );

alu_control ac(
    .ins_func(ins[14:12]),
    .ins_out(funct),
    .alu_op(alu_op)
    );

extend alu_imm(
    .a1(ins[31:20]),
    .a2(imm_ext)
    );

mux2_1 alu_mux(
    .a(Data_Out2), .b(imm_ext), .s(alu_src), .c(v2)
    );

ALU a(
    .clk(clk),
    .reset(reset),
    .funct(funct),
    .v1(v1),
    .v2(v2),
    .rz(rz),
    .result(result)
    );

endmodule

I could not find any errors but it won't compile.","You are only allowed one set of packed dimensions per wire declaration. You need to split it up
wire [2:0] funct, [31:0] v1, [31:0] v2, [31:0] result;

should be
wire [2:0] funct;
wire [31:0] v1, v2, result;

And same for another line below it.",,,,,
How do I pass multiple clocking blocks with different polariy from an system verilog interface?,"I have an system verilog interface
interface XZY(input clk, input reset, input a, output b);
    clocking cb @(posedge clk);
        input a;
        output b;
    endclocking: cb

   modport master(clocking cb, input reset);


endinterface: XYZ

I am passing the interface as virtual interface to my driver.
The driver is using the moport(master).
Now I need to access both the posedge and the negedge of the clock in my driver.
I can easily access the posedge by @cb.
How do I access the negedge?
Do i need to create another modport/clocking block for the negedge and pass it separately to the driver?","I would recommend a clocking block for both positive and negative edge clocks. You can have both clocking blocks listed in your modport. You don't need a modport when in your driver/monitor.
If you want to dynamically choose the polarity with the same clocking block then see my answer here: Changing clocking block clock polarity on the fly. This works for a polarity mode switch; I would not recommend it if both edges are needed in the same transaction.",,,,,
"VDHL error: converted type of object near text or symbol ""UNSIGNED"" must match std_logic_vector type of target object","I'm getting this error when I try to compile some VHDL code: Error (10409): VHDL Type Conversion error at &lt;line&gt;: converted type of object near text or symbol &quot;UNSIGNED&quot; must match std_logic_vector type of target object.
I think I understand that this error is saying a is instantiated as std_logic_vector, but since I have added unsigned when I use a in the architecture, they are not the same type anymore so they cannot be properly converted. However, when I try to add unsigned in the entity declaration for SW or in the signal declaration, I get another error saying &quot;unsigned&quot; is never used. Can anyone help?
Here is my code:
library ieee;           
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity E is 
    port( SW:   in   std_logic_vector(9 downto 0); 
          LEDG: out      std_logic_vector(4 downto 0)   
            ); 
end entity E; 

architecture main of E is 
signal a, b, c: std_logic_vector; 

begin 

a &lt;= unsigned(SW(4 downto 0));
b &lt;= unsigned(SW(9 downto 7));
c &lt;= ('0' &amp; a) + ('0' &amp; b);
 
// non-relevant code

end architecture main; 
            
","VHDL is very strict about types, it won't convert one type into another one unless you explicitly tell it to.
So to fix your error, you simply have to convert the unsigned value back to an std_logic_vector, i.e.:
a &lt;= std_logic_vector(unsigned(SW(4 downto 0)));
b &lt;= std_logic_vector(unsigned(SW(9 downto 7)));

However, there's not really any reason to convert to unsigned and then convert back to std_logic_vector straight away. So you might as well just do:
a &lt;= SW(4 downto 0);
b &lt;= SW(9 downto 7);

However, in both cases you'll still get errors, because you didn't define the length of a, b and c. So you should fix those declarations:
signal a : std_logic_vector(4 downto 0);
signal b : std_logic_vector(2 downto 0);
signal c : std_logic_vector(? downto ?); -- Can't infer this from your code.
",,,,,
Improper array length of a 5-bit input rom on VHDL code,"I am trying to create a 5-bit input 32-bit output rom but on testbench section I get an error which says the following:
COMP96 ERROR COMP96_0367: &quot;Improper array length (8). Expected length is 5.&quot; &quot;testbench.vhd&quot; 18 26
COMP96 ERROR COMP96_0367: &quot;Improper array length (8). Expected length is 5.&quot; &quot;testbench.vhd&quot; 17 26
COMP96 ERROR COMP96_0367: &quot;Improper array length (8). Expected length is 5.&quot; &quot;testbench.vhd&quot; 16 14
COMP96 ERROR COMP96_0367: &quot;Improper array length (4). Expected length is 5.&quot; &quot;testbench.vhd&quot; 15 26

And the testbench code is the following:
library IEEE;
use IEEE.std_logic_1164.all;

entity rom_test is
end entity rom_test;

architecture dataflow of rom_test is
    signal input_address: std_logic_vector (4 downto 0);
    signal output_data: std_logic_vector (31 downto 0);
    
begin
    g1: entity work.rom(dataflow)
        port map(addr=&gt;input_address, data_out=&gt;output_data);
        
        input_address &lt;= x&quot;0&quot;,
                         x&quot;01&quot; after 20 ns,
                         x&quot;02&quot; after 40 ns,
                         x&quot;03&quot; after 60 ns;
end architecture dataflow;

Can someone help?","input_address is a std_logic_vector of length 5 (4 downto 0). You are trying to assign it a one or two digit hexadecimal value, which is of length 4 and 8.
One way to to fix it is to concatenate a 0 to a one digit hex number, resulting in a vector of length 5:
input_address &lt;= '0' &amp; x&quot;0&quot;,
                         '0' &amp; x&quot;1&quot; after 20 ns,
                         '0' &amp; x&quot;2&quot; after 40 ns,
                         '0' &amp; x&quot;3&quot; after 60 ns;

Another way is to only assign the 4 lowest bits of input_address:
input_address(4) &lt;= '0';
input_address(3 downto 0) &lt;= x&quot;0&quot;,
                             x&quot;1&quot; after 20 ns,
                             x&quot;2&quot; after 40 ns,
                             x&quot;3&quot; after 60 ns;
",,,,,
VHDL: Combining multiplication and slicing into one line,"I have a hardware accelerated function that requires two instances of fixed point multiplication. My current solution (example below) requires two clock cycles per multiplication; one step of multiplication, followed by a second step where that value is sliced back to the original input word size. I would like this to take as few cycles as necessary for latency.
Here is my current solution:
signal a        : std_logic_vector(7 downto 0);
signal b        : std_logic_vector(7 downto 0);
signal y        : std_logic_vector(7 downto 0);
signal product  : std_logic_vector(15 downto 0);
    
MULTIPLY_PROCESS : process(clk) 
    begin
        if(rising_edge(clk)) then
            product &lt;= std_logic_vector(unsigned(a) * unsigned(b));
            y &lt;= product(11 downto 4);      --takes one additional clock cycle
        end if;                             --for y to appear
end process;

It makes sense to me that this could be shrunk down to one clock cycle, as normal unsigned multiplication does this automatically by throwing out the top end of the oversized vector.
example:
signal a    : std_logic_vector(7 downto 0);
signal b    : std_logic_vector(7 downto 0);
signal y    : std_logic_vector(7 downto 0);

MULTIPLY_PROCESS : process(clk)
    begin
        if(rising_edge(clk)) then
            y &lt;= std_logic_vector(unsigned(a) * unsigned(b)); --truncates automatically
        end if;
end process;

This is code I thought would work, but throws a compiler error:
y &lt;= std_logic_vector(unsigned(x) * unsigned(a))(11 downto 4)

Error: Prefix of slice name cannot be type conversion (STD_LOGIC_VECTOR) expression.

Is there some way to fixed-point multiply and truncate in a single line/step/clock cycle?","Credit to user1155120. Calling the multiplication through a function and then slicing the function before conversion does the trick.
y &lt;= std_logic_vector(&quot;*&quot;(unsigned(x), unsigned(a))(11 downto 4));
",,,,,
How to automatically convert port signals of verilog sub modules using python?,"Let's say there is a TOP module, one logic (logic1) and one test logic (logic2) like in the left picture.
I want to exclude test logic like in the right picture (all verilog form).

At first, If we suppose all the logics (logic and test logic) are instantiated inside the TOP module,
The left side of verilog code would be something like this.
(Let's say a-&gt; blue, b-&gt; yellow, c-&gt; red, d-&gt; green, signal b penetrates test logic)
module TOP (

input  a1,
input  b1,
input  c1,
output d1
);
wire   b2;
wire   c2;

logic1 U_logic(
.A (a1),
.B (b2),
.C (c2),
.D (d1),
);

logic2 U_testlogic(
.B    (b2),
.C_IN (c1),
.C    (c2),
);

endmodule

The right side of verilog code would be something like this.
module TOP (

input  a1,
input  b1,
input  c1,
output d1
);

logic1 U_logic(
.A (a1),
.B (b1),
.C (c1),
.D (d1),
);

endmodule

If the number of logics and test logics are more than 100, and it is hard to exclude all the test logic manually, How can I deal with this automatically by using Python code (The number of logics and test logics are same)?
The main goal is to convert port signal of test logic (logic2) to port signal of logic (logic1) and remove test logic. [ex. c2-&gt;c1 (.C port signal -&gt; .C_IN port signal), b2-&gt;b1 (penetrating signal -&gt; specific input), remove logic2]","An outline of a possible solution is as follows:
import re

with open(&quot;test.txt&quot;) as in_file, open(&quot;output.txt&quot;, 'w') as out_file:
    for line in in_file:
        if &quot;U_logic&quot; in line:
            out_file.write(line)
            for line in in_file:
                if &quot;);&quot; in line:
                    break
                out_file.write(re.sub(r&quot;(\.\w+\s*\(\w+)2&quot;, r&quot;\g&lt;1&gt;1&quot;, line))

        elif &quot;U_testlogic&quot; in line:
            for line in in_file:
                if &quot;);&quot; in line:
                    break

        else:
            out_file.write(line)

What this does is:

parse each line of the file.
Once the declaration of U_logic is encountered, start a new loop and:

Write each line to the new file until reaching the );. The replacement itself is done by the regex shown which can be observed and modified in this demo.


Once the declaration of U_testlogic is reached, simply skip all lines until );.
All other lines are passed on without change to the new file.


This is just an outline because there might be many more cases to take in count:

What if there are parameters to the modules?
What if the ); is at the same line as the last port?
What if the whole instantiation is on one line?
etc. etc.

I will leave it to you to work-out those details.",,,,,
VHDL variable length arrays without using access types,"In synthesizable VHDL designs, I often need to do a few &quot;software&quot; calculations to convert high-level parameters (generics) into low-level configurations. To do these calculations, it's useful to have basic software tools available, such as dynamic memory allocation.
To clarify, this parameter conversion usually takes the form of a function call that assigns a value to some constant, for example:
    constant internal_config_c  : config_t := calc_low_level_config(params_g);

Therefore, please note that this question is purely about VHDL &quot;software&quot; programming (the stuff that goes inside calc_low_level_config). My question is not about synthesis (the stuff that subsequently uses internal_config_c), and I only mention synthesis because Xilinx Vivado synthesis doesn't support access types, which to me would be the most natural way to create dynamic arrays in VHDL.
Therefore, my question is: What programming constructs are available in VHDL (besides access types) for using (or mimicking) variable sized arrays?
The only possible solution I have been able to come up with is recursion. I don't like this because I find recursive functions tend to be horribly unreadable, so I would be keen to learn about any alternatives.
To illustrate, here is a simplified but complete toy example using access types:
entity top is
generic (
    params_g    : integer_vector := (7, 11, 6)
);
end;

architecture rtl of top is
    
    function internal_calculations(x : natural) return bit_vector is
    begin
        -- Toy example...
        if x mod 3 = 2 then
            return &quot;1101&quot;;
        elsif 7*x mod 5 &lt; 3 then
            return (x-1 downto 0 =&gt; '1');
        else
            return (3*(x/2)-1 downto 0 =&gt; '0');
        end if;
    end function;
    
    function calc_low_level_config(params : integer_vector) return bit_vector is
        type ptr_t is access bit_vector;
        variable data   : ptr_t := new bit_vector'(0 to -1 =&gt; '0');
    begin
        -- Collect variable-length data
        for i in params'range loop
            data := new bit_vector'(data.all &amp; internal_calculations(params(i)));
        end loop;
        
        -- Print
        report to_string(data.all);
        
        return data.all;
    end function;
    
    constant internal_config_c  : bit_vector := calc_low_level_config(params_g);
    
begin
end;


Simulating this in Modelsim prints out the expected result:

vlib work 
vcom -2008 top.vhd 
vsim work.top 
# ** Note: 0000000001101111111

However, the above implementation cannot be synthesized by Xilinx Vivado. Therefore, the only usable option I can think of is recursion, as shown below:
    function calc_low_level_config(params : integer_vector; idx : integer) return bit_vector is
    begin
        if idx = params'high then
            -- Exit condition
            return internal_calculations(params(idx));
        else
            -- Recurse
            return internal_calculations(params(idx)) &amp; calc_low_level_config(params, idx+1);
        end if;
    end function;
    
    constant internal_config_c  : bit_vector := calc_low_level_config(params_g, params_g'low);

Is there a better way?
EDIT: In response to the initial comments below:

The example code above is not intended for synthesis in a real project. I wrote it specifically to illustrate the type of array resizing I want to do. It is my attempt at a minimal but complete (compilable) example.
I am not asking if array resizing is necessary in this hugely simplified example. My question about the VHDL language is primary and the example is very much secondary. Please ignore the example if it is a distraction.
The real examples I have are complicated (involving multiple variable-length arrays inside the same loop, whose length changes are inter-dependent and depend on deeply nested function calls). The verification models that I have written in C++ and MATLAB use variable-size arrays, so I am quite certain I want to also use variable-size arrays in VHDL if possible.
","I think the best answer to this question has been provided by Tricky in the comments above:

The only other way would be to know the length of the whole vector in
advance, and populate the bits by working out the slice ranges. The
recursive form here is probably the least effort. VHDL has no &quot;dynamic
sizing&quot; objects. Even for access types you need to know the length
when you create the object.
",,,,,
Why won't a signal be updated instantly in process statement? VHDL,"In VHDL, you need to use a variable in a process statement for it to be updated instantaneously. The use of a signal can be done, but it won't be updated immediately. Repeating my question from above: Why won't a signal be updated instantly in process statement?","The short answer is the VHDL execution model.   The VHDL execution model does a simulation cycle in two separate steps:  Update and then Execution.  A limited perspective (there are many details that I have abstracted away) of the a simulation cycle is:

During the update phase all signals that will be updated during a simulation cycle are.
When signals are updated and change, processes that are sensitive to a signal changing are marked for execution.
Execute statements and processes that were marked for execution until they encounter either a wait statement or loop back to the process sensitivity list (and the process has one).

Your question is why do this?   It guarantees that every compliant VHDL simulator executes the same code with exactly the same number of simulation cycles and produces the exact same result.
To understand why it would be problematic if signals updated instantaneously, consider the following code:
proc1 : process(Clk)
begin
  if rising_edge(Clk) then
    Reg1 &lt;= A ;
  end if ; 
end process ; 

proc2 : process(Clk)
begin
  if rising_edge(Clk) then
    Reg2 &lt;= Reg1 ; 
  end if ; 
end process ; 

In the above code, if signals updated instantaneously like variables, and the processes ran in the order proc1 then proc2, then in the simulator we would see 1 flip-flop for A to be received by Reg2.   OTOH, if the processes ran in the order proc2 then proc1, then in the simulator we would see 2 flip-flops for A to be received by Reg2.
This is also why shared variables of an ordinary type in VHDL were only introduced temporarily in 1993 and removed in 2000 when a more appropriate feature was able to be introduced (shared variables of a protected type).",,,,,
an array declared as output reg with signals saved into multi flip-flop cannot coesist if the same array is delared into a different modue,"i've this arary(dout) that is passed into a module where there are 8 bit synchronous flip-flops, all works fine, but when i pass dout into another module(b_mux_write) as output reg [7:0] dout(i want to change the signals of dout into another module) is like broken, if i change output reg [7:0] dout to input[7:0] dout, all works fine, why?
//this module is just for declaring the clock and giving the signals 
//value to data, that are passed to the array dout, where every single element
// of dout correspond to a synchronous flip-flop
 module b_tb();
    reg clk;
    reg [7:0] data;
    wire [7:0] dout; 
    
  //Here i call the main module
    b_cpu b_cpu(
        data,
        dout

    );
    initial begin
        //initializing data, i know this is ugly, i'll make it more elegant in the future, i'm trying to create a processor :)
        data[0] = 1;
        data[1] = 1;
        data[2] = 1; 
        data[3] = 1; 
        data[4] = 1; 
        data[5] = 1; 
        data[6] = 1; 
        data[7] = 1; 
        
        clk = 1;

        $dumpfile(&quot;w.vcd&quot;);
        $dumpvars(0,b_tb);

    end 

always #1 clk = ~clk; //Here the clock switching from negative to positive
endmodule

    
//Main
module b_cpu(  
    //input clk ,
    input[7:0] data,
    input [7:0] dout
    );

    reg clk;
    
    fflop fflop(
        clk,
        data,
        dout
    );
    
    b_mux_read b_mux_read(
        clk,
        dout
    );
 

    b_mux_write b_mux_write(
        clk,
        dout
                 
    );
 
    initial begin
        clk = 1;
    end

    always #1 clk = ~clk;
    
    initial begin
        #2;
        $display(&quot;-----------cpu main begin-------&quot;);
        $display(dout[0]);
    end
endmodule
    
    module fflop(  
        input clk ,
        
        input[7:0] data,
        output reg[7:0] dout
        );
        
        //0;
        
        always@(clk) begin //LATCH DO1
            if(clk != 0)
                dout[0] &lt;= data[0];
            else
                dout[0] &lt;= 0;
           // $display(do1);
        end
         
        //1
        
        always@(clk) begin //LATCH DO1
            if(clk != 0)
                dout[1] &lt;= data[1];
            else
                dout[1] &lt;= 0;
           // $display(do1);
        end
    
        //2
        
        always@(clk) begin //LATCH DO1
            if(clk != 0)
                dout[2] &lt;= data[2];
            else
                dout[2] &lt;= 0;
           // $display(do1);
        end
    
        //3
    
        always@(clk) begin //LATCH DO1
            if(clk != 0)
                dout[3] &lt;= data[3];
            else
                dout[3] &lt;= 0;
           // $display(do1);
        end
    
        //4
    
        always@(clk) begin //LATCH DO1
            if(clk != 0)
                dout[4] &lt;= data[4];
            else
                dout[4] &lt;= 0;
           // $display(do1);
        end
    
        //5
    
        always@(clk) begin //LATCH DO1
            if(clk != 0)
                dout[5] &lt;= data[5];
            else
                dout[5] &lt;= 0;
           // $display(do1);
        end
    
        //6
    
        always@(clk) begin //LATCH DO1
            if(clk != 0)
                dout[6] &lt;= data[6];
            else
                dout[6] &lt;= 0;
           // $display(do1);
        end
    
        //7
    
        always@(clk) begin //LATCH DO1
            if(clk != 0)
                dout[7] &lt;= data[7];
            else
                dout[7] &lt;= 0;
           // $display(do1);
        end
    
        initial begin
           #1;
            $display(&quot;----flip-flop----&quot;);
            $display(dout[0]);
        end
    endmodule
    
//if i change output reg to input[7:0] dout the program works fine, but i need 
//the output reg, because i wan't to change the values of dout
module b_mux_write(input clk, output reg[7:0] dout);
endmodule

      
    module b_mux_read(input clk ,input[7:0] dout);
    endmodule

     
","Your dout signal serves as an input to the b_cpu module. The rule of thumb is that this signal can only be read inside this module. You should not try to assign a value to it.
Now, your b_mux_write module just does that, it assigns the value via the output port, which is of a reg type.
As a result, you drive the same signal from two ends: tb and mux_write. I believe that values you see are 'x's just because of this. You need to change your logic and and add some muxes to move your data in a correct direction.
Do not assign internally to 'inputs'. You can try to exploit 'inouts' but I do not think that you need it here.",,,,,
Generate inside always_comb block in SystemVerilog,"I know you can not have a generate inside an always_comb block in SystemVerilog, but I want to do something similar to what I show below and I do not know how I could do it.
genvar i, j;
generate
for (i = 0; i &lt; 4; i++) begin
    always_comb begin 
        unique case (STATE) 
            0: begin
               ...
               for(j = 0; j &lt; 8; j++)
                   var[j*8+2*i+1:j*8+2*i] = 2'b11;
            end
            ...
        endcase

    end
end
endgenerate

Right now it gives me the following compilation error : Unknown range in part select 
Any help would be apreciatted.","
var is a keyword in verilog, it cannot be used as a variable.
genvar j cannot be modified inside an always block.
partselect in system verilog must at least have a constant width.
you missed endgenerate

so, you need to

rename var to something else
declare j as a non-genvar variable, i.e., int
your width is always 2, so you can use the system verilog +: or -: range specifiers
you do not really need generate..endgenerate markers any longer in system verilog.

here is an example:
genvar i;
//generate
  for (i = 0; i &lt; 4; i++) begin: loop
    always_comb begin 
        unique case (STATE) 
            0: begin
               //...
              for(int j = 0; j &lt; 8; j++)
                v[j*8+2*i +: 2] = 2'b11;
                   //v[j*8+2*i+1:j*8+2*i] = 2'b11;
            end
            //...
        endcase
    end
  end
//endgenerate
",,,,,
"During simulation, why do flip-flops take the value preceding the transition while conditional(if) statements take the value after the transition?","As you can see in the cursor below, the if statement looks AFTER the transition (it sees rst = 0 and thus sets a equal to in) rather than seeing rst = 1.
BUT it can also be seen that c takes the value of a BEFORE the transition.
I am wondering why this is. Suppose you want to gate a register with an enable that is delayed on clock cycle, then you can not use if (enable_delayed) because (ideally) the falling transition will happen on the rising edge of the clock and thus not be detected in simulation.
I have not had success finding my problem online. It is hard to explain and search for. Thanks for the help.

Code:
module project_test 
( input logic clk, rst, 
    input logic in,
    output logic a,
    output logic b,
    output logic c
);

always@(posedge clk) 
    if(rst) a &lt;= 1'b0;
    else    a &lt;= in;
always@(posedge clk) 
    if(a) b &lt;= a;
always@(posedge clk) 
    c &lt;= a;

endmodule: project_test

","My guess would be you are setting rst earlier than you think and it is already 0 when the logic inside the module observes the positive clk edge.
If you were to set rst to 0 as a result of a @(posedge clk) things would work as you expect, but I suspect rst is being changed in parallel with clk.
When debugging this sort of thing, I always try to delay the assignment of the values. That is, in your module here replace &lt;= with &lt;= #1 .",,,,,
Verilog Binary Coded Decimal Adder Not Outputting Correctly,"I'm new to Verilog and basically trying to teach myself a Digital Logic Design module for university. I am trying to write a BCD Adder in Verilog using two Full Adders with some logic in between for conversion to BCD when needed.
Here is my code:
module      binary_adder (
    output  [3:0]   Sum,
    output          C_out,
    input   [3:0]   A, B,
    input           C_in
);
    assign  {C_out, Sum} = A || B || C_in;
endmodule

module      BCD_Adder (
    output  [3:0]   Sum,
    output          Carry_out,
    input   [3:0]   Addend, Augend,
    input           Carry_in
);

wire [3:0]  Z, correction;
wire adder1C_out, carryInAdder2, adder2C_out;

    binary_adder adder1 (.Sum(Z), .C_out(adder1C_out), .A(Addend), .B(Augend), .C_in(Carry_in));
    
assign Carry_out = (adder1C_out || (Z[3] &amp;&amp; Z[1]) || (Z[3] &amp;&amp; Z[2]));
assign correction = (Carry_out) ? (4'b0110) : (4'b0000);
assign carryInAdder2 = (1'b0);

    binary_adder adder2 (.Sum(Sum), .C_out(adder2C_out), .A(correction), .B(Z), .C_in(carryInAdder2));

endmodule

For some reason, I keep getting the following outputs:
Submitted: A = 0000, B = 0010, Carry In = 0, Sum = 0001, Carry Out = 0
Expected:  A = 0000, B = 0010, Carry In = 0, Sum = 0010, Carry Out = 0
Submitted: A = 0000, B = 0011, Carry In = 0, Sum = 0001, Carry Out = 0
Expected:  A = 0000, B = 0011, Carry In = 0, Sum = 0011, Carry Out = 0
Submitted: A = 0000, B = 0100, Carry In = 0, Sum = 0001, Carry Out = 0
Expected:  A = 0000, B = 0100, Carry In = 0, Sum = 0100, Carry Out = 0
It basically continues like this for all values. My A, B, Carry In and Carry  Out values always match, but for some reason the output sum is always 0001. I'm not sure where I'm going wrong, the logic seems okay to me. I am very new to this and only know the basics, so any help would be greatly appreciated!
Thanks,
Wes","The logic in binary_adder does not implement addition; as it is currently written, it will just set Sum to 1 if any of A, B or C_in are non-zero.
While there are many architectures of multibit addition (see https://en.wikipedia.org/wiki/Adder_(electronics)#Adders_supporting_multiple_bits), the simplest to understand is the Ripple Carry Adder. It implements several full adders and chains them together to implement addition.
A simple implementation of this architecture looks like this:
module full_add(input A, B, Cin,
                output S, Cout);
  // Basic implementation of a Full Adder (see https://en.wikipedia.org/wiki/Adder_(electronics)#Full_adder)
  assign S = A ^ B ^ Cin;
  assign Cout = A &amp; B | ((A ^ B) &amp; Cin); // Note I use bit-wise operators like | and ^ instead of logical ones like ||; its important to know the difference
endmodule

module add(input [3:0] A, B,
           input Cin,
           output [3:0] S,
           output Cout);

  wire [3:0] Carries; // Internal wires for the carries between full adders in Ripple Carry

  // This is an array instance which just makes [3:0], ie 4, instances of the full adder.
  // Take note that a single Full Adder modules takes in single bits, but here
  // I can pass bit vectors like A ([3:0]) directly which assign full_add[0].A = A[0], full_add[1].A = A[1], etc
  // Common alternatives to using array instances (which are more rare) include generate statements or just instantiate the module X times
  full_add f[3:0](.A(A), .B(B), .Cin({Carries[2:0], Cin}), .S(S), .Cout(Carries));

  assign Cout = Carries[3];
endmodule
",,,,,
Can VHDL alias be created to contain several different concatenated std_logic_vectors?,"The alias is basically an alternative name for something. Now assume that I want to create alternative name for a bunch of things like this:
alias myalias : std_logic_vector(7 downto 0) is a(3 downto 0) &amp; b(1 downto 0) &amp; c &amp; d;

Is this allowed in VHDL? From my understanding, it is not.","Isn't this just a wire?
entity Whatever is port (
  a : in std_logic_vector(32 downto 0);
  b : in std_logic_vector(32 downto 0);
  c : in std_logic,
  d : in std_logic);
end Whatever;

architecture x of Whatever is
  signal myalias : std_logic_vector(7 downto 0);
begin
  myalias &lt;= a(3 downto 0) &amp; b(1 downto 0) &amp; c &amp; d;
end x;
",,,,,
Setting signals length using received parameters in SystemC,"context
I'm making a simulation environment with systemC co-simulated with verilog/VHDL RTL modules using modelsim/questasim
My Verilog modules use parameters to set up each module
My VHDL modules use generics to set up each module
My systemC modules can replicate this using templates if needed.
The following discussion is very alike except I can't use the sc_main because of Modelsim:
Setting the vector length in SystemC with a received parameter
Question
I want to be able to instantiate a systemC module using a verilog parameter
Example
Here is a minimal (not-working) example :
Verilog file
module submodule
#(
    parameter parameter1 = 32
}
(
    input logic clk,
    /* signals (...) */
); 

systemc_module
#(
    .parameter_sc (parameter1 * 2) /* parameter can be modified */
)
systemc_module_0
(
    .clk(clk),
    /* signals (...) */
);

endmodule 

SystemC file
SC_MODULE(systemc_module)
{
    sc_in&lt;sc_logic&gt; clk;
    sc_signal&lt;sc_lv&lt;parameter_sc&gt; &gt; compilation_dynamic_signal;
    // other signals (...)

    SC_CTOR(systemc_module)
    {
        // I can get the parameter at execution time with modelsim :
        int buf;
        sc_get_param(&quot;parameter_sc&quot;, buf)
    }
}

/*Modelsim module export*/
SC_MODULE_EXPORT(systemc_module);
","You cannot do this because your SystemC code gets compiled separately from your Verilog/VHDL code. The concept of generics/parameters is unique to VHDL/Verilog and and does not map directly to C++ templates. At the point where you compile your SystemC code, you do not know how many instances of the SC_MODULE there will be and what their parameter values might be.
The reason the example with sc_main works is because it gets compiled using the C++ compiler where the templatization of the SC_MODULE happens.
choosing appropriate specialized template at runtime",,,,,
What does don't cares and null do in VHDL?,"What does setting a value to don't cares actually mean and do in VHDL? Also what's the difference between setting the values to don't care vs setting it to null?
Here's a snippet from the lab I'm doing:
with selector select
    mux_data_selected &lt;=    Channel_1_registered_data when '0';
                            Channel_2_registered_data when '1';
                            (others =&gt; '-') when others;
","The type of the elements of mux_data_selected is probably std_ulogic or one of the like. To answer your last question, there is no null value in these types, so you cannot assign (others =&gt; null).
null is a void instruction that does nothing and that is sometimes used to indicate that there is nothing to be done in a branch of the control flow and that it is intentional.
It is also a pointer value (access types). Finally we sometimes talk about null arrays but it means that the array has an empty range, like 1 to 0, for instance. If your vector has a non-null range you cannot assign it a null array value, this would cause an error.
The - don't care value is one of the 9 values of the std_ulogic enumerated type. As its name says it is for cases where you do not care about the value. Either because you know this situation will never happen in real life or because when the situation happens you do not use the signal.
A smart enough logic synthesizer can use this indication to implement any actual '0' or '1' value that improves one metric (speed, area, power...) While if you code, e.g., '0' the synthesizer is forced to obey, which could lead to a speed, area or power waste.
As noted by @user16145658 the '-' value is also treated as a match anything wildcard by VHDL2008 STD_MATCH functions and predefined matching relational operators (?=, ?/=, ?&lt;, ?&lt;=, ?&gt;, and ?&gt;=). So you can use it also for soft comparisons.",,,,,
Assign std_logic to a std_logic_vector entity port of size 1,"If I have an entity that has a dataport sig_i specified as follows
ENTITY input_sync IS
  GENERIC(
    signal_width : INTEGER := 1;
    synch_depth  : integer := 1
  );
  PORT(
    clk_i : IN  STD_LOGIC;
    rst_i : IN  STD_LOGIC;
    sig_i : IN  STD_LOGIC_VECTOR(signal_width - 1 DOWNTO 0);
    sig_o : OUT STD_LOGIC_VECTOR(signal_width - 1 DOWNTO 0)
  );
END input_sync;

and I specify the generic signal_width of this instance as 1 I end up with sig_i being
sig_i : in std_logic_vector(0 downto 0);

Is there a possibility to assign a normal std_logic to this port or do I always have to go the extra round of introducing an intermediate std_logic_vector for the assignment?
signal temp : std_logic_vector(0 downto 0);
signal data : std_logic;

temp(0) &lt;= data;

u1 : input_sync
generic map(
  signal_width := 1
)
port map(
  ...
  sig_i =&gt; temp,
  ...
);
","Array ports can be mapped element by element or slice by slice as long as once you start mapping you map all elements contiguously (not necessarily in order though).
u1 : input_sync
generic map(
  signal_width := 1
)
port map(
  ...
  sig_i(0) =&gt; data,
  ...
);
",,,,,
Infinite loop in vhdl,"I am trying to obtain two digit number from a std_logic_vector. I know... it is not a professional way to do that(the way I made it), but I am in  the process of learning.  My real problem is the 'while' loop. I can't figure it out why it is an infinite loop. Anyone who can help?
In testbench the value for d is &quot;10010&quot;;
here is the error and the code:
[Synth 8-3380]loop condition does not converge after 2000 iterations [afisare.vhd:30]

line 30 is while aux&gt;noua loop. I am synthesizing and want to simulate after that
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity bcd is
    port( y0: out std_logic_vector(6 downto 0);
          y1: out std_logic_vector(6 downto 0);
          d: in std_logic_vector(4 downto 0);
          anode: out std_logic_vector(7 downto 0));
end bcd;


architecture afis of bcd is
begin
process(d)
variable prima: integer;
variable aux: std_logic_vector(4 downto 0);
variable din: std_logic_vector(3 downto 0);
variable noua: std_logic_vector(4 downto 0);
variable unu: std_logic;
variable zero: std_logic;
begin
prima:=0;
noua:=&quot;01001&quot;;
aux:=d;
unu:='1';
zero:='0';
while aux&gt;noua loop
    if (aux(4)=unu and aux(3)=zero)  then
        aux(4):=zero;
    end if;
    if (aux(1)=unu and aux(0)=zero)  then
            aux(1):=zero;
     end if;
    aux:=aux xor noua;
    prima:=prima+1;
end loop;
din:=aux(3 downto 0);

case din is
    when &quot;0000&quot;=&gt; y0&lt;=&quot;0000001&quot;;
       when &quot;0001&quot;=&gt;y0&lt;=&quot;1001111&quot;;
       when &quot;0010&quot;=&gt;y0&lt;=&quot;0010010&quot;;
       when &quot;0011&quot;=&gt;y0&lt;=&quot;0000110&quot;;
       when &quot;0100&quot;=&gt;y0&lt;=&quot;1001100&quot;;
       when &quot;0101&quot;=&gt;y0&lt;=&quot;0100100&quot;;
       when &quot;0110&quot;=&gt;y0&lt;=&quot;0100000&quot;;
       when &quot;0111&quot;=&gt;y0&lt;=&quot;0001111&quot;;
       when &quot;1000&quot;=&gt;y0&lt;=&quot;0000000&quot;;
       when &quot;1001&quot;=&gt;y0&lt;=&quot;0000100&quot;;
       when others=&gt;y0&lt;=&quot;0110110&quot;;
end case;
case prima is 
when 0=&gt;y1&lt;=&quot;0000001&quot;;
when 1=&gt;y1&lt;=&quot;1001111&quot;;
when 2=&gt;y1&lt;=&quot;0010010&quot;;
when 3=&gt;y1&lt;=&quot;0000110&quot;;
when others=&gt;y1&lt;=&quot;0110110&quot;;
end case;
anode&lt;=&quot;11111100&quot;;
end process;

end afis;
","The synthesizer does not care about the testbench, it tries to create a piece of hardware that would be equivalent to your loop and would work for any possible input. And in order to do this it somehow tries all possibilities (32). Unfortunately it is apparently not smart enough to detect that this loop always terminates in at most 3 iterations (not sure of this &quot;3&quot;, I may be wrong).
Generally speaking, for synthesis, it is better to use loops with caution (static bounds of for loops, static condition of while loops). In this case it is difficult to say if you are beyond Vivado's capabilities or not. If the documentation says that non-static conditions of while loops are supported for synthesis you can open a service request, you found a bug.
Anyway, it would be better to describe this differently. Try maybe to fix the number of iterations (after verifying by simulation or plain reasoning that 3 is enough, of course, I am just guessing):
for i in 1 to 3 loop
  if aux&gt;noua then
    if (aux(4)=unu and aux(3)=zero) then
      aux(4):=zero;
    end if;
    if (aux(1)=unu and aux(0)=zero) then
      aux(1):=zero;
    end if;
    aux := aux xor noua;
    prima:=prima+1;
  end if;
end loop;
",,,,,
VHDL What does it mean when variable take a value immediately and signal take their value at the end of the process?,"I'm confused about a paragraph from my lab reading:
Snippet from reading
Recall that variables like rst_meta take on their value immediately, whereas signals 
take on their assignment when the process suspends in this case, at the process sensitivity
list. This implies that the ordering of the signal assignments will change the  behavior of
the code. 

I'm confused about what they mean by variables take their values immediately and signals take their value after the process. They also mentioned that whether a variable comes before or after a signal also makes a difference, but I don't know what effect that does.
Here's the code they tried to implement:
Code snippet
entity reset_bridge is
    Port ( clk_dst : in STD_LOGIC;
           rst_in : in STD_LOGIC;
           rst_out : out STD_LOGIC);
end reset_bridge;

architecture Behavioral of reset_bridge is
    --signal rst_meta : std_logic;
begin
    process (clk_dst,rst_in)
        variable rst_meta : std_logic;
    begin
        if rst_in = '1' then
            rst_meta := '1';
            --rst_meta &lt;= '1';
            rst_out  &lt;= '1';
        elsif rising_edge(clk_dst) then
            --rst_meta &lt;= '0';
            rst_out &lt;= rst_meta;
            rst_meta := '0';
        end if;
    end process;

end Behavioral;

Edit:
The reading is on metastability and the circuit they're trying to implement is a double FF.
Link to image","I don't think that saying, &quot;This implies that the ordering of the signal assignments will change the behavior of the code&quot; is accurate for your use case.
Consider the following code:
architecture Forward of AFewFlipFlops is
    signal r1, r2, r3: std_logic;
begin
    process (clk_dst)
    begin
        if rising_edge(clk_dst) then
            r1 &lt;= A_in ;
            r2 &lt;= r1 ;
            r3 &lt;= r2 ;
            rst_out  &lt;= r3;
        end if;
    end process;

The above creates the same hardware as:
architecture Reverse of AFewFlipFlops is
    signal r1, r2, r3: std_logic;
begin
    process (clk_dst)
    begin
        if rising_edge(clk_dst) then
            rst_out  &lt;= r3;
            r3 &lt;= r2 ;
            r2 &lt;= r1 ;
            r1 &lt;= A_in ;
        end if;
    end process;

OTOH, if r1, r2, and r3 were variables, then architecture Reverse would produce the same results as the signal based architectures, but Forward would not - it would create only 1 flip-flop.  And it would not be due to the ordering of the signals, it would be due to the ordering of the variables.
If we consider a slightly different circuit, then we can see a variable being the invariant (as long as we are using it to create combinational logic) and here the signal ordering is important.
In architecture JunkySignalCode, if we change the order of the conditionals Add1 and Add2, then we impact the result as here last executed signal assignment wins.
architecture JunkySignalCode of JunkyMath is
    signal A : unsigned(7 downto 0) ;
begin
    process (clk_dst,rst_in)
    begin
       if rising_edge(clk_dst) then
         if rst_in = '1' then
             A &lt;= (others =&gt; '0') ;
         else
           if Add1 = '1' then 
             A &lt;= A + 1 ; 
           end if ; 
           if Add2 = '1' then 
             A &lt;= A + 2 ; 
           end if ; 
         end if;
       end if;
    end process;

OTOH, in architecture JunkyVariableCode, if we change the order of the conditionals Add1 and Add2, then the result is indeed the same.
architecture JunkyVariableCode of JunkyMath is
    signal A : unsigned(7 downto 0) ;
begin
    process (clk_dst,rst_in)
      variable ATemp : unsigned(7 downto 0) ; 
    begin
       if rising_edge(clk_dst) then
         if rst_in = '1' then
            ATemp  := (others =&gt; '0') ;
         else
           if Add1 = '1' then 
             ATemp  := ATemp + 1 ; 
           end if ; 
           if Add2 = '1' then 
             ATemp  := ATemp + 2 ; 
           end if ; 
         end if;
         A &lt;= ATemp ; 
       end if;
    end process;

One generality I see is that every signal assignment in a clocked process always creates a flip-flop.   Variable assignments in a clocked process may or may not create a flip-flop depending on the order of the assignments.
In JunkyMath, most of the time, the if then end if followed by if then end if  would be better understood as if then elsif then end if.  However, for the variable case here we ended up with an interesting exception to that rule.",,,,,
"VHDL - Why is it bad practice to not include an else-condition in a ""process"" block?","I'm watching a beginner tutorial on VHDL. The lecturer says that it's bad practice to not include an else-condition inside a &quot;process&quot; block because it will create a latch and is bad for timing in advance circuits. He said that including an else-condition will create a mux instead and is better to use in most case.
Why is that?
snippet from lecture video
Why is a latch design bad for timing and what makes the mux design better?","The point is to make VHDL code that results in the design you want, and the risk is that you will inadvertently create a latch.
There are several basic constructions in VHDL, that can illustrate this.
Mux by process with if-then-else, can be made with this code:
process (all) is  -- Mux
begin
  if sel = '0' then
    z &lt;= a;
  else
    z &lt;= b;
  end if;
end process;

Mux by process with if-then and default assign, can be made with this derived code:
process (all) is  -- Mux
begin
  z &lt;= b;  -- Default b, thus for sel = '1', since no overwrite
  if sel = '0' then
    z &lt;= a;
  end if;
end process;

However, if you want to make a mux, then a better coding style is by continuous assign with this code:
z &lt;= a when (sel = '0') else b;

Finally, what can lead to a latch with a process, is if the resulting output is not assigned in all branches of the code.  That can occur, if the if-then does neither have an else, nor a default assign to the output, like this code:
process (all) is  -- Latch
begin
  if en = '1' then
    q &lt;= d;
  end if;
end process;

So a good rule when designing combinatorial logic using a process, is to have an initial line that makes a default assignment to the resulting output, for example just assing undefined 'X'.  A latch is thereby avoided, and functional verification should catch the undefined 'X', if this is a bug.
Also, remember to check the syntheis report for warnings about created latches, since that is most likely a bug in the design.",,,,,
Block Memory on Machxo 2280C always reads Zeros,"So I needed a couple of kB of SRAM on my timing generator project. Since it was not working, I decided to write a dedicated program with a bunch of delays an output word for my logic analyzer to capture (directly connected to the Q of the RAM_DP block and in frustration I've wired it up as below:
My RAM_DP block
I've tried holding write enable high for some mS or even just one cycle(verified by disconnecting my output array and tying a bit to the signal and watching it with the logic analyzer, which pulses as expected). I have also verified the data to write is non-zero.
No matter what I do, Q always remains zero, what am I doing wrong? Must be something pretty obvious for me to miss it. Code below:
Ram_Dq_Buffer Buffer  (sram_address,sram_address,s_write_data,s_writeEnable,osc_clck, 1'b1,1'b0,osc_clck, 1'b1,s_read_data ) ;

always @(posedge osc_clk )
begin
    if (sram_state==0)
        begin
            //Initialize
            s_writeEnable&lt;=0;   
            //sram_Clock_EN &lt;=1;
            //sram_reset &lt;=0;
            sram_address&lt;=511;
            delay&lt;=0;
            sram_state&lt;=1;
            counter&lt;=counter+1;
            s_write_data&lt;=counter;
        end
    if (sram_state==1)
        begin
            delay&lt;=delay+1;
            if (delay&gt;20000)
                begin
                    delay&lt;=0;
                    sram_state&lt;=2;                      
                end
        end
    if (sram_state==2)
        begin
            s_writeEnable&lt;=1;
            delay&lt;=delay+1;
            if (delay&gt;20000)
                begin
                    delay&lt;=0;
                    sram_state&lt;=3;
                    
                end
            
        end
    if (sram_state==3)
        begin
            s_writeEnable&lt;=0;
            delay&lt;=delay+1;
            if (delay&gt;20000)
                begin
                    delay&lt;=0;
                    sram_state&lt;=4;
                    
                end
        end
    if (sram_state==4)
        begin
            delay&lt;=delay+1;
            if (delay&gt;20000)
                begin
                    delay&lt;=0;
                    sram_state&lt;=0;
                    mydata&lt;=s_read_data;
                end
        end
        
end

I'm using the internal oscillator just for testing; around a 20MHz clock, but the timing seems well within the allowable timings. I've checked the IP express generated block and that seems fine.","You seem to be using osc_clck in one place and osc_clk in another. Beware that by default, Verilog automatically creates undefined signals - this will usually produce a warning, but you can make it into an error with &quot;`default_nettype none&quot;",,,,,
How can I reduce a lvalue bus without an extra signal?,"I have a module with a multi-bit signal:
output  logic [2:0]  tuser,

In the module instantiating it, I only have a single bit signal and it should be the reduction OR* of the modport.

Is there a way to do a reduction-OR (|sig) directly with the streaming operator {&gt;&gt;{}} or any other technique?

Example: (obviously wrong)
logic single_bit;
 .tuser  ({&gt;&gt;{|single_bit}})
 .tuser  ({|&gt;&gt;{single_bit}})
 .tuser  (|single_bit)

I'm trying here to use the language's power here instead of having a separate signal just to do the reduction.",Unfortunately SystemVerilog does not have the syntax that expresses what you want to do. The only operators defined to work as the target of an assignment (known as an lvalue) are concatenation and the streaming operators. Those only map positional bit associations. You have to define an extra signal for anything beyond that.,,,,,
how to change DVT eclipse menu font-size,"I need to change DVT eclipse menu size. also in properties view and Project Explorer.
High DPI make them larger than the code font size.
Although this soultion did work it was complicated and change only the Project Explorer (without Menu and Project)
DVT Version - dvt_eclipse_20.1.37-e46 
","As mentioned in DVT &quot;Themes&quot; documentation page.
To change the fonts, please go to Window &gt; Preferences &gt; DVT &gt; Themes.
You will find there the option to change both the Editor Font and the UI Font (the second one is what you are looking for)
",,,,,
Null item error when placing factory registration within a function,"I'm trying to write a function that creates registers an item with the factory then does some basic operations to that item. The problem I'm having is that when I try to execute this code, I get a null item error.
An example excerpt of the code I'd like to have would be:
modified_sequence_item example_msg_item

function new (string name = ex_sequence);
  super.new(name); 
  create_message(example_msg_item, &quot;example_msg_item&quot;, 32'hDEADBEEF);
endfunction

function create_message(modified_sequence_item msg_item, string msg_name, bit[31:0] data);
    msg_item = modified_sequence_item::type_id::create(msg_name);
    msg_item.data_field = data;
endfunction

Unfortunately, this doesn't work. I get the following error:
UVM_FATAL @ 5710: reporter [NullITM] attempting to start a null item from sequence 'main'
However, the following code does work:
modified_sequence_item example_msg_item

function new (string name = ex_sequence);
  super.new(name); 
  example_msg_item = modified_sequence_item::type_id_create(&quot;example_msg_item&quot;);
  example_msg_item.data_field = 32'hDEADBEEF;
endfunction


Looking at these two bits of code, to me they are nearly identical aside from the actions being nested inside a function in the first bit of code. This leads me to believe the issue is most likely an issue with passing data being the functions.
Does anyone have any recommendations on how I could modify the first code example so that it does not have a null item error?","Two problems with your function declaration:

The handle that you are creating inside your function needs to be copied out when exiting the function, so msg_item needs to be declared as an output argument.
You forgot to declare the return type as void. Otherwise the default is a 1-bit 4-state result (IEEE Std 1800-2017, section 13.4 Functions: implicit_data_type)


function void create_message(
                             output modified_sequence_item msg_item, 
                             input string msg_name, bit[31:0] data);
  msg_item = modified_sequence_item::type_id::create(msg_name);
  msg_item.data_field = data;
endfunction
",,,,,
How to write a behavioral level code for 2to4 decoder in verilog?,"I want to write a behavioral level code for 2 to 4 decoder using for loop in Verilog.  This is what I tried, but I always seem to get the output as 0:
module decoder2x4Beh(a,e,q);
input e;
input [1:0]a;
output reg [3:0]q;
integer int_a,i;
always @(a) int_a = a;
initial begin
if(e) begin
 for(i=0;i&lt;4;i=i+1) begin
  if(int_a==i)begin
  q[i] = 1'b1;
  end
 end
end
else q=4'b0;
end
endmodule

This is my testbench:
module testDecoder2x4();
reg e;
reg [1:0]a;
wire [3:0]q;
//decoder3x8 dec1(.d(d),.y(y));
//decoder2x4_df dec2(.a(a),.e(e),.q(q));
decoder2x4Beh dec3(.a(a),.e(e),.q(q));
integer k;
initial
begin
{e,a} = 3'b0;
$monitor($time,&quot; enable %b input code = %b   output q3 %b q2 %b q1 %b q0 %b&quot;,e,a,q[3],q[2],q[1],q[0]);
for(k=0;k&lt;16;k=k+1)
begin
#10 {e,a} = k;
end
end
initial
#120 $stop;
endmodule
","You have a few issues:

your action code in decoder2x4Beh is executed only once at time 0 because you put in in the initial block. Instead it should be a part of an always block. For example

always @* begin
   if(e) begin
      for(i=0;i&lt;4;i=i+1) begin
         if(int_a==i)begin
            q[i] = 1'b1;
         end
      end
   end
   else 
     q=4'b0;
end


{e,a} = k, will only set enable for some of the sequences. I think that you should provide a reset at the beginning of the tb and then have 'e' asserted through the simulation process.

You'd better use always @* to avoid issues with incomplete sensitivity lists.

You should started using clocks in your design.

Good indentation would help reading your program.

",,,,,
NAND gate not working properly in this HDL?,"Whenever I input a = 1 and b = 1 I still get 0 and my inner pin of aAndNotb shows 1, however if I delete the Not gate I get a normally functioning Nand gate, what's the deal?
/**
 * And gate: 
 * out = 1 if (a == 1 and b == 1)
 *       0 otherwise
 */

CHIP And {
    IN a, b;
    OUT out;

    PARTS:
    // Put your code here: 
    Nand(a=a, b=b, out=aAndNotb);   
    Not(in=aAndNotb, out=out);
}
","Given the symptoms you describe, the problem appears to be in your Not gate. Perhaps that component is not correctly implemented?
You can test this by implementing the Not gate directly using a Nand gate, which if you've implemented a Not gate, you already know how to do.
If that works, then the issue is the Not gate implementation. If it doesn't, then the issue is the wiring of the gates for some reason (but they look OK to me).",,,,,
How to connect enable port to 4x1 MUX in verilog?,"I am trying to implement 4x1 multiplexer in Verilog. I want to connect enable (en) as a port which input '1'(high) can ON the MUX and '0'(low) turn OFF this multiplexer.
Please suggest some modifications in my code.
Thanks in Advance.
module mux_4_to_1(
    input d,c,b,a,      //Inputs
    input s1,s0,               //Select Lines
    input en,                  //enable
    output reg y                   //output
    );

always @ (*)
begin
    case (s0 | s1)
    2'b00 : y &lt;= a;
    2'b01 : y &lt;= b;
    2'b10 : y &lt;= c;
    2'b11 : y &lt;= d;
    default : y &lt;= 0;
    endcase
end
endmodule
","You want en to act as a global switch to turn on or off the mux, so it gets the highest priority.
always @ (*)
begin
    if (en) begin
        case ({s0, s1})  // pay attention here
        2'b00 : y = a;
        2'b01 : y = b;
        2'b10 : y = c;
        2'b11 : y = d;
        default : y = 0;
        endcase
    end
    else begin
        y = 1'b0;  // your question didn't specify the expected output when OFF
    end
end

Please notice I've changed case (s0 | s1) to case ({s0, s1}).
s0 | s1 returns a 1-bit wide result, while you need the concatenation of s0 and s1.
Also, I replaced all NBA &lt;= by BA =.
And, the default branch actually couldn't happen in silicon because you've specified all possible combinations. But if you think it maybe helpful in simulation, you may leave it.",,,,,
Unpacking a vector into an array of a certain bit width,"Suppose I have a vector of bits. I'd like to convert it into an array of n bit values, where n is a variable (not a parameter). Can I achieve this using the streaming operators? I tried this (right now I'm just trying a value of 3, but eventually '3' should be variable):
module tb;
  bit [51:0] vector = 'b111_110_101_100_011_010_001_000;
  byte vector_byte[];
  
  initial begin
    $displayb(vector);
    vector_byte = {&lt;&lt;3{vector}};
    foreach(vector_byte[i])
      $display(&quot;%0d = %0b&quot;, i, vector_byte[i]);
  end
endmodule

What I was expecting was:
vector_byte = '{'b000, 'b001, 'b010 ... 'b111};

However, the output I got was:
# vsim -voptargs=+acc=npr
# run -all
# 00000000000000000000000000000000111110101100011010001000
# 0 = 101
# 1 = 111001
# 2 = 1110111
# 3 = 0
# 4 = 0
# 5 = 0
# 6 = 0
# exit

Am I just using the streaming operators wrong?","The streaming operators only work with contiguous streams. You need 5'b00000 inserted into each byte.
module tb;
  bit [51:0] vector = 'b111_110_101_100_011_010_001_000;
  int W = 3;
  byte vector_byte[];
  
  initial begin
    vector_byte = new[$bits(vector)/3];
    $displayb(vector);
    foreach(vector_byte[i]) begin
      vector_byte[i] = vector[i*W+:8] &amp; (1&lt;&lt;W)-1; // mask W is in range 1-8
      $display(&quot;%0d = %0b&quot;, i, vector_byte[i]);
    end
  end
endmodule
",,,,,
Error while using always block for half adder: sum is not a valid l-value,"module halfadder(a,B,sum,carry);
input a,B;
output sum,carry;
always@(a,B)
  begin
     sum=a^B;
     carry=a&amp;B;
  end
endmodule

For the above code, I am getting error:
: sum is not a valid l-value in tb_halfadder.ha.
: sum is declared here as wire.
: carry is not a valid l-value in tb_halfadder.ha.
: carry is declared here as wire.
","sum and carry are not valid l-values because they are driven in a always block. They should be declared as reg.
reg sum, carry;

When a port is not declared with a type, it automatically gets a type of wire.",,,,,
Automatically constrain string size using initialization in VHDL,"I'm working with VHDL, and I'm wondering if there is any way to constrain the string size when declaring it, using initialization. For example, we declare a string as follow:
variable sequence : string(1 to 20) := &quot;AGTAACCAATTCGCATTCGC&quot;;

I would like to know if there is any way to do something like:
variable sequence : string := &quot;AGTAACCAATTCGCATTCGC&quot;;

Of course, second line isn't valid, because interpreter says:
[VRFC 10-1547] variable cannot be unconstrained
","Constants don't have to be constrained, so you could do this:
constant Csequence : string := &quot;AGTAACCAATTCGCATTCGC&quot;;
variable Vsequence : string(Csequence'range) := Csequence;


https://www.edaplayground.com/x/r3wK
entity E is
end entity E;

architecture A of E is
begin
  process
    constant Csequence : string := &quot;AGTAACCAATTCGCATTCGC&quot;;
    variable Vsequence : string(Csequence'range) := Csequence;
  begin
  wait;
  end process;
  
end architecture A;
  
",,,,,
System verilog constraint for uniform address pattern,"I want to add a constraint on &quot;rand bit [7:0] addr[10]&quot; such that we have address generated in uniformly increasing order from 0th index to 5th and uniformly decreasing order from 6th to last index. I am new to SV constraints, can someone help with ways to do this.","class A;
  rand bit [7:0] addr[10];
  rand int step; // this needs to be an int to catch underflow/overflow
  constraint uniform {
     foreach (addr[index]) {
        index inside {[0:4]} -&gt; addr[index] + step == addr[index+1];
        index inside {[6:8]} -&gt; addr[index] - step == addr[index+1];
     }
     step inside {[1:25]};
  }
endclass
",,,,,
Add ignore_bins To Already Defined Coverpoints,"I am working with already generated coverpoints and covergroups. I have a way to access all the coverpoints in the covergroup through an  `include file, but cannot edit the coverpoints directly.
covergroup cg_FOO;
  apple: coverpoint Atype_e'(sample.apple.value);
  kiwi: coverpoint Ktype_e'(sample.kiwi.vale);

  `ifdef MY_COV
    `include &quot;cg_FOO.svh&quot;
  `endif
end group: cg_FOO

cg_FOO.svh is an example for this covergroup, but with another generated covergroup I have a separate associated file. I define all sorts of crosses and non-generated coverpoints in these  `included files. However, I also want to specify certain enum values for coverpoints apple and kiwi that may not be valid for cg_FOO.
If I was able to change each coverpoint, I would just do the following:
apple: coverpoint Atype_e'(sample.value) {
  ignore_bins ignore_FUJI = apple with (FUJI);
}

But, including a separate file into each coverpoint of each covergroup is messy and not feasible.
Everything I have found thus far makes it seem like I need to specify an ignore_bin inside a coverpoint structure. How could I ignore certain bins of a coverpoint from within my cg_FOO.svh file (ie in the covergroup, but not changing all the generated coverpoints)?
Note, I also have 2 other  `include files to work with, one outside the covergroups but inside the class that contains them (I am using this file for macro, variable, and function definitions), and another file to define helping logic just before the covergroups get sampled (ie when sample gets defined).","You're out of luck unless the tool you are using gives you an API to access and modify the coverage database. Bins are very difficult to access because they have no easy names to reference them, you have to scan through them. It's very easy to exclude coverpoints externally by setting their weights to 0.
Without knowing exactly what your coverage model looks like, it's hard to give you a better answer.",,,,,
No actual for constant interface in vhdl,"I have the following entity, core, containing one of my components, generator. I pass generator a signal that is made from the sum of the generic m_r of core and the signal start of core.
However upon trying to compile this, I get the error  error: no actual for constant interface &quot;m_r&quot; pointing me to the line generator_imp : generator. I assume it has something to do with start_generator being composed of m_r, however even after googling for a few hours, I have been able to find very little related to this specific problem. Has anyone encountered something like this before?
File the error stems from:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.my_components.all;

entity core is
  generic (
    m_r : unsigned(31 downto 0)  := x&quot;00000001&quot;;
    step  : unsigned(31 downto 0)
  );
  port (
    clk              : in std_logic;
    reset            : in std_logic;
    start            : in unsigned(31 downto 0);
    f                : out std_logic
  );
end core;

architecture arch of core is

  signal start_generator       : unsigned(31 downto 0) := x&quot;00000000&quot;;
  signal n                     : std_logic;

begin

  start_generator &lt;= m_r + start;

generator_imp : generator
  generic map(
    step  =&gt; step
  )
  port map(
    clk               =&gt; clk,
    start             =&gt; start_generator,
    reset_in          =&gt; reset,
    padded_message    =&gt; padded_chunk,
    n                 =&gt; n
  );

end arch;



my_components package:
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package my_components is


    component generator is
        generic (
          step  : unsigned(31 downto 0)
        );
        port (
          clk                 : in    std_logic;
          start               : in    unsigned(31 downto 0);
          reset_in            : in    std_logic;
          padded_message      : out   std_logic_vector(511 downto 0);
          n                   : out   unsigned(31 downto 0)
        );
    end component;
end package my_components;


Additionally, the entity core is generated within another component &quot;all&quot; using a for generate loop, as described below. It is also part of the my_components package, but for the sake of keeping this code overseeable I have removed it after thouroughly checking that all port names in the component match the entity. The for-generate loop works like below:
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.my_components.all;

entity all is
  port (
    clk : in std_logic
  );
end all;

architecture Behavioral of all is

  constant count : integer := 5;
  type f_array is array (0 to count -1) of std_logic;
  signal f_signals : found_array;

  signal reset         : std_logic := '0';

  signal start         : unsigned(31 downto 0) := x&quot;11111111&quot;;
begin

  generate_cores : for I in 1 to mining_core_count - 1 generate
    core_imp: core
      generic map(
        m_r =&gt; to_unsigned(I,32),
        step  =&gt; to_unsigned(count, 32)
      )
      port map(
        clk           =&gt; clk,
        reset         =&gt; reset,
        start         =&gt; start,
        f             =&gt; f_signals(I)
      );
  end generate;

  core_zero : core
  generic map(
    m_r =&gt; x&quot;00000000&quot;,
    step  =&gt; to_unsigned(count, 32)
  )
  port map(
    clk           =&gt; clk,
    reset         =&gt; reset,
    start         =&gt; start,
    f             =&gt; f_signals(0)
  );

end Behavioral;


","Could this be cause by the fact that signal 'start_generator' is an arithmetic operation on a concurrent part? This could cause this signal be seen as non-constant or stable as an input port.
Just thinking loud..",,,,,
Report throwing type mismatch error at elaboration,"I'm trying to debug some errors that are causing some variable width mismatch issues (the adding stage below).
To do this, I want to use report statements to output some variables used in the calculations of these variable widths.
However, for some reason, even the most simple report statement:
report &quot;this is a message&quot;;

Is throwing this error:

syntax error near report


error type void does not match with a string literal

Any idea what could be causing this?

I'm using VHDL2008 in Xilinx Vivado.
The whole source file for reference:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.All;
use IEEE.math_real.all;
use work.functions.all;


entity averager is
    generic
    (
        buffer_len: positive := 32; -- MUST BE A POWER OF 2
        input_max: positive := integer'high / buffer_len -- Maximum value of one data input
    );
    port 
    (
        clk : in STD_LOGIC;
        tri : in STD_LOGIC; 
        reset: in std_logic;       
        data_in : in unsigned (get_min_counter_width(input_max) - 1 downto 0);
        avg_out : out unsigned (get_min_counter_width(input_max) - 1 downto 0)
     );
end averager;

architecture behavioral of averager is
    
    -- TODO - Add assert that buffer_len is power of 2


    constant input_width: positive := get_min_counter_width(input_max);
    constant accum_width: positive := get_min_counter_width(input_width * buffer_len); -- Done at synthesis time, perfomance non-critical
    constant avg_bitshift: positive := integer(ceil(log2(real(buffer_len)))); -- How much bitshift is needed for fast divide
    
    signal last_tri: std_logic := '0';
    
    subtype in_val is unsigned(input_width - 1 downto 0);
    type acc_buffer is array(buffer_len - 1 downto 0) of in_val;
    
    constant in_zero: in_val := to_unsigned(0,input_width);
    signal in_buffer: acc_buffer; -- Initialised in reset

    type state is (rst, idle, adding, writing);
    signal current_state: state := rst;
    signal next_state: state := rst;
    
    constant accum_zero: unsigned(accum_width - 1 downto 0) := to_unsigned(0,accum_width);
    signal accumulator: unsigned(accum_width - 1 downto 0) := accum_zero;
    

begin


    sync_proc: process(clk)
    begin
       if (rising_edge(clk)) then
           if (reset = '1') then
               last_tri &lt;= '0';
                current_state &lt;= rst;
            else
                last_tri &lt;= tri;
                current_state &lt;= next_state;
                if (last_tri = '0' and tri = '1') then
                    in_buffer &lt;= in_buffer(in_buffer'high downto in_buffer'low + 1) &amp; in_val(data_in);
                end if;
            end if;
        end if;
    end process;
    
    next_state_decode: process(current_state, tri)
    begin
       next_state &lt;= current_state;
       case(current_state) is
           when rst =&gt;
               next_state &lt;= idle;
           when idle =&gt; 
               if (last_tri = '0' and tri = '1') then
                   next_state &lt;= adding;
               end if;
           when adding =&gt;
                   next_state &lt;= writing;
           when writing =&gt;
                   next_state &lt;= idle;     
       end case;
    end process;
    
    output_decode: process(current_state)
    begin
       next_state &lt;= current_state;
       case(current_state) is
           when rst =&gt;
               next_state &lt;= idle;
               for i in in_buffer'high downto 0 loop
                    in_buffer(i) &lt;= in_zero;
               end loop;
           when idle =&gt; 

           when adding =&gt;
               for i in in_buffer'high downto 0 loop
                    accumulator &lt;= unsigned(accumulator) + resize(unsigned(in_buffer(i)),accum_width);
               end loop;
           when writing =&gt;
                   avg_out &lt;= accumulator(accumulator'high downto accumulator'low + avg_bitshift);     
       end case;
    end process;
    
    
    report &quot;this is a message&quot;;
    


end behavioral;
","A report statement is a sequential statement and can be used in sequential blocks only.
You can't use a report statement in architecture code, which is for concurrent statements only.
A report statement is a sequential statement by itself.
An assert statement can be used in concurrent blocks. The message in the report clause of the assertion will be printed if the assertion is false.
VHDL has a constant, false, of boolean type which has the value False. So if an assert false is used, the message in the report clause will be printed always.
So an assert false report &quot;your message&quot;; can also be used if you want to print a message in a concurrent block.",,,,,
What could be an equivalent approach to a casex statement from SystemVerilog in C,"Some context: I'm currently writing an emulator. I'm trying to implement a decoder with similar behavior such as a 'casex' statement on SystemVerilog.
To give some examples these are some of the instructions.
BNE_ENCODING        0b100011xx
BRK_ENCODING        0b10101100
CMP_ENCODING        0b01110000
DEC_ENCODING        0b1001xxxx

What I tried: I tried replacing the x with zeros. But that Didn't work.
I don't understand how to ignore the last bit on C, without creating conflicting case statements. The x represents the ignored bits. I tried to understand a bit of the implementation by looking at the generated RTL output from Quartus(I know RTL has nothing to do with C, it's just to give me an idea of the boolean expressions that I could implement). The decoder is implemented with NOR gates.
Part of the decoder on System Verilog.
casex(op)
        8'b100011xx: /* Do something */;
        8'b10101100: /* Do something */;
        8'b01110000: /* Do something */;
        8'b1001xxxx: /* Do something */;
endcase

Question: What would be the right approach to implement such a decoder in C? By decoder I mean a switch statement with similar behavior as the Verilog casex statement.","Ignoring some bits can be done by masking them with bitwise AND operation.
if ((op &amp; 0xFC) == 0x8C) {
    /* 8'b100011xx */
} else if ((op &amp; 0xFF) == 0xAC) {
    /* 8'b10101100 */
} else if ((op &amp; 0xFF) == 0x70) {
    /* 8'b01110000 */
} else if ((op &amp; 0xF0) == 0x90) {
    /* 8'b1001xxxx */
}

If you will stick to use switch statement, you can use multiple levels of ones.
switch (op &amp; 0xF0) {
    case 0x80: /* 8'b1000xxxx */
        switch (op &amp; 0x0C) {
            case 0x0C: /* 8'bxxxx11xx (8'b100011xx) */
                break;
        }
        break;
    case 0xA0: /* 8'b1010xxxx */
        switch (op &amp; 0x0F) {
            case 0x0C: /* 8'bxxxx1100 (8'b10101100) */
                break;
        }
        break;
    case 0x70: /* 8'b0111xxxx */
        switch (op &amp; 0x0F) {
            case 0x00: /* 8'bxxxx0000 (8'b01110000) */
                break;
        }
        break;
    case 0x90: /* 8'b1001xxxx */
        break;
}
",,,,,
How do I create and use a Task in Verilog,"I have recently been playing with the Arduino MKR Vidor 4000, and I have run into a small problem.
I want to be able to reuse code (like with a function in C++) and have the defined variables local to the piece of code, so they don't interact. I have come across Tasks in Verilog, and these seem to be the correct way of doing this.
The problem is, I can't get Quartus to compile it. It just reports an error:

Error (12006): Node instance &quot;comb_6&quot; instantiates undefined entity
&quot;test&quot;. Ensure that required library paths are specified correctly, define the specified entity, or change the instantiation. If this entity represents Intel FPGA or third-party IP, generate the synthesis files for the IP.

Here is my code:
task automatic test(input [3:0] in, output [3:0] out);
   reg [3:0] temp;
   assign temp[0] = in[0];
   assign out[0] = temp[0];
endtask
test(bMKR_D[4:1], bMKR_D[8:5]);

This is included by a file which defines the available MKR Vidor pins.
Edit: Here is a minimal reproducible example... I think
module MKRVIDOR4000_top
(
  // Input definitions available for the MKR Vidor 4000
);
// Other signal declarations

// My code
task automatic test(input [3:0] in, output [3:0] out);
    reg [3:0] temp;
    assign temp[0] = in[0];
    assign out[0] = temp[0];
endtask
test(bMKR_D[4:1], bMKR_D[8:5]);

endmodule

From what I gather from the comments, I shouldn't be using any assigns inside a task. And I should also only call tasks from inside an always/begin-end/initial etc.
If I can't use tasks this way, what should I do to create reusable code in order to make basic logic gates, that can be synthesised? E.g a register bank","I have put the code I wanted to be able to reuse in a module, and it works okay now!
I am not sure if this is what I should be doing, so if anyone has a better way to do it, then I'm all ears!
I have, effectively, done this:
module test (input [3:0] in, output [3:0] out);
reg [3:0] temp;
assign temp[0] = in[0];
assign out[0] = temp[0];
endmodule

module main;
reg [7:0] bMKR_D;
test test1 (bMKR_D[4:1], bMKR_D[8:5]);
endmodule
",,,,,
if statement problem while converting a vector,"im new at vhdl coding, and there is a problem with if statement
so my code is the following
i want to convert a vector(bar), if the statement is true (so in this example if its smaller than 10)
process(bar)
      variable tmp : integer;
    begin
      tmp := to_integer(signed(bar));
      if tmp &lt; 10 then
            good(3) &lt;= bar(3);
            good(2) &lt;= bar(3) xor bar(2);
            good(1) &lt;= bar(2) xor bar(1);
            good(0) &lt;= bar(1) xor bar(0);
      end if;
    end process;

but the problem is that the statement is not working, if i put a bigger number for example &quot;1111&quot; it is converting in the same way as it converted before","From the comments it seems you want good to be set to 0 whenever bar &gt;= 10. In that case you can just do:
process(bar)
  variable tmp : integer;
begin
  tmp := to_integer(signed(bar));
  if tmp &lt; 10 then
    good(3) &lt;= bar(3);
    good(2) &lt;= bar(3) xor bar(2);
    good(1) &lt;= bar(2) xor bar(1);
    good(0) &lt;= bar(1) xor bar(0);
  else
    good &lt;= (others =&gt; '0');
  end if;
end process;
",,,,,
VHDL: for...loop instead of for...generate,"Hello I have a problem in using for...loop instead of for...generate. I'd like to use for...loop because our Professor only taught us about it.
library ieee;
use ieee.std_logic_1164.all;

entity supersomm_4bit is
  port (
    c_in: in std_logic;
    a,b: in std_logic_vector(3 downto 0);
    s: out std_logic_vector(3 downto 0);
    sP,sG: out std_logic
  );
end supersomm_4bit;

architecture arch of supersomm_4bit is
  signal p,g,c: std_logic_vector(3 downto 0);

  begin
    g1: for i in 0 to 3 generate
      g(i) &lt;= a(i) and b(i);
      p(i) &lt;= a(i) or b(i);
    end generate;

    c(0) &lt;= c_in;
    c(1) &lt;= g(0) or (p(0) and c(0));
    c(2) &lt;= g(1) or (p(1) and g(0)) or (p(1) and p(0) and c(0));
    c(3) &lt;= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and c(0));

    g2: for i in 0 to 3 generate
      s(i) &lt;= a(i) xor b(i) xor c(i);
    end generate;

    sP &lt;= p(0) and p(1) and p(2) and p(3);
    sG &lt;= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
          or (p(3) and p(2) and p(1) and g(0));
end arch;

I've tried doing something like this
architecture for_loop of supersomm_4bit is
  signal p,g,c: std_logic_vector(3 downto 0);
  begin
    process begin
        for i in 0 to 3 loop
        g(i) &lt;= a(i) and b(i);
        p(i) &lt;= a(i) or b(i);
        end loop;
        wait;
    end process;

    c(0) &lt;= c_in;
    c(1) &lt;= g(0) or (p(0) and c(0));
    c(2) &lt;= g(1) or (p(1) and g(0)) or (p(1) and p(0) and c(0));
    c(3) &lt;= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and c(0));
        
    process begin
        for i in 0 to 3 loop
        s(i) &lt;= a(i) xor b(i) xor c(i);
        end loop;
        wait;
    end process;

    sP &lt;= p(0) and p(1) and p(2) and p(3);
    sG &lt;= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
            or (p(3) and p(2) and p(1) and g(0));
end architecture for_loop;

but it doesn't work (s and sP/sG are uninitialized). I've also tried putting all the code under a single process but it still doesn't work.
Am I doing something wrong or should I simply avoid using for...loop?
Thanks!
EDIT (adding the whole project):
library ieee;
use ieee.std_logic_1164.all;

entity unita_cla is
  port (
    a,b: in std_logic_vector(15 downto 0);
    c_in: in std_logic;
    S: out std_logic_vector(15 downto 0);
    C_OUT: out std_logic
  );
end unita_cla;

architecture arch of unita_cla is
  signal C: std_logic_vector(4 downto 1);
  signal P,G: std_logic_vector(3 downto 0);

  component supersomm_4bit
    port (
      c_in: in std_logic;
      a,b: in std_logic_vector(3 downto 0);
      s: out std_logic_vector(3 downto 0);
      sP,sG: out std_logic
    );
  end component;

  begin
    C(1) &lt;= G(0) or (P(0) and c_in);
    C(2) &lt;= G(1) or (P(1) and G(0)) or (P(1) and P(0) and c_in);
    C(3) &lt;= G(2) or (P(2) and G(1)) or (P(2) and P(1) and G(0))
            or (P(2) and P(1) and P(0) and c_in);
    C(4) &lt;= G(3) or (P(3) and G(2)) or (P(3) and P(2) and G(1))
            or (P(3) and P(2) and P(1) and G(0))
            or (P(3) and P(2) and P(1) and P(0) and c_in);

    bit0_3: supersomm_4bit port map (c_in, a(3 downto 0), b(3 downto 0),
                                     S(3 downto 0), P(0), G(0));
    bit4_7: supersomm_4bit port map (C(1), a(7 downto 4), b(7 downto 4),
                                     S(7 downto 4), P(1), G(1));
    bit8_11: supersomm_4bit port map (C(2), a(11 downto 8), b(11 downto 8),
                                     S(11 downto 8), P(2), G(2));
    bit12_15: supersomm_4bit port map (C(3), a(15 downto 12), b(15 downto 12),
                                     S(15 downto 12), P(3), G(3));

    C_OUT &lt;= C(4);
end arch;

TESTBENCH:
library ieee;
use ieee.std_logic_1164.all;

entity unita_cla_tb is
end unita_cla_tb;

architecture testbench of unita_cla_tb is
  signal a,b,S: std_logic_vector(15 downto 0);
  signal c_in,C_OUT: std_logic;

  component unita_cla
    port (
      a,b: in std_logic_vector(15 downto 0);
      c_in: in std_logic;
      S: out std_logic_vector(15 downto 0);
      C_OUT: out std_logic
    );
  end component;

  begin
    u1: unita_cla port map (a,b,c_in,S,C_OUT);
    tb: process
    begin
      a &lt;= &quot;0000000000000000&quot;;
      b &lt;= &quot;0000000000000000&quot;;
      c_in &lt;= '1';
      wait for 10 ns;
      a &lt;= &quot;1111111111111111&quot;;
      b &lt;= &quot;0000000000000000&quot;;
      c_in &lt;= '0';
      wait for 10 ns;
      a &lt;= &quot;1010101010101010&quot;;
      b &lt;= &quot;0101010101010101&quot;;
      c_in &lt;= '1';
      wait for 10 ns;
      a &lt;= &quot;1111111111111111&quot;;
      b &lt;= &quot;1111111111111111&quot;;
      c_in &lt;= '0';
      wait for 10 ns;
      a &lt;= &quot;1010101010101010&quot;;
      b &lt;= &quot;1010101010101010&quot;;
      c_in &lt;= '1';
      wait for 10 ns;
      wait;
    end process;
  end testbench;
","The two process in the for loop version of the architecture for supersomm_4bit execute only once due to the unconditional wait statements. Adding sensitivity lists and removing the wait statements:
architecture for_loop of supersomm_4bit is
    signal p,g,c: std_logic_vector(3 downto 0);
begin
    process (a, b)  -- ADDED sensitiity list
    begin
        for i in 0 to 3 loop
            g(i) &lt;= a(i) and b(i);
            p(i) &lt;= a(i) or b(i);
        end loop;
        -- wait;  -- resumes for every change in a or b
    end process;

    c(0) &lt;= c_in;
    c(1) &lt;= g(0) or (p(0) and c(0));
    c(2) &lt;= g(1) or (p(1) and g(0)) or (p(1) and p(0) and c(0));
    c(3) &lt;= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and c(0));

    process  (a, b, c)  -- ADDED sensitivity list
    begin
        for i in 0 to 3 loop
        s(i) &lt;= a(i) xor b(i) xor c(i);
        end loop;
        -- wait;   -- resumes for every change in a, b or c
    end process;

    sP &lt;= p(0) and p(1) and p(2) and p(3);
    sG &lt;= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
            or (p(3) and p(2) and p(1) and g(0));
end architecture for_loop;

Allows the simulation to match that of architecture arch. Each process will resume for any signal in the sensitivity list that has an event (a new value).
IEEE Std 1076-2008
11.3 Process statement

If a process sensitivity list appears following the reserved word process, then the process statement is assumed to contain an implicit wait statement as the last statement of the process statement part; this implicit wait statement is of the form
wait on sensitivity_list ;

The rules for constructing a sensitivity list are found in 10.2 Wait statement.
14.7.5 Model execution
14.7.5.1 General

The execution of a model consists of an initialization phase followed by the repetitive execution of process statements in the description of that model. Each such repetition is said to be a simulation cycle. In each cycle, the values of all signals in the description are computed. If as a result of this computation an event occurs on a given signal, process statements that are sensitive to that signal will resume and will be executed as part of the simulation cycle.
At certain stages during the initialization phase and each simulation cycle, the current time, Tc, and the time of the next simulation cycle, Tn, are calculated. Tn is calculated by setting it to the earliest of ...

14.7.5.2 Initialization

At the beginning of initialization, the current time, Tc, is assumed to be 0 ns.
The initialization phase consists of the following steps:

..
f) For each nonpostponed process P in the model, the following actions occur in the indicated order:


The process executes until it suspends.
...




Processes suspend and resume in wait statements. A process with a sensitivity list has an implicit wait statement as the last statement.
10.2 Wait statement

The timeout clause specifies the maximum amount of time the process will remain suspended at this wait statement. If no timeout clause appears, the timeout clause for (STD.STANDARD.TIME'HIGH â€?STD.STANDARD.NOW) is assumed. It is an error if the time expression in the timeout clause evaluates to a negative value.

The existing wait statements have no time out clause and would cause the process to cease execution following the first process execution following initialization. The input values used to provide update waveforms for signal outputs would be all 'U's at that time.
14.7.5.3 Simulation cycle

A simulation cycle consists of the following steps:

...
f) The following actions occur in the indicated order:

...
2) For each process, P, if P is currently sensitive to a signal, S, and if an event has occurred on S in this simulation cycle, then P resumes



Scheduled and updated at the current simulation time.",,,,,
UART Transmitter only functions when embedded logic analyzer is running,"I have been trying to implement a UART in order to communicate between my Lattice MachXO3D board and my computer. At the moment I am attempting to implement the transmission from the FPGA.
Upon testing on the hardware, I encountered a very strange issue. If run normally, it will function for a few seconds and then it will suddenly stop functioning (The CH340 connected to my computer will report it is receiving messages containing 0x0). However, if I embed a logic analyzer onto the FPGA through the Lattice Diamond software, and I run the analyzer, it will function perfectly for an extended period of time.
Sadly, I don't have a logic analyzer, so the embedded logic analyzer is my only chance at knowing what is actually being transmitted.
These are the files related to my implementation:
baud_gen
LIBRARY IEEE; 
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
-- Generates 16 ticks per bit
ENTITY baud_gen IS
  GENERIC(divider: INTEGER := 13 -- 24M/115200*16
          );
  PORT(
    clk, reset: IN STD_LOGIC;
    s_tick: OUT STD_LOGIC
    );
END baud_gen;

ARCHITECTURE working OF baud_gen IS
  
BEGIN
  PROCESS(clk)
    VARIABLE counter: UNSIGNED(3 DOWNTO 0) := to_unsigned(0,4);
  BEGIN
    IF clk'EVENT AND clk='1' THEN
      IF reset='1' THEN
        s_tick &lt;= '0';
        counter := to_unsigned(0,4);
      ELSIF counter=to_unsigned(divider-1,4) then
        s_tick &lt;= '1';
        counter:= to_unsigned(0,4);
      ELSE
        s_tick &lt;= '0';
        counter := counter + 1;
      END IF;
    END IF;
  END PROCESS;
END working;

rs232_tx
LIBRARY IEEE; 
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY rs232_tx IS
  PORT(clk: IN std_logic;
       tx: OUT std_logic;
       rst: IN std_logic;
       fifo_empty: IN std_logic;
       fifo_RdEn, fifo_RdClock: OUT std_logic;
       fifo_data: IN STD_LOGIC_VECTOR(7 DOWNTO 0);
       Q: OUT STD_LOGIC_VECTOR(1 DOWNTO 0));
END rs232_tx;

ARCHITECTURE working OF rs232_tx IS
  TYPE state IS (idle,start,data);
  SIGNAL tx_pulse: STD_LOGIC := '1';
  SIGNAL s_tick: STD_LOGIC;
  SIGNAL pr_state, nx_state: state := idle;
  SIGNAL data_val: std_logic_vector(7 DOWNTO 0):=(others=&gt;'0');
  SIGNAL data_count: unsigned(2 DOWNTO 0):=to_unsigned(0,3);
BEGIN
  process(s_tick, rst)
    VARIABLE count: unsigned(3 DOWNTO 0):= to_unsigned(0,4);
  BEGIN
    IF rising_edge(s_tick) THEN
      count := count + to_unsigned(1,4);

      IF count = to_unsigned(15,4) THEN
        tx_pulse &lt;= '1';
      ELSE
        tx_pulse &lt;='0';
      END IF; 
    END IF;
  END PROCESS;

  process(tx_pulse,rst)
  BEGIN
    IF rising_edge(tx_pulse) THEN
      IF rst='1' THEN
        pr_state &lt;= idle;
        data_val &lt;= (others=&gt;'0');
        data_count &lt;= to_unsigned(0,3);
      ELSE
        pr_state &lt;= nx_state;
        CASE pr_state IS
          WHEN idle =&gt;
            data_count &lt;= to_unsigned(0,3);
          WHEN data =&gt;
            data_count &lt;= data_count + to_unsigned(1,3);
          WHEN start =&gt;
            data_val &lt;= fifo_data;
          WHEN OTHERS =&gt;
        END case;
        
      END IF;
    END IF;
  END process;

  process(fifo_empty,rst,data_count,pr_state,data_count)
  BEGIN
    case pr_state is
      when idle =&gt;
        Q &lt;= ('1','1');
        fifo_RdEn &lt;= '0';
        tx &lt;= '1';
        IF fifo_empty='0' AND rst='0' THEN          
          nx_state &lt;= start;
        ELSE          
          nx_state &lt;= idle;
        END IF;
      WHEN start =&gt;
        Q &lt;= ('1','0');
        fifo_RdEn &lt;= '1';
        tx &lt;= '0';
        nx_state &lt;= data;
      WHEN data =&gt;
        Q &lt;= ('0','1');
        fifo_RdEn &lt;= '0';
        tx &lt;= data_val(to_integer(data_count));
        if data_count=to_unsigned(7,3) then
          nx_state &lt;= idle;
        ELSE
          nx_state &lt;= data;
        end if;

    end case;
  END process;
  
  fifo_RdClock &lt;= tx_pulse;
  baud_gen: ENTITY work.baud_gen
    PORT MAP(clk,reset=&gt;'0',s_tick=&gt;s_tick);
END working;

testbench
LIBRARY IEEE; 
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY rs232_tx_test IS
  GENERIC(clk_period: TIME := 41666666.7 fs;
          baud_period: TIME := 8680.55556 ns);
END rs232_tx_test;

ARCHITECTURE working OF rs232_tx_test IS
  SIGNAL clk: STD_LOGIC := '0';
  SIGNAL tx, rst, fifo_empty, fifo_RdEn, fifo_RdClock: STD_LOGIC;
  SIGNAL fifo_data: STD_LOGIC_VECTOR(7 DOWNTO 0);
BEGIN
  clk &lt;= NOT clk AFTER clk_period/2;
  rst &lt;= '1', '0' AFTER 100 ns;
  PROCESS
  BEGIN
    fifo_empty &lt;= '1';
    WAIT FOR baud_period;
    fifo_empty &lt;= '0';
    WAIT FOR baud_period*16;
  END PROCESS;

  fifo_data &lt;= ('1','1','0','0','1','0','1','1') WHEN fifo_RdEn='1' ELSE (others=&gt;'0');
  dut: ENTITY work.rs232_tx
    PORT MAP(clk,tx,rst,fifo_empty,fifo_RdEn,fifo_RdClock,fifo_data);
END working;

EDIT
I have tested another UART design I found online @ 9600 bps and it fails in the same way. It can send a constant character, in this case 'a', to a terminal on my computer, and then it suddenly stops sending anything. However, if I start listening to the soft logic analyzer I generated in Lattice Diamond, it works without a problem and does not fail.","This smells like a classic timing issue.
In the comments, others have explained where there are weaknesses in the code that could indirectly lead to this. I'm going to concentrate on what is occurring.
As you have stated, in simulation your code works as you expect. However, that is only half the story. To create an FPGA bit stream the build tools take your code and several other files, synthesises, and conducts Place &amp; Route. Your timing issue occurs during P&amp;R. This is why your simulation doesn't pick up on any errors, as I'm assuming it's an RTL (pre-place &amp; route) simulation.
During P&amp;R the tools lay the logic in the best way to fit the timing model of the device so all paths meet their timing requirements. The path timing requirements are derived from explicit statements in a Timing Constraints file and inferred from your code (that's why your coding style matters btw).
Once P&amp;R is complete, the tools will put the build artefact through a static timing analyser (STA) tool and report back whether the build fails to meet the timing requirements.
This leads to two questions:

Does the build report a timing error?
Do you have a Timing Constraints file - if you're unsure, the answer is no.

The way to debug your problem is to use the Timing Report generated by Lattice Diamond to see where the failures are.
If there are no reported failures it means your timing model is wrong because of a lack of appropriate timing constraints. As a minimum, you will need to constrain all IO in the design and describe all the clocks in your design.
Here is a good document to help you out:
https://www.latticesemi.com/-/media/LatticeSemi/Documents/UserManuals/RZ/Timing_Closure_Document.ashx?document_id=45588
The reason that your design works when you use the embedded Logic Analyser is that extra logic has been placed in the design, which changes the timing model. The P&amp;R tools lay out the design differently, and by luck have placed the design in such a way as meet the real timing requirements on it.
As I often say to my Software Engineer colleagues, software languages create a set of instructions, HDL creates a set of suggestions.",,,,,
VHDL Configuration Across Block Statements,"Consider the following code:

entity foo is
end entity foo;

architecture a of foo is
begin
  assert false report ""Architecture a"";
end architecture a;

architecture b of foo is
begin
  assert false report ""Architecture b"";
end architecture b;

entity bar is
end entity bar;

architecture behav of bar is
  component foo is
  end component foo;
begin
  test_block : block
  begin
    foo_inst : foo;
  end block;
end architecture behav;


How do I specify a configuration for foo_inst to select between architecture a or b?  I've tried:

configuration test_cfg of bar is
  for behav
    for foo_inst : foo
      use entity work.foo(b);
    end for;
  end for;
end configuration test_cfg;


But this clearly doesn't work, as it doesn't get through the hierarchy:

** Error: j.vhd(28): Component instance ""foo_inst : foo"" not found.
** Note: j.vhd(32): VHDL Compiler exiting


How do I specify the test_block boundary in the configuration?","clearly doesn't work  isn't descriptive enough to help people understand your problem. 

Show your analysis error message. Beside providing a line number identifying the cause the error message also reveals the tool you're using and the reason:

ghdl -a test_cfg.vhdl
test_cfg.vhdl:29:5:error: no component instantation with label ""foo_inst""`. 
ghdl:error: compilation error


Where the problem is when analyzing the sixth design unit (the configuration declaration if you put all the VHDL in one design file) foo_inst isn't visible in bar(behav).

First some background from IEEE Std 1076-2008 - 


Design entities and configurations
3.1 General (para 2):



  A design entity may be described in terms of a hierarchy of blocks, each of which represents a portion of the whole design. The top-level block in such a hierarchy is the design entity itself; such a block is an external block that resides in a library and may be used as a component of other designs. Nested blocks in the hierarchy are internal blocks, defined by block statements (see 11.2).


The configuration declaration doesn't represent the design hierarchy here. There is no visibility into the block statement.

3.4.2 Block configuration  


  A block configuration defines the configuration of a block. Such a block is either an internal block defined by a block statement or an external block defined by a design entity. If the block is an internal block, the defining block statement is either an explicit block statement or an implicit block statement that is itself defined by a generate statement.  
  
  &nbsp;&nbsp;&nbsp;&nbsp;block_configuration ::=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for block_specification
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ use_clause }
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ configuration_item }
  &nbsp;&nbsp;&nbsp;&nbsp;end for ;
  
  block_specification ::=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;architecture_name
  &nbsp;&nbsp;&nbsp;&nbsp;| block_statement_label
  &nbsp;&nbsp;&nbsp;&nbsp;| generate_statement_label [ ( generate_specification ) ]  
  
  ...  
  
  configuration_item ::=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block_configuration
  &nbsp;&nbsp;&nbsp;&nbsp;| component_configuration
  
  The block specification identifies the internal or external block to which this block configuration applies.
  
  ...


We see that a configuration item may be a block configuration, allowing hierarchical configuration specifications in the configuration declaration.

Where the configuration declaration can be modified to take advantage of this to specify which architecture to use for foo_inst in the block statement:

configuration test_cfg of bar is
    for behav
        for test_block
            for foo_inst: foo
                use entity work.foo(b);
            end for;
        end for;
    end for;
end configuration test_cfg;


We see that test_block is visible in bar(behav) and foo_inst is visible in test_block.


Concurrent statements
11.1 General para 5:



  All concurrent statements may be labeled. Such labels are implicitly declared at the beginning of the declarative part of the innermost enclosing entity declaration, architecture body, block statement, or generate statement.


You label component instantiations and the block statement here so the labels are known and useable in a configuration specification found in the configuration declaration.

The rules for visibility in configuration declarations and specifications are found in 12.3 Visibility.",,,,,
Random 1-bit and 2-bit error using random in systemverilog,"I am making use of an error detction block. I need to randomly flip 1 bit of the data using SystemVerilig. How do I do this? I also want to do the same where I flip 2 random bits of data.

Hamming Code is being used. So random bits from parity and data need to be flipped.","The most straightforward way is to use $urandom_range(0, msb) to select which bit you want to corrupt. An example:

module test();

parameter DATA_WIDTH = 29;
parameter IDX_WIDTH = $clog2(DATA_WIDTH);

logic [DATA_WIDTH-1:0] data;
logic [IDX_WIDTH-1:0]  idx_to_flip;

initial begin
   data = $urandom();
   $display(""Original data = %x"", data);

   idx_to_flip = $urandom_range(0, DATA_WIDTH-1);
   $display(""Flipping data bit idx %d"", idx_to_flip);

   data[idx_to_flip] = !data[idx_to_flip];
   $display(""Corrupted data = %x"", data);
end

endmodule


This is very straightforward for a single bit. If you want to corrupt 2 bits, you will need a bit more complexity to ensure the second bit index selected is not the same as the first selected. There are two options for this:

1) Loop over the second $urandom_range() call until it produces a value different than the first random number.

2) Create a class with two 'rand' fields, and use a constraint to ensure the values are not the same:

class Corruption;
  rand bit [IDX_WIDTH-1:0] corrupt_idx1;
  rand bit [IDX_WIDTH-1:0] corrupt_idx2;
endclass

Corruption corr = new;

initial begin
   corr.randomize() with {corrupt_idx1 != corrupt_idx2;};
   $display(""Bit indices to flip: %d and %d"", corr.corrupt_idx1, corr.corrupt_idx2);
end
",,,,,
"When using fscanf, what is happening inbetween lines being scanned?","I have an input file that I scan each line until the end. I use the first character as an indicator as what I want to do:  1. paused for x cycles, 2. write a 16-bit word serially, 3. write one bit at a time, 4 end of file.

The issue is that I see an extra mode in between the first p to w transition.

I tried printing out the string value of my variable ""mode"" but what I see is printed on the wave in between the first p and w is an additional mode not specified in my case statement.

at time = 0: mode equals "" "" (blank, nothing, all fine)
at time = A: mode now equals ""p"" (paused 4 cycles long, sure fine, I can fix this later)
at time = B: mode now equals ""[]"" (ERROR! this is not the next line)
at time = C: mode now equals ""w"" (back to normal)

input file:

p 10
w DEAD
w BEEF
p 5
b HHLL
p 100
eol


I have my systemverilog code that is suppose to scan the input file:

$fscanf(fd, ""%c %h"", mode, mystr);

case(mode)
  ""p"": begin
    wait_v = mystr.atoi();
    repeat ( wait_v) begin
      //turns bits on or off, but only modifies wire outputs and not mode
    end
  end

  ""w"": begin
    data = mystr.atohex();
    // writes data, each character is 4 bits. each word is 16 cycles
  end

  ""b"": begin
    lastsix = mystr.atobin();
    // writes data outputs either high or low, each character is 1 cycle long
  end

  ""eol"": begin
    $fclose(fn);
    $stop;
  end


Expected:

time =&gt; 0: mode equals "" "" (blank, nothing, all fine)
time =&gt; A: mode now equals ""p"" (paused for 3 cycles)
time =&gt; C: mode now equals ""w"" (back to normal)


Actual:

time =&gt; 0: mode equals "" "" (blank, nothing, all fine)
time =&gt; A: mode now equals ""p"" (paused 4 cycles long, sure fine, I can fix this later)
time =&gt; B: mode now equals ""[]"" (ERROR! this is not the next line)
time =&gt; C: mode now equals ""w"" (back to normal)
","When you use %c in scanf it will read the very next character.  When you use %h it will read a hex value, stopping after the last valid hex digit, and not reading what is next.  So after your first fscanf call, the input will be pointing at the newline a the end of the first line, and the next fscanf call will read that newline with %c, and you'll get mode == ""\n""

What you probably want is to use "" %c%h"" as your format -- note the  (space) before the %c.  The space causes fscanf to read and discard whitespace.  Since %h automatically skips whitespace before reading a number, you don't need the space before it.",,,,,
How to assign an output with combinational logic on a parametric design,"I want to implement a multiplexer that given a control signal (addr_i) puts in to the output(data_o) the content of a register(slv_reg[i]). Where ""i"" is a value from 0 to the module parameter TOTAL_REGS.
Can I assign the slv_reg in a for loop without generating a latch?

I have written a couple of simple examples. But even if my logic covers all the possible conditions if an else is missing it generates a latch. When doing it manually, I can write the else and get rid of the problem, but when using a loop, I don't know how to do it. 

module why_latch_1 #                                                 
    (                                                                
        // Width of data bus                                         
        parameter integer DATA_WIDTH    = 32,                        
        // Number of registers                                       
        parameter integer TOTAL_REGS = 3                             
    )                                                                
    (                                                                
     input wire clk_i,                                               
     input wire rstn_i,                                              
     input wire [DATA_WIDTH-1:0] addr_i,                             
     output wire [DATA_WIDTH-1:0] data_o                             
    );                                                               
    reg [DATA_WIDTH-1:0] slv_reg [0:TOTAL_REGS-1];                   
    reg [DATA_WIDTH-1:0] reg_data_out;                               
    assign data_o = reg_data_out;                                    

    integer i;                                                       

    always @(posedge clk_i)                                          
        if (~rstn_i) begin                                           
            for (i=0; i&lt;TOTAL_REGS; i=i+1) begin                     
                slv_reg[i]&lt;={DATA_WIDTH{1'b0}};                      
            end                                                      
        end                                                          

    always_comb                                                      
    begin : decode                                                   
    //check if the address is out of the range of R registers        
        if (addr_i&gt;0 &amp;&amp; addr_i &lt;= TOTAL_REGS) begin                  
            //this is a latch                                        
            integer i;                                               
            for(i=0;i&lt;TOTAL_REGS;i++)begin                           
                if(addr_i==i) begin                                  
                    reg_data_out =slv_reg[i];                        
                end                                                  
            end                                                      
        end else                                                     
            reg_data_out ={DATA_WIDTH{1'b0}};                        
    end                                                              
    endmodule                                                        





module why_latch_2 #                                      
(                                                         
    // Width of data bus                                  
    parameter integer DATA_WIDTH    = 32,                 
    // Number of registers                                
    parameter integer TOTAL_REGS = 3                      
)                                                         
(                                                         
 input wire clk_i,                                        
 input wire rstn_i,                                       
 input wire [DATA_WIDTH-1:0] addr_i,                      
 output wire [DATA_WIDTH-1:0] data_o                      
);                                                        
reg [DATA_WIDTH-1:0] slv_reg [0:TOTAL_REGS-1];            
reg [DATA_WIDTH-1:0] reg_data_out;                        
assign data_o = reg_data_out;                             

integer i;                                                

always @(posedge clk_i)                                   
    if (~rstn_i) begin                                    
        for (i=0; i&lt;TOTAL_REGS; i=i+1) begin              
            slv_reg[i]&lt;={DATA_WIDTH{1'b0}};               
        end                                               
    end                                                   

always_comb                                               
begin : decode                                            
//check if the address is out of the range of R registers 
    if (addr_i&gt;0 &amp;&amp; addr_i &lt;= TOTAL_REGS) begin           
        //this is NOT a latch                             
        if(addr_i==0)                                     
            reg_data_out =slv_reg[0];                     
        else                                              
            if(addr_i==1)                                 
                reg_data_out =slv_reg[1];                 
            else                                          
                reg_data_out =slv_reg[2];                 
    end else                                              
        reg_data_out ={DATA_WIDTH{1'b0}};                 
end                                                       
endmodule                                                 



By using spyglass as a linting tool, I get the following reports:

For module why_latch_2. Everything is fine, as I was expecting.

############### BuiltIn -&gt; RuleGroup=Design Read ###############                
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ID       Rule                    Alias                   Severity    File                                                                                  Line    Wt    Message
======================================================================================
[1]      DetectTopDesignUnits    DetectTopDesignUnits    Info        ./why_latch_2.sv                                                                      1       2     Module why_latch_2 is a top level desi
gn unit
[0]      ElabSummary             ElabSummary             Info        ./why_latch_2/why_latch_2/lint/lint_rtl/spyglass_reports/SpyGlass/elab_summary.rpt    0       2     Please refer file './why_latch_2/why_l
atch_2/lint/lint_rtl/spyglass_reports/SpyGlass/elab_summary.rpt' for elab summary report
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


For why_latch_1:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++         
MORESIMPLE REPORT:                                                              


############### BuiltIn -&gt; RuleGroup=Design Read ###############                
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ID       Rule                    Alias                   Severity            File                                                                                  Line    Wt      Message
======================================================================================
[1]      DetectTopDesignUnits    DetectTopDesignUnits    Info                ./why_latch_1.sv                                                                      1       2       Module why_latch_1 is a top 
level design unit
[4]      SYNTH_12608                                     SynthesisWarning    ./why_latch_1.sv                                                                      27      1000    why_latch_1 -&gt; The logic of 
the always block mismatches with the type of Always Block(which should be ""always_latch (Latch)"") due to latch instance \reg_data_out_reg[0]
[0]      ElabSummary             ElabSummary             Info                ./why_latch_1/why_latch_1/lint/lint_rtl/spyglass_reports/SpyGlass/elab_summary.rpt    0       2       Please refer file './why_lat
ch_1/why_latch_1/lint/lint_rtl/spyglass_reports/SpyGlass/elab_summary.rpt' for elab summary report
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


############### Non-BuiltIn -&gt; Goal=lint/lint_rtl ###############               
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ID       Rule          Alias                 Severity    File                Line    Wt    Message
======================================================================================
[7]      InferLatch    (OpenMORE 5.5.2.1)    Error       ./why_latch_1.sv    40      5     Latch inferred for signal 'reg_data_out[31:0]' in module 'why_latch_1'
[2]      W415a                               Warning     ./why_latch_1.sv    35      5     Signal reg_data_out is being assigned multiple times ( assignment within same for-loop ) in same always block [Hiera
rchy: ':why_latch_1']
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
","this should generate a latch in your case. You do not cover all possible cases here.

       for(i=0;i&lt;TOTAL_REGS;i++)begin                           
            if(addr_i==i) begin                                  
                reg_data_out =slv_reg[i];                        
            end                                                  
        end  


try this instead. Move the default case upfront:

begin : decode                                                   
//check if the address is out of the range of R registers        

   reg_data_out ='0;    // do default assignment before the rest                     

   if (addr_i&gt;0 &amp;&amp; addr_i &lt;= TOTAL_REGS) begin                  
        //this is a latch                                        
        integer i;                                               
        for(i=0;i&lt;TOTAL_REGS;i++)begin                           
            if(addr_i==i) begin                                  
                reg_data_out =slv_reg[i];                        
            end                                                  
        end                                                      
   end 
end                                                             
",,,,,
"if you have a long signed array, can you break it up using wires?","Imagine for simplicity that I have a 50-bit input into my module.  This 50-bit input is split into ten 5-bit signed words.  Is this how you would make each part of the input signed?

module(in, out)
input signed [49:0] in;
wire signed [4:0] in_temp [0:9];
genvar i;

for(i = 0; i &lt; 128; i = i+1)
assign in_temp[i] = in[5*(i+1)-1 -: 5];
....
","That's one way. You can also cast each slice using $signed(in[5*(i+1)-1 -: 5]), then you don't need an intermediate signal. 

SystemVerilog adds another option. You can defined a packed array which is a 50-bit vector made up of 10 signed 5-bit vectors. 

typedef logic signed [4:0] int5_t;
typedef int_5_t signed [9:0] int50_t;
module m(input int_50_t in, output out));
// can now use in[1] as a 5-bit signed signal which corresponds to bits [9:5] of the 50-bit vector
",,,,,
Using function inside constriant block,"I am trying to use a function inside constraint block. Randomization happens but the constraints are not being met.  I have verified that the function works as expected outside the constraint block. The function uses only function arguments and not any other class members.

local rand      logic [6:0] [3:0] [9:0] coeff_mult;

constraint prods_are_multiples {
     foreach(coeff_mult[i]) {
           get_real(coeff_mult[i][3]) == (-1 * get_real(coeff_mult[i][0]));
           get_real(coeff_mult[i][2]) == (-1 * get_real(coeff_mult[i][1]));
           get_real(coeff_mult[i][0]) == (3 * get_real(coeff_mult[i][1]));
     }
 }

 function automatic shortreal get_real(input [9:0] val);
                shortreal sign;
                bit [9:0] magnitude;
                sign = -1**(val[9]);
                magnitude = ({10{val[9]}} ^ val[9:0]) + val[9];
                get_real = sign * (magnitude[9:3] + magnitude[2] * 0.5 + magnitude[1] * 0.25 + magnitude[0] * 0.125);                
 endfunction



I came across a similar post, but it didnt solve my problem.

Is there anything wrong with the code? If not, is there any other way of doing this?","The post you reference explains the reasoning. The inputs to your function get their random values chosen before calling the function in the constraint. So there are effectively no constraints on coeff_mult before evaluating the equality constraints.

Also, the LRM does not allow expressions of non-integral values in constraints, technically, although some tools allow limited cases. 

The best strategy for randomizing real numbers is doing everything with scaled integral values, then converting the resulting values to real (or sign/magnitude) in post_randomize().",,,,,
Writing to a peripheral in Vivado and then outputting to a LED,"I want to create a basic project in Vivado that takes a value that i input to a client, which is sent to a server I made (in C), and then the server writes that value to a peripheral in Vivado, and then that data in the peripheral is sent to an output pin that assigns to LED's, making the LED light up.

Basically I want to go from client-->server-->peripheral-->LED lights up

For example, in the client (a GUI) I want to give it a value such as 0011, which is received by the server. Then the server writes that value to the peripheral which will then make, in this case, LED0 &amp; LED1 not light, but LED2 &amp; LED3 will light.

I know how to make an AXI4 peripheral in Vivado, and the client-server (TCP/IP) has been made. My question is what code/design block I would need to then take the data written to the peripheral and assign it to the LED's?

Should I make the peripheral a Master or Slave? Overall confused how should i proceed from here. I am using a Red Pitaya (Xilinx Zynq 7010 SoC) connected by an Ethernet cable to my computer.

Also, I thought of running the program on the Red Pitaya by loading the bitstream on to it (using WinSCP) by running the command 

cat FILE_NAME.bit &gt; /dev/xdevcfg


in PuTTY (connected to the Pitaya by IP address), then running the server on the pitaya, and then sending the signal from the client for the server to receive. Is that the correct way of approaching it?

If my logic is off in anyway please let me know","I am somewhat thrown by your statements. 


First you say ""I know how to make an AXI4 peripheral in Vivado""
Next I read: ""Should I make the peripheral a Master or Slave?""


Maybe I am wrong but to me it says you don't really know what you are doing.

Simplest is to:


Instance a zynq system.
Add the IP with the name ""AXI GPIO"". (Which, by the way, is an AXI slave.)
Run the auto connection.
Assign the right I/O pins to the GPIO port. (check your development system manual)
Build the system.


By the way you find the address of the peripheral in the address tab and it normally is 0x0080000000. 

You wrote that you made a server (TCP/IP). ""All"" it has to do is write the received value to a register in the GPIO block. (Here I assume Xilinx has a document which describes how the GPIO block works and has example GPIO drivers.) ",,,,,
Creating a `RAM` chip in `Verilog` with single in/out data port,"I want to create a RAM chip in verilog to learn how Verilog, modern chips like RAM and EEPROM allow reading and writing to the chip over a single address port and a single data port.(Data port being the input and output port)
I want to do the same thing in Verilog, and I think I need the inout type, but I don't know how it works.
I google it, but all RAM examples I can find have a separate data write and data read port.
Since the inout type requires both sides to be connected to a wire, I need to connect one wire from one side to a reg chosen by the address.(so no assign).But I don't know how to do that.

This is what I tried and doesn't work:

wire [7:0] a;
wire rw;// 0 if read, 1 if write
reg [7:0] mem [16];
initial begin
  if (rw == 1) begin
    #1 a = mem[0];// 0 would be the address wire, but excluding it for clarity
  end
  if (rw == 0) begin
    #1 mem[0] = a;// 0 would be the address wire, but excluding it for clarity
  end
end


Can anyone help?

Thanks","
  all RAM examples I can find have a separate data write and data read port. 


The reason is a combination of two facts:


A true bi-directional data bus would requires tri-state drivers. 
FPGA or ASIC chips no longer have on-chip tri-state drivers.


The only place where a bi-directional data is possible is at I/O where you have tri-state pads. 

Thus internally everybody will use the two data buses as any real memory will have at its core a separate read-data and write-data bus. Then at the edge (at the pads) they will switch to bi-directional mode. 

To write your own Verilog bi-directional bus you should use tri-state signal assignments. Something along the line of:

inout[7:0] data_bus,

// This assignment is inside the memory model:
// Driving the read data out of the memory device
assign data_bus = mem_read ? mem_read_data : 8'hzz;


// This assignment is outside the memory model
// Driving the write data into the memory device
assign data_bus = mem_read ? 8'hzz : external_driver;
",,,,,
RGB to YUV conversion equation,"I'm trying to understand RGB to YUV conversion equation.
and I've got some implementation from https://sistenix.com/rgb2ycbcr.html.




But I can't understand how it to be made as the below especially about R in (4)?

R&lt;&lt;6 + R&lt;&lt;1 ?


How does (65.7388*R)/256 can be represented as     R&lt;&lt;6 + R&lt;&lt;1 ? ","You are missing a part, (65.7388*R)/256 becomes (R&lt;&lt;6 + R&lt;&lt;1)&gt;&gt;8

The steps are actually pretty easy: approximating to the nearest integer (65.7388*R)/256 becomes (66*R)/256 that can be written as (64*R + 2*R)/256. A multiplication by 2 is equal to a shift to the left thus 2*R becomes R&lt;&lt;1 and 64*R becomes R&lt;&lt;6. In the same way, a division by 2 is equal to a shift to the right, thus /256 becomes &gt;&gt;8",,,,,
How to use a PLL to make a 50% duty cycle clock from a non 50% duty cycle clock,"I am new to Verilog and I have been tasked to produce a new clock signal using a PLL (with which I am also not very familiar). The input clock is a 21 MHz 57% duty cycle clock (The clock cycle is meant to synchronize with 7 data bits so 4 bits are sent on the high part of the clock and the other 3 on the low). It is a Camera Link clock.

I want to produce a clock with 7 times the frequency so I can be synchronized with the 7 data bits that are incoming. Since I just want to trigger my logic on the positive edge, I guess the duty cycle of this output clock doesn't matter. But I am completely lost on how to do this. 

I thought Maybe I could just create a clock divider because that is something I already know how to do. Since I know the frequency of the incoming clock is 21MHz, I could make a 21*7 MHz clock divider and just sync it with the original clock. But I want to know how to do this using a PLL.

Where do I start?

I am working with a Xilinx ML605","Use the Clocking Wizard in Xilinx ISE. It will generate HDL code to instantiate a PLL on your hardware. It'll prompt you for the input and output frequency; from what you've described in your question, it sounds as though you have all the information it'll need to proceed.

The PLL is a hard macro on the FPGA, so it's not possible to describe in Verilog alone. It's possible to instantiate one directly (rather than using the Clocking Wizard), but figuring out the correct parameters to do so would be difficult, especially if you lack experience with the part.",,,,,
'Opt_Design Error' in Vivado when trying Run Implementation,"Trying to make a UART Transmitter to send a data from FPGA to PC; 9600 baudrate, 8-bits, no parity, 1 start &amp; stop bit; I wrote a code with VHDL, run synthesis and simulate it in a way I like it to be. I wanted to see it with BASYS 3 FPGA, After created constraints, Run Implementation issued an error in which its called ""Opt_Design Error"".

library ieee;
use ieee.std_logic_1164.all;


entity rs232_omo is
generic(clk_max:integer:=10400); --for baudrate


port(

clk : in std_logic;
rst : in std_logic;
start : in std_logic;
input : in std_logic_vector(7 downto 0);
done : out std_logic;
output : out std_logic;
showstates: out std_logic_vector(3 downto 0)
);
end entity;

architecture dataflow of rs232_omo is

type states is (idle_state,start_state,send_state,stop_state);
signal present_state,next_state : states;
signal data,data_next : std_logic;

begin

process(clk,rst)
variable count : integer range 0 to clk_max;
variable index : integer range 0 to 10;
begin

if rst='1' then
    present_state&lt;=idle_state;
    count:=0;
    data&lt;='1';
    done&lt;='0';

elsif rising_edge(clk) then

    present_state&lt;=next_state;
    count:=count+1;
    index:=index+1;
    data&lt;=data_next;

end if;

end process;

process(present_state,data,clk,rst,start)
variable count : integer range 0 to clk_max;
variable index : integer range 0 to 10;
begin

done&lt;='0';
data_next&lt;='1';

case present_state is

    when idle_state =&gt;
        showstates&lt;=""1000"";
        data_next&lt;='1';

        if start='1' and rst='0' then
            count:=count+1;
            if count=clk_max then
                next_state&lt;=start_state;
                count:=0;
            end if;    
        end if;

    when start_state =&gt;
        showstates&lt;=""0100"";
        data_next&lt;='0';

        count:=count+1;
        if count=clk_max then
            next_state&lt;=send_state;
            count:=0;
        end if;

    when send_state =&gt;
        showstates&lt;=""0010"";
        count:=count+1;
        data_next&lt;=input(index);

        if count=clk_max then
            if index=7 then
                index:=0;
                next_state&lt;=stop_state;
            else
                index:=index+1;
            end if;
        count:=0;
        end if;

    when stop_state =&gt;
        showstates&lt;=""0001"";
        count:=count+1;
        if count=clk_max then
        next_state&lt;=idle_state;
        done&lt;='1';
        count:=0;
        end if;

   end case;
   end process;
   output&lt;=data;

   end architecture;


This's the error message in detail


  ""[DRC MDRV-1]Multiple Driver Nets:Net done_OBUF has multiple drivers:
  done_OBUF_inst_i_1/O,and done_reg/Q""
  
  ""[Vivado_Tcl 4-78] Error(s) found during DRC. Opt_Design not run.""


What would be the reason for this error?","You are assigning done both in the first and the second process, which is exactly what the implementation is complaining about, you cannot have multiple drivers. 

Remove done&lt;='0'; from the first process and it should complete the implementation. 

(I didn't check if the rest of the code is doing exactly what you want.) ",,,,,
"""Readline called past the end of file"" error VHDL","I need to read a file in VHDL but there is an error:
""Line 57: Readline called past the end of file mif_file""

impure function init_mem(mif_file_name : in string) return mem_type is
    file mif_file : text open read_mode is mif_file_name;
    variable mif_line : line;
    variable temp_bv : bit_vector(DATA_WIDTH-1 downto 0);
    variable temp_mem : mem_type;
begin
    for i in mem_type'range loop
        readline(mif_file, mif_line);
        read(mif_line, temp_bv);
        temp_mem(i) := to_stdlogicvector(temp_bv);
    end loop;       
return temp_mem;
end function;
","As stated in the comment section, you are trying to read more than you have in the file, you can avoid the error by checking if you reached the end of the file in your for loop and in that case assign a default value instead.

impure function init_mem(mif_file_name : in string) return mem_type is
    file mif_file : text open read_mode is mif_file_name;
    variable mif_line : line;
    variable temp_bv : bit_vector(DATA_WIDTH-1 downto 0);
    variable temp_mem : mem_type;
begin
    for i in mem_type'range loop
        if(not endfile(mif_file)) then
            readline(mif_file, mif_line);
            read(mif_line, temp_bv);
            temp_mem(i) := to_stdlogicvector(temp_bv);
        else
            temp_mem(i) := default_value_to_be_defined;
        end if;
    end loop;       
return temp_mem;
end function;


Or you can exit the for loop if you don't want to set a default value

impure function init_mem(mif_file_name : in string) return mem_type is
    file mif_file : text open read_mode is mif_file_name;
    variable mif_line : line;
    variable temp_bv : bit_vector(DATA_WIDTH-1 downto 0);
    variable temp_mem : mem_type;
begin
    for i in mem_type'range loop
        if(not endfile(mif_file)) then
            readline(mif_file, mif_line);
            read(mif_line, temp_bv);
            temp_mem(i) := to_stdlogicvector(temp_bv);
        else
            exit;
        end if;
    end loop;       
return temp_mem;
end function;
",,,,,
Output is in undefined state,"Image. I am trying to solve a problem that was written below. I confused why my output was in undefined state.
A ""population count"" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.

module top_module( 
    input [254:0] in,
    output [7:0] out );

    reg [7:0] counter=8'b0;
    reg [7:0] counter_next=8'b0;
    always @ (*)
        begin
            counter=counter_next;
        end
    always @ (*)
        begin
            for (int i=0; i&lt;$bits(in);i++)
                counter_next=counter+in[i];
        end
    assign out=counter;
endmodule
","
  confused why my output was in undefined state.


All HDL variables are undefined ('X' or 'U') until you give them a value.
Then, you add a value to that undefined value counter_next=counter+in[i]; which still gives undefined. So it stays that way.

Also you are using 'counter=counter_next' which suggest you have seen some existing HDL code and you are trying to copy it, but you do not understand why it is implemented that way. The 'next' system is used when there is a clock. You do not have a clock and as such it is superfluous here. 

The code you are looking for is probably something like this:

output reg [7:0] out

always @( * )
begin
   out = 0;
   for (int i=0; i&lt;$bits(in);i++)
      out =out+in[i];
end


Note that I am not using an extra variable counter here. All I do is make 'out' a reg type so I can use it directly. ",,,,,
Cadence IUS simulator options,"What is the difference between -INcdir and +incdir+ options in NC simulator?

Below is the example command from the Makefile. As far as I know the testbench directories are included using -INcdir and  the source code file directories are included using +incdir+ command

ncvlog -SV -INcdir ../include -INcdir ../src -64bit ../src/top.sv ../src/test.sv;
ncelab ncelab.log top +incdir+../../../sv/src +incdir+../../../sv/include


Please help me to understand the the significance of these options.","I agree with Tudor. They actually mean the same thing. 

The +incdir+arg is replaced with ncvlog -incdir arg, the same way in which +define+arg is replaced with ncvlog -define arg.

It is referred to as ""Plus"" option translation in the Cadence NC-Verilog Simulator user guide.

",,,,,
Finding the maximum value of an array in log2 time in Verilog?,"I have designed a 'sorter' that finds the maximum value of its input, which is 16 31-bit words.  In simulation, it works, but I am not sure if it will work in hardware (as it doesn't seem to be working on the FPGA as planned).  Can someone please let me know if this will work?  I am trying to save on resources, that is why I am trying to reuse the same register. Thank you...

module para_sort(clk, ready, array_in, out_max)
input clk, ready;
input [16*31-1:0] array_in;
output reg [30:0] out_max;
reg [30:0] temp_reg [0:15]
integer i, j;

always @ (posedge clk)
begin
   if(ready)
   begin
      for(j=0; j&lt;16; j=j+1)
      begin
      temp_reg[j] &lt;= array_in[31*(j+1)-1 -: 31];
      end
      i&lt;=0;
      done&lt;=0;
   end
   else
   begin
      if(i&lt;4)
      begin
      for(j=0; j&lt;16; j=j+1)
         if(temp_reg[j+1] &gt; temp_reg[j]
         temp_reg[((j+2)&gt;&gt;1)-1] &lt;= temp_reg[j+1]
         else
         temp_reg[((j+2)&gt;&gt;1)-1] &lt;= temp_reg[j]

      i&lt;=i+1;
      end
   end

   if(i == 4)
   begin
      out_max &lt;= temp_reg[0];
      done &lt;=1;
      i &lt;= i + 1;
   end
   if(i == 5)
      done &lt;=0;
end
endmodule


Sorry for the long code.  If you have any questions about the code, please let me know.","Before answering the question, I assume that you do not have any problem with code syntax and semantics, and the module is part of the design so that you do not have problem with number of I/O pins, as it seems to be the case. 

First of all, the algorithm that has been used in this posted code is incorrect. Maybe you meant something different, but this one is incorrect. The following code worked for me:

//The same code as you posted, but slight changes are made
//Maybe you have tried compiling this code and missed some points while posting
module para_sort(clk, ready, array_in, out_max, done);
input clk, ready;
input [16*31-1:0] array_in;
output reg [30:0] out_max;
output reg done;
reg [30:0] temp_reg [0:16];
integer i, j;

always @ (posedge clk)
begin
   if(ready)
   begin
      for(j=0; j&lt;16; j=j+1)
      begin
      temp_reg[j] &lt;= array_in[31*(j+1)-1 -: 31];
      end
      i&lt;=0;
      done&lt;=0;
   end
   else
   begin
      if(i&lt;4)
      begin
      for(j=0; j&lt;16; j=j+2)
        begin
         if(temp_reg[j+1] &gt; temp_reg[j])
           temp_reg[((j+2)&gt;&gt;1)-1] &lt;= temp_reg[j+1];
         else
           temp_reg[((j+2)&gt;&gt;1)-1] &lt;= temp_reg[j];

        end // end of the for loop
        i&lt;=i+1;
      end
   end

   if(i == 4)
   begin
      out_max &lt;= temp_reg[0];
      done &lt;=1;
      i &lt;= i + 1;
   end
   if(i == 5)
      done &lt;=0;
end
endmodule


If the above code does not solve the problem, then:

The problem might be with timing. In Quartus Prime software, there are netlist viewer tools (The same is true for Vivado). When you check the generated circuit, you can see paths with many combinational blocks and feedback (caused mostly by the second for loop). If the second for loop does not have enough time to complete execution in a single clock, you will loose synchronization and the results will be unpredictable.  

So,


Try the above code first
If the code does not solve your problem, then try FSM (with case and if - else - if statements ) even the code becomes longer or looks uglier (not user friendly), it is more FPGA hardware friendly.
",,,,,
"If sensitivity list in VHDL is not synthesizable, why does it gives an error due the Analysis and Synthesis?","To provide sequential logic in design with VHDL I have to use process statement, which has sensitivity_list. From different sources I know, that sensitivity list is non-synthesizable construction, i.e., if I will synthesize this code:

    ...
    process(c)
    b &lt;= a and c;
    end process;
    ...


I would not have any latch by c signal, it will just be a usual AND-gate. But, when I synthesize code without sensitivity list:

    ...
    process
    b &lt;= a and c;
    end process;
    ...


no matter what version of VHDL I choose, I get the same problem:


  Error (10442): VHDL Process Statement error at process_test.vhd(79):
  Process Statement must contain either a sensitivity list or a Wait
  Statement


My question is: why does synthesizer care about sensitivity list? In my understanding, it is over-concerned about customers and this cannot be an error, but a critical warning, or even nothing, and warnings only when the simulation is on.

UPD. Here is full code and some images. I used Quartus Prime Standard 16.1

    library ieee;
    use ieee.std_logic_1164.all;
    entity stck_ovflw is
        port 
        (
            a       : in std_logic;
            c       : in std_logic;
            b       : out std_logic
        );
    end entity;
    architecture rtl of stck_ovflw  is
    begin
        process(c)
        begin
            b &lt;= a AND c;
        end process;
    end rtl;


RTL Synthesis:

Modelling:
","It is the job of a logic synthesiser to generate a circuit that behaves exactly the same as your RTL. A process without a sensitivity list or a wait if an infinite loop and so cannot be simulated. Therefore, given my first sentence, how can a logic synthesiser possibly generate a circuit that behaves exactly the same as your RTL?

This should never be a problem, because you should always simulate before you synthesise. So, you should have fixed this before the logic synthesiser ever sees your code.",,,,,
Macro Vim - expand multiple Verilog Bus,"I'm trying to implement Macro to expand Verilog Bus as Vim - Macro to expand verilog bus and this is really working good for one variable.

But I've got the problem because I want to implement multiple bus as the below

Source:

{test[13:10],thisistest[3:0],BUS[2:1]}


Result:

test[13]
test[12]
test[11]
test[10]
thisistest[3]
thisistest[2]
thisistest[1]
thisistest[0]
BUS[2]
BUS[1]


What I tried to do : 
I made similar function as 

fun! split()
    let line = getline('.')
    let result = []
    let list = split(line, "","")
    let length = len(list)

    for i in length
        call ExpandIt(list[length])
    endfor
endf


fun! ExpandIt()
    let pat = '^\(.*\)\[\(\d\+\):\(\d\+\)\]\s*$'
    let line = getline('.')
    let lnr = line('.')
    if line !~ pat
        return
    endif
    let exestr = substitute(line,pat,'range(\2,\3,-1)','g')
    let text = substitute(line,pat,'\1','g')
    exec 'let range='.exestr
    let result = []
    for i in range
        call add(result, text.'['.i.']')
    endfor
    call append(lnr, result)
    exec lnr'.d'    
endf

nnoremap &lt;F6&gt; :call split()&lt;cr&gt;


Could you please let me know what am I supposed to do to go with right way?","Based on the obvious errors in your added split() function (the function name must be capitalized to avoid E128, you pass an argument to ExpandIt(), but it doesn't take any, length is not iterable by :for), you seem to have a limited understanding of Vimscript, and just try to ""make it work"" through brute-force attempts. Therefore it was good to ask here on Stack Overflow, but please be aware that just relying on helpful strangers to fix things for you is a lopsided approach, so please use this and future questions to slowly but steadily learn about Vim, to become a master of it yourself!

The following seems to do what you're asking for, by doing the following modifications:


fixing the obvious errors listed above
collecting the result List in Split() is the right idea, but the actual insertion (:call append()) and deletion of the original line has to be moved there as well, and ExpandIt() has to return the result
likewise, ExpandIt() needs to be passed the extracted element instead of directly getting the current line
the split() of the line into comma-separated elements needs to drop the surrounding { and }; substitute() can do this.




fun! Split()
    let line = getline('.')
    let result = []

    for l in split(substitute(line, '[{}]', '', 'g'), "","")
        let result += ExpandIt(l)
    endfor

    let lnr = line('.')
    call append(lnr, result)
    exec lnr'.d'
endf

fun! ExpandIt(line)
    let pat = '^\(.*\)\[\(\d\+\):\(\d\+\)\]\s*$'
    if a:line !~ pat
        return
    endif
    let exestr = substitute(a:line,pat,'range(\2,\3,-1)','g')
    let text = substitute(a:line,pat,'\1','g')
    exec 'let range='.exestr
    let result = []
    for i in range
        call add(result, text.'['.i.']')
    endfor
    return result
endf

nnoremap &lt;F6&gt; :call Split()&lt;cr&gt;
",,,,,
Parameterize parameters?,"I would like to parameterize localparam parameters.

My module definition:

module native  #(
  parameter SIM_ONLY = 0,
  parameter FREQ = 500
)(
  ...
);


I have lots of instantiations using the same localparam parameter A.

if (FREQ == 550) begin
  localparam A = 987;
end else begin
  localparam A = 122;
end

AA #(
   .A_VALUE  (A),
) AA_inst (
 ...
);


But that isn't allowed in the specification, is there a different proper way to do it?

/!\ The A value is a magic number, not something that can be calculated from FREQ.

I've tried:

if (FREQ == 550) begin
  shortreal A = 987;
end else begin
  shortreal A = 122;
end


but I get The expression for a parameter actual associated with the parameter name... must be constant.","Use the conditional operator ?: 

localparam A = (FREQ==550) 987 : 122;


You can also put more complicated expressions into a constant function

localparam A = some_function(FREQ);

function int some_function(int F);
   case(F)
     550: return 987;
     123: return 456;
     default: return 122;
   endcase
endfunction
",,,,,
Is it possible to let emacs verilog-auto connect wires which are templated in AUTO_TEMPLATE,"When using AUTOINST in emacs verilog-mode auto, it will try to connect all ports listed in .v. Is it possible to let emacs verilog-mode auto only connect ports which are templated at AUTO_TEMPLATE when using AUTOWIRE / AUTOOUTPUT / AUTOINPUT ?","This is a great question/feature request to post at https://www.veripool.org/wiki/verilog-mode

Mac",,,,,
VHDL Changing and holding the signal in if statement,"Im super new with VHDL and I have an assigned project to do. Basically what I'm aiming is to display 2 numbers and substract and add them with the help of a switch. (On FPGA Board)

For example:
Assume I have a signal A with the bit value 9 and B with 2, whenever I open the switch it will operate A-B and display 7. The problem is, when I close the switch, I get 9 instead of 7. (It doesn't hold the value) What I want is to display all the substraction results with opening and closing the same switch : 9,7,5,3,1 

What I did so far:


I coded a decoder for the seven segment display
I have a 5 bit bitslice adder substractor implementation
In my main module, I have them as components and instantiations
In main module, I have signals for the two numbers which I declared
as the input values of my bitslice instantiatons
In the process, I assigned the default values to my signals (9 and 2)
Inside of an if statement, I assigned the signal A to the result
signal (which is assigned to adder-substractor instantiations bit by bit) And assigned the signal for seven segment to result.


It works when I open the switch, but when I close the switch default value holds. How can I update the value of A with the result each time?

My Code:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity main is

    Port ( 
              S : in  STD_LOGIC_VECTOR (1 downto 0);
           Cin : in  STD_LOGIC;
              Cout: out STD_LOGIC;
              StartGameSwitch : IN std_logic;
              SevenSegControl : OUT std_logic_vector(7 downto 0):=x""ff"";
              SevenSegBus : OUT std_logic_vector(7 downto 0);
              clk : IN std_logic);
end main;


architecture Behavioral of main is

--COMPONENTS-------------------------------------------------------------------------------------------------------

COMPONENT sevenSegment
    PORT(
        A : IN std_logic_vector(4 downto 0);
        B : IN std_logic_vector(4 downto 0);
        C : IN std_logic_vector(4 downto 0);
        D : IN std_logic_vector(4 downto 0);
        E : IN std_logic_vector(4 downto 0);
        F : IN std_logic_vector(4 downto 0);
        G : IN std_logic_vector(4 downto 0);
        H : IN std_logic_vector(4 downto 0);
        SevenSegControl : OUT std_logic_vector(7 downto 0);
        SevenSegBus : OUT std_logic_vector(7 downto 0);
        clk : IN std_logic          
        );
END COMPONENT;

COMPONENT logic
    PORT(
        A : IN std_logic;
        B : IN std_logic;
        COld : IN std_logic;
        S : IN std_logic_vector(1 downto 0);
        AG : IN std_logic;
        BG : IN std_logic;          
        CNew : OUT std_logic;
        NumberBit : OUT std_logic;
        negativeSign : OUT std_logic
        );
END COMPONENT;

COMPONENT comparator
    PORT(
        A : IN std_logic_vector(4 downto 0);
        B : IN std_logic_vector(4 downto 0);          
        AG : OUT std_logic;
        BG : OUT std_logic
        );
END COMPONENT;

--SIGNALS-------------------------------------------------------------------------------------------------------

signal sA,sB,sC,sD,sE,sF,sG,sH: std_logic_vector (4 downto 0) ;
signal logicLed,result,negativeSign,sevenSegmentResult,sevenSegmentNegativeSign: std_logic_vector (4 downto 0);
signal c0,c1,c2,c3,c4: std_logic;
signal AG,BG: std_logic;
signal HP1,HP2,ATK1,ATK2: std_logic_vector (4 downto 0);

--CONSTANTS-------------------------------------------------------------------------------------------------------

constant charO:std_logic_vector(4 downto 0):= ""01010""; --10
constant charP:std_logic_vector(4 downto 0):= ""01011""; --11
constant charE:std_logic_vector(4 downto 0):= ""01100""; --12
constant charN:std_logic_vector(4 downto 0):= ""01101""; --13
constant charF:std_logic_vector(4 downto 0):= ""01110""; --14
constant charI:std_logic_vector(4 downto 0):= ""01111""; --15
constant charG:std_logic_vector(4 downto 0):= ""10000""; --16
constant charH:std_logic_vector(4 downto 0):= ""10001""; --17
constant charT:std_logic_vector(4 downto 0):= ""10010""; --18
constant charA: std_logic_vector(4 downto 0):= ""10011"";--19
constant char0:std_logic_vector(4 downto 0):= ""00000"";
constant char1:std_logic_vector(4 downto 0):= ""00001"";
constant char2:std_logic_vector(4 downto 0):= ""00010"";
constant char3:std_logic_vector(4 downto 0):= ""00011"";
constant char4:std_logic_vector(4 downto 0):= ""00100"";
constant char5:std_logic_vector(4 downto 0):= ""00101"";
constant char6:std_logic_vector(4 downto 0):= ""00110"";
constant char7:std_logic_vector(4 downto 0):= ""00111"";
constant char8:std_logic_vector(4 downto 0):= ""01000"";
constant char9:std_logic_vector(4 downto 0):= ""01001"";
constant charEmpty:std_logic_vector(4 downto 0):= ""11111"";

begin


--INSTANTIATIONS-------------------------------------------------------------------------------------------------------

    Inst_logic1: logic PORT MAP(
        A =&gt;HP2(0) ,
        B =&gt;ATK1(0) ,
        COld =&gt;c0 ,
        CNew =&gt;c1,
        NumberBit =&gt;result(0) ,
        S =&gt;S, 
        AG =&gt; AG,
        BG =&gt; BG,
        negativeSign =&gt; negativeSign(0)
    );

        Inst_logic2: logic PORT MAP(
        A =&gt;HP2(1) ,
        B =&gt;ATK1(1) ,
        COld =&gt;c1 ,
        CNew =&gt;c2,
        NumberBit =&gt;result(1) ,
        S =&gt;S, 
        AG =&gt; AG,
        BG =&gt; BG,
        negativeSign =&gt; negativeSign(1)
    );

        Inst_logic3: logic PORT MAP(
        A =&gt;HP2(2) ,
        B =&gt;ATK1(2) ,
        COld =&gt;c2 ,
        CNew =&gt;c3,
        NumberBit =&gt;result(2) ,
        S =&gt;S, 
        AG =&gt; AG,
        BG =&gt; BG,
        negativeSign =&gt; negativeSign(2)
    );

        Inst_logic4: logic PORT MAP(
        A =&gt;HP2(3) ,
        B =&gt;ATK1(3) ,
        COld =&gt;c3 ,
        CNew =&gt;c4,
        NumberBit =&gt;result(3) ,
        S =&gt;S, 
        AG =&gt; AG,
        BG =&gt; BG,
        negativeSign =&gt; negativeSign(3)
    );

        Inst_logic5: logic PORT MAP(
        A =&gt;HP2(4) ,
        B =&gt;ATK1(4) ,
        COld =&gt;c4 ,
        CNew =&gt;Cout,
        NumberBit =&gt;result(4) ,
        S =&gt;S, 
        AG =&gt; AG,
        BG =&gt; BG,
        negativeSign =&gt; negativeSign(4)
    );  

        Inst_comparator: comparator PORT MAP(
        A =&gt; HP2,
        B =&gt; ATK1,
        AG =&gt; AG,
        BG =&gt; BG
    );

--GAME LOGIC-------------------------------------------------------------------------------------------------------



process(StartGameSwitch)
begin


--DEFAULT VALUES FOR HP1,HP2,ATK1,ATK2--
-- I WANT HP1 AND HP2 TO CHANGE ACCORDING TO SWITCHES --
    HP2 &lt;= char9;
    ATK1 &lt;= char2;   
   HP1 &lt;= char9;
    ATK2 &lt;= char3;

    if(StartGameSwitch = '0') then -- OPEN P35 ON FPGA

            sA &lt;= charO; -- s_ are the signals for the seven segment 
            sB &lt;= charP;
            sC &lt;= charE;
            sD &lt;= charN;
            sE &lt;= charEmpty;
            sF &lt;= charP;
            sG &lt;= char7;
            sH &lt;= char8;

    else -- WHEN P35 IS OPENED ( WHEN THE GAME STARTS) 


            sA &lt;= HP1; --HP POINT FOR P1
            sB &lt;= charEmpty; 
            sC &lt;= ATK1; --Attack POINT FOR P1
            sD &lt;= charEmpty; 

            sE &lt;= charEmpty; 
            sF &lt;= ATK2; --Attack POINT FOR P2
            sG &lt;= charEmpty; 
            sH &lt;= HP2; --HP POINT FOR P2

            if(S = ""01"") then -- WHEN PLAYER 1 ATTACKS PLAYER 2 ( HP2 - ATK1 = RESULT (i.e 9-2 = 7))
                HP2 &lt;= result; 
                sH &lt;= HP2; -- When SWITCH IS OPEN, IT SHOWS 7 WITHOUT ANY PROBLEM
            end if;
    -- HOWEVER, WHEN THE SWITCH IS AGAIN BACK TO 00, sH displays 9 instead of 7, HOW CAN I SAVE THE VALUE OF HP2?

    end if;
end process;

-- SIGNALS ASSIGNED TO DISPLAY 
Inst_sevenSegment: sevenSegment PORT MAP(
        A =&gt;sA, --1ST PLAYER HEALTH 
        B =&gt;sB, -- 1ST PLAYER DMG
        C =&gt;sC ,
        D =&gt;sD ,
        E =&gt;sE ,
        F =&gt;sF ,
        G =&gt;sG , -- 2ND PLAYER DMG
        H =&gt;sH , --2ND PLAYER HEALTH
        SevenSegControl =&gt;SevenSegControl ,
        clk =&gt; clk,
        SevenSegBus =&gt; SevenSegBus
    );

end Behavioral;


Thanks","The problem is in your game logic process. Since your HP and ATK signals are in the top level of the process, they essentially get a continuous assignment to the default values all the time. The only time this changes is when you open the switch and you see the expected result displayed. When you close the switch again, the values get assigned their defaults again, rather than retaining the previous arithmetic result.

If you assign those signals their defaults only when you trigger StartGameSwitch (see below), then you should see the correct display when using your switch.

On a side note, your process sensitivity list was incomplete. The logic in your process depends on the switch signal S, so this should be included in the sensitivity list (as I've shown below). It doesn't really matter for synthesis, only for correctly simulating your code. 

process(StartGameSwitch,S)
begin


--DEFAULT VALUES FOR HP1,HP2,ATK1,ATK2--
-- I WANT HP1 AND HP2 TO CHANGE ACCORDING TO SWITCHES --
    --HP2 &lt;= char9;
    --ATK1 &lt;= char2;   
    --HP1 &lt;= char9;
    --ATK2 &lt;= char3;

    if(StartGameSwitch = '0') then -- OPEN P35 ON FPGA

            HP2 &lt;= char9;  --Assign default values here instead
            ATK1 &lt;= char2;   
            HP1 &lt;= char9;
            ATK2 &lt;= char3;

            sA &lt;= charO; -- s_ are the signals for the seven segment 
            sB &lt;= charP;
            sC &lt;= charE;
            sD &lt;= charN;
            sE &lt;= charEmpty;
            sF &lt;= charP;
            sG &lt;= char7;
            sH &lt;= char8;

    else -- WHEN P35 IS OPENED ( WHEN THE GAME STARTS) 
",,,,,
RedPitaya hello world hangs up a board,"
I Tested a simple ""hello world"" application for RedPitaya FPGA: RedPitayaHelloWorldVHDL.
It takes a clock from PACKAGE_PIN U18 and U19, devides it by frequency to receive 1Hz, and outputs counter to LEDs. After making a bitstram and writing to FPGA by command:

 cat bitstram.bit &gt; /dev/xdevcfg


LEDs blinks good, but Linux on board of RedPitaya hangsup. Why it's happening? and how to avoid it?

","You need to instantiate a Zynq ""PS7"" component in your design, that is the interface between the Linux SoC part and the FPGA fabric, there is also a wizard in Vivado to configure this. If this component is not in the design then programming the bitstream crashes the SoC. 

If the Linux on Red Pitaya also assumes the presence of any AXI slaves on the FPGA fabric side, omitting these from the design might also cause a lock up, but this is less likely to be the problem. ",,,,,
Verilog: Declaration error at define_state.h: identifier is already declared in the present scope,"All I am trying to do right now is get past this error, so I can start testing the code, it is for a hardware image de compressor.

The main .v file:

`timescale 1ns/100ps

`ifndef DISABLE_DEFAULT_NET
`default_nettype none
`endif

`include ""define_state.h""

// This is the top module
// It connects the UART, SRAM and VGA together.
// It gives access to the SRAM for UART and VGA
module experiment4a (
  /////// board clocks                      ////////////
  input logic CLOCK_50_I,                   // 50 MHz clock

  /////// pushbuttons/switches              ////////////
  input logic[3:0] PUSH_BUTTON_I,           // pushbuttons
  input logic[17:0] SWITCH_I,               // toggle switches

  /////// 7 segment displays/LEDs           ////////////
  output logic[6:0] SEVEN_SEGMENT_N_O[7:0], // 8 seven segment displays
  output logic[8:0] LED_GREEN_O,            // 9 green LEDs

  /////// VGA interface                     ////////////
  output logic VGA_CLOCK_O,                 // VGA clock
  output logic VGA_HSYNC_O,                 // VGA H_SYNC
  output logic VGA_VSYNC_O,                 // VGA V_SYNC
  output logic VGA_BLANK_O,                 // VGA BLANK
  output logic VGA_SYNC_O,                  // VGA SYNC
  output logic[7:0] VGA_RED_O,              // VGA red
  output logic[7:0] VGA_GREEN_O,            // VGA green
  output logic[7:0] VGA_BLUE_O,             // VGA blue

  /////// SRAM Interface                    ////////////
  inout wire[15:0] SRAM_DATA_IO,            // SRAM data bus 16 bits
  output logic[19:0] SRAM_ADDRESS_O,        // SRAM address bus 18 bits
  output logic SRAM_UB_N_O,                 // SRAM high-byte data mask
  output logic SRAM_LB_N_O,                 // SRAM low-byte data mask
  output logic SRAM_WE_N_O,                 // SRAM write enable
  output logic SRAM_CE_N_O,                 // SRAM chip enable
  output logic SRAM_OE_N_O,                 // SRAM output logic enable

  /////// UART                              ////////////
  input logic UART_RX_I,                    // UART receive signal
  output logic UART_TX_O                    // UART transmit signal
);

  logic resetn;

  top_state_type top_state;
  state_type state;

  // For Push button
  logic [3:0] PB_pushed;

  // For VGA SRAM interface
  logic VGA_enable;
  logic [17:0] VGA_base_address;
  logic [17:0] VGA_SRAM_address;

  // For SRAM
  logic [17:0] SRAM_address;
  logic [15:0] SRAM_write_data;
  logic SRAM_we_n;
  logic [15:0] SRAM_read_data;
  logic SRAM_ready;

  //For Milestone 1
  parameter Y_offset = 0;
  parameter U_offset = 38400;
  parameter V_offset = 57600;
  parameter RGB_offset = 146944;
  logic [17:0] y_loc, uv_loc, rgb_loc;
  logic [15:0] red, green, blue, r_hold, g_hold, b_hold;
  logic [15:0] y, y_hold, u_prime, u_hold, v_prime, v_hold;
  logic [7:0] u_comp [5:0];
  logic [7:0] v_comp [5:0];
  logic u_v_toggle;
  logic lead_in;
  logic [7:0] mult_1, mult_2, mult_3;


  // For UART SRAM interface
  logic UART_rx_enable;
  logic UART_rx_initialize;
  logic [17:0] UART_SRAM_address;
  logic [15:0] UART_SRAM_write_data;
  logic UART_SRAM_we_n;
  logic [25:0] UART_timer;

  logic [6:0] value_7_segment [7:0];

  // For error detection in UART
  logic [3:0] Frame_error;

  // For disabling UART transmit
  assign UART_TX_O = 1'b1;

  assign resetn = ~SWITCH_I[17] &amp;&amp; SRAM_ready;

  // Push Button unit
  PB_Controller PB_unit (
    .Clock_50(CLOCK_50_I),
    .Resetn(resetn),
    .PB_signal(PUSH_BUTTON_I),
    .PB_pushed(PB_pushed)
  );

  // VGA SRAM interface
  logic [9:0] VGA_RED_O_long, VGA_GREEN_O_long, VGA_BLUE_O_long;

  VGA_SRAM_interface VGA_unit (
    .Clock(CLOCK_50_I),
    .Resetn(resetn),
    .VGA_enable(VGA_enable),

    // For accessing SRAM
    .SRAM_base_address(VGA_base_address),
    .SRAM_address(VGA_SRAM_address),
    .SRAM_read_data(SRAM_read_data),

    // To VGA pins
    .VGA_CLOCK_O(VGA_CLOCK_O),
    .VGA_HSYNC_O(VGA_HSYNC_O),
    .VGA_VSYNC_O(VGA_VSYNC_O),
    .VGA_BLANK_O(VGA_BLANK_O),
    .VGA_SYNC_O(VGA_SYNC_O),
    .VGA_RED_O(VGA_RED_O_long),
    .VGA_GREEN_O(VGA_GREEN_O_long),
    .VGA_BLUE_O(VGA_BLUE_O_long)
  );

  assign VGA_RED_O = VGA_RED_O_long[9:2];
  assign VGA_GREEN_O = VGA_GREEN_O_long[9:2];
  assign VGA_BLUE_O = VGA_BLUE_O_long[9:2];

  // UART SRAM interface
  UART_SRAM_interface UART_unit(
    .Clock(CLOCK_50_I),
    .Resetn(resetn),

    .UART_RX_I(UART_RX_I),
    .Initialize(UART_rx_initialize),
    .Enable(UART_rx_enable),

    // For accessing SRAM
    .SRAM_address(UART_SRAM_address),
    .SRAM_write_data(UART_SRAM_write_data),
    .SRAM_we_n(UART_SRAM_we_n),
    .Frame_error(Frame_error)
  );

  // SRAM unit
  SRAM_Controller SRAM_unit (
    .Clock_50(CLOCK_50_I),
    .Resetn(~SWITCH_I[17]),
    .SRAM_address(SRAM_address),
    .SRAM_write_data(SRAM_write_data),
    .SRAM_we_n(SRAM_we_n),
    .SRAM_read_data(SRAM_read_data),
    .SRAM_ready(SRAM_ready),

    // To the SRAM pins
    .SRAM_DATA_IO(SRAM_DATA_IO),
    .SRAM_ADDRESS_O(SRAM_ADDRESS_O[17:0]),
    .SRAM_UB_N_O(SRAM_UB_N_O),
    .SRAM_LB_N_O(SRAM_LB_N_O),
    .SRAM_WE_N_O(SRAM_WE_N_O),
    .SRAM_CE_N_O(SRAM_CE_N_O),
    .SRAM_OE_N_O(SRAM_OE_N_O)
  );

  assign SRAM_ADDRESS_O[19:18] = 2'b00;

  always @(posedge CLOCK_50_I or negedge resetn) begin
    if (~resetn) begin
      top_state &lt;= S_IDLE;

      UART_rx_initialize &lt;= 1'b0;
      UART_rx_enable &lt;= 1'b0;
      UART_timer &lt;= 26'd0;

      VGA_enable &lt;= 1'b1;
    end else begin
      UART_rx_initialize &lt;= 1'b0;
      UART_rx_enable &lt;= 1'b0;

      // Timer for timeout on UART
      // This counter reset itself every time a new data is received on UART
      if (UART_rx_initialize | ~UART_SRAM_we_n) UART_timer &lt;= 26'd0;
      else UART_timer &lt;= UART_timer + 26'd1;

      case (top_state)
        S_IDLE: begin
          VGA_enable &lt;= 1'b1;
          if (~UART_RX_I | PB_pushed[0]) begin
            // UART detected a signal, or PB0 is pressed
            UART_rx_initialize &lt;= 1'b1;

            VGA_enable &lt;= 1'b0;

            top_state &lt;= S_ENABLE_UART_RX;
          end
        end
        S_ENABLE_UART_RX: begin
          // Enable the UART receiver
          UART_rx_enable &lt;= 1'b1;
          top_state &lt;= S_WAIT_UART_RX;
        end
        S_WAIT_UART_RX: begin
          if ((UART_timer == 26'd49999999) &amp;&amp; (UART_SRAM_address != 18'h00000)) begin
            // Timeout for 1 sec on UART for detecting if file transmission is finished
            UART_rx_initialize &lt;= 1'b1;

            VGA_enable &lt;= 1'b1;
            top_state &lt;= S_IDLE;
          end
        end
        default: top_state &lt;= S_IDLE;
      endcase
    end
  end

  assign VGA_base_address = 18'd0;

  // Give access to SRAM for UART and VGA at appropriate time
  assign SRAM_address = ((top_state == S_ENABLE_UART_RX) | (top_state == S_WAIT_UART_RX))
    ? UART_SRAM_address
    : VGA_SRAM_address;

  assign SRAM_write_data = UART_SRAM_write_data;

  assign SRAM_we_n = ((top_state == S_ENABLE_UART_RX) | (top_state == S_WAIT_UART_RX))
    ? UART_SRAM_we_n
    : 1'b1;

  //Milestone 1
  always_ff @ (posedge CLOCK_50_I or negedge resetn) begin
    if (resetn == 1'b0) begin
      SRAM_we_n &lt;= 1'b1;
      SRAM_write_data &lt;= 16'd0;
      SRAM_address &lt;= 18'd0;

      red = 16'd0;
      green = 16'd0;
      blue = 16'd0;
      r_hold = 16'd0;
      g_hold = 16'd0;
      b_hold = 16'd0;

      y = 16'd0;
      y_hold = 16'd0;

      u_prime = 16'd0;
      u_hold = 16'd0;
      u_comp [0] = 8'd0;
      u_comp [1] = 8'd0;
      u_comp [2] = 8'd0;
      u_comp [3] = 8'd0;
      u_comp [4] = 8'd0;
      u_comp [5] = 8'd0;

      v_prime  = 16'd0;
      v_hold = 16'd0;
      v_comp [0] = 8'd0;
      v_comp [1] = 8'd0;
      v_comp [2] = 8'd0;
      v_comp [3] = 8'd0;
      v_comp [4] = 8'd0;
      v_comp [5] = 8'd0;

      u_v_toggle = 8'd0;

      lead_in = 1'b1;

      state &lt;= S_IDLE;
    end else begin
      case (state)
        S_IDLE: begin
          red = 16'd0;
          green = 16'd0;
          blue = 16'd0;
          r_hold = 16'd0;
          g_hold = 16'd0;
          b_hold = 16'd0;

          y = 16'd0;
          y_hold = 16'd0;

          u_prime = 16'd0;
          u_hold = 16'd0;
          u_comp [0] = 8'd0;
          u_comp [1] = 8'd0;
          u_comp [2] = 8'd0;
          u_comp [3] = 8'd0;
          u_comp [4] = 8'd0;
          u_comp [5] = 8'd0;

          v_prime  = 16'd0;
          v_hold = 16'd0;
          v_comp [0] = 8'd0;
          v_comp [1] = 8'd0;
          v_comp [2] = 8'd0;
          v_comp [3] = 8'd0;
          v_comp [4] = 8'd0;
          v_comp [5] = 8'd0;

          u_v_toggle = 8'd0;


          SRAM_address &lt;= U_offset;
          uv_loc &lt;= 18'd0;
          y_loc &lt;= 18'd0;
          rgb_loc &lt;= 18'd0;
          SRAM_we_n &lt;= 1'b0;
          lead_in &lt;=1'b1;

          state &lt;= S_LEAD_IN_1_U;
        end

        S_LEAD_IN_1_U: begin
          u_hold &lt;= SRAM_read_data;
             u_comp [5] &lt;=u_hold[15:8];
             u_comp [4] &lt;=u_hold[15:8];
          u_comp [3] &lt;=u_hold[15:8];
          u_comp [2] &lt;=u_hold[7:0];
          SRAM_address &lt;= SRAM_address + 18'd1;
          uv_loc &lt;= uv_loc + 18'd1;
          state&lt;= S_LEAD_IN_2_U;
        end

        S_LEAD_IN_2_U: begin
          u_hold &lt;= SRAM_read_data;
          u_comp [1] &lt;=u_hold[15:8];
          u_comp [0] &lt;=u_hold[7:0];
          SRAM_address &lt;= V_offset;
          state&lt;= S_LEAD_IN_3_V;
        end

        S_LEAD_IN_3_V: begin
          v_hold &lt;= SRAM_read_data;
             v_comp [5] &lt;=u_hold[15:8];
             v_comp [4] &lt;=u_hold[15:8];
          v_comp [3] &lt;=u_hold[15:8];
          v_comp [2] &lt;=u_hold[7:0];
          SRAM_address &lt;= SRAM_address + 18'd1;
          state&lt;= S_LEAD_IN_4_V;
        end

        S_LEAD_IN_4_V: begin
          v_hold &lt;= SRAM_read_data;
          v_comp [1] &lt;=u_hold[15:8];
          v_comp [0] &lt;=u_hold[7:0];
          SRAM_address &lt;= Y_offset;
          state&lt;= S_LEAD_IN_Y;
        end

        S_LEAD_IN_Y: begin
          y = SRAM_read_data;
          u_prime [15:8] &lt;= u_comp[3];
          mult_1 &lt;= 159*(u_comp[3]+u_comp[2]);
          mult_2 &lt;= 52*(u_comp[4]+u_comp[1]);
          mult_3 &lt;= 21*(u_comp[5]+u_comp[0]);
          u_prime [7:0] &lt;= mult_1 - mult_2 + mult_3;
          y_loc &lt; y_loc + 18'd1
          SRAM_address &lt;= SRAM_address + 18'd1;
          state &lt;= S_READ_Y;
        end

        S_READ_Y: begin
          y_hold &lt;= SRAM_read_data;
          r = r_hold;
          g = g_hold;
          b = b_hold;
          v_prime [15:8] &lt;= v_comp[3];
          mult_1 &lt;= 159*(v_comp[3]+v_comp[2]);
          mult_2 &lt;= 52*(v_comp[4]+v_comp[1]);
          mult_3 &lt;= 21*(v_comp[5]+v_comp[0]);
          v_prime [7:0] &lt;= mult_1 - mult_2 + mult_3;
          uv_loc &lt;= uv_loc + 18'd1;
          SRAM_address &lt;= U_offset + uv_loc;
          state &lt;= S_READ_U;
        end

        S_READ_U: begin
          //still need the read u and if statement for every other clock cycle
          if(u_v_toggle == 8'd0) begin // toggle == 0, then read
                         u_hold &lt;= SRAM_read_data;
          end
          mult_1 &lt;= 76284*(y[15:8]-16);
          mult_2 &lt;= 104595*(v_prime[15:8]-128);
          mult_3 &lt;= 132251*(u_prime[15:8]-128);
          r_hold [15:8] = mult_1 + mult_2;
          b_hold [15:8] = mult_1 + mult_3;
          SRAM_address &lt;= V_offset + uv_loc;
          state &lt;= S_READ_V;
        end

        S_READ_V: begin
        if(u_v_toggle == 8'd0) begin // toggle == 0, then read
             v_hold &lt;= SRAM_read_data;
        end
          mult_2 &lt;= 53281(v_prime[15:8] - 128);
          mult_3 &lt;= 25624(u_prime[15:8] - 128);
          g_hold [15:8] &lt;= mult_1 - mult_2 - mult_3;
          SRAM_address &lt;= RGB_offset + rgb_loc;
          state &lt;= S_WRITE_R;
        end

        S_WRITE_R: begin
          mult_1 &lt;= 76284*(y[7:0]-16);
          mult_2 &lt;= 104595*(v_prime[7:0]-128);
          mult_3 &lt;= 132251*(u_prime[7:0]-128);
          r_hold [7:0] = mult_1 + mult_2;
          b_hold [7:0] = mult_1 + mult_3;

          u_comp[5] = u_comp[4];
          u_comp[4] = u_comp[3];
          u_comp[3] = u_comp[2];
          u_comp[2] = u_comp[1];
          u_comp[1] = u_hold[7:0];

             if(lead_in == 1'b0) begin
                    //if its not lead in then do the write to R othewise skip it
                    SRAM_write_data &lt;= r;

                    rgb_loc &lt;= rgb_loc + 18'd1;
                    SRAM_address &lt;= SRAM_address + rgb_loc;
                end
          state &lt;= S_WRITE_G;
        end

        S_WRITE_G: begin
          mult_2 &lt;= 53281(v_prime[7:0] - 128);
          mult_3 &lt;= 25624(u_prime[7:0] - 128);
          g_hold [7:0] &lt;= mult_1 - mult_2 - mult_3;

           if(lead_in == 1'b0) begin
               SRAM_write_data &lt;= g;
               rgb_loc &lt;= rgb_loc + 18'd1;
               SRAM_address &lt;= SRAM_address + rgb_loc;
            end

          v_comp[5] = v_comp[4];
          v_comp[4] = v_comp[3];
          v_comp[3] = v_comp[2];
          v_comp[2] = v_comp[1];
          v_comp[1] = v_hold[7:0];


          state &lt;= S_WRITE_B;
        end

        S_WRITE_B: begin
          if(lead_in == 1'b0) begin
                SRAM_write_data &lt;= b;
            rgb_loc &lt;= rgb_loc + 18'd1;
            SRAM_address &lt;= SRAM_address + rgb_loc;
          end
          y &lt;=y_hold;
          u_prime [15:8] &lt;= u_comp[3];
          mult_1 &lt;= 159*(u_comp[3]+u_comp[2]);
          mult_2 &lt;= 52*(u_comp[4]+u_comp[1]);
          mult_3 &lt;= 21*(u_comp[5]+u_comp[0]);
          u_prime [7:0] &lt;= mult_1 - mult_2 + mult_3;


          if(lead_in==1'b1) begin
            lead in &lt;=1'b0;
          end
           = u_v_toggle + 8'd1;
          if(u_v_toggle == 8'd2) begin //reset toggle after 2 cycles of the common case
            u_v_toggle = 8'd0;
          end
          state &lt;= S_READ_Y;
        end



        default: state &lt;= S_IDLE;
      endcase
    end


  end




  // 7 segment displays
  convert_hex_to_seven_segment unit7 (
    .hex_value(SRAM_read_data[15:12]),
    .converted_value(value_7_segment[7])
  );

  convert_hex_to_seven_segment unit6 (
    .hex_value(SRAM_read_data[11:8]),
    .converted_value(value_7_segment[6])
  );

  convert_hex_to_seven_segment unit5 (
    .hex_value(SRAM_read_data[7:4]),
    .converted_value(value_7_segment[5])
  );

  convert_hex_to_seven_segment unit4 (
    .hex_value(SRAM_read_data[3:0]),
    .converted_value(value_7_segment[4])
  );

  convert_hex_to_seven_segment unit3 (
    .hex_value({2'b00, SRAM_address[17:16]}),
    .converted_value(value_7_segment[3])
  );

  convert_hex_to_seven_segment unit2 (
    .hex_value(SRAM_address[15:12]),
    .converted_value(value_7_segment[2])
  );

  convert_hex_to_seven_segment unit1 (
    .hex_value(SRAM_address[11:8]),
    .converted_value(value_7_segment[1])
  );

  convert_hex_to_seven_segment unit0 (
    .hex_value(SRAM_address[7:4]),
    .converted_value(value_7_segment[0])
  );

  assign
    SEVEN_SEGMENT_N_O[0] = value_7_segment[0],
    SEVEN_SEGMENT_N_O[1] = value_7_segment[1],
    SEVEN_SEGMENT_N_O[2] = value_7_segment[2],
    SEVEN_SEGMENT_N_O[3] = value_7_segment[3],
    SEVEN_SEGMENT_N_O[4] = value_7_segment[4],
    SEVEN_SEGMENT_N_O[5] = value_7_segment[5],
    SEVEN_SEGMENT_N_O[6] = value_7_segment[6],
    SEVEN_SEGMENT_N_O[7] = value_7_segment[7];

  assign LED_GREEN_O = {resetn, VGA_enable, ~SRAM_we_n, Frame_error, top_state};

endmodule


The define_state.h:

`ifndef DEFINE_STATE

// This defines the states
typedef enum logic [1:0] {
    S_IDLE,
    S_ENABLE_UART_RX,
    S_WAIT_UART_RX
} top_state_type;

typedef enum logic [4:0] {

    S_IDLE,
    S_LEAD_IN_1_U,
    S_LEAD_IN_2_U,
    S_LEAD_IN_3_V,
    S_LEAD_IN_4_V,
    S_LEAD_IN_Y,
    S_WRITE_R,
    S_WRITE_G,
    S_WRITE_B,
    S_READ_Y,
    S_READ_U,
    S_READ_V,

} state_type;

typedef enum logic [1:0] {
    S_RXC_IDLE,
    S_RXC_SYNC,
    S_RXC_ASSEMBLE_DATA,
    S_RXC_STOP_BIT
} RX_Controller_state_type;

typedef enum logic [2:0] {
    S_US_IDLE,
    S_US_STRIP_FILE_HEADER_1,
    S_US_STRIP_FILE_HEADER_2,
    S_US_START_FIRST_BYTE_RECEIVE,
    S_US_WRITE_FIRST_BYTE,
    S_US_START_SECOND_BYTE_RECEIVE,
    S_US_WRITE_SECOND_BYTE
} UART_SRAM_state_type;

typedef enum logic [3:0] {
    S_VS_WAIT_NEW_PIXEL_ROW,
    S_VS_NEW_PIXEL_ROW_DELAY_1,
    S_VS_NEW_PIXEL_ROW_DELAY_2,
    S_VS_NEW_PIXEL_ROW_DELAY_3,
    S_VS_NEW_PIXEL_ROW_DELAY_4,
    S_VS_NEW_PIXEL_ROW_DELAY_5,
    S_VS_FETCH_PIXEL_DATA_0,
    S_VS_FETCH_PIXEL_DATA_1,
    S_VS_FETCH_PIXEL_DATA_2,
    S_VS_FETCH_PIXEL_DATA_3
} VGA_SRAM_state_type;

`define DEFINE_STATE 1
`endif


All the states have been defined in an external file define_state.h, there shouldn't be any previous declarations of the state (I have checked this to the best of my ability.)Thus, I am unsure as to why the error is persisting..

I have been attempting to fix the issue for quite some time now to no avail.

Any help would be appreciated","You have two enum types that use the same value - S_IDLE. That is not allowed. enum types in the same scope are not allowed to share values. You either need to think of a different name or put the two type declarations in separate packages. These type definitions would be better off in a package, anyway, rather than using an include file as you have.

typedef enum logic [1:0] {
    S_IDLE,                           // here
    S_ENABLE_UART_RX,
    S_WAIT_UART_RX
} top_state_type;

typedef enum logic [4:0] {
    S_IDLE,                            // and here 
    S_US_STRIP_FILE_HEADER_1,
    S_US_STRIP_FILE_HEADER_2,
    S_US_START_FIRST_BYTE_RECEIVE,
    S_US_WRITE_FIRST_BYTE,
    S_US_START_SECOND_BYTE_RECEIVE,
    S_US_WRITE_SECOND_BYTE
} UART_SRAM_state_type;
",,,,,
Vivado Clock Implementation error SystemVerilog,"I get the following implementation error. I have not clocks in my design. How can I fix this?

Implementation
Place Design
[Place 30-574] Poor placement for routing between an IO pin and BUFG. If this sub optimal condition is acceptable for this design, you may use the CLOCK_DEDICATED_ROUTE constraint in the .xdc file to demote this message to a WARNING. However, the use of this override is highly discouraged. These examples can be used directly in the .xdc file to override this clock rule.
    &lt; set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets en_IBUF] >

en_IBUF_inst (IBUF.O) is locked to IOB_X0Y11
 and en_IBUF_BUFG_inst (BUFG.I) is provisionally placed by clockplacer on BUFGCTRL_X0Y0


[Place 30-99] Placer failed with error: 'IO Clock Placer failed'
Please review all ERROR, CRITICAL WARNING, and WARNING messages during placement to understand the cause for failure.

[Common 17-69] Command failed: Placer could not place all instances","It looks like you are attempting to use a non-global-clock-capable pin as a clock inside your design. I am not sure what you mean by ""I have not clocks in my design"", do note that even if your design is asynchronous I believe Vivado will use clock resources for latch enables - or it is possible that you do have clocks (this will be any always @(posedge ...) for example) and don't realise it.

Either you need to use a clock capable pin for the clock input; or accept possible issues such as duty cycle distortion from using non-clock-capable routing and suppress the error using the suggested ""set_property"" command in your xdc file.",,,,,
Coverage for a bus with struct type,"I have a bus of following type 

typedef struct            packed {
      logic                vld;
      logic [ASI_MAX_PCL_CYC_M:0]  cyc;
   } type_t;

with a certain width say [3:0]

So type_t [3:0] my_bus_req;

How do i write a coverpoint which says that at any clock cycle, only one vld is high
i.e my_bus_req[0].vld = 1 and rest = 0. (Only one request coming in )

if the signal wasn't a struct type eg logic [3:0] my_req_bus;
we could have simple done 

coverpoint i iff (my_bus_req[i].vld == 1 &amp;&amp; $onehot(my_bus_req))

but not sure how it can be done for a bus of struct type","Since you made this a packed array, there's no simple expression you can use directly without creating a separate function or casting to an unpacked array.

typedef type_t type_unpacked_t[4];
type_unpacked temp;
temp = type_unpacked'(my_bus_req);
...
coverpoint i iff (temp[i].vld == 1 &amp;&amp; temp.sum() with (int'(item.vld)) == 1)
",,,,,
VHDL; How do I constrain a unconstrained std_logic_vector within a constrained array,"Consider the following 

type foo is (A, B, C);
type foo_vector is array (foo) of std_logic_vector;


How do I constrain foo_vector? It seems like the compiler should be able to constrain the signal if I give it defaults. 

signal bar : foo_vector : (others =&gt; x""0000""); 


But the compiler just continues to say ""Signal cannot be unconstrained""

If that's the case then how can I constrain this signal? 

signal bar : foo_vector(?)(15 downto 0);


I am using the Lattice compiler. 

Alternatively, If I do 

type baz_vector is array (natural range &lt;&gt;) is std_logic_vector;


And I try to constrain the signal by doing this: 

signal baz_vector_signal : baz_vector(1 downto 0)(15 downto 0);


The code compiles. So I know that the compiler is capable of handling unconstrained arrays (VHDL2008). ","Your code snippets don't provide a minimal, reproducible example. 

You're attempting to provide an element constraint for the element of type std_logic_vector while the array index is already constrained. 

That's possible:

library ieee;
use ieee.std_logic_1164.all;

package cjc_pkg is
    type foo is (A, B, C);
    type foo_vector is array (foo) of std_logic_vector;
    signal bar: foo_Vector (open) (3 downto 0) := (others =&gt; (others =&gt; '0'));
end package;


using an array constraint found in IEEE Std 1076-2008 5.3.2 Array types, 5.3.2.1 General, (the BNF) in the subtype indication for the declaration of signal bar:


  constrained_array_definition ::=
  array index_constraint of element_subtype_indication


subtype_indication is defined 6.3 Subtype declarations and consist of a optional resolution indication, type mark and constraint. Here we are dealing with the unconstrained element.

From 6.3:


  constraint ::=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;range_constraint
  &nbsp;&nbsp;&nbsp;&nbsp;| array_constraint
  &nbsp;&nbsp;&nbsp;&nbsp;| record_constraint  
  
  element_constraint ::=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array_constraint
  &nbsp;&nbsp;&nbsp;&nbsp;| record_constraint  


which bounces us back to 5.3.2.1:


  array_constraint ::=
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index_constraint [ array_element_constraint ]
  &nbsp;&nbsp;&nbsp;&nbsp;| ( open ) [ array_element_constraint ]  
  
  array_element_constraint ::= element_constraint
  ...
  index_constraint ::= ( discrete_range { , discrete_range } )  
  
  discrete_range ::= discrete_subtype_indication | range
  
  An array constraint may be used to constrain an array type or subtype (see 5.3.2.2 and 6.3).  
  
  An array object is characterized by the number of indices (the dimensionality of the array); the type, position, and range of each index; and the type and possible constraints of the elements. The order of the indices is significant.


You can use (open) as a space holder to skip over a constrained index preserving the order significance of the constrained index.

The example will analyze with a -2008 compatible VHDL implementation.",,,,,
How to load coverage_db?,"I'm trying to write a functional coverage for my design. I wrote needed covergroups, but now I faced with difficulties to transport my coverage between test runs.
Here a few code examples:

`include ""uvm_macros.svh""
package t;
    import uvm_pkg::*;

    class test extends uvm_test;
        `uvm_component_utils(test)
        byte unsigned data;
        covergroup cg;
            dat: coverpoint data;
        endgroup

        function new(string name, uvm_component parent);
            super.new(name,parent);
            cg = new();
        endfunction: new

        task run_phase(uvm_phase phase);
            phase.raise_objection(this);
            repeat(5) begin
                #5data = $urandom();
                #10 cg.sample();
            end
            phase.phase_done.set_drain_time(this, 50ns);
            phase.drop_objection(this);
        endtask
    endclass: test
endpackage

module top();
    import uvm_pkg::*;
    import t::*;
    initial begin
        $load_coverage_db(""coverage_report.db"");
        $set_coverage_db_name(""coverage_report.db"");
        run_test();
    end
endmodule


If I try to run test above, I get this error:


  ** Error: (vsim-6844) Covergroup '/t/test/cg' has no instance created in simulation, ignoring it


Clearly, the problem is that cg created after test start, while config_db loading when it's not created yet. So I placed $load_coverage_db in run_phase like this:

`include ""uvm_macros.svh""
package t;
    import uvm_pkg::*;

    class test extends uvm_test;
        `uvm_component_utils(test)
        byte unsigned data;
        covergroup cg;
            dat: coverpoint data;
        endgroup

        function new(string name, uvm_component parent);
            super.new(name,parent);
            cg = new();
        endfunction: new

        task run_phase(uvm_phase phase);
            $load_coverage_db(""coverage_report.db"");
            phase.raise_objection(this);
            repeat(5) begin
                #5data = $urandom();
                #10 cg.sample();
            end
            phase.phase_done.set_drain_time(this, 50ns);
            phase.drop_objection(this);
        endtask
    endclass: test
endpackage

module top();
    import uvm_pkg::*;
    import t::*;
    initial begin
        $set_coverage_db_name(""coverage_report.db"");
        run_test();
    end
endmodule


Now, I'm getting this type of warning:


  ** Warning: (vsim-6841) Covergroup instance '/t::test::cg ' exists in simulation but not found in database


What I need to do, to get my old coverage in test?","After I already wrote a python script that creates and updates my own sqlite database after each run of tests from the coverage exported to a text file,I finally found out that there is a vcover merge command in questa sim that merges the coverage of all tests.
As far as I understand, this is the generally accepted practice: to keep the coverage of each of the tests and merge them together, rather than loading the total coverage into each of the new tests.
But there is still a problem that vcover has very poor help and there is practically no mention of it in the documentation.",,,,,
Is this a verilog race condition?,"Is there something about this code that would produce a race condition? If I run it as is, seems to hang. If I make the small change noted below it performs as intended. 

This isn't the complete code, I just wanted to post enough to see if someone recognized something obvious. I'm stumped. I can post the entire code is someone wants it. Thanks.

wire clk;        

// core
reg src_in; // 0 = ram, 1 = uart
initial src_in = 1'b1; 
reg src_out;
initial src_out = 1'b1;
reg src_in_;
reg src_out_;
wire [7:0] I = src_in ? term_in : data_read;
wire emit;

always @* begin         

    // //src_in
    case(I)
        ""}"" :       src_in_ = 1'b1; // 1 = uart 
        ""]"" :       src_in_ = 1'b0; // 0 = ram
        default:    src_in_ = src_in; //!!!!!!!!!! if I change this to 1'b0 there is no problem
    endcase         


    // //src_out
    case(I)
        ""{"" :       src_out_ = 1'b1; // 1 = uart 
        ""["" :       src_out_ = 1'b0; // 0 = ram
        default:    src_out_ = src_out; //!!!!!!!!!! if I change this to 1'b0 there is no problem
    endcase     

end

always @(posedge clk) begin
    {R, L} &lt;= {R_, L_};
    {src_in, src_out} &lt;= {src_in_, src_out_};
end
","If your code 'hangs' you have a combinatorial loop, not a race condition.
Thus somewhere you have a series of a=b; b=c; c=~d; d=a;

I don't immediately see one in the code above so I suspect it is in the code you do not show. 

One way of finding those is to step through the code. 

That can be very tedious with a big design so another way you can try is to sprinkle delays throughout the code where you suspect the problem is (e.g. add #5;) and check the waveform, That is for debugging only!!
In that case make sure your clock is much slower. e.g. use #1000. 

This is an example waveform I made of a combinatorial loop (a=~b&amp;clk; b=a;)with a #5 in it:

",,,,,
VHDL LR shifter circular not updating,"I have my code here but when i run my TB i have the problem that my shifting does not work when i leave the left ='1'  and the clock has another rising edge. 

the objective here is to make a left right parallel shifting register.
the register has to update on every rising edge of the clock.
when le is high it loads information, when left is high it should do a left circular shift. if right is high it should do right circular shift.

table explaining function of register
What do i do wrong?

---------------------------------------------------------
-- Description: 
--  An n-bit register (parallel in and out) with left and right shift
--  functionality (circular).
--
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity lr_shift_par_load is
    generic(
        C_REG_WIDTH : natural := 8
    );
    port(
          reset : in  STD_LOGIC;
            clk : in  STD_LOGIC;
           left : in  STD_LOGIC;
          right : in  STD_LOGIC;
             le : in  STD_LOGIC;
         par_in : in  STD_LOGIC_VECTOR(C_REG_WIDTH-1 downto 0);
        par_out : out STD_LOGIC_VECTOR(C_REG_WIDTH-1 downto 0)
    );
end lr_shift_par_load;

architecture Behavioral of lr_shift_par_load is

    signal reg_i : std_logic_vector(C_REG_WIDTH-1 downto 0) := (others=&gt;'0');
begin

    -- TODO: Write a process that implements the correct behaviour for reg_i.
    --   This should be a good refresher of your knowledge of last year.
    process(clk,reset)
    begin
        if(reset = '1')then
            reg_i &lt;= (others=&gt;'0');
        end if;
        if(rising_edge(clk)) then
            if(le ='1') then
                -- load
                reg_i &lt;= par_in;
            elsif(le ='0' and left ='1')then 
                -- shift left
                reg_i &lt;= par_in(C_REG_WIDTH-2 downto 0) &amp;  par_in(C_REG_WIDTH-1);
            elsif(le ='0' and left ='0'and right ='1')then
                -- shift right
                reg_i &lt;= par_in(0) &amp; par_in(C_REG_WIDTH-1 downto 1);
            elsif(le ='0' and left ='0'and right ='0')then
                --hold
                reg_i &lt;= par_in;
            end if;
        end if;
     end process;

    par_out &lt;= reg_i;

end Behavioral;
","When shifting you use the input vector 'par_in'. You probably want to use the shift register itself: 'reg_i'.

Also your conditions are unnecessary complex.

 if(le ='1') then
    -- load
     reg_i &lt;= par_in;
 elsif(le ='0' ... &lt;&lt; Why are you testing for this? 
                      If ""le"" was not zero it would never get here 
                      but get handled in the first 'if'.


Same here:

(le ='0' and left ='0'and right ='1') then


(le ='0' and left ='0' is superflous. ",,,,,
How to write Thread application in DO file of Model-sim 10.5c using TCL?,"I have a FPGA logic, which contains the Logic-A and Logic-B functionalities.
I need to create two threads in DO file (TCL) for driving the data to the FPGA Inputs.

Thread 1: FPGA Inputs.

'#sim:/tb_uut/uut/DATA_IN 1F 00'


Thread 2: Provide the inputs to B_IN in Logic B, when A_IN is high, otherwise ignore B_IN.

    '#If { [examine sim:/tb_uut/Logic_B/A_IN]==1} { #sim:/tb_uut/Logic_B/B_IN 1 0 #}'


Here I need to monitor the value of the A_IN until getting high.
I am able to drive the B_in during post synthesis simulations by accessing B_IN.
I am unable to create two different threads for continuous monitoring of A_IN and driving DATA_IN to FPGA.

How to create the thread in TCL?

Whether threads will be supporting in modelsim 10.5c or not?

How to independently provide the Inputs using DO and VHDL files ?","You can't use TCL threads in ModelSim, it's not supported. This is also not the way to do things in parallel for a VHDL simulation.

Instead, register a TCL callback which executes when the signal you are monitoring changes. You can continue to drive the other signal while monitoring first one. Refer to the ""when"" command in the ModelSim Command Reference Manual.

I've constructed this example which demonstrates how you can use the ""when"" command in a ModelSim TCL script.

In the TCL script:

when -label MyLabel {A_IN == '1'} {
  echo ""Hello from TCL at $now ns""
}

run -all


The VHDL process:

process
begin

  wait for 10 ns;
  A_IN &lt;= '1';
  wait for 10 ns;
  A_IN &lt;= '0';
  wait for 10 ns;
  A_IN &lt;= '1';
  wait for 10 ns;
  A_IN &lt;= '0';

  report ""VHDL simulation finished"";
  finish;

end process;


The output to the ModelSim console after we run the TCL script:

VSIM 1&gt; do run.do
# Hello from TCL at 10 ns
# Hello from TCL at 30 ns
# ** Note: VHDL simulation finished
#    Time: 40 ns  Iteration: 0  Instance: /ent
",,,,,
replace `define with let construct,"I'm trying to avoid using `define pre-processor and start using ""let"" since it's a language construct.

Here is my example:

`define MY_REGISTER_RANGE 15:0

logic [`MY_REGISTER_RANGE] my_array;


How can I do the same with let construct? My code is very simple but it assumes that I'm `include the file where my macro MY_REGISTER_RANGE is defined (in another file).

Thanks.","In this particular case you do not need the let construct. Moreover, the construct has nothing to do with declarations of variables. 

You can start using parameters instead of text macros. For example

parameter MY_REGISTER_WIDTH = 16;
...
logic [MY_REGISTER_WIDTH-1:0] my_array;


The let construct defines a simple function containing a single expression. In this respect it could be used to replace certain types of macros, e.g.

`define MULT(A,B)   A * B
...
R = `MULT(O1,O2);


could be replaced with

let MULT(A,B) = A * B;
...
R = MULT(O1,O2);
",,,,,
problem in jumping to system verilog macros `define in VIM using ctags,"I checked following things, tags file path is set properly.

the macro tag i am looking for exist in the tags file. task/function/parameters etc works without hiccups. i have problem only with regex. 

the expression present in ctags file are 

1. --regex-SystemVerilog=/^\s*`define\b\s*(\w+)/`\1/d,define/ 
2. --regex-systemverilog=/^[ \t]*`define[ \t]*([a-zA-Z_0-9]+)/`\1/d,define/


both the options does not work.","When :tag `altuvm_test_arg works, but the corresponding CTRL-] key doesn't, this often is caused by incompatible 'iskeyword' definitions, so that actually gets passed to :tag is altuvm_test_arg (without the leading backtick).

You can check the scope of keyword matching (when on such a tag) with the * command, which highlights the same keyword under the cursor. If backticks are excluded, try adding the backtick to the range of keyword characters:

:setlocal iskeyword+=`


If this helps (and doesn't break things like syntax highlighting, or annoys you with the changed navigation of commands like w and e), you can make that setting permanent for verilog filetypes put putting it in ~/.vim/after/ftplugin/verilog.vim.",,,,,
Can enum be made an output in systemverilog?,"In verilog, I can do something like this:

module controller (
    input rstb, clk, start,
    output reg [1:0] state, next_state
);
    parameter S_idle = 2'b00, S_1 = 2'b01, S_2 = 2'b11;

    always @ (posedge clk, negedge rstb)
    begin
        if (!rstb) state &lt;= S_idle;
        else state &lt;= next_state;
    end
...
endmodule


But in systemverilog, this will generate an error since I declared state, next_state twice:

module controller (
    input rstb, clk, start,
    output logic [1:0] state, next_state
);
    enum logic [1:0] {S_idle, S_1, S_2} state, next_state;

    always_ff @ (posedge clk, negedge rstb)
    begin
        if (!rstb) state &lt;= S_idle;
        else state &lt;= next_state;
    end
...
endmodule


I suppose I could rename my output ports to state_out, next_state_out and assign them to state, next_state. Is there an easier way to use the enum as an output?","When using user defined types, you should use a typedef and put them in a package so they can be shared amongst the modules that use them. Otherwise you run into type incompatibility assignment errors.

package stuff;
  typedef enum logic [1:0] {S_idle, S_1, S_2} state_t;
endpackage


module controller import stuff::*; (
        input logic rstb, clk, start,
        output state_t state, next_state
    );
        always_ff @ (posedge clk, negedge rstb)
        begin
            if (!rstb) state &lt;= S_idle;
            else state &lt;= next_state;
        end
    ...
 endmodule
",,,,,
Are there any reccomended styleguides or quick reference sheets for VHDL?,"I have been writing VHDL for a short time now, so I feel this is a good time to start making sure my coding is in a good style. I have had trouble finding any good style guides or quick ref. sheets for this. I am thinking of something like the Barr group embedded C standard, but for VHDL. 

Does something like this exist?","The following style is recommended by CERN BE-CO-HT

i_   Input signal 
o_   Output signal 
s_   signal
c_   Constant 
g_   Generic  
t_   User-Defined Type 


There are many other recommendations. You can have a look at coding style followed in CERN BE-CO-HT https://ohwr.org/project/vhdl-style/blob/master/doc/vhdl-coding-style.adoc",,,,,
Functions within VHDL,"I am trying to read the output from multiple components and display them within an integer form. The outputs are all 4-bit vectors. As I do not want to have to repeat the code numerous times, I am trying the use of functions native to VHDL. I have not used these before and also cannot see much well-explained documentation online. 

function FourBitsToNumber (X : std_logic_vector(3 downto 0))
return integer is
begin
if (X = ""0000"") then return 0;
  elsif (X = ""0001"") then return integer(1);
  elsif (X = ""0010"") then return integer(2);
  elsif (X = ""0011"") then return integer(3);
  elsif (X = ""0100"") then return integer(4);
  elsif (X = ""0101"") then return integer(5);
  elsif (X = ""0110"") then return integer(6);
  elsif (X = ""0111"") then return integer(7);
  elsif (X = ""1000"") then return integer(8);
  elsif (X = ""1001"") then return integer(9);
 end if;
end FourBitsToNumber;


I am calling the function on the clock pulse with the following code:

variable1 &lt;= FourBitsToNumber(A);


...With 'variable1' being of type integer declaration. 'A' is a 4-bit vector.

However, from my test bench, I can see that the line of code is being reached but am just receiving a value of 0 throughout (even when I know it should be more). 

My guess is maybe the syntax or another stupid error on my behalf. ","Try this...

function my_int(X : std_logic_vector(3 downto 0)) return integer is
    begin
        return to_integer(unsigned(X));
end function my_int;


I have a feeling that this could also work with an undefined length slv...
e.g.

function my_int_of_any_len(X : std_logic_vector) return integer is
    begin
        return to_integer(unsigned(X));
end function my_int_of_any_len;


Matthew's suggestion: (see his comment below)

function my_int(X : std_logic_vector(3 downto 0)) return integer is
use ieee.numeric_std.all;
    begin
        return to_integer(unsigned(X));
end function my_int;


I should also point out that you dont actually have to build your own function for this. Where you have said that you want an integer, just put variable1 &lt;= to_integer(unsigned(X));",,,,,
VHDL - How to compare two bit_vectors for dynamic table lookup,"I'm storing two tables in two signals. One table keeps the key (address) and the other keeps the value corresponding to the key. I need to compare an input to the key and, if they match, return the value stored.

The reason why I need this is for a dynamic lookup table for branch instruction prediction. In the fetch stage of a processor I get the input Instruction_Address and I return a branch_To_Address and a branch_Prediction. Initially I want to store 16 predictions/branch addresses and use a circular buffer ring to overwrite as needed.

I've been trying to use a FOR with a nested IF to search for the key inside keyTable.

The whole module seems to work fine, except when I compare two bit_vectors with the IF statement. I need this twice (one on read and another on write) and hence I need to ""sweep"" the keysTable so I can see if the address that is being looked up has an entry.

I noticed the error upon simulation, where the ELSE clause is being called always regardless of the keysTable having the right entries.

Verifiable example:

library IEEE;
use ieee.numeric_bit.all;

entity branch_prediction_table is
generic (
    addrSize    : NATURAL   := 4;
    tableSize   : NATURAL   := 4);
port (
    clock : in bit;
    input_addr: in bit_vector(addrSize-1 downto 0);
    return_value : out bit );
end branch_prediction_table;

architecture branch_table of branch_prediction_table is

    signal keysTable : bit_vector(addrSize*tableSize-1 downto 0) := ( others =&gt; '0');
    signal valuesTable : bit_vector(tableSize*2-1 downto 0) := ( others =&gt; '0');

begin

    tableProc: process(clock) is

        variable valueFromTable : bit;
    begin
        if rising_edge(clock) then

            search_table: for iR in (tableSize-1) to 0 loop

                if (keysTable(addrSize*(iR+1)-1 downto addrSize*iR) = input_addr) then
                    valueFromTable := valuesTable((iR+1)*2-1);
                    EXIT search_table;
                else
                    valueFromTable := '0';
                end if;

            end loop search_table;

            return_value &lt;= valueFromTable;

        end if; -- rising_edge(clock)
    end process tableProc;
end branch_table;


with verifiable testbench simulation TCL:

add wave -position insertpoint  \
sim:/branch_prediction_table/addrSize \
sim:/branch_prediction_table/clock \
sim:/branch_prediction_table/input_addr \
sim:/branch_prediction_table/keysTable \
sim:/branch_prediction_table/return_value \
sim:/branch_prediction_table/tableSize \
sim:/branch_prediction_table/valuesTable
force -freeze sim:/branch_prediction_table/valuesTable 11111111 0
force -freeze sim:/branch_prediction_table/keysTable 1111101001100011 0
force -freeze sim:/branch_prediction_table/clock 0 0, 1 {5000 ps} -r {10 ns}
run 10 ns
force -freeze sim:/branch_prediction_table/input_addr 1010 0
run 20 ns
force -freeze sim:/branch_prediction_table/input_addr 1111 0
run 10 ns


and testbench simulation result showing that error is indeed in the IF:


I have tried converting them with to_integer(unsigned(bit_vector1)) = to_integer(unsigned(bit_vector2)) with no avail","As user1155120 pointed out:
The problem lies within search_table: for iR **in** (tableSize-1) to 0 loop
It should've been &quot;down to&quot; as L &gt; R. Since I used &quot;in&quot; with L&gt;R, that produces a null range and the for loop iteration is said to be complete.

(IEEE Std 1076-2008 5.2 Scalar types, &quot;A range specifies a subset of values of a scalar type. A range is said to be a null range if the specified subset is empty. The range L to R is called an ascending range; if L &gt; R, then the range is a null range. The range L downto R is called a descending range; if L &lt; R, then the range is a null range.&quot;).
10.10 Loop statement &quot;For the execution of a loop with a for iteration scheme, the discrete range is first evaluated. If the discrete range is a null range, the iteration scheme is said to be complete, ...&quot;
",,,,,
What does the expression mean(^bus === 1'bX) in verilog?,I was finding a way to detect any x or z present in input so I find out this (^bus === 1'bX) but I am unable to interpret it. How are we able to detect x or z using this expression and with whom are we doing the xor of bus?,"The left side ^bus is unary reduction xor operator. For example, if bus is three bits wide, ^bus is equivalent to bus[0] ^ bus[1] ^ bus[2]. If any of the bits is X or Z, it is propagated to the result.
The right side 1'bX is a 1-bit wide literal that has all bits set to X.
The operator === compares the sides, including equality of X and Z states.",,,,,
Carry-out bit detection in Verilog,"Just started to learn about Verilog. Anyway, I can't figure out why my code doesn't output the overflow into the carry bit cout. So, the addition of 8'h~42 + 8'h45 + 1'b1 = 9'h103. However, I can't seem to get the overflow in the cout (Shown in the code below). The 9th bit is truncated. All I had gotten was 003 (The carry-out bit is still 0), instead of 103. Not sure where I'm going wrong with this. Hope someone can help!
Note - Matrix_A and Matrix_B hex values are gotten from a COE file, which is 42 and 45 respectively.
wire [0:0] cout;
wire    [7:0] matrix_A;
wire    [7:0] matrix_B;
wire [7:0] matrix_BA;

assign {cout,matrix_BA} = (~matrix_A + matrix_B + 1'b1);
","Tested at Edaplayground. I can't see anything wrong with it......
EDIT: actually, my example was a bit different than yours. Rewritting the design and the testbench gives me a hint: when you add the three components in the assign, all of them are &quot;promoted&quot; to 9 bits, but as you are negating matrix_A, the promoted bit is negated as well.
~42h + 45h + 1 = ~01000010 + 01000101 + 1 = (promoted to 9 bits) =
~001000010 + 001000101 + 000000001 = (applying negation) = 
110111101 + 001000101 + 000000001 = 1000000011 (a 10 bit result, which is
truncated to 9 bits) = 000000011 , making your carry to be 0.

Try this:
assign {cout,matrix_BA} = {1'b0, ~matrix_A} + {1'b0, matrix_B} + 9'b1;

You can test it by yourself here: https://www.edaplayground.com/x/iGQP",,,,,
Why are the bits in this Verilog wire assigned as 'z'?,"I am trying to create a multiplication module in Verilog for an ALU project.
When I pass test values to this modules, 0100101010011100 and 0100110000000000 and print these values with  $display(), they appear normal. However, if I try to print one of my calculated values like p0-p15, it shows 16bits of z. I don't understand why this is happening, because it appears I am assigning {16{inputA[0]}} &amp; inputB[15:0] which shows valid results when I print it out.
The only conclusion that I can come to is that I am either calling this module improperly, or assigning the values improperly.
Should I be using reg instead of wires for the 15 'p' variables?
module Product(inputA, inputB, Output);
    input [15:0] inputA, inputB;
    output [31:0] Output;

//calculate 16 subproducts
wire [15:0] p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15;
//assign p0[15:0]  = {16{inputA[0]}} &amp; inputB[15:0];
assign p0[15:0]  = {16{inputA[0]}} &amp; inputB[15:0];
assign p1[15:0]  = {16{inputA[1]}} &amp; inputB[15:0];
assign p2[15:0]  = {16{inputA[2]}} &amp; inputB[15:0];
assign p3[15:0]  = {16{inputA[3]}} &amp; inputB[15:0];
assign p4[15:0]  = {16{inputA[4]}} &amp; inputB[15:0];
assign p5[15:0]  = {16{inputA[5]}} &amp; inputB[15:0];
assign p6[15:0]  = {16{inputA[6]}} &amp; inputB[15:0];
assign p7[15:0]  = {16{inputA[7]}} &amp; inputB[15:0];
assign p8[15:0]  = {16{inputA[8]}} &amp; inputB[15:0];
assign p9[15:0]  = {16{inputA[9]}} &amp; inputB[15:0];
assign p10[15:0] = {16{inputA[10]}} &amp; inputB[15:0];
assign p11[15:0] = {16{inputA[11]}} &amp; inputB[15:0];
assign p12[15:0] = {16{inputA[12]}} &amp; inputB[15:0];
assign p13[15:0] = {16{inputA[13]}} &amp; inputB[15:0];
assign p14[15:0] = {16{inputA[14]}} &amp; inputB[15:0];
assign p15[15:0] = {16{inputA[15]}} &amp; inputB[15:0];

initial begin
    $display(&quot;%b&quot;,inputA);
    $display(&quot;%b&quot;,inputB);
    $display(&quot;----------------&quot;);
    $display(&quot;%b&quot;, {16{inputA[0]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[1]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[2]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[3]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[4]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[5]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[6]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[7]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[8]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[9]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[10]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[11]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[12]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[13]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[14]}} &amp; inputB[15:0]);
    $display(&quot;%b&quot;, {16{inputA[15]}} &amp; inputB[15:0]);
    $display(&quot;----------------&quot;);
    $display(&quot;%b&quot;,p0);
    $display(&quot;%b&quot;,p1);
    $display(&quot;%b&quot;,p2);
    $display(&quot;%b&quot;,p3);
    $display(&quot;%b&quot;,p4);
    $display(&quot;%b&quot;,p5);
    $display(&quot;%b&quot;,p6);
    $display(&quot;%b&quot;,p7);
    $display(&quot;%b&quot;,p8);
    $display(&quot;%b&quot;,p9);
    $display(&quot;%b&quot;,p10);
    $display(&quot;%b&quot;,p11);
    $display(&quot;%b&quot;,p12);
    $display(&quot;%b&quot;,p13);
    $display(&quot;%b&quot;,p14);
    $display(&quot;%b&quot;,p15);
    $display(&quot;----------------&quot;);
end


wire [31:0] s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13,s14,s15;
assign s0[31:0]  = p0  &lt;&lt; 0;
assign s1[31:0]  = p1  &lt;&lt; 1;
assign s2[31:0]  = p2  &lt;&lt; 2;
assign s3[31:0]  = p3  &lt;&lt; 3;
assign s4[31:0]  = p4  &lt;&lt; 4;
assign s5[31:0]  = p5  &lt;&lt; 5;
assign s6[31:0]  = p6  &lt;&lt; 6;
assign s7[31:0]  = p7  &lt;&lt; 7;
assign s8[31:0]  = p8  &lt;&lt; 8;
assign s9[31:0]  = p9  &lt;&lt; 9;
assign s10[31:0] = p10 &lt;&lt; 10;
assign s11[31:0] = p11 &lt;&lt; 11;
assign s12[31:0] = p12 &lt;&lt; 12;
assign s13[31:0] = p13 &lt;&lt; 13;
assign s14[31:0] = p14 &lt;&lt; 14;
assign s15[31:0] = p15 &lt;&lt; 15;
end module

    module testbench();

 
  reg [4:0] i;
  parameter n=16;
  reg [15:0] inputA;
  reg [15:0] inputB;
  reg [4:0] opcode;
 
  
 
  wire  [31:0] out1; 
  wire [1:0] out2; 
  
  
  wire [15:0] a,b;
  assign a =16'b0100_1010_1001_1100;
  assign b =16'b0100_1100_0000_0000;
  
  
  Product prod(a, b, out1);
endmodule
","This is a time-0 race condition because you have not given enough time for the inputs to propagate to the outputs. Other simulators show non-z results. You can add a #1 before you display any of your signals.
In general simulation needs time to propagate all statements that happen concurrently.",,,,,
Checking the value of output signal over a period of time,"I've got an initial block which calls a task named power_task as below
initial begin
#10;
power_task;
end

Inside the power task, I've two signals power_a and power_b. Initially, power_a goes low and after a certain skew, power_b goes low. As long as both the signals are low, I need to check the output q. Output q should be low during the time window where power_a and power_b signals are low. Since there are no other signals like a clock, I'm not sure how to continuously monitor q.  I've written something like below
task power_task;

#1;
power_a=0;
#5; //skew
power_b=0;
   if (power_a==0 &amp;&amp; power_b==0 &amp;&amp; q==0) begin
   $display(&quot;pass&quot;);
   end
#50;
power_b=1;
#5;
power_a=1;
end
endtask

In the above task, the if statements check the value of q only after both signals are low and not during the entire 50 ns time window. Can someone please help?","You can use a wait statement in a fork block
task power_task;
  begin
    reg fail;
    fail = 0;
    #1 power_a=0;
    #5 power_b=0; //skew
    fork : check_q
      wait (q) fail = 1;
      #50 begin
          if (fail) 
            $display(&quot;fail&quot;);
          else
            $display(&quot;pass&quot;);
          disable check_q;
        end
    join
    power_b=1;
    #5 power_a=1;
  end
endtask

Not exactly sure why you need to check that power_a/b are still 0 unless there is some other code that could change it.",,,,,
verilog Error in If statement. (reg) is not a constant. Target <reg> of concurrent assignment or output port connection should be a net type,"I'm making a 8Bit select adder with 4bit adder.
When i try to test this code.
i got a 2 error.
First one is &quot;coutL is not a constant&quot;
Second one is &quot;Target  of concurrent assignment or output port
connection should be a net type.&quot;
Can anyone help me?
module selectAdd8(
    input [7:0] a,
    input [7:0] b,
    input cin,
    output reg [7:0] sum,
    output reg cout
    );

    reg coutL, sumL, sum0, sum1, cout0, cout1;
    
    always @ (*);

        begin
            
            add4 add_lower(a[3:0],b[3:0],cin,sumL,coutL);
            add4 add4_0(a[7:4],b[7:4],0,sum0,cout0);
            add4 add4_1(a[7:4],b[7:4],1,sum1,cout1);
            
            if (coutL==1) begin
                assign sum = {sum1, sumL};
                assign cout = cout1;
            end else begin
                assign sum = {sum0, sumL};
                assign cout = cout0;
            end
            
        end

endmodule
","The following statement makes no sense with semicolon after it:
always @ (*);

I guess the following begin .. end were intended to go with the previous always block. They did not because of the semicolon. In any case, instantiating of modules inside such a block is illegal in verilog, it should be done outside the block and outside of begin/end:
            add4 add_lower(a[3:0],b[3:0],cin,sumL,coutL);
            add4 add4_0(a[7:4],b[7:4],0,sum0,cout0);
            add4 add4_1(a[7:4],b[7:4],1,sum1,cout1);

Both, stand-alone begin/end and if statement represent a generate block in modern verilog. So, the following is  a part of the generate block:
            if (coutL==1) begin
                assign sum = {sum1, sumL};
                assign cout = cout1;
            end else begin
                assign sum = {sum0, sumL};
                assign cout = cout0;
            end

But such blocks only operate with constants. So countL must be a constant, i.e. a parameter. It is a reg, therefore, there is an error.
Again, it seems that you intended this as a part of the always block. assign statements within such a block are a very special verilog constructs and should not be used without a very good understanding of what they do.
My guess is that you intended something like the following:
module selectAdd8(
    input [7:0] a,
    input [7:0] b,
    input cin,
    output reg [7:0] sum,
    output reg cout
    );

    reg coutL, sumL, sum0, sum1, cout0, cout1;
    always @ (*)
        begin           
            if (coutL==1) begin
                sum = {sum1, sumL};
                cout = cout1;
            end else begin
                sum = {sum0, sumL};
                cout = cout0;
            end            
        end            
   
    add4 add_lower(a[3:0],b[3:0],cin,sumL,coutL);
    add4 add4_0(a[7:4],b[7:4],0,sum0,cout0);
    add4 add4_1(a[7:4],b[7:4],1,sum1,cout1);
endmodule
",,,,,
System Verilog: randomization per instance at initial,"I want to simulate a multiple latches with random starting conditions, but I want each instance to have its own initial condition
This is a simplified version of the code. I would like the value to be different in both of the instances, without changing the interface
module random_usage();
  integer addr1;
  real data;
  initial begin
    addr1 = $urandom();
    data  = $urandom();
 
    $display(&quot;addr1=%0d, data=%0d&quot;,addr1,data);
  end
endmodule

module tb();
    integer seed = 1;
    random_usage a();
    random_usage b();
    initial
    begin
        #5;
        seed  = $get_initial_random_seed();
        $display(&quot;seed=%0d&quot;, seed);
    end

endmodule

What I have seen so far:
Instance specific $urandom in system-verilog
solution doesn't work in initial condition, or even when you feed the same clock
https://www.systemverilog.io/randomization
I have modules, so i don't know how to apply the solutions, or even if it will work here
https://www.reddit.com/r/FPGA/comments/jd0dmu/system_verilog_force_randomization_different_per/
seems to be the same question, and there is no straight solution, but the last person gave a VCS flag. I am using VCS, but i have not been able to get the flag to work","The IEEE 1800-2017 SystemVerilog LRM section 18.14.1 Random stability properties says rather naively that each instances gets seeded with the same initialization seed.
Most tools now have a switch changing that behavior by using the hierarchical path name to seed each instance. Some tools have even made that the default. If you want tool independent behavior, you can use this package:
package seed_instance;

int initial_seed = $urandom;

function automatic void srandom(string path);
  static int hash[int];
  int hash_value = initial_seed;
  process p = process::self();
  for(int i=0;i&lt;path.len();i++)
    hash_value+=path[i]*(i*7);
  if (!hash.exists(hash_value))
    hash[hash_value] = hash_value;
  else
    hash[hash_value]+=$urandom; // next seed
  p.srandom(hash[hash_value]);
endfunction

endpackage
  
module random_usage();
  integer addr1;
  real data;
  initial begin
    seed_instance::srandom($sformatf(&quot;%m&quot;));
    addr1 = $urandom();
    data  = $urandom();
 
    $display(&quot;1: addr1=%0d, data=%0d&quot;,addr1,data);
  end
  
   initial begin
    seed_instance::srandom($sformatf(&quot;%m&quot;));
    addr1 = $urandom();
    data  = $urandom();
 
     $display(&quot;2: addr1=%0d, data=%0d&quot;,addr1,data);
  end
endmodule

module tb();
    integer seed = 1;
    random_usage a();
    random_usage b();
endmodule
",,,,,
Verilog module instantiation reg input output,"While implementing Verilog code in behavioral modeling we are using reg as output. But, when I have to use module instantiation and connect it using a wire, it's showing an error while implementation. Is there any other way where I can use module instantiation to connect outputs of different module instances to implement combinational logic as it's illegal to connect the reg output of the previous model to a wire? Note that I have to apply behavioral modeling hence no assignment statements are allowed.  This is an example to connect two half adders to one full adder.
module half_adder(input wire a,b,output reg sum,output reg carry);
always@(a or b)
begin
sum = a^b ;
carry= a &amp; b ;
end 
endmodule

module full_adder(input wire a,b,c,output reg sum,output reg carry);
    wire s1,c1,c2;
    half_adder gate1(a,b,s1,c1);
    half_adder gate2(s1,c,sum,c2);
    always@(a or b or c)
    begin
    carry = c1|c2;
    end
endmodule


Error (10663): Verilog HDL Port Connection error at full_adder.v(14):
output or inout port &quot;sum&quot; must be connected to a structural net
expression
","In standard old verilog a reg cannot be connected to a reg using module connection or a continuous assignment. System verilog allows it. So, one of the solutions could be to switch to system verilog.
As for verilog, in half_adder port sum is declared as a reg. Instance gate2 connects variable of type reg to the port of type reg. This is illegal. This type of an assignment can only happen inside a procedural (i.e. always) block. Instance gate1 bypasses this issue by connecting port to the wire s1.
So, you can follow the similar path. Create another wire s2 as in the following example.
module full_adder(input wire a,b,c,output reg sum,output reg carry);
    wire s1,c1, s2, c2;

    half_adder gate1(a,b,s1,c1);
    half_adder gate2(s1,c,s2,c2); // use s2 here

    always@*
       carry = c1|c2;
    
    always @*
       sum = s2; // now you can s2 assign to the 'sum' port
  
    endmodule

Another way is to declare the 'sum' port as a wire. A register can be connected to a wire, using port connections or continuous assignment.
   module full_adder(input wire a,b,c,
      output sum, // declares it as a wire
       output reg carry);

  ... 
    half_adder gate2(s1,c,sum,c2); // now it works this way.


And btw, do not use @(a,b,c). It is always error prone and is just wrong in your case. It should be @(c1,c2). But it is much better to use @*.",,,,,
SystemVerilog property pass by reference,"Is it possible to pass a signal to a property by reference? For example, I want to create a cover property to capture a register changing, and re-use this property for dozens of different registers. I'd like to do something like this:
property reg_change(int num_cycles, ref bit some_reg);
    @(posedge CLK)
    $changed(some_reg) |-&gt; ##num_cycles $changed(some_reg);
endproperty

Reg1Change10Cycles_cp : cover property (reg_change(10, reg1);
Reg2Change10Cycles_cp : cover property (reg_change(10, reg2);
//...

But I get a compile error for trying to use 'ref' in the property. I don't think I can just use bit some_reg since that would be pass-by-value, and won't ever see some_reg change. Is there anyway I can achieve this behavior without defining the entire property in each cover property?","There is no way and no need to pass formal arguments by reference to properties and sequences. Formal arguments to assertion constructs are replaced inline by the actual arguments. So in a sense they are always by reference. See section 16.8 Declaring sequences in the IEEE 1800-2017 SystemVerilog LRM. The same argument behavior applies to properties.
BTW, you should leave assertion arguments typeless unless you need strong typing rules to keep your assertion expression evaluating correctly.",,,,,
How to use case statement instead of for-loop in verilog,"The following is a seven-person voting program described in verilog, but due to the efficiency of the for loop, I would like to change the for loop into a case statement.
module voter7(pass, vote);

output pass;
input[6:0] vote;
reg[2:0] sum;

integer i;
reg pass;

always @(vote) 
    begin
        sum = 0;
        for(i=0; i&lt;=6; i=i+1)
            if(vote[i]) sum = sum+1;
        if(sum[2]) pass = 1;
        else pass = 0;
    end

endmodule

This is the assignment left by my professor. Exactly, I would like to use case statement to rewrite the code below.
for(i=0; i&lt;=6; i=i+1)
  if(vote[i]) sum = sum+1;
","
Unlike different high-level programming languages like 'C', the Verilog case statement includes implicit break statements.
verilog-case-statement in Verilog Tutorial

In my experience, your professor maybe made a mistake that he think Verilog can sequentially execute multiple case statements but actually it can not do that.
So, you may use a awkward method which is as follow to response your professor.
module voter7(pass, vote);

output pass;
input[6:0] vote;
reg[2:0] sum;

integer i;
reg pass;

always @(vote) 
    begin
        sum = 0;

        casez(vote)
            7'b??????1: sum = sum + 1;
        endcase
        casez(vote)
            7'b?????1?: sum = sum + 1;
        endcase
        casez(vote)
            7'b????1??: sum = sum + 1;
        endcase
        casez(vote)
            7'b???1???: sum = sum + 1;
        endcase
        casez(vote)
            7'b??1????: sum = sum + 1;
        endcase
        casez(vote)
            7'b?1?????: sum = sum + 1;
        endcase
        casez(vote)
            7'b1??????: sum = sum + 1;
        endcase
        
        if(sum[2]) pass = 1;
        else pass = 0;
    end

endmodule
",,,,,
How can you control Kristen FPGA from implementing excess registers?,"I am using Kristen to generate a Verilog FPGA host interface for a neuromorphic processor.  I have implemented the basic host as follows,
&lt;module name= &quot;nmp&quot; duplicate=&quot;1000&quot;&gt;
        &lt;register name=&quot;start0&quot;     type=&quot;rdconst&quot; mask=&quot;0xFFFFFFFF&quot; default=&quot;0x00000000&quot; description=&quot;Lower 64 bit start pointer of persitant NMP storage.&quot;&gt;&lt;/register&gt;
        &lt;register name=&quot;start1&quot;     type=&quot;rdconst&quot; mask=&quot;0xFFFFFFFF&quot; default=&quot;0x00000020&quot; description=&quot;Upper 64 bit start pointer of persitant NMP storage.&quot;&gt;&lt;/register&gt;
        &lt;register name=&quot;size&quot;       type=&quot;rdconst&quot; mask=&quot;0xFFFFFFFF&quot; default=&quot;0x10000000&quot; description=&quot;Size of NMP persitant storage in Mbytes.&quot;&gt;&lt;/register&gt;
        &lt;register name=&quot;c_start0&quot;       type=&quot;rdconst&quot; mask=&quot;0xFFFFFFFF&quot; default=&quot;0x10000000&quot; description=&quot;Lower 64 bit start pointer of cached shared storage.&quot;&gt;&lt;/register&gt;
        &lt;register name=&quot;c_start1&quot;       type=&quot;rdconst&quot; mask=&quot;0xFFFFFFFF&quot; default=&quot;0x00000020&quot; description=&quot;Upper 64 bit start pointer of cached shared storage.&quot;&gt;&lt;/register&gt;
        &lt;register name=&quot;c_size&quot;         type=&quot;rdconst&quot; mask=&quot;0xFFFFFFFF&quot; default=&quot;0x10000000&quot; description=&quot;Size of cached shared storage in Mbytes.&quot;&gt;&lt;/register&gt;
        &lt;register name=&quot;row&quot;        type=&quot;rdwr&quot; mask=&quot;0xFFFFFFFF&quot; default=&quot;0x00000000&quot; description=&quot;Configurable row location for this NMP.&quot;&gt;&lt;/register&gt;
        &lt;register name=&quot;col&quot;        type=&quot;rdwr&quot; mask=&quot;0xFFFFFFFF&quot; default=&quot;0x00000000&quot; description=&quot;Configurable col location for this NMP.&quot;&gt;&lt;/register&gt;
        &lt;register name=&quot;threshold&quot;  type=&quot;rdwr&quot; mask=&quot;0xFFFFFFFF&quot; default=&quot;0x00000000&quot; description=&quot;Configurable synaptic sum threshold for this instance.&quot;&gt;&lt;/register&gt;
         &lt;memory name=&quot;learn&quot;  memsize=&quot;0x00004000&quot; type=&quot;mem_ack&quot; description=&quot;Learning interface - Map input synapsys to node intensity&quot;&gt;
            &lt;field name=&quot;input_id&quot;         size=&quot;22b&quot; description=&quot;Input ID this map data is intended for.&quot;&gt;&lt;/field&gt;
            &lt;field name=&quot;scale&quot;            size=&quot;16b&quot; description=&quot;The intensity scale for this input ID.&quot;&gt;&lt;/field&gt;
         &lt;/memory&gt;
    &lt;/module&gt;

The end result is that I am seeing a ton of registers being generated and I have to scale my NMP size down to fit within the constraints of my FPGA.  Is there a way to control the number of registers being generated here?  Obviously I need to store settings for these different fields.  Am I missing something here?
I should add that I am trying to get to a 2048 scale on my NMP but the best I can do is just over a 1000, and not quite 1024.  If I implement without PCIe or host control, I can get to 2048 without issue.","If I understand correctly, each NMP instance has a been coded with a internal register to store data and the configuration you have shown will result in kristen creating Verilog with registers as well.  Effectivley there is a double buffered storage occuring.

Because of this, the number of registers are effectively doubled beyond what they need to be.  One way of dealing with this situation described is to use another RAM interface of 32 bits wide.  I do note that your config calls for 9 x 32 bits words which is a odd size for memory.  There will be some wasted adddress space.  Kristen will create a RAM's on binary boundaries so, you can get a 16x32bit memory region that you can overlay on that interface.  And then a second RAM just like you have already for the learn memory.
&lt;module&gt;
    &lt;memory name=&quot;regs&quot; memsize=&quot;0x10&quot; type=&quot;mem_ack&quot; description=&quot;Register mapping per NMP instance&quot;&gt;
        &lt;field name &quot;start0&quot; size=&quot;32b&quot; description=&quot;Start0&quot;&gt;&lt;/field&gt;
        &lt;field name &quot;start1&quot; size=&quot;32b&quot; description=&quot;Start1&quot;&gt;&lt;/field&gt;
        ....
        &lt;field name &quot;threshold&quot; size=&quot;32b&quot; description=&quot;Threshold&quot;&gt;&lt;/field&gt;
    &lt;/memory&gt;
    &lt;memory name=&quot;learn&quot;  memsize=&quot;0x00004000&quot; type=&quot;mem_ack&quot; description=&quot;Learning interface - Map input synapsys to node intensity&quot;&gt;
        &lt;field name=&quot;input_id&quot;         size=&quot;22b&quot; description=&quot;Input ID this map data is intended for.&quot;&gt;&lt;/field&gt;
        &lt;field name=&quot;scale&quot;            size=&quot;16b&quot; description=&quot;The intensity scale for this input ID.&quot;&gt;&lt;/field&gt;
     &lt;/memory&gt;
&lt;/module&gt;

Generate this and take a look at the new interface.  That should reduce the number of registers generated in your Verilog code and subsequent synthesis.",,,,,
VHDL function that alters record fields disrupts untouched fields in Vivado Simulation,"I've spent too much time on this and am completely confused. I have a record type:
--t_dp_sosi record
TYPE t_fft_sosi_out IS RECORD  -- Source Out or Sink In
sync     : STD_LOGIC;   
bsn      : STD_LOGIC_VECTOR(c_dp_stream_bsn_w-1 DOWNTO 0);      -- ctrl
re       : STD_LOGIC_VECTOR(c_fft_out_dat_w-1 DOWNTO 0);            -- data
im       : STD_LOGIC_VECTOR(c_fft_out_dat_w-1 DOWNTO 0);            -- data
valid    : STD_LOGIC;                                           -- ctrl
sop      : STD_LOGIC;                                           -- ctrl
eop      : STD_LOGIC;                                           -- ctrl
empty    : STD_LOGIC_VECTOR(c_dp_stream_empty_w-1 DOWNTO 0);    -- info at eop
channel  : STD_LOGIC_VECTOR(c_dp_stream_channel_w-1 DOWNTO 0);  -- info at sop
err      : STD_LOGIC_VECTOR(c_dp_stream_error_w-1 DOWNTO 0);    -- info at eop (name field 'err' to avoid the 'error' keyword)
END RECORD;

and make an array type of it as such:
TYPE t_fft_sosi_arr_out IS ARRAY (INTEGER RANGE &lt;&gt;) OF t_fft_sosi_out;
All constants used to define the ranges of the field in the types are defined prior and in the same file. This type is used everywhere in my code as an interface and works well.
Now I have this function:
FUNCTION func_dp_stream_arr_combine_data_info_ctrl(dp : t_fft_sosi_arr_out; info, ctrl : t_fft_sosi_out) RETURN t_fft_sosi_arr_out IS
VARIABLE v_dp : t_fft_sosi_arr_out(dp'RANGE) := dp;       -- hold sosi data
BEGIN
FOR I IN dp'RANGE LOOP                          -- set sosi info
  v_dp(I).bsn     := info.bsn;      
  v_dp(I).channel := info.channel;  
  v_dp(I).empty   := info.empty;    
  v_dp(I).err     := info.err;      
  -- set sosi ctrl
  v_dp(I).valid := ctrl.valid;
  v_dp(I).sop   := ctrl.sop;
  v_dp(I).eop   := ctrl.eop;
  v_dp(I).sync  := ctrl.sync;
END LOOP;
RETURN v_dp;
END func_dp_stream_arr_combine_data_info_ctrl;

that is meant to take an array of records and alter some of each records' fields (minus the re and im field) to be like that of the ctrl or info records provided.
At some point in my code I use the function as such:
nxt_src_out_arr &lt;= func_dp_stream_arr_combine_data_info_ctrl(snk_in_arr, out_sosi, out_sosi);
and it completely messes up my re and im fields see here (sorry it is a little blurry):

snk_in_arr and nxt_src_out_arr are both ```t_fft_sosi_arr_out(g_nof_streams-1 DOWNTO 0);`` arrays where g_nof_streams is a defined generic. If I do not go via the function as such:
nxt_src_out_arr &lt;= snk_in_arr;
Then the re and im fields match and all is well:

I'm running this on Vivado 2020.2 on Windows 10.
I've found that this issue does not occur with Vivado 2020.1 (on Mint or Windows 10).
Thanks in advance.","I've found that this appears to be a version issue for both this problem and the one mentioned here.
As you can see, in Vivado 2020.1 (below) nxt_src_out_arr and snk_in_arr now match after running it through the function in question:

Thanks all, I'd log this issue with Vivado but I am struggling to do so. I've also logged in several times and filled in a survey in an attempt to reach the community forum. When I finally got there,
I get errors when selecting 'Vivado' as my topic for my question. Hopefully they find this issue here.",,,,,
verilog representing binary value problem in verilog,"My task is to create a text file and put my first name as binary data in the text file, and then to read this file and convert this binary to characters and put it in another file as characters.
So my question is how do I represent my name in binary.
I tried:
reg [255:0] myname = 01001110011010010110101101101111011011000110111101111010;

But it did not work. The error says the number is too big.
Then I tried:
reg [1:0] myname1 = 2'b0100_1110_0110_1001_0110_1011_0110_1111_0110_1100_0110_1111_0111_1010;

This also did not work. It always gave &quot;_&quot; as an output.","reg [255:0] myname = 01001110011010010110101101101111011011000110111101111010;

In this case you have a huge decimal number 1,001,110,011,010,010,110,101,101,101,111,011,011,000,110,111,101,111,010 which you try to assign to a relatively small reg (256 bit wide).  It does fit in 256 bits but you will have big problems decoding it.
reg [1:0] myname1 = 2'b0100_1110_0110_1001_0110_1011_0110_1111_0110_1100_0110_1111_0111_1010;

Here you are trying to squeeze a 56 bit binary number into a 2 bit variable. This is physically impossible and the number gets truncated to 2 bits. Underscores are only used for readabilityt purposes and do not have any other effect.
I guess, you need something like the following:
reg [255:0] myname = 256'b01001110011010010110101101101111011011000110111101111010;

You can add underscores for readability if you wish.",,,,,
How to make a simualtion in verilog have different results everytime if it has random values?,"I want to generate a different output of the same code every time I run it as it has random values assigned to some variables.  Is there a way to do that, for example seeding using time as in C?
Sample code that has the randomization in it:
class ABC;

    rand bit [4 : 0] arr []; // dynamic array
    constraint arr_size{

        arr.size() &gt;= 2;
        arr.size() &lt;= 6;

    }


endclass 



module constraint_array_randomization();

ABC test_class;

initial begin 


    test_class = new();
    test_class.randomize();
    $display(&quot;The array has the value = %p &quot;, test_class.arr);



end



endmodule








","I this is probably dependent on the tool that is being used. For example xcelium from cadence supports xrun -seed some_seed(Questa has -sv_seed some_seed I think). I am certain all tools support something similar. Look for simulation tool reference/manual/guide/help it may support random seed for every simulation run.
Not sure if this is possible from inside of simulation.

As mentioned in the comments for Questa, -sv_seed random should do the trick.",,,,,
How do you select specific bits from a Verilog define macro?,"I originally had a 'params_list.v' file where multiple global constraints were listed
// params_list.v file

localparam
 parameter1   = 18'h00AB,
 parameter2   = 18'h00CD;

The parameters were used in a specific module as shown below
// design_main_ORIGINAL.v file

module my_module

`include &quot;params_list.v&quot;

assign reg1 = parameter1[4:0];
assign reg2 = parameter2[4:0];

endmodule

The original 'params_list.v' file got divided into multiple header files 'header1.vh', 'header2.vh',
The definition for one of the files is shown below
// header1.vh

`ifndef _header1_vh_
`define _header1_vh_

`define param1 18'h00AB
`define param2 18'h00CD

`endif   

The header files are then included in the main design file (*.v) using the following lines
// design_main_NEW.v file

`include â€œheader1.vhâ€?`include â€œheader2.vhâ€?
module module_xyz(

 assign reg1 = param1[4:0];
 assign reg2 = param2[4:0];

);
endmodule

When compile, the following error keeps showing up
** Error: (vlog-13069) C:/my_path/main_module.v(440): near &quot;[&quot;: syntax error, unexpected '['.
Would appreciate it if you could please shed some light on what I might be missing.","If you want to select a part of a literal, you need to enclose it in a concatenation
assign reg1 = {`param1}[4:0];
assign reg2 = {`param2}[4:0];

This only works in SystemVerilog. But if reg1 and reg2 are already 5-bit variables, there's no need to do any of this. It will automatically be truncated.",,,,,
SystemVerilog: Collapsing and & on an array of interface ... Collapsing or | on an array of interface,"I am trying to change some of my code pretty drastically. Everywhere where I am using a widely used struct in a module port signature, I would like to replace with a interface (if appropriate).
One logical operation that I have not figured out is a collapsing &amp; or and collapsing or.
This is very easy to do with a regular vector of bits:
Somewhere in a module I can very easily perform collapsing &amp; and |
logic [31:0] vect ;
logic my_sig_and ;
logic my_sig_or ;

always_comb begin
  my_sig_and = &amp;vect ;
  my_sig_or = |vect ;
end

But, my question is, how to perform this on a single bit field across an array of interface
My attempts are below (even the silly ones):
interface myInterface () () ;
    logic valid
    logic[31:0] data
endinterface

Attempt #1:
My attempt somewhere in a module:
myInterface () my_intfs [PORTS-1:0] () ; // assume this is assigned to
logic temp_signal ;
logic my_sig_and ;

always_comb begin
    temp_signal = my_intfs[0].ready ;
    for( genvar ii = 1; ii &lt; PORTS; ii++ ) begin
        temp_signal = temp_signal &amp;&amp; my_intfs[ii].ready ; // error line
    end
end

always_comb begin
    my_sig_and = temp_signal;
end

Error: near &quot;genvar&quot;: syntax error, unexpected genvar, expecting ';'.
Attempt #2:
My attempt somewhere in a module:
myInterface () my_intfs [PORTS-1:0] () ; // assume this is assigned to
logic temp_signal ;
logic my_sig_and ;

always_comb begin
    temp_signal = my_intfs[0].ready ;
    for( int ii = 1; ii &lt; PORTS; ii++ ) begin
        temp_signal = temp_signal &amp;&amp; my_intfs[ii].ready ; // error line
    end
end

always_comb begin
    my_sig_and = temp_signal;
end

Error: Nonconstant index into instance array 'my_intfs'
Attempt #3:
My attempt somewhere in a module:
myInterface () my_intfs [PORTS-1:0] () ; // assume this is assigned to
logic temp_signal ;
logic my_sig_and ;

always_comb begin
    temp_signal = my_intfs[0].ready ;
    for( int ii = 1; ii &lt; PORTS; ii++ ) begin
        temp_signal = temp_signal &amp;&amp; my_intfs[ii+:0].ready ; // error line
    end
end

always_comb begin
    my_sig_and = temp_signal;
end

(vlog-13172) Selected name after a part-select may only be a modport on an interface port.
Attempt #4:
My attempt somewhere in a module:
myInterface () my_intfs [PORTS-1:0] () ; // assume this is assigned to
logic temp_signal ;
logic my_sig_and ;

always_comb begin
    temp_signal = my_intfs[0].ready ;
end

for( genvar ii = 1; ii &lt; PORTS; ii++ ) begin
    always_comb begin
        temp_signal = temp_signal &amp;&amp; my_intfs[ii].ready ; // error line
    end
end

always_comb begin
    my_sig_and = temp_signal;
end

(vopt-7033) Variable 'temp_signal' driven in a combinational block, may not be driven by any other process
Attempt #5:
My attempt somewhere in a module:
myInterface () my_intfs [PORTS-1:0] () ; // assume this is assigned to
logic temp_signal ;
logic my_sig_and ;

for( genvar ii = 0; ii &lt; PORTS; ii++ ) begin
    always_comb begin
        temp_signal = temp_signal &amp;&amp; my_intfs[ii].ready ; // error line
    end
end

always_comb begin
    my_sig_and = temp_signal;
end

(vopt-7033) Variable 'temp_signal' driven in a combinational block, may not be driven by any other process.
Attempt #6:
My attempt somewhere in a module:
myInterface () my_intfs [PORTS-1:0] () ; // assume this is assigned to
logic temp_signal ;
logic my_sig_and ;

always_comb begin
    temp_signal = &amp;my_intfs.ready ; // error line
end

always_comb begin
    my_sig_and = temp_signal;
end

(vopt-2990) Illegal operation on unpacked type.
Attempt #7 (silly but desired haha):
My attempt somewhere in a module:
myInterface () my_intfs [PORTS-1:0] () ; // assume this is assigned to
logic temp_signal ;
logic my_sig_and ;

always_comb begin
    temp_signal = my_intfs.&amp;ready ; // error line
end

always_comb begin
    my_sig_and = temp_signal;
end

near &quot;&amp;&quot;: syntax error, unexpected '&amp;'
Attempt #8 some syntax from bash/sh with @ to ref whole array (silly but desired haha):
My attempt somewhere in a module:
myInterface () my_intfs [PORTS-1:0] () ; // assume this is assigned to
logic temp_signal ;
logic my_sig_and ;

always_comb begin
    temp_signal = &amp;my_intfs[@].ready ; // error line
end

always_comb begin
    my_sig_and = temp_signal;
end

near &quot;@&quot;: syntax error, unexpected '@'.","Using a macro that assigns all interface array elements to a placeholder logic vector worked. Simply collapse the logic vector after all of the assignments are complete.:
somewhere in a module:
myInterface () my_intfs [PORTS-1:0] () ; // assume this is assigned to
logic temp_signal ;
logic my_sig_and ;

`INTF_FIELD_COLLAPSE_AND( blah, my_intfs, valid, PORTS, 1, my_sig_and )



`ifndef INTF_FIELD_COLLAPSE_AND
    `define INTF_FIELD_COLLAPSE_AND( unique, intf, field, size, field_size, output_sig ) \
        logic [size-1:0] [field_size-1:0] my_sig_unique ; \
        for( genvar ii_unique = 0; ii_unique &lt; PORTS; ii_unique++ ) begin \
            always_comb begin \
                my_sig_unique[ii_unique] = intf[ii_unique].field ; \
            end \
        end \
        output_sig = &amp;my_sig_unique ;
`endif
",,,,,
Simple code yielding error even though syntax seems correct (ISE VERILOG),"I am relatively very new(just a few hours old) in Xilinx ISE verilog coding. This is my code from my uni project. And it shows syntax error on the count = 0 line. I dont see anything wrong here upon running check syntax. How do i fix this?
 module syncdown(clk,rst,count);
input clk,rst;
output reg [3:0] count = 1;
always @(posedge clk);
begin
if(rst)
count = 0; // wrong here 
else
count = count-1;
end
endmodule

The error
ERROR:HDLCompiler:806 - &quot;/home/bossman/mux/syncdown.v&quot; Line 8: Syntax error near &quot;=&quot;.
","Remove the semicolon at the end of the always line:
module syncdown(clk,rst,count);
input clk,rst;
output reg [3:0] count = 1;
always @(posedge clk)
begin
if(rst)
count = 0; // wrong here 
else
count = count-1;
end
endmodule
",,,,,
Verilog if statement inconsistency,"I'm trying to write a simple 4-bit stack of depth 8 with push/pop signals but it's behaving in a very odd manner. One of my if statements works fine and the other one does not run at all. Here's my code:
module Stack_8x4(
    input wire clk,
    input wire reset,
    input wire push,
    input wire pop,
    input wire [3:0] data_in,
    output reg [3:0] data_out,
    output reg empty,
    output reg full
    );
    
    reg [3:0] index;
    reg [3:0] stack [7:0];
    
    always @(posedge reset) begin
        index &lt;= -1;
        data_out = 4'd0;
        empty = 1;
        full = 0;
    end
    always @(posedge clk) begin
        if (push &amp; !pop) begin
            empty = 0;
            if(!full) begin
                index = index + 1;
                stack[index] = data_in;
                if(index &gt; 6) full = 1;
            end
        end
        if (pop &amp; !push) begin
            full = 0;
            if(!empty) begin
                data_out = stack[index];
                index = index - 1;
                if(index &lt; 0) empty= 1;
            end else data_out = 0;
        end
    end
endmodule

As you can see, the logic for push and pop is almost the same. My question is why does the line if(index &lt; 0) empty= 1; does not work while if(index &gt; 6) full = 1; works just fine?
Here's a test bench and simulation for more details:
module sim();

reg clk;
reg reset;
reg push;
reg pop;
reg [3:0] data_in;
wire [3:0] data_out;
wire full;
wire empty;
//wire [3:0]i;

always begin
clk = 0;
#5
clk = 1;
#5
clk = 0;
end

initial begin
// setup
reset = 1;
push = 0;
pop = 0;
data_in = 0;
#10
reset = 0;

// idle
#20

// push 1, 2, 3, 4, 5, 6, 7, 8, 9 to fill the module and test for idling at full
push = 1;
data_in = 1;
#10
data_in = 2;
#10
data_in = 3;
#10
data_in = 4;
#10
data_in = 5;
#10
data_in = 6;
#10
data_in = 7;
#10
data_in = 8;
#10
data_in = 9;
#10
data_in = 10;
#10
data_in = 11;
#10
pop = 1;
#10
push = 0;
#30
pop = 0;
push = 1;
#30
push = 0;
#20
pop = 1;
// pop
//pop = 1;

end

Stack_8x4 S (
    .clk(clk),
    .push(push),
    .pop(pop),
    .reset(reset),
    .data_in(data_in),
    .data_out(data_out),
    .full(full),
    .empty(empty)
);

endmodule

","Your main issue is in the attempt to use signed data with unsigned variables. So,         index &lt;= -1;, index &lt; 0 just do not work as you expect.  My suggestion is to forget about signed arithmetic and do unsigned only.
Other issues:

you should use only a single always block to do reset and non-reset work.
you should use non-blocking assignments everywhere in your always @posedge blocks
for some reason you do not use 2 elements in your stack (6, 7) due to 'index &lt; 6'.

So, here is my re-write of your code:
   always @(posedge clk) begin
      if (reset) begin
         index &lt;= 0;
         data_out &lt;= 4'd0;
         empty &lt;= 1;
         full &lt;= 0;
      end      
      else if (push &amp; !pop) begin
          if(index &lt; 8) begin
            full&lt;= 0;
            stack[index] &lt;= data_in;
            index &lt;= index + 1;
         end
         else 
           full &lt;= 1;
      end
      else if (pop &amp; !push) begin
         if(index == 0) begin
            empty &lt;= 1;
            data_out &lt;= 0;
         end
         else begin
            empty &lt;= 0;
            index &lt;= index - 1;
            data_out &lt;= stack[index];
         end
      end // if (pop &amp; !push)
   end // always @ (posedge clk)
",,,,,
if-else latch SystemVerilog,"i was trying to make a floating point adder in SystemVerilog. When i saw the schematic generated i noticed the presence of a latch. The code is:
module ADDER (
    input   ieee_effloat  In1_ADD, In2_ADD,
    input   ieee_float    A_ADD,

    output  ieee_float    Out_ADD
    );

    logic [24:0] MantissaSum;                               //Can generate an overflow, expand at 25 bit

    always_comb
        begin
            MantissaSum = In1_ADD.Eff_Mantissa + In2_ADD.Eff_Mantissa;  //Sum the mantissas
            
            if(MantissaSum[24] == 1'b1)                        //If overflow
                begin
                    MantissaSum &gt;&gt;= 1;                      //Shift the mantissa of 1
                    Out_ADD.Exponent = A_ADD.Exponent + 1;  //&lt;== Here is the latch (?)
                    Out_ADD.Mantissa = MantissaSum [22:0];  //Select the first 23 bit 
                end
            else
                begin
                    Out_ADD.Mantissa = MantissaSum [22:0];   //Select the first 23 bit
                end
        end

    assign Out_ADD = '{1'b0, Out_ADD.Exponent, Out_ADD.Mantissa};
    
endmodule

The types are defined:
`ifndef FPU_MACROFLAG
    `define FPU_MACROFLAG

    package FPU_DEFINITION;

        typedef struct packed {
            logic               Sign;
            logic        [7:0]  Exponent;
            logic        [22:0] Mantissa;
        } ieee_float;               //IEEE-753 floating point number rapresentation

        typedef struct packed {
            logic               Eff_Sign;
            logic        [7:0]  Eff_Exponent;
            logic        [23:0] Eff_Mantissa;
        } ieee_effloat;             //IEEE-753 floating point number rapresentation effective mantissa

    endpackage
    
    import FPU_DEFINITION::*;

`endif

I don't know why this happen, I even closed the if with the else...","The way the latch is created in verilog is when you do not assign all outputs in all branches of an always block. In your situation:
    always_comb
        begin

you create a default value for MantissaSum. This way it is always assigned.
            MantissaSum = In1_ADD.Eff_Mantissa + In2_ADD.Eff_Mantissa;  

now, when you shift it in one of the branches and do not do anything in the other one the previous statement will take care of it.
            if(MantissaSum[24] == 1'b1)                        //If overflow
                begin
                    MantissaSum &gt;&gt;= 1;                      //Shift the mantissa of 1

However, here is you problem. your Out_ADD.Exponent is only assigned in the true branch of the if statement. If ManticcaSum[24] is not 1, then its value is supposed to be the same as before. This is a latch behavior.
                    Out_ADD.Exponent = A_ADD.Exponent + 1;  //&lt;== Here is the latch (?)

The rest is ok. Out_ADD.Mantissa is assigned in all branches.
                    Out_ADD.Mantissa = MantissaSum [22:0];  //Select the first 23 bit 
                end
            else
                begin
                    Out_ADD.Mantissa = MantissaSum [22:0];   //Select the first 23 bit
                end
        end

If this is what you want, you shold split this always block in two: one with always_comb, the second as always_latch, which takes care of the exponent. Or you should review your algorithm.",,,,,
Shift Register in verilog,"I have designed a serial in parallel out shift register as input register for an encoder
module ShiftRegister_SIPO(clk, in, out);
input clk,in;
output [3:0] out;
reg [3:0] tmp;

always @(posedge clk)
begin
tmp = {tmp[2:0], in};
end
assign PO = tmp;
endmodule

how do I retain the value once the desired parallel out data is got , even with clk=1? Because even after the output data is got the value keeps shifting. For example ,if i give
Part  of testbench
in=1;
#10
in=0;
#10
in=1;
#10
in=1;

#5 clk=~clk;

I get 1011 at the 4th clock cycle , but the value then keeps shifting. Can i retain it as 1011 for the remaining period also, still keeping the clk=1.
Thanks in advance","In you example the value will be shifting every positive edge of the clock. In order to prevent it from shifting under some circumstances you need a way to enable or disable shifting. For example:
always @(posedge clk)
begin
   if (enable)
      tmp &lt;= {tmp[2:0], in};
end

So, controlling the enable signal you can control shifting. If its value is low, then no shifting will happen and the value of 'tmp' will remain unchanged till you enable it again.",,,,,
verilog alu design why all my output result is always 00000000,"Here is my code, the professor say module format cannot be changed. And the homework also require only the input can be load when rst_n=1, and the output should be 0 when rst_n = 0. But in test bench all my result always is 00000000, zero is 1, cout is 0, overflow is 1, what's the problem with my code?
I thought the problem maybe are here, but I have no idea how to edit it.
(I use //problem to mark to line in code below)
cout = out; //problem       
result = results; //problem       
result &lt;= 32'b0; //problem



`timescale 1ns/1ps
module ALU_1bit(
    input               src1,       //1 bit source 1  (input)
    input               src2,       //1 bit source 2  (input)
    input               Ainvert,    //1 bit A_invert  (input)
    input               Binvert,    //1 bit B_invert  (input)
    input               Cin,        //1 bit carry in  (input)
    input       [2-1:0] operation,  //2 bit operation (input)
    output reg          result,     //1 bit result    (output)
    output reg          cout        //1 bit carry out (output)
    );

/* Write your code HERE */

reg temp1;
reg temp2;
reg temp3;
reg temp4;
reg temp5;

always@(src1 or src2 or Ainvert or Binvert or Cin or operation)
  begin
  case (Ainvert)
    1'b0:  temp1 = src1;   // 0
    1'b1:  temp1 = ~src1;   // 1
  endcase
  //$display(&quot;temp1 %d&quot;, temp1);
  case (Binvert)
    1'b0:  temp2 = src2;   // 0
    1'b1:  temp2 = ~src2;   // 1
  endcase
  //$display(&quot;temp2 %d&quot;, temp2);
  temp3 = temp1 &amp; temp2;
  temp4 = temp1 | temp2;
  {cout, temp5} = temp1 + temp2 + Cin;
  //$display(&quot;temp3 %d&quot;, temp3);
  //$display(&quot;temp4 %d&quot;, temp4);
  //$display(&quot;temp5 %d&quot;, temp5);
  case (operation)
    2'b00:  result = temp3;   // AND
    2'b01:  result = temp4;   // OR
    2'b10:  result = temp5;    // addition
    2'b11:  result = temp5;    // addition
  endcase
end

endmodule


module alu(
    input                   rst_n,         // negative reset            (input)
    input        [32-1:0]   src1,          // 32 bits source 1          (input)
    input        [32-1:0]   src2,          // 32 bits source 2          (input)
    input        [ 4-1:0]   ALU_control,   // 4 bits ALU control input  (input)
    output reg  [32-1:0]    result,        // 32 bits result            (output)
    output reg              zero,          // 1 bit when the output is 0, zero must be set (output)
    output reg              cout,          // 1 bit carry out           (output)
    output reg              overflow       // 1 bit overflow            (output)
    );

/* only below can be edit */
wire [32-1:0]results;
wire out;
wire carryout0,  carryout1, carryout2, carryout3, carryout4, carryout5, carryout6, carryout7, carryout8, carryout9, carryout10, carryout11, carryout12, carryout13, carryout14, carryout15, carryout16, carryout17, carryout18, carryout19, carryout20, carryout21, carryout22, carryout23, carryout24, carryout25, carryout26, carryout27, carryout28, carryout29, carryout30;
ALU_1bit UUT0(src1[0], src2[0], ALU_control[3], ALU_control[2], ALU_control[2], ALU_control[1:0], results[0], carry0);
ALU_1bit UUT1(src1[1], src2[1], ALU_control[3], ALU_control[2], carry0, ALU_control[1:0], results[1], carry1);
ALU_1bit UUT2(src1[2], src2[2], ALU_control[3], ALU_control[2], carry1, ALU_control[1:0], results[2], carry2);
ALU_1bit UUT3(src1[3], src2[3], ALU_control[3], ALU_control[2], carry2, ALU_control[1:0], results[3], carry3);
ALU_1bit UUT4(src1[4], src2[4], ALU_control[3], ALU_control[2], carry3, ALU_control[1:0], results[4], carry4);
ALU_1bit UUT5(src1[5], src2[5], ALU_control[3], ALU_control[2], carry4, ALU_control[1:0], results[5], carry5);
ALU_1bit UUT6(src1[6], src2[6], ALU_control[3], ALU_control[2], carry5, ALU_control[1:0], results[6], carry6);
ALU_1bit UUT7(src1[7], src2[7], ALU_control[3], ALU_control[2], carry6, ALU_control[1:0], results[7], carry7);
ALU_1bit UUT8(src1[8], src2[8], ALU_control[3], ALU_control[2], carry7, ALU_control[1:0], results[8], carry8);
ALU_1bit UUT9(src1[9], src2[9], ALU_control[3], ALU_control[2], carry8, ALU_control[1:0], results[9], carry9);
ALU_1bit UUT10(src1[10], src2[10], ALU_control[3], ALU_control[2], carry9, ALU_control[1:0], results[10], carry10);
ALU_1bit UUT11(src1[11], src2[11], ALU_control[3], ALU_control[2], carry10, ALU_control[1:0], results[11], carry11);
ALU_1bit UUT12(src1[12], src2[12], ALU_control[3], ALU_control[2], carry11, ALU_control[1:0], results[12], carry12);
ALU_1bit UUT13(src1[13], src2[13], ALU_control[3], ALU_control[2], carry12, ALU_control[1:0], results[13], carry13);
ALU_1bit UUT14(src1[14], src2[14], ALU_control[3], ALU_control[2], carry13, ALU_control[1:0], results[14], carry14);
ALU_1bit UUT15(src1[15], src2[15], ALU_control[3], ALU_control[2], carry14, ALU_control[1:0], results[15], carry15);
ALU_1bit UUT16(src1[16], src2[16], ALU_control[3], ALU_control[2], carry15, ALU_control[1:0], results[16], carry16);
ALU_1bit UUT17(src1[17], src2[17], ALU_control[3], ALU_control[2], carry16, ALU_control[1:0], results[17], carry17);
ALU_1bit UUT18(src1[18], src2[18], ALU_control[3], ALU_control[2], carry17, ALU_control[1:0], results[18], carry18);
ALU_1bit UUT19(src1[19], src2[19], ALU_control[3], ALU_control[2], carry18, ALU_control[1:0], results[19], carry19);
ALU_1bit UUT20(src1[20], src2[20], ALU_control[3], ALU_control[2], carry19, ALU_control[1:0], results[20], carry20);
ALU_1bit UUT21(src1[21], src2[21], ALU_control[3], ALU_control[2], carry20, ALU_control[1:0], results[21], carry21);
ALU_1bit UUT22(src1[22], src2[22], ALU_control[3], ALU_control[2], carry21, ALU_control[1:0], results[22], carry22);
ALU_1bit UUT23(src1[23], src2[23], ALU_control[3], ALU_control[2], carry22, ALU_control[1:0], results[23], carry23);
ALU_1bit UUT24(src1[24], src2[24], ALU_control[3], ALU_control[2], carry23, ALU_control[1:0], results[24], carry24);
ALU_1bit UUT25(src1[25], src2[25], ALU_control[3], ALU_control[2], carry24, ALU_control[1:0], results[25], carry25);
ALU_1bit UUT26(src1[26], src2[26], ALU_control[3], ALU_control[2], carry25, ALU_control[1:0], results[26], carry26);
ALU_1bit UUT27(src1[27], src2[27], ALU_control[3], ALU_control[2], carry26, ALU_control[1:0], results[27], carry27);
ALU_1bit UUT28(src1[28], src2[28], ALU_control[3], ALU_control[2], carry27, ALU_control[1:0], results[28], carry28);
ALU_1bit UUT29(src1[29], src2[29], ALU_control[3], ALU_control[2], carry28, ALU_control[1:0], results[29], carry29);
ALU_1bit UUT30(src1[30], src2[30], ALU_control[3], ALU_control[2], carry29, ALU_control[1:0], results[30], carry30);
ALU_1bit UUT31(src1[31], src2[31], ALU_control[3], ALU_control[2], carry30, ALU_control[1:0], results[31], out);

always@(posedge rst_n) begin
  cout = out; //problem
  result = results; //problem
  zero = ~(|result);
  overflow = result[31] ^ cout;
end

always@(negedge rst_n) begin
  result &lt;= 32'b0; //problem
  zero = 0;
  overflow = 0;
end

endmodule


testbench
`timescale 1ns/1ps

module testbench;

parameter PATTERN_NUMBER = 6'd30;

reg          clk;
reg          rst_n;
reg [32-1:0] src1_in;
reg [32-1:0] src2_in;
reg  [4-1:0] operation_in;

reg  [8-1:0] mem_src1   [0:(PATTERN_NUMBER*4-1)];
reg  [8-1:0] mem_src2   [0:(PATTERN_NUMBER*4-1)];
reg  [8-1:0] mem_opcode [0:(PATTERN_NUMBER-1)];
reg  [8-1:0] mem_result [0:(PATTERN_NUMBER*4-1)];
reg  [8-1:0] mem_zcv    [0:(PATTERN_NUMBER-1)];

reg  [6-1:0] pattern_count;
reg          start_check;
reg  [6-1:0] error_count;
reg  [6-1:0] correct_count;
reg  [6-1:0] error_count_tmp;

wire [32-1:0] result_out;
wire          zero_out;
wire          cout_out;
wire          overflow_out;

wire  [3-1:0] zcv_out;
wire [32-1:0] result_correct;
wire  [3-1:0] zcv_correct;
wire  [4-1:0] opcode_tmp;

    assign zcv_out = {zero_out, cout_out, overflow_out};
    assign opcode_tmp = mem_opcode[pattern_count];
    assign result_correct = {mem_result[4*(pattern_count-1) + 5'd3],
                            mem_result[4*(pattern_count-1) + 5'd2],
                            mem_result[4*(pattern_count-1) + 5'd1],
                            mem_result[4*(pattern_count-1) + 5'd0]};
    assign zcv_correct = mem_zcv[pattern_count-1];

initial begin
    clk   = 1'b0;
    rst_n = 1'b0;
    src1_in = 32'd0;
    src2_in = 32'd0;
    operation_in = 4'h0;
    start_check = 1'd0;
    error_count = 6'd0;
    correct_count = 6'd0;
    error_count_tmp = 6'd0;
    pattern_count = 6'd0;

    $readmemh(&quot;src1.txt&quot;, mem_src1);
    $readmemh(&quot;src2.txt&quot;, mem_src2);
    $readmemh(&quot;op.txt&quot;, mem_opcode);
    $readmemh(&quot;result.txt&quot;, mem_result);
    $readmemh(&quot;zcv.txt&quot;, mem_zcv);

    #100 rst_n = 1'b1;
    start_check = 1'd1;

    //$dumpfile(&quot;alu.vcd&quot;);
    //$dumpvars(0,testbench);
end

always #5 clk = ~clk;

alu alu(
    .rst_n(rst_n),
    .src1(src1_in),
    .src2(src2_in),
    .ALU_control(operation_in),
    .result(result_out),
    .zero(zero_out),
    .cout(cout_out),
    .overflow(overflow_out)
);


always@(posedge clk) begin
    if(pattern_count == (PATTERN_NUMBER+1)) begin
        if(error_count == 6'd0) begin
            $display(&quot;*      Congratulation! All data are correct!      *&quot;);
            $display(&quot;***************************************************&quot;);
            $display(&quot;Correct Count: %2d&quot;, correct_count );
        end
        else begin
        end
        $finish;
    end
    else if(rst_n) begin
        src1_in         &lt;= {mem_src1[4*pattern_count + 6'd3],
                            mem_src1[4*pattern_count + 6'd2],
                            mem_src1[4*pattern_count + 6'd1],
                            mem_src1[4*pattern_count + 6'd0]};
        src2_in         &lt;= {mem_src2[4*pattern_count + 6'd3],
                            mem_src2[4*pattern_count + 6'd2],
                            mem_src2[4*pattern_count + 6'd1],
                            mem_src2[4*pattern_count + 6'd0]};
        operation_in    &lt;= opcode_tmp;
        pattern_count   &lt;= pattern_count + 6'd1;
    end
end

always@(posedge clk) begin
    if(start_check) begin
        if(pattern_count==0) begin
            $display(&quot;***************************************************&quot;);
            $display(&quot;*             PATTERN RESULT TABLE                *&quot;);
            $display(&quot;***************************************************&quot;);
            $display(&quot;* PATTERN *              Result             * ZCV *&quot;);
            $display(&quot;***************************************************&quot;);
        end
        else if(pattern_count &lt; (PATTERN_NUMBER+1)) begin
            if(result_out == result_correct) begin
                if(zcv_out != zcv_correct) begin
                    $display(&quot;* No.%2d error!                                    *&quot;,pattern_count);
                    $display(&quot;* Correct result: %h     Correct ZCV: %b   *&quot;,result_correct, zcv_correct[3-1:0]);
                    $display(&quot;* Your result: %h        Your ZCV: %b      *&quot;,result_out, zcv_out);
                    $display(&quot;***************************************************&quot;);
                    error_count &lt;= error_count + 6'd1;
                end
                else begin
                    correct_count &lt;= correct_count + 6'd1;
                end
            end
            else begin
                $display(&quot;* No.%2d error!                                    *&quot;,pattern_count);
                $display(&quot;* Correct result: %h     Correct ZCV: %b   *&quot;,result_correct, zcv_correct[3-1:0]);
                $display(&quot;* Your result: %h        Your ZCV: %b      *&quot;,result_out, zcv_out);
                $display(&quot;***************************************************&quot;);
                error_count &lt;= error_count + 6'd1;
            end
        end
    end
end

endmodule

result error
***************************************************
*             PATTERN RESULT TABLE                *
***************************************************
* PATTERN *              Result             * ZCV *
***************************************************
* No. 1 error!                                    *
* Correct result: eeeeeeee     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No. 3 error!                                    *
* Correct result: 9bf5fea6     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No. 4 error!                                    *
* Correct result: 00000000     Correct ZCV: 110   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No. 5 error!                                    *
* Correct result: fffffffe     Correct ZCV: 001   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No. 6 error!                                    *
* Correct result: 70459a76     Correct ZCV: 011   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No. 7 error!                                    *
* Correct result: 7530eca9     Correct ZCV: 010   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No. 8 error!                                    *
* Correct result: 00000001     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No. 9 error!                                    *
* Correct result: ffffffff     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.11 error!                                    *
* Correct result: ffffffff     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.12 error!                                    *
* Correct result: 00000000     Correct ZCV: 110   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.13 error!                                    *
* Correct result: 00000000     Correct ZCV: 110   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.14 error!                                    *
* Correct result: 00000001     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.15 error!                                    *
* Correct result: 00000000     Correct ZCV: 110   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.16 error!                                    *
* Correct result: 000000ff     Correct ZCV: 010   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.18 error!                                    *
* Correct result: 00000001     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.21 error!                                    *
* Correct result: 00000001     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.22 error!                                    *
* Correct result: ffffffff     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.23 error!                                    *
* Correct result: 12345678     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.24 error!                                    *
* Correct result: 02244220     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.26 error!                                    *
* Correct result: ffffffff     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.27 error!                                    *
* Correct result: 97755779     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.28 error!                                    *
* Correct result: ffffffff     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
* No.30 error!                                    *
* Correct result: ffffffff     Correct ZCV: 000   *
* Your result: 00000000        Your ZCV: 100      *
***************************************************
","Did not run it through any tool but please try this:
wire carryout0,  carryout1, carryout2, carryout3, carryout4, carryout5, carryout6, carryout7, carryout8, carryout9, carryout10, carryout11, carryout12, carryout13, carryout14, carryout15, carryout16, carryout17, carryout18, carryout19, carryout20, carryout21, carryout22, carryout23, carryout24, carryout25, carryout26, carryout27, carryout28, carryout29, carryout30;
wire [31:0] results;
ALU_1bit UUT0(src1[0], src2[0], ALU_control[3], ALU_control[2], ALU_control[2], ALU_control[1:0], results[0], carry0);
ALU_1bit UUT1(src1[1], src2[1], ALU_control[3], ALU_control[2], carry0, ALU_control[1:0], results[1], carry1);
ALU_1bit UUT2(src1[2], src2[2], ALU_control[3], ALU_control[2], carry1, ALU_control[1:0], results[2], carry2);
ALU_1bit UUT3(src1[3], src2[3], ALU_control[3], ALU_control[2], carry2, ALU_control[1:0], results[3], carry3);
ALU_1bit UUT4(src1[4], src2[4], ALU_control[3], ALU_control[2], carry3, ALU_control[1:0], results[4], carry4);
ALU_1bit UUT5(src1[5], src2[5], ALU_control[3], ALU_control[2], carry4, ALU_control[1:0], results[5], carry5);
ALU_1bit UUT6(src1[6], src2[6], ALU_control[3], ALU_control[2], carry5, ALU_control[1:0], results[6], carry6);
ALU_1bit UUT7(src1[7], src2[7], ALU_control[3], ALU_control[2], carry6, ALU_control[1:0], results[7], carry7);
ALU_1bit UUT8(src1[8], src2[8], ALU_control[3], ALU_control[2], carry7, ALU_control[1:0], results[8], carry8);
ALU_1bit UUT9(src1[9], src2[9], ALU_control[3], ALU_control[2], carry8, ALU_control[1:0], results[9], carry9);
ALU_1bit UUT10(src1[10], src2[10], ALU_control[3], ALU_control[2], carry9, ALU_control[1:0], results[10], carry10);
ALU_1bit UUT11(src1[11], src2[11], ALU_control[3], ALU_control[2], carry10, ALU_control[1:0], results[11], carry11);
ALU_1bit UUT12(src1[12], src2[12], ALU_control[3], ALU_control[2], carry11, ALU_control[1:0], results[12], carry12);
ALU_1bit UUT13(src1[13], src2[13], ALU_control[3], ALU_control[2], carry12, ALU_control[1:0], results[13], carry13);
ALU_1bit UUT14(src1[14], src2[14], ALU_control[3], ALU_control[2], carry13, ALU_control[1:0], results[14], carry14);
ALU_1bit UUT15(src1[15], src2[15], ALU_control[3], ALU_control[2], carry14, ALU_control[1:0], results[15], carry15);
ALU_1bit UUT16(src1[16], src2[16], ALU_control[3], ALU_control[2], carry15, ALU_control[1:0], results[16], carry16);
ALU_1bit UUT17(src1[17], src2[17], ALU_control[3], ALU_control[2], carry16, ALU_control[1:0], results[17], carry17);
ALU_1bit UUT18(src1[18], src2[18], ALU_control[3], ALU_control[2], carry17, ALU_control[1:0], results[18], carry18);
ALU_1bit UUT19(src1[19], src2[19], ALU_control[3], ALU_control[2], carry18, ALU_control[1:0], results[19], carry19);
ALU_1bit UUT20(src1[20], src2[20], ALU_control[3], ALU_control[2], carry19, ALU_control[1:0], results[20], carry20);
ALU_1bit UUT21(src1[21], src2[21], ALU_control[3], ALU_control[2], carry20, ALU_control[1:0], results[21], carry21);
ALU_1bit UUT22(src1[22], src2[22], ALU_control[3], ALU_control[2], carry21, ALU_control[1:0], results[22], carry22);
ALU_1bit UUT23(src1[23], src2[23], ALU_control[3], ALU_control[2], carry22, ALU_control[1:0], results[23], carry23);
ALU_1bit UUT24(src1[24], src2[24], ALU_control[3], ALU_control[2], carry23, ALU_control[1:0], results[24], carry24);
ALU_1bit UUT25(src1[25], src2[25], ALU_control[3], ALU_control[2], carry24, ALU_control[1:0], results[25], carry25);
ALU_1bit UUT26(src1[26], src2[26], ALU_control[3], ALU_control[2], carry25, ALU_control[1:0], results[26], carry26);
ALU_1bit UUT27(src1[27], src2[27], ALU_control[3], ALU_control[2], carry26, ALU_control[1:0], results[27], carry27);
ALU_1bit UUT28(src1[28], src2[28], ALU_control[3], ALU_control[2], carry27, ALU_control[1:0], results[28], carry28);
ALU_1bit UUT29(src1[29], src2[29], ALU_control[3], ALU_control[2], carry28, ALU_control[1:0], results[29], carry29);
ALU_1bit UUT30(src1[30], src2[30], ALU_control[3], ALU_control[2], carry29, ALU_control[1:0], results[30], carry30);
ALU_1bit UUT31(src1[31], src2[31], ALU_control[3], ALU_control[2], carry30, ALU_control[1:0], results[31], cout);

always@(posedge rst_n) begin
  result = results;
  zero = ~(|results);
  overflow = results[31] ^ cout;
end

always@(negedge rst_n) begin
  result &lt;= 32'b0;
  zero = 0;
  overflow = 0;
end

endmodule
",,,,,
constraint dependents in array of classes,"How can I constraint 2 variables in an array of classes, when there is a dependent between different items of the array?
class X;
  rand bit en;
  rand int idx;

  constraint cnst1{
     idx inside {[0:9]};
  }
endclass

class Y;
   rand X arr_x[100];

   constraint cnst2{
      ???
   }
endclass

I want to create cnst2 that will guarantee that:

each idx optional value (0-9) will be set for at least one of the arr_x[i].idx .
for all of the arr_x[i] that have the same value of idx, at least 1 will have en set to 1.

for example:
let's say that only the following have idx == 9:
arr_x[0].idx == 9;
arr_x[13].idx == 9;
arr_x[44].idx == 9;
arr_x[75].idx == 9;
arr_x[81].idx == 9;
arr_x[93].idx == 9;

need to guarantee that:
arr_x[0].en | arr_x[13].en | arr_x[44].en | arr_x[75].en | arr_x[81].en | arr_x[93].en == 1;

and so on for every idx value;","You want the or array reduction method. Also create a helper array so you can iterate from 0-9. This constraint reads: if at least one element has the value 0-9, then one of those elements has to have en set.
bit iterator[10];
constraint cnst2{
  foreach(iterator[i])
       arr_x.or(x) with (i ==x.idx) -&gt; // needed if idx will not have every value 0-9
         arr_x.or(y) with (i == y.idx &amp;&amp; y.en);
}

See sections 18.5.8.2 Array reduction iterative constraints and 7.12.3 Array reduction methods in the IEEE 1800-2017 SystemVerilog LRM.",,,,,
When to use `include in SystemVerilog,"i was wondering what's the use of the `include preprocessor directive and when to use it. For example i was using Xilinx's Vivado and i tried this:
module A (          //This is the top module 
    input  logic x, y,
    output logic z
    );
    
    B B1 (.a(x),
          .b(y),
          .c(z)
          );
endmodule

I wrote in a different file this
module B(
    input  logic a, b,
    output logic c
        );
        
        assign c = a &amp; b;
endmodule

The software didn't warn me of anything and it synthetized correctly. So now I'm a little bit confused, also I've seen people that include every file in their top module other people that include only their parmeters and packages.","In order for verilog to compile your model you need to provide all files which contain relevant code in one of two ways:

list of files at command line
use `include

Method #1 assumes a certain compilation order (first to last). However, it does not matter in which order design elements (modules, primitives, ...) are compiled. The compiler can always locate a module either compiled before or after the code which instantiates it.
Certain verilog elements require a specific order of compilation. In classic verilog those are macro definitions (`define). System verilog adds packages and definitions in  global scope. If your files contain those elements, they must be listed before the code which uses them.
The other case, related mostly to pre-system verilog world, is to use `include to insert common parameter definitions in scopes of modules. This way the statement appears inside of the module. In system verilog this can be replaced with packages and import statements.
For order-dependent compilation elements you can put them in the compilation list before the code which uses them. However at times the order could be difficult to implement. `includes help in this situation. They alow you to guarantee the order of compilation and also group related files together.
Verilog allows you to `include any code, it just does not care. However, in my experience, `include of code which contains design elements (modules) can cause code management issues and can cause compilation issues in some cases.",,,,,
"""logical root block and symbol is not supported in target"" error in ISE Design Suite 14.7","I'm a total noob in ISE Design Suite 14.7 and I don't know a thing.
I'm trying to make a SR latch (I know there is a SR latch in ISE but I want to create it myself to practice).
the SR latch itself works fine but I get an error from Top_Module.
here is the code for SR latch:

and the top module code and the error when I want to implement it:

It works fine when I change the top module to SRlatch.v and not the topmodule.v.
what should I do?
please don't say I have to search on google because I don't understand a thing.","I solved the problem. What I wrote was rudimentary and also wasn't well connected and it couldn't implement it.
But I wanted to see the result by using ModelSim and it was fine with it and compiled it.",,,,,
VHDL - Register for Push Button,"I'm trying to create a simple push button in VHDL that turns on after an input switch or pb goes from 0 to 1 to 0 using a clock and a process. However, my code seems to be giving me undefined output. Here's what I have so far.
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

Entity captureInput is port
(
    CLK          : in  std_logic := '0';
     RESET_n      : in  std_logic := '0';
     buttonState  : in  std_logic := '0';
     buttonOut    : out std_logic := '0'
);
end Entity;

   ARCHITECTURE one of captureInput is
    
    signal lastButtonState: std_logic := '0';
    signal btnState      : std_logic := '0'; 
    
BEGIN

process (CLK, RESET_n) is

begin
   if (RESET_n = '0') then
        lastButtonState &lt;= '0';
         
    elsif (rising_edge(CLK)) then
        if (buttonState ='0' and lastButtonState = '1') then
             btnState &lt;= '1';
    end if;
     lastButtonState &lt;= buttonState;
    end if; 
end process;

buttonOut &lt;= btnState

end;
","Try to initialize your btnState in the reset branch of your register and also have an else statement where you set your btnState back to 0, under some condition. I would bet that your undefined output comes from the fact that you do not define your btnState anywhere else outside your if conditions. It's good practice to not rely on the initial value of your declaration: Synthesis tools ignore it and some simulators will as well. Also, remember that the clocked body of the if will generate a register for every signal that gets assigned a value inside it, and that signals will keep the last value assigned to them inside a process.
You are also missing the Library ieee; statement at the top and a semicolon after buttonOut &lt;= btnState.",,,,,
Is it possible to use the same expression in a case statement included in different other case statement in SystemVerilog?,"I have a SystemVerilog testbench in which I want to use a case statement in other case statements from my program.
For example, I have:
    task a(string b,string c)
    case(b)
     &quot;a1&quot;: x(x1,case(c) &quot;b1&quot;:y=1; &quot;b2&quot;:y=2;);
     &quot;a2&quot;: x(x2,case(c) &quot;b3&quot;:y=4; &quot;b4&quot;:y=5;);

This is the structure I want to implement, to use the case with string c in multiple different case items.","If I guess correctly, x represents a task or a function and you are trying to pass a case statement as an argument. right? impossible.
But this should work:
 task a(string b,string c)
    case(c)
      &quot;b1&quot;: y = 1;
      &quot;b2&quot;: y = 2;
      ...
    endcase

    case(b)
     &quot;a1&quot;: x(x1,y);
     &quot;a2&quot;: x(x2,y);

or for case within a case in general use begin/end:
     &quot;a1&quot;: begin
            x=x1;
            case(c) 
              &quot;b1&quot;:y=1; 
              &quot;b2&quot;:y=2;
            endcase
           end
     &quot;a2&quot;: begin
            x = x2;
            case(c)
              &quot;b3&quot;: y=3;
              &quot;b4&quot;: y= 4;
            endcase
           end
      endcase
",,,,,
Cannot reserve memory on Petalinux2020.2?,"I'm building a project using petalinux2020.2 and an RFSOC, zcu111 board, for my application I need to reserve a section of memory from petalinux to use with DMA, implemented on the programmable logic of the FPGA.
I tried following this tutorial, but I get an error at boot time.

Which terminates with a kernel panic, shown here:

I've tried to modify Memory Size by using petalinux-config command, setting the Memory Size to 0x70000000 but it did not help.
The entry for the device tree is shown here:
/include/ &quot;system-conf.dtsi&quot;
/{
    reserved-memory {
        #address-cells = &lt;2&gt;;
        #size-cells = &lt;2&gt;;
        ranges;
 
        reserved: buffer@0 {
            no-map;
            reg = &lt;0x0 0x70000000 0x0 0x10000000&gt;;
        };
    };
    reserved-driver@0 {
        compatible = &quot;xlnx,reserved-memory&quot;;
        memory-region = &lt;&amp;reserved&gt;;
    };
};

How can I make this work?","I'm running PetaLinux 2018.1 on a Zynq-7020 board and can successfully reserve memory for my DMA operations.  While not your exact set up it should be similar enough.  You'll need to adjust the memory addresses to suit your system.
I'm using the DMA API &quot;shared-dma-pool&quot; property.  That way my device driver will use my reserved space instead of the default CMA pool.
Also, note that I had problems reserving the memory until I added the vmalloc=512M statement to the bootargs.  Although I was only reserving 256MB for DMA, I needed to vmalloc a larger value (double in my case) to get things to work.
My device tree entry:
/include/ &quot;system-conf.dtsi&quot;
/ {
    chosen {
    bootargs = &quot;console=ttyPS0,115200 earlyprintk vmalloc=512M&quot;;
    stdout-path = &quot;serial0:115200n8&quot;;
    };

reserved-memory {
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;1&gt;;
        ranges;
 
            dma_reserved: buffer@30000000 {
        compatible = &quot;shared-dma-pool&quot;;
            no-map;
        reg = &lt;0x30000000 0x10000000&gt;;
            };
    };

    //Required properties: 
    // - dmas: a list of &lt;[DMA device phandle] [Channel ID]&gt; pairs, 
    //         where Channel ID is (if both channels are enabled):
    //      '0' for write/tx channel
    //      '1' for read/rx channel 
    //     If only one channel is enabled, either tx or rx: 
    //      Channel ID is '0'. 
    // - dma-names: a list of DMA channel names, one per &quot;dmas&quot; entry 
    dma_proxy@0 {
        compatible =&quot;xlnx,dma_proxy&quot;;
        dmas = &lt;&amp;axi_dma_0 0;
        dma-names = &quot;dma1&quot;;
    memory-region = &lt;&amp;dma_reserved&gt;;
    };
}

Console showing reserved memory:
",,,,,
"how can i use ""with-select"" in vhdl?","Hello :) im still noobie to vhdl and trying to implement the following with with-select but im getting false logic when implementing to my FBGA i dont know what am missing but somehow its tricky and it would be really nice if someone can tell me where im missing the point ...
what im tring to implement is
o0 = ((not i3) and i1 and i0) or ((not i3) and (not i2) and i1) or (i0 and (not i2)) or (i3  and (not i0))
o1 = ((not i0) and i3) or ((not i3) and (not i2) and i1) or (i0 and i2 and i3 and i1)
o2 = (i0 and i2 and i3 and i1) or ((not i3) and (not i1)) or (i3 and (not i1))
o3 = ((i3) and (not i0)) or ((not i3) and (not i2) and i1) or ((not i3) and i0 and i1)
im trying to rebuild a PROM ... my vhdl code is :
library ieee;
use ieee.std_logic_1164.all;
 
entity with_select is
port(i3,i2,i1,i0 : in std_logic;
      o0,o1,o2,o3:out std_logic
            );
end with_select;
 
architecture behave of with_select is
 signal s_out : std_logic_vector(3 downto 0);   
begin
  with i0 select
  o0&lt;=((not i3) and i1 and i0) or ((not i3) and (not i2) and i1) or (i0 and (not i2)) or (i3  and (not i0)) when '1',
    '0' when others;
       with i1 select
  o1&lt;=((not i0) and i3) or ((not i3) and (not i2) and i1) or (i0 and i2 and i3 and i1)  when '1',
    '0' when others;
       with i2 select
  o2&lt;=(i0 and i2 and i3 and i1) or ((not i3) and (not i1)) or (i3 and (not i1)) when '1',
    '0' when others;
       with i3 select
  o3&lt;=((i3) and (not i0)) or ((not i3) and (not i2) and i1) or ((not i3) and i0 and i1) when '1', 
  '0' when others;
 end behave;
","The terms are not correct for the Boolean expressions when using a selected signal assignment statement.  The choice '1' requires in the assignment to o0 for example requires i0 to be '1' which contradicts the terms:
    with i0 select
    o0 &lt;= ((not i3) and i1 and i0) or 
          ((not i3) and (not i2) and i1) or 
           (i0 and (not i2)) or 
           (i3  and (not i0))   when '1',
          '0' when others;

Correcting this requirement can be performed in a selected signal assignment by modifying terms:
-- selected signal assignment statement with corrected terms
    with to_x01(i0) select
       o0s &lt;=
          -- ((not i3) and i1 and i0) or
           (not i3 and i1) or
          -- ((not i3) and (not i2) and i1) or -- met in new term above
          -- (i0 and (not i2)) or              -- as well as new term below
          not i2
          -- (i3  and (not i0))
          when '1',
           (not i3 and not i2 and i1) or
           i3
          when '0',
          'X' when others;  -- because std_logic;

but it takes effort to translate.
There are two other types of assignment that will do as well:
-- conditional signal assignment statement equivalent
        o0c &lt;= '1' when (
                       (not i3 and i1 and i0) or 
                       (not i3 and not i2 and i1) or 
                       (i0 and not i2) or 
                       (i3  and not i0)
                       ) = '1' else
              '0';

-- simple signal assignment statement
         o0d &lt;= (not i3 and i1 and i0) or 
               (not i3 and not i2 and i1) or 
               (i0 and not i2) or 
               (i3  and not i0);

You can demonstrate the original selected signal assignment statement doesn't match the Boolean expressions:
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity with_select_tb is
end entity;

architecture foo of with_select_tb is
    signal i0, i1, i2, i3:  std_logic;
    signal o0:              std_logic;  -- original result
    signal o0s:             std_logic;  -- corrected selected signal assignment
    signal o0c:             std_logic;  -- conditional signal assignment
    signal o0d:             std_logic;  -- dataflow simple waveform assignment
    -- for revision less than -2008:
    function to_string (inp: std_logic_vector) return string is
        variable image_str: string (1 to inp'length);
        alias input_str:  std_logic_vector (1 to inp'length) is inp;
    begin
        for i in input_str'range loop
            image_str(i) := character'VALUE(std_ulogic'IMAGE(input_str(i)));
        end loop;
        return image_str;
    end function;
begin
-- original selected signal assignment    
    with i0 select
    o0 &lt;= ((not i3) and i1 and i0) or 
          ((not i3) and (not i2) and i1) or 
           (i0 and (not i2)) or 
           (i3  and (not i0))   when '1',
          '0' when others;

-- selected signal assignment statement with corrected terms
    with to_x01(i0) select
       o0s &lt;=
          -- ((not i3) and i1 and i0) or
           (not i3 and i1) or
          -- ((not i3) and (not i2) and i1) or -- met in new term above
          -- (i0 and (not i2)) or              -- as well as new term below
          not i2
          -- (i3  and (not i0))
          when '1',
           (not i3 and not i2 and i1) or
           i3
          when '0',
          'X' when others;  -- because std_logic;
               
-- conditional signal assignment statement equivalent
        o0c &lt;= '1' when (
                       (not i3 and i1 and i0) or 
                       (not i3 and not i2 and i1) or 
                       (i0 and not i2) or 
                       (i3  and not i0)
                       ) = '1' else
              '0';

-- simple signal assignment statement
         o0d &lt;= (not i3 and i1 and i0) or 
                (not i3 and not i2 and i1) or 
                (i0 and not i2) or 
                (i3 and not i0);

STIMULI:
    process
    begin
        report LF &amp; HT &amp; &quot;(i3, i2, i1, i0)&quot; &amp; HT &amp;
                 &quot;o0  &quot; &amp; &quot;o0s &quot; &amp; &quot;o0c &quot; &amp; &quot;o0d &quot;;
        for i in 0 to 15 loop
            (i3, i2, i1, i0) &lt;= std_logic_vector(to_unsigned(i,4));
            wait for 10 ns;
            report LF &amp; HT &amp; to_string(std_logic_vector'(i3, i2, i1, i0)) &amp;
                   HT &amp; HT &amp; HT &amp;
                   std_ulogic'image(o0)  &amp; &quot; &quot; &amp;
                   std_ulogic'image(o0s) &amp; &quot; &quot; &amp;
                   std_ulogic'image(o0c) &amp; &quot; &quot; &amp;
                   std_ulogic'image(o0d);
        end loop;
        wait;
    end process;
    
end architecture foo;

which produces:
ghdl -r with_select_tb
with_select.vhdl:92:9:@0ms:(report note):
        (i3, i2, i1, i0)        o0  o0s o0c o0d
with_select.vhdl:97:13:@10ns:(report note):
        0000                    '0' '0' '0' '0'
with_select.vhdl:97:13:@20ns:(report note):
        0001                    '1' '1' '1' '1'
with_select.vhdl:97:13:@30ns:(report note):
        0010                    '0' '1' '1' '1'
with_select.vhdl:97:13:@40ns:(report note):
        0011                    '1' '1' '1' '1'
with_select.vhdl:97:13:@50ns:(report note):
        0100                    '0' '0' '0' '0'
with_select.vhdl:97:13:@60ns:(report note):
        0101                    '0' '0' '0' '0'
with_select.vhdl:97:13:@70ns:(report note):
        0110                    '0' '0' '0' '0'
with_select.vhdl:97:13:@80ns:(report note):
        0111                    '1' '1' '1' '1'
with_select.vhdl:97:13:@90ns:(report note):
        1000                    '0' '1' '1' '1'
with_select.vhdl:97:13:@100ns:(report note):
        1001                    '1' '1' '1' '1'
with_select.vhdl:97:13:@110ns:(report note):
        1010                    '0' '1' '1' '1'
with_select.vhdl:97:13:@120ns:(report note):
        1011                    '1' '1' '1' '1'
with_select.vhdl:97:13:@130ns:(report note):
        1100                    '0' '1' '1' '1'
with_select.vhdl:97:13:@140ns:(report note):
        1101                    '0' '0' '0' '0'
with_select.vhdl:97:13:@150ns:(report note):
        1110                    '0' '1' '1' '1'
with_select.vhdl:97:13:@160ns:(report note):
        1111                    '0' '0' '0' '0'

The simple signal assignment resembles the original Boolean expressions. You could provide parentheses around occurrences of the unary not operator and it's operand to match style. VHDL prioritizes not over other logical operators and the parentheses are not required.

Note report statement format is VHDL tool implementation dependent.",,,,,
Is There Any Limit to How Wide 2 VHDL Numbers Can Be To Add Them In 1 Clock Cycle?,"I am considering adding two 1024-bit numbers in VHDL.
Ideally, I would like to hit a 100 MHz clock frequency.
Target is a Xilinx 7-series.
When you add 2 numbers together, there are inevitably carry bits. Since carry bits on the left cannot be computed until bits on the right have been calculated, to me it seems there should be a limit on how wide a register can be and still be added in 1 clock cycle.
Here are my questions:
1.) Do FPGAs add numbers in this way? Or do they have some way of performing addition that does not suffer from the carry problem?
2.) Is there a limit to the width? If so, is 1024 within the realm of reason for a 100 MHz clock, or is that asking for trouble?","No. You just need to choose a suitably long clock cycle.
Practically, though there is no fundamental limit, for any given cycle time, there will be some limit which depends on the FPGA technology.
At 1024 bits, I'd look at breaking the addition and pipelining it.
Implemented as a single cycle, I would expect a 1024 bit addition to have a speed somewhere around 5, maybe 10 MHz. (This would be easy to check : synthesise one and look at the timing reports!)
Pipelining is not the only approach to overcoming that limit.
There are also &quot;fast adder&quot; architectures like carry look-ahead, carry-save (details via the usual sources) ... these pretty much fell out of fashion when FPGAs built fast carry chains into the LUT fabric, but they may have niche uses such as yours. However they may not be optimally supported by synthesis since (for most purposes) the fast carry chain is adequate.",,,,,
"No feasible entry to subprogram shift_left, type error near","I am trying to use the function shift_left() in my project, but I'm getting 2 errors I can't explain:

Error: type error near 'shift left'; expected type 'std_logic_vector'

but temp IS a std_logic_vector!

Error: no feasible entry for subprogram 'shift_left' found

the signals used in the code are defined as:
signal shifted_pixel, temp : std_logic_vector(15 downto 0);
signal i_data : std_logic_vector(7 downto 0);

the snippet below is written within a process
temp &lt;= &quot;00000000&quot; &amp; i_data;
shifted_pixel &lt;= shift_left(temp, 5);

full code below:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.ALL;


entity project is
    port (
        i_clk     : in std_logic;
        i_rst     : in std_logic;
        i_start   : in std_logic;
        i_data    : in std_logic_vector(7 downto 0);
    );
end project;

architecture rtl of project is
    signal shifted_pixel, temp : std_logic_vector(15 downto 0);
    begin
        process(i_data)
        begin
            temp &lt;= &quot;00000000&quot; &amp; i_data;
            shifted_pixel &lt;= shift_left(temp, 5);
        end process;
end rtl;
","The shift_left function in numeric_std package takes an unsigned as first argument and it returns an unsigned value.
So you have to cast your values:
shifted_pixel &lt;= std_logic_vector(shift_left(unsigned(temp), 5));

HTH",,,,,
Intel MAX 10 DDR output,"I want to output a clock signal via a DDR register. The target FPGA is an Intel MAX 10 (10M16DAU324I7G) FPGA. I instantiate an ALTDDIO_OUT component as shown in the code below. However, the output Pin stays permanently low. Clock is running, Pin in R15.
Can anyone provide a hint what my problem could be?
library ieee;
use ieee.std_logic_1164.all;

library altera_mf;
use altera_mf.altera_mf_components.all;

entity ddr_test
    port(
        clk_in  : in  std_logic;        
        clk_out : out std_logic
    );
end entity ddr_test;

architecture rtl of ddr_test is
    signal s_clk : std_logic;
begin
    s_clk &lt;= clk_in; --omitted the global clock network for simplicity

    i_ODDR : component ALTDDIO_OUT
        generic map(
            width =&gt; 1
        )
        port(
            datain_h   =&gt; &quot;1&quot;,
            datain_l   =&gt; &quot;0&quot;,
            outclock   =&gt; s_clk,
            dataout(0) =&gt; clk_out
        );
end architecture rtl;
","Direct instantiation of the ALTDDIO_OUT primitive does not seem to work reliably on the chosen FPGA and/or tool chain (MAX 10, Quartus Prime 18.1).
The solution is to generate an IP core with the MegaWizard GPIO Lite Intel FPGA IP using a DDR register output.",,,,,
Illegal concatenation of an unsized constant,"I wrote the following testbench:
// 4-&gt;1 multiplexer TB template
module mux4_tb;

//Some code

    initial begin
        d0={0,0,0,0};
    end

endmodule

But, when I run it, I get 24 errors like this one:

Error (suppressible): mux4_tb.sv(23): (vlog-2121) Illegal concatenation of an unsized constant. Will treat it as a 32-bit value.

What's wrong with my code above?
In case you need it:
// 4-&gt;1 multiplexer template
module mux4 (
    input logic[3:0] d0,    // Data input 0
    input logic[3:0] d1,    // Data input 1
    input logic[3:0] d2,    // Data input 2
    input logic[3:0] d3,    // Data input 3
    input logic[1:0] sel,   // Select input
    output logic[3:0] z     // Output
);
","If you look at the definition of the concatenation operator in section 11.4.12 of the 1800-2017 LRM (or any earlier Verilog version), it says

Unsized constant numbers shall not be allowed in concatenations.

This is because in earlier versions, the size of integers and integer constant literals was implementation dependent. But even now in the current version where an integer is sized 32 bits, many people forget that the simple unsized literals 0 and 0 are not single bits. They are implicitly 32â€™sd0. (32-bit signed decimal literal 0) You would need to write the following to use a concatenation:
d0={1'b0,1'b0,1'b0,1'b0};

or you could just use a binary literal:
d0 = 4'b0_0_0_0;

Your mistake is exactly the motivation behind the restriction of not allowing unzied (actually implictly sized) literals inside a concatenation.",,,,,
"Index out of range error in Verilog, although the register is declared correctly","I am trying to learn Verilog and I have this simple code
module division (
    output reg [14:0] A,
    input [14:0] D);
    
    reg[4:0] i;

    always @(*) begin
    
        for (i = 14; i &gt;= 0; i = i-1) begin
            
            A[0] = D[i];
            
        end
    end         
endmodule 

This returns the error : Index out of range for D.. I have no idea why, since D is declared on that interval. Can you please help me?
I know the code might not make any sense, but I only included the relevant part to the issue.","You have declared i as unsigned, so the expression i &gt;= 0 will always be true.
When i reaches 0, the next iteration is 5'b11111, which is out of range. You should declare i as an integer or add the signed keyword.",,,,,
Verilog function returning wrong value,"Can somebody please help me understand why my function is not working as I'd like it to?
module TestBench2();
 
localparam SELECT_NONE   = 0;
localparam SELECT_RAM    = 1;
localparam SELECT_VGA    = 2;
localparam SELECT_UNKNOWN = 8;
 
logic iClk;  
logic reset;
 
logic [ 4 : 0 ] chipSelect;
logic [ 4 : 0 ] requestChipSelect;
logic [ 4 : 0 ] chipSelected;
 
logic oVGAInitReadRequest;
logic oVGALineComplete;
 
initial
begin
  reset = 1;
  oVGAInitReadRequest = 0;
  oVGALineComplete = 0;  
  chipSelected = SELECT_UNKNOWN;
end
 
function automatic logic [ 4 : 0 ] chipSelectFunc;
input requestChipSelect, oVGAInitReadRequest, oVGALineComplete;
 
  if( requestChipSelect == SELECT_VGA )
  begin
    $display( &quot;  requestChipSelect == SELECT_VGA?  -&gt; YES&quot;);
    chipSelectFunc = SELECT_VGA;
    chipSelected   = SELECT_VGA;
  end
  else
  if( oVGAInitReadRequest )
  begin
    $display( &quot;  oVGAInitReadRequest?  -&gt; YES&quot;);
    chipSelectFunc = SELECT_VGA;
    chipSelected   = SELECT_VGA;
  end
  else
  if( oVGALineComplete )
  begin
    $display( &quot;  oVGALineComplete?  -&gt; YES&quot;);
    chipSelectFunc = SELECT_NONE;
    chipSelected   = SELECT_NONE;
  end
  else
  if( requestChipSelect == SELECT_RAM )
  begin
    $display( &quot;  requestChipSelect == SELECT_RAM?  -&gt; YES&quot;);
    chipSelectFunc = SELECT_RAM;
    chipSelected   = SELECT_RAM;
  end
  else
  if( requestChipSelect == SELECT_NONE )
  begin
    $display( &quot;  requestChipSelect == SELECT_NONE?  -&gt; YES&quot;);
    chipSelectFunc = SELECT_NONE;
    chipSelected   = SELECT_NONE;
  end
  else
  begin
    $display( &quot;requestChipSelect -&gt; STAY SAME&quot;);
    // Leave it as-is
    chipSelectFunc = chipSelected;
  end
 
endfunction
 
assign chipSelect = chipSelectFunc( requestChipSelect, oVGAInitReadRequest, oVGALineComplete );
 
integer count = 0;
 
always @( posedge iClk )
begin
  reset = 0;
 
  case( count )
     1: begin
          $strobe (&quot;%2d:requestChipSelect &lt;= SELECT_VGA&quot;, count);  
          requestChipSelect &lt;= SELECT_VGA;
        end
 
     2: begin
          $strobe (&quot;%2d:requestChipSelect &lt;= SELECT_NONE&quot;, count);
          requestChipSelect &lt;= SELECT_NONE;
        end      
 
     default: begin
          $strobe (&quot;%2d:Default case&quot;, count);
        end
  endcase
 
  $strobe (&quot;%2d:chipSelect: %d &quot;, count, chipSelect);  
  count ++;
end
 
endmodule

When I run the above code, I get this as the output:
# requestChipSelect -&gt; STAY SAME
#  1:Default case
#  1:chipSelect:  8 
#   requestChipSelect == SELECT_NONE?  -&gt; YES
#  2:requestChipSelect &lt;= SELECT_VGA
#  2:chipSelect:  0 
#   requestChipSelect == SELECT_NONE?  -&gt; YES

Why is it that when requestChipSelect is set to SELECT_VGA (2), my function always sees/treats this as 0?","Because you have declared requestChipSelect to be 1 bit wide:
function automatic logic [ 4 : 0 ] chipSelectFunc;
input requestChipSelect, oVGAInitReadRequest, oVGALineComplete;

instead of (eg) 5, like your return value:
function automatic logic [ 4 : 0 ] chipSelectFunc;
input [ 4 : 0 ] requestChipSelect;       
input oVGAInitReadRequest, oVGALineComplete;
",,,,,
Rotations Operations for 16bit ALU using multiplexers (updated question),"I'm new to this topic, with less knowledge about the coding part of it. But is there a way to implement multiple bit rotate operations using multiplexers for 16bit ALU ? I know the understanding, but not the coding part in iVerilog. I did barrel shifter part, but don't know this. Please help out.
The code below is for shifting right, similarily how to do for rotations, left and right?
module mux2 (input wire i0, i1, j, output wire o);
  assign o = (j==0)?i0:i1;
endmodule

module barrel_shift_16bit (in, ctrl, out);
  input  [15:0] in;
  input [3:0] ctrl;
  output [15:0] out;
  wire [15:0] x,y,z;
 
 
//8bit shift right
mux2 mux_15(in[15],1'b0,ctrl[3],x[15]);
mux2 mux_14(in[14],1'b0,ctrl[3],x[14]);
mux2 mux_13(in[13],1'b0,ctrl[3],x[13]);
mux2 mux_12(in[12],1'b0,ctrl[3],x[12]);
mux2 mux_11(in[11],1'b0,ctrl[3],x[11]);
mux2 mux_10(in[10],1'b0,ctrl[3],x[10]);
mux2 mux_9(in[9],1'b0,ctrl[3],x[9]);
mux2 mux_8(in[8],1'b0,ctrl[3],x[8]);
mux2 mux_7(in[7],in[15],ctrl[3],x[7]);
mux2 mux_6(in[6],in[14],ctrl[3],x[6]);
mux2 mux_5(in[5],in[13],ctrl[3],x[5]);
mux2 mux_4(in[4],in[12],ctrl[3],x[4]);
mux2 mux_3(in[3],in[11],ctrl[3],x[3]);
mux2 mux_2(in[2],in[10],ctrl[3],x[2]);
mux2 mux_1(in[1],in[9],ctrl[3],x[1]);
mux2 mux_0(in[0],in[8],ctrl[3],x[0]);

//4bit shift right
mux2 mux_31(x[15],1'b0,ctrl[2],y[15]);
mux2 mux_30(x[14],1'b0,ctrl[2],y[14]);
mux2 mux_29(x[13],1'b0,ctrl[2],y[13]);
mux2 mux_28(x[12],1'b0,ctrl[2],y[12]);
mux2 mux_27(x[11],x[15],ctrl[2],y[11]);
mux2 mux_26(x[10],x[14],ctrl[2],y[10]);
mux2 mux_25(x[9],x[13],ctrl[2],y[9]);
mux2 mux_24(x[8],x[12],ctrl[2],y[8]);
mux2 mux_23(x[7],x[11],ctrl[2],y[7]);
mux2 mux_22(x[6],x[10],ctrl[2],y[6]);
mux2 mux_21(x[5],x[9],ctrl[2],y[5]);
mux2 mux_20(x[4],x[8],ctrl[2],y[4]);
mux2 mux_19(x[3],x[7],ctrl[2],y[3]);
mux2 mux_18(x[2],x[6],ctrl[2],y[2]);
mux2 mux_17(x[1],x[5],ctrl[2],y[1]);
mux2 mux_16(x[0],x[4],ctrl[2],y[0]);

//2bit shift right
mux2 mux_47(y[15],1'b0,ctrl[1],z[15]);
mux2 mux_46(y[14],1'b0,ctrl[1],z[14]);
mux2 mux_45(y[13],y[15],ctrl[1],z[13]);
mux2 mux_44(y[12],y[14],ctrl[1],z[12]);
mux2 mux_43(y[11],y[13],ctrl[1],z[11]);
mux2 mux_42(y[10],y[12],ctrl[1],z[10]);
mux2 mux_41(y[9],y[11],ctrl[1],z[9]);
mux2 mux_40(y[8],y[10],ctrl[1],z[8]);
mux2 mux_39(y[7],y[9],ctrl[1],z[7]);
mux2 mux_38(y[6],y[8],ctrl[1],z[6]);
mux2 mux_37(y[5],y[7],ctrl[1],z[5]);
mux2 mux_36(y[4],y[6],ctrl[1],z[4]);
mux2 mux_35(y[3],y[5],ctrl[1],z[3]);
mux2 mux_34(y[2],y[4],ctrl[1],z[2]);
mux2 mux_33(y[1],y[3],ctrl[1],z[1]);
mux2 mux_32(y[0],y[2],ctrl[1],z[0]);

//1bit shift right
mux2 mux_63(z[15],1'b0,ctrl[0],out[15]);
mux2 mux_62(z[14],z[15],ctrl[0],out[14]);
mux2 mux_61(z[13],z[14],ctrl[0],out[13]);
mux2 mux_60(z[12],z[13],ctrl[0],out[12]);
mux2 mux_59(z[11],z[12],ctrl[0],out[11]);
mux2 mux_58(z[10],z[11],ctrl[0],out[10]);
mux2 mux_57(z[9],z[10],ctrl[0],out[9]);
mux2 mux_56(z[8],z[9],ctrl[0],out[8]);
mux2 mux_55(z[7],z[8],ctrl[0],out[7]);
mux2 mux_54(z[6],z[7],ctrl[0],out[6]);
mux2 mux_53(z[5],z[6],ctrl[0],out[5]);
mux2 mux_52(z[4],z[5],ctrl[0],out[4]);
mux2 mux_51(z[3],z[4],ctrl[0],out[3]);
mux2 mux_50(z[2],z[3],ctrl[0],out[2]);
mux2 mux_49(z[1],z[2],ctrl[0],out[1]);
mux2 mux_48(z[0],z[1],ctrl[0],out[0]);
endmodule
","It looks like this code assigns '0' to x[15:8] and assigns 'in[15:8]' to x[7:0] (if ctrl[3] is 1). In a sense it is a shift right by 8 bits.
mux2 mux_15(in[15], 1'b0, ctrl[3],x[15]);
mux2 mux_14(in[14], 1'b0, ctrl[3],x[14]);
mux2 mux_13(in[13], 1'b0, ctrl[3],x[13]);
mux2 mux_12(in[12], 1'b0, ctrl[3],x[12]);
mux2 mux_11(in[11], 1'b0, ctrl[3],x[11]);
mux2 mux_10(in[10], 1'b0, ctrl[3],x[10]);
mux2 mux_9(in[9],   1'b0, ctrl[3],x[9]);
mux2 mux_8(in[8],   1'b0, ctrl[3],x[8]);

mux2 mux_7(in[7],in[15],ctrl[3],x[7]);
mux2 mux_6(in[6],in[14],ctrl[3],x[6]);
mux2 mux_5(in[5],in[13],ctrl[3],x[5]);
mux2 mux_4(in[4],in[12],ctrl[3],x[4]);
mux2 mux_3(in[3],in[11],ctrl[3],x[3]);
mux2 mux_2(in[2],in[10],ctrl[3],x[2]);
mux2 mux_1(in[1],in[9],ctrl[3],x[1]);
mux2 mux_0(in[0],in[8],ctrl[3],x[0]);

Following the same logic, rotation would mean to assign 'in[7:0]' to 'x[15:8]'. Is it what you want? if so, you can probably write it as the following:
mux2 mux_15(in[15], in[7], ctrl[3],x[15]);
mux2 mux_14(in[14], in[6], ctrl[3],x[14]);
mux2 mux_13(in[13], in[5], ctrl[3],x[13]);
mux2 mux_12(in[12], in[4], ctrl[3],x[12]);
mux2 mux_11(in[11], in[3], ctrl[3],x[11]);
mux2 mux_10(in[10], in[2], ctrl[3],x[10]);
mux2 mux_9(in[9],   in[1], ctrl[3],x[9]);
mux2 mux_8(in[8],   in[0], ctrl[3],x[8]);

mux2 mux_7(in[7],in[15],ctrl[3],x[7]);
mux2 mux_6(in[6],in[14],ctrl[3],x[6]);
mux2 mux_5(in[5],in[13],ctrl[3],x[5]);
mux2 mux_4(in[4],in[12],ctrl[3],x[4]);
mux2 mux_3(in[3],in[11],ctrl[3],x[3]);
mux2 mux_2(in[2],in[10],ctrl[3],x[2]);
mux2 mux_1(in[1],in[9],ctrl[3],x[1]);
mux2 mux_0(in[0],in[8],ctrl[3],x[0]);
",,,,,
Verilog 2's complement adder/subtractor,"Design a four-bit adder/subtractor in Verilog and display it on a  seven-segment display.
The majority of my code is functioning however when I require a subtraction involving a negative it produces the wrong result.
For instance,
5 - 7 should result in 2 but I receive E
Below is my code:
module fullAdder (a0,a1,carry_in,s,carry_out);

    input a0,a1,carry_in;
    output s, carry_out;

    assign s = (a0 ^ a1) ^ carry_in;
    assign carry_out = (a0 &amp; a1 &amp; carry_in)|(a0 &amp; a1 &amp; ~carry_in)|(a0 &amp; ~a1 &amp; carry_in)|(~a0 &amp; a1 &amp; carry_in);

endmodule

module Lab3(a0,a1,s,cout);

    input s;
    input  [3:0] a0, a1;
    output [3:0] cout;
    
    wire c,d,e,f;
    wire input1, input2, input3, input4;
    
    xor(input1, s, a1[0]);
    xor(input2, s, a1[1]);
    xor(input3, s, a1[2]);
    xor(input4, s, a1[3]);
    
    //a0,a1,carry_in,s,carry_out    
    fullAdder fa0(a0[0],input1,s,cout[0],c);
    fullAdder fa1(a0[1],input2,c,cout[1],d);
    fullAdder fa2(a0[2],input3,d,cout[2],e);
    fullAdder fa3(a0[3],input4,e,cout[3],f);

endmodule 
","E is the correct result here, as it is -2 in 4 bit two's complement.
The trick to go from a negative two's complement value to positive, if you haven't covered it already, is to invert and add one.

E is 1110 in binary

1110 inverted is 0001

0001 plus 1 is 0010 (2)

",,,,,
How to truncate 16 bits to 8 bits VHDL?,"Hi I have the following code
 library ieee;
 use ieee.std_logic_1164.all;
 use ieee.numeric_std.all;
 entity mult is 
 PORT (in1, in2 : IN UNSIGNED (7 downto 0);
 product: OUT UNSIGNED (7 downto 0));
 end mult;
 Architecture behaviour of mult is 
 signal prod_sig: UNSIGNED (7 downto 0);
 begin

 product&lt;=in1*in2; --this cause an error because it needs to be truncated to its 8 bit equivalent 

 end behaviour;

Can someone help me understand how to truncate the product please","In VHDL, you work directly with bits, so there is no notion of &quot;truncate&quot; as in C.
Rather, just select the bits you want:
signal full_product: UNSIGNED (15 downto 0);

...
full_product &lt;= in1 * in2;
product &lt;= full_product (7 downto 0);
",,,,,
What is the correct syntax for assigning one value to multiple variables in Verilog?,"I am writing a 64-bit adder module, and my inputs are a,b,cin and my outputs are sum and carry.
I want to use a continuous assignment, and so I wrote assign sum = (a + b); before my end module.
In order to also assign this value to my carry, would assign sum,carry = (a + b);  be the correct syntax? I also saw online that it should include curly brackets  assign {sum, carry} = (a + b); but it was not explicitly stated.","It should include curly brackets.
{  ,  ,  }

This is the concatenation operator in Verilog. So,
assign {carry,sum} = (a + b);

Is what you want. (Note that in Verilog the LSB is always on the right hand side, so the carry needs to be on the left.)",,,,,
Why should add a name before the statement in VHDL?,"ARCHITECTURE synthesis1 OF vending IS
    TYPE statetype IS (Idle, Opt1, Opt2, Error);
SIGNAL currentstate, nextstate : statetype;
BEGIN
    fsm1: PROCESS( buttons, currentstate ) -- Is necessary to give the PROCESS bl a name?
    BEGIN
    -- Process the input
    END PROCESS; 
END synthesis1;

Is necessary to give the Process a name? Why should I set the name?","No. It is not necessary. It is optional. However, sometimes it is useful to give a process (or other statement) a name, for example, to make your code easier to read.",,,,,
Cross coverage inheriting iff clause of coverpoint,"I'm seeing an issue with one of my crosses inheriting the &quot;iff&quot; clause of one of it's constituent coverpoints.
covergroup cg @(LdReqVld_d1);
    LdReq_cp : coverpoint LdReqVld_d1 iff (!LdReqCancel);
    LdOp_cp  : coverpoint LdReqOp_d1  iff (LdReqVld_d1 &amp;&amp; !LdReqCancel);
    LdCancel_cp : coverpoint LdReqCancel;
    CrossCancel : cross LdOp_cp, LdCancel_cp;

I'm seeing the CrossCancel is never hitting any bin with LdReqCancel == 1 even when I expect it to, and I suspect it's because the LdOp_cp is crossed with contains the iff (LdReqVld_d1 &amp;&amp; !LdReqCancel), so the CrossCancel &quot;secretly&quot; has that iff guarding it too. Is this the expected behavior? And if so, how can I prevent this?","A cross is technically between bins of a coverpoint, not the coverpoint itself. From the IEEE 1800-2017 SystemVerilog LRM section 19.6 Defining cross coverage:

Cross coverage of a set of N coverage points is defined as the
coverage of all combinations of all bins associated with the N
coverage points

So if a coverpoint bin does not get sampled because of an iff guard, the cross bin is guarded as well.",,,,,
Can posedge in verilog be used only on clock?,"Can a posedge be detected on variables that aren't a clock?
For example I have a reset button R, which should reset the machine to the starting state whenever it is pressed.
always @ (posedge clk, posedge R)
    if(R)
      reset_the_machine();
    else
      use_the_next_state();
","You have two questions in your question:

can posegde in verilog be used only on clock?

The answer is no.

Can a posedge be detected on variables that aren't a clock?

The anser is yes.
There are no clocks in verilog language. Every signal is equal. Edges could be detected in simulation on any variable. Detection of edges itself is a simulation artifact.
Clock is only a modern hardware artifact. A verilog program reflects hardware behavior and therefore it needs to program clocks in a specific hardware-related way. But this is just a programming trick.
As for your example, see dave-59's answer.",,,,,
VHDL state machines and clock,"I have a general question about state machines used in VHDL. I heard that every state is processed in one clock cycle.
So lets say I have a state that needs more than one clock cycle to be finished. For example if I want to wait for a few seconds inside a state. Can this be done?
Or if I have a state in which I want to write to a blockram which needs 10 clock cycles (10 adresses) to be filled. Can this be done inside the case statements which are typically used for presenting state machines?","Usually in cases when you need to execute N repetitive actions in one state (like you described, waiting N ns, writting  to N addresses.) it is often used a counter in it. Hope the following example may clarify it a bit:
process(clk, rst)
begin
if (rst = '1') then
index &lt;= 0; -- memory address
current_s &lt;= write_memory ;
currentValue &lt;= (others =&gt; '0');
elsif rising_edge(clk) then
   case curresnt_s is 
   when write_memory =&gt;
      if index &lt; ADDRESS_SIZE then
        index &lt;= index + 1; 
        memory(index) &lt;= currentValue;
      else 
        curresnt_s  &lt;= done;
      end if;
   when done =&gt; null;
   end case;
end case;

In this code memory would be an array of std_logic_vector;
You could use the same idea to wait for 100ns.
if you know your clock runs at 10ns period, you could count to 10 in some state before changing to other.",,,,,
Signal assignment method,"I am new to VHDL and have had some difficulty in performing the assignment of two different values to the same signal inside a process. For example,
process(CLK)

 if rising_edge(CLK) then

   OUTPUT0 &lt;= X(0);
   OUTPUT1 &lt;= X(1);
   OUTPUT2 &lt;= X(2);

   LED0 &lt;= VALUE;

   OUTPUT0 &lt;= Y(0);
   OUTPUT1 &lt;= Y(1);
   OUTPUT2 &lt;= Y(2);

   LED1 &lt;= VALUE;

 end if;
end process;


Note that VALUE is an output dependent on the values assigned to OUTPUT0, OUTPUT1, OUTPUT2.
From what I understand in a process is that the last assignment to the same signal is always applied. What I am trying to do is apply two different sets of values to one set of inputs, map the output and it be done sequentially. I have tried separate processes tied to the same clock, a FSM to attempt to move sequentially and so on. At this point I have exhausted my knowledge of things to try.
My question is: What would be the best way to sequentially assign two values to one input and map its output in order?
EDIT:
As per Brian's suggestion on the state machine I had went ahead and implemented one again and found my error and fixed it. This gave the sequential assignment I was looking for.
I was reading 2 addresses from one instance of 32x1 distributed RAM which is the reason for a sequential assignment. Apologies for not providing the best example. Below is my final implementation:
RAM_READ_FSM : process(CLOCK) -- FSM to read the RAM addresses sequentially

    begin

        if rising_edge(CLOCK) then
        
            case curr_state is
            
             when S0 =&gt; if SW2 = '1' then
             
            RAMADDR0 &lt;= XYVEC(5); -- Y addresses
            RAMADDR1 &lt;= XYVEC(6);
            RAMADDR2 &lt;= XYVEC(7);
            RAMADDR3 &lt;= XYVEC(8);
            RAMADDR4 &lt;= XYVEC(9);
            
            LED1 &lt;= RAMOUT;
            
            curr_state &lt;= S1;

         else
         
         curr_state &lt;= S0;
         
            end if;
            
             when S1 =&gt; if SW2 = '1' then
                        
            RAMADDR0 &lt;= XYVEC(0); -- X addresses
            RAMADDR1 &lt;= XYVEC(1);
            RAMADDR2 &lt;= XYVEC(2);
            RAMADDR3 &lt;= XYVEC(3);
            RAMADDR4 &lt;= XYVEC(4);
            
            LED2 &lt;= RAMOUT;
            
            curr_state &lt;= S0;
            
            else
            
            curr_state &lt;= S1;
            
            end if;
        end case;
    end if;
end process;
","
The signals should be driven from the same process : multiple drivers would interfere with each other..

See Is process in VHDL reentrant? on signal assignment semantics.

now you can see there is need for some delay (even just 2 delta cycles, if the logic calculating VALUE is just a simple signal assignment) between the X and LED0 assignments.

You were on the right lines with a state machine but you didn't say anything about how it failed. Worth adding that to the Q to get a fuller answer.

Meanwhile there is a simple way to add delay :


like
LEDS : process is
begin

   wait until rising_edge(CLK);
   OUTPUT0 &lt;= X(0);
   OUTPUT1 &lt;= X(1);
   OUTPUT2 &lt;= X(2);
    
   wait until rising_edge(CLK);
   LED0 &lt;= VALUE;
  
   wait until rising_edge(CLK);
   OUTPUT0 &lt;= Y(0);
   -- etc
end process LEDS;
",,,,,
Make two 8 bits signal join eachother to a 16 bit signal in VHLD,"I have a problem with combininig 2 signals. RS232 sends me a number 4 (8 bit) en then 5 (8 bit), togehter it is the number 45. My questions is how can I combine these number 4 and 5 to a 16 bit signal with the number 45 in vhdl? Also I have tried to count the two 8 bits signal and resized it but then i get a 16 bit signal with the number 9.","Something like the state machine bellow may help you if the idea is to gather both numbers in a single signal.
process(clk, rst)
begin 
if (rst = '1') then
     current_state &lt;= FIRST_N;
     this_register &lt;= (others =&gt; '0');
elsif rising_edge(clk) then
    case current_state  is 
    when FIRST_N =&gt; 
        this_register   &lt;= RS232_input * 10; 
        current_state   &lt;= SECOND_N;
    when FIRST_N =&gt; 
        this_register   &lt;= RS232_input + this_register; 
        current_state   &lt;= FIRST_N ;                   
     end case;
end if;   
end process;

Would something like this solve your problem?",,,,,
Is a struct packed allowed to be used in ports?,"Most of the tools I use allow it but one doesn't. I've read the specs, IEEE1800-2017 I couldn't find it.
module mymod (
  input   logic           clk,
  input   logic           reset,
  input   struct packed {  
                            logic [1:0]  var0;
                            logic [1:0]  var1;
                            logic [8:0]  var2;
                        } addr,

...

I saw some examples here and there, using even typedef structures in ports.

Is it allowed by the specs? Where?

Cf. 7.2 Structures and 7.2.1 Packed structures","A port can be any data type. (section 23.2.2) There are some restrictions on whether that datatype can be represented by a variable or net signal that interact with the port direction.
But I would strongly discourage the use of an anonymous type (struct in your example) and instead declare a user defined type with a typedef in a common package and use that typedef when declaring that port. That eliminates type compatibility issues when trying to connect unpacked struct and enums.",,,,,
Process sensitivity list vhdl,"I have the following problem:
I have a simple entity driven by a single process:
LIBRARY IEEE;
USE ieee.std_logic_1164.ALL;            
USE ieee.std_logic_unsigned.ALL;        
USE ieee.std_logic_arith.ALL;

entity somma_CDC is
                Port 
                    (
                    
                        A                       : in    std_logic;                                  
                        B                       : in    std_logic;                                  
                        Reset                   : in    std_logic;                                  
                        Internal_Carry_enable   : in    std_logic;                                  
                        S                       : out   std_logic                                   
                    
                    );
end somma_CDC;

architecture Behavioral_somma_CDC of somma_CDC is

signal Internal_Carry: std_logic;

begin
    somma_CDC:process (Reset,A,B) 
                    begin
                    
                        if Reset = '1' 
                            then
                                Internal_Carry &lt;= '0';
                                
                        else 
                                S &lt;= A XOR B XOR Internal_Carry ;
                                if (Internal_Carry_enable = '1')
                                    then
                                    Internal_Carry &lt;= (A AND B) OR (Internal_Carry AND A) OR (Internal_Carry AND B) ;
                                end if;
                        end if;
                        
                    end process;
end architecture;
                    

In practice, it is very similar to a full adder.
Ideally, the block diagram should look like this:

My problem arises when in the cycles following the first, I find the values of the operands equal. In this case, the process does not activate and therefore fails to calculate the case in which
A = 1, B = 1, Carry_In = 1.
There is a clock signal in my system, but the clock goes faster than the input data change. If I put the clock in the sensitivity list I get wrong results, as the carry &quot;propagates&quot; in the wrong way.
I tried without using the sensitivity list and putting a wait for &quot;X&quot; time, with &quot;X&quot; the minimum time for changing operands A and B. It works, but it depends on something that can always change in a project.
Is there another way to activate this process?","TL;DR:
Add Internal_Carry to your sensitivity list.
Edit: As @Tricky pointed out, Internal_Carry_enable should be in the sensitivity list as well.
Full Answer:
I think the problem here is that you may miss understood how to use the sensitivity list. You are using it as C like programming, where the process would be reading reset, A and B as inputs.
But in vhdl every signal in the sensitivity list is a trigger that must change its value in order for the process to be rerun again.
So, the main problem here is the signal Internal_Carry. Since it is not in the sensitivity list, the signal S wont respond as Internal_Carry change to a new value after the first run. You would need to change either reset, A or B to see the effects of Internal_Carry from the last run.
There are other problems in your code, but not related to this.

Internal_Carry is a latch since you didnt assign any default value to it (which value should it holds if reset is not 0 and Internal_Carry_enable is not 1?).

You may need to take a look in the differences between combinational and sequential logic, since you wrote about clock in an adder circuit. If you add a clock the assignment of a value to a signal will generate a register, while a process without a clock in its sensitivity list will be purely combinational.

",,,,,
Best way to instantiate grid of processing elements in Verilog / SystemVerilog?,"I have a ProcessingElement.sv module, and I would like to instantiate a configurable array of them, so I was thinking to create a generate block like so:
module ProcessingArray #(parameter Y=14, X=14, W=16) (  
    input                   GlobalClk,
    input           [3:0]   OpCode,
    input           [W-1:0] DataIn,
    output logic    [W-1:0] DataOut 
    );

    

    genvar x, y;
    generate
        for (y=0; y&lt;=Y; y++) begin 
            for (x=0; x&lt;X; x++) begin
                ProcessingElement #(.W(16)) PE(
                    .Clk(GlobalClk),
                    .OpCode(OpCode),
                    .Input(DataIn),
                    .Output(DataOut)
                );
            end
        end
    endgenerate


endmodule

This seems to compile fine using Modelsim, but I'm having issues finding a smooth way to connect the array elements to one another. Generally, the connections are if x &gt; y, the elements will be connected horizontally; if y &gt; x, vertically; if x == y, both AND diagonally.
Here's an example of how the upper left 3x3 grid would be connected:
[Connections][1]
Is there a way to reference (eg. by naming the instances) each of the generated instances in the loops? If there were, maybe I could make another generate statement that performed all of the assigns.
I am relatively new to Verilog / SV, so if there is a better way to do this, I am happy to be enlightened
Edit:
Here is an example unrolled
module ProcessingArray #(parameter Y=14, X=14, W=16) (  
    input                   GlobalClk,
    input           [3:0]   OpCode,
    input           [W-1:0] DataIn,
    output logic    [W-1:0] DataOut 
    );

ProcessingElement #(.W(16)) PE_00(
    .Clk(GlobalClk),
    .OpCode(OpCode),
    .Input(DataIn),
    .Output(DataOut_00)
);

// For readability
wire wire00_01 = DataOut_00;
wire wire00_10 = DataOut_00;
wire wire00_11 = DataOut_00;

ProcessingElement #(.W(16)) PE_01(
    .Clk(GlobalClk),
    .OpCode(OpCode),
    .Input(wire00_01),
    .Output(DataOut_01)
);

wire wire01_02 = DataOut_01;

ProcessingElement #(.W(16)) PE_02(
    .Clk(GlobalClk),
    .OpCode(OpCode),
    .Input(wire01_02),
    .Output(wire02_elsewhere)
);

ProcessingElement #(.W(16)) PE_10(
    .Clk(GlobalClk),
    .OpCode(OpCode),
    .Input(wire00_10),
    .Output(DataOut_10)
);

wire wire10_20 = DataOut_10;

ProcessingElement #(.W(16)) PE_11(
    .Clk(GlobalClk),
    .OpCode(OpCode),
    .Input(wire00_11),
    .Output(DataOut_11)
);

wire wire11_12 = DataOut_11;
wire wire11_21 = DataOut_11;
wire wire11_22 = DataOut_11;

ProcessingElement #(.W(16)) PE_12(
    .Clk(GlobalClk),
    .OpCode(OpCode),
    .Input(wire11_12), 
    .Output(DataOut_12)
);

ProcessingElement #(.W(16)) PE_20(
    .Clk(GlobalClk),
    .OpCode(OpCode),
    .Input(DataIn), 
    .Output(DataOut_20)
);

ProcessingElement #(.W(16)) PE_21(
    .Clk(GlobalClk),
    .OpCode(OpCode),
    .Input(wire11_21), 
    .Output(DataOut_21)
);

ProcessingElement #(.W(16)) PE_22(
    .Clk(GlobalClk),
    .OpCode(OpCode),
    .Input(wire11_22), 
    .Output(DataOut)
);

endmodule
","What you can do is create a 2-D array of wires, and make conditional connections inside the generate loop. Here's what a complete example looks like:
module ProcessingArray #(parameter Y=14, X=14, W=16) (  
    input                   GlobalClk,
    input           [3:0]   OpCode,
    input           [W-1:0] DataIn,
    output logic    [W-1:0] DataOut 
    );
  // internal connections
  wire [W-1:0] ConnIn[Y][X];
  wire [W-1:0] ConnOut[Y][X];
  // entry and exit connections
  assign ConnIn[0][0] = DataIn;
  assign DataOut = ConnOut[Y-1][X-1];

  for (genvar y=0; y&lt;Y; y++) begin : row
    for (genvar x=0; x&lt;X; x++) begin  :col
      ProcessingElement #(.W(16)) PE(
        .Clk(GlobalClk),
        .OpCode(OpCode),
        .Input(ConnIn[y][x]),
        .Output(ConnOut[y][x])
      );
      if (y&lt;=x &amp;&amp; x&gt;0) assign ConnIn[y][x] = ConnOut[y][x-1]; // horizontal 
      if (x&lt;=y &amp;&amp; y&gt;0) assign ConnIn[y][x] = ConnOut[y-1][x]; // vertical 
    end
  end

endmodule

module ProcessingElement #(int W) (
  input Clk,
  input           [3:0]   OpCode,
  input           [W-1:0] Input,
  output logic    [W-1:0] Output
);
  assign Output=Input+1;  // trace connectivity
  initial #1 $display(&quot;PE %m %d&quot;,Input);
endmodule

module tb;
  logic [15:0] in,out;
  logic [3:0] op;
  
  ProcessingArray PE(clk,op,in,out);
  
  initial begin
    in = 1;
    #1 $display(out);
  end
endmodule
",,,,,
How to implement HDMI pass-through on XILINX FPGA (Artix-7),"I want to implement my own HDMI-Passthrough on Nexys-Video Board equipped with Artix-7 FPGA and HDMI sink/source ports. My setup is: A PC HDMI port is connected to the sink port while an LED monitor is connected to the source HDMI port.
Since there is no TDMS encoder/decoder on the board, I will also need to implement them next (I don't want to just grab one of the closed source implementations readily available on the internet). But for now, I just need to connect sink/source ports over the FPGA so I can get the video shown on the monitor. However, I could not succeed yet. No picture is shown and the monitor says 'No Signal'. I am a little bit worried about mis-using FGPA ports which could result in permanent damage to the board. Therefore, I did not try everything came to my mind. I am expecting advices to correct/complete my code.
I connected HDMI signals as in the following code and schematic:
module HDMI_Top(RSTN, CLK, BTN, SW, LED,
            HDMIR_TXEN, HDMIR_HPA, HDMIT_HPD, 
            HDMIR_SCL, HDMIR_SDA, HDMIT_SCL, HDMIT_SDA,
            HDMIR_CLK_P, HDMIR_CLK_N, HDMIR_DATA_P, HDMIR_DATA_N,
            HDMIT_CLK_P, HDMIT_CLK_N, HDMIT_DATA_P, HDMIT_DATA_N);

input RSTN;
input CLK;
input [4:0] BTN;
input [7:0] SW;
output [7:0] LED;

output HDMIR_TXEN;
output HDMIR_HPA;
input HDMIT_HPD;
inout HDMIR_SCL;
inout HDMIR_SDA;
inout HDMIT_SCL;
inout HDMIT_SDA;

input HDMIR_CLK_P;
input HDMIR_CLK_N;
input [2:0] HDMIR_DATA_P;
input [2:0] HDMIR_DATA_N;
output HDMIT_CLK_P;
output HDMIT_CLK_N;
output [2:0] HDMIT_DATA_P;
output [2:0] HDMIT_DATA_N;

wire [2:0] HDMI_DATA;
wire HDMI_CLK;
wire w0, w1, w2;

assign LED = SW;
//assign HDMIR_HPA = HDMIT_HPD;
assign HDMIR_TXEN = 1'b1;
assign HDMIT_SCL = HDMIR_SCL;
assign HDMIT_SDA = HDMIR_SDA;

// IBUFDS: Differential Input Buffer
IBUFDS #(
    .DIFF_TERM(&quot;FALSE&quot;), // Differential Termination
    .IOSTANDARD(&quot;DEFAULT&quot;) // Specify the input I/O standard
) IBUFDS_hdmir_clk (
    .O(HDMI_CLK), // Buffer output
    .I(HDMIR_CLK_P), // Diff_p buffer input (connect directly to top-level port)
    .IB(HDMIR_CLK_N) // Diff_n buffer input (connect directly to top-level port)
);

OBUFDS #(
    .IOSTANDARD(&quot;DEFAULT&quot;) // Specify the output I/O standard
) OBUFDS_hdmit_clk (
    .O(HDMIT_CLK_P), // Diff_p output (connect directly to top-level port)
    .OB(HDMIT_CLK_N), // Diff_n output (connect directly to top-level port)
    .I(HDMI_CLK) // Buffer input
);

// IBUFDS: Differential Input Buffer
IBUFDS #(
    .DIFF_TERM(&quot;FALSE&quot;), // Differential Termination
    .IOSTANDARD(&quot;DEFAULT&quot;) // Specify the input I/O standard
) IBUFDS_hdmir_data [2:0] (
    .O(HDMI_DATA), // Buffer output
    .I(HDMIR_DATA_P), // Diff_p buffer input (connect directly to top-level port)
    .IB(HDMIR_DATA_N) // Diff_n buffer input (connect directly to top-level port)
);

OBUFDS #(
    .IOSTANDARD(&quot;DEFAULT&quot;) // Specify the output I/O standard
) OBUFDS_hdmit_data [2:0] (
    .O(HDMIT_DATA_P), // Diff_p output (connect directly to top-level port)
    .OB(HDMIT_DATA_N), // Diff_n output (connect directly to top-level port)
    .I(HDMI_DATA) // Buffer input
);endmodule

Here is the schematic corresponding to the code.
Thanks;","I got it working finally. Now my Nexys Video card passes through a Full HD video. Here are the details:

Both HPA and TXEN pins must be set to '1'. In my case I assigned HPD pin of the source port to the HPA pin of the sink port. Checking the board schematic, the HPD pin is tied to an open drain MOSFET, so it must be inverted before the assignment.

assign HDMIR_HPA = ~HDMIT_HPD;

Additionally, after a thorough googling, I found that bridging DDC SCL and SDA pins of sink port to source port seems to be impossible as two bidirectional pins cannot be (simply) wired on FPGAs. So the solution to the problem is adding an EDID ROM emulator to the sink side. Then the FPGA itself behaves as a monitor to the video source device (i.e. the PC in my setup).

I found a VHDL implementation of EDID ROM from here. It emulates a 1024 x 768 monitor, however I changed it to 1920 x 1080.
This is the revised code for the top module:
module HDMI_Top(
input RSTN,
input CLK,
input [4:0] BTN,
input [7:0] SW,
output [7:0] LED,
output HDMIR_TXEN,
output HDMIR_HPA,
input HDMIT_HPD, 
input HDMIR_SCL,
inout HDMIR_SDA,
output HDMIT_SCL,
inout HDMIT_SDA,
input HDMIR_CLK_P,
input HDMIR_CLK_N,
input [2:0] HDMIR_DATA_P,
input [2:0] HDMIR_DATA_N,
output HDMIT_CLK_P,
output HDMIT_CLK_N,
output [2:0] HDMIT_DATA_P,
output [2:0] HDMIT_DATA_N
);

wire HDMI_CLK;
wire [2:0] HDMI_DATA;

assign LED = SW;

// Whenever a sink is ready and wishes to announce its presence, it connects the 5V0 supply pin to the HPD pin. On
// the Nexys Video, this is done by driving the HPA (Hot Plug Assert) signal high. Note: this should only be done
// after a DDC channel slave has been implemented in the FPGA and is ready to transmit display data.
// FPGA lets the HDMI source (e.g., a PC) connected to its sink port know its presence by setting HPA signal to '1'.
// A monitor connected to the source port sets HPD signal to '0'.
// assign HDMIR_HPA = 1'b1;
assign HDMIR_HPA = ~HDMIT_HPD;

// A pull-down resistor on the TXEN signal makes sure the sink buffer's transmitter facing the FPGA is disabled by default.
// An FPGA design using the sink port needs to actively drive this pin high for the buffer to pass data through.
assign HDMIR_TXEN = 1'b1;

// The Display Data Channel, or DDC, is a collection of protocols that enable communication between the display
// (sink) and graphics adapter (source). The DDC2B variant is based on I2C, the bus master being the source and the
// bus slave the sink. When a source detects high level on the HPD pin, it queries the sink over the DDC bus for video
// capabilities. It determines whether the sink is DVI or HDMI-capable and what resolutions are supported. Only
// afterwards will video transmission begin. Refer to VESA E-DDC specifications for more information.
edid_rom edid_rom_rx0 (.clk(CLK), .sclk_raw(HDMIR_SCL), .sdat_raw(HDMIR_SDA));
    
// IBUFDS: Differential Input Buffer
IBUFDS #(
    .DIFF_TERM(&quot;FALSE&quot;), // Differential Termination
    .IOSTANDARD(&quot;DEFAULT&quot;) // Specify the input I/O standard
) IBUFDS_hdmir_clk (
    .O(HDMI_CLK), // Buffer output
    .I(HDMIR_CLK_P), // Diff_p buffer input (connect directly to top-level port)
    .IB(HDMIR_CLK_N) // Diff_n buffer input (connect directly to top-level port)
);

OBUFDS #(
    .IOSTANDARD(&quot;DEFAULT&quot;) // Specify the output I/O standard
) OBUFDS_hdmit_clk (
    .O(HDMIT_CLK_P), // Diff_p output (connect directly to top-level port)
    .OB(HDMIT_CLK_N), // Diff_n output (connect directly to top-level port)
    .I(HDMI_CLK) // Buffer input
);

// IBUFDS: Differential Input Buffer
IBUFDS #(
    .DIFF_TERM(&quot;FALSE&quot;), // Differential Termination
    .IOSTANDARD(&quot;DEFAULT&quot;) // Specify the input I/O standard
) IBUFDS_hdmir_data [2:0] (
    .O(HDMI_DATA), // Buffer output
    .I(HDMIR_DATA_P), // Diff_p buffer input (connect directly to top-level port)
    .IB(HDMIR_DATA_N) // Diff_n buffer input (connect directly to top-level port)
);

OBUFDS #(
    .IOSTANDARD(&quot;DEFAULT&quot;) // Specify the output I/O standard
) OBUFDS_hdmit_data [2:0] (
    .O(HDMIT_DATA_P), // Diff_p output (connect directly to top-level port)
    .OB(HDMIT_DATA_N), // Diff_n output (connect directly to top-level port)
    .I(HDMI_DATA) // Buffer input
); endmodule

You can find the whole source code here.
My next step is adding serializer/deserializer and tmds encoder/decoder to the project. For those who may wish to do the same thing, here is the most recent version of my (working) source code including serializer/deserializer and tmds encoder/decoder.",,,,,
How to compile a file with compiler directives (`ifdef) and different `define's?,"I have two files, file a and file b. File a has compile directives based on whether or not 'b' is defined.
The code in a.sv is as follows:
module a_module()
    initial begin
`ifdef b
            $display(&quot;This is compiled in file b&quot;);
`else
            $display(&quot;This is compiled in file a&quot;);
`endif
    end
endmodule: a_module()

The code in b.sv is as follows:
`define b 1
`include a.sv

module b_module()

    a_module a_module();

endmodule: b_module()

Despite defining 'b' before importing file a, running both files will output &quot;This is compiled in file a&quot;.
Why is this? How do I structure my code so that a.sv will be independently compiled both times?","Verilog is different from 'c' in compilation processing. In 'c' every source file is a compilation unit and is self-contained. All macro definition are contained within it.
In verilog all declarations of macros (and all declarations in system verilog global scope) are sticky. This means that macro definitions in one source file are also seen in other source files which follow the one with declarations.
So, in verilog if you want to include the same file with different macro definitions, you would need to employ `define and `undef directives, for example,
`define b
`include &quot;a.sv&quot;
...
`undef b
`include &quot;a.sv&quot;

However,  just a note of caution. In real projects this type of inclusions is a source of many errors, incorrect compilations and debugging problems. I suggest that you avoid using it.",,,,,
VHDL Vivado's behavioral simulation returns unknown (red X) over output assignment operation,"I have written this simple process. It's supposed to accumulate ((b-a)/n)*yi terms, where yi is an input that is updated per every clock cycle, and then output the result of the sum.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all; 
entity Integrator is
    Port ( a : in STD_LOGIC_VECTOR(7 downto 0);
           b : in STD_LOGIC_VECTOR(7 downto 0);
           n : in STD_LOGIC_VECTOR(7 downto 0);
           yi : in STD_LOGIC_VECTOR (15 downto 0);
           start : in std_logic;
           clk : in std_logic;
           output : out signed (15 downto 0);
           done : out STD_LOGIC);
end Integrator;

architecture Integrator_arch of Integrator is
signal do : std_logic;
signal i : unsigned(7 downto 0);
signal tmp1, tmp2, tmp3, res : signed(15 downto 0);
begin
    process(clk)
    begin
        if(clk'event and clk='1') then
            if(start='1') then
                do &lt;= '1';
                i &lt;= (others=&gt;'0');
                done &lt;= '0';
                res &lt;= (others=&gt;'0');
            elsif(do='1' and done='0') then   
                if(i=unsigned(n)) then
                    output &lt;= res;
                    do &lt;= '0';
                    done &lt;= '1';
                else                    
                    tmp1 &lt;= resize(signed(b)-signed(a),16);
                    tmp2 &lt;= resize(tmp1/signed(n),16);
                    tmp3 &lt;= resize(tmp2*signed(yi),16);
                    res &lt;= res + tmp3;
                    i &lt;= i+1;
                end if;
            end if;  
        end if;         
    end process;
end Integrator_arch;

And this is the testbench:
architecture Behavioral of Integrator_Testbench is
signal start : std_logic;
signal clk, done : std_logic;
signal yi : std_logic_vector(15 downto 0);
signal O : signed(15 downto 0);
begin
    uut: entity work.integrator(integrator_arch)
            port map(a=&gt;&quot;11111110&quot;, b=&gt;&quot;00000010&quot;, n=&gt;&quot;00000100&quot;, yi=&gt;yi
                ,start=&gt;start, clk=&gt;clk, done=&gt;done, output=&gt;O);
    process
    begin
        clk&lt;='0';
        start&lt;='1';
        wait for 200ns;
        
        clk&lt;='1';
        wait for 200ns;
        
        start&lt;='0';
        clk&lt;='0';
        yi&lt;=x&quot;0003&quot;;
        wait for 200ns;
        
        clk&lt;='1';
        yi&lt;=x&quot;0003&quot;;
        wait for 200ns;
        
        clk&lt;='0';
        yi&lt;=x&quot;0001&quot;;
        wait for 200ns;
        
        clk&lt;='1';
        yi&lt;=x&quot;0001&quot;;
        wait for 200ns;
        
        clk&lt;='0';
        yi&lt;=x&quot;0000&quot;;
        wait for 200ns;
        
        clk&lt;='1';
        yi&lt;=x&quot;0000&quot;;
        wait for 200ns;
        
        clk&lt;='0';
        yi&lt;=x&quot;0002&quot;;
        wait for 200ns;
        
        clk&lt;='1';
        yi&lt;=x&quot;0002&quot;;
        wait for 200ns;
        
        clk&lt;='0';
        yi&lt;=x&quot;0000&quot;;
        wait for 200ns;
        
        clk&lt;='1';
        yi&lt;=x&quot;0000&quot;;
        wait for 200ns;
        
        clk&lt;='0';
        yi&lt;=x&quot;0000&quot;;
        wait for 200ns;
        
        clk&lt;='1';
        yi&lt;=x&quot;0000&quot;;
        wait for 200ns;
    end process;
end Behavioral;

But here's the problem, the output is always reported as unknown (red Xs) when I run a behavioral simulation. What's more weird is that it runs completely fine in a debug session, and by running a line-by-line debug session I was able to get the correct output, which is x&quot;0006&quot;!!!

After two hours of attempting to find the issue, I finally decided to ask. Specially since it runs completely fine and outputs the correct result in a line-by-line debug so I have no idea why the simulation keeps acting out.
Thanks a lot for your time.","Found my own answer by more trial and error
It seems that the result of one line of numeric_std expression takes one clock cycle to settle down, so when I tried to make it more readable by writing
tmp1 &lt;= resize(signed(b)-signed(a),16);
tmp2 &lt;= resize(tmp1/signed(n),16);
tmp3 &lt;= resize(tmp2*signed(yi),16);
res &lt;= res + tmp3;

It took 4 clock cycles to settle down and before these 4 clock cycles are done, the port is set to unknown.
So I shortened all of those lines into one line
res &lt;= res + resize((resize(b-a,16)/signed(n))*yi,16);

And now the result is ready for me in 1 clock cycle just as it should be.",,,,,
Can bazel package depend on a source file in another package,"A few years ago I wrote a set of wrappers for Bazel that enabled me to use it to build FPGA code. The FPGA bit is only relevant because the full clean build takes many CPU days so I really care about caching and minimizing rebuilds.
Using Bazel v0.28 I never found a way to have my Bazel package depend on a single source file from somewhere else in the git repo. It felt like this wasn't something Bazel was designed for.
We want to do this because we have a library of VHDL source files that are parameterized and the parameters are set in the instantiating VHDL source. (VHDL generics). If we declare this library as a Bazel package in its own right then a change to one library file would rebuild everything (at huge time cost) when in practice only a couple of steps might need to be rebuilt.
I worked around this with a python script to copy all the individual source files into a subdirectory and then generate the BUILD file to reference these copies. The resulting build process is:

call python preparation script
bazel build //:allfpgas
call python result extractor

This is clearly quite ugly but the benefits were huge so we live with it.
Now we want to leverage Bazel to build our Java, C++ etc so I wanted to revisit and try and make everything work with Bazel alone.
In the latest Bazel is there a way to have a BUILD package depend on individual source files outside of the package directory? If Bazel cant, would buck pants or please.build work better for our use case?","The Bazel rules for most languages support doing something like this already. For example, the Python rules bundle source files from multiple packages together, and the C++ rules manage include files from other packages. Somehow the rule has to pass the source files around in providers, so that another rule can generate actions which use them. Hard to be more specific without knowing which rules you're using.
If you just want to copy the files, you can do that in bazel with a genrule. In the package with the source file:
exports_files([&quot;templated1.vhd&quot;, &quot;templated2.vhd&quot;])

In the package that uses it:
genrule(
    name = &quot;copy_templates&quot;,
    srcs = [&quot;//somewhere:templated1.vhd&quot;, &quot;//somewhere:templated2.vhd&quot;],
    outs = [&quot;templated1.vhd&quot;, &quot;templated2.vhd&quot;],
    cmd = &quot;cp $(SRCS) $(RULEDIR)&quot;,
)

some_library(
    srcs = [&quot;templated1.vhd&quot;, &quot;templated2.vhd&quot;, &quot;other.vhd&quot;],
)

If you want to deduplicate that across multiple packages that use it, put the filenames in a list and write a macro to create the genrule.",,,,,
"Verilog Error: ""Syntax in assignment statement l-value."" when writing a simple alu","I am having trouble finding the syntax error in this code of a simple simulator of MIPS alu functions. The error appears in the else of the case 6'b001000: // addi:

ALU_.v:112: syntax error
ALU_.v:113: Syntax in assignment statement l-value.

And here is my code:
module alu(instruction, regA, regB, result, flags);

input[31:0] instruction, regA, regB; 
output[31:0] result;
output[2:0] flags; 

reg[5:0] opcode, func;
reg[4:0] rs, rt;
reg[15:0] immidiate;
reg[31:0] signeximm, zeroeximm;
reg[31:0] regC;
reg[2:0] flagout;

assign result = regC[31:0];
assign flags = flagout[2:0];

always @(instruction,regA,regB)
begin
    opcode = instruction[31:26];
    rs = instruction[25:21];
    rt = instruction[20:16];
    func = instruction[5:0];
    immidiate = instruction[15:0];
    signeximm = {{16{immidiate[15]}},immidiate};
    zeroeximm = {{16{1'b0}},immidiate};
    case(opcode)
        6'b000000: // R-type
            case(func)
                6'b100000: // add
                    begin
                        regC = $signed(regA) + $signed(regB);
                        flagout[2] = ((~regA[31])&amp;(~regB[31])&amp;regC[31])|(regA[31]&amp;regB[31]&amp;(~regC[31]));
                    end
                6'b100001: // addu
                    begin
                        regC = regA + regB;
                    end
                6'b100100: // and
                    begin
                        regC = regA &amp; regB;
                    end                
                6'b100111: // nor
                    begin
                        regC = regA ~| regB;
                    end
                6'b100101: // or
                    begin
                        regC = regA | regB;
                    end
                6'b000000: // sll
                    begin
                        if(rt) regC = regB &lt;&lt; instruction[10:6];
                        else regC = regA &lt;&lt; instruction[10:6];
                    end
                6'b000100: // sllv
                    begin
                        if(rt) regC = regB &lt;&lt; regA;
                        else regC = regA &lt;&lt; regB;
                    end
                6'b101010: // slt
                    begin
                        if(rt) regC = ($signed(regA) &lt; $signed(regB));
                        else regC = ($signed(regB) &lt; $signed(regA));
                        flagout[1] = regC[0];
                    end
                6'b101011: // sltu
                    begin
                        if(rt) regC = (regA &lt; regB);
                        else regC = (regB &lt; regA);
                        flagout[1] = regC[0];
                    end
                6'b000011: // sra
                    begin
                        if(rt) regC = regB &gt;&gt;&gt; instruction[10:6];
                        else regC = regA &gt;&gt;&gt; instruction[10:6];
                    end
                6'b000111: // srav
                    begin
                        if(rt) regC = regB &gt;&gt;&gt; regA;
                        else regC = regA &gt;&gt;&gt; regB;
                    end
                6'b000010: // srl
                    begin
                        if(rt) regC = regB &gt;&gt; instruction[10:6];
                        else regC = regA &gt;&gt; instruction[10:6];
                    end
                6'b000110: // srlv
                    begin
                        if(rt) regC = regB &gt;&gt; regA;
                        else regC = regA &gt;&gt; regB;
                    end
                6'b100010: // sub
                    begin
                        if(rt) regC = $signed(regA) - $signed(regB);
                        else regC = $signed(regB) - $signed(regA);
                    end
                6'b100011: // subu
                    begin
                        if(rt) regC = regA - regB;
                        else regC = regB - regA;
                    end
                6'b100110: // xor
                    begin
                        regC = regA ^ regB;
                    end
            endcase
        6'b001000: // addi
            begin
                if(rt) 
                regC = $signed(regA) + $signed(signeximm);
                flagout[2] = ((~regA[31])&amp;(~signeximm[31])&amp;regC[31])|(regA[31]&amp;signeximm[31]&amp;(~regC[31]));
                else 
                regC = $signed(regB) + $signed(signeximm);
                flagout[2] = ((~regB[31])&amp;(~signeximm[31])&amp;regC[31])|(regB[31]&amp;signeximm[31]&amp;(~regC[31]));
            end
        6'b001001: // addiu
            begin
                if(rt) regC = regA + signeximm;
                else regC = regB + signeximm;
            end
        6'b001100: // andi
            begin
                if(rt) regC = regA &amp; zeroeximm;
                else regC = regB &amp; zeroeximm;
            end
        6'b000100: // beq
            begin
                regC = signeximm &lt;&lt; 2;
                flagout[0] = (regA == regB);
            end
        6'b000101: // bne
            begin
                regC = signeximm &lt;&lt; 2;
                flagout[0] = (regA != regB);
            end
        6'b100011: // lw
            begin
                if(rt) regC = regA + immidiate;
                else regC = regB + immidiate;
            end
        6'b001101: // ori
            begin
                if(rt) regC = regA | zeroeximm;
                else regC = regB | zeroeximm;
            end
        6'b001010: // slti
            begin
                if(rt) regC = $signed(regA) &lt; $signed(signeximm);
                else regC = $signed(regB) &lt; $signed(signeximm);
                flagout[1] = regC[0];
            end
        6'b001011: // sltiu
            begin
                if(rt) regC = regA &lt; signeximm;
                else regC = regB &lt; signeximm;
                flagout[1] = regC[0];
            end
        6'b101011: // sw
            begin
                if(rt) regC = regA + immidiate;
                else regC = regB + immidiate;
            end
        6'b001110: // xori
            begin
                if(rt) regC = regA ^ zeroeximm;
                else regC = regB ^ zeroeximm;
            end
        default:
            begin
                regC = 32'bx;
                flagout = 3'bx;
            end
    endcase
end

endmodule

This error appears on the process of compiling so I haven't got a chance to check if there's any other problem in current code.","There are two coding errors:
Fix them this way

This was a bad nor expression
regC = ~(regA | regB) ;

Was missing begin/end pairs


Like this
if(rt)
  begin
  regC = $signed(regA) + $signed(signeximm);
  flagout[2] = ((~regA[31])&amp;(~signeximm[31])&amp;regC[31])|(regA[31]&amp;signeximm[31]&amp;(~regC[31]));
  end
 else
 begin
   regC = $signed(regB) + $signed(signeximm);
   flagout[2] = ((~regB[31])&amp;(~signeximm[31])&amp;regC[31])|(regB[31]&amp;signeximm[31]&amp;(~regC[31]));
 end
",,,,,
"OpenCL FPGA: Kernel Execution of 2 copies of same kernel is not being made in parallel. In addition to that, there is also idle time in between them","My goal is to complete FFTs of 2 - 4K Data points together. Hence, I made 2 kernel objects from the same kernel and Enqueued the tasks at once, i.e. without any Buffer Read-Write or any callbacks in between. I find out that it doesn't happen that way. In addition to that, there is also some idle time between the executions. Can someone please  explain?

I was expecting both of them to run in parallel because my FPGA seems to have more area. About 38 percent of it is used.",I found this question that kind off answers my doubts. It can be foundhere,,,,,
(VERI-1322) prefix of assignment pattern must be a data type,"Here is a snippet from my code;
always_ff @(posedge clk) begin : output_assigment // left side should only be &quot;_q&quot;
    if(reset_n == 1'b0 || clear == 1'b1) out_signal_q &lt;= {8'{!(REPORT_POL)}}; 

But i see this error:   (VERI-1322) prefix of assignment pattern must be a data type
How can this be corrected for the assignment &quot;out_signal_q &lt;= {8'{!(REPORT_POL)}}&quot;
Can you please help ?
end","It always helps to show declarations of all signals involved in the expression. I have to assume that REPORT_POL is a single bit and you want it replicated 8 times to assigned to out_signal_q. In that case you want to remove the ' and just write
out_signal_q &lt;= {8{!REPORT_POL}};
",,,,,
modelsim simulation time cycles appear to be different than test_bench,"i have a testbench which states at the top:
'timescale 1 ns/ 1 ps

a clock which is defined as:
code in testbench
always begin
   #5 sys_clk = ~sys_clk;
   #20 clk_in = ~clk_in;
   #8 clk_acq = ~clk_asq;
end

run the simulation using a do file:
vsim in do file
but the clock period in ModelSim waveform, when measured by the cursor, is:66ns and not 10ns
clock waveform
any idea?
I don't really understand what causes this behavior.
Edit: also, if i run the fallowing commands in the TESTBENCH:
initial 
begin
#1 $display(&quot;T=0t at time #1&quot;,$realtime);
#1 $display(&quot;T=0t at time #2&quot;,$realtime);
#1 $display(&quot;T=0t at time #3&quot;,$realtime);
#1 $display(&quot;T=0t at time #4&quot;,$realtime);
#2 $display(&quot;T=0t at time #5&quot;,$realtime);
end

i get:
T=1000 at time #1
T=2000 at time #2
T=3000 at time #3
T=4000 at time #4
T=6000 at time #5

I guess this is a clue, but i have no idea what causing it.","You should have put all the code in text form. You generate clocks following this scheme:
always begin
   #5 sys_clk = ~sys_clk;
   #20 clk_in = ~clk_in;
   #8 clk_acq = ~clk_asq;
end

So, your clocks are updated every 33 cycles: 5 + 20 + 8, which explains clock period of 66.
An always block does not run parallel jobs, nor it restarts till it finishes. So, it will go through all updates before it starts again. As a result all your clocks will have a period of 66 and just will have an offset relative to each other.",,,,,
Getting nan values from OpenCL FFT kernel on FPGA,"I was trying to use the Intel's FFT1D kernel by writing the Host program by my own for Intel FPGA. Link to  Intel's FFT1d can be found here
I have also given my host program below, wherein, I have a file saved (which contains some data), my task is to read that data, calculate its FFT and print some of it. It is a 4K point FFT
 #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
#include &quot;CL/opencl.h&quot;
#include &quot;AOCLUtils/aocl_utils.h&quot;
#include &lt;string.h&gt;
#include &quot;fft_config.h&quot;


#define N (1&lt;&lt;LOGN) //Please check the FFT Sample Code for Ref (2 to the power 12 gives 4K points)
#define DATA_FILE &quot;complex_input.data&quot;

using namespace aocl_utils;


cl_platform_id platform = NULL;
cl_device_id device = NULL;
cl_command_queue queue0 = NULL;
cl_command_queue queue1 = NULL;
cl_context context = NULL;
cl_program program = NULL;
cl_kernel kernel0, kernel1;
cl_mem d_inData, d_outData;
cl_int err = 0;

typedef struct {
  float x;
  float y;
} float2;
//float2 h_outData[N], h_inData[N];
float2 *h_inData = (float2 *)alignedMalloc(sizeof(float2)*N);
float2 *h_outData = (float2 *)alignedMalloc(sizeof(float2)*N);

void init();    //Function that does the job of Querying Platform and Device, creating Context, Command Queues, Program and required Kernels to do the job.
void cleanup(); //Function that releases all the Created Contexts, Buffers etc, in order to finish the execution.
void read_data();   //Reads data from the complex numbers from .data file and fills in the float2 struct h_inData[].
int temp_value = 1;

int main()
{
 // h_inData = (float2 *)alignedMalloc(sizeof(float2)*N);
  //h_outData = (float2 *)alignedMalloc(sizeof(float2)*N);

  int inverse = false;
  int temp =1;
  init();
  read_data();

  d_inData = clCreateBuffer(context, CL_MEM_READ_WRITE, sizeof(float2)*N, NULL, &amp;err);
  checkError(err,&quot;Failed to allocate Buffer for input array\n&quot;);

  d_outData = clCreateBuffer(context, CL_MEM_READ_WRITE | CL_CHANNEL_2_INTELFPGA, sizeof(float2)*N, NULL, &amp;err);
  checkError(err, &quot;Failed to allocate the Buffer for output\n&quot;);


  //WE FINISH THE FETCH KERNEL
  err = clEnqueueWriteBuffer(queue1,d_inData, CL_TRUE, 0, sizeof(float2)*N, h_inData, 0, NULL, NULL);
  checkError(err,&quot;Failed to Write the input Buffer\n&quot;);

  err = clSetKernelArg(kernel1, 0, sizeof(cl_mem), (void *)&amp;d_inData);
  checkError(err, &quot;Failed to set KerArg for Kernel1 - 0\n&quot;);

  err = clSetKernelArg(kernel0, 0, sizeof(cl_mem), (void *)&amp;d_outData);
  checkError(err, &quot;Failed to set KerArg for Kernel0 - 0\n&quot;);

  err = clSetKernelArg(kernel0, 1, sizeof(cl_int), (void *)&amp;temp_value);
  checkError(err, &quot;Failed to set KerArg for Kernel0 - 1\n&quot;);

  err = clSetKernelArg(kernel0, 2, sizeof(cl_int), (void *)&amp;inverse);
  checkError(err, &quot;Failed to set KerArg for Kernel0 - 2\n&quot;);

  printf(&quot;FFT Initialization Complete!\n\n&quot;);

  err = clEnqueueTask(queue0, kernel0, 0, NULL, NULL);
  checkError(err, &quot;Failed to Launch the Kernel for FFT\n&quot;);

  size_t local_work_size = N/8;
  size_t global_work_size = local_work_size * 1; //Coz the number of Iterations is just 1

  err = clEnqueueNDRangeKernel(queue1, kernel1, 1, NULL, &amp;local_work_size, &amp;global_work_size, 0, NULL, NULL);
  checkError(err, &quot;Failed to launch the Fetch Kernel\n&quot;);

  err = clFinish(queue0);
  checkError(err, &quot;Failed to finish FFT\n&quot;);
  err = clFinish(queue1);
  checkError(err, &quot;Failed to finish Fetch kernel\n&quot;);

  err = clEnqueueReadBuffer(queue0, d_outData, CL_TRUE, 0, sizeof(float2)*N, h_outData, 0, NULL, NULL);
  checkError(err, &quot;Failed to Read back the Buffer output\n&quot;);


  printf(&quot;FFT is Complete!\n\n&quot;); 
  printf(&quot;Printing some of the values, just to make sure they are non-zero\n\n&quot;);
  for(int ii=100;ii&lt;125;ii++)
  {
        printf(&quot;%f + %f j -&gt; %f + %f j\n&quot;,h_inData[ii].x,h_inData[ii].y,h_outData[ii].x,h_outData[ii].y);
  }
  printf(&quot;\n\n&quot;);
  cleanup();

  return 0;
}



void read_data()
{
  size_t sourceSize;
  float* temp;

  FILE *fp = fopen(DATA_FILE,&quot;r&quot;);
  if(fp==NULL)
  {
    printf(&quot;Could not find the Random Data File! Exiting!\n&quot;);
    exit(1);
  }
  fseek(fp,0,SEEK_END);
  sourceSize=ftell(fp);
  rewind(fp);

  temp = (float *)alignedMalloc(sourceSize);
  fread(temp, sizeof(float),sourceSize,fp);
  fclose(fp);

  for(int i=0;i&lt;N;i++)
  {
    h_inData[i].x = temp[2*i];
    h_inData[i].y = temp[(2*i)+1];
  }
}


void init()
{
  platform = findPlatform(&quot;Intel(R) FPGA SDK for OpenCL(TM)&quot;);
  if(platform == NULL)
  {
    printf(&quot;Could not find the Platform\n&quot;);
    exit(1);
  }


  scoped_array&lt;cl_device_id&gt; devices;
  cl_uint num_devices;
  devices.reset(getDevices(platform, CL_DEVICE_TYPE_ACCELERATOR, &amp;num_devices));
  device = devices[0];

  context = clCreateContext(NULL, 1, &amp;device, &amp;oclContextCallback, NULL, &amp;err);
  checkError(err, &quot;Failed to create Context\n&quot;);

  queue0 = clCreateCommandQueue(context, device, CL_QUEUE_PROFILING_ENABLE, &amp;err);
  checkError(err, &quot;Failed to create Command Queue0\n&quot;);
  queue1 = clCreateCommandQueue(context, device, CL_QUEUE_PROFILING_ENABLE, &amp;err);
  checkError(err, &quot;Failed to create Command Queue1\n&quot;);


  program = createProgramFromBinary(context, &quot;bin/fft1d.aocx&quot;, &amp;device, 1);

  err = clBuildProgram(program, 1, &amp;device, &quot;&quot;, NULL, NULL);
  checkError(err, &quot;Failed to Build Program\n&quot;);


  kernel0 = clCreateKernel(program, &quot;fft1d&quot;, &amp;err);
  checkError(err,&quot;Could not Create Kernel0\n&quot;);

  kernel1 = clCreateKernel(program, &quot;fetch&quot;, &amp;err);
  checkError(err, &quot;Could not Create Kernel1\n&quot;);

  printf(&quot;Finished with the Initial Setup!\n&quot;);
}

void cleanup()
{
  if(kernel0)
    clReleaseKernel(kernel0);
  if(kernel1)
    clReleaseKernel(kernel1);
  if(program)
    clReleaseProgram(program);
  if(queue0)
    clReleaseCommandQueue(queue0);
  if(queue1)
    clReleaseCommandQueue(queue1);
  if(d_inData)
    clReleaseMemObject(d_inData);
  if(d_outData)
    clReleaseMemObject(d_outData);
  if(context)
    clReleaseContext(context);


}

I checked if the data from file is being read fine, and It is correct and as expected.
Please let me know where could this go wrong!","Update!
I found out the solution. Reading from the itself was not a good idea, here. I tried generating the random there during the execution and it worked just fine!",,,,,
Gate-level timing checks in SVA,"I need to check the value of a signal after a certain amount of time a clock edge occurs. For example, I want to check that if signal b asserts to high 1ps after posedge clock occurs.
Does SVA provide a syntax for this?","system-verilog-assertions were not intended for use as gate-level timing checks. Verilog already provides a number of built-in and optimized timing checks like $setuphold and $skew. See section 31. Timing checks in the IEEE 1800-2017 SystemVerilog LRM.
Timing checks are usually expressed as limitsâ€”either assertion happens at least 1ps after the clock edge, or at most 1ps after the clock edge. Also, must b be asserted after every clock edge? Regardless of the answers to these questions, it's possible to use SVA to model timing check, but you will have to manually create equations based on the actual requirements. For example
property p;
  realtime timestamp;
  @(posedge c) ($rose(a), timestamp = $realtime) |=&gt; 
       @(posedge b) $realtime - timestamp &lt; 1ps;
endproperty
",,,,,
Missing connection for port 'v1',"I'm working on a systemVerilog code, where a lookup value is being compared to 8 registers of the same bit size, it should give valid 1 if one of the registers matches the the lookup val. everything compiles but it gives several warnings stating &quot;Missing connection for port 'v1'&quot; and I'm not sure how to resolve this issue
code below with a simple testbench
module V(
input logic [3:0] A,B,
output logic valid);

  logic xnor_3, xnor_2, xnor_1, xnor_0, and_0;
  
  assign xnor_3 = ~(A[3] ^ B[3]);
  assign xnor_2 = ~(A[2] ^ B[2]);
  assign xnor_1 = ~(A[1] ^ B[1]);
  assign xnor_0 = ~(A[0] ^ B[0]);
  assign and_0 = xnor_1 &amp; xnor_0 &amp; xnor_2 &amp; xnor_3 ;
  assign valid = and_0 ;
  
endmodule

module Vt(
input logic[3:0] D_lookup,
input logic[3:0] r0,r1,r2,r3,r4,r5,r6,r7,
output logic v0, v1, v2, v3, v4, v5, v6, v7, Valid);

  V vt0(D_lookup,r0,v0);
  V vt1(D_lookup,r1,v1);
  V vt2(D_lookup,r2,v2);
  V vt3(D_lookup,r3,v3);
  V vt4(D_lookup,r4,v4);
  V vt5(D_lookup,r5,v5);
  V vt6(D_lookup,r6,v6);
  V vt7(D_lookup,r7,v7);

  assign Valid = v0 || v1 || v2 || v3 || v4 || v5 || v6 || v7;
endmodule

module tb_V();
logic[3:0] D_lookup;
logic[3:0] r0,r1,r2,r3,r4,r5,r6,r7;
Vt dut(D_lookup,r0,r1,r2,r3,r4,r5,r6,r7,Valid);
initial begin
D_lookup = 4'b1010;
r0 = 4'b1000;
r1 = 4'b1001;
r2 = 4'b1010;
r3 = 4'b1011;
r4 = 4'b1100;
r5 = 4'b1101;
r6 = 4'b1110;
r7 = 4'b1111; 
#10;
end
endmodule
","It would have helped if you posted and read the exact error message you are getting
# ** Warning: (vsim-2685) [TFMPC] - Too few port connections for 'dut'.  Expected 18, found 10.
#    Time: 0 ns  Iteration: 0  Instance: /tb_V/dut File: testbench.sv Line: 36
# ** Warning: (vsim-3722) testbench.sv(36): [TFMPC] - Missing connection for port 'v1'.
# ** Warning: (vsim-3722) testbench.sv(36): [TFMPC] - Missing connection for port 'v2'.
# ** Warning: (vsim-3722) testbench.sv(36): [TFMPC] - Missing connection for port 'v3'.
# ** Warning: (vsim-3722) testbench.sv(36): [TFMPC] - Missing connection for port 'v4'.
# ** Warning: (vsim-3722) testbench.sv(36): [TFMPC] - Missing connection for port 'v5'.
# ** Warning: (vsim-3722) testbench.sv(36): [TFMPC] - Missing connection for port 'v6'.
# ** Warning: (vsim-3722) testbench.sv(36): [TFMPC] - Missing connection for port 'v7'.
# ** Warning: (vsim-3722) testbench.sv(36): [TFMPC] - Missing connection for port 'Valid'.

So it seems you are missing all of the output port connections to your Vt module. All you need to do is add them. You don't even have to declare them separately; the will be implicitly declared as 1-bit wires.
  Vt dut(D_lookup,r0,r1,r2,r3,r4,r5,r6,r7,
     v0, v1, v2, v3, v4, v5, v6, v7, Valid );
",,,,,
Chapter 2 ALU.hdl not working on final line,"When I run ALU-nostat.tst, the code executes perfectly. However, when I run ALU.tst, the code stops on line 1. If I then click the forward arrow again and allow it to test out the following test cases, it seems to work. I compared the output file generated with the compare file and I think that everything matches. The error seems to be before the cases are tested out because the output file is empty (only with the input and output column headers) before I click the forward arrow again.
set x %B0000000000000000,  // x = 0

^ is the line where the test script stops. It is strange because it does not stop here:
set x %B0000000000000000,

on the no-stat script.
In case it helps, the code is below.
`
PARTS:
Mux16(a=x[0..15],b[0..15]=false,sel=zx,out=x1);
Not16(in=x1,out=maybex);
Mux16(a=x1,b=maybex,sel=nx,out=x2);

Mux16(a=y[0..15],b[0..15]=false,sel=zy,out=y1);
Not16(in=y1,out=maybey);
Mux16(a=y1,b=maybey,sel=ny,out=y2);

And16(a=x2,b=y2,out=output1);//I dont know what is wrong here
Add16(a=x2,b=y2,out=output2);
Mux16(a=output1,b=output2,sel=f,out=output3);

Not16(in=output3,out=almost);

Mux16(a=output3,b=almost,sel=no,out=out);

Mux16(a=output3,b=almost,sel=no,out[15]=pt2);
Mux16(a=output3,b=almost,sel=no,out=pt3);


And(a=pt2,b=true,out=ngtest);
Add16(a=pt3,b[0..15]=true,out[15]=pinname);
Mux(a=pinname,b=false,sel=ngtest,out=zr);
And(a=pt2,b=true,out=ng);`

Even after commenting out all of the new lines for the zr and ng output pins, it is still giving me a comparison failure on line 1.
It is not a problem with ALU.tst as I re-downloaded it and it still does not work. I do not understand what the error is.
Many thanks!!!!","This is just a wild guess, but I noticed that the set y line in alu.tst ends in a ; while the one in alu-nostat.tst ends in a ,
Same goes for the other set y later in the file.
I would change those ;'s to ,'s and see if it fixes the issue.
If it doesn't, it may be that your ALU isn't generating the zr and ng values correctly so it's really failing on the first eval but for some reason you're getting a misleading error message pointing you to the wrong line. I would suggest you single-step through the tests and manually check to the ALU is responding correctly.
Good luck!",,,,,
Way to pick random addresses from dynamic ranges in SV constraints,"I have a requirement to pick random addresses from a set of predefined ranges in Systemverilog
program test;

int unsigned q[$], rSz;
typedef struct {
  int unsigned from, till;
} range_t;

initial begin
    range_t ranges[$];

    ranges.push_back('{from: 'h10, till: 'h1F});
    ranges.push_back('{from: 'h30, till: 'h3F});
    ranges.push_back('{from: 'h50, till: 'h5F});

    rSz = ranges.size();
    $displayh(rSz, ranges);

    repeat (10) begin
        std::randomize(q) with {
            q.size() inside {[4:8]};
            foreach (q[i]) {
                q[i] inside {[ranges[0].from: ranges[0].till]} ||
                q[i] inside {[ranges[1].from: ranges[1].till]} ||
                q[i] inside {[ranges[2].from: ranges[2].till]} ;
            }
        };
        $displayh(q);
    end
end

endprogram : test

It works fine if I have a fixed number of ranges that I can hard-code.
But the number of ranges itself is dynamic, I can not hard-code the ranges as in the foreach loop.
I can't use a nested foreach as the statements in the inner loop will be treated as individual constraints and fail with each other as the ranges are non-overlapping.
All I could come up with is something like below where I use the ranges in order and then shuffle at the end.
program test;

int unsigned q[$], rSz;
typedef struct {
  int unsigned from, till;
} range_t;

initial begin
    range_t ranges[$];
    ranges.push_back('{from: 'h10, till: 'h1F});
    ranges.push_back('{from: 'h30, till: 'h3F});
    ranges.push_back('{from: 'h50, till: 'h5F});

    rSz = ranges.size();
    $displayh(rSz, ranges);

    repeat (10) begin
        std::randomize(q) with {
            q.size() inside {[4:8]};
            foreach (q[i]) {
                q[i] inside {[ranges[i % rSz].from: ranges[i % rSz].till]};
            }
        };
        q.shuffle();
        $displayh(q);
    end
end

endprogram : test

Is there a better way of doing this in general?
I am looking for something like foreach-or where all lines in loop are or-ed instead of and-ed - if that explains the requirement.","Most people are familiar with the sum() array reduction method, but there are also or(), and(), and xor() reduction methods as well.
module test;
  int unsigned q[$], rSz;
  typedef struct {
    int unsigned from, till;
  } range_t;
  
  initial begin
    range_t ranges[$];

    ranges.push_back('{from: 'h10, till: 'h1F});
    ranges.push_back('{from: 'h30, till: 'h3F});
    ranges.push_back('{from: 'h50, till: 'h5F});

    rSz = ranges.size();
    $displayh(rSz,, ranges);

    repeat (10) begin
      assert(std::randomize(q) with {
        q.size() inside {[4:8]};
        foreach (q[i]) 
          ranges.or(range) with (q[i] inside {[range.from: range.till]});
      });
      $displayh(q);
    end
  end
endmodule: test

See section 7.12.3 Array reduction methods in the IEEE 1800-2017 SystemVerilog LRM.",,,,,
Virtual interface element uses an interface with interface ports [warning from QuestaSIM vlog/vsim],"What is the meaning of the following warning issued by QuestaSIM's vsim? What is the simulator worried about here? I haven't been able to produce an actual simulation error from this yet.
My guess: it has something to do with interface instances vs. virtual interface instances, but my understanding is minimal.

** Warning: (vsim-8887) tests/base_test.svh(28): Virtual interface element 'this.apb_driver_bfm_vi.clk' uses an interface with interface ports.

apb_driver_bfm_vi is a virtual interface handle to the following interface:
interface apb_driver_bfm(
    input logic clk,
    input logic nrst,
    apb_if.apb_s apb_if_i // apb_if is itself an interface, apb_s is a modport.
);

endinterface : apb_driver_bfm

The virtual interface is used as follows: @(posegde apb_driver_bfm_vi.clk); in the run_phase of my testbench. This seems to work fine, despite the warning.","From section 25.9 Virtual interfaces in the IEEE 1800-2017 SystemVerilog LRM

Although an interface may contain hierarchical references to objects outside its body or ports that reference other interfaces, it shall be illegal to use an interface containing those references in the declaration of a virtual interface.

this a problem when the interface port gets connected to a parameterized interface and different instances of the virtual interface have different parameterizations. This is not a problem when the interfaces have the same parameters, but the LRM is overly pessimistic.",,,,,
Why use ports in interfaces?,"The SystemVerilog LRM (IEEE 1800-2017) describes ports in interfaces as follows:

One limitation of simple interfaces is that the nets and variables declared within the interface are only used to connect to a port with the same nets and variables. To share an external net or variable, one that makes a connection from outside the interface as well as forming a common connection to all module ports that instantiate the interface, an interface port declaration is required. The difference between nets or variables in the interface port list and other nets or variables within the interface is that only those in the port list can be connected externally by name or position when the interface is instantiated. Interface port declaration syntax and semantics are the same as those of modules (see 23.2.2).

What is the first sentence saying exactly? I don't see the limitation.
In the second sentence, what is an example of an external signal? How do you decided whether a signal should be declared inside the interface or as a port to the interface? The text used in the LRM just doesn't click for me.","The problem is shown with the simple_bus example that follows the section of the IEEE 1800-2017 SystemVerilog LRM you quoted.
There are two instances of the interface sb_intf1 and sb_intf2 each creating a unique set of internal signals (req, int, ...). If clk had also been declared as internal signal, there would also be two clock signals. What's not shown in the example is the code generating the clock signal. That could have been in the top module or another module. They would have needed to add continuous assignments to get the generated clock signal to each the internal clk in each interface instance.
By putting the shared signals in the interface in their port declarations, it makes it much easier to join the common signals.
interface simple_bus (input logic clk); // Define the interface
  logic req, gnt;
  logic [7:0] addr, data;
  logic [1:0] mode;
  logic start, rdy;
endinterface: simple_bus
module memMod(simple_bus a); // Uses just the interface
  logic avail;
  always @(posedge a.clk) // the clk signal from the interface
    a.gnt &lt;= a.req &amp; avail; // a.req is in the 'simple_bus' interface
endmodule
module cpuMod(simple_bus b);
  ...
endmodule
module top;
  logic clk = 0;
  simple_bus sb_intf1(clk); // Instantiate the interface
  simple_bus sb_intf2(clk); // Instantiate the interface
  memMod mem1(.a(sb_intf1)); // Reference simple_bus 1 to memory 1
  cpuMod cpu1(.b(sb_intf1));
  memMod mem2(.a(sb_intf2)); // Reference simple_bus 2 to memory 2
  cpuMod cpu2(.b(sb_intf2));
endmodule
",,,,,
Why does this for loop containing a delay not run to completion?,"I have two test benches:
// test_a.v
module test_a;
    initial
    begin
        for (int i = 0; i &lt; 128; i++) begin
            $display(&quot;hello&quot;);
            #10;
        end
    end
endmodule

// test_b.v
module test_b;
    initial
    begin
        #50;
        $finish();
    end
endmodule

I build and run this like so:
iverilog -g2012 -o icarus.out test_a.v test_b.v
vvp icarus.out

...and then see this output:
hello
hello
hello
hello
hello
hello

But it stops there. Why do I not get 128 &quot;hello&quot;s? I guess the $finish() in test_b.v causes test_a.v to quit early but is that expected?
https://www.edaplayground.com/x/JjJR","Most likely a problem with a piece of code you have not shown. Adding a final block after the initial block might give some clues.
final $display($realtime);

It is unfortunate that Icarus Verilog does not notify you that it has hit a $finish and just prints Done. So you might wanna search for other $finish tasks and put a $display statement just before it.
UPDATE:
Based on your updated code, all modules share the same global concept of simulation time, beginning and end-of-time. When one module executes a $finish, that is the end-of-time for the entire simulation. The way you have coded it, there is a race condition whether you would see 5 or 6 &quot;hello&quot;s.",,,,,
What is the Difference Between Actual and Formal Arguments in Systemverilog DPI?,"In SystemVerilog design I am using DPI-C with c program functions. While running simulation on both files, I am getting error:
&quot;Actual type is not supported for DPI open array&quot;.
I want to know which argument is called actual and which is called formal in SystemVerilog side of DPI.","From software programming terminology, the formal arguments to any routine are the ones declared when defining the routine. The actual arguments are the expressions you pass to the routine when calling it. For example
import &quot;DPI&quot; function void master_write(int address,
                                        int data[]);

address and data are the formal arguments.
int addr;
int buffer[$];

always @(posedge clk) master_write(addr/2, buffer);

addr/2 and buffer are the actual arguments passed to master_write().
Another piece of terminology: &quot;not supported&quot; usually means what you wrote is defined by the LRM, but the tool you are using has not implemented it yet.",,,,,
Machine state does not change output,"As you can see in the code below, I have a machine state with a state called start. This state should take the value of coord_x_reg , increment it by one and assign it to the output port using the assign instruction at the end. The problems are:

The output coord_x does not change in the simulation as you can see in the photo 

I imagine that the problem is that I cannot write and read from the register at the same time. How can I achieve the effect I want then? (I also tried using coord_x_reg as a integer variable)

When using reset, I have to comment some signals, other way I get Illegal left hand side of nonblocking assignment error.


module Ball
  #(parameter SCR_W = 1280,   //SCREEN RESOLUTION?
    parameter SCR_H = 720,
    parameter BALL_WIDTH = 30,
    parameter PAD_Y_WIDTH = 26,
    parameter PAD_Y_LENGTH = 168,
    parameter PAD_x_POS_L = 67,
    parameter PAD_x_POS_R = 1213  //SCR_W-PAD_x_POS_L
  )
  (
     input wire CLK, RST,
     input wire button_L, button_R,
     input wire [9:0] pad_y_L,
     input wire [9:0] pad_y_R,
     output wire [9:0] coord_x,
      output wire [9:0] coord_y,
     output wire [3:0] score_left,
      output wire [3:0] score_right
  );

  //STATES
  localparam [3:0] //11 states needed we need 4 bits
       start = 4'b0000,
       start_race = 4'b0001,

       left_player_begins = 4'b0010,
       right_player_begins = 4'b0011,

       top_left = 4'b0100,
       top_right = 4'b0101,

       bottom_left = 4'b0110,
       bottom_right = 4'b0111,

       score_L = 4'b1000,
       score_R = 4'b1001,

       game_over = 4'b1010;


  //Current state variables
  reg [3:0] state_reg, state_next;

  //output registers
  reg [9:0] coord_x_reg = 0;
  reg [9:0] coord_y_reg = 0;
  reg [3:0] score_left_reg = 0;
  reg [3:0] score_right_reg = 0;




  always @(posedge CLK, posedge RST)
  begin
      if(RST) // go to state zero if reset
          begin
           state_reg &lt;= start;

           //coord_x &lt;= 0;
           //coord_y &lt;= 0;
           //score_left &lt;= 0;
           //score_right &lt;= 0;
              
          end
      else // otherwise update the states
          begin

           state_reg &lt;= state_next;

          end
  end


  //_________________________________________________________________________
  // MACHINE STATE DESIGN
  //_________________________________________________________________________

  always @(state_reg) //   &lt;------------ PUT VARIABLES HERE???????!!!!!!!!!!!!!!!
  begin
      // store current state as next
      state_next = state_reg; // REQUIRED: when no case statement is satisfied


      case(state_reg)

        start :
          begin


            coord_x_reg &lt;= coord_x_reg + 1;

            if (coord_x_reg == 10)
                  state_next = start_race;


          end

        start_race :
          begin
            state_next = start;
          end

      endcase

  end

assign coord_x = coord_x_reg;
assign coord_y = coord_y_reg;
assign score_left = score_left_reg;
assign score_right = score_right_reg;


endmodule // Ball 
","By investigating, I came to the conclusion that the sensibility list was giving problems. I modified the code so the machine state is inside the always @(posedge CLK, posedge RST). Now works as expected. The new code:
module Ball
#(parameter SCR_W = 1280,   //SCREEN RESOLUTION?
    parameter SCR_H = 720,
    parameter BALL_WIDTH = 30,
    parameter PAD_Y_WIDTH = 26,
    parameter PAD_Y_LENGTH = 168,
    parameter PAD_x_POS_L = 67,
    parameter PAD_x_POS_R = 1213  //SCR_W-PAD_x_POS_L
  )
  (
     input wire CLK, RST,
     input wire button_L, button_R,
     input wire [9:0] pad_y_L,
     input wire [9:0] pad_y_R,
     output wire [9:0] coord_x,
      output wire [9:0] coord_y,
     output wire [3:0] score_left,
      output wire [3:0] score_right
  );

  //STATES
  localparam [3:0] //11 states needed we need 4 bits
       start = 4'b0000,
       start_race = 4'b0001,

       left_player_begins = 4'b0010,
       right_player_begins = 4'b0011,

       top_left = 4'b0100,
       top_right = 4'b0101,

       bottom_left = 4'b0110,
       bottom_right = 4'b0111,

       score_L = 4'b1000,
       score_R = 4'b1001,

       game_over = 4'b1010;


  //Current state variables
  reg [3:0] state;

  //output registers
  reg [9:0] coord_x_reg = 0;
  reg [9:0] coord_y_reg = 0;
  reg [3:0] score_left_reg = 0;
  reg [3:0] score_right_reg = 0;




  always @(posedge CLK, posedge RST)
  begin
      if(RST) // go to state zero if reset
          begin
           state &lt;= start;

           coord_x &lt;= 0;
           coord_y &lt;= 0;
           score_left &lt;= 0;
           score_right &lt;= 0;

          end
      else // otherwise update the states
          begin

          case(state)

            start :
              begin


                coord_x_reg = coord_x_reg + 1;

                if (coord_x_reg == 10)
                  state = start_race;


              end

            start_race :
              begin
                state = start_race;
              end

          endcase


          end
  end


assign coord_x = coord_x_reg;
assign coord_y = coord_y_reg;
assign score_left = score_left_reg;
assign score_right = score_right_reg;


endmodule // Ball ```
",,,,,
Getting Unix time or epoch in VHDL,To introduce some randomness in my testbench I would like to use pseudo-random numbers seeded with the current Unix time or epoch. Is there a (non-synthesizable ofc) function in VHDL for that? I need it to work in VHDL 2008.,"Why not simply passing a generic parameter value on the same command line you use to run the simulation? Example with bash:
entity foo is
  generic(seed: natural := 0);
end entity foo;

architecture bar of foo is
begin
  assert false report natural'image(seed);
end architecture bar;

$ ghdl -a --std=08 foo.vhd
$ ghdl -r --std=08 foo
foo.vhd:7:3:@0ms:(assertion error): 0
$ ghdl -r --std=08 foo -gseed=$(date +%s)
foo.vhd:7:3:@0ms:(assertion error): 1648027085
",,,,,
Serial-Load-Shift-Register,"In the serial load shift register, how can i make sure that the shift was not disabled before at least five data has been loaded?
module serial_load_shift_register(
  input logic clk         ,
  input logic shift_enable,
  input logic d_in        ,
  output logic q
);
  logic [0:4] register;
  always @(posedge clk) begin
    register[0] &lt;= shift_enable ? d_in        : register[0];
    register[1] &lt;= shift_enable ? register[0] : register[1];
    register[2] &lt;= shift_enable ? register[1] : register[2];
    register[3] &lt;= shift_enable ? register[2] : register[3];
    register[4] &lt;= shift_enable ? register[3] : register[4];
  end
  assign q = register[4];
endmodule: serial_load_shift_register
","What you can do is put the shift_enable signal into a shift register as well that gives you a history of that signal. If that register is non-zero, use that condition to control the shifting of data.
module serial_load_shift_register(
  input logic clk         ,
  input logic shift_enable,
  input logic d_in        ,
  output logic q
);
  logic [0:3] register;
  always @(posedge clk) begin
    logic [0:4] enable;
    enable = {enable,shift_enable};
    if (enable != 0) register &lt;= {register, d_in};
  end
  assign q = register[0];
 
endmodule: serial_load_shift_register

Note that the assignment to enable is not using an NBA. This means the statements that references enable following the assignment use the current value, not the value from the previous cycle. There are no issues with race conditions because I declared enable local to the always block, so no one can reference it outside the always.",,,,,
Error in the output window of Xilinx as shown in below diagram for 32 bit logic unit using gate level,"Below mentioned is the code for the 32-bit logic unit with the below showed logic function in the diagram. I am not sure where I am going wrong. I tried making changes in the logic function of the selection bit 's' but it doesn't seem to works somehow.

module ALU_unit(output out, input x, input y, input [1:0] s);
wire ns0, ns1;
wire w0,w1,w2,w3;
wire t1,t2,t3,t4;

and (t1,x,y);
or (t2,x,y);
xor (t3,x,y);
nor (t4,x,y);

not (ns0, s[0]);
not (ns1, s[1]);
and (w0, t1, ns0, ns1);
and (w1, t2, s[0], ns1);
and (w2, t3, ns0, s[1]);
and (w3, t4, s[0], s[1]);
or (out, w0, w1, w2, w3);
endmodule

module stimulus;

reg [31:0] x, y;
reg [1:0] s;
wire [31:0] out;

ALU_unit m0(out[0], x[0], y[0], s[0]);
ALU_unit m1(out[1], x[1], y[1], s[1]);
ALU_unit m2(out[2], x[2], y[2], s[2]);
ALU_unit m3(out[3], x[3], y[3], s[3]);
ALU_unit m4(out[4], x[4], y[4], s[4]);
ALU_unit m5(out[5], x[5], y[5], s[5]);
ALU_unit m6(out[6], x[6], y[6], s[6]);
ALU_unit m7(out[7], x[7], y[7], s[7]);
ALU_unit m8(out[8], x[8], y[8], s[8]);
ALU_unit m9(out[9], x[9], y[9], s[9]);
ALU_unit m10(out[10], x[10], y[10], s[10]);
ALU_unit m11(out[11], x[11], y[11], s[11]);
ALU_unit m12(out[12], x[12], y[12], s[12]);
ALU_unit m13(out[13], x[13], y[13], s[13]);
ALU_unit m14(out[14], x[14], y[14], s[14]);
ALU_unit m15(out[15], x[15], y[15], s[15]);
ALU_unit m16(out[16], x[16], y[16], s[16]);
ALU_unit m17(out[17], x[17], y[17], s[17]);
ALU_unit m18(out[18], x[18], y[18], s[18]);
ALU_unit m19(out[19], x[19], y[19], s[19]);
ALU_unit m20(out[20], x[20], y[20], s[20]);
ALU_unit m21(out[21], x[21], y[21], s[21]);
ALU_unit m22(out[22], x[22], y[22], s[22]);
ALU_unit m23(out[23], x[23], y[23], s[23]);
ALU_unit m24(out[24], x[24], y[24], s[24]);
ALU_unit m25(out[25], x[25], y[25], s[25]);
ALU_unit m26(out[26], x[26], y[26], s[26]);
ALU_unit m27(out[27], x[27], y[27], s[27]);
ALU_unit m28(out[28], x[28], y[28], s[28]);
ALU_unit m29(out[29], x[29], y[29], s[29]);
ALU_unit m30(out[30], x[30], y[30], s[30]);
ALU_unit m31(out[31], x[31], y[31], s[31]);

initial
begin
$monitor(""Input is %d %d, output is %d \n\n"", x, y, out);
x = 32'd111; y = 32'd222;

#1 s= 2'b00;
#1 s= 2'b01;
#1 s= 2'b10;
#1 s= 2'b11;

end
endmodule


Below is the image of the logic unit, the error and above mentioned is the code in gate-level Verilog.


","you are not instantiating a 32 bit ALU in the Design instead you have coded for 1-bit ALU and making multiple instances of it in Test-bench.now coming to the issue from the stimulus block you are not passing 2 bit for selection of logic operation instead you are sending 1-bit for selection, so code will be optimized and thats why warnings are shown in EDA tool.

module alu_unit(
   output      out
  ,input       x,y
  ,input [1:0] s
);

  wire ns0, ns1;
  wire w0,w1,w2,w3;
  wire t1,t2,t3,t4;

  and  u_gate_inst_0(t1,x,y);
  or   u_gate_inst_1(t2,x,y);
  xor  u_gate_inst_2(t3,x,y);
  nor  u_gate_inst_3(t4,x,y);

  not u_mux_inst_0 (ns0, s[0]);
  not u_mux_inst_1 (ns1, s[1]);
  and u_mux_inst_2 (w0 , t1, ns0 , ns1   );
  and u_mux_inst_3 (w1 , t2, ns1 , s[0]  );
  and u_mux_inst_4 (w2 , t3, ns0 , s[1]  );
  and u_mux_inst_5 (w3 , t4, s[0], s[1]  );
  or  u_mux_inst_6 (out, w0, w1  , w2, w3);

endmodule

module alu_top(
    output [31:0] out
   ,input  [31:0] x,y
   ,input  [1:0]  s
);

 alu_unit u_alu_unit [31:0] (out,x,y,s);

endmodule

module stimulus;

 reg  [31:0] x, y;
 reg  [1:0]  s;
 wire [31:0] out;

 alu_top u_alu_top (out,x,y,s);

 initial begin
    $monitor(""Input is %d %d, output is %d \n\n"", x, y, out);
    x = 32'd111; y = 32'd222;

    #1 s= 2'b00;
    #1 s= 2'b01;
    #1 s= 2'b10;
    #1 s= 2'b11;

 end
endmodule
",,,,,
VHDL Code explanation needed (std_logic_vector),"1) std_logic_vector(data_width - 1 downto 0)

In this code, I am not understanding (-1 downto 0). I know this is telling us that it is 8 bit. But Not understanding how? For example, (7 donwto 0) is self-explanatory eg. 0,1,2,3,4,5,6,7. 

2) A_reg(data_width - 1 downto 1) &lt;= A_reg(data_width - 2 downto 0);

I know we are left shifting. But can anyone explain how? I wanted to know how the bit position is changing or shifting.","You should read very carefully. It does not say (-1 downto 0). it says (data_width - 1 downto 0).

Thus if data_width is 8 you get (8-1 downto 0) which is your (7 downto 0) 



Now the next one: A_reg(data_width - 1 downto 1) &lt;= A_reg(data_width - 2 downto 0);

Again using a data_width of 8 we get : A_reg(7 downto 1) &lt;= A_reg(6 downto 0);

Thus the bits 6,5,4,...0 are transferred to resp bits 7,6,5,..1. Each bit is moved one position to the left, but bit 0 stays the same:

 A[7][6][5][4][3][2][1][0]
     /  /  /  /  /  /  /|
    /  /  /  /  /  /  / | 
   v  v  v  v  v  v  v  v
 A[7][6][5][4][3][2][1][0]
",,,,,
Why does port size doesn't match here in Verilog (16-bit CarrySelectAdder)?,"Here I'm designing a 16-bit CarrySelectAdder 

Here is the adder file:

module multiplexer2x1_4 (X, I0, I1, S);
   output [3:0] X;   
   input [3:0]  I1;  
   input [3:0]  I0;  
   input S; 
   assign X = (S == 1'b0) ? I0 : I1;
endmodule

module multiplexer2x1_1 (X, I0, I1, S);
   output X;   
   input I1;  
   input I0;  
   input S; 
   assign X = (S == 1'b0) ? I0 : I1;
endmodule

module halfAdder(S,Cout,A,B);
    output S;
    output Cout;
    input A;
    input B;
    xor(S,A,B);
    and(Cout,A,B);
endmodule

module fullAdder(S, Cout, A, B, Cin);
   output S;
   output Cout;
   input  A;
   input  B;
   input  Cin;
   wire   C1;
   wire   C2;
   wire   S1;
   halfAdder h1 (S1,C1,A,B);
   halfAdder h2 (S,C2,S1,Cin);     
   or(Cout, C1, C2);
endmodule 

module rippleCarryAdder(S, C, A, B, Cin);
   output [3:0] S;
   output   C; 
   input [3:0]  A; 
   input [3:0]  B; 
   input    Cin; 

   wire     C0;
   wire     C1;
   wire     C2;

   fullAdder f0(S[0], C0, A[0], B[0], Cin);
   fullAdder f1(S[1], C1, A[1], B[1], C0);
   fullAdder f2(S[2], C2, A[2], B[2], C1);
   fullAdder f3(S[3], C, A[3], B[3], C2);  
endmodule



module carrySelectAdder(S, C, A, B);
   output [15:0] S;  
   output   C;  
   input [15:0]     A;  
   input [15:0]     B; 

   wire [11:0]  S0; 
   wire [11:0]  S1; 

   wire     C0;   
   wire     C1;  
   wire     C2; 
   wire     C3; 
   wire     C4; 
   wire     C5;  
   wire     C6; 
   wire     C7; 
   wire     C8; 

   rippleCarryAdder R1 (S[3:0], C0, A[3:0], B[3:0], 0);

   rippleCarryAdder R2_1 (S0[3:0], C1, A[7:4], B[7:4], 0);     
   rippleCarryAdder R2_2 (S1[3:0], C2, A[7:4], B[7:4], 1);     
   multiplexer2x1_4 mux2 (S[7:4], S0[3:0], S1[3:0], C0);  

   multiplexer2x1_1 mc2 (C3,C1,C2,C0);

   rippleCarryAdder R3_1 (S0[7:4], C4, A[11:8], B[11:8], 0);     
   rippleCarryAdder R3_2 (S1[7:4], C5, A[11:8], B[11:8], 1);     
   multiplexer2x1_4 mux3 (S[11:8], S0[11:8], S1[11:8], C3);  

   multiplexer2x1_1 mc3 (C6,C4,C5,C3);

   rippleCarryAdder R4_1 (S0[11:8], C7, A[15:12], B[15:12], 0);     
   rippleCarryAdder R4_2 (S1[11:8], C8, A[15:12], B[15:12], 1);     
   multiplexer2x1_4 mux4 (S[15:12], S0[11:8], S1[11:8], C6);

   multiplexer2x1_1 mc4 (C,C7,C8,C6);

endmodule


and this is the testbench:

module carrySelectAdder_testBench;
reg [15:0] a;
reg [15:0] b;
wire [15:0] sum;
wire carry;
  carrySelectAdder sl (sum[15:0],carry,a[15:0],b[15:0]);
initial 
begin
$monitor(""%b \t %b"",sum,carry);
assign a = 16'b1001010110010101;
assign b = 16'b1001010111110101;
$finish;
end
endmodule


it gives me size match error in port 5 in the rippleCarryAdder, What is wrong?


  design.sv: L78: warning: Port sizes don't match in port #5 design.sv:
  L80: warning: Port sizes don't match in port #5 design.sv: L81:
  warning: Port sizes don't match in port #5 design.sv: L86: warning:
  Port sizes don't match in port #5 design.sv: L87: warning: Port sizes
  don't match in port #5 design.sv: L92: warning: Port sizes don't match
  in port #5 design.sv: L93: warning: Port sizes don't match in port #5
","The issue is that you tied the input port of your rippleCarryAdder instance to 0 instead of 1'b0. 

0 is an unsized literal constant number here, meaning you did not define the bit-width of this constant. When looking at Section 5.7.1 (Integer literal constants) of the the SystemVerilog LRM, we find that:


  The number of bits that make up an unsized number (which is a simple decimal number or a number with a base specifier but no size specification) shall be at least 32. Unsized unsigned literal constants where the high-order bit is unknown (X or x) or three-state (Z or z) shall be extended to the size of the expression containing the literal constant.


Hence, the compiler is interpreting your RTL as if you connected a 32-bit (or more) constant to the 1-bit input port of rippleCarryAdder.",,,,,
Big multiplexer with for loop in Verilog,"I want my circuit to write a value between 010 and 25510 to a reg called mem_address_reg depending on an incoming address. After an and-operation this address can take one of 25610 different values. I want the circuit to be combinational, so one way to check the value is to build a multiplexer with 25610 different inputs that then writes one of those to the output, depending on the incoming address (the select line of the multiplexer).

This circuit works but requires me to write a script that generates all 25610 case-statements and the code gets bloated. So instead of writing each and every line myself I want to use a for loop that generates those for me. Unfortunately this doesn't seem to work. 

What did I do wrong?

The working circuit with bloated code:

wire [31:0] masked_write_adr;
reg  [29:0] nvmm_write_request_adr;
reg  [7:0]  mem_address_reg;     

assign masked_write_adr = {2'b00, nvmm_write_request_adr} &amp; 32'hFFC0_0000;

always@(*)
begin
    case(masked_write_adr)
      32'h0000_0000:  mem_address_reg = 8'h00;
      32'h0040_0000:  mem_address_reg = 8'h01;
      32'h0080_0000:  mem_address_reg = 8'h02;
      32'h00C0_0000:  mem_address_reg = 8'h03;
      32'h0100_0000:  mem_address_reg = 8'h04;
      32'h0140_0000:  mem_address_reg = 8'h05;
      (...)
      32'h3FC0_0000:  mem_address_reg = 8'hFF;
      default:        mem_address_reg = 8'h0;
    endcase
end


This is what I thought to be an analog circuit which does not work:

wire [31:0] masked_write_adr;
reg  [29:0] nvmm_write_request_adr;
reg  [7:0]  mem_address_reg;     

assign masked_write_adr = {2'b00, nvmm_write_request_adr} &amp; 32'hFFC0_0000;

integer k;
always@(*)
begin
  mem_address_reg &lt;= 8'h00;
  for(k=0; k&lt;255; k=k+1)
  begin
      if((k*32'h40_0000) == masked_write_adr)
        mem_address_reg &lt;= k;
  end              
end
","just do

assign mem_address_reg = masked_write_addr[29:22];
",,,,,
(vhdl) expected type = current type type error,"I keep getting an error that says: 


  line 25: type error near num_values ; current type unsigned; expected
  type unsigned.


It is already the type that is supposed to be, and I think it is same in bit length and declared alright, what am I doing wrong here?

The code is about implementation of fifo queue structure. 

&lt;Queue.vhd&gt;


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity Queue is
    port (
        -- clock
        clk: in std_logic;
        -- input
        push: in std_logic;
        push_data: in std_logic_vector(31 downto 0);
        pop: in std_logic;
        -- output
        pop_data: out std_logic_vector(31 downto 0);
        num_values: out unsigned(31 downto 0)
    );
end entity;

architecture Behavioral of Queue is

type items is array(0 to 31) of std_logic_vector(31 downto 0);
signal manager : items := (others =&gt; (others =&gt; '0'));
signal push_idx, pop_idx : integer := 0;

begin
process(clk) is
variable howmany : integer := 0;


begin
if rising_edge(clk) then
    if (push = '1') then
        manager(push_idx) &lt;= push_data;
        push_idx &lt;= push_idx + 1;
        howmany := howmany + 1;
     end if;

     if (pop = '1') then
        if (howmany /= 0) then 
            pop_data &lt;= manager(pop_idx);
            pop_idx &lt;= pop_idx + 1;
            howmany := howmany - 1;
        end if;
        else
            pop_data &lt;= std_logic_vector(to_unsigned(0,pop_data'length));
     end if;

     if (push_idx = 31) then
        push_idx &lt;= 0;
     end if;

     if (pop_idx = 31) then
        pop_idx &lt;= 0;
     end if;
num_values &lt;= to_unsigned(howmany,32);
end if;
end process;
end architecture;

&lt;QueueTb.vhd&gt;

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;

entity QueueTb is
end entity;

architecture sim of QueueTb is

    constant ClockFrequency : integer := 100e6;
    constant ClockPeriod : time := 1000ms / ClockFrequency;

    signal clk : std_logic := '0';
    signal push, pop : std_logic := '0';
    signal num_values : unsigned(31 downto 0);
    signal push_data, pop_data : std_logic_vector(31 downto 0) := (others =&gt;'0');

begin

    UUT : entity work.Queue(Behavioral)
    port map(
        clk =&gt; clk,
        push   =&gt; push,
        pop   =&gt; pop,
        num_values  =&gt; num_values,    &lt;=== this is where error occurs!
        push_data =&gt; push_data,
        pop_data =&gt; pop_data);

    clk &lt;= not clk after ClockPeriod / 2;

    process is 
    begin
    wait for 10 ns;
    push &lt;= '1';
    push_data &lt;= conv_std_logic_vector(123,32);

    wait for 10 ns;
    push_data &lt;= conv_std_logic_vector(456,32);

    wait for 10 ns;
    push &lt;= '0';
    push_data &lt;= conv_std_logic_vector(0,32);
    pop &lt;= '1';

    wait for 10 ns;
    pop &lt;= '0';
    push &lt;= '1';
    push_data &lt;= conv_std_logic_vector(789,32);

    wait for 10 ns;
    push &lt;= '0';
    pop &lt;= '1';
    wait for 80 ns;

    end process;
end architecture;


What am I doing wrong here??","In the Queue entity you are using ieee.numeric_std and in the QueueTB you are using ieee.std_logic_arith . Both define different unsigned types.
Delete std_logic_arith from the testbench as it is not a standard VHDL library and use numeric_std instead.",,,,,
How to pass specific array index as input in a module in Verilog?,"I have a 4:1 Mux as follows:

module mux4_1 (input [31:0]A, input [31:0]B, input [31:0]C, input [31:0]D, input sel[1:0], output [31:0]Y);

wire mux1o, mux2o;
mux2_1 mux1 (A, B, sel[0], mux1o);
mux2_1 mux2 (C, D, sel[0], mux2o);
mux2_1 mux3 (mux1o, mux2o, sel[1], Y);

endmodule


In another module I have an array F of length 4 as input and need an instance of the 4:1 mux in this module with elements F[1] and F[3] of F as selectors. How can I specifiy this when declaring the instance? Surely this code below does not work, but it should illustrate what I am trying to achieve.

module someModule (inputs... F[3:0], outputs...);
 // some code...
 mux mux4_1 (A, B, C, D, F[1]F[3], Y);
endmodule
","To create you selector signal, you can simply concatenate the signal you need from your array.

wire [1:0] selector;
assign selector = {F[1], F[3]};

// selector is a 2 bit vector where 
// selector[0] == F[3]
// selector[1] == F[1]


A faster implementation would be in your case:

module someModule (inputs... F[3:0], outputs...);
     // some code...
     mux4_1 myInstance (A, B, C, D, {F[1], F[3]} , Y);
endmodule


In this case, the LSB of the selector is F[3] and its MSB is F[1]",,,,,
VHDL No drivers exist on out port,"I am doing my first project in VHDL, I try to implement  8-bit barrel shifter using mux.

This is code for one block (8 mux in chain):

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE work.sample_package.all;
-------------------------------------
ENTITY Shifter IS
  GENERIC (n : INTEGER );
  PORT (    x,y: IN STD_LOGIC_VECTOR (n-1 DOWNTO 0);
            redB: IN Integer;
            out_m: OUT STD_LOGIC_VECTOR(n-1 downto 0));
END Shifter;
--------------------------------------------------------------
ARCHITECTURE dfl OF Shifter IS
SIGNAL sm : STD_LOGIC;
SIGNAL what_b : STD_LOGIC;
BEGIN   
  --redB in the number of the red block in the diagram
  --The first mux port map is the same for all three blocks
  sm &lt;= y(redB); 
    first : MUX port map(
            a =&gt; x(0),
            b =&gt; '0',
            s0 =&gt; sm,
            y =&gt; out_m(0)
    );

    b0: if redB=0 generate                             --First block - only the first mux has b=0
    rest : for i in 1 to n-1 generate
          chain : MUX port map(
            a =&gt; x(i),
            b =&gt; x(i-1),
            s0 =&gt; sm,
            y =&gt; out_m(i)
          );
     end generate;
    end generate;

    b1: if redB=1 generate 
    rest : for i in 1 to n-1 generate
        what_b &lt;= '0' when i=1 else                    --Second block - 2 first mux has b=0
                      x(i-2);                                              
          chain : MUX port map(
            a =&gt; x(i),
            b =&gt; what_b,
            s0 =&gt; sm,
            y =&gt; out_m(i)
          );
     end generate;
    end generate;

    b2: if redB=2 generate 
    rest : for i in 1 to n-1 generate
       what_b &lt;= '0' when i=1 or i=2 or i=3 else       --Third block - 4 first mux has b=0  
                 x(i-4);
          chain : MUX port map(
            a =&gt; x(i),
            b =&gt; what_b,
            s0 =&gt; sm,
            y =&gt; out_m(i)
          );
     end generate;
    end generate;

END dfl;


In this is the code for changing 3 shifters:


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE work.sample_package.all;

-------------------------------------
ENTITY Barrel IS
  GENERIC (n : INTEGER);
  PORT (    x,y: IN STD_LOGIC_VECTOR (n-1 DOWNTO 0);
            out_shifter0,out_shifter1,out_shifter2: OUT STD_LOGIC_VECTOR(n-1 downto 0));
END Barrel;
--------------------------------------------------------------
ARCHITECTURE dfl OF Barrel IS
SIGNAL temp_out0 : std_logic_vector(n-1 DOWNTO 0);
SIGNAL temp_out1 : std_logic_vector(n-1 DOWNTO 0);
SIGNAL temp_out2 : std_logic_vector(n-1 DOWNTO 0);
BEGIN

  y0: Shifter GENERIC MAP(n) port map (x=&gt;x,y=&gt;y,redB=&gt;0,out_m=&gt;temp_out0);
  out_shifter0 &lt;= temp_out0;
  y1: Shifter GENERIC MAP(n) port map (x=&gt;temp_out0,y=&gt;y,redB=&gt;1,out_m=&gt;temp_out1);
  out_shifter1 &lt;= temp_out1;
  y2: Shifter GENERIC MAP(n) port map (x=&gt;temp_out1,y=&gt;y,redB=&gt;2,out_m=&gt;temp_out2);
  out_shifter2 &lt;= temp_out2;

END dfl;


All the files are compiling, but when I try to run a simulation I get this warning:

# ** Warning: (vsim-8684) No drivers exist on out port /tb/L0/y1/out_m(7 downto 1), and its initial value is not used.
# 
# Therefore, simulation behavior may occur that is not in compliance with
# 
# the VHDL standard as the initial values come from the base signal /tb/L0/temp_out1(7 downto 1).


I am using ModelSim.
Anyone got any idea of what could be the problem?

Thanks! ","You have done a generate with a signal, and compared its value to something. Integers initialise to -2^31, so none of the generate blocks exist because the values you have assigned externally do not get assigned until after the simulation is started, but the generates get created during elaboration (before the simulation starts) using the initial value of redB. Hence no drivers for out_m. Instead of using a signal in the generate condition, use generics instead, as their values are fixed and assigned during elaboration.",,,,,
"Verilog - ""timescale""","Question:

I use ""timescale"" before module to regulate time, but Vivado tell me there is a syntax error at the first row. Please tell me the reason and what should I write?

Display from Vivado:

Error:Syntax Error near """".

Code:

'timescale 1ns/1ns
module datactl (data,in,data_ena);

    output [7:0] data;
    input [7:0] in;
    input data_ena;

    assign data = data_ena?in:8'bzzzz_zzzz;

endmodule
",It looks like you used a single quote ' instead of a backtick `. A compiler directives use a backtick. Note that there's no need for the `timescale directive unless your code has #delays or specify blocks.,,,,,
SV: Error llegal combination of procedural drivers,"Getting a SV: Error illegal combination of procedural drivers error with the below code, any idea how to resolve this?  The values of temp range from 0 to 3.

    module multi_driver_check ();
    reg [7:0] ll_data_map[3:0];
    reg [7:0] data_in[3:0];
    reg [7:0] temp[3:0];
    assign data_in = '{default:0};
    genvar map_i;
    for(map_i=0;map_i&lt;4;map_i++)
    begin
      always_comb
      begin
        if(temp[map_i]==0)
          ll_data_map[0] = data_in[map_i];
        else if(temp[map_i]==1)
          ll_data_map[1] = data_in[map_i];
        else if(temp[map_i]==2)
          ll_data_map[2] = data_in[map_i];
        else
          ll_data_map[3] = data_in[map_i];
     end 
    end
   endmodule
","Reason for Error:
A generate for-loop unravels the code it encapsulates with in it at elaboration time of compile. always_comb make sure that anything it assigns is not assigned anywhere else. In your code is compiled, you effectively have 4 always_combs assigning ll_data_map which is illegal.

Solution:
Move the for-loop inside the always_comb (map_i cannot be a genvar). This way all assignments to ll_data_map is done by a single always_comb.

Other Note:
ll_data_map is not a combinational logic even thought it is defined in an always_comb. The best tools will flag this; worst case it will fail to synthesize because the target devices does not support latches.
To make it proper combinational logic, you could add ll_data_map = '{default:'0}; (or some other deterministic assignment) before starting the for-loop.
If ll_data_map is intended to be a latch, then use always_latch instead of always_comb. (In general RTL design, latches are discouraged but are necessary for certain functionality)",,,,,
Does subtraction need less resource than comparison symbol in verilog?,"I'm working on a project and I'm confused with the verilog code that a senior engineer wrote before, he's not in the company right now so I want to know why he write the comparison in this way:

subtractor #(41) sub_sum(expiredSum, {1'b0,dataRead[39:0]}, {1'b0,timeStandard}); 
assign expiredD = expiredSum[40];//goes high when dataRead&gt;timeStandard


What's the advantage of this? Why didn't he just do 
expiredD == (dataRead &lt; timeStandard);
It a more common way in my opinion.

module subtractor( c, a, b );

parameter WIDTH = 1;

input [WIDTH-1:0] a;
input [WIDTH-1:0] b;

output [WIDTH-1:0] c;

assign c = a - b;

endmodule


Thanks in advance","I have ran into this kind of issue a few time throughout my career. Even if the original engineer was available, it could be challenging to figure out why something was done a particular several projects latter.

Usually the root cause had to do with the timing and/or area challenges with standard cell library or synthesizer. In your specific case it looks like a 40-bit comparator was less efficient than use forced 41-bit subtractor. This could still be the true. 

You should do a trial synthesize and timing analysts. Regardless of the results, add more meaningful comment in the code explaining the rational so it will make sense during code review and whoever will inherit the code latter. Even if the comparator is more efficient this time around. The next technology node or fpga target might be different again. Better to have both with one commented out and good comments explaining it.",,,,,
Why does my Verilog Waveform Suddenly Stop When a Value Changes to 1,"I am creating a pipelined processor with a hazard unit. During the simulation, when Flush = 1, the program waveform halts. I believe there is some sort of infinite loop in my code and this hazard unit does not return any value. In the image, I attached you can see in the value column that Flush becomes 1. But in the module it is called from it is still zero, so it is likely that it loops at this point.

Image of Waveform

`timescale 1ns / 1ps

module Hazard_Unit(input BranchD, MtoRFSelE, MtoRFSelM, RFWEE, RFWEM, RFWEW, RST, input [4:0] RsD, RtD, RsE, RtE, RFAE, RFAM, RFAW,
                   output reg Stall, ForwardAD, ForwardBD, Flush, output reg [1:0] ForwardAE, ForwardBE);

reg LWStall, BRStall;

always @(*) begin
    if (RST) begin
        ForwardAD = 1'b0;
        ForwardBD = 1'b0;
        ForwardAE = 2'b00;
        ForwardBE = 2'b00;
        LWStall = 1'b0;
        BRStall = 1'b0;
        Stall = 1'b0;
        Flush = 1'b0;
    end

    else begin
        if ((RsE != 0) &amp;&amp; RFWEM &amp;&amp; (RsE == RFAM)) ForwardAE = 2'b10;
        else if ((RsE != 0) &amp;&amp; RFWEW &amp;&amp; (RsE == RFAW)) ForwardAE = 2'b01;
        else ForwardAE = 2'b00;

        if ((RtE != 0) &amp;&amp; RFWEM &amp;&amp; (RtE == RFAM)) ForwardBE = 2'b10;
        else if ((RtE != 0) &amp;&amp; RFWEW &amp;&amp; (RtE == RFAW)) ForwardBE = 2'b01;
        else ForwardBE = 2'b00;

        if (MtoRFSelE &amp;&amp; ((RtE == RsD) || (RtE == RtD))) LWStall = 1'b1;
        else LWStall = 1'b0;

        if ((RsD != 0) &amp;&amp; (RsD == RFAM) &amp;&amp; RFWEM) ForwardAD = 1'b1;
        else ForwardAD = 1'b0;

        if ((RtD != 0) &amp;&amp; (RtD == RFAM) &amp;&amp; RFWEM) ForwardBD = 1'b1;
        else ForwardBD = 1'b0;

        if ((RsD == RFAE || RtD == RFAE) &amp;&amp; BranchD &amp;&amp; RFWEE || (RsD == RFAM || RtD == RFAM) &amp;&amp; BranchD &amp;&amp; MtoRFSelM) BRStall = 1'b1;
        else BRStall = 1'b0;

        if (LWStall || BRStall) begin
            Flush = 1'b1;
            Stall = 1'b0;
        end
        else begin
            Flush = 1'b0;
            Stall = 1'b1;
        end
    end
end
endmodule
","Indeed it is likely that you have a combinatorial loop. 

I could search where it is, but I prefer to give you a general method to solve these issues. This one I use if it happens to me (once in a blue moon :-)


Make sure you use a clock which is long enough. e.g. 100 or 500 time units. This is in general a good practice. A clock time of 1 high and 1 low is a disaster in the making. Your simulation will not run any slower because of this
Put a #5 between statements.

if ((RsE != 0) &amp;&amp; RFWEM &amp;&amp; (RsE == RFAM)) ForwardAE = 2'b10;
else if ((RsE != 0) &amp;&amp; RFWEW &amp;&amp; (RsE == RFAW)) ForwardAE = 2'b01;
else ForwardAE = 2'b00;
#5;

if ((RtE != 0) &amp;&amp; RFWEM &amp;&amp; (RtE == RFAM)) ForwardBE = 2'b10;
else if ((RtE != 0) &amp;&amp; RFWEW &amp;&amp; (RtE == RFAW)) ForwardBE = 2'b01;
else ForwardBE = 2'b00;
#5;
...



Now your waveform is likely to keep running and show you where the oscillation is. Don't forget to remove the #5 again once you have fixed the code.

Next point:
Your code is generally wrong. You are producing lots of latches in that if statement. Every one of your variables ForwardAD, ForwardBD, ForwardAE ... must be assigned a value in each if statement. Or you should start with giving them a default value right after the else:

else begin
    ForwardAD = ..;
    ForwardBD = ..;
    ForwardAE = .;
    ...
    if ((RsE != 0) &amp;....


If you can't do that, probably the whole section should be a clocked statement:

always @(posedge some_clock) begin
",,,,,
One IMP_PORT connected to multiple EXPORTS,"I am creating a scoreboard which has a single implication port. I want to connect multiple exports from a parent class to the same imp port of the scoreboard class I am writing. Essentially (in pseudo-code):

class parent_class extends uvm_scoreboard;

  uvm_analysis_export #(my_type) export0;
  uvm_analysis_export #(my_type) export1;
  uvm_analysis_export #(my_type) export2;
  uvm_analysis_export #(my_type) export3;

  my_scoreboard m_scb;

  function void connect_phase(uvm_phase phase);
    export0.connect(m_scb.my_imp);
    export1.connect(m_scb.my_imp);
    export2.connect(m_scb.my_imp);
    export3.connect(m_scb.my_imp);

  endfunction
endclass

class my_scoreboard extends uvm_scoreboard;

  uvm_analysis_imp#(my_type) my_imp;

  function void write (my_type);
    // do something here
  endfunction

endclass


This works fine but I am wondering now, if we get 2 or 3 or 4 transactions broadcasted from their ports on the same clock cycle, will the write function be called twice/thrice/4times? This is the behaviour I would want.

I don't have a dependency on the order in which they are called but don't want to miss a broadcast because of my setup.","Yes, you can have multiple write()s called in an indeterminate order. If the scoreboard needs to know which port it came from, you will have to put that information in the transaction. ",,,,,
What does this {} means after parameter in verilog?,"module test #(parameter WIDTH = 4) (output wire [WIDTH-1:0] result, input wire input );
// synopsys template
assign result = {WIDTH{input}};
endmodule


In this code, {input} after WIDTH means what? In what way that affects the parameter?","The curly brackets, preceded by the parameter, are called the replication operator. 

assign result = {WIDTH{input}};


makes WIDTH copies of the 1-bit input-signal and assigns it to the WIDTH-bit output signal result. This means that input does thus not affect the parameter like you suspected in your question. Rather, the parameter affects how many copies of input are made.

For future reference please also consult the SystemVerilog LRM. Simple syntax-related questions like yours can be easily looked up in that document. For example, take a look at Section 11.4.12.1 Replication operation in the document that I referenced.",,,,,
"endfile not detected in the VHDL testbench in modelsim, the testbench just keeps repeating it self indefinetly","I wrote a VHDL code that should loop through a file and close the file and stop after the file ends and closes the file but it just keeps looping indefinitely reading from the file

            FILE f               : TEXT;
            constant filename    : string :=""input.txt"";
            VARIABLE L           : LINE;
            variable al          : integer ;
            variable opcode_str  : string(5 downto 1);
            variable comma       : character;

            begin
            File_Open (f,FILENAME, read_mode);  
                while not endfile(f) loop
                readline (f, l);
                read(l, opcode_str);
                read(l, comma);
                read(l, Al);
                op_code&lt;= read_opcode(opcode_str);      
                w_tb &lt;=std_logic_vector(to_unsigned(Al, w_tb'length));
                  wait for 10 ns;
            end loop;
            File_Close (f);
        end process
","Your process has no wait statement at the end of the process. All processes with no sensitivity list are infinite loops.

Simply add the statement

wait;  -- waits forever


at the end of the process.",,,,,
Verilog: assigning value to reg,"I have this very beginner question about Verilog and I would love some help, please.

Below you can see the code for a simple counter which has:


input: single clock signal, connected to the clock
input: reset signal, which is connected to a physical button
output: the counter output
output: led equal to reset input


The odd behaviour is that when the reset signal is high, the counter doesn't reset to zero.
On the board I can see the led switching  on and off when I press the button so reset is true, but the if instruction internal_counter &lt;= 0; is not executed (?)

I'm using Quartus Prime II Lite with a DE-10 Nano Terasic Board 

Any suggestion, please? Thanks!

//Single clock input and a 32bit output port
    //reset will zero the internal_counter 
    module simple_counter (
                                    CLOCK_50,
                                    counter_out,
                                    reset,
                                    led
                                );          

    input CLOCK_50 ;
    input reset ;
    output led;
    output [31:0] counter_out;
    reg [31:0] counter_out;
    reg [31:0] internal_counter;
    reg led;

    always @ (posedge CLOCK_50) // on positive clock edge
        begin
            if (reset)
                        internal_counter &lt;= 0;

            led &lt;= reset;
            internal_counter &lt;= internal_counter + 1;
            counter_out &lt;= internal_counter;// increment counter
        end

    endmodule // end of module counter
","Your code does not work because you make two assignments to internal_counter. This is allowed but the rule is that the last assignment ""wins"".

So let's step through the code when the reset is active:

if (reset)   
  internal_counter &lt;= 0; 


This makes that the internal_counter is reset (set to zero).
But later we get another assignment:

internal_counter &lt;= internal_counter + 1;


As this one is later/behind the previous assignment it ""wins"". There is no condition here so this always replaces the previous if .... With that the if... code becomes superfluous. It is never executed and the synthesis tool will remove any logic for that.

As others have pointed out: you need an else section. It is good practice to reset all the variables in the reset section:

always @ (posedge CLOCK_50) // on positive clock edge
begin
   if (reset)
   begin
      internal_counter &lt;= 0;
      led &lt;= 1'b1; 
      counter_out  &lt;= 0;
   end // reset section
   else
   begin // clocked section
      internal_counter &lt;= internal_counter + 1;
      led &lt;= 1'b0; 
      counter_out &lt;= internal_counter; 
   end
end // clocked section 


Now we get some general remarks:

I suggest you switch to ANSI port definitions. It is easier as you keep everything together. If you need to change e.g. the width of counter_out you can do that in one place:

module simple_counter (
    input      CLOCK_50 ,
    input      reset ,
    output reg led,
    output reg [31:0] counter_out  
   ); 


Your led is a bit weird. It is high on reset, low otherwise. I assume you did this for debugging.

Thecounter_out is always one value behind the internal_counter. Is this what you want? It also costs you 32 extra registers. I would expect to do without the internal counter and use the counter_out direct:  

always @ (posedge CLOCK_50) // on positive clock edge
begin
   if (reset)
   begin
      led &lt;= 1'b1; 
      counter_out  &lt;= 0;
   end // reset section
   else
   begin // clocked section
      led &lt;= 1'b0; 
      counter_out &lt;= counter_out + 1; 
   end
end // clocked section 
",,,,,
Reading a file in GHDL/VHDL,"I am working on reading a text file in vhdl. There are many examples on this, but I am curious  why this minimal showcase example doesn't work in GHDL. It works in ModelSim (by Mentor).


Is this because of missing features in GHDL? (I did not find anything in docs/ github issues)
Is this because of wrong standard that I am using without knowing?


library IEEE;
use IEEE.STD_LOGIC_1164.all;
use STD.textio.all;

entity test is
end test;

architecture behavioral of test is
    file input : text;
begin
    process
    variable line_in : line;
    begin
        file_open(input, ""input.txt"");
        while not endfile(input) loop
            readline(input, line_in); 
        end loop;
        wait for 100 ns;
    end process;

end behavioral;


The output I get is:

./test:error: cannot open file ""input.txt""


This means, there is no file/cannot be opened, but the file exists with correct access rights (proven in Modelsim). I tried this with full file name, too.

I'm using GHDL 0.37 on Linux with these flags:
--ieee=synopsys --std=08

If

   file input : text;


is replaced with

    file input : text open read_mode is ""input.txt"";


and

        file_open(input, ""input.txt"");


is removed it works in GHDL.

However, I still don't know why the previous version did not work.","The example code is expected to fail. Note the lack of a procedure file_close call.

After the execution of the wait for 100 ns; wait statement the execution of the process statement will resume in a future simulation cycle. The statements in a process are executed in order and after the last statement (the wait statement) the first statement 

        file_open(input, ""input.txt"");


will be executed again.

Without an intervening file_close call a subsequent file_open call will fail.

IEEE Std 1076-2008

10.2 Wait statement


  The timeout clause specifies the maximum amount of time the process will remain suspended at this wait statement. If no timeout clause appears, the timeout clause for (STD.STANDARD.TIME'HIGH â€?STD.STANDARD.NOW) is assumed. It is an error if the time expression in the timeout clause evaluates to a negative value.


11.3 Process statement


  The execution of a process statement consists of the repetitive execution of its sequence of statements. After the last statement in the sequence of statements of a process statement is executed, execution will immediately continue with the first statement in the sequence of statements.


5.5.2 File operations:


  In the second form of FILE_OPEN, the value returned through the Status parameter indicates the results of the procedure call:  
  
  
    â€?A value of OPEN_OK indicates that the call to FILE_OPEN was successful. If the call to FILE_OPEN specifies an external file that does not exist at the beginning of the call, and if the access mode of the file object passed to the call is write-only, then the external file is created.
    â€?A value of STATUS_ERROR indicates that the file object already has an external file associated with it.
    â€?A value of NAME_ERROR indicates that the external file does not exist (in the case of an attempt to read from the external file) or the external file cannot be created (in the case of an attempt to write or append to an external file that does not exist). This value is also returned if the external file cannot be associated with the file object for any reason.
    â€?A value of MODE_ERROR indicates that the external file cannot be opened with the requested Open_Kind.  
  
  
  The first form of FILE_OPEN causes an error to occur if the second form of FILE_OPEN, when called under identical conditions, would return a Status value other than OPEN_OK.


The question use of the file_open procedure call is of the first form.  The second form would fail returning a Status parameter value of STATUS_ERROR, already associating an external file with the file object input.

The fix for that would be to transform the wait statement to prevent the process from continuing to execute:

        wait; -- wait for 100 ns;
    end process;


or provide an explicit file_close call so a subsequent file_open call would succeed. (This would cause a lot of host activity for no useful purpose.)

The modified code could look like:

-- library IEEE;
-- use IEEE.STD_LOGIC_1164.all;  -- NOT USED
use STD.textio.all;

entity test is
end test;

architecture behavioral of test is
    file input : text;
begin
    process
    variable line_in : line;
    begin
        file_open(input, ""input.txt"");
        while not endfile(input) loop
            readline(input, line_in);
            write (OUTPUT, line_in.all &amp; LF);
        end loop;
        wait; -- wait for 100 ns;  -- EXECUTE ONCE
    end process;

end behavioral;


Yields:

%% ghdl -a --ieee=synopsys  --std=08 test.vhdl
%% ghdl -e --ieee=synopsys  --std=08 test
%% ghdl -r --std=08 test
some text
more text
yet some more text
getting boring
%% 


Where a write to the file OUTPUT (the console) echos the contents of each line found in input.txt. Note that the end of line is removed by the readline procedure call and reintroduced to the string being written to OUTPUT.

So why does the different file declaration succeed? 

architecture file_declaration of test is
    -- file input : text;
    file input:     text open read_mode is ""input.txt"";
begin
    process
    variable line_in:   line;
    begin
        -- file_open(input, ""input.txt"");
        while not endfile(input) loop
            readline(input, line_in);
            write (OUTPUT, line_in.all &amp; LF);
        end loop;
        wait for 100 ns;
    end process;

end architecture file_declaration;


There's only one call to file_open, an implicit call during elaboration of the file declaration (6.4.2.5 File declarations). The file remains open yet there are no remaining lines to read, determined by the endfile call. Here the endfile call would occur every 100 ns, which would likely result in your CPU utilization to increase as test executes until TIME'HIGH is reached. Performing the endfile call would result in host file operations resulting in suspension and resumption of the ghdl model execution. An effective test of only making endfile procedure calls. 

A wait statement (10.2) without a timeout clause (for 100 ns) will wait until TIME'HIGH effective ending the simulation without any intervening signal events or other process suspensions and resumptions or making TIME'HIGH/100 ns - 1 endfile procedure calls, each involving suspension and resumption of the shown process statement.

You could also specify a simulation stop time on ghdl's command line, matching the usage in Modelsim most likely:

%% ghdl -a --ieee=synopsys  --std=08 test.vhdl
%% ghdl -e --ieee=synopsys  --std=08 test
%% ghdl -r --std=08 test --stop-time=300ns
some text
more text
yet some more text
getting boring
./test:info: simulation stopped by --stop-time @300ns
%% 


Host file operations can incur a significant execution time penalty. If you were to assign the read values to a signal or variable of a composite (array or record) type object they can be reused without waiting on host file operations.",,,,,
Driving an LED from a switch,"I have been studying Verilog with Altera's Quartus II in combination with the terASIC DE10 board, but now something unexpected is happening.

For the sake of debugging, I am driving an LED through a switch, and between the two, I have inserted a module:
switch-module-led

The module code is as below, where the value of the variable to_led is updated every time in_clock_counter[0] change.

module in_out (
                input [31:0] in_clock_counter,
                input from_switch,
                output reg to_led
    );



always @ (posedge in_clock_counter)
    begin
        if (from_switch)
            to_led &lt;= 1'b1;
        else
            to_led &lt;= 1'b0;
    end 

endmodule 


I would expect that if I press the switch, the LED would be lit. But, this is not the case.
Using Simulation Waveform Editor I can see that the LED value changes.  What am I doing wrong?","
  and the system works as intended


Happy you got it working.


  isn't it a PLL block necessary to create a constant clock frequency? I thought so.


No, the best, most stable clock is the one that come straight from your oscillator.
The PLL allows you to make different frequencies from that clock (other then the usual: divide-by-2, divide-by-3 etc.)

For example, some allow you to make something as weird as a 23/3 times clock. Thus also a higher frequency.  (In fact that is where the 3GHz processors get their clock from.) But the jitter specs will always be worse then your crystal. 

But still that code should work from the PLL clock so I suspect something else is still wrong. I suggest you have a look at the synthesized netlist (schematic). And check what is all connected where. ",,,,,
Understanding the SB_IO primitive in Lattice ICE40,"I am playing with cliffordwolf/picorv32 and am having some problem understanding the following snippet in picosoc (link to source):

SB_IO #(
    .PIN_TYPE(6'b 1010_01),
    .PULLUP(1'b 0)
) flash_io_buf [3:0] (
    .PACKAGE_PIN({flash_io3, flash_io2, flash_io1, flash_io0}),
    .OUTPUT_ENABLE({flash_io3_oe, flash_io2_oe, flash_io1_oe, flash_io0_oe}),
    .D_OUT_0({flash_io3_do, flash_io2_do, flash_io1_do, flash_io0_do}),
    .D_IN_0({flash_io3_di, flash_io2_di, flash_io1_di, flash_io0_di})
);


I have found a graphic description for the SB_IO primitive in Lattice iCE40 technology library documentation, but I still cannot understand its purpose because it's too complex for me to interpret. There is another question about the primitive, after reading which I would assume it creates some kind of bidirectional connection, but I failed to understand how that is related to making the output pin ""tristated"".

I would appreciate a high-level description of the effect of the SB_IO cell under this particular configuration. Which pin is connected to which pin? Which are inputs and which are outputs? What is the purpose of instantiating this cell?","This instance was used because at the time Yosys didn't support tristates in Verilog well enough, it does now but in general tristate support in FPGA toolchains isn't always trusted.

It could be replaced with the following generic Verilog, repeated 4 times from 0 to 4.

assign flash_io0 = flash_io0_oe ? flash_io0_do : 1'bz;
assign flash_io0_di = flash_io0;
",,,,,
How to convert std_logic to unsigned in an expression,"So if wanted to assign a std_logic to a 1-bit usnigned I could just write...

signal X : unsigned(0 downto 0);
signal Y : std_logic;

X(0) &lt;= unsigned(Y)


But what s the best way to convert a std_logic to an unsigned when used in an expression.
That is to say, without directly doing an assignment to a signal of type unsigned.

The scenario I have is this.  I have two flags A and B that are signals of type std_logic.
Each flag has a strobe (A_valid , B_valid) of type std_logic that assert for 1 clock cycle each time their flag (A , B) is valid.
I have a counter (CNT) that is a signal of type unsigned that must count the number of times that either of the flags is '1'.
On any given clock cycle I must incrment CNT by 0, 1, or 2 depending on how many flags are 1.

Here is the straight forward way of doing it with an ""if"" statement.

signal A       : std_logic;
signal A_valid : std_logic;
signal B       : std_logic;
signal B_valid : std_logic;
signal CNT     : unsigned;

if rising_edge(clk) then
  if (A and A_valid and B and B_valid) = '1' then
    CNT &lt;= CNT + 2;
  elsif (A and A_valid) = '1' then
    CNT &lt;= CNT + 1;
  elsif (B and B_valid) = '1' then
    CNT &lt;= CNT + 1;
  end if;
end if;


The problem with the code above is that it doesn't generalize very well since the number of cases goes up exponentially with the number of flags.  For example if I had 5 flags I would have to write out 32 branches in the IF statement.

A more compact way of representing the same thing using an aggregate and a type mark is...
This is better becasue I just write one expression for each flag.

if rising_edge(clk) then
  CNT &lt;= CNT + unsigned'(0=&gt; A AND A_valid) + unsigned'(0=&gt; B AND B_valid);
end if;


Are there any other built-in ways (other than writing a function) to convert std_logic to unsigned in an expression in VHDL?","The easiest way is to concatenate the std_logic with a null array,  yielding an array of length 1. 

Cnt &lt;= cnt + ("""" &amp; a_valid);

It should be able to work out the type from the context,  otherwise you may need to qualify it with unsigned'",,,,,
Does Verilog Module Instantiation Order Matter?,"module parity (
a      , // First input
b      , // Second input 
c      , // Third Input
d      , // Fourth Input
y        // Parity  output
);

// Input Declaration
input       a       ;
input       b       ;
input       c       ;
input       d       ;
// Ouput Declaration
output      y      ;
// port data types
wire        a        ;
wire        b        ;
wire        c        ;
wire        d        ;
wire        y        ;
// Internal variables
wire        out_0 ;

wire        out_1 ;

// Code starts Here
xor u0 (out_0,a,b);

xor u1 (out_1,c,d);

xor u2 (y,out_0,out_1);

endmodule // End Of Module parity 


Suppose I have the module above. Does the order of the xor  module declarations matter? If I reordered the declarations likes so:

xor u1 (out_1,c,d);

xor u2 (y,out_0,out_1);

xor u0 (out_0,a,b);


Would the synthesized circuit be the same?","The Verilog language is used to describe behavior of connected hardware-like elements and algorithms. The connections define how the elements are evaluated during simulation and how they are synthesized. The simulation scheduling (and hardware behavior) is based on the events which happen in the connection network.

Therefore, the order in which you instantiate those elements is irrelevant, if you connect them right. For example

module a(input i, output o);
endmodule

module b(input i, output o);
endmodule

module top(input i, output o);
  a a1(i, t);
  b b1(t, o);
endmodule


as soon as output of the module a a1 is connected to the input of module b b1, it will behave the same as in here:

module top(input i, output o);
  b b1(t, o);
  a a1(i, t);
endmodule


for readability reasons, you might prefer the first version though.",,,,,
System Verilog to Specman E,"What is the equivalent syntax in Specman E for $readmemh(file,array) and similar system tasks and functions in System verilog?

I am working in converting the existing System verilog code into Specman E ,I have converted and implemented most of the concepts except few system methods like below .Please help me to implement methods like below in Specman E.

$readmemh(file_s,data_2d_i);//For converting SV code into Specman E
","In the vr_ad Package there is an equivalent method. Assuming you have a vr_ad_mem object called data_2d_i, you can e.g. call

data_2d_i.readmemh(file_s,0,1000,0,1000);


To read addresses 0..1000 from that file into memory.

Example:

import vr_ad/e/vr_ad_top;
extend sys {
   mem: vr_ad_mem;
   keep mem.addressing_width_in_bytes == 1;
   keep mem.size == 1000;

   run() is also {
      var data_2d_l: list of byte;
      -- read first 16 bytes of mem-file and store the result in a list
      mem.readmemh(""mem.txt"", 0, 15, 0, 15);
      data_2d_l = mem.fetch(0, 16);
      print data_2d_l;
   };
};
",,,,,
VUnit test sequential components,"How to test sequential components properly with VUnit testing library and using VHDL? I've been using it to test combinatorial components using wait for statements etc. Example of it here in my github repo.

Obviously I've to generate a clock signal with clk &lt;= not clk after half_period; but how to wait for it? Do I write something like wait until rising_edge(clk). But if I want to advance clock by multiple clock cycles? Is there better way than copy above line multiple times?","If you're using VUnit you already have such a procedure available. VUnit ships with the OSVVM library for its randomization features but it also contains other stuff, for example WaitForClock. To enable OSVVM you need to add the following in your Python script.

ui = VUnit.from_argv()
ui.add_osvvm()
",,,,,
Trying to finish adder need if statement to change carry,"I have got an adder with inputs a and b in std_logic_vector(data_width-1) downto 0 and out output of sum std_logic_vector(data_width) downto 0. I am trying to use an if statement to bypass the carry bit and add it to the sum

I just need help with the syntax the idea is if the carry's MSB is 1 the it adds 1 to the answer(sum)

architecture v1 of adding is
begin
adding : process (A, B) is
    variable CI :  std_logic_vector((DATA_WIDTH) downto 0);
    variable SUMMER :  std_logic_vector((DATA_WIDTH) downto 0);
begin   
            SUMMER := A xor B;
            CI := A and B;
            CI_msb &lt;= CI(CI'left);
            if CI_msb =  '1' then
                SUMMER = SUMMER + 1;
            end if;


I am getting syntax errors regarding (summer = summer + 1;) I am not familiar enough to know what is needed.","To assign a value to a variable you have to use :=, so the code becomes SUMMER := SUMMER + 1;.",,,,,
How to move the numerical calculation part from VHDL code to C can run it on NEXY3 Spartan 6 board,"I am currently working on a project which requires to use a embedded soft core. I wrote a pong game using VHDL (ISE) and synthesised it onto the FPGA, the next step is going to shift the numerical calculation part to soft core which means i need to rewirte this code in C. However, ISE can not achieve this function, what design suite (software) i can use? Can EDK work? ",You have to add a soft processor to your project using EDK and synthesize the new project. Then you can write the software code to run on the soft processor using SDK (Software Development Kit).,,,,,
Verilog LED Blinking no syntax errors. why it is not blinking,"I wrote the program for blink 8 raw LEDs and code has not any errors and it is properly loaded. But blinking LEDs is not happen properly.

I checked pin planner and it was correct and clock I used is 50MHz. I am using the DE10 lite board.

module LED_blink(clk,led);
    input clk;
    output reg[7:0] led;
    reg[31:0] count = 0;
    always @(posedge clk)
      begin
        count &lt;= count + 1;
        led &lt;= (count&lt;50000000) ? 8'b11111111 : 0;
        count &lt;= (count&lt;50000000) ? count : 0;      
      end
endmodule


There are no error messages but it is not working the way I assumed.","You should get the habit of simulating your code with a testbench before running it on an FPGA. But in this case even a simple Rubber Duck Debugging shows the errors.
When you execute count&lt;=(count&lt;50000000)?count:0; you override the previous count&lt;=count+1;, thus the count will never increment.

This can be easily fixed by changing the 2 lines to: 

count&lt;=(count&lt;50000000)?count+1:0;


The second problem is that led will be 0 only for one clock cycle (when count is equal to 50000000), practically you won't see any blinking.
This can be easily fixed by changing the line to: 

led&lt;=(count&lt;25000000)?8'b11111111:0;
",,,,,
Implementing a short pulse signal triggered by a push button on a Spartan 3E,"I'm trying to implement an ""emergency"" function on a traffic light controller.

This emergency signal is an std_logic input, and it's triggered by a push button (using a ucf file).

What this signal does is basically whenever the push button is pressed, the controller will detect which of the two roads (north to south or west to east)  is on red and it'll immediately switch it to orange (the other one , of course, will turn red) to let the emergency vehicle pass (an ambulance, for example).

I've tried to denounce the switch and then feed the denounced signal into a rising-edge detector. It didn't work: pressing the emergency button makes the red and yellow lights of both roads (NS and WE) light at the same time, just a disaster, the counter which I used to configure how long each light is on also gets disturbed for quite a while before going back to normal.  

Here's my code so far:


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;

entity TLC is
    Port (    
               Clck : in  STD_LOGIC;
               Reset: in  STD_LOGIC;
               emergency:in std_logic;

               Trafficlights: out  STD_LOGIC_Vector (5 downto 0)  --trafficlights (5 downto 3) for the NS road and (2 downto 0) for the WE road.

             );
 end TLC;

architecture Behavioral of TLC is


-------------for debouncing
constant COUNT_MAX : integer := 20; 

constant BTN_ACTIVE : std_logic := '1';

signal count1 : integer := 0;
type   state_type1 is (idle,wait_time); 
signal state1 : state_type1 := idle;
signal emergency_debounced:std_logic;
-----------------------------------------


  type state_type is (NRWG, NRWY, NGWR, NYWR); --NRWG: North-South on red and West-East on green and so on.
  signal one_second_counter: STD_LOGIC_vector(25 downto 0):=""00000000000000000000000000"";

  signal one_second_enable: std_logic;


  signal state: state_type:=NRWG; 
  signal count : std_logic_vector (3 downto 0);

  constant sec8 : std_logic_vector ( 3 downto 0) := ""1000"";
  constant sec3 : std_logic_vector (3 downto 0 ) := ""0011"";
  constant sec11: std_logic_vector (3 downto 0 ) := ""1011"";



--edge detector signals
 signal emergencya, emergencyb, emergencyc: std_logic;
----------

begin

controller: process (Clck,reset,emergencyc)

 begin

  if emergencyc='1' then

   if state=NRWG or state=NRWY then ----if NS is on red then switch it to yellow.
         state&lt;=NYWR;
            count&lt;=x""0"";
   else
       if state=NGWR or state=NYWR then  ----if WE is on red then switch it to yellow.
          state&lt;=NRWY; 
             count&lt;=x""0"";

      end if;
   end if;


  elsif reset ='1' then

      state&lt;=NRWG;
      count&lt;=X""0"";


  else
    if rising_edge(clck) then
     if one_second_enable='1' then
       case state is              
         when  NRWG =&gt;
           if count &lt; sec8 then
             state &lt;= NRWG;
             count &lt;= count + 1;                
           else  
             state &lt;= NRWY;
             count &lt;= X""0"";
           end if;

         when NRWY =&gt;
           if count &lt; sec3 then
             state &lt;=  NRWY;
             count &lt;= count + 1;
           else
             state &lt;= NGWR;
             count &lt;= X""0"";
           end if;

         when NGWR =&gt;
           if count &lt; sec11 then
             state &lt;= NGWR;
             count &lt;= count + 1;
           else
             state &lt;= NYWR;
             count &lt;= X""0"";
           end if;

         when NYWR =&gt;   
           if count &lt; sec3 then
             state &lt;=  NYWR;
             count &lt;= count + 1;
           else
             state &lt;=NRWG;
             count &lt;= X""0"";
           end if; 

         when others =&gt;
           state &lt;= NRWG;
       end case;      
     end if;
    end if;
  end if;

end process;



-----------decode state
   OUTPUT_DECODE: process (state)
   begin
     case state is 
       when NRWG =&gt;    Trafficlights &lt;= ""100001"";   
       when NRWY =&gt;    Trafficlights &lt;= ""100010"";
       when NGWR =&gt;    Trafficlights &lt;= ""001100"";
       when NYWR =&gt;    Trafficlights &lt;= ""010100"";
       when others =&gt;  Trafficlights &lt;= ""100001"";
     end case; 
   end process;
--------------------------------






--------------Slow_Clock-------------

slow_clock:process(clck) begin
if(rising_edge(clck)) then
            if(one_second_counter=""10111110101111000010000000"") then

                one_second_counter &lt;=""00000000000000000000000000"";
            else
                one_second_counter &lt;= one_second_counter +1;
            end if;
        end if;
end process;

one_second_enable &lt;= '1' when one_second_counter=""10111110101111000010000000"" else '0';
--------------------------------------------------- 








-----------------for debouncing---------------
debounce_emergency:process(clck) 

begin
if(rising_edge(Clck)) then
        case (state1) is
            when idle =&gt;
                if(emergency = BTN_ACTIVE) then  
                    state1 &lt;= wait_time;
                else
                    state1 &lt;= idle; 
                end if;
                emergency_debounced &lt;= '0';
            when wait_time =&gt;
                if(count1 = COUNT_MAX) then
                    count1 &lt;= 0;
                    if(emergency = BTN_ACTIVE) then
                        emergency_debounced &lt;= '1';
                    end if;
                    state1 &lt;= idle;  
                else
                    count1 &lt;= count1 + 1;
                end if; 
        end case;       
    end if;        
end process;
------------------------------------------------------------

---------edge_detector--------
edge_detection:process (clck) 

begin

  if(rising_edge(clck)) then
    emergencya &lt;= emergency_debounced;
    emergencyb &lt;= emergencya;
  end if;

end process ;

emergencyc &lt;= not emergencyb and emergencya;
---------------------------------

 end Behavioral;



Any ideas as to why the emergency function doesn't work the way it supposed to?","Your debounce_emergency:process is wrong in many ways. I suggest you simulate your design to see it. What happens if the emergency button is pressed for 40 clock cycles? 

Moreover in the controller: process the if emergencyc='1' ... part must be inside the if rising_edge(clck) otherwise will trigger multiple changes in the state signal.",,,,,
Why do incomplete if statements create latches during synthesis in VHDL?,"Why is it when we try to synthesize incomplete if statements in VHDL the synthesizer uses latches instead of flip-flops? 

An explanation from a digital/circuit standpoint would be greatly appreciated.","Short answer: because the behaviour of a latch matches that of an incomplete IF. A register does not. 

if (A)
   B = C;


If the condition A is true and C changes, the output B follows the input immediately. If A is false B keeps it value. This behavior of the IF statement corresponds with the behavior of a latch. Thus a latch is what is generated.

You can not generate this behaviour with a register.",,,,,
Weird behavior of registers on Quartus II using Verilog,"I'm creating my own processor based on MIPS32 using the Quartus II and Verilog. Everything was working fine until suddenly my Registers stopped working (I don't remember making any modifications to the code). I probably made some mistake but I can't seem to find it.

I've already tried using an older version of the code (that was 100% working) but the error persists, even when I'm testing the registers isolated from the rest of the system. I've also tried deleting Quartus' temporary files and recompiling with no success.

    module RegFile
    (
        output [31:0] Debug2,       //Outputs Reg 2
        output [31:0] Debug3,       //Outputs Reg 3
        input Reset,                //Makes sure Reg 0 is always 0
        input Slow_Clock,           //Write Clock
        input Fast_Clock,           //Read Clock
        input Reg_Write,            //Write to Reg Flag
        input [31:0] Write_Data,    //Data that will be written in the Reg selected by Reg_WR
        input [5:0] Reg_1,          //First Register Selection (Read)
        input [5:0] Reg_2,          //Second Register Selection (Read)
        input [5:0] Reg_WR,         //Third Register Selection (Read or Write)
        output reg [31:0] Data_1,   //Data that will outputted by the Reg selected by Reg_1
        output reg [31:0] Data_2,   //Data that will outputted by the Reg selected by Reg_2
        output reg [31:0] Data_3    //Data that will outputted by the Reg selected by Reg_WR
    );


    reg [31:0] DataReg[63:0];       //64x 32bit Register

    assign Debug2 = DataReg[2]; //Hardwired Reg2 (for testing)
    assign Debug3 = DataReg[3]; //Hardwired Reg3 (for testing)

    always @ (posedge Fast_Clock)   //Reads from Registers at posedge Read Clock
    begin
        Data_1 &lt;= DataReg[Reg_1];
        Data_2 &lt;= DataReg[Reg_2];
        Data_3 &lt;= DataReg[Reg_WR];
    end

    always @ (negedge Slow_Clock) //Writes on Registers at negedge Write Clock
    begin
        if (Reset)
        begin
            DataReg[0] &lt;= 32'b00000000_00000000_00000000_00000000; //Forces Reg0 to be 0 when Reset is activated
        end
        else if (Reg_Write &amp;&amp; (Reg_WR != 0)) //If you are writing to some register and this register isn't Reg0...
        begin
            DataReg[Reg_WR] &lt;= Write_Data; //...write to the register selected by Reg_WR
        end
    end

    endmodule






I expect the ending result to be the number 3 on register 2 and the number 4 on register 3 but, as you can see, register 2 ends with the number 4 and the register 3 ends with the number 0.","I figured it out.

There was an inconsistency when writing and loading the new values in the next clock.

I fixed it by creating two aux. variables that hold Write_Data and Reg_WR until right before writing and updating the values. I used a faster clock to be able to keep these aux. variables updated.

This is the solution I found:

module RegFile
(
    //output [31:0] Debug2,       //Outputs Reg 2
    output [31:0] Debug3,       //Outputs Reg 3
    input Reset,                //Makes sure Reg 0 is always 0
    input Slow_Clock,             //Write Clock
    input Fast_Clock,
     input Reg_Write,            //Write to Reg Flag
    input [31:0] Write_Data,    //Data that will be written in the Reg selected by Reg_WR
    input [5:0] Reg_1,          //First Register Selection (Read)
    input [5:0] Reg_2,          //Second Register Selection (Read)
    input [5:0] Reg_WR,         //Third Register Selection (Read or Write)
    output [31:0] Data_1,         //Data that will outputted by the Reg selected by Reg_1
    output [31:0] Data_2,       //Data that will outputted by the Reg selected by Reg_2
    output [31:0] Data_3        //Data that will outputted by the Reg selected by Reg_WR
);

reg [31:0] RegBank[63:0];

reg [31:0] Aux_WD;
reg [5:0] Aux_Reg;

assign Data_1 = RegBank[Reg_1];
assign Data_2 = RegBank[Reg_2];
assign Data_3 = RegBank[Reg_WR];

//assign Debug2 = RegBank[2];
assign Debug3 = RegBank[3];

always @ (negedge Fast_Clock)
begin
    Aux_WD &lt;= Write_Data;
    Aux_Reg &lt;= Reg_WR;
end

always @ (negedge Slow_Clock)
begin
    if (Reset)
    begin
        RegBank[0] &lt;= {32{1'b0}};
    end
    else if (Reg_Write &amp;&amp; (Aux_Reg != 6'b000000))
    begin
        RegBank[Aux_Reg] &lt;= Aux_WD;
    end
end

endmodule
",,,,,
Delay in Simulation of Output with regard to Input,"I am making a MultiLevel Car Parking system module with consist of common entry and exit, The idea is that, when I get input stimulus  from signal car entry or car exit, It will check the car's Type and then the output should display the level reserved for the particular type where, the car should go, If the slots reserves for particular type is full then the display should output as such. The code gets stimulated through the output gets displayed only after the next clock cycle after the input stimulus is given.

I have tried using a different if-else block for counting operations and also with different process using a flag, and tried to change it to different if-else blocks, but it's still the same. I am beginner to vhdl the execution of statements is quite confusing, and online search is of little help, please help me where did I go wrong?

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.Numeric_std.all; 
            use work.Parking_Package.all;

entity CarPark is 
port(     clk :in std_logic;
      rst : in std_logic;
      car_in : in std_logic;
      Car_out : in std_logic;
      Ent_car_type : car_type;
          Ext_car_type : car_type;
      Status : out level
    );
end CarPark;

architecture behave of CarPark is 
signal count : counter;
begin         
SLOT_CHECKING: process(rst,clk)
begin 
        if(rst= '1')then
    count &lt;= (others =&gt; 0);
    Status &lt;= FULL;

        elsif(rising_edge(clk))then
    if(car_in )then       
                     case(Ent_car_type)is                                    
    when Admin =&gt;                                            
                    if(count(Admin) &lt; 5) then                                                
                            Status &lt;= L1;                                                
                            count(Admin) &lt;= count(Admin) +1;
        else
                         Status &lt;= FULL;                                 
                    end if;
    when Staff =&gt;
         if(count(Staff) &lt; 5) then
            Status &lt;= L2;
            count(Staff) &lt;= count(Staff) + 1;
        else
          Status &lt;= FULL;
               end case;                                                                         
            end if;
      elsif(car_out)then                                 
            case(Ext_car_type)is                                     
        when Admin =&gt;                                            
                            if(count(Admin) &gt;0) then
               Status &lt;= L1a;
               count(Admin) &lt;= count(Admin) - 1;
            else
               count(Admin)&lt;= 0;                  
            end if;
        when Staff =&gt;
            if(count(Staff) &gt;0) then
                Status &lt;= L2a;
                count(Staff) &lt;= count(Staff) - 1;
            else
                count(Staff) &lt;= 0;  
            end if;
     end process;
 end behave;


The user defined packages is given below

library ieee;
        use ieee.std_logic_1164.all;
        use ieee.Numeric_std.all;
package Parking_Package is

     type car_type is (Admin, Staff);

     type level is (L1, L2a, FULL);

     type counter is array (Staff downto Admin) of integer range 0 to 22;

     end Parking_Package;

package body Parking_Package is

end Parking_Package;


After initializing using reset, I give input of car_in as 1 and 
car_type as Admin, The output gets displayed as L1 in the Next Clock
and if I force the value of car_type as staff, The corresponding output is simulated in the next clock cycle.

![ScreenShot Simulation] https://imgur.com/a/B6cqADn","Firstly, some comments :  


Your application (MultiLevel Car Parking) is not very adapted to VHDL language. It's too high level. Your coding style is a bit object oriented (type and variable names).
There are syntax errors in your code (I assume you already know it because You achieve to have a simulation screen).
The behavior that you expect on the first clock cycle implies that your output will be the product of combinational logic. It's better to have outputs directly from flip flops.


Then the code that you can use to have the expected behavior with 2 process (One purely sequential, the other purely combinational) :  

    signal current_count        : counter;
    signal next_count           : counter;
    signal current_status       : level;
    signal next_status          : level;

begin

    SEQ : process(rst_tb, clk_tb)
    begin

        if (rst_tb = '1') then

            current_count   &lt;= (others =&gt; 0);
            current_status  &lt;= FULL;

        elsif (rising_edge(clk_tb)) then

            current_count   &lt;= next_count;
            current_status  &lt;= next_status;

        end if;

     end process;

     SLOT_CHECKING : process(current_count, current_status, car_in, car_out, Ent_car_type, Ext_car_type)
     begin

        next_count  &lt;= current_count;
        next_status &lt;= current_status;

        if (car_in = '1') then       

            case (Ent_car_type) is

                when Admin =&gt;                                            
                    if (current_count(Admin) &lt; 5) then                                                
                        next_status         &lt;= L1;                                                
                        next_count(Admin)   &lt;= current_count(Admin) + 1;
                    else
                        next_status         &lt;= FULL;                                 
                    end if;

                when Staff =&gt;
                    if (current_count(Staff) &lt; 5) then
                        next_status         &lt;= L2;
                        next_count(Staff)   &lt;= current_count(Staff) + 1;
                    else
                        next_status         &lt;= FULL;                                                                       
                    end if;

            end case;

        elsif (car_out = '1') then    

            case (Ext_car_type) is  

                when Admin =&gt;                                            
                    if (current_count(Admin) &gt; 0) thenremarques
                        next_status         &lt;= L1a;
                        next_count(Admin)   &lt;= current_count(Admin) - 1;
                    else
                        next_count(Admin)   &lt;= 0;                  
                    end if;

                when Staff =&gt;
                    if (current_count(Staff) &gt; 0) then
                        next_status         &lt;= L2a;
                        next_count(Staff)   &lt;= current_count(Staff) - 1;
                    else
                        next_count(Staff)   &lt;= 0;  
                    end if;

            end case;

         end if;

    end process;

    count   &lt;= next_count   ;
    Status  &lt;= next_status  ;


Warning, with this code the outputs are directly from combinational logic : It's not recommended but it is the only way to get the behavior you expect.

If this application is only a practise, I advice you too to take another example more adapted to VHDL : filter, SPI communication, processing unit, ...",,,,,
VHDL way to group constants together,"Is it possible to group related constants together inside of packages?
What I want to do is to have generic constants but then grouped together with related constants and types. In software like Python this could be done with package inside of package or class to group constants together.

What I want to do is something like this:

library constants;
...
if (some_signal = constants.group_a.SOME_CONSTANT_VALUE) then
    ...
end if;


Reader can see where the constant is coming from like here group_a.","If I understand the question well you can use records inside your package

package ex_pkg is

  type constants_group_1_t is record
    CONSTANT1 : integer;     
    CONSTANT2 : integer;
    CONSTANT3 : integer;
    CONSTANT4 : integer;
  end record constants_group_1_t;

constant constant_group1 : constants_group_1_t  := (
 CONSTANT1 =&gt; 1,
 CONSTANT2 =&gt; 2,
 CONSTANT3 =&gt; 3,
 CONSTANT4 =&gt; 4
);

end package;


then you can use it as

liberary work;

...

 if some_integer = work.ex_pkg.constants_group1.CONSTANT1 then

 end if; 


so basically you declare a new record type containing all the constants that you want to use, which can be any of your chosen types, then creating a constant of the newly created type and assign for each field its value. You can then access it like ""record.field"" moreover you can define a record of records for as deep abstraction as you want.",,,,,
Case statement in VHDL test bench takes decremented value,"I am working on a project using VHDL and I am facing a problem during one of my test benches. I testing all input combinations for a combinational component using a for loop in my stimulus process, but I have a case statement inside the foor loop which is not behaving the way I wish it to.

This is the code segment that isn't behaving the way I want it to:

for i in 0 to 20 loop
    case opcode is
        when ""01001"" | ""01010"" | ""01100"" | ""01110"" | ""10000"" =&gt;
            d &lt;= '0';
            wait for period;
            d &lt;= '1';
        when ""00010"" | ""00100"" | ""00101"" | ""00110"" | ""10001"" | ""10010"" | ""10011"" =&gt;
            d &lt;= '1';
        when others =&gt;
            d &lt;= '0';
    end case;
    wait for period;
    opcode &lt;= opcode + 1;

end loop;


As an example, I expect d to become 1 when opcode is 00010. In the simulation, however, d becomes 1 when opcode becomes 00011 rather than 00010 (same for all other cases too), as if the value the case statement checks is decremented by 1. I changed opcode inside the case statement to opcode+1 and it worked correctly. I do know that VHDL is a hardware description language and that its behavior differs from a programming language, but I still cannot wrap my head around why this is happening, and would like an explanation.",The update to the opcode signal is not 'sensed' by the simulator until it hits a wait statement. Adding wait for 0 ns; at the start of the loop fixes the problem.,,,,,
How to manually compile shared dpi lib?,"I try to import some C-function that generates an array in SystemVerilog.
Here is code:

#include ""svdpi.h""
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void getPacket(int packetSize, svOpenArrayHandle fpSig, svOpenArrayHandle err)
{
    int* cfpSig = (int*) calloc(packetSize, sizeof(int));
    double* cerr = (double*)calloc(packetSize, sizeof(double));

    for(int i = 0; i &lt; packetSize; ++i)
    {
        cfpSig[i] = i;
        cerr[i] = 1.1*i;
        printf(""%d %f\n"",cfpSig[i],cerr[i]);
    }
    printf(""----------"");
    memcpy((int*) svGetArrayPtr(fpSig),cfpSig,packetSize);
    memcpy((int*) svGetArrayPtr(err),cerr,packetSize);
    free(cfpSig);
    free(cerr);
}


import ""DPI-C"" function void getPacket(input int packetSize,
                                    output int fpSig[], output real err[]);
module top();
    initial begin
        parameter int packetSize =  4;
        int fpSig[packetSize];
        real    err[packetSize];
        getPacket(packetSize,fpSig,err);
        for(int i = 0; i &lt; packetSize; ++i) begin
            $display(""fpSig: %d\nerr  : %f"",fpSig[i],err[i]);
        end
    end

endmodule


But when I compile the c-code manually, an error is generated at the linking stage: undefined reference to 'svGetArrayPtr'.
I have not previously worked with svOpenArrayHandle and it was enough to connect the header file ""svdpi.h"". I tried to look for some svdpi.dll lib in the questa install folder, but didn't find it. 

If I compile c-file by vlog it's working fine, but I want to compile it manually because I plan to include matlab libs and compiling via vlog will become uncomfortable.","In Questasim simulator, the library containing the svGetArrayPtr symbol is mtipli.dll",,,,,
Complex if statements are not simulatable,"I intend to summerize many if statements into one (in VHDL), like:

from this working snippet

if config = ""0001"" and counter = 40 then
    res &lt;= '1';
elsif config = ""0010"" and counter = 52 then
    res &lt;= '1';
else
    res &lt;= '0';
end if;


to this unworking snippet

if config = ""0001"" and counter = 40 or config = ""0010"" and counter = 52 then
    res &lt;= '1';
else
    res &lt;= '0';
end if;


Vivado tells me ""there is a problem near 'or'"", but I don't see one.

Will this be better (more robust) on hardware implementation?

Thank you","Provide a Minimal, Complete, and Verifiable example, e.g.:

library ieee;
use ieee.std_logic_1164.all;

entity unworking_snippet is
end entity;

architecture snippet of unworking_snippet is
    signal config:  bit_vector (3 downto 0) := ""0001"";
    signal counter: integer range 0 to 52 := 40;
    signal res:  std_logic;
begin

    process  (config, counter)
    begin

        if config = ""0001"" and counter = 40 or config = ""0010"" and counter = 52 then
            res &lt;= '1';
        else
            res &lt;= '0';
        end if;
    end process;
end architecture;


Which will produce an error message pointing to your if statement. ghdl for example points to two errors in the if statement:

ghdl -a unworking_snippet.vhdl
unworking_snippet.vhdl:16:45:error: only one type of logical operators may be used to combine relation
unworking_snippet.vhdl:16:64:error: only one type of logical operators may be used to combine relation
ghdl:error: compilation error


where line 16 contains the if statement condition, character 45 is the 'o' in or and character 64 is the 'a' in the second and.

These are hard coded into VHDL's expression parsing described in the Baccus Naur Form (BNF) in IEEE Std 1076-2008 9. Expressions, 9.1 General:

An expression is a formula that defines the computation of a value.
expression ::=
      condition_operator primary
    | logical_expression

logical_expression ::=
      relation { and relation }
    | relation { or relation }
    | relation { xor relation 
    | relation [ nand relation ]
    | relation [ nor relation ]
    | relation { xnor relation }

relation ::=
    shift_expression [ relational_operator shift_expression ]

shift_expression ::=
    simple_expression [ shift_operator simple_expression ]

simple_expression ::=
    [ sign ] term { adding_operator term }

term ::=  
    factor { multiplying_operator factor }

factor ::=
      primary [ ** primary ]  
    | abs primary
    | not primary
    | logical_operator primary  

primary ::=  
      name
    | literal
    | aggregate
    | function_call
    | qualified_expression
    | type_conversion
    | allocator
    | ( expression )


where you'll find by hand parsing the if statement condition the only way to have two different logical operators as relations in another logical operator is if the primary is contained in parentheses:

        if (config = ""0001"" and counter = 40) or (config = ""0010"" and counter = 52) then


The path through the BNF is relation => shift_expression => simple_expression => term => logical_operator primary, primary => (expression). This occurs for both sides of the or operator.

Substituting the updated if statement condition allows the MCVe to analyze  (compile) successfully.

While superfluous parentheses are often introduced by those with programming backgrounds parentheses are required for different logical operators in the same expression (config = ""0001"" and counter = 40 or config = ""0010"" and counter = 52 in the original 'unworking' snippet). 

Because it's a syntax analysis requirement in the BNF there can be no difference between simulation and post synthesis functionality.

VHDL treats logical operators with the same precedence:

9.2 Operators

9.2.1 General


  The operators that may be used in expressions are defined as follows. Each operator belongs to a class of operators, all of which have the same precedence level; the classes of operators are listed in order of increasing precedence.
  
  ...
  logical_operator ::= and | or | nand | nor | xor | xnor  
  
  relational_operator ::= = | /= | &lt; | &lt;= | > | >= | ?= | ?/= | ?&lt; | ?&lt;= | ?> | ?>=
  ...  
  
  Operators of higher precedence are associated with their operands before operators of lower precedence. Where the language allows a sequence of operators, operators with the same precedence level are associated with their operands in textual order, from left to right. The precedence of an operator is fixed and cannot be changed by the user, but parentheses can be used to control the association of operators and operands.
  
  In general, operands in an expression are evaluated before being associated with operators. For certain operations, however, the right-hand operand is evaluated if and only if the left-hand operand has a certain value. These operations are called short-circuit operations. The binary logical operations and, or, nand, and nor defined for operands of types BIT and BOOLEAN are all short-circuit operations; furthermore, these are the only short-circuit operations.


Here the language doesn't allow the sequence of operators based on the lack of precedence between logical operators.

9.1 paragraphs 3 &amp; 4


  Each primary has a value and a type. The only names allowed as primaries are attributes that yield values and names denoting objects or values. In the case of names denoting objects other than objects of file types or protected types, the value of the primary is the value of the object. In the case of names denoting either file objects or objects of protected types, the value of the primary is the entity denoted by the name.  
  
  The type of an expression depends only upon the types of its operands and on the operators applied; for an overloaded operand or operator, the determination of the operand type, or the identification of the overloaded operator, depends on the context (see 12.5). For each predefined operator, the operand and result types are given in the following subclause.


The following subclause is 9.2 and the type of expressions resulting from relational operators is type BOOLEAN (9.2.3 Relational operators). 

The BNF restriction requiring parentheses avoids the complexity of evaluating an entire expression repetitively to determine it's tree structure without superimposing logical operator precedence on George Boole's algebra, noting expressions can also produced values of arbitrary types. There are no restrictions on the size or complexity of expressions and the parentheses imply sub-trees.",,,,,
How to use a 'case' in VHDL blocks,"I want to re-use some code block and to make it more readable I tried to put it in a block. 
The code block is used to save some data to some buffers. This also includes a case statement. This block is used in a few states in a statemachine.

      someBlock: block
      begin
        destinationAddr &lt;= destinationAddr_i;
        sourceAddr &lt;= sourceAddr_i

        case type is
          when typeA =&gt;
            someData &lt;= dataA;
            dataLength &lt;= 1;
          when typeB =&gt;
            someData &lt;= dataB;
            dataLength &lt;= 2;
          when typeC =&gt;
            someData &lt;= dataC;
            dataLength &lt;= 3;
        end case;

    end block;


The code is just an example of what I'm trying to do. I want this code to be inserted in the place I call someBlock.
If I make this block Sigasi and Vivado complain about the case statement. (mismatched input 'case', expecting 'end'). I placed the block declaration after the architecture begin but not inside a process.

Is this the wrong way to use a block? Is there some other way of making a 'function' that can manipulate all signals in the architecture?

edit:
ok figured it out. I tried using a procedure before, i placed it in the architecture but not in the process. The signals weren't accessible according to vivado because it couldn't be sure there wouldn't be multiple drivers (from different processes). If I place the procedure in the process it does work.

Thanks for the help everyone :)","First of all, type is a reserved word and cannot be used for an object name. You also cannot use a case statement based on a checking an object type.

It is complaining because the inside of a Block statement is not a sequential region of the code. Case statements must be used in a sequential region, such as a process, function or procedure. In addition, blocks cannot be re-used, they are there simply to add a local region for scoping purposes. 

To make it re-useable, you probably want to use a procedure instead. This would be declared in a declarative region - ie. before a ""begin"". Here is an example:

  procedure mux(constant s    : in  std_logic; 
                constant bits : in  std_logic_vector(1 downto 0);
                signal   o    : out std_logic
               ) is  
  begin
    case s is
      when '1'    =&gt; o &lt;= bits(1);
      when '0'    =&gt; o &lt;= bits(0);
      when others =&gt; o &lt;= 'X';    -- for simulation only
    end case;
  end procedure;
begin

  -- create a synchronous mux
  process(clk)
  begin
    if rising_edge(clk) then
      mux(s0, ipA, opA);
    end if;
  end process;

  -- you can call it outside a process also - this infers an async process, sensitive to s1, ipB, opB
  mux(s1, ipB, opB);

end architecture;


",,,,,
"In Verilog, when using a for-loop within a sequential process, how can you increment the sequential variable?","Here is a snippet of code, hopefully you are alright without the preamble:

   always @ (posedge clk)
   begin
      if(rst)
      begin
         i&lt;=0;
         j&lt;=0;
      end
      else
      begin
         for(j = 0 ; j &lt; 16 ; j = j+1)
         begin
            if(i&lt;8)
            begin
               var[j] &lt;= var_2[i];
               i &lt;= i+1;
            end
         end      
      end
   end


Basically, I am wondering if the outer ""for-loop"" will erroneously increment the counter variable i, rather than simply calculating the 16 vars in parallel. If this is the case, should I cut the for-loop short so that the variable is incremented outside the for-loop?

Thanks!","You are making the code unnecessary complex.

If i&lt;8 then these get executed:

var[j] &lt;= var_2[i];
i &lt;= i+1;


But the i is not incremented until after the clock edge.
As 'i' does not change the condition does not change and thus once true it stays true for all values of j.

Probably a better way of understanding this is to write the code as follows which has the exact same behavior:

   always @ (posedge clk)
   begin
      if(rst)
      begin
         i&lt;=0;
         j&lt;=0;
      end
      else
      begin
         for (j = 0 ; j &lt; 16 ; j = j+1)
         begin
            if(i&lt;8)
               var[j] &lt;= var_2[i];
         end      
         // i increment independent from the 'j' loop
         if(i&lt;8)
            i &lt;= i+1;
      end
   end
",,,,,
Verilog case statement is always true,"Verilog case statmenet expression is always true

module test(input clk,
input reset,
output reg[3:0] ledss

);

reg[31:0] dataread;

always @(posedge clk)
begin

case(dataread)

    32'b1010101010101010101:ledss='b1010;

endcase


 end
endmodule


dont understand why this line executed

32'b1010101010101010101:ledss='b1010;


leds is on same pattern 1010

also after executing this code , leds not on

module test(input clk,
input reset,
output reg[3:0] ledss

);

reg[31:0] dataread;

always @(posedge clk)
begin


    if(dataread==32'b1010101010101010101)   ledss='b1010;




 end
endmodule


but if i execute this,leds is on ,pattern 1010

module test(input clk,
input reset,
output reg[3:0] ledss

);

reg[31:0] dataread;

always @(posedge clk)
begin

case(dataread)

    32'b101010101010:
    begin
    if(dataread==32'b101010101010)  ledss='b1010;
    end
endcase



 end
endmodule


dont understand how case statement works in verilog","I believe you are skipping Verilog simulation and loading your code directly to FPGA.

In simulation. ledss would be X until the patter match is satisfied (both case or if). In the provided code dataread is never assigned so it will be X, therefore in simulation ledss will always be X. In your pastebin links you have dataread driven by a ROM output, so it will have a know output that might match the checking condition.

FPGA synthesizes your RTL and typically goes through some optimization. ledss is not explicitly initialized and has only one possible value if ever assigned. Because of this the optimizer might assume the initial value is don't care, then simplify logic by choosing the initial value to be the same as the only possible value it can be assigned to. Or it might assume the initial value is 0 and keep the logic. For this scenario in general, case tends the follow the former and if tends to follow the latter. Though your code is functionally equivalent, it is uncommon to have a case-statement with only one condition.  

I suggest you improve your coding style so your intended behavior is more explicitly understood by the synthesizer and anyone reading your code. Bellow are some suggestions. Remember to assign dataread to a known value. (Note: replaced 32'b1010101010101010101 with the equivalent 32'h0005_5555 for human readability)

always @(posedge clk)
begin
  case(dataread)
    32'h0005_5555 : ledss &lt;= 4'b1010;
    default : ledss &lt;= 4'b1111;
  endcase
end


Or equivalent:

always @(posedge clk)
begin
  if (dataread == 32'h0005_5555)
    ledss &lt;= 4'b1010;
  else
    ledss &lt;= 4'b1111;
end


If you want ledss to keep the 1010 patter after assignment, then you could do:

always @(posedge clk)
begin
  if (reset) begin
    ledss &lt;= 4'b1111;
  end
  case(dataread)
    32'h0005_5555 : ledss &lt;= 4'b1010;
  endcase
end


Or equivalent:

always @(posedge clk)
begin
  if (reset) begin
    ledss &lt;= 4'b1111;
  end
  else if (dataread == 32'h0005_5555) begin
    ledss &lt;= 4'b1010;
  end
end
",,,,,
A problem with the output of a 4to1 mux made using 2to1 mux's in Modelsim,"After a successful compilation and simulation using Modelsim of the code beneath, which is just a simple 4to1 mux built using two 2to1 mux's, I ran a waveform test to see what it would look like, the output was continuously in the U state regardless of the values the inputs, here is the code along with the results:

a. The code for the 2to1 mux:

entity mux2_1 is
port( a,b:in std_logic_vector(2 downto 0);
s:in std_logic;
e:out std_logic_vector(2 downto 0));
end mux2_1;


architecture wx of mux2_1 is

begin

process

begin
if(s='0') then
e&lt;=a;
else
e&lt;=b;
end if;
wait;

end process;
end wx;


b. The code for the 4to1 mux:


entity mux4_1 is

port( a,b,c,d:in std_logic_vector(2 downto 0);
       s1,s0:in std_logic;
       e :out std_logic_vector (2 downto 0));

end mux4_1;


architecture nj of mux4_1 is

signal t1,t2:std_logic_vector (2 downto 0);


begin

k1: entity work.mux2_1 port map (a,b,s0,t1);
k2: entity work.mux2_1 port map (c,d,s0,t2);
k3: entity work.mux2_1 port map (t1,t2,s1,e);

end nj;


Here's the console report just after simulating:



And finally, the waveforms, with the inconsistent output:

","I believe the error is due to the 'wait' statement in your 2:1 mux. Please remove it.

Here's a side note: use the wait statements as much as possible in the testbench only. As waits are non-synthesizable, you will come across a few errors. 

Thank you",,,,,
How can I get the index of a one-hot encoded vector without using a for-loop?,"I have a signal ""event_id"" where only one of the bits is high at any time. I need to convert this one-hot encoded signal to an integer-value of the index. 

The signals:

signal event_id: std_logic_vector(3 downto 0);
signal event_index: natural;


I know I can do this with a for-loop. This is what I'm currently doing:

for i in 3 downto 0 loop
    if(event_id(i) = '1') then
      event_index = i;
    end if;
end loop;


Is there a better way to do this that doesn't require a for-loop or going through each bit individually? I know I could make a function with the for-loop method, but I feel like there should be a simple solution that I'm missing.","There is no ""simple"" solution for generating the index of a one-hot vector in VHDL.

For a one-hot vector of 4 bits, thus a resulting index of 2 bits, the loop you have made is an OK solution, that is readable and does not take up too much resources in implementation.  Though it is not the smallest solution, since it does not allow the implementation size to benefit from the one-hot property, as it returns the lowest index of a set bit.  For short one-hot vectors this does not matter if the implementation is in an FPGA, since it uses quantized LUT resources.

For longer one-hot vectors the implementation will be smaller if the one-hot property is used.  This can be done with an algorithm where the index bits are generated from the one-hot vector and a mask.  A function for this is shown below.

-- One hot to index calculate; assuming LEN_HOT = 2 ** LEN_IDX
function hot2idx_cal(hot : std_logic_vector) return std_logic_vector is
  variable mask_v : std_logic_vector(LEN_HOT - 1 downto 0);
  variable res_v  : std_logic_vector(LEN_IDX - 1 downto 0);
begin
  for i in 0 to LEN_IDX - 1 loop
    -- Generate mask
    for j in 0 to LEN_HOT - 1 loop
      if ((j / (2 ** i)) mod 2) = 0 then
        mask_v(j) := '0';
      else
        mask_v(j) := '1';
      end if;
    end loop;
    -- Apply mask and generate bit in index
    if unsigned(hot and mask_v) = 0 then
      res_v(i) := '0';
    else
      res_v(i) := '1';
    end if;
  end loop;
  return res_v;
end function;
",,,,,
"Ethernet Media-Independent Interface Management Control results in ""link down""","I am working on an Ethernet driver for the Digilent Nexys4 board (Artix7 FPGA). I have written a VHDL component to communicate with the LAN8720A PHY in MDIO protocol. It works well, When I send a frame asking to write in a register, I can read the value I wrote. But when I ask to read the Basic Status Register, it returns a link down status.

That means the Ethernet link is down and I cannot send Ethernet frames. I have absolutely no idea of why I have the link down status. Even when I let the auto-negociation enabled, after the auto-negiacion is over when I try to send a frame, I have a link down status.

Does anyone have an idea of why this is happening and maybe how I can fix this ?

Thanks.

EDIT : it seems it is because of the DATA_VALID signal of the LAN8720A. Does anyone know how can I set the signal to '1' ?

EDIT2 : for more precisions, DATA_VALID is an internal signal of the LAN8720A. It is used to pull up or down the link state bit of the status register.","I have found a solution to my problem : I did not respect the interframe time. Now that I respect the interframe time, the link state does not go down, it stays up. Though the frame is still not sent, it is a great step forward.",,,,,
Writing a Verilog function to Locate the index of the first one on the right in the vector,"I am Writing a Verilog function to Locate the index of the first one on the right in the vector.If the vector has no ones,  the function should returns the value to the vectorâ€™s highest index + 1. Here is the code :
module m ();
 parameter n = 3;
  function integer Locate_one (input [n-1:0] a );
    Locate_one ='dx;
    for (integer i =n-1 ; i&lt;=0 ; i=i-1)
      begin
        if(a[i] == 1'b1)
          begin
          Locate_one=i;
            break; 
          end
    end
  
    if (Locate_one=='dx)
      Locate_one=n;
  
  
  
  endfunction
initial begin 
  reg [n-1:0] a = 3'b111;
integer result =  Locate_one (a);
  
  $display(&quot;output is %d &quot;, result);
end 
endmodule

Th questions are as follows :

How to break out of the function when we find the highest one ?  I have used the keyword break, which is as I found online, is a valid SystemVerilog keyword not Verilog Keyword.
The strategy that I have used to know that there is no one in the vector is that I have initialized the return integer to X and then I have compared the variable to X at the end of the function. Is this a good way to do so  or there is another better way to do this comparison ?
","There are a number of problems with your code.

You cannot use the == to compare with xâ€”it always returns false. you must use the === operator
You are initializing two static variables a and result and the order of initializations is not defined. They are not procedural statements. SystemVerilog has made implicitly static variable initializations inside procedural code illegal, and that is the only backward incompatibility with Verilog I can think of.
Your code has a lot of SystemVerilog constructs besides break

declaring a variable in a for loop
a function/task body without begin/end keywords.


You should not be using x values in your code. It's not synthesizable, and it makes debugging your code more difficult if you made a mistake.
Your loop condition was the opposite of what you needed.

You can use a disable statement to get functionality similar to a break if you want strict Verilog compatibility.
module m ();
 parameter n = 5;
  function integer Locate_one (input [n-1:0] a );
    integer i;
    begin : block
    Locate_one = n;
      for (i =n-1 ; i&gt;=0 ; i=i-1)
      begin
        if(a[i] == 1'b1)
          begin
          Locate_one=i;
            disable block; 
          end
    end
    end 
  endfunction
  
    reg [n-1:0] a = 3'b111;
initial begin 
integer result;  
  result =  Locate_one (a);     
  $display(&quot;output is %d &quot;, result);
end 
endmodule

Here is the SystemVerilog code
module m ();
 parameter n = 5;
  function int Locate_one (input [n-1:0] a );
    Locate_one = n;
      for (int i =n-1 ; i&gt;=0 ; i=i-1)
      begin
        if(a[i] == 1'b1)
          begin
          Locate_one=i;
            break; 
          end
    end
  endfunction
    logic [n-1:0] a = 3'b111;
    int result;
initial begin 
  result =  Locate_one (a);     
  $display(&quot;output is %d &quot;, result);
end 
endmodule
",,,,,
UVM sequence body task gives unknown compilation error,"I have the following code block where a syntax error is fired:
 virtual task body();
     forever begin
    my_transaction m_req;
    // Blocking wait for a transaction request:
    p_sequencer.m_request_fifo.get(m_req);
    // Generate response based on &quot;req_kind&quot; value:
    if ( m_req.req_kind == REQ ) begin
       `uvm_do_with(req, {req_kind == REQ;} )
    end
    else begin
       `uvm_do_with(req, {req_kind == NO_REQ;} )       
    end
     end
  endtask

I get the following error message:
Error-[SE] Syntax error
  Following verilog source has syntax error :
  &quot;./src/my_transaction.sv&quot;, 77: token is ')'
    if ( m_req.req_kind == REQ ) begin
                                      ^

If I comment the if and else lines as follows, this code block compiles normally:
  virtual task body();
     forever begin
    my_transaction m_req;
    // Blocking wait for a transaction request:
    p_sequencer.m_request_fifo.get(m_req);
    // Generate response based on &quot;req_kind&quot; value:
    //if ( m_req.req_kind == REQ ) begin
       `uvm_do_with(req, {req_kind == REQ;} )
    //end
    //else begin
       `uvm_do_with(req, {req_kind == NO_REQ;} )       
    //end
     end
  endtask

I tried commenting this line:
my_transaction m_req;

as well and expected an error to fire up due to undefined m_req identifier. But the code actually compiles!
The definition of req_kind is:
class my_transaction extends uvm_sequence_item;
   typedef enum {REQ, NO_REQ} req_kind_e;
   rand req_kind_e req_kind;
...
...
...

and the class my_transaction  is type forwarded in the file where the compilation error is present:
typedef class my_transaction ;

The code block in question is a sequence in a sequence library where m_request_fifo is the port used in the slave sequencer to retrieve the sequence.
I'm compiling this file along with other files. Is the compiler error message misleading? What other places in code i can look for to know the source of the problem?
What can possibly be the issue?","The source code for the declaration of the uvm_sequence class is:
virtual class uvm_sequence #(
    type    REQ  =  uvm_sequence_item,
    type    RSP  =  REQ
) extends uvm_sequence_base

REQ is a type parameter. Your using it for something else is wrong/confusing your compiler.",,,,,
Verilog: More efficient way to use ternary operator,"I have written the following assign statement:
assign F = (BCD == 4'd1 | BCD == 4'd2 | BCD == 4'd3 | BCD == 4'd4 | BCD == 4'd5) ? 1'b1 : 1'b0;

where if the BCD input (4-bits) is 1-5, the function returns a 1 and otherwise returns a 0. This works perfectly how I intended, but I'm looking for a more efficient way to write the &quot;OR&quot; parts. Is there a more efficient way to write this?","There's no need for the ternary operator here. The result of each equality(==) is 1-bit, and you are doing a bit-wise OR (|). You probably should be using a logical OR (||) whose result is also 1-bit.
assign F = (BCD == 4'd1 || BCD == 4'd2 || BCD == 4'd3 || BCD == 4'd4 || BCD == 4'd5);

In SystemVerilog which most tools are supporting, you can use the inside operator
assign F = BCD inside {[1:5]}; //  contiguous range
assign F = BCD inside {[1:3],5, [7:10]}; //  noncontiguous values
",,,,,
concurrent procedure call in vhdl,"I am trying to understand the concurrent procedure call with different parameters' class. Assuming I have the procedure test and it is called concurrently like below:
ENTITY tb IS
END ENTITY tb;

ARCHITECTURE sim OF tb IS
  SIGNAL cnt  : integer RANGE 0 TO 3 := 0;
  SIGNAL str  : string(1 TO 5) := (OTHERS =&gt; ' ');
 
  PROCEDURE test (CONSTANT number  : IN integer RANGE 0 TO 3 := 0;
                  SIGNAL   num_str : OUT string(1 TO 5)) IS
  BEGIN
    REPORT &quot;here&quot;;
    CASE number IS
      WHEN 0      =&gt; num_str &lt;= &quot;zero &quot;;
      WHEN OTHERS =&gt; num_str &lt;= &quot;one  &quot;;
    END CASE;
  END PROCEDURE;
  
BEGIN
  test(cnt, str);  -- CONCURRENT CALL TO PROCEDURE TEST
  PROCESS 
  BEGIN
    FOR i IN 0 TO 3 LOOP
      WAIT FOR 10 ns;
      cnt &lt;= i;
    END LOOP;
    WAIT;
  END PROCESS;
END ARCHITECTURE sim;

In THE VHDL DESIGNER GUIED

Another point to note about concurrent procedure calls is that if there are no signals
associated with in-mode or inout-mode parameters, the wait statement in the equivalent
process does not have a sensitivity clause. If the procedure ever returns, the process suspends indefinitely. This may be useful if we want the procedure to be called only once at
startup time.

As procedure test has no signals associated with in-mode or inout-mode, it supposes to be executed once and then suspends indefinitely. But with this example, the procedure is executed 4 times.
Can someone explain to me what is happening or what I am missing?","Section 11.4 of the 2008 LRM (IEEE Std 1076-2008):

For any concurrent procedure call statement, there is an equivalent
process statement [...] The equivalent process statement also has no
sensitivity list, an empty declarative part, and a statement part that
consists of a procedure call statement followed by a wait statement.
The procedure call statement consists of the same procedure name and
actual parameter part that appear in the concurrent procedure call
statement.


If there exists a name that denotes a signal in the actual part of any
association element in the concurrent procedure call statement, and
that actual is associated with a formal parameter of mode in or inout,
then the equivalent process statement includes a final wait statement
with a sensitivity clause that is constructed by taking the union of
the sets constructed by applying the rule of 10.2 to each actual part
associated with a formal parameter.

Forget about the last part, in your case things are super simple and your equivalent process is:
process
begin
  test(cnt, str);
  wait on cnt;
end process;

The CONSTANT class declaration of your procedure's declaration only indicates that (section 4.2.2.2):

For parameters of class constant or variable, only the values of the
actual or formal are transferred into or out of the subprogram call.

It somehow forces you to manipulate this value as if it was a constant and nothing else... inside the procedure's body. It forbids you, for instance, to use signal attributes (e.g. number'EVENT). But it doesn't say anything about the actual parameter that you will associate to this formal parameter when instantiating the procedure.
And the result is, logically, what you observe: your procedure is called 4 times in the equivalent process. Each time the value of the actual parameter, that is, the signal cnt is passed through the formal parameter number.
And your book is right:

[...] if there are no signals associated with in-mode or inout-mode
parameters, the wait statement in the equivalent process does not have
a sensitivity clause.

Indeed, you have a signal (cnt) associated with an in-mode parameter (number).",,,,,
How to implement clock into Program Counter?,"I am trying to create a program counter with logic gates. I got the logic done but I'm not sure where I should connect the clock.
","
... where I should connect the clock.

This is because your circuit will not work:
Let's say &quot;inc in&quot; is true, &quot;load in&quot; is false and &quot;reset in&quot; is false.
Then the value of &quot;out Out&quot; is the output of the &quot;inc16&quot; element.
And the output of the &quot;inc16&quot; element is the value of &quot;out Out&quot; plus 1.
This means that the value of &quot;out Out&quot; is calculated as:
inc16 = out_Out + 1
out_Out = inc16

Or:
out_Out = out_Out + 1

This line has to be read like a mathematical equation, not like a variable assignment in a programming language:
And because the equation has no solution, the circuit won't work.
You have to introduce some delay element (a register made of flip-flops) into your circuit. This delay element will be controlled by the &quot;Clock in&quot; input:
Whenever there is a pulse at &quot;Clock in&quot;, the input of the delay element will be copied to it's output.
The equations could then look like this (there are different possibilities):
inc16 = delay_Out + 1
out_Out = inc16
delay_In = out_Out
delay_Out = delay_In;

Or:
out_Out = out_Out + 1;

The first three lines are again read like mathematical equations; however, the two lines ending with a semi-colon (&quot;;&quot;) are meant like a variable assignment in a programming language (such as C, C++ or Java) that takes place when there is a pulse from the &quot;Clock in&quot; input.
Here is EV3's solution (thanks for the edit):
",,,,,
1-cycle enable signal in a clocked process,"I am taking a vhdl online course.
One of the laboratory work is: &quot;Based on frequency divider and 8-bit cyclic shift register implement a ring counter with a shift period of 1 s.&quot;
The task says that the most significant bit of the counter cannot be used as the clock signal of the shift register (i.e. in the if rising_edge (shifter (MSB)) construction.
It is necessary to form the enable signal as a strobe.
I did the job. The result is accepted.
I have a question related to shift register by enable.
    shift_reg_proc : process(clk)
    begin
        if (rising_edge(clk)) then
            if    (srst = '1') then
                shift_reg &lt;= &quot;10000000&quot;;
            elsif (en = '1') then
                shift_reg &lt;= shift_reg(0) &amp; shift_reg(7 downto 1);
            end if;
        end if;
    end process shift_reg_proc

If the duration of the enable signal is 1 period clk, then there is a probability that at the moment of rising_edge (clk) the en signal level will not have time to become = 1.
If this is the case, then it is not guaranteed that the register shift will occur in the next second.
Is there any &quot;correct&quot; way to do this task?
Is it so? Is my decision correct? Is the lab clue misleading?
I am attaching the implementation code, test bench and wave image.
ring_counter.vhd
--------------------------------------------------------------------------------
-- Based on frequency divider and 8-bit cyclic shift register implement a ring 
-- counter with a shift period of 1 s.
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;

entity ring_counter is
    
    port(clk  : in  std_logic;
         srst : in  std_logic;
         dout : out std_logic_vector(7 downto 0);
         en_o : out std_logic
    );

end entity ring_counter;

architecture behave of ring_counter is

    signal   cntr             : std_logic_vector(26 downto 0) := (others =&gt; '0');
    signal   cntr_msb_delayed : std_logic;
    signal   shift_reg        : std_logic_vector(7 downto 0);
    signal   en               : std_logic;
    constant cntr_msb_num     : integer := 4; -- 26 for DE board, 4 for test bench 

begin
    
    -- signal for test bench
    en_o &lt;= en;

    --------------------------------------------------------------------------------
    -- Counter implementation
    --------------------------------------------------------------------------------

    cntr_proc : process(clk)
    begin
        if (rising_edge(clk)) then
            if (srst = '1') then
                cntr &lt;= (others =&gt; '0');
            else
                cntr &lt;= unsigned(cntr) + 1;
            end if;
        end if;
    end process cntr_proc;

    ----------------------------------------------------------------------------
    -- Shift register implementation
    ----------------------------------------------------------------------------

    shift_reg_proc : process(clk)
    begin
        if (rising_edge(clk)) then
            if    (srst = '1') then
                shift_reg &lt;= &quot;10000000&quot;;
            elsif (en = '1') then
                shift_reg &lt;= shift_reg(0) &amp; shift_reg(7 downto 1);
            end if;
        end if;
    end process shift_reg_proc;
    
    dout &lt;= shift_reg;

    ----------------------------------------------------------------------------
    -- Enable signal generation
    ----------------------------------------------------------------------------

    -- Counter MSB delay for 1 period of clk
    delay_proc : process(clk)
    begin
        if (rising_edge(clk)) then
            cntr_msb_delayed &lt;= cntr(cntr_msb_num);
        end if;
    end process delay_proc;

    en &lt;= cntr(cntr_msb_num) and not cntr_msb_delayed;


end architecture behave;


ring_counter_tb.vhd
library ieee;
use ieee.std_logic_1164.all;

entity ring_counter_tb is
    
end entity ring_counter_tb;

architecture behave of ring_counter_tb is

    component ring_counter is
        port(clk  : in  std_logic;
             srst : in  std_logic;
             dout : out std_logic_vector(7 downto 0);
             en_o : out std_logic
        );
    end component ring_counter;

    signal clk  : std_logic;
    signal srst : std_logic;
    signal dout : std_logic_vector(7 downto 0);
    signal en_o : std_logic;

    constant clk_period : time := 4 ns;

begin

    dut : ring_counter
        port map (
            clk  =&gt; clk,
            srst =&gt; srst,
            dout =&gt; dout,
            en_o =&gt; en_o
        );

    clk_gen : process
    begin
        clk &lt;= '0';
        wait for clk_period;
        loop
            clk &lt;= '0';
            wait for clk_period/2;
            clk &lt;= '1';
            wait for clk_period/2;
        end loop;
    end process clk_gen;

    srst &lt;= '0',
            '1' after 100 ns,
            '0' after 150 ns;

    
end architecture behave;

wave for test bench","TL;DR
The rising edge of clk after which en is raised is not the same as the rising edge of clk at which your shift register shifts. en is asserted high after rising edge N and de-asserted after rising edge N+1. Your shift register is thus shifted at rising edge N+1.
So you have about one clock period delay between assertions of en and the register shifts. You don't care because your specification says that you want a shift period of 1 second. As long as en is periodic with a period of one second, even if there is a small constant delay between en and your shift register, you fulfill the specifications.
But what is of uttermost importance is that, as it is seen by your shift register, en is asserted high sufficiently after rising edge N to avoid a too early shift and de-asserted sufficiently after rising edge N+1 to allow a good nice shift. If you are interested in this too, please continue reading.
Detailed explanation
Your en signal is computed from the outputs of registers synchronized on the same clock clk as your shift register. You cannot have any hold time problem there: the propagation delay from the rising edge of the clock to the outputs of your cntr and cntr_msb_delayed registers guarantee that en will arrive at your shift register sufficiently after the rising edge of the clock that caused it (assuming you don't have large clock skews). It cannot arrive too early.
Can it arrive too late (setup time problem)? Yes, if your clock frequency is too high. The clock period would then be too short, en would not have enough time to be computed, stabilize and propagate to your shift register before the next rising edge of the clock and anything could happen (no shift at all, partial shift, metastabilities...)
This is a very common concern in digital design: you cannot operate at an arbitrarily high clock frequency. If you could you would clock your own computer at yotta-Hz or even more, instead of giga-Hz, and everything would become instantaneous. It would be nice but it is not how the real world works.
In a digital design you always have what is called a critical path. It is a particular chain of logic gates between a set of source registers and a destination register, along which the propagation delay of electrical signals is the largest of the whole design.
Which path it is among all possible and the total delay along this path depend on your design's complexity (e.g. the number of bits of your counter), your target hardware technology (e.g. the FPGA of your prototyping board) and the operating conditions (temperature, voltage of power supply, speed-grade of your FPGA).
(Yes, it depends also on the temperature, reason why hard-core gamers cool down their computers with high performance cooling systems. This avoids the destruction of the silicon and allows to operate the computer at a higher clock frequency with more frames per second and a better user experience.)
The largest time it takes for the signals to travel from the source clock-edge to the arrival at destination, augmented by a small security margin called the setup time of the destination register, is the smallest clock period (highest clock frequency) at which you can run your design. As long as you don't exceed this limit your system works as expected.
Hardware design tool chains usually comprise a Static Timing Analyzer (STA) that tells you what this maximum clock frequency is for your design, your target, and your operating conditions. If it tells you 500 MHz and you need only 350 MHz, everything is fine (you could however investigate and see if you could modify your design, save some hardware, and still run at 350 MHz).
But if you need 650 MHz it is time to roll up your sleeves, look at the critical path (the STA will also show the path), understand it and rework your design to speed it up (e.g. pipeline long computations, use carry look ahead adders instead of carry ripple...) Note that, usually, when you encounter timing closure problems you do not consider only one critical path but the set of all paths that exceed your time budget because you want to eliminate them all, not just the worst. This is why the STA gives you not only the worst critical path but a list of critical paths, in decreasing order of severity.",,,,,
can't multiply real and integer,"I use this code in a testbench, which works as expected:
std_logic_vector(to_unsigned(integer(0.603205*(2**16)),16))

i want to replace it with a function defined in the same file:
function convert_mult(mult : real) return std_logic_vector is
begin       
    
    return std_logic_vector(to_unsigned(integer(mult*(2**16)),16));
    
end function;

and call it like this:
convert_mult(0.603205)

the function fails compilation with &quot;Cannot find the &quot;*&quot; operator with operands denoted with the &quot;[REAL, UNIVERSAL_INTEGER]&quot; signature.&quot;
I can't work out whats wrong with this, i thought real * integer was supported? should i be using another type?","TL;DR
You can mix real and integer literals like in 0.603205*(2**16) but not non-literal reals and integer literals like in mult*(2**16). As noted by Matthew, real and integer are closely related types, so converting is easy. Use:
return std_logic_vector(to_unsigned(integer(mult*real(2**16)),16));

And, incidentally, you write I thought real * integer was supported. Well, you were wrong. It is not supported. You must use an explicit conversion... except with literals.
Details
Why does it work with literals but not with non-literals? According the VHDL 2008 Language Reference Manual (IEEE Std 1076-2008) universal_integer and universal_real are, respectively, the types of integer and floating point literals.
0.603205 is a universal_real.
2**16 is a bit more complex because it is an expression involving integer literals (universal_integers). Section 9.3.6 Type conversions of the LRM  explains that universal_integer can be automatically converted to another integer type when needed by the context. I do not know exactly what automatic conversions take place because the LRM is not very easy to follow on this, but I suspect that the 16 is automatically converted to an integer according rules of section 9.3.6, which allows the use of the universal_integer ** integer operand of package STANDARD that returns a universal_integer (see section 16.3 Package STANDARD where all these operators are defined in their functional form).
Finally, section 9.5 Universal expressions explicitly states that the * operator is defined on universal_integer * universal_real and universal_real * universal_integer. Both return a universal_real.
Note: there is also a universal_real / universal_integer returning universal_real but no universal_integer / universal_real.",,,,,
VHDL enumerator relational operators,"I'm currently programming a system in VHDL, and I'm using an enumerator from another package called vnir, which is defined as such:
package vnir is
    type row_type_t is (ROW_NONE, ROW_NIR, ROW_BLUE, ROW_RED);
end package vnir;

I've defined my architecture as such
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.vnir;

entity imaging_buffer is
    port(
        clock           : in std_logic;
        reset_n         : in std_logic;
        vnir_row_ready  : in vnir.row_type_t
    );
end entity imaging_buffer;

architecture rtl of imaging_buffer is
    signal vnir_row_ready_i : vnir.row_type_t;
begin
    vnir_pipeline : process (reset_n, clock) is
    begin
        if (reset_n = '0') then
            vnir_row_ready_i &lt;= vnir.ROW_NONE;
        elsif rising_edge(clock) then
            if (vnir_row_ready /= vnir.ROW_NONE) then
                --do stuff
            end if;
       end if;
    end process vnir_pipeline;
end architecture;

The internal signal vnir_row_ready_i can be assigned to no problem, however the relational operator doesn't seem to work as ModelSim throws this error when I try to compile:
# ** Error: C:/Users/nashg/Documents/iris_project/ex2_iris/vhdl/subsystems/sdram/Imaging Buffer/test.vhd(23): (vcom-1581) No feasible entries for infix operator '/='.
# ** Error: C:/Users/nashg/Documents/iris_project/ex2_iris/vhdl/subsystems/sdram/Imaging Buffer/test.vhd(23): Type error resolving infix expression &quot;/=&quot; as type std.STANDARD.BOOLEAN.
# ** Error: C:/Users/nashg/Documents/iris_project/ex2_iris/vhdl/subsystems/sdram/Imaging Buffer/test.vhd(28): VHDL Compiler exiting
","My coworker helped me figure out how to make it work! I think that the /= operator is created in the vnir scope, but not ported over to the entity I'm working on. By writing :use work.vnir.&quot;/=&quot;; at the beginning of the file it compiles, so the full entity looks like so:
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.vnir;
use work.vnir.&quot;/=&quot;;

entity imaging_buffer is
    port(
        clock           : in std_logic;
        reset_n         : in std_logic;
        vnir_row_ready  : in vnir.row_type_t
    );
end entity imaging_buffer;

architecture rtl of imaging_buffer is
    signal vnir_row_ready_i : vnir.row_type_t;
begin
    vnir_pipeline : process (reset_n, clock) is
    begin
        if (reset_n = '0') then
            vnir_row_ready_i &lt;= vnir.ROW_NONE;
        elsif rising_edge(clock) then
            if (vnir_row_ready /= vnir.ROW_NONE) then
                --do stuff
            end if;
       end if;
    end process vnir_pipeline;
end architecture;

Alternatively it did work by including use work.vnir.all; and taking out the vnir. before the types, but that wasn't possible with the project I'm working one",,,,,
How to normalize the sum of two IEEE754 single precision numbers?,"I am designing a floating point unit in SystemVerilog that takes two 32-bit inputs that are in IEEE754 format, adds them together, and outputs the result in the same 32-bit IEEE754 format.

My question is, how can I tell if my result needs to be normalized? 

I realize it is when you need to move the ""leftmost"" 1 to the correct bit, which should be bit 23.(starting with bit 0)

What I'm having a hard time wrapping my head around is how I can identify what the correct ""leftmost"" 1 bit is so I can shift the mantissa and increment/decrement the exponent bits appropriately.

If my understanding is correct, addition should have the following process.


Separate the bits into sign, exponent, and mantissa
Prepend a '1' to the mantissas
Compare exponents and add the difference to the smaller exponent
Shift the mantissa of the smaller exponent to the right by said difference to 'line' up the decimals/number correctly
Perform binary addition
Normalize the result if necessary


I believe I have every step except the normalizing part correct. My problem is, how can I identify that the result is not normalized if all I have are bits?

I know that it is not normalized if the result is not 1.(fraction).
ie. 10.10101 * 2^1 should be normalized to 1.010101 *2^2 and .1001 * 2^2 should be normalized to 1.001 * 2^1.

Specifically, I guess I'm trying to ask how I can keep track of where the ""decimal"" place is after adding two numbers.

For example: Adding input a: 0x3fc00000 (1.5) and b: 0x40500000 (3.25)

a = 0 | 0111 1111 | (1) 100 0000 0000 0000 0000 0000
b = 0 | 1000 0000 | (1)101 0000 0000 0000 0000 0000

exponent of a is less than b by a difference of 1, so:

a = 0 | 1000 0000 | 0(1)10 0000 0000 0000 0000 0000
b = 0 | 1000 0000 | (1)101 0000 0000 0000 0000 0000

adding the mantissas will give us a result of

1 0011 0000 0000 0000 0000 0000

Here we see the ""leftmost"" 1 being the bit 24 as opposed to bit 23, so we shift the mantissa to the right by 1 and increment the exponent to normalize the result. Then we remove the ""leftmost"" 1 because it is implied in IEEE754 format and we get:

0 | 1000 0001 | 001 1000 0000 0000 0000 0000 (4.75) as our final output which is correct.

Given this example, I thought I simply just had to check for the following cases:


If bit 24 of the mantissa is equal to 1, shift mantissa right and increment exponent
Else check bit 23 is 1, if true no normalization needed
Else check bit 22 is 1, then shift mantissa left and decrement exponent


However, I'm only finding this to be true for some cases. What am I missing?

In my implementation I made a 26 bit value to hold the sum of the two mantissas, which I'm not sure is correct. Bit 25 is the sign of the mantissa, which I don't really I think I need, and the bits 24 and 23 are the hidden bits, or bits that won't be included in the final output. 

For example: 0x449ebbc8 (1269.868163) + 0xc60eb709 (-9133.758561) gives me the following mantissa:

11 0111 1010 1101 1111 1001 0000 notice this is 26 bits(25:0)

If I followed the previous case that would mean the ""leftmost 1"" bit excluding the sign bit would bit 24, meaning I would shift the mantissa right and increment the exponent. However the correct answer is the opposite! The ""'true' leftmost 1"" bit is actually bit 22! Meaning I should shift left and decrement instead! Giving me the final output of:

1 | 10001011 | 111 0101 1011 1111 0010 0000 (-7863.8906) which is correct.

Similarly, adding 0x45c59cbd and 0xc473d9dc gives a mantissa of

01 1010 0111 0010 0001 1000 0010 but the ""leftmost 1"" bit is not the one at bit 24, but bit 23, so no normalization is needed.

Why is it that for the first case I needed to worry about bit 24 but not the other two cases? Is it because I'm adding opposite signs for the other cases? Overflow problem? Or is there something else I'm fundamentally missing?

Thanks for the help and sorry if the formatting is poor!","Consider adding two positive normal numbers in the IEEE-754 basic 32-bit binary format. When their significands1 are completed by prefixing the leading bit, shifted to align the exponents, and added, the leading bit is either in the same position (because no carry occurred) or one to the left (because a carry occurred). To normalize this, simply shift one bit right if a carry occurred.

(If both numbers are subnormal, the leading bit may be further to the right. However, no normalization will be done, as the result either carried into the position that makes it normal [so no normalization is needed] or did not carry into that position [so the result is still subnormal and cannot be normalized].)

If both numbers are negative, the same situation holds. The significands may be treated as absolute values, ignoring the sign bits.

If the number have opposing signs, there are complications. The question describes prefixing a sign bit to the significand. This would not appear to lead to a correct result. For example, consider adding +1.125 and âˆ?.125. The four-bit significand of each number is 1001. Prefixing the sign bits gives us 01001 and 11001, respectively. Then adding those gives 1 00010 (the new leftmost digit comes from a carry out of the previous leftmost position). Regardless of how we treat the leading bits, the low bits are wrongâ€?010 is not correct; since +1.125 + âˆ?.125 = 0, the result ought to be 0000 with some sign. So merely prefixing the sign bit to a significand is not a correct procedure.

Every description of implementing floating-point addition I recall specifies using subtraction instead of addition when the signs are opposed. In this case, one subtracts the smaller (or equal) number from the larger (or equal) number and then must shift left some number (possibly zero) of bits.

In this model, determining how to normalize the number becomes simpler:


When adding like-sign numbers, normalization requires shifting right zero or one bits, according to whether there was a carry out from the high position. (Note that exponent overflow may occur.)
When subtracting opposite-sign numbers, normalization requires shift left until the leading one bit is in the proper position or the minimum exponent is reached.


I expect it is possible to implement the mixed-sign case using addition and twoâ€™s complement arithmetic. In this case, one should not merely prefix the sign bit to the significand but should form the twoâ€™s complement of the significand by inverting each bit and then adding one. Once the sum is found, if it is negative, it could be twoâ€™s-complemented again and then normalized. However, you are then adding more additions, with their carry chain dependencies, to the implementation.

Note that you must also account for rounding the result, since some bits may be lost during the shift to align exponents before adding and during the shift to normalize the result of adding like-sign numbers.

Footnote

1 â€œSignificandâ€?is the preferred term for the fraction portion of a floating-point number. â€œMantissaâ€?is a historic term for the fraction portion of a logarithm. Significands are linear (doubling a significand doubles the represented value) while mantissas are logarithmic (doubling a mantissa squares the portion of the value it represents).",,,,,
Allowing re-declaration of certain parameters inside package for simulation,"I have a system that has some timeouts that are on the order of seconds, for the purpose of simulation i want to reduce these to micro- or milli-seconds.

I have these timeouts defined in terms of number of clock cycles of my FPGAs clock. So as an example

package time_pkg

parameter EXT_EN_SIG_TIMEOUT = 32'h12345678;
...
endpackage


I compare a counter against the constant global parameter EXT_EN_SIG_TIMEOUT to to determine if it is the right time to assert an enable signal.

I want have this parameter (as well as a bunch of others) defined in a package called time_pkg in a file called time_pkg.v and I want to use this package for synthesis.

But when I simulate my design in Riviera Pro (or Modelsim) i'd like to have a second parameter defined inside a file called time_pkg_sim.v that is imported after time_pkg.v and overwrites the parameters that share the same name as already defined in time_pkg.

If I simply make a time_pkg_sim.v with a package inside it with the same name (time_pkg) then Riviera complains since i'm trying to re-declare a package that's already been declared. 

I don't particularly want to litter my hdl with statements to check if a simulation flag is set in order to decide whether to compare the counter against EXT_EN_SIG_TIMEOUT or EXT_EN_SIG_TIMEOUT_SIM

Is there a standard way to allow re-definition of paramters inside packages when using a simulation tool?","No, you can't override parameter in packages. What you can do is have two different filenames that declare the same package with different parameter values, and then choose which one to compile for simulation or synthesis.",,,,,
"Error with localparam inside ""for"" loop on Verilog","parameter N = 4, FOO = { N { 4'd1 } };
//And then in the generate loop
genvar i;
for( i = 0; i &lt; N; i = i + 1 )
    begin : gen_loop
       localparam THIS_FOO = FOO[ i * 4 +: 4 ];
   end
wire [1:0] rr = THIS_FOO[1:0];
wire [1:0] rt = THIS_FOO[3:2];


I get this error but did not understand why?:

Line 344: &lt;THIS_FOO&gt; is not declared. 
Line 345: &lt;THIS_FOO&gt; is not declared.
Module &lt;TCL_vec&gt; ignored due to previous errors.



  Please tell me where I was wrong?
","Your localparam is declared inside begin:gen_loop..end scope. Moreover your generate for loop created multiple versions of the block, with names

gen_loop[0]
gen_loop[1]
...


So you have multiple versions of the THIS_FOO as well.The way to access them is to use a cross-reference notation.  

wire [1:0] rr = gen_loop[0].THIS_FOO[1:0];
wire [1:0] rt = gen_loop[1].THIS_FOO[3:2];
...


and yes, you have to know which iteration of the loop to access.

So, in your case it complained because you do not have THIS_FOO declared in the scope you wanted to access it. ",,,,,
systemverilog - legal to pass '1 to module instantiation as port?,"In SystemVerilog, is it legal to instantiate a module and pass '1 as the value on the port list? It appears that assignment patterns are disallowed according to the end of section 10.9. Are unsized bit literals allowed?","Yes it's legal. And since a port connection is an assignment-like context (10.8), '1 fills the width of the port with 1's.

And the rule you read in 10.9 has to do with port declarations, not port connections. A port expression would something like

module sub(input .p('{a,b,c}) ); // illegal to use assignment pattern here


Assignment patterns cannot be used in self-determined contexts.",,,,,
VHDL reset during execution,"I am developing a Secure Sequence Detector, which is a FSM, by using 3 different processes. It has as input num_in (8 bits) that represents the input number and a first input (1 bit) that has to be '1' only during the first number, otherwise the FSM goes in a state with fixed output. This condition can happen again if the user insert 3 wrong input sequences. The output is composed by an unlock signal (equal to '1' if the sequence is correct) and by a warning signal (equal to '1' if the sequence is wrong), and they both have to be updated every 5 clock cycles, since the sequence is composed by 5 numbers, even if one of the input is wrong. The first process is:

state_register_p : process(rst, clk)
        begin 
            if rst = '0' then   -- initial state, asynchronous rst
                current_state &lt;= S0;
            elsif (clk'EVENT and clk = '1') then
                if(rst = '0') then
                    current_state &lt;= S0;
                    --errors &lt;= -1;
                else
                    current_state &lt;= next_state;
                    five_cycles &lt;= std_logic_vector(to_unsigned((to_integer(unsigned(five_cycles)) + 1), five_cycles'length));
                    if to_integer(unsigned(five_cycles)) = 5 then
                        five_cycles &lt;= ""001"";
                    end if;
                 end if;
            end if;
    end process state_register_p;


In this FSM I receive each clock a number on 8 bits and I have to check if it is in the right sequence, if it is not, after 5 cycle from the beginnig I set an error. When the error = 3, the FSM goes in another state in which the unlock is fixed at 0 and the warning at 1, until a reset is given as input again and the FSM starts from the initial S0 state.
My testbench code is like that:

clk_tb &lt;= (not(clk_tb) and end_sim) after T_CLK / 2; 
rst_tb &lt;= '1' after T_RESET;

d_process: process(clk_tb, rst_tb)
    variable t : integer := 0; 
  begin
    if(rst_tb = '0') then
      num_in_tb &lt;= (others =&gt; '0');
      first_tb &lt;= '0';
      t := 0;
    elsif(rising_edge(clk_tb)) then
      case(t) is 
        -- correct
        when 1 =&gt; num_in_tb &lt;= ""00100100""; first_tb &lt;= '1';  --36
        when 2 =&gt; num_in_tb &lt;= ""00010011""; first_tb &lt;= '0';  --19
        when 3 =&gt; num_in_tb &lt;= ""00111000""; first_tb &lt;= '0';  --56
        when 4 =&gt; num_in_tb &lt;= ""01100101""; first_tb &lt;= '0';  --101
        when 5 =&gt; num_in_tb &lt;= ""01001001""; first_tb &lt;= '0';  --73

        --invalid because of the num_in (error = 1, but still &lt; 3)
        when 6 =&gt; num_in_tb &lt;= ""00100100""; first_tb &lt;= '1';  --36
        when 7 =&gt; num_in_tb &lt;= ""00010011""; first_tb &lt;= '0';  --19
        when 8 =&gt; num_in_tb &lt;= ""00111000""; first_tb &lt;= '0';  --56
        when 9 =&gt; num_in_tb &lt;= ""01100100""; first_tb &lt;= '0';  --100
        when 10 =&gt; num_in_tb &lt;= ""01001001""; first_tb &lt;= '0';  --73

        --invalid because of the two first (blocking condition) 
        when 11=&gt; num_in_tb &lt;= ""00100101""; first_tb &lt;= '0';  --37
        when 12=&gt; num_in_tb &lt;= ""00100110""; first_tb &lt;= '1';  --38
        when 13=&gt; num_in_tb &lt;= ""00100111""; first_tb &lt;= '1';  --39

        --reset is needed
        when 14=&gt; rst_tb &lt;= '0', '1' after T_RESET;  --unknown behavior here

        -- correct
        when 15 =&gt; num_in_tb &lt;= ""00100100""; first_tb &lt;= '1';  --36
        when 16 =&gt; num_in_tb &lt;= ""00010011""; first_tb &lt;= '0';  --19
        when 17 =&gt; num_in_tb &lt;= ""00111000""; first_tb &lt;= '0';  --56
        when 18 =&gt; num_in_tb &lt;= ""01100101""; first_tb &lt;= '0';  --101
        when 19 =&gt; num_in_tb &lt;= ""01001001""; first_tb &lt;= '0';  --73

        when 20 =&gt; end_sim &lt;= '0';
        when others =&gt; null; -- Specifying that nothing happens in the other cases 

      end case;
      t := t + 1;
    end if;
  end process;


I would like to insert something like that when 14=> rst_tb &lt;= '0', '1' after T_RESET; to reset my FMS. How can I do it? Thanks","You currently have rst_tb driven in multiple locations which is a conflict. Remove it from outside of d_process, and remove rst_tb from your sensitivity list. Then your if-statement will be:

if rising_edge(clk_tb) then ...


You can create a when 0 =&gt; clause on your t variable where you perform resetting:

when 0 =&gt;
  num_in_tb &lt;= (others=&gt;'0');
  first_tb &lt;= '0';
  t := 0;
  rst_tb &lt;= '0', '1' after T_RESET;


Then you can have rst_tb driven again in your when 14 =&gt; clause.

...

when 14 =&gt;
  rst_tb &lt;= '0', '1' after T_RESET;

...


You will have to make your T_RESET shorter than a clk_tb period, or your state_register_p process will start missing stimulus from d_process.

EDIT:

library IEEE;
use IEEE.std_logic_1164.all;
library STD;
use STD.textio.all;

entity tb is
end tb;

architecture arch of tb is

constant T_RESET : time := 5 ns;
constant T_CLK   : time := 10 ns;

signal clk_tb    : std_logic := '0';
signal rst_tb    : std_logic := '0';
signal trig_rst  : std_logic := '0';
signal num_in_tb : std_logic_vector(7 downto 0);
signal first_tb  : std_logic := '0';
signal end_sim   : std_logic := '1';

begin

--  rst_tb &lt;= '0','1' after T_RESET;
clk_tb &lt;= (not(clk_tb) and end_sim) after T_CLK / 2; 

--d_process: process(clk_tb, rst_tb)
d_process: process(clk_tb)
  variable t : integer := 0; 
begin
--    if(rst_tb = '0') then
--      num_in_tb &lt;= (others =&gt; '0');
--      first_tb &lt;= '0';
--      t := 0;
--    elsif(rising_edge(clk_tb)) then
  if(rising_edge(clk_tb)) then
    case(t) is 
    when 0 =&gt;
      num_in_tb &lt;= (others=&gt;'0');
      first_tb &lt;= '0';
      rst_tb &lt;= '0', '1' after T_RESET;
    -- correct
    when 1 =&gt; num_in_tb &lt;= ""00100100""; first_tb &lt;= '1';  --36
    when 2 =&gt; num_in_tb &lt;= ""00010011""; first_tb &lt;= '0';  --19
    when 3 =&gt; num_in_tb &lt;= ""00111000""; first_tb &lt;= '0';  --56
    when 4 =&gt; num_in_tb &lt;= ""01100101""; first_tb &lt;= '0';  --101
    when 5 =&gt; num_in_tb &lt;= ""01001001""; first_tb &lt;= '0';  --73

    --invalid because of the num_in (error = 1, but still &lt; 3)
    when 6 =&gt; num_in_tb &lt;= ""00100100""; first_tb &lt;= '1';  --36
    when 7 =&gt; num_in_tb &lt;= ""00010011""; first_tb &lt;= '0';  --19
    when 8 =&gt; num_in_tb &lt;= ""00111000""; first_tb &lt;= '0';  --56
    when 9 =&gt; num_in_tb &lt;= ""01100100""; first_tb &lt;= '0';  --100
    when 10 =&gt; num_in_tb &lt;= ""01001001""; first_tb &lt;= '0';  --73

    --invalid because of the two first (blocking condition) 
    when 11 =&gt; num_in_tb &lt;= ""00100101""; first_tb &lt;= '0';  --37
    when 12 =&gt; num_in_tb &lt;= ""00100110""; first_tb &lt;= '1';  --38
    when 13 =&gt; num_in_tb &lt;= ""00100111""; first_tb &lt;= '1';  --39

    --reset is needed
    when 14 =&gt; rst_tb &lt;= '0', '1' after T_RESET;  --unknown behavior here

    -- correct
    when 15 =&gt; num_in_tb &lt;= ""00100100""; first_tb &lt;= '1';  --36
    when 16 =&gt; num_in_tb &lt;= ""00010011""; first_tb &lt;= '0';  --19
    when 17 =&gt; num_in_tb &lt;= ""00111000""; first_tb &lt;= '0';  --56
    when 18 =&gt; num_in_tb &lt;= ""01100101""; first_tb &lt;= '0';  --101
    when 19 =&gt; num_in_tb &lt;= ""01001001""; first_tb &lt;= '0';  --73

    when 20 =&gt; end_sim &lt;= '0';
    when others =&gt; null; -- Specifying that nothing happens in the other cases 

    end case;
    t := t + 1;
  end if;
end process d_process;

end arch;
",,,,,
if statement inside counter in VHDL,"I have a 3 bit counter that counts upwards from ""000"". Every time ""101"" is reached, I want the o_en signal to be HIGH. 
I have the following VHDL file. 
The behaviour is unfortunately different.
The o_en signal is HIGH, when ""110"" is reached (delayed by one clock cycle).

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

entity special_counter is
    port(
        i_clk : in std_logic;
        i_en : in std_logic;
        i_rst : in std_logic;
        o_data : out std_logic_vector(2 downto 0);
        o_en : out std_logic
    );
end entity;

architecture behave of special_counter is
signal w_data : std_logic_vector(2 downto 0);
signal w_en : std_logic;

begin
    process(i_clk, i_rst) begin
        if i_rst = '1' then
            w_data &lt;= ""000"";
        elsif rising_edge(i_clk) then
            if i_en = '1' then
                if w_data = ""101"" then
                    w_en &lt;= '1';
                    w_data &lt;= w_data + 1;
                else
                    w_en &lt;= '0';
                    w_data &lt;= w_data + 1;
                end if;
            end if;
        end if;
    end process;
    o_data &lt;= w_data;
    o_en &lt;= w_en;
end architecture;


How can I change my program to perform the expected behaviour ?","That is exactly correct and that is what you have coded.

To put it into words:
 ""At the rising edge of the clock, when the counter has the value 101 then the w_en will be set high.""

Thus the w_en signal from which o_en is derived, will be high after the rising edge of the clock.
In the same time as the w_data changes and  after the rising clock becomes ""110"". 

There are two solutions:


Test for ""100"" (so one cycle sooner)
Make w_en (and thus o_en) combinatorial. 


For the latter you must move the assignment outside the 'clocked' section
and use e.g. 

w_en &lt;= '1' when w_data = ""101"" else '0';",,,,,
verilog_mode autoreginput behavior when using assignment,"I wonder if the following case is possible.
I have : 

module a(
input [2:0] a_i
);
endmodule

module b ();

 /*AUTOREGINPUTS*/

 a u_a(/*AUTOINST*/)
endmodule


It expands to: 

 module b ();

 /*AUTOREGINPUTS*/
 reg [2:0] a_i;
 a u_a(/*AUTOINST*/
       .a_i(a_i))
endmodule


But if I modify adding the line assign a_i  = '0;, then it does not expands AUTOREGINPUTS anymore. Is there a way to expand it even if I'm doing an assignment ?","The short answer is because when running verilog-auto to fill in /*AUTOREGINPUT*/ will exclude any signal that is already declared and by adding assign a_i = '0;, you are declaring a_i.

In Verilog, explicit variable declarations are not required and will take on the default nettype if left undeclared under certain circumstances. So, if I had the following:

module x;
  assign myVar = '0;
endmodule


myVar will be implicitly declared to be a net with the default nettype (which by default is wire). You can read more in the System-Verilog LRM (IEEE1800-2009 Section 6.10). One recommendation to avoid typos generating implicitly declared variables is to change the default nettype with the `default_nettype macro to none (ie `default_nettype none on the top of every file); doing this forces all variables to be explicitly declared or the compiler/synthesizer will throw an error.

verilog-mode mode in emacs is aware of implicit declaration and, as such, will not autogenerate anything declared. Thus, when you add the assign statement, you are declaring a_i and so the autogenerator will not ""redefine"" a_i.

To avoid this, I can only recommend running the generator before you assign any of the variables to be autogenerated. Im not sure if it handles `default_nettype none correctly, but I would assume not.

Also note, it should be /*AUTOREGINPUT*/, not /*AUTOREGINPUTS*/, no 's' at the end.",,,,,
Most significant bit operand in part-select of vector wire is illegal,"I want to make a parameterized FIR filter in verilog on xilinix. This is my code:

module FIRFilter(xInput, clock, reset, filterCoeff, yOutput);
parameter inputBits = 8, lengthOfFilter = 4, coeffBitLength = 8, lengthOfCoeff = lengthOfFilter + 1, outputBitWdth = 2 * inputBits;
input [(coeffBitLength * lengthOfCoeff) - 1 : 0] filterCoeff;
input clock, reset;
input [inputBits - 1 : 0] xInput;
reg [outputBitWdth - 1 : 0] addWires [lengthOfFilter - 1 : 0];
output reg [outputBitWdth - 1 : 0] yOutput;
reg [inputBits - 1 : 0] registers [lengthOfFilter - 1 : 0];
integer i, j;
always @ (posedge clock, posedge reset)
begin
    if(reset)
    begin
        for(i = 0; i &lt; lengthOfFilter; i = i + 1)
        begin
            registers[i] &lt;= 0;
        end
    end
    else
    begin
        registers[0] &lt;= xInput;
        for(i = 1; i &lt; lengthOfFilter; i = i + 1)
        begin
            registers[i] &lt;= registers[i - 1];
        end
    end
end
always @ (posedge clock)
begin
    addWires[0] = filterCoeff[(lengthOfFilter * coeffBitLength) - 1 : (lengthOfFilter - 1) * coeffBitLength] * xInput;
    for(j = 1; j &lt; lengthOfFilter; j = j + 1)
    begin
        addWires[j] = (filterCoeff[((j + 1) * coeffBitLength) - 1 : j * coeffBitLength] * registers[j - 1]) + addWires[j - 1];
    end
    yOutput = (filterCoeff[coeffBitLength - 1 : 0] * registers[lengthOfFilter - 1]) + addWires[lengthOfFilter - 1];
end
endmodule


But I keep getting this error

ERROR:HDLCompilers:109 - ""FIRFilter.v"" line 33 Most significant bit operand in part-select of vector wire 'filterCoeff' is illegal
ERROR:HDLCompilers:110 - ""FIRFilter.v"" line 33 Least significant bit operand in part-select of vector wire 'filterCoeff' is illegal
ERROR:HDLCompilers:45 - ""FIRFilter.v"" line 33 Illegal right hand side of blocking assignment


I searched online for the solution but haven't got any satisfactory answer.
Can someone help me with the this?","Verilog does not allow part selects signal[msb:lsb]  where msb and lsb are not constants. You can use another construct called an indexed part select where you specify a constant width, but a variable offset signal[offset+:width]

addWires[0] = filterCoeff[(lengthOfFilter * coeffBitLength) +:coeffBitLength] * xInput;
",,,,,
Systemverilog interfaces over hierarchical boundaries,"I have experienced some back-end issues using systemverilog interfaces when and interface is traversing over hierarchical boundaries. I've tried to sketch the situation in the attached drawing.

The top picture shows the ""regular"" method of using interfaces. the interface and connected module are all instantiated at the same level of hierarchy. This works for simulation and back-end.

The middle picture shows my situation. At the toplevel I have a module and interface instantiation. The interface is connected to the purple module and then connected to 2 sub-modules. In simulation this works.

Then the synthesis tool complains that the interface at the purple level should be an modport. So I added that. However the synthesis tool is interpreting the wires in the as bidirectional and adds logic to facilitate this. In my design all wires are unidirectional.

The only workaround I could find to fix this issue is depicted in the lower picture. I connect via a modport the original interface (labeled A). Then I instantiate a new interface (labeled B) which has the same parent as interface A. Both interfaces A and B are connected to a connect module which contains a lot of statements like:

assign interfaceB.rx1 = interfaceA.rx1;

assign interfaceB.rx2 = interfaceA.rx2;

assign interfaceA.statusX = interfaceB.statusX;

etc

so it is just a ""dumb"" connection of interface A and B.

This way of work feels very wrong as this connect module is creating a lot of overhead. Is there a good / easier way of using the interface over hierarchical boundaries that is not only working in simulations but also works for synthesis?

Thanks
","Hierarchical composition is definitely a shortcoming of SystemVerilog interfaces. 

You can simplify your solution by creating InterfaceB with a port list and making connections to the individual signals from the InterfaceA port. That eliminates the connect module. 

interface InterfaceB( input rx1, rx2, output ...)'
 modport .../ same as what you have
endinterface
",,,,,
I have error in `define on the Verilog with for,"...
'define ZERO_INIT2D(VECT,SD_WIDTH) for(integer i=0;i&lt;(SD_WIDTH);i=i+1) (VECT)[i]=0;
...`

...
reg [31:0] rrr [7:0];
...
always @(negedge clk)
begin
        ZERO_INIT2D(rrr,8)
        //for(integer i=0;i&lt;8;i=i+1) rrr[i]=0;// if using it. All works fine
        Buffer_reg = 111;
        Start_addr = 0;
        Counter=0;
...


I want to use exactly define!
My define has nothing to do with the register ""Buffer_reg"". Why am I getting the following error?

ERROR:HDLCompiler:806 - ""MEMORY_m.v"" Line 170: Syntax error near ""Buffer_reg"".
ERROR:ProjectMgmt - 1 error(s) found while parsing design hierarchy.
","I made such changes and everything was synthesized normally: ... 


...
'define ZERO_INIT2D(VECT,SD_WIDTH) for(integer i=0;i&lt;SD_WIDTH;i=i+1) VECT[i]=0;
...


I do not know why but 


  (VECT) -> VECT
  
  (SD_WIDTH) -> SD_WIDTH 


and it helped, but this also violates the syntax of defines, well, it works.",,,,,
How to tell verilator linter to not verify submodule?,"I'm using verilator for linting my design with this commands :

verilator -lint-only -Wall top_design.v


But some submodule are not available (mainly because it template from FPGA constructor). Then I have these kind of errors :

%Error: efb.v:39: Cannot find file containing module: VHI
%Error: efb.v:41: Cannot find file containing module: BB
%Error: efb.v:43: Cannot find file containing module: BB
%Error: efb.v:45: Cannot find file containing module: VLO
%Error: efb.v:97: Cannot find file containing module: EFB
%Error: submod.v:163: Cannot find file containing module: OSCH


All submodules mentionned in these errors messages are templates for lattice machxo3 fpga.

Is there a solution to ask verilator to not care about these modules ? ","According to official verilator forum, the only way to do it is to make Â«null moduleÂ».",,,,,
Converting 8-bit two complement signed number to decimal,"The task is larger but I'm stuck at converting from signed 8 bit two complement number to decimal. Here is some code:

entity example is
    Port ( switches : in STD_LOGIC_VECTOR (7 downto 0) );
end example;
signal integer_value : integer;


Logic I'm trying to use to convert this input to decimal is

integer_value &lt;= to_integer(unsigned(switches));


integer_value ends up being either zero or minimum value for integer (-2147483648). Example input would be ""01101111"".","Use signed, not unsigned, thus as:

integer_value &lt;= to_integer(signed(switches));


Consider making a small test bench to experiment with the construction, so you isolate the problem, since it sounds like the issue is elsewhere in the design.  Simple test bench may be like:

entity mdl_tb is
end entity;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

architecture sim of mdl_tb is
  signal switches      : std_logic_vector(7 downto 0);
  signal integer_value : integer;
begin

  integer_value &lt;= to_integer(signed(switches));

  process is
  begin
    switches &lt;= ""00000000""; wait for 10 ns; report integer'image(integer_value);
    switches &lt;= ""11111111""; wait for 10 ns; report integer'image(integer_value);
    switches &lt;= ""10000000""; wait for 10 ns; report integer'image(integer_value);
    switches &lt;= ""01101111""; wait for 10 ns; report integer'image(integer_value);
    wait;
  end process;

end architecture;


and this outputs:

# ** Note: 0
#    Time: 10 ns  Iteration: 0  Instance: /mdl_tb
# ** Note: -1
#    Time: 20 ns  Iteration: 0  Instance: /mdl_tb
# ** Note: -128
#    Time: 30 ns  Iteration: 0  Instance: /mdl_tb
# ** Note: 111
#    Time: 40 ns  Iteration: 0  Instance: /mdl_tb
",,,,,
Verilog always block with no sensitivity list,"would an always block with no sensitivity list infer a combinational logic, just the same as always_comb or always @(*)? Eg code:

always begin
if (sig_a)begin
 @(posedge sig_b); // wait for a sig_b posedge event
 @(negedge sig_b); // then wait for a sig_b negedge event
 event_true=1;  
end

if (event_true)begin
  @((sig_c==1)&amp;&amp;(sig_a==0)); //wait for sig_a to deassert and sig_c assert event to be true
  yes =1;
 end
 else yes =0;

end
","Synthesis tools require a specific template coding style to synthesize your code. Most only allow a single explicit event control ar the beginning of an always block. Some of the higher-level synthesis tools that do allow multiple event controls only allow multiple occurrences of the same clock edge. 

Simulation tools don't have these restrictions and will try to execute whatever legal syntax you can compile. BTW, your @((sig_c==1)&amp;&amp;(sig_a==0)) means wait for the expression to change value, not wait for it to become true. The wait(expr)construct means wait for the expression to become true.",,,,,
How to define a custom cell for netlist synthesis?,"I am currently working on a CPU design in which I want to compare different microarchitectures in means of power, speed and area. These microarchitectures differ only by instantiation of different components, e.g. differently implemented ALUs or register files. Some of these components are rather complex and not available to me in form of HDL code. So the idea is to instantiate them as blackboxes in the HDL code and let the synthesis tool (Synopsys Design Compiler) map these to self-defined cells to attain the netlist.

Now, the question is: How do I self-define cells to use in the synthesis? Of course, I have a standard cell library available, so I only need to ""add"" those few extra cells to the link library. I could not find a way to define them inside the DC shell. So I suppose that I have to write an extra liberty file to load and link to.

Is there a way to define a liberty file where I do not have to worry about header stuff, such as as process parameters, and only need to define the desired cells and ""add"" those to the existing library so that it automatically presumes all the process parameters as specified in the standard cell library?

I assume this is not too uncommon to want to do for simulation purposes when no tapeout is planned. I just couldn't find any useful information online or in the user guide. I would be glad if someone could point me to the right direction.",I found a solution. One can simply write a liberty file containing only the custom cells' descriptions and then read it in before compile via the update_lib command. This is just what I wanted.,,,,,
"In System Verilog, how to determine whether a class item exists?","I have a system with a config file that is read in by the testbench.  The config file is generated by another group and it now has config values that are no longer used, but which they do not want to remove.  In the testbench, I read in the config file and apply the values in it to a member of a multiply-nested class that represents the register map of the device.

Up to this point, I had a large but simple case statement that parsed the config key, then simply applied the associated value to the register field that was associated with the configuration key.  E.g.,

while(!$feof(cfg_file)) begin
  cfg_r        = $fgets(cfg_line, cfg_file);
  cfg_r        = $sscanf(cfg_line,""%s = %s"", cfg_name_str, cfg_value_str);

  case (cfg_name_str)

    ""gpe"" : begin
       ewd_regs.op.gpe.coef = cfg_field_value;
    end

    // Other configuration keywords and a default:

  endcase
end 


In this example the keyword and the register field are both ""gpe"", but for several of the fields the config file keyword and the register field are different.

Now with the clutter in the config file I have some keywords that are listed in the config file and which match one of the cases, but which are no longer defined by separate code that defines and builds the register/field map.  So, in the above example, ewd_regs.op exists, but ewd_regs.op.gpe does not.

So my question is, how can I test to determine whether ewd_regs.op.gpe exists before doing the assignment?  If it does not exist, I want to log the condition and continue parsing the config file.","There is no way within the SystemVerilog Language to lookup an identifier using a string to see if it exists and then use that string to access it. 

If this is a UVM register model, they have implemented an associated string to class handle lookup that you could use instead of direct handle names. 

Otherwise, you may want to create a script that reads the config file and generates this portion of your testbench file.",,,,,
Concatenate block of memory into a wire array?,"In my project I have something like this:

reg [15:0] mem [3:0];
wire [63:0] data;


I know I can concatenate the mem into data like this:

assign data = {mem[3], mem[2], mem[1], mem[0]};


but it becomes some bad work when the memory grows big:

reg [3:0] mem [255:0];
wire [1023:0] data;


I'm afraid writing something like this isn't going to be a good idea, even I can write some other Python or Ruby script to generate such a line.

assign data = {mem[255], ..........., mem[0]};
summon_cthulhu();


Is there any better approach to do this?

Note: This is not an XY problem - it's the exact problem that I want to solve.","Use a generate-for loop

genvar ii;
for (ii=0;ii&lt;256;ii=ii+1)
   assign data[ii*16+:16] = mem[ii];
",,,,,
VHDL shift_right number,"I want to divide a number by 512 meaning that I need to shift it by 9. For example in my code I want to take the number 26 in binary form to multiply by 100 and then divide it by 512. But instead of dividing by 512 all I need to do is to shift right 9 times the number 26*100. But when I do the shift_right command I get the following error:


  Error (10511): VHDL Qualified Expression error at Multiplier_VHDL .vhd(34): SHIFT_RIGHT type specified in Qualified Expression must match std_logic_vector type that is implied for expression by context


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity Multiplier_VHDL is
    GENERIC (
        display_resolution : INTEGER := 23; -- counter to get to the lowest frequency
        display_counter: INTEGER := 8);     -- counter to get to 97KHz frequency

    port (
        Nibble1 : in std_logic_vector(display_counter downto 0) := ""000011010""; -- 26 in binary form
        Nibble2 : in std_logic_vector(display_counter downto 0);
        Result: out std_logic_vector(17 downto 0));
end entity Multiplier_VHDL;

architecture Behavioral of Multiplier_VHDL is
    signal number : unsigned(display_counter downto 0) := ""001100100""; -- 100 in binary form

begin
    Result &lt;= std_logic_vector(unsigned(Nibble1) * unsigned(number));
    Result &lt;= (shift_right(unsigned(number), display_counter + 1));

end architecture Behavioral;
","shift_right returns either unsigned or signed, depending on what you give it.  So you're trying to write an unsigned to a std_logic_vector (Result is of type std_logic_vector).  

Also, number is already of type unsigned so there's no need to cast it to unsigned again.  

But I give you +1 point for using numeric_std rather than std_logic_arith.  ",,,,,
"Synopsys Synplify Pro synthesis failed when using ""``""","When I try to use construction like this my synthesis was failed

`define defLOMIC 0 //For example
`define rd(LOMIC) `def``LOMIC


Late:

wire lod = `rd(LOMIC);


Error:

E   CS231   Unknown macro def   VDF_TOP.v (368) syntax.log (13) 09:14:32 Thu Dec 06 Synthesis Check
E   CS234   expecting identifier immediately following back-quote (`)   VDF_TOP.v (368) syntax.log (14) 09:14:32 Thu Dec 06 Synthesis Check


If I use ISE XST for this, the synthesis goes well.

Used ""Synplify C-2009.06""

Does anyone know maybe ""``"" is not supported? How to enable it? Or in which version is support it?",'``' is a SystemVerilog construct. Change your file extension to *.sv. Or use the -sysv switch. It's possible 2009 is too old a version.,,,,,
Mapping PCIe BAR regions of size greater than 4MB in Xilinx Vivado,"We are developing a system with a custom processor, Microblaze and some peripherals in VC709 FPGA using Xilinx Vivado. We are using two 'PCIe : BARs' in 'AXI Bridge for PCI express gen 3'.

The changes we make in the block configuration of the PCI express block are not getting reflected on the host side.

For example, when we set the BAR0 for 2GB and BAR1 for 2MB, we get two regions of 4KB and 4MB. And this doesn't change when we tried varying different BAR combinations.

    $lspci -vv
    0a:00.0 Memory controller: Xilinx Corporation Device 7038
    Subsystem: Xilinx Corporation Device 0007
    Physical Slot: 3
    Control: I/O+ Mem+ BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr+ Stepping- SERR- FastB2B- DisINTx-
    Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-
    Interrupt: pin A routed to IRQ 16
    Region 0: Memory at fbff0000 (32-bit, non-prefetchable) [size=4K]
    Region 1: Memory at fb800000 (32-bit, non-prefetchable) [size=4M]
    Capabilities: &lt;access denied&gt;
    Kernel modules: riffa


How can I debug it?","Solution

I have been using Xilinx SDK for programming the FPGA. But it the SDK was always loading an old bit stream. I have solved it by programming the FPGA through Vivado itself.

Tools > Xilinx hardware manager > open target > autoconnect > program device

Credits: Mandar Datar (HPC Lab, Dept of EE, IIT Bombay)",,,,,
shift register using dff verilog,"I want to create a shift register using d-flip-flop as basic structural element.
code:

dff:

  module dff(d,q,clk,rst);

  input d,clk,rst;
  output reg q;

  always @(posedge clk)
     begin:dff_block
        if(rst==1'b1)
          q=1'b0;
        else
          q=d;
     end
  endmodule


shift register:

  module shift_register(s1,d,clk,s0,q);
  parameter n=3;

  input  s1,clk;
  input [n:0] d;

  output s0;
  output [n:0] q;

  genvar i;

  assign d[3]=s1;


  generate
  for(i=0; i&lt;=n; i=i+1)
     dff U1(.d(d[i]),.q(q[i]),.clk(clk));
  endgenerate

  assign q[3]=d[2];
  assign q[2]=d[1];
  assign q[1]=d[0];
  assign q[0]=s0;



  endmodule


test bench:

  module tb();

  parameter n=3;
  reg [n:0] d;
  reg s1,clk;

  wire [n:0] q;
  wire s0;


  shift_register UUT(.s1(s1),.d(d),.clk(clk),.q(q),.s0(s0));

  initial begin

  d=4'b0000;
  clk=0;
  end


always
begin:clok
#10 clk=~clk; s1=1;

end
endmodule


I think test bench has the problem.I have tried to give s1 values for every #10 while clk=1 but again does not work.

This code does not give me waveforms for q and s0.I cant find whats wrong.Any ideas?","you have several problems with the code.


q is an output reg of dff; q[i] is passed as q to dff. q[i] gets also assigned in within the assign statement. So, you have multiply driven wire q[i] which most likely gets resolved to x and never changes. You have your i/o swapped around somewhere. 
you do not assign anything to s0, so it does not change and does not produce any waveform.
in this particular case blocking assignments within the flop will not pay any role, but in general they could cause unpredictable simulation results. Use non-blocking. 
there is not much sense in the generate loop there. You can pass full vectors tot he dff and can flop full vectors as well.
It looks like you get confused int teh direction of the assign statement. It implies direction. assign q[0] = s0; means assign value of s0 to the wire q[0], not vice versa.  
",,,,,
"In Verilog Procedural Interface, is it possible to scan through iteration loop several times?","We can use vpi_scan in the following way:

vpiHandle iter = vpi_iterate(property, handle);
if (iter)
  while ( entry = vpi_scan(iter) )
    /*code*/;


iter will be freed when vpi_scan() returns NULL. 
But what if I need to scan through the loop several times? Is there a way to tell vpi_scan not to free the iterator, so that I could vpi_free_object when I'm done? 
I think I can solve the problem using an additional container (to collect and keep all entries), but is it really needed?

EDIT: 
1. I would not like to call vpi_iterate more than once, since it can be expensive. 
2. Suppose I go with an additional container solution. Is there a way to find out the number of entries in the vpi_scan loop without actual scanning through the loop? This could make implementation simpler.","
ut what if I need to scan through the loop several times? vpi_iterate returns an initialized pointer to the iterator. Every vpi_scan removes an element from the list and frees it. If vpi_scan did not run till the end, you'd better use vpi_free_object to clean the rest of the iterator list. If you need to rescan the same object again, you can call vpi_iterate again and it will return a new iterator object which you can re-scan.
s there a way to tell vpi_scan not to free the iterator, so that I could vpi_free_object when I'm done? No, (1) is the only mechanism which can be used to access and free iterator elements. There is no other exist in the standard.
I think I can solve the problem using an additional container (to collect and keep all entries), but is it really needed? -- this is a good idea if you want to re-scan your data structs. It could be much better from the performance point of view. Verilog simulator usually has a separately generated vpi database which it needs to consult, probably multiple times to provide you with vpi access information. 
Is there a way to find out the number of entries in the vpi_scan loop without actual scanning through the loop? not really. there  are no defined way to query this information from the iterator. There might be a work-around with using  vpi_handle(vpiUse, iterator) but it depends on the underlying data and the type of iteration.  It is much easier to use linked lists created by the first scanning loop.


you can get all additional information for LRM or a verilog pli handbook.",,,,,
"VHDL (Error (10500): VHDL syntax error at Router.vhd(39) near text ""port""; expecting ""("", or ""'"", or ""."")","So basically I am doing the Mousetrap Latch controller on Altera and the syntax error keeps showing up (Error (10500): VHDL syntax error at Router.vhd(39) near text ""port"";  expecting ""("", or ""'"", or ""."").

    Library ieee; 
    use ieee.std_logic_1164.all; 
    use ieee.std_logic_arith.all; 
    use ieee.std_logic_signed.all; 

    entity Router is
    port(Ri, Ao, vld_i, rst: in std_logic; Data_i: in std_logic_vector(33 
    downto 0); Ro, Ai, vld_o: out std_logic; 
    Data_o: out std_logic_vector(33 downto 0));
    end entity Router;

    architecture behavioral of Router is
    signal reqI, ackO, VLDi: std_logic;
    signal reqO, VLDo: std_logic;
    signal Di, Do : std_logic_vector (33 downto 0);
    component latch1
    port(D, en: in std_logic; Q: out std_logic);
    end component;

    component latch_34
    port(D: in std_logic_vector(33 downto 0); en: in std_logic; Q: out 
    std_logic_vetor(33 downto 0));
    end component;
    begin

    process (rst)
    begin
    reqI&lt;= Ri;
    ackO&lt;= Ao;
    VLDi&lt;=vld_i;
    Di&lt;= Data_i;
    if (rst ='1') then
    reqI &lt;= ""0"";
    ackO&lt;='0';
    VLDi&lt;='0';
    Di&lt;= '0';
    Do&lt;= '0';
    reqO&lt;= '0';
    VLDo&lt;= '0';
    else
    **u1: latch1 port map(reqI&lt;=reqI, en&lt;=reqO XNOR ackO, reqO&lt;=reqO);**
    **u2: latch1 port map(VLDi, reqO XNOR ackO, VLDo);**
    **u3: latch_34 port map(Di, Not(reqO XNOR ackO) NAND VLDo, Do);**
    end if;
    end process;
    Ro&lt;=reqO;
    Ai&lt;=reqO;
    vld_o&lt;= VLDo;
    Do&lt;=Data_o;
    end behavioral;
","You forgot a ""c"" in std_logic_vector : 

component latch_34
port(D: in std_logic_vector(33 downto 0); en: in std_logic; Q: out 
std_logic_vetor(33 downto 0));
end component;
",,,,,
"VHDL coding error â€œElse clause after check for clock not supportedâ€?""The function of the code is given an opcode", it will perform a task at the rising edge of the clock. I'm a second year undergrad student, so any help/input will be appreciated,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
Y     :IN BIT_VECTOR(2 downto 0);,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 u, r : bit_vector(2 downto 0);,,,,,,
,,,,,,,
,,,,,,,
Y   :IN BIT_VECTOR(2 downto 0);,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
Y,CLK,OPcode),,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 you only need 'CLK' in your process sensitivity list.,,,,,,,
,,,,,,,
 it will perform a task at the rising edge of the clock. I'm a second year undergrad student, so any help/input will be appreciated,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
Y     :IN BIT_VECTOR(2 downto 0);,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 u, r : bit_vector(2 downto 0);,,,,,,
,,,,,,,
,,,,,,,
Y   :IN BIT_VECTOR(2 downto 0);,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
Y,CLK,OPcode),,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 you only need 'CLK' in your process sensitivity list.,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 the top signal is the ALUout and the second signal is ALUoutM. My desired outcome is for my ALUoutM signal to match my ALUout signal from the previous clock cycle (I have verified that a full clock cycle is the period between the signal changes in the image). As previously stated, this desired outcome is seen in all cycles previous to this one. Between the first and second cycle, the outcome isn't as desired,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 I was able to add the signals of the buffer into my simulator also, but it is displaying the exact same behavior as the input signals are. In the following image, you'll notice a correct behavior for the first 4 clock cycles and then a random value of 0x00000000 coming out of the buffer. Then it is correct for one more clock cycle before completely flying off the rails.,,,,,
,,,,,,,
 thanks to Oldfart (still love that name) for giving me advice on the issue. After talking about it all with the professor and a teaching assistant, I changed all of my MUXes to trigger on an ,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 thus causing the value of the output to potentially change the same number of times as the number of signals that changed (unless you're lucky enough to have every signal reach at the same time). This potentially gives you the incorrect signal many times until all of the inputs have propagated to the MUX. In short, who knows what values you end up clocking if you're doing it the way I was originally doing it.,,,,,,
,,,,,,,
 when I declare my outputs, I do so as,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 but when I went back and did this," it made the entire processor give me much nicer signals that acted as I expected. I believe this is because it causes all of the outputs to """"latch"""". If someone could elaborate on why this helps"," I would greatly appreciate it.""",,,,,
Unexpected behaviour using the ternary operator (Verilog),"In the following Verilog module, I'd like to understand why the blocking assignment using concatenation doesn't give the same result as the 2 commented out blocking assignments.

When I run the program on the FPGA, it gives the expected result with the 2 blocking assignments (the leds blink), but not with the blocking assignment using concatenation (the leds stay off).

Bonus points for answers pointing to the Verilog specification explaining what is at play here!

/* Every second, the set of leds that are lit will change */
module blinky(
input clk,
output [3:0] led
);
    reg [3:0] count = 0;
    reg [27:0] i = 0;
    localparam [27:0] nTicksPerSecond = 100000000;

    assign led = {count[3],count[2],count[1],count[0]};

    always @ (posedge(clk)) begin
        // This works:
        //count = i==nTicksPerSecond ? (count + 1) : count;
        //i     = i==nTicksPerSecond ? 0 : i+1;

        // But this doesn't:
        {count,i} = i==nTicksPerSecond ? 
          {count+1, 28'b0  } :
          {count  , i+1};
    end
endmodule


PS: I use Vivado 2018.2","The reason is because the widths of count+1 and i+1 are both 32 bits. An unsized number is 32 bits wide (1800-2017 LRM section 5.7.1) and the width of the addition operator is the size of the largest operand (LRM section 11.6.1). To make your code work, add a proper size to your numeric literals 

 {count,i} = i==nTicksPerSecond ? 
          {count+4'd1, 28'b0  } :
          {count  , i+28'd1};


A simpler way to write this code is 

  always @ (posedge clk) 
      if (i== nTicksPerSecond)
         begin 
           count &lt;= count + 1;
           i &lt;= 0;
         end
      else
         begin
           i &lt;= i + 1;
         end
",,,,,
"""Target of concurrent assignment or output port connection should be a net type""","I'm running into the following errors when trying to synthesize my code to run on my Anvyl board:

 ERROR:HDLCompiler:329 - ""C:/Users/Chase/Desktop/Code 
 Templates/final_bcd_counter.v"" Line 25: Target &lt;digit_1&gt; of concurrent assignment or output port connection should be a net type.

 ERROR:HDLCompiler:329 - ""C:/Users/Chase/Desktop/Code 
 Templates/final_bcd_counter.v"" Line 26: Target &lt;digit_2&gt; of concurrent assignment or output port connection should be a net type.


I was provided with a Lab_board.v file to drive the board which is as follows:

`timescale 1ns / 1ps

module lab_board(LED, SW, CLK);

output  [7:0] LED;
input  [7:0] SW;
input CLK;

bcd_count_7 counter( 
.max_count(SW[6:0]), 
.CLK(CLK), 
.run(SW[7]), 
.digit_l(LED[3:0]),
.digit_2(LED[7:4])
); 


endmodule



The code that the errors are throw in is my final_bcd_counter.v file which is the main driver of the program that passes all the needed values to the board. It is as follows: 

// This is the top module for the programmable BCD counter.
// It implements a programmable 7-bit counter and a binary-
// to-bcd converter that can output two digits.


module bcd_count_7(max_count, CLK, run, digit_1, digit_2);

  input [6:0] max_count;
  input CLK, run;
  output reg [3:0] digit_1;
  output reg [3:0] digit_2;

  //Wires and registers for interconnect if needed
  wire [6:0] countin_out;

  // Programmable 7-bit counter module
  prog_count_7 counter(.max_count(max_count), 
            .run(run), 
            .CLK(CLK), 
            .count_out(countin_out));

  // Binary-to-BCD Converter for converting count_out to BCD
  binary_bcd_2 bcd_converter(.bin_in(countin_out),
                  .digit_1(digit_1), 
                  .digit_2(digit_2));

endmodule


I've tried changing the type of digit_1 and digit_2 with no avail. Could the solution be creating wires that connect to the lab board instead of passing output registers, if so, what would that look like?

Any help is appreciated. I can provide the code of the other modules in the program if needed.

Thanks!","You've declared digit_1/2 as a variable and it needs to be a net in Verilog  I'm assuming those are output ports from your binary_bcd_2 module. SystemVerilog does not have this restriction.

Simply remove the reg keyword from the port declaration. I've added wire for clarity, but that is what is implicit

module bcd_count_7(
  input wire [6:0] max_count,
  input wire CLK, run,
  output wire [3:0] digit_1,
  output wire [3:0] digit_2
);
",,,,,
Setting entire register array to zero,"I want to set all the registers in the array to zero. However, I've parametrized the sizing of the array:

logic [WIDTH-2:0] numelem [0:MAXBITS-1];


Is there a way where I could essentially do numelem &lt;= {0,0,0,0,...} but for a generic size? The method preferably needs to be non-blocking since I need to do the assignment within an always_ff block. Thanks.","There are a few ways to achieve this:

1) As Oldfart suggested, use a for loop; its simple and easy to understand

int i;
...
for (i = 0; i &lt; MAXBITS; i = i + 1) begin
  numelem[i] &lt;= '0;
end


2) Use array assignment pattern with the default keyword:

numelem &lt;= '{default: '0};


3) Use bit type instead of logic type if you dont need to simulate 'bx or 'bz states; variables of type bit are initialized to 'b0 instead of 'bx.",,,,,
Reduce RAM Usage for AlexNet implementation on FPGA,"I am working on an intelligent embedded system that implemented with an alexnet (kind of shallow cnn) while training my model on colab, I realized that RAM usage is about 10 GB. Does FPGA Support this? How can I reduce RAM usage?
Thanks","There are no FPGAs with 10 GB of RAM built-in, but many of them will let you connect that much RAM externally.",,,,,
Incomprehensible case expression with macros,"In preparation for an exam, I want to go over some Verilog Code and I'm using https://www.jdoodle.com/ as a compiler. But for some reason the cases throw errors.

jdoodle.v:20: syntax error
jdoodle.v:20: error: Incomprehensible case expression.
jdoodle.v:21: syntax error
jdoodle.v:21: error: Incomprehensible case expression.
jdoodle.v:22: syntax error
jdoodle.v:22: error: Incomprehensible case expression.
jdoodle.v:23: syntax error
jdoodle.v:23: error: Incomprehensible case expression.
jdoodle.v:24: syntax error
jdoodle.v:24: error: Incomprehensible case expression.



module ALU (
    input wire [2:0]OPCODE,
    input wire [31:0]A,
                     B,
    output reg [31:0]RESULT
);

`define ADD 0;
`define SUB 1;
`define MULT 2;
`define DIV 3;
`define MOD 4;

function [31:0] calculate (
    input [31:0] A,
    input [31:0] B,
    input [2:0] OPCODE
); 
    case (OPCODE)
        `ADD: calculate = A + B;
        `SUB: calculate = A - B;
        `MULT: calculate = A * B;
        `DIV: calculate = A / B;
        `MOD: calculate = A % B;
    endcase
endfunction

always @(A or B or OPCODE)
    RESULT = calculate(A, B, OPCODE);

endmodule


Would appreciate any kind of help.","Remove the semicolon at the end your defines.

You are defining ADD as 0;
Thus your code becomes:

case (OPCODE)
    0; : calculate = A + B;
    1; : calculate = A - B;
    2; : calculate = A * B;
    3; : calculate = A / B;
    4; : calculate = A % B;
endcase
",,,,,
Problem outputting solution for a 2 digit BCD adder using Verilog,"I am building a 2 digit BCD adder using only one module. I am rather new to verilog so i don't know if i made a mistake with some of the assignments, but the simulation wont output any answer it just give me the X error for my output. I dont know if i made a mistake in coding the module or coding the simulation but all the waveform output shows is the inputs but give me no outputs. I just want to know where i went wrong. I am kinda stuck here. 

I am trying to create this:

The code for module is as follows:

   `timescale 1ns / 1ps


module two_digit_BCDAdder(input [7:0] X, input Load, input clk, output [8:0]R );

reg [7:0] Q=0;
always @(posedge clk)
begin 
if (Load)
Q&lt;=X;
else 
Q&lt;=Q;
end 
// 8 bit register 

wire sum1, sum3; 

//wires for both upper  parallel adders sum1 left adder sum 3 right adder

 wire cout1, cout2, cout3, cout4;
// wires for cout,  being cout1 top left adder, cout 2 bottom left adder,
//  cout3 top right adder, cout 4 bottom right adder

 wire cin;
// wire for or gate connected to cin

 wire d1,d2;
// D1 connects or gate of the comparator and cout 1 to PA bottom left,
//  D2 connects or gate of the comparator and cout 1 to PA bottom right,

 wire C1,C2;
// C1 comparator on the left 
// C2 comparator on the right

 assign cin = (cout1|cout2);
// Cin or gate

 assign d1 = (cout1|C1);
 assign d2 =(cout3|C2);
// Creation of or gates

 assign C1 = (sum1 &gt; 4'b1001);
 assign C2= (sum3 &gt; 4'b1001);
// Comparator sum hase tobe greater than 9 for BCD addition

 assign {cout3, sum3}= {Q[0],Q[1],Q[2],Q[3]}+{X[0],X[1],X[2],X[3]};
// Top right Parallel Adder
 assign {cout4,{R[0],R[1],R[2],R[3]}} = sum3+{1'b0,d2,d2,1'b0};
// Bottom left Comparator

 assign {cout1,sum1} = {Q[4],Q[5],Q[6],Q[7]}+{X[4],X[5],X[6],X[7]}+cin;
 // Top left Parallel Adder

 assign {cout2,{R[4],R[5],R[6],R[7]}} = sum1 +{1'b0,d1,d1,1'b0};
 // bottom left Parallel Adder

 assign R[8]=(d1|cout2); 
//or gate for final carry led

endmodule



This is the simulation code i am working with:

    `timescale 1ns / 1ps

module BCD_sim();
reg [7:0]x;
reg b;
reg clk;
wire[8:0]r;

two_digit_BCDAdder uut(x,b,clk,r);

initial
begin 
clk =0;

 forever #1 clk=~clk;
end


initial
 begin 

x=0; b=0;
//Values for test
#2 x=55; b=1;
#2 x=55; b=0;
#4;
#2 x=99; b=1;
#2 x=99; b=0;
#4;
#2 x=87; b=1;
#2 x=78; b=0;
#4;
#2 x=25; b=1;
#2 x=75; b=0;
#4;
#2 x=33; b=1;
#2 x=66; b=0;
#4;
#2 x=69; b=1;
#2 x=96; b=0;



$finish;
end 
endmodule

","I have updated the code to make it modular.. and picture with inked modular names is added 

     `timescale 1ns / 1ps

module two_digit_BCDAdder(
    input           clk,
    input [7:0]     X,
    input           Load,
    output [8:0]    R
);

reg [7:0] Q = 0;

// 8 bit register
always @(posedge clk)begin
    if (Load) Q &lt;= #10 X;
    else      Q &lt;= #10 Q;
 end

 wire [3:0] AM,AL,BL,BM;
 wire [3:0] sum_PA1,sum_PA2,sum_PA3,sum_PA4;
 wire       cin_PA1,cin_PA2,cin_PA3,cin_PA4;
 wire       cout_PA1,cout_PA2,cout_PA3,cout_PA4;
 wire       or_gate1_out,or_gate2_out,or_gate3_out,or_gate4_out;
 wire       c1_ag9,c2_ag9;

 assign AL = Q[3:0] ;
 assign AM = Q[7:4] ;
 assign BL = X[3:0] ;
 assign BM = X[7:4] ;

adder PA1(
    .a     (AM)
   ,.b     (BM)
   ,.c_in  (or_gate3_out)
   ,.sum   (sum_PA1)
   ,.c_out (cout_PA1)
);

adder PA2(
    .a     (AL)
   ,.b     (BL)
   ,.c_in  (1'b0)
   ,.sum   (sum_PA2)
   ,.c_out (cout_PA2)
);

adder PA3(
    .a     ({1'b0,{2{or_gate1_out}},1'b0})
   ,.b     (sum_PA1)
   ,.c_in  (1'b0)
   ,.sum   (sum_PA3)
   ,.c_out (cout_PA3)
);

adder PA4(
    .a     ({1'b0,{2{or_gate4_out}},1'b0})
   ,.b     (sum_PA2)
   ,.c_in  (1'b0)
   ,.sum   (sum_PA4)
   ,.c_out (cout_PA4)
);

comp C1(
    .a   (sum_PA1)
   ,.ag9 (c1_ag9)
);

comp C2(
    .a   (sum_PA2)
   ,.ag9 (c2_ag9)
);

or_gate or_gate1 (
  .a   (cout_PA1)
 ,.b   (c1_ag9)
 ,.out (or_gate1_out)
);

or_gate or_gate2 (
  .a   (or_gate1_out)
 ,.b   (cout_PA3)
 ,.out (or_gate2_out)
);

or_gate or_gate3 (
  .a   (cout_PA2)
 ,.b   (cout_PA4)
 ,.out (or_gate3_out)
);

or_gate or_gate4 (
  .a   (c2_ag9)
 ,.b   (cout_PA2)
 ,.out (or_gate4_out)
);

 assign R[3:0]  = sum_PA4;
 assign R[7:4]  = sum_PA3;
 assign R[8]    = or_gate2_out;

endmodule

 module adder (input  [3:0] a,b,
               input        c_in,
               output [3:0] sum,
               output       c_out
);
    assign {c_out,sum} = a+b+c_in;
endmodule

module comp (input [3:0] a,
             output      ag9
);
   assign ag9 = a &gt; 4'h9;
endmodule

module or_gate(input  a,b,
               output out
);
    assign out = a||b;
endmodule


and new tb file with named port connections to dut

     `timescale 1ns / 1ps

module BCD_sim();
reg [7:0]x;
reg b;
reg clk;
wire[8:0]r;

two_digit_BCDAdder dut(
     .clk    (clk)  
    ,.X      (x)
    ,.Load   (b)   
    ,.R      (r)
);

initial
begin 
clk =0;
 forever #1 clk=~clk;
end


initial
 begin 

x=0; b=0;
//Values for test
#2 x=55; b=1;
#2 x=55; b=0;
#4;
#2 x=99; b=1;
#2 x=99; b=0;
#4;
#2 x=87; b=1;
#2 x=78; b=0;
#4;
#2 x=25; b=1;
#2 x=75; b=0;
#4;
#2 x=33; b=1;
#2 x=66; b=0;
#4;
#2 x=69; b=1;
#2 x=96; b=0;



$finish;
end 
endmodule


with the above files vivdo simulator is showing the results..

simple code instead of modular 

    module two_digit_BCDAdder(
    input           clk,
    input [7:0]     X,
    input           Load,
    output [8:0]    R
);

reg [7:0] Q = 0;

// 8 bit register
always @(posedge clk)begin
    if (Load) Q &lt;= #10 X;
    else      Q &lt;= #10 Q;
 end

 wire [3:0] AM,AL,BL,BM;
 wire [3:0] sum_PA1,sum_PA2,sum_PA3,sum_PA4;
 wire       cin_PA1,cin_PA2,cin_PA3,cin_PA4;
 wire       cout_PA1,cout_PA2,cout_PA3,cout_PA4;
 wire       or_gate1_out,or_gate2_out,or_gate3_out,or_gate4_out;
 wire       c1_ag9,c2_ag9;

 assign AL = Q[3:0] ;
 assign AM = Q[7:4] ;
 assign BL = X[3:0] ;
 assign BM = X[7:4] ;

 //4 Adders
 assign {cout_PA1,sum_PA1} = AM[3:0] + BM[3:0] + or_gate3_out;
 assign {cout_PA2,sum_PA2} = AL[3:0] + BL[3:0] + 1'b0        ;
 assign {cout_PA3,sum_PA3} = sum_PA1[3:0] + {1'b0,{2{or_gate1_out}},1'b0} + 1'b0;
 assign {cout_PA4,sum_PA4} = sum_PA2[3:0] + {1'b0,{2{or_gate4_out}},1'b0} + 1'b0;

 // 2 Comparators
 assign c1_ag9 = sum_PA1 &gt; 4'h9 ;
 assign c2_ag9 = sum_PA2 &gt; 4'h9 ;

// 4 OR gates
assign or_gate1_out = cout_PA1     || c1_ag9   ;
assign or_gate2_out = or_gate1_out || cout_PA3 ;
assign or_gate3_out = cout_PA2     || cout_PA4 ;
assign or_gate4_out = cout_PA2     || c2_ag9   ;

// Assigning outputs
 assign R[3:0]  = sum_PA4;
 assign R[7:4]  = sum_PA3;
 assign R[8]    = or_gate2_out;

endmodule
",,,,,
How can I assign module arguments in Verilog?,"I have a verilog module that has a very long list of inputs and outputs that are required. 

module mymodule(clock,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,m13,m18,m15,m16,S26,S25,S22,S27,S14,S11,S17,S10,S13,S16,S6,S12,S19,S18,S15,S7,S9,S20,S28,S23,S8,S21,S24);


I am trying to write a test bench for this module. Is there a smart way to supply the arguments as an array. About half of the arguments are inputs where the other half is outputs. I tried to do something like this based on my limited verilog experience.

reg clk = 0;
reg inputs[16:0] = 0;
wire outputs[23:0];

mymodule tc(clk, inputs, outputs);     


I want the variable ""inputs"" to act as an array that will hold all the inputs, and ""outputs"" will also do the same.

I also want to be able to set all the inputs to random

inputs = $random; 


Is there a way to do this in Verilog or do I have to initialize all the variables manually?","Since the module is defined with individual ports, each port must be connected to individually. Verilog does not provided built in way to auto connect ports. 

SystemVerilog has .* connections, but it only works when the net/var name matches the port name. So with SystemVerilog you could connect with intermediate assignment. (Note: all modern Verilog simulators support most, if not all, SystemVerilog features. Simply change the file extinction from .v to .sv to enable)

logic clock;
logic [15:0] inputs;
wire [22:0] outputs;
wire m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,m13,m18,m15,m16;
wire S26,S25,S22,S27,S14,S11,S17,S10,S13,S16,S6,S12,S19,S18,S15,S7,S9,S20,S28,S23,S8,S21,S24;
assign {m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,m13,m18,m15,m16} = inputs;
assign outputs = {S26,S25,S22,S27,S14,S11,S17,S10,S13,S16,S6,S12,S19,S18,S15,S7,S9,S20,S28,S23,S8,S21,S24};
mymodule tc( .* );


For a cleaner solution, I recommend the Emacs plugin Verilog-Mode (vim wrapper exists). This tool was specifically created to simplify long port list connectivity and other repetitive tasks that are common to Verilog projects. For example, the below would expand to an index to index connection

/* mymodule AUTO_TEMPLATE (
  .m@       (inputs[\1]),
  .S@       (outputs[\1]),
); */
mymodule dut (/*AUTOINST*/);


The below two templates would expand with a offset except for m18 which explicitly connects to inputs[13]. (I picked m18 because I noticed there is no m14 and it is defined between m13 and m15)

/* mymodule AUTO_TEMPLATE (
  .m@       (inputs[@""(- \1 1)""]),
  .S@       (outputs[@""(- \1 6)""]),
); */
mymodule dut (
  .m18      (inputs[13]),
   /*AUTOINST*/);


or

/* mymodule AUTO_TEMPLATE (
  .m18      (inputs[13]),
  .m@       (inputs[@""(- \1 1)""]),
  .S@       (outputs[@""(- \1 6)""]),
); */
mymodule dut (/*AUTOINST*/);
",,,,,
Verilog - Assigning value to a reg twice in a single always block,"I am working on a counter that counts the number of bits high in an input bit-stream of variable width. The code is as follows:

module counter(i_clk, i_arst, i_data, o_done, o_cnt);

    // ---------------------------------------- SIGNALS ---------------------------------------- //
    // Parameters   
    parameter                   OUT_WIDTH;      // Width of the output in bits
    parameter                   IN_WIDTH;       // Number of bits in an input bit stream

    // Input
    input   wire                i_clk;          // Clock
    input   wire                i_arst;         // Active high asynchronous reset
    input   wire                i_data;         // Input data

    // Outputs
    output  reg                 o_done;         // Output done bit
    output  reg[OUT_WIDTH-1:0]  o_cnt;          // WIDTH-bit output counter

    // Internal signals
    integer                     index;          // Bit index for the input
    reg[OUT_WIDTH-1:0]          r_cnt_tmp;      // Temporary counter for assignment


    // ---------------------------------------- LOGIC ---------------------------------------- //
    // Combinational logic
    always @(*) begin
        o_cnt = r_cnt_tmp;
    end


    // Sequential logic
    always @(posedge i_clk or posedge i_arst) begin

        // Reset the counter
        if(i_arst) begin
            r_cnt_tmp   &lt;= {OUT_WIDTH{1'b0}};
            o_done      &lt;= 1'b0;                
            index       &lt;= 0;
        end
        else begin
            // When a new bit stream arrives
            if(index == 0) begin
                r_cnt_tmp   &lt;= {OUT_WIDTH{1'b0}};       // Reset the output data
                o_done      &lt;= 1'b0;                    // Data is now invalid because it is a new bit stream
                                                        // It only happens after a reset or a valid data output 
            end

            // If bit is set
            if(i_data == 1'b1) begin                
                r_cnt_tmp &lt;= r_cnt_tmp + 1; // Count up
            end

            index &lt;= index + 1;             // Increment the index

            if(index == IN_WIDTH) begin     // The input has been completely looped over
                o_done  &lt;= 1'b1;            // Data is now valid for the output
                index   &lt;= 0;               // Reset the index
            end
        end
    end
endmodule


Once I am done with the current bit-stream, I set the o_done signal to inform that the output data is valid and I reset the variable index to start with a new bit-stream. Then at the next clock rising edge, I reset the o_done signal and the counter value andstart counting again.

The problem I have is that my counter does not always reset. Since the signal takes its value only at the end of the block, if the first bit of the bit-stream is high, then it is not reset.

I would like to reset and start counting again in the same clock cycle because I do not want more latency and I have continuous bit-streams arriving on the input. 

Is there a solution to avoid this issue ? 

Thanks for your help.","I think that your issue is in these statements: 

           // When a new bit stream arrives
            if(index == 0) begin
                r_cnt_tmp   &lt;= {OUT_WIDTH{1'b0}};       // Reset the output data
                o_done      &lt;= 1'b0;                    // Data is now invalid because it is a new bit stream
                                                        // It only happens after a reset or a valid data output 
            end

            // If bit is set
            if(i_data == 1'b1) begin                
                r_cnt_tmp &lt;= r_cnt_tmp + 1; // Count up
            end


Supposedly that you have index == 0 and i_data == 1. Now, the r_cnt_tmp value will be scheduled to become 0 after the block is executed, because you use the non-blocking assignment there. 

The next block will try to increment the value, but it will use an old value of the counter and will happily override the previously scheduled reset value. Most likely it will not be '1' or '0'.

One way to re-write it is the following. In the example the initial value of the counter will become '1' if i_data is '1' while index is 0. 

           // When a new bit stream arrives
            if(index == 0) begin
                r_cnt_tmp   &lt;= i_data;       // Reset the output data to '0' or '1' depending on i_data
                o_done      &lt;= 1'b0;                    // Data is now invalid because it is a new bit stream
                                                        // It only happens after a reset or a valid data output 
            end
            else if(i_data == 1'b1) begin   // you definitely need this 'else'             
                r_cnt_tmp &lt;= r_cnt_tmp + 1; // Count up
            end


Sorry, i have not tested it, in particular when i_data is 'x'. 

You might need different requirements for the initial condition. So, you can write it in your own way.",,,,,
Generated begin-end blocks must be named,"I am compiling an SNN simulator named &quot;ODIN&quot; in Xilinx. for Generate block I get this error but I think there is nothing wrong with this block. Can you help me with this?
'''
genvar i;
generate
    for (i=0; i&lt;8; i=i+1) begin
    
        sdsp_update #(
            .WIDTH(3)
        ) sdsp_update_gen (
            // Inputs
                // General
            .SYN_PRE(CTRL_PRE_EN[i] &amp; (SPI_UPDATE_UNMAPPED_SYN | SYNARRAY_RDATA[(i&lt;&lt;2)+3])),
            .SYN_BIST_REF(CTRL_BIST_REF),
                // From neuron
            .V_UP(NEUR_V_UP_int[i]),
            .V_DOWN(NEUR_V_DOWN_int[i]),    
                // From SRAM
            .WSYN_CURR(SYNARRAY_RDATA[(i&lt;&lt;2)+3:(i&lt;&lt;2)]),
            
            // Output
            .WSYN_NEW(SYNARRAY_WDATA_int[(i&lt;&lt;2)+3:(i&lt;&lt;2)])
        );
    end
endgenerate

I get these errors:

Generated begin-end blocks must be named
Illegal redeclaration of ''
","Some compilers wants to have a name when generating logic. This name is taken from the name of the begin-end block.
Try this:

'''
genvar i;
generate
    for (i=0; i&lt;8; i=i+1) 
    begin : sdsp_gen // &lt;&lt;&lt; Name for begin/end block 

        sdsp_update #(
            .WIDTH(3)
        ) sdsp_update_gen (
            // Inputs
                // General
            .SYN_PRE(CTRL_PRE_EN[i] &amp; (SPI_UPDATE_UNMAPPED_SYN | SYNARRAY_RDATA[(i&lt;&lt;2)+3])),
            .SYN_BIST_REF(CTRL_BIST_REF),
                // From neuron
            .V_UP(NEUR_V_UP_int[i]),
            .V_DOWN(NEUR_V_DOWN_int[i]),    
                // From SRAM
            .WSYN_CURR(SYNARRAY_RDATA[(i&lt;&lt;2)+3:(i&lt;&lt;2)]),

            // Output
            .WSYN_NEW(SYNARRAY_WDATA_int[(i&lt;&lt;2)+3:(i&lt;&lt;2)])
        );
    end
endgenerate
",,,,,
floating point multiply problem in verilog,"For a given project I encountered with floating point multiplication in verilog. So I used from IP cores of Xilinx in ISE 14.7
with following configurations for floating point IP core GUI:


Multiply
Single (Exponent width : 8 bit, fraction width : 24)
No usage (in family optimization)
maximum latency (which is here 8 clock cycles)


so when I give the following inputs in ieee 754 format

A = 0_0111111_000000000000000000000000Â (which is one)

B = 0_0111111_000000000000000000000000Â 


the result after 8 clock cycles is :

0_0111110_100000000000000000000000


my question is why the result is not one in ieee 754 format?
who is wrong?","This is how your first number decodes:

                  3  2          1         0
                  1 09876543 21098765432109876543210
                  S ---E8--- ----------F23----------
          Binary: 0 01111110 00000000000000000000000
             Hex: 3F00 0000
       Precision: SP
            Sign: Positive
        Exponent: -1 (Stored: 126, Bias: 127)
       Hex-float: +0x1p-1
           Value: +0.5 (NORMAL)


So, its value is 0.5, not 1 as you claimed.

This is how the product decodes:

                  3  2          1         0
                  1 09876543 21098765432109876543210
                  S ---E8--- ----------F23----------
          Binary: 0 01111101 00000000000000000000000
             Hex: 3E80 0000
       Precision: SP
            Sign: Positive
        Exponent: -2 (Stored: 125, Bias: 127)
       Hex-float: +0x1p-2
           Value: +0.25 (NORMAL)


So, it's 0.25. And that is correct since 0.5 * 0.5 = 0.25 indeed.

If you want to test multiplying 1 * 1 = 1 use the following encoding:

                  3  2          1         0
                  1 09876543 21098765432109876543210
                  S ---E8--- ----------F23----------
          Binary: 0 01111111 00000000000000000000000
             Hex: 3F80 0000
       Precision: SP
            Sign: Positive
        Exponent: 0 (Stored: 127, Bias: 127)
       Hex-float: +0x1p0
           Value: +1.0 (NORMAL)


i.e., 0_01111111_00000000000000000000000 which is how the number 1.0 is encoded as an 32 bit single-precision IEEE754 floating point value. Note in particular that the exponent is 8-bits, which seems to be the source of the issue in your original encoding where you have 7 bits.",,,,,
Creating a 2d array using types in vhdl,"Can you help me with this matrix declaration using types in VHDL? 

-- A    B     Q    Y
(('0', '0', ""000"", 0),
 ('0', '1', ""ZZ1"", 1),
 ('1', '0', ""Z1Z"", 1),
 ('1', '1', ""1ZZ"", 2))


","The type declaration may look like this:

type element_t is record
  A : std_logic;
  B : std_logic;
  Q : std_logic_vector(2 downto 0);
  Y : natural;
end record;

type array_t is array (0 to 3) of element_t;

constant VALUE : array_t :=
  -- A    B     Q    Y
  (('0', '0', ""000"", 0),
   ('0', '1', ""ZZ1"", 1),
   ('1', '0', ""Z1Z"", 1),
   ('1', '1', ""1ZZ"", 2));


Let me suggest you get a VHDL compiler and simulator, like the free ModelSim-Intel FPGA Starter Edition; then you can easily try come VHDL yourself.",,,,,
How do we correctly exclude an {'1} value from a cover group?,"I got the following covergroup implemented:

covergroup my_covergroup_cg  (input string name);
      enable_reg_cp : coverpoint enabled_reg[PARAM1-1:0] {
         illegal_bins no_enable = {0};
      }
      feature_active_reg_cp : coverpoint feature_active_reg_mask[PARAM2-1:0] { // Interested in covering a PARAM2-width chunk of a 32-bit feature_active_reg
         illegal_bins all_features_active = {'1}; // We must not activate all features (1 bit = 1 feature active)
      }      
      my_covergroup_cross : cross enable_reg_cp , feature_active_reg_cp {
         illegal_bins il0 = (binsof (enable_reg_cp) intersect {0});
         illegal_bins il1 = (binsof (feature_active_reg_cp) intersect {'1});
      }
   endgroup : my_covergroup_cg


Upon execution, the ""il1"" illegal bin of my cross gets hit with a value  ""0x1"" of the 
feature_active_reg_mask[PARAM2-1:0] - which is completly legal and does not match the {'1} (equivalent to ..111111 : all ones).

Is there a particular issue of how these {'1} are treated in the ""binsof"" scope ?","Just to share my workaround for knowledge share:
I have decided to go with using localparam semantic. As it appears the issue is related to the tool interpreting the {'1}.
I did the following:

localparam all_ones = {PARAM2{1'b1}};
covergroup my_covergroup_cg  (input string name);
      enable_reg_c .... // rest of code


and I passed the alias into my illegal_bins

illegal_bins il1 = (binsof (feature_active_reg_cp) intersect {all_ones});


Cheers,",,,,,
System Verilog typedef of typedef,"typedef enums allow a convenient way to describe a set of name-value pairs. Is there a way to chain them to create deeper structures using enum at all levels?

For instance, I have the following:

typedef enum logic {ALPHA=0, BETA=1} a_t;
typedef enum logic {GAMMA=0, DELTA=1} b_t;
typedef enum logic {ZETA=0, ETA=1} c_t;
...


I want to create a variable c which is formed of a_t and b_t. Is this possible?

Something like:

a_t b_t c;


so at every dimension of c, I can have enums.

EDIT: Some clarification - assume a_t, b_t and c_t are immutable as they are generated automatically. And there are hundreds of such different enums. I want to create bigger structures as I need because automatically generating all combinations of them would make the code too big and messy.

For instance, say my a_t describes number of masters and b_t describes number of slaves. I want to create a structure where I have this hierarchy in my signal, and at the same time allow enums for them to allow easy of readability and use.

So, something like this:

c[MASTER_0][SLAVE_0]
c[MASTER_0][SLAVE_1]
c[MASTER_1][SLAVE_0]
c[MASTER_1][SLAVE_1]
","Are you perhaps referring to an associative array, such as:

c[ALPHA] = BETA;


If so, you could simply refer to it as:

b_t c[a_t];


Which means create an associative array c who's key is of enums a_t and value is of enums b_t. You could keep going if you'd like :)

typedef enum logic {ALPHA=0, BETA=1} a_t;
typedef enum logic {GAMMA=0, DELTA=1} b_t;
typedef enum logic {BAD_AT=0, GREEK_LETTERS=1} c_t;

c_t my_data_structure[a_t][b_t];

// Assigning a value
my_data_structure[ALPHA][GAMMA] = GREEK_LETTERS;


See an example on EDA Playground here.

Also, I think you're slightly misunderstanding the use of typedef. It does not exactly describe a set of name-value pairs, rather it gives a new name to a data type. It is the enum that is actually creating a 'set of name-value pairs', but I'd clarify that it is essentially assigning identifiers to values. It would help if you could explain the application for a clearer answer.",,,,,
"""="" Function exists for all types, where can I explicitly get it from?","In the following code, I am using numeric_std_unsigned. This defines ""="" such that if S has a meta value, it will always fail the compare, regardless of what it is comparing to.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std_unsigned.all;

entity lib_test is
end entity;

architecture sim of lib_test is
begin

  process
    variable s    : std_logic_vector(7 downto 0);
  begin

    s := x""UU"";
    report ""s="" &amp; to_string(s);

    if s = x""UU"" then
      report ""S match"";
    else
      report ""S no match"";
    end if;

    wait;
  end process;

end architecture sim;


My Question is, other than manually adding all the functions I need from numeric_std_unsigned and leaving out the ""="" function defined for arithmatic, or using explicit references to every function call (and not using numeric_std_unsigned.all at the top), is there a path I can explicitly use to get  the ""="" function implicitly defined for SLV?","Running your original test case with some white space modification:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std_unsigned.all;

entity lib_test is
end entity;

architecture sim of lib_test is
begin

    process
        variable s:     std_logic_vector(7 downto 0);
    begin

        s := x""UU"";
        report ""s = "" &amp; to_string(s);

        if s = x""UU"" then
            report ""S match"";
        else
            report ""S no match"";
        end if;
        wait;
    end process;
end architecture sim;


yields a reproducible error:

ghdl -a --std=08 lib_test.vhdl
ghdl -e --std=08 lib_test sim
ghdl -r --std=08 lib_test sim
lib_test.vhdl:16:9:@0ms:(report note): s = UUUUUUUU
../../src/ieee2008/numeric_std-body.vhdl:1776:7:@0ms:(assertion warning): NUMERIC_STD.""="": metavalue detected, returning FALSE


There are four ways to cure the issue in VHDL.

Using an alias in an inner declarative region to specify the correct ""="" operator:

architecture sim_alias of lib_test is
begin

    process   -- &lt;-- inner declarative region
        variable s:     std_logic_vector(7 downto 0);
        alias ""="" is ieee.std_logic_1164.""=""
                [ieee.std_logic_1164.std_ulogic_vector,
                 ieee.std_logic_1164.std_ulogic_vector return
                 std.standard.BOOLEAN];
    begin

        s := x""UU"";
        report ""s = "" &amp; to_string(s);

        if s = x""UU"" then
            report ""S match"";
        else
            report ""S no match"";
        end if;
        wait;
    end process;
end architecture sim_alias;


resulting in:

ghdl -e --std=08 lib_test sim_alias
ghdl -r --std=08 lib_test sim_alias
lib_test.vhdl:39:9:@0ms:(report note): s = UUUUUUUU
lib_test.vhdl:42:13:@0ms:(report note): S match


Testing the string value:

architecture sim_string of lib_test is
begin

    process
        variable s:     std_logic_vector(7 downto 0);
    begin

        s := x""UU"";
        report ""s = "" &amp; to_string(s);


        if to_string(s) = x""UU"" then
            report ""S match"";
        else
            report ""S no match"";
        end if;
        wait;
    end process;
end architecture sim_string;


also producing the correct result:

ghdl -e --std=08 lib_test sim_string
ghdl -r --std=08 lib_test sim_string
lib_test.vhdl:58:9:@0ms:(report note): s = UUUUUUUU
lib_test.vhdl:62:13:@0ms:(report note): S match


Calling the correct ""="" function:

architecture sim_function_call of lib_test is
begin

    process 
        variable s:     std_logic_vector(7 downto 0);
    begin

        s := x""UU"";
        report ""s = "" &amp; to_string(s);

       if ieee.std_logic_1164.""="" (s, x""UU"") then
            report ""S match"";
        else
            report ""S no match"";
        end if;
        wait;
    end process;
end architecture sim_function_call;


also successful:

ghdl -e --std=08 lib_test sim_function_call
ghdl -r --std=08 lib_test sim_function_call
lib_test.vhdl:78:9:@0ms:(report note): s = UUUUUUUU
lib_test.vhdl:81:13:@0ms:(report note): S match


Use a case statement:

architecture sim_case of lib_test is
begin

    process 
        variable s:     std_logic_vector(7 downto 0);
    begin
        s := x""UU"";
        report ""s = "" &amp; to_string(s);
        case s is
            when x""UU"" =&gt;
                report ""S match"";
            when others  =&gt;
                report ""S no match"";
        end case;
        wait;
    end process;
end architecture sim_case;


also producing the same result:

ghdl -e --std=08 lib_test sim_case
ghdl -r --std=08 lib_test sim_case
lib_test.vhdl:96:9:@0ms:(report note): s = UUUUUUUU
lib_test.vhdl:99:17:@0ms:(report note): S match


Also note that if you were assigning a signal or variable you could use a selected signal assignment or a selected variable assignment, both of which represent case statements which are guaranteed to use the predefined ""="".

You could also author your own function providing an overload for ""="" operator exhibiting the correct behavior. Like the use of an alias this would depend on the use of an inner declarative region (here the process statement) to prevent the predefined operator from being used in an arithmetic context where the operator in ieee.numeric_std_unsigned is intended. 

Likewise you could author your own function for use in a function call, or with a little malice of forethought use 

  -- Id: M.5
 function STD_MATCH (L, R : STD_ULOGIC_VECTOR) return BOOLEAN;
  -- Result subtype: BOOLEAN
  -- Result: terms compared per STD_LOGIC_1164 intent


From package numeric_std.

The issue comes about from mixing evaluation of a std_logic_vector value (base type std_ulogic_vector) both as metavalues and numeric values, which is likely driven by style issues when package numeric_std type unsigned could be used along with type conversions, noting the dearth of mapping between VHDL port types and interface types in multi-language supporting simulators (such as Modelsim).

The solution to abandon strong typing may not be the ideal solution. The proficiency required to patch up your VHDL source as a result is roughly equivalent to knowing when and where to perform type conversions.  These are all 'gimmick' solutions.",,,,,
Mismatched array sizes in 2D array,"I want to create a constant 2D array with configuration values to switch the configuration over a generic value. Each configuration consists of seven 8-Bit values:

entity Foo is
   Generic (   CONFIG      : INTEGER := 0;
           );
end Foo

...

type Config_t is array(0 downto 1, 0 to 6) of STD_LOGIC_VECTOR(7 downto 0);

constant Configs        : Config_t  := ((x""39"", x""08"", x""06"", x""17"", x""01"", x""02"", x""0F""),
                                        (x""39"", x""08"", x""06"", x""17"", x""01"", x""02"", x""0C""),
                                        (others =&gt; (others =&gt; '0'))
                                        );


But I get an error

[Synth 8-421] mismatched array sizes in rhs and lhs of assignment

So what is wrong with this declaration? I donÂ´t get it.","The downto must be with descending index values, and the 2 values are given explicitly, so skip the others part, resulting in:

type Config_t is array(1 downto 0, 0 to 6) of STD_LOGIC_VECTOR(7 downto 0);

constant Configs        : Config_t  := ((x""39"", x""08"", x""06"", x""17"", x""01"", x""02"", x""0F""),
                                        (x""39"", x""08"", x""06"", x""17"", x""01"", x""02"", x""0C"")
                                        );
",,,,,
Circular Buffer: Selecting Range of Indices that Include the Wraparound Point,"I think this question is best understood with an example. So here we go:

Imagine the following are defined:

parameter number_of_points_before_point_of_interest = 4;

logic [15:0] test_data = 16'b0000111100001111;
logic [3: 0] point_of_interest;
logic [7: 0] output_data;


if the value assigned to point_of_interest is 1 and the value to number_of_points_before_point_of_interest is 4. I want my output_data to be {test_data[E: F], test_data[5:0]} or 8'b00111100.

So in essence, I want to take 8 bits starting from (point_of_interest - number_of_points_before_point_of_interest) and ending at (point_of_interest 
 - number_of_points_before_point_of_interest + 7).

Since point_of_interest is a variable number, the following two indexing methods are invalid:

To make the code more concise: point_of_interest --> pot

number_of_points_before_point_of_interest --> num_pt_before_pot

buffer[pot - num_pt_before_pot: 4'hF]  // Invalid since pot not constant
buffer[pot -: num_pt_before_pot]       // Part-select doesn't work either 


Note: Variability of pot is not an issue in the second case since starting point can be variable. Regardless, part-select does not provide the desirable results in this example.

Your help is very much appreciated. Thanks in advance","A simple trick you can do is replicate your test_data, then take a slice of it

  output_data   = {2{test_data}}[16+pot-before_pot-:2*before_pot];
",,,,,
ATM FSM has unknown output,"in my assignment, I was asked a question to design an ATM machine using state diagram in verilog HDL . I designed in this way but it is not showing correct output actually any output is not being shown . Can anyone please check? State diagram used for this is attached in the image.
Design a virtual/digital ATM machine using the Mealy model with the following features:
(i) Flashes a green light when cash is available and the machine is ready
(ii) Flashes a red light when cash is not available or there is a machine defect
(iii) When a card is inserted, it asks for a pin if the card is legal or undamaged, else returns a
message asking for resubmission.
(iv) If the wrong pin is entered, asks for re-entry of the pin at the first instant, when the second
entry is also wrong, takes the card in, raises an alarm, and goes back to the rest state.
(v) If the pin is right, prompts for an amount to be dispensed.
(vi) If the amount is more than in store, gives a sign of not enough cash and goes to rest state.
(vii) If the amount is less than in store, dispense the amount and get back to the rest state.

module Mealy_atm (output reg
                  green,red,askpin,carddam,insuf,alarm,askamt,wrongpin,collect,input cash,legal, clock, reset,input
                  [2:0]epin,amt,prepin,arepin,bal); //module for atm 
   reg [2: 0] state, next_state; //reg variables for states 
   wire       pin,wpin,equ,les; //wire variables required 
   parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011,S4 =3'b100; //required parameters 
   comparator M1 (pin,wpin,epin,prepin); //instantiation of comparator 
   comparator M2 (equ,les,amt,bal); //instantiation of comparator for amount 
   assign amtok=equ||les; //assigning value of amtok 
   comparator M3 (repin,wpin,arepin,prepin); //instantiation of comparator for repin 
   always @ ( posedge clock, negedge reset) //always block for block 
     begin //begin of always block 
        if (reset == 0) state &lt;= S0; //reset of states 
        else state &lt;= next_state; //assigning next state 
     end //end of always block 
   always @ (state,cash,legal,pin,amtok,repin) //always for nextstate caluculation 
     begin //begin for always block  
        case (state) //case for assigning next state depending on next state 
          S0: if (cash) next_state &lt;= S1; else next_state &lt;= S0; //next state if cash is present in atm 
          S1: if (legal) next_state &lt;= S2; else next_state &lt;= S1; //next state if card is legal 
          S2: if (pin) next_state &lt;= S3; else next_state &lt;= S4; //next state if pin is correct 
          S3: if (amtok) next_state &lt;= S1; else next_state &lt;= S1; //next state if amount is less than balance 
          //in atm 
          S4: if (repin) next_state&lt;= S3; else next_state &lt;= S1; //next state re-entered pin is correct 
        endcase //end of case 
     end //end of always block 
   always @ (state) //always block for outputs 
     begin //begin for always block 
        case (state) //case for different outputs in different in states 
          S0: begin //begin for outputs for S0 state 
             carddam &lt;=1'b0; //outputs for S0 state 
             insuf&lt;=1'b0; //outputs for S0 state 
             collect &lt;=1'b0; //outputs for S0 state 
             alarm&lt;=1'b0; //outputs for S0 state 
             askamt&lt;=1'b0; //outputs for S0 state 
             askpin&lt;=1'b0; //outputs for S0 state 
             wrongpin&lt;=1'b0; //outputs for S0 state 
             green&lt;=1'b0; //outputs for S0 state 
             if(!cash) red &lt;=1'b1; //outputs for S0 state 
          end //end for outputs for S0 state 
          S1: begin //begin for outputs for S1 state 
             red &lt;=1'b0; //outputs for S1 state 
             insuf&lt;=1'b0; //outputs for S1 state 
             collect &lt;=1'b0; //outputs for S1 state 
             alarm&lt;=1'b0; //outputs for S1 state 
             askamt&lt;=1'b0; //outputs for S1 state 
             askpin&lt;=1'b0; //outputs for S1 state 
             wrongpin&lt;=1'b0; //outputs for S1 state  
             green&lt;=1'b1; //outputs for S1 state 
             if(!legal) carddam&lt;=1'b1; //outputs for S1 state 
          end //end for outputs for S1 state 
          S2: begin //begin for outputs for S2 state 
             red &lt;=1'b0; //outputs for S2 state 
             insuf&lt;=1'b0; //outputs for S2 state 
             collect &lt;=1'b0; //outputs for S2 state 
             alarm&lt;=1'b0; //outputs for S2 state 
             askamt&lt;=1'b0; //outputs for S2 state 
             green&lt;=1'b1; //outputs for S2 state 
             carddam &lt;=1'b0; //outputs for S2 state 
             askpin&lt;=1'b1; //outputs for S2 state 
             if(!pin) wrongpin&lt;=1'b1; //outputs for S2 state 
          end //end for outputs for S2 state 
          S3: begin //begin for outputs for S3 state 
             red &lt;=1'b0; //outputs for S3 state 
             alarm&lt;=1'b0; //outputs for S3 state 
             askamt&lt;=1'b0; //outputs for S3 state 
             wrongpin&lt;=1'b0; //outputs for S3 state 
             green&lt;=1'b1; //outputs for S3 state 
             carddam &lt;=1'b0; //outputs for S3 state 
             askpin&lt;=1'b1; //outputs for S3 state 
             if(~amtok) insuf&lt;=1'b1; //outputs for S3 state 
             else collect &lt;=1'b1 ; //outputs for S3 state 
          end //end for outputs for S3 state 
          S4: begin //begin for outputs for S4 state 
             red &lt;=1'b0; //outputs for S4 state 
             insuf&lt;=1'b0; //outputs for S4 state 
             collect &lt;=1'b0; //outputs for S4 state 
             askpin&lt;=1'b0; //outputs for S4 state 
             wrongpin&lt;=1'b0; //outputs for S4 state  
             green&lt;=1'b1; //outputs for S4 state 
             carddam &lt;=1'b0; //outputs for S4 state 
             if(repin) askamt&lt;=1'b1; //outputs for S4 state 
             else alarm&lt;=1'b1; //outputs for S4 state 
          end //end for outputs for S4 state 
        endcase //end of case 
     end //end of case 
endmodule //end of module 


module comparator(output reg less,equal,input [2:0] Data_in_A,Data_in_B); //module for
   //comparaing two inputs 
   always @ (Data_in_A , Data_in_B) //always for inputs 
     if(Data_in_A == Data_in_B) //if block for equality 
       begin //begin for if block 
          less &lt;= 1'b0; //less value assigning 
          equal&lt;= 1'b1; //equal value assigning 
       end //end of begin 
     else if(Data_in_A &lt; Data_in_B) //if block for less 
       begin //begin for if block 
          less &lt;= 1'b1; //less value assigning 
          equal&lt;= 1'b0; //equal value assingning 
       end //end of begin of if 
     else //else for other things 
       begin //begin for else 
          less&lt;=1'b0; //less value assigning 
          equal&lt;=1'b0; //equal value assigning 
       end //end of else block 
endmodule //end of module 


// Test bench is 

module t_atm; //module for test bench  
   wire t_green,t_red,t_askpin,t_carddam,t_insuf,t_alarm,
        t_askamt,t_wrongpin,t_collect;
   //output variables
   
   reg  t_cash,t_legal, t_clock,t_reset; //input variables 
   reg [2:0] t_epin,t_amt,t_prepin,t_arepin,t_bal; //input variables 
   Mealy_atm M1              
     (t_green,t_red,t_askpin,t_carddam,t_insuf,t_alarm,
      t_askamt,t_wrongpin,t_collect ,t_cash,t_legal, 
      t_clock,t_reset,t_epin,t_amt,t_prepin,t_arepin,t_bal);
   //instantiation of Mealy_atm 
   initial #100 $finish; //termination time 
   initial //initial for clock signal 
     begin //begin of clock signal initial 
        t_clock=1'b0; //initial clock signal 
        forever #5 t_clock=~t_clock; //forever loop 
     end //end of initial block 
   initial //initial for assigning inputs 
     begin //begin for initial block 
        t_reset=1'b1; //input value of reset 
        #6 t_reset =1'b0;t_prepin=3'b000;t_bal=3'b111; //input values 
        #4 t_cash=1'b1; //input values 
        #5 t_legal=1'b1; //input values 
        #5 t_epin=3'b001; //input values 
        #5 t_amt=3'b001; //input values 
     end //end of initial block //input values 
endmodule //end of module //input values  
","You get unknown (X) on your output because you did not initialize one of your input signals: t_arepin.  It is declared as a reg type, which means its initial value is X.  When I set it to 0 in your testbench, all outputs become known.
   initial //initial for assigning inputs 
     begin //begin for initial block 
        t_reset=1'b1; //input value of reset 
        t_arepin = 0;
        #6 t_reset =1'b0;t_prepin=3'b000;t_bal=3'b111; //input values 
        #4 t_cash=1'b1; //input values 
        #5 t_legal=1'b1; //input values 
        #5 t_epin=3'b001; //input values 
        #5 t_amt=3'b001; //input values 
     end //end of initial block //input values 
",,,,,
SystemVerilog UVM Hello World Testbench error: expecting an '=' or '<=' sign in an assignment [9.2(IEEE)],"I modified a hello world UVM testbench on Eda Playground to create hierarchy of uvm sequence. While creating object of base class sequence from the virtual task body of the child class, I get the following error:
xmvlog: *E,MISEXX (my_sequence.svh,72|29): expecting an '=' or '&lt;=' sign in an assignment [9.2(IEEE)].

The offending line of code is:
base_sequence base_seq_obj = base_sequence::type_id::create(&quot;base_seq_obj&quot;);

The entire code is at this link. Only the UVM systemverilog code for the hierarchical sequences is as follows:
my_sequence.svh
class my_transaction extends uvm_sequence_item;

  `uvm_object_utils(my_transaction)

  rand bit cmd;
  rand int addr;
  rand int data;

  constraint c_addr { addr &gt;= 0; addr &lt; 256; }
  constraint c_data { data &gt;= 0; data &lt; 256; }

  function new (string name = &quot;&quot;);
    super.new(name);
  endfunction

endclass: my_transaction

class base_sequence extends uvm_sequence #(my_transaction);
 `uvm_object_utils(base_sequence)
  
  rand int value;
  
  function new(string name = &quot;base_sequence&quot;);
    super.new(name);  
  endfunction : new
  
  virtual task body;
    `uvm_info(&quot;UVM_SEQUENCE:base_sequence&quot;, &quot;Body Started&quot;, UVM_MEDIUM);
    
    req = my_transaction::type_id::create(&quot;req&quot;);
    `uvm_info(&quot;UVM_SEQUENCE&quot;, &quot;start_item call started&quot;, UVM_MEDIUM);
    start_item(req);
    `uvm_info(&quot;UVM_SEQUENCE&quot;, &quot;start_item call ended&quot;, UVM_MEDIUM);


    `uvm_info(&quot;UVM_SEQUENCE&quot;, &quot;before randomized&quot;, UVM_MEDIUM);
    if (!req.randomize()) begin
      `uvm_error(&quot;MY_SEQUENCE&quot;, &quot;Randomize failed.&quot;);
    end

    `uvm_info(&quot;UVM_SEQUENCE&quot;, &quot;after randomized&quot;, UVM_MEDIUM);

    // If using ModelSim, which does not support randomize(),
    // we must randomize item using traditional methods, like
    // req.cmd = $urandom;
    // req.addr = $urandom_range(0, 255);
    // req.data = $urandom_range(0, 255);

    `uvm_info(&quot;UVM_SEQUENCE&quot;, &quot;Before finish_item call.&quot;, UVM_MEDIUM);
    finish_item(req);
    `uvm_info(&quot;UVM_SEQUENCE&quot;, &quot;After finish_item call.&quot;, UVM_MEDIUM);
    
    `uvm_info(&quot;UVM_SEQUENCE:base_sequence&quot;, &quot;Body Ended&quot;, UVM_MEDIUM);
  endtask : body
  
endclass: base_sequence

class my_sequence extends base_sequence;

  `uvm_object_utils(my_sequence)
  
  rand integer n_times;
  
  constraint times { n_times inside { [1:4] };}

  function new (string name = &quot;&quot;);
    super.new(name);
  endfunction

  virtual task body;
    `uvm_info(&quot;UVM_SEQUENCE:my_sequence&quot;, &quot;Body Started&quot;, UVM_MEDIUM);
    base_sequence base_seq_obj = base_sequence::type_id::create(&quot;base_seq_obj&quot;);
    base_seq_obj.randomize();
    value = base_seq_obj.value;    
    
    repeat(n_times) begin
      `uvm_do_with(base_seq, {base_seq_obj.value  == value;}) 
    end
    `uvm_info(&quot;UVM_SEQUENCE:my_sequence&quot;, &quot;Body Ended&quot;, UVM_MEDIUM);
  endtask: body

endclass: my_sequence

","Within any procedural block, variable declarations must precede any other statements. Change
virtual task body;
    `uvm_info(&quot;UVM_SEQUENCE:my_sequence&quot;, &quot;Body Started&quot;, UVM_MEDIUM);
    base_sequence base_seq_obj = base_sequence::type_id::create(&quot;base_seq_obj&quot;);
    base_seq_obj.randomize();
    ...

to
virtual task body;
    base_sequence base_seq_obj = base_sequence::type_id::create(&quot;base_seq_obj&quot;);
    `uvm_info(&quot;UVM_SEQUENCE:my_sequence&quot;, &quot;Body Started&quot;, UVM_MEDIUM);
    base_seq_obj.randomize();
    ...

or you can split the declaration from the initialization
virtual task body;
    base_sequence base_seq_obj;
    `uvm_info(&quot;UVM_SEQUENCE:my_sequence&quot;, &quot;Body Started&quot;, UVM_MEDIUM);
    base_seq_obj = base_sequence::type_id::create(&quot;base_seq_obj&quot;);
    base_seq_obj.randomize();
    ...
",,,,,
What is the difference between the symbol '->' and '|->' in System Verilog Assertion Properties,"I have encountered an example property which works here:
property p_a;
    @(posedge clk) $rose(a) -&gt; $rose(b);
endproperty

There is no syntax error above.
Then I tried to modify to this
property p_a;
    @(posedge clk) $rose(a) -&gt; ##2 $rose(b);
endproperty

Which gives me syntax error, only to realize its not actually '|-&gt;'
property p_a;
    @(posedge clk) $rose(a) |-&gt; ##2 $rose(b);
endproperty

This works, so what is the symbol -&gt; actually here in property? I know usually its for triggering an event.","The -&gt; operator is a logical implication operator, works on the logical operands:

The logical implication expression1 â€?gt; expression2 is logically equivalent to
(!expression1 || expression2)

The |-&gt; is a sequential implication used to express certain temporal properties.

The implication construct specifies that the checking of a property is performed conditionally on the match of a sequential antecedent ... This construct is used to precondition monitoring of a property expression and is allowed at the property
level. The result of the implication is either true or false. The left-hand operand sequence_expr is called the antecedent, while the right-hand operand property_expr is called the consequent...

In other words, the first one is can be used for logical functions, the second is used in sequences of events. They are very much different.",,,,,
Verilog For loop,"I have the following code in verilog to test a For loop:
module test1;

reg [2:0] i;

initial
begin
    for(i=0;i&lt;=3;i=i+1) begin
         #10;
         $display(&quot;%d&quot;,i);
    end
end

endmodule

The printed output shows:
0
1
2
3
Which makes sense to me. But the waveform below confuses me:

How does the reg 'i' take the value '4' here?
This is part of a bigger code I am working on where I have many nested for loops used in a testbench.
I am adding a nested loop which behaves weird:
module test1;

reg signed [2:0] i,j;

initial
begin
    for(i=-3;i&lt;=3;i=i+1) begin
        for(j=-3;j&lt;=3;j=j+1) begin
            #10;
            $display(&quot;%d   %d&quot;,i,j);
        end
    end
end

endmodule

The output waveform is shown below:

Why is the 2nd loop not working and first loop keep repeating?","This has to do with how for loops know when to stop.
When you write
for(i=0;i&lt;=3;i=i+1)

this says three things:

i starts at 0
The loop continues until i&lt;=3 becomes false
Each time, increment i by one

The thing is, i&lt;=3 can't become false until i becomes 4. When i becomes 4, the loop stops looping. But i is still 4.

In your nested loop example, the problem is overflow.
You have declared j as signed three bits:
reg signed [2:0] i,j;

But you are looping until j becomes 4:
for(j=-3;j&lt;=3;j=j+1)

There is no way to represent 4 as a signed three bit integer. Because j&lt;=3 must always be true, the loop can never stop.",,,,,
DMA writing to allocated memory misses the first two adresses on the first write,"I'm playing around with a ZYNQ7 (Dual-Core ARM) with a FPGA. The FPGA design has a 32-bit counter accessing the DDR via a DMA controller in chunks of 256-packets.
In the C-Code for the processor 1, I run a LWIP application to connect via ethernet to my pc.
There I allocate ram memory for the DMA transactions. The address of the pointer is passed via shared memory to the 2nd Core.
#define RCVADDR 0x1ef00002
u32_t * send=NULL;
u32_t* addr = (uint32_t*)RCVADDR;

//Allocating the memory once initially
if(send==NULL){
        send=malloc(256*sizeof(uint32_t));
    }

    *addr = (uint32_t)send;
    //starting the DMA on Core 2
    *getdma=1;


Using a handshake I initialize the DMA transactions in the second core and send the Data after finished transactions to the PC using a TCP connection on the 1st Core.
#define GetDMA  0x1ef00001
#define DONEDMA 0x1ef00003

uint8_t* getdma = (uint8_t*)GetDMA;
uint32_t* addr=(uint32_t*)RCVADDR;

    while(1){
        if(*getdma == 1){
            StartDMATransfer(*addr, 2048);  // The Number 2048 is the number Of Transfered Packets. It has to be at least the amount of Packets my Counter transfers in chunks. The design has a packet end indicator on its own. So 256 or bigger works the same as 256
            *getdma =0;

            Xil_DCacheFlush();

        }
    }

Before establishing a TCP-connection I flush the DCache
void send_data(){
    int ip_addr[4];
        u8_t i=0;

        char * token = strtok(ip,&quot;.&quot;);
        ip_addr[0] = atoi(token);

        while(token != NULL){

            ip_addr[++i]=atoi(strtok(NULL,&quot;.&quot;));
        }
        Xil_DCacheFlushRange(send, 256*sizeof(uint32_t));

        //sleep(0.5);
        connect(ip_addr,atoi(port));
}

The Problem: The first Transmission Cycle after programming the Device shows:
[1280, 1281, 2, 3, 4, 5, 6,.....
....., 248, 249,1530, 1531, 1532, 1533, 1534, 1535]
The first 2 Values and the last 6 values are from a previous Cycle before reprogramming the device.
However, this only occurs on the first DMA Transaction. Afterwards, while the device runs it never occurs once again.
Any Ideas?","I found a solution....
I had to flush the Cache after allocating the memory, before passing the address to the 2nd Core for processing.",,,,,
User Flash Memory Page Address,I'm using max10 FPGA  user flash memory in my project . It has 4 pages in one sector each page is 64kbits of size. Now how to identify what is starting and ending address of each page in memory to write or read data from flash memory.,"You can find a design example here:
https://fpgacloud.intel.com/devstore/platform/17.1std.1/Standard/utilizing-the-user-flash-memory-ufm-on-max-10-devices-with-a-nios-ii-processor/
The User Guide is here:
https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/hb/max-10/ug_m10_ufm.pdf
The UFM &amp; CFM array size is dependent on the device you have chosen as shown in the following table:

Also, the sectors you can access depend on the configuration mode you use. These are shown in the following tables:

So, my latest design uses a flash 10M08 with dual compressed images. That means I can only access Sector 0 &amp; 1 and each Sector has 8 pages with each page have a size of 16 Kb. Note that the datasheet states sizes in Kibibits where a Kb is 1024 bits, not 1000. Converting to bytes gives a page size of 2048 Bytes. The Avalon Interface requires you to access using Hex addresses that refer to the actual byte number. This means that, in my example, each page would be 0x0800 bytes in size. Thus, the each page would start at + 0x0800 e.g.
Sector 0 Page 0 Start Addr = 0x0000
Sector 0 Page 1 Start Addr = 0x0800
Sector 0 Page 2 Start Addr = 0x1000
...
Sector 1 Page 7 Start Addr = 0x7800

Another way to identify the addresses is to look at what's reported in the IP Parameter Editor:

As you can see, it gives the start and end addresses of each sector. To find the page sizes, just divide the given address space by 8 and then you can work out the start address for each one.
Why Intel/ Altera had to use Kibibits rather than just Bytes in their datasheet is beyond me.",,,,,
How to write new line to file in VHDL?,"I would like to separate my data with new line character in an output file, but the following codes result in error &quot;can't resolve overload for procedure call&quot;:
write(out_line, &quot;\n&quot;); 
write(out_line, &quot;&quot;); 
write(out_line, '');

An example code how I want to use it:
ENTITY writer IS 
PORT ( clk : IN STD_LOGIC := '0'; start : IN STD_LOGIC := '0');
END ENTITY;

ARCHITECTURE arch OF writer IS
    SIGNAL vect : STD_LOGIC_VECTOR (2 downto 0) := &quot;000&quot;;
    TYPE state_type IS (init, write_file);
    SIGNAL state : state_type := init;
BEGIN
    PROCESS (clk, start)
        FILE out_file : text;
        VARIABLE out_line : line;
    BEGIN
       IF rising_edge(clk) THEN
           CASE state IS 
               WHEN init =&gt; 
                   IF start = '1' THEN
                       state &lt;= write_file;
                   ELSE 
                       state &lt;= init;
                   END IF;
               WHEN write_file =&gt;
                   state =&gt; init;

                   FOR i IN 0 TO 10 LOOP
                       write(out_line, vect);
                       writeline(out_file, out_line);
                       -- write(out_line, &quot;\n&quot;); &lt;-- 
                       -- write(out_line, &quot;&quot;); &lt;-- 
                       -- write(out_line, ''); &lt;-- None of these work
                       writeline(out_file, out_line); 
                   END LOOP;
           END CASE;
       END IF;
   END PROCESS;
END ARCHITECTURE;
               

So I would like to know, is it possible in VHDL? If yes, how?","The following will consistently give you a single blank line:
write(out_line, string'(&quot;&quot;));  
writeline(out_file, out_line);

I suspect what @Dani posted may be tool dependent.   For example while on one popular simulator, the following produces one line feed:
write(out_line, LF);  
writeline(out_file, out_line);

However when I add a space after the LF, I get two lines:
write(out_line, LF &amp; ' ');  
writeline(out_file, out_line);
",,,,,
UVM end of test,"In case I want to end the simulation from my monitor (I know that it is not the recommended way) how can I do this?
lets say I got this code inside my monitor:
Virtual task monitor_run();

fork

forever begin
.....
end

forever begin
.....
end

forever begin
.....
end

join

endtask : monitor_run

Every forever loop check that outputs of the DUT came on time, in case they doesnt it should stop simulation.
This special monitor should break the simulation in case of mismatch(error) and there is no Scoreboard.
I still want to manage nice end of simulation behaviour. I tried use raise and drop objection but I get an error of OBJT_ZERO sometimes. Does anyone knows a good way to end the simulation in that case?
thanks!","The UVM is set up by default so that uvm_report_fatal ends the test immediately, and uvm_report_error lets the simulation continue until hitting an error limit that you can set. And you can control the actions of each severity for an individual component. See uvm_report_object which is the base class of uvm_component.
Upon ending the test, the UVM calls uvm_report_server::report_summarize() that dumps out all the severity counts. If you insist, you can create a final block in your testbench module that gathers the severity counts from the report server and print the last message. For example:
module top;
  initial run_test();


  uvm_report_server rs = uvm_report_server::get_server();

  final if (rs.get_severity_count(UVM_FATAL) != 0 ||
            rs.get_severity_count(UVM_ERROR) !=0 )
            $display(&quot;Test Failed&quot;);

endmodule

But this is really unnecessary and may not catch other non-UVM errors like assertion failures or timing checks. Many tools have a TESTSTATUS exit code that reports the most severe message encounte, UVM or tool.",,,,,
"Error (10327) can't determine definition of operator """"=""""","For this VHDL design description:
library ieee;
     use ieee.std_logic_1164.all;
     use ieee.std_logic_arith.all;

entity four_bit_counter is
    port (
        count_out : out unsigned (3 downto 0);
        clk : in std_logic;
        enable:in std_logic;
        reset: in std_logic) ;
    end four_bit_counter;
    
architecture arc of four_bit_counter is
    signal count : unsigned (3 downto 0);
    begin
        process (clk, reset, enable)
            begin
                if (reset = '1') then
                count &lt;= &quot;0000&quot;;
            elsif (clk' event and clk = '1') then
                if (enable = '1') then
                    if (count=&quot;1010&quot;) then
                    count&lt;=&quot;0000&quot;;
                    else
                        count &lt;= count +1;
                end if;
            end ;
        end if;
    end process;
            count_out &lt;= count;
            end arc;

I have the error
Error (10327): VHDL error at four_bit_counter.vhd(22): can't determine definition of operator &quot;&quot;=&quot;&quot; -- found 2 possible definitions

and I don't know how to fix this.","The two possible definitions are both from package std_logic_arith
function &quot;=&quot;(L: UNSIGNED; R: UNSIGNED) return BOOLEAN;
function &quot;=&quot;(L: SIGNED; R: UNSIGNED) return BOOLEAN;

The ambiguity comes from overload resolution for the equality operator due to the package providing the second definition and how the type of the right operand a string literal is determined.
See IEEE Std 1076-2008 9.3.2 Literals:

String and bit string literals are representations of one-dimensional arrays of characters. The type of a string or bit string literal shall be determinable solely from the context in which the literal appears, excluding the literal itself but using the fact that the type of the literal shall be a one-dimensional array of a character type. The lexical structure of string and bit string literals is defined in Clause 15.

Here the context is the equality operator, where 12.5 The context of overload resolution specifies the error:

Overloading is defined for names, subprograms, and enumeration literals.
For overloaded entities, overload resolution determines the actual meaning that an occurrence of an identifier or a character literal has whenever the visibility rules have determined that more than one meaning is acceptable at the place of this occurrence; overload resolution likewise determines the actual meaning of an occurrence of an operator or basic operation (see 5.1).
At such a place, all visible declarations are considered. The occurrence is only legal if there is exactly one interpretation of each constituent of the innermost complete context. ...

Overloads for operators are provided by function declarations (
4.5.2 Operator overloading). For a binary operator the left operand is association with the first function parameter and the right parameter is associated with the second parameter. The return value is a Boolean (again from context, it's an if statement's condition which is a Boolean expression).
The type of the right operand can't be determined from context.
There are several possible solutions

Use the IEEE's numeric_std package instead where functions implementing operators don't have both signed and unsigned operands. Package numeric_std is incorporated into the standard's -2008 revision leading to package std_logic_arith's eventual deprecation.

Use a qualified expression (9.3.5) to specifically state the type of the operand.


        if count = unsigned'(&quot;1010&quot;) then

(the redundant parentheses around the condition have been removed for clarity)

Rely on an abstract literal (15.5) where the ambiguity doesn't exist. This can either be of the form of a decimal literal (15.5.2) or based literal (15.5.3).

Use a function call to the overloaded operator's declaration with a selected name noting that named association can't be used for operator overloads.

Define an object (here a constant) with that value provided by a value expression. The type is inherent in an object declaration.

",,,,,
Logical && versus bitwise & in Verilog,"Consider the following assignment
A1 = (b[3:0] ==c[3:0] &amp; d[3:0]==e[3:0]) ? 1'b1 : 1'b0 ;
A2 = (b[3:0] ==c[3:0] &amp;&amp; d[3:0]==e[3:0]) ? 1'b1 : 1'b0 ;
Are the 2  assignments equivalent or they could be different depending on tools?
Is it possible that (b[3:0] ==c[3:0]) evaluated as T/F is dependent on tool Whether it stores T as '1' or '0'.","The result of the equality, relational and logical operators are defined in sections 11.4.4-7 of the IEEE 1800-2017 LRM. There is no room for implementation differences. Truth is defined as 1'b1, and false is defined as 1'b0.
Note there are slight differences in precedence between the logical and bitwise operators, and it's easy to mix them up when you start dealing with multiple bit results, so use the bitwise operators only if your intent is to deal with multi-bit results.",,,,,
How to get declaration order AUTOINST with emacs verilog-mode?,"When using vim autoinstantiation, I get an AUTOINST in declaration order as shown. But, I need to use emacs AUTO_TEMPLATE for multiple instantiations, so I am trying to use &quot;emacs --batch file.v -f verilog-batch-auto&quot;. Unfortunately, this is giving a sorted order. How can I get this declaration order AUTOINST using emacs verilog-mode?
DWC_mipi_dsi_host i_DWC_mipi_dsi_host_left
    (/*AUTOINST*/
      //APB Interface
    .presetn                        (presetn                                              ), // input 
    .pclk                           (pclk                                                 ), // input 
    .paddr                          (paddr[9:0]                                           ), // input 
    .penable                        (penable                                              ), // input 
    .psel                           (psel                                                 ), // input 
    .pwrite                         (pwrite                                               ), // input 
    .pwdata                         (pwdata[31:0]                                         ), // input 
    .prdata                         (prdata[31:0]                                         ), // output
    .interrupt                      (interrupt                                            ), // output
      //DPI INTERFACE
    .dpipclk                        (dpipclk                                              ), // input 
    .dpivsync                       (dpivsync                                             ), // input 
    .dpihsync                       (dpihsync                                             ), // input 
    .dpipixdata                     (dpipixdata[`DSI_HOST_PIXELDATAWIDTH-1:0]             ), // input 
    .dpidataen                      (dpidataen                                            ), // input 
    .dpishutdn                      (dpishutdn                                            ), // input 
    .dpicolorm                      (dpicolorm                                            ), // input 
    .dpiupdatecfg                   (dpiupdatecfg                                         ), // input 
    .edpihalt                       (edpihalt                                             ), // output

According to the documentation at http://doc.endlessparentheses.com/Fun/verilog-auto-inst.html it seems I need to use verilog-auto-arg-sort:nil and verilog-auto-inst-sort:nil
I have tried to set them in ~/.emacs and in the bottom of the file, but there is no difference. Any ideas?
// Local Variables:
// verilog-library-flags:(&quot;-f ../src/files.vc&quot;)
// verilog-auto-arg-sort:nil
// verilog-auto-inst-sort:nil
// End:
","As it turns out, this is due to an older version of verilog-mode which came preinstalled with emacs.
emacs Verilog --&gt; Version and FAQ
You are using verilog-mode 2017-08-07-c085e50-vpo-GNU

This can be fixed by updating verilog-mode according to instructions at https://www.veripool.org/wiki/verilog-mode",,,,,
Generating second counter in VHDL,"I am new to VHDL and trying to generate 1 second counter. For simplicity, I am using the clock frequency of 10 Hz. For this purpose I am using a clk as an input and LED as an output. My VHDL code is given below:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
use ieee.numeric_std.all;

entity tick_counter is
    generic(FrequencyHz : integer := 10);
    Port ( clk : in  STD_LOGIC;
           led : out  STD_LOGIC);
end tick_counter;

architecture Behavioral of tick_counter is
    signal tick :integer;
    signal counter :integer;
begin
    process(clk, tick, counter)
    begin
        if rising_edge(clk) then
            if tick = FrequencyHz - 1 then
                tick &lt;= 0;
                counter &lt;= counter + 1;
            else
                tick &lt;= tick + 1;
            end if;
        end if;
    end process;

    led &lt;= '1' when counter = 3 else '0';
end Behavioral;

I tried to write the code in such a way so that, when three seconds pass, the LED turns ON. My test bench code is given below:
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;
use ieee.numeric_std.all;
 
-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--USE ieee.numeric_std.ALL;
 
ENTITY tick_counter_tb IS
END tick_counter_tb;
 
ARCHITECTURE behavior OF tick_counter_tb IS 
 
    -- Component Declaration for the Unit Under Test (UUT)
     -- We're slowing down the clock to speed up simulation time
    constant FrequencyHz : integer := 10; -- 10 Hz
    constant clk_period  : time    := 1000 ms / FrequencyHz;
 
    COMPONENT tick_counter
    PORT( clk : IN  std_logic;
          led : OUT  std_logic);
    END COMPONENT;

    --Inputs
    signal clk : std_logic := '0';

    --Outputs
    signal led : std_logic;

BEGIN
 
    -- Instantiate the Unit Under Test (UUT)
    uut : entity work.tick_counter
        generic map(FrequencyHz =&gt; FrequencyHz) 
        PORT MAP (clk =&gt; clk,
                  led =&gt; led);

    -- Clock process definitions
    clk_process :process
    begin
        clk &lt;= '0';
        wait for clk_period/2;
        clk &lt;= '1';
        wait for clk_period/2;
    end process;

    -- Stimulus process
    stim_proc: process
    begin       
        -- hold reset state for 100 ns.
        wait until rising_edge(clk);
        -- insert stimulus here 

        wait;
    end process;

END;

But in the simulation result, I am just seeing a blank diagram as shown below (link given):

I don't understand where I am making a mistake. Any help would be highly appreciated.","The default initial value of an integer is INTEGER'LOW (a very negative number).
That means counter won't become 3 for a very long time (as the busybee indicated).
You can constrain and/or provide an initial value for tick. counter appears to be meant as a modulo counter range 0 to 3. It's modulus could be passed identically to tick which uses FrequencyHZ. Also note that any integer counter needs explicit roll over, it's an error if the result of an addition doesn't fall with the range INTEGER'LOW to INTEGER'HIGH or the constrained range.
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
-- USE ieee.std_logic_unsigned.ALL;
-- use ieee.numeric_std.all;

entity tick_counter is
    generic(FrequencyHz : integer := 10);
    Port ( clk : in  STD_LOGIC;
           led : out  STD_LOGIC);
end tick_counter;

architecture Behavioral of tick_counter is
    -- Initial value of integers is INTEGER'LOW (a large negative number)
    signal tick:    integer range 0 to FrequencyHz - 1 := 0;
    signal counter: integer := 0;   -- ADDED default initial value
begin
    process(clk, tick, counter)
    begin
        if rising_edge(clk) then
            if tick = FrequencyHz - 1 then
                tick &lt;= 0;
                if counter = 3 then  -- ADDED MODULUS 4 test for counter
                    counter &lt;= 0;
                else
                    counter &lt;= counter + 1;
                end if;
            else
                tick &lt;= tick + 1;
            end if;
        end if;
    end process;

    led &lt;= '1' when counter = 3 else '0';
end Behavioral;

With the changes the simulation will cause led to be a '1' for one second every four seconds.
",,,,,
Bit order for generaic std_logic_vector with dynamic width,"I have a generic std_logic_vector with dynamic length as suggested here: https://stackoverflow.com/a/28513417/12978575
entity lfsr is
    generic(
        INIT : std_logic_vector
    );
[...]
end entity;

Later, I want to access the bits of INIT individually in a way where order matters. How can I ensure that the bit order of INIT will always be a downto bit order (for example 3 downto 0 when having 4 bit length) and never a to order (for example 0 to 3)?","You can provide a deterministic descending range with an object alias:
library ieee;

use ieee.std_logic_1164.all;
entity lfsr is
    generic (
        INIT:  std_logic_vector
    );
    -- In the entity declarative part:
    alias DINIT: std_logic_vector(INIT'LENGTH - 1 downto 0)  is INIT; 
end entity lfsr;

Use DINIT in the architecture where you'd have previously used INIT.
You could alias INIT in the architecture block declarative part or any declarative region (e.g. process statement, block statement, generic_statement, subprogram definition) in the architecture within the scope of the generic declaration:
library ieee;

use ieee.std_logic_1164.all;
entity lfsr is
    generic (
        INIT:  std_logic_vector
    );
end entity lfsr;

architecture foo of lfsr is
    alias DINIT: std_logic_vector(INIT'LENGTH - 1 downto 0)  is INIT;
begin
end architecture;
",,,,,
Wait trigger data only catching the first event,"I am using OVM
My code is triggering an ovm event in one place (I added a print to confirm). However, in another place I'm waiting for that trigger and it's only &quot;caught&quot; once (also here I added a print to confirm).
function void trigger_event_for_incoming_transaction(ovm_object txn);
    if (is_type_1(txn))
      type_1.trigger(txn);            
endfunction

And somewhere else:
    task look_for_type_1();    
      forever begin
        type_1.wait_trigger_data(my_obj);
      end
    endtask

I can't paste most of the code due to intelucatal property...
But I registered event properly etc.","OVM/UVM's trigger and wait_trigger works the same as SystemVerilog's event trigger -&gt;e and event control @eâ€”the event control has to block waiting for the trigger before executing the trigger. You can use the triggered method of an event in wait(e.triggered()) which returns true from the point when the triggered until the end of the time step. Then the ordering between the trigger and the event control within the time step no longer matters; a persistent trigger.
You can try using OVM's wait_ptrigger_data which uses this triggered method underneath.",,,,,
Integer output turns to binary in synthesize ISE,"I have a VHDL BCD counter whose output is an integer value (digit).
But when I simulate the code in Xilinx ISE it shows the code's waveform in binary value. The code works but the output should be integer but it's not. I have tested this code in Modelsim and the output is correct and it's in integer value. This problem is in code synthesize too and the value is binary.
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity bcdcnt is
    Port ( clk : in  STD_LOGIC;
           digit : out  INTEGER RANGE 0 TO 9);
end bcdcnt;

architecture Behavioral of bcdcnt is

begin   
count: PROCESS(clk)
    VARIABLE temp : INTEGER RANGE 0 TO 10;
    BEGIN 
        IF (clk'EVENT AND clk = '1') THEN 
            temp := temp + 1;
            IF (temp = 10) THEN temp := 0;
            END IF;
        END IF;
        digit &lt;= temp;
    END PROCESS count;
end Behavioral;
","That's what synthesis does.
That's what synthesis MUST do : it translates your high level design to the resources in your FPGA or ASIC, which are binary. So, what's the problem here?
If you need to simulate the post-synth result, the usual approach is to create a wrapper entity that takes the correct port types, and translates between those and the post-synthesis netlist component.
Then, simulation should work with either the original entity, or this wrapper entity, both of which have integer ports.
Better still, you can re-use the same entity, and add the wrapper as a second architecture, thus guaranteeing that it uses the same interface (ports).
(You can even instantiate both the original and post-synth in its wrapper in the testbench, in parallel with a comparator on their outputs, to see they both do the same thing. But note there will be gate-level delays between them; usually you check outputs only on clock edges so these do not matter.)

Another approach is to restrict port types on the top level of the design to binary types like std_logic_vector. This plays nicer with badly designed tools, like ISE where the automatically generated testbench will have binary port types, (I generally edit them back to the correct ones; it's almost easier to write TBs from scratch).
But it restricts you to using an obscure and complex design style instead of higher level abstractions like Integers.
It's bad - really bad - that this approach is taught and encouraged so widely. But it is, and sometimes you'll just have to live with it. (Even in this approach, there's no reason to avoid decent abstractions internal to the FPGA, as long as the synthesis tool understands them).

A third approach - roughly, &quot;trust, but verify&quot; - is to trust that synthesis tools are competently written - which is usually true - and forget about post-synthesis simulation.
Just verify the design thoroughly at the behavioural level in simulation, then synthesise it, and test in live FPGA.
99% of the time (unless you're writing really weird VHDL), synth and P&amp;R have done the right thing, and any differences you see are due to the aforementioned I/O timings (gate delays at the I/O pins). Then model these in the testbench and/or wrapper until you see the same behaviour in both (fix anything that needs fixing, and re-synthesise).
In this approach you only need to bother with the (MUCH slower) post-synth and post-PAR simulations if you need to track down a suspected synthesis tool bug.
This does happen : I've seen two in a quarter century.
Most of the time I just use the third approach.",,,,,
Recursively compile files in a directory using Modelsim and a TCL script,"I use modelsim to simulate my HDL designs. I would like to build a script-based workflow so that I don't have to use the GUI and can simulate faster.
My typical directory tree is:
rtl/
  includes/
  module1/
  module2/

What I need to do is to compile all the .sv and .vhd files that might be in the rtl folder and load the design in modelsim.
I have a scheleton for my script which is:
quit -sim
vdel -all -lib work
vlib work
vmap work work

# compile systemverilog
vlog -work work -svinputport=net rtl/file1.sv
vlog -work work -svinputport=net rtl/module1/file2.sv

# compile vhdl
vcom -work rtl/file3.vhd
vcom -work rtl/module2/file4.vhd

# Load design
vsim work.top_name -voptargs=+acc

run -all

What I would like to do is to automate the search for .sv and .vhd file and compile them in correct order.
A basic solution I tried, uses a foreach loop:
 foreach file [fileutil::findByPattern $basepath *.sv] {
    vlog -work work -svinputport=net $file
  }

But modelsim is not happy with this as file may be not always compiled in correct order.
Any hint would be appreciated, thanks in advance.
Andrea","It's not possible to automatically order SystemVerilog files unless you establish some coding conventions.
Macros and other compiler directives are sensitive to compilation order and there are too many cases where the only way to handle it with an explicitly ordered file list. With macros, you typically typically use  `include &quot;file.svh&quot; where ever the macros are needed, and the file.svh does not wind up on the command line.
Package references require parsing the file, and if the only reference to a package is via an import statement, you might be able to write a script to build a dependency list by parsing through all the files.
But most people just manually create files that have the necessary files in the correct order. This will alway be more efficient because the files only need to be parsed once in the correct order.",,,,,
Synthesized for loop in always_ff block,"I want to write the following code to be more readable and nicer looking.
always_ff @(posedge clk or negedge rst_n) 
    if(!rst_n)
        line_pipe &lt;= 0;
    else 
        begin
            line_pipe[00] &lt;= Func(inline);
            line_pipe[01] &lt;= Func(line_pipe[00]);
            line_pipe[02] &lt;= Func(line_pipe[01]);
            line_pipe[03] &lt;= Func(line_pipe[02]);
            line_pipe[04] &lt;= Func(line_pipe[03]);
            line_pipe[05] &lt;= Func(line_pipe[04]);
            line_pipe[06] &lt;= Func(line_pipe[05]);
            line_pipe[07] &lt;= Func(line_pipe[06]);
            line_pipe[08] &lt;= Func(line_pipe[07]);
            line_pipe[09] &lt;= Func(line_pipe[08]);
            line_pipe[10] &lt;= Func(line_pipe[09]);
            line_pipe[11] &lt;= Func(line_pipe[10]);
            line_pipe[12] &lt;= Func(line_pipe[11]);
            line_pipe[13] &lt;= Func(line_pipe[12]);
            line_pipe[14] &lt;= Func(line_pipe[13]);
            line_pipe[15] &lt;= Func(line_pipe[14]);
        end


Can I rewrite this code with a for loop?","Assuming your current code synthesizes, this should synthesize as well.  You can use a for loop for 15 of the 16 assignments:
always_ff @(posedge clk or negedge rst_n) 
    if(!rst_n)
        line_pipe &lt;= 0;
    else 
        begin
            line_pipe[00] &lt;= Func(inline);
            for (int i=1; i&lt;16; i++) begin
                line_pipe[i] &lt;= Func(line_pipe[i-1]);
            end
        end
",,,,,
Is it possible to convert from Bits to SpinalEnum?,I have a SlaveFactory and I'd like to save some flags in registers as SpinalEnums. Is it possible to cast Bits to my SpinalEnum on write operation?,"I figured it out. Basically on AxiLite4SlaveFactory side I have something like this:
val gen_stop_type = RegInit(StopType.stop_frame.asBits)
busCtrl.write(gen_stop_type, JumboBridgeAXIReg.GEN_STOP.id)
io.gen_stop_type_o.assignFromBits(gen_stop_type)

StopType is my SpinalEnum. So going line by line:

The key here is .asBits, when initialising with a default value â€?it is in Bits type, but with correct bit length according to StopType length when encoded in hardware.
A regular SlaveFactory.write method (which now references to Bits register, not StopType register, what caused errors before).
The key is .assignFromBits, which I found, when looking through docs. Basically every hardware type has this method (and SpinalEnum is a hardware type), so it's possible to &quot;convert&quot; Bits (with width previously derived from the enum) to StopType enum.
",,,,,
SystemVerilog calculations right before writing to clocking block,"I have a task, whose job it is to drive data onto a bus via a clocking block. See snippet:
task effects_driver::ReadQueueData();
  stream_intf_.cycles(); // clocking block event
  if (sample_q_.size() &gt;= 2) // check to see if there is enough data in the queue
    begin
      automatic bit [31:0] sample0, sample1;
      sample0 = sample_q_.pop_front(); // read from queue
      sample1 = sample_q_.pop_front(); // read from queue
      stream_intf_.cb.AXIS_TDATA &lt;= {sample1, sample0}; // drive two samples at once
      stream_intf_.cb.AXIS_TVALID &lt;= 1;
    end
  else
    ...
endtask

You'll notice that I need to read a couple of items out of a queue before writing it to the clocking block. Is this the correct way to do it? Am I guaranteed that the simulator will perform these blocking assignments to the automatic variable before writing it to the clocking block?
Thanks!
P.S. I run into this scenario semi-frequently--where I need to do some quick calculations on the fly right before writing to the clocking block.","I believe you meant to ask &quot;Am I guaranteed that the simulator will perform these blocking assignments to the automatic variable before writing it to the clocking block?&quot; because that is what your code is doing.
The answer to that is yes, blocking assignments are guaranteed to complete before executing the statement following it.
Also note that there is no need to declare sample0 and sample1 with automatic lifetimes because class methods always have automatic lifetimes. Variables declared within them are implicitly automatic.",,,,,
Verilog wire to register,"I have a bidirectional bus and I can read the inputs from it into wires, but I have a hard time do logic with them and assign them back on the BUS as an output, or connecting them into registers so I could work with the values.
All help and response is appreciated.
JozsÃ³","There are two basic classes of variables in verilog: nets and regs. reg is used to do calculations in procedural blocks, nets are used to connect different entities such as module instances or UDPs.
So, they have different functions and different rules and operators. So, wires are connected through module instance ports and/or a continuous assign operators, which ideally represent wire connections.
The basic rule are

a net value can be used as a rhs of a register expression. So, it can be assigned to a register within a procedural (e.g. always) block.
a reg value can be assign to a net in a continuous assign operator, or in an output port connection.
net cannot be assigned any value within an always block
reg cannot be assigned with a continuous assignment

The basic scheme to work around it is the following:
wire --&gt; always block ( reg ) --&gt; assign (wire)
Here is an example:
module top (bus, en);
   inout wire bus;
   input wire en;
    
   reg tmp;
  
   always @*
     tmp = bus;

  assign bus = en ? tmp : 1'bz;

endmodule
",,,,,
verilog module renaming using precompiler,"I want to name a module using a `define directive
It seems to work if I use a macro like :
`define module_rename(NAME,TAG) ``NAME``TAG

module `module_rename(foo,_A) (...);

but it fails (in quartus) if I do the following :
`define NAME foo
`define TAG _A

module `NAME`TAG (...);

Syntax Error near_A missing&quot;;&quot;
Any idea what is wrong ?
Tx for your help","The SystemVerilog token pasting operator `` is only allowed in the body of a `define text macro, and that is the only place you can join text together to form a single identifier. The second example you wrote is seen as illegal syntax.
module foo _A;
",,,,,
"How Can I Solve ""Failed To Source Bitbake"" With Xilinx Petalinux SDK","I am running Ubuntu 16.04 with Xilinx Petalinux 2018.03 SDK. After a number of successful compilations I am now facing this error
$ petalinux-build
[INFO] building project
[INFO] sourcing bitbake
ERROR: Failed to source bitbake
ERROR: Failed to build project

How can I solved this issue?","First you need to investigate the error a little further, do this:
source /opt/pkg/petalinux/2018.3/settings.sh

It will return something similar to this below:
PetaLinux environment set to '/opt/pkg/petalinux/2018.3'
INFO: Checking free disk space
INFO: Checking installed tools
INFO: Checking installed development libraries
INFO: Checking network and other services

Source the environment setup:
source /opt/pkg/petalinux/2018.3/components/yocto/source/aarch64/environment-setup-aarch64-xilinx-linux

followed by:
devtool --help

In my case I can see more about the actual error:
NOTE: Starting bitbake server...
ERROR: Unable to start bitbake server
ERROR: Last 10 lines of server log for this session (/opt/pkg/petalinux/2018.3/components/yocto/source/aarch64/bitbake-cookerdaemon.log):
Traceback (most recent call last):
  File &quot;/opt/pkg/petalinux/2018.3/components/yocto/source/aarch64/layers/core/bitbake/lib/bb/daemonize.py&quot;, line 77, in createDaemon
    function()
  File &quot;/opt/pkg/petalinux/2018.3/components/yocto/source/aarch64/layers/core/bitbake/lib/bb/server/process.py&quot;, line 433, in _startServer
    self.cooker = bb.cooker.BBCooker(self.configuration, self.featureset)
  File &quot;/opt/pkg/petalinux/2018.3/components/yocto/source/aarch64/layers/core/bitbake/lib/bb/cooker.py&quot;, line 178, in __init__
    self.configwatcher = pyinotify.WatchManager()
  File &quot;/opt/pkg/petalinux/2018.3/components/yocto/source/aarch64/layers/core/bitbake/lib/pyinotify.py&quot;, line 1764, in __init__
    raise OSError(err % self._inotify_wrapper.str_errno())
OSError: Cannot initialize new instance of inotify, Errno=Too many open files (EMFILE)

ERROR: Unable to start bitbake server
ERROR: Last 10 lines of server log for this session (/opt/pkg/petalinux/2018.3/components/yocto/source/aarch64/bitbake-cookerdaemon.log):
Traceback (most recent call last):
  File &quot;/opt/pkg/petalinux/2018.3/components/yocto/source/aarch64/layers/core/bitbake/lib/bb/daemonize.py&quot;, line 77, in createDaemon
    function()
  File &quot;/opt/pkg/petalinux/2018.3/components/yocto/source/aarch64/layers/core/bitbake/lib/bb/server/process.py&quot;, line 433, in _startServer
    self.cooker = bb.cooker.BBCooker(self.configuration, self.featureset)
  File &quot;/opt/pkg/petalinux/2018.3/components/yocto/source/aarch64/layers/core/bitbake/lib/bb/cooker.py&quot;, line 178, in __init__
    self.configwatcher = pyinotify.WatchManager()
  File &quot;/opt/pkg/petalinux/2018.3/components/yocto/source/aarch64/layers/core/bitbake/lib/pyinotify.py&quot;, line 1764, in __init__
    raise OSError(err % self._inotify_wrapper.str_errno())
OSError: Cannot initialize new instance of inotify, **Errno=Too many open files (EMFILE)**

This is pointing to the /proc/sys/fs/inotify/max_user_instances that need to be increased. In my case I went from 128 to 256 by doing this:
sudo su 
echo 256 &gt; /proc/sys/fs/inotify/max_user_instances

You need to become root with &quot;su&quot; and change the mac_user_instances.",,,,,
Passing objects into SystemVerilog tasks/functions - Vivado Zynq Verification IP / API,"I have a testbench in Vivado which has a hierarchy of IP--some custom IP and some Xilinx IP, like the Zynq Processing System. The Zynq Processing System also has an associated Verification IP library that has useful API for doing things like loading DDR.
I would like to write a task which leverages the Zynq Verification IP (and associated API) inside it. I can't figure out how I would implement this in my testbench? I am new to SV, and am guessing that I need to pass the zynq processing system object as an argument so I can access it's API inside my super-task.
Updated example of what I'm trying to do in my testbench. I realize this isn't proper SystemVerilog, it's just to demonstrate the functionality I'm trying to obtain. TOP is a module defined in some other .sv file that contains the definition of a task called T:
module tb();

  TOP TIPTOP(), TIPITTYTOP();

  task myTask(input TOP T);
    begin
        T.T;
    end
  endtask
  
initial begin
  
  myTask(TIPTOP);
  myTask(TIPITTYTOP);
  
end
  
endmodule
","Another answer to the updated question
This can only be done if the module TOP is not a module but a different flavour of module, called an interface. There is a special kind of SystemVerilog variable called a virtual interface which is a variable that can store a reference to the instance of an interface. This is what you need here. So,

you need to make TOP an interface and
you need to add the keyword virtual to your task: task myTask(input virtual TOP T);

There are restrictions on an interface, however. (We are not quite using it for its normal purpose here.) The main one which might affect you is that you cannot instantiate a module inside an interface.

https://www.edaplayground.com/x/SM33
interface TOP;
  task T;
    $display(&quot;TOP.T&quot;);
  endtask
endinterface

module tb();

  TOP TIPTOP(), TIPITTYTOP();

  task myTask(input virtual TOP T);
    begin
        T.T;
    end
  endtask
  
initial begin
  
  myTask(TIPTOP);
  myTask(TIPITTYTOP);
  
end
  
endmodule
  
",,,,,
Using a specify block to code a clock to output hold time?,"You can set a module path delay in a specify block as follows (in this case, the clock to q delay in a DFF):
specify
  specparam tPLHc = 4:6:9, tPHLc = 5:8:11;
  (clock *&gt; q) = (tPLHc, tPHLc);
endspecify

In other words, the minimum delay for a 0-&gt;1 transition on q is 4 time units, and so on. However, this only gives the delays for a new valid output on q, and doesn't specify how long the previous q output holds after a clock edge (or the stability window over which the new q is valid). Assume, for example, that q remains valid for 2 time units after a clock rising edge, and takes on the new value after 4 time units.
Is there some way to specify the output hold time, or does this have to be manually coded?","That information is built into the setup/hold requirements of the next stage. Realize that the min/max delays are statistical thresholds on a slope, and the true output slope depends in the input slopes. And those slopes depend on resistance/capacitance networks that you cannot normally get without analog analysis. So the hold times have to be pessimistic enough to give you practical worse case senarios.",,,,,
How does adding 1'b1 to 8 bit reg work in Verilog?,"I am absolute beginner in Verilog and I am wondering how does the addition statement work in this piece of program.
reg [7:0] hcount;
...
always @(posedge clk) begin
      if(!n_rst) begin
         hcount &lt;= 'd0;
      end else if(hcount== (WIDTH-1)) begin
         hcount &lt;= 'd0;
      end else begin
         hcount &lt;= hcount + 1'b1;
      end
   end

I understand that 1'b1 expands to 8'b1 because hcount has 8 bit width and now the calculation will work with 8 bit now. But how exactly does that addition work? Your help is much appreciated.","Verilog is a hardware description langue in a sense that it tries to describe behavior of real hardware. One of attributes of modern hardware is clock. Clock drives flops which synchronize data across different hardware devices.
Clock behavior in verilog is simulated by posedge clk (or negede), meaning that the corresponding always block will be executed if and only if clk switches to 1 from any other value (x, z, 0);.
So, in your case, there is supposed to be  a clock (clk) which gets generated somewhere in test bench. It periodically switches between 0 and 1.
As soon as it switches 0 -&gt; 1 it gets executed. If condition is right, the hcount &lt;= hcount + 1'b1 will be executed. As you mentioned the compiler will zero-extend 1'b1 to the 8-bit value 00000001. The rest is the same as in any programming language, hcount will be incremented.
There is certain semantic associated with the non-blocking assignment, &lt;=, but this would be a different question. For the purpose of your question it does not matter.
So, a result will be that a single increment will be done every clock cycle unless n_rst is '0'. Also, as soon as the counter reaches WIDH - 1 it will be set to '0'. Only one operation is allowed at a single clock edge.",,,,,
Verilog parameters with parametric width,"It isn't hard to agree that parametrized module design is a good practice and data width is a good starting point.
I have been defining constants 0 and 1 of required bus or operand widths for years. That to avoid compiler warnings and to explicitly communicate the intention. Typically using something like:
parameter   WIDTH = 16;
//  ...
parameter   ZERO  = {WIDTH{1'b0}};            // all zeroes
parameter   UNO   = {{WIDTH-1{1'b0}}, 1'b1};  // all zeroes except LSB

This is all fine until I want to define an arbitrary constant with given parametrized WIDTH.
I certainly can write a constant with fixed width - but that's not what I want:
parameter   FULL   = 16'd57;

However, analogous construct using the parametric WIDTH fails with syntax error:
parameter   LEVEL   = WIDTH'd57;   // &lt;== *ERROR*

What is the proper syntax - if there is one?","This was a problem in Verilog because the RHS of a parameter assignment was used as the self-determined width of the parameter. SystemVerilog addressed this by allowing you to specify a datatype as part of a parameter declaration
parameter   WIDTH = 16;
//  ...
parameter bit [WIDTH-1:0] ZERO  = '0;           // all zeroes
parameter bit [WIDTH-1:0] UNO   = 1;  // all zeroes except LSB
parameter bit [WIDTH-1:0] LEVEL = 57;

The datatype does not change when overriding.
Another way is using a sizing cast
parameter LEVEL = WIDTH'(56);
But if you do it this way and override the parameter, the datatype becomes the width of the overriding value's type.",,,,,
How can I automatically scale a $display column width?,"I want to $display strings in a column like in a fixed-width table.
However, I don't know what the maximum column width of my strings is
ahead of time.
Let's say I have an array of SystemVerilog strings (names).
When I $display them, I guess at a width for the column (10),
but my guess is too small:
module tb;

string names [5];

initial begin
    names = '{
        &quot;ALU&quot;           ,
        &quot;COMPARATOR_3&quot;  ,
        &quot;MEMORY&quot;        ,
        &quot;FLOP&quot;          ,
        &quot;ram_macro_with_a_long_name&quot;
    };

    // Display all elements of the array
    foreach (names[i]) begin
        $display(&quot;| %10s |&quot;, names[i]);
    end
end

endmodule

This is the output:
|        ALU |
| COMPARATOR_3 |
|     MEMORY |
|       FLOP |
| ram_macro_with_a_long_name |

This is the output I want:
|                        ALU |
|                 COMPARATOR |
|                     MEMORY |
|                       FLOP |
| ram_macro_with_a_long_name |

I could guess a really big number (like 100), but it might be a lot bigger
than I need.
How can I automatically scale the width of the $display?","Loop through the array to calculate the maximum string length
using the len array method.  Refer to IEEE Std 1800-2017,
section 6.16 String data type.
Then create the format string using $sformatf.
module tb;

string names [5];
int maxlen = 0;
string fmt;

initial begin
    names = '{
        &quot;ALU&quot;           ,
        &quot;COMPARATOR&quot;    ,
        &quot;MEMORY&quot;        ,
        &quot;FLOP&quot;          ,
        &quot;ram_macro_with_a_long_name&quot;
    };

    // First, lets calculate the maximum string length
    foreach (names[i]) begin
        if (names[i].len() &gt; maxlen) maxlen = names[i].len();
    end

    // Create the format which will be used by $display
    //      %%  ... double &quot;%&quot; is needed to create a literal &quot;%&quot;
    //      %0d ... this formats the maxlen number
    //      s   ... string format
    //      |   ... this is just the character I chose for the start/end of the field
    fmt = $sformatf(&quot;| %%%0ds |&quot;, maxlen);

    // Display all elements of the array
    foreach (names[i]) begin
        $display($sformatf(fmt, names[i]));
    end
end

endmodule

This is the output:
|                        ALU |
|                 COMPARATOR |
|                     MEMORY |
|                       FLOP |
| ram_macro_with_a_long_name |

Here is a runnable example on edaplayground.

The output above is right-justified.  To get left-justified output, use:
fmt = $sformatf(&quot;| %%-%0ds |&quot;, maxlen);

Output:
| ALU                        |
| COMPARATOR                 |
| MEMORY                     |
| FLOP                       |
| ram_macro_with_a_long_name |
",,,,,
Value of a vector won't update,"I have a 32x32 multiplier in system-verilog with an fsm style machine that basically does long multiplication like in school.
I tested it 2 days ago, and it worked out fine. But, suddenly without even changing the code, one of the outputs just stays put at 0 for no reason.
Here is the code:
// 32X32 Multiplier arithmetic unit template
module mult32x32_arith (
    input logic clk,             // Clock
    input logic reset,           // Reset
    input logic [31:0] a,        // Input a
    input logic [31:0] b,        // Input b
    input logic a_sel,           // Select one byte from A
    input logic b_sel,           // Select one 2-byte word from B
    input logic [1:0] shift_sel, // Select output from shifter
    input logic upd_prod,        // Update the product register
    input logic clr_prod,        // Clear the product register
    output logic [63:0] product  // Miltiplication product
);

// Put your code here
// ------------------
logic [15:0] mux2to1a;
logic [15:0] mux2to1b;
logic [31:0] mul;
logic [63:0] shift0;
logic [63:0] shift16;
logic [63:0] shift32;
logic [63:0] mux4to1;
logic [63:0] adder;
always_comb begin
    if(a_sel==1'b1)begin
         mux2to1a=a[31:16];
    end
    else begin
         mux2to1a=a[15:0];
    end
    
    if(b_sel==1'b1)begin
         mux2to1b=b[31:16];
    end
    else begin
         mux2to1b=b[15:0];
    end
    
    mul=mux2to1a*mux2to1b;
    
    shift0=mul;
    
    shift16= mul &lt;&lt; 16;
    shift32= mul &lt;&lt; 32;
    
    if(shift_sel[0]==1'b0&amp;&amp;shift_sel[1]==1'b0)begin
        mux4to1=shift0;
    end
    else if(shift_sel[0]==1'b1&amp;&amp;shift_sel[1]==1'b0)begin
        mux4to1=shift16;
    end
    else if(shift_sel[0]==1'b0&amp;&amp;shift_sel[1]==1'b1)begin
        mux4to1=shift32;
    end
    else begin
        mux4to1=0;
    end
    
    adder=mux4to1+product;
    
end

always_ff @(posedge clk, posedge reset)begin
                if(reset)begin
                    product&lt;=0;
                end
                
                else begin
                    if(upd_prod==1'b1)begin
                        product&lt;=adder;
                    end
                    else begin
                        product&lt;=product;
                    end     
                    
                    if(clr_prod==1'b1)begin
                        product&lt;=0;
                    end
                    else begin
                        product&lt;=product;
                    end
                end
    end
// End of your code

endmodule

For some reason the product output stays at 0 although you can see that the adder value changes.

EDIT:
the rest of the code (fsm and tb)
FSM part:
// 32X32 Multiplier FSM
module mult32x32_fsm (
    input logic clk,              // Clock
    input logic reset,            // Reset
    input logic start,            // Start signal
    output logic busy,            // Multiplier busy indication
    output logic a_sel,           // Select one byte from A
    output logic b_sel,           // Select one 2-byte word from B
    output logic [1:0] shift_sel, // Select output from shifter
    output logic upd_prod,        // Update the product register
    output logic clr_prod         // Clear the product register
);

// Put your code here
// ------------------
typedef enum {idle, a0b0,a0b1,a1b0,a1b1} sm_type;

sm_type current, next;

always_ff @(posedge clk, posedge reset) begin
    if(reset) begin
        current&lt;=idle;
    end
    else begin
        current&lt;=next;
    end
end

always_comb begin
    next=idle;
    busy=1'b1;
    a_sel=1'b0;
    b_sel=1'b0;
    shift_sel={1'b0,1'b1};
    upd_prod=1'b1;
    clr_prod=1'b0;
    case(current)
        idle: if(start==1'b1) begin
                next=a0b0;
                busy=1'b0;
                upd_prod=1'b0;
                clr_prod=1'b1;
            end 
            else begin
                next=idle;
                busy=1'b0;
                upd_prod=1'b0;
            end
        a0b0: begin 
            next=a0b1;
            shift_sel={1'b0,1'b0};
            end
        
        a0b1: begin
            next=a1b0;
            b_sel=1'b1;
            end
        a1b0: begin
            next=a1b1;
            a_sel=1'b1;
            end
        a1b1: begin
            a_sel=1'b1;
            b_sel=1'b1;
            shift_sel={1'b1,1'b0};
            end
    endcase
end
// End of your code

endmodule

Combined Machine:
// 32X32 Iterative Multiplier template
module mult32x32 (
    input logic clk,            // Clock
    input logic reset,          // Reset
    input logic start,          // Start signal
    input logic [31:0] a,       // Input a
    input logic [31:0] b,       // Input b
    output logic busy,          // Multiplier busy indication
    output logic [63:0] product // Miltiplication product
);
// Put your code here
// ------------------
        
 logic a_sel;       
 logic b_sel;         
 logic [1:0] shift_sel; 
 logic upd_prod;      
 logic clr_prod; 
 
mult32x32_fsm fsm(
    .busy(busy),
    .a_sel(a_sel),
    .b_sel(b_sel),
    .shift_sel(shift_sel),
    .upd_prod(upd_prod),
    .clr_prod(clr_prod),
    .clk(clk),
    .reset(reset),
    .start(start)
    );
mult32x32_arith arith(
    .product(product),
    .clk(clk),
    .reset(reset),
    .a(a),
    .b(b),
    .a_sel(a_sel),
    .b_sel(b_sel),
    .shift_sel(shift_sel),
    .upd_prod(upd_prod),
    .clr_prod(clr_prod)
);

// End of your code
endmodule

Test Bench:
// 32X32 Multiplier test template
module mult32x32_tb;

logic clk;            // Clock
logic reset;          // Reset
logic start;          // Start signal
logic [31:0] a;       // Input a
logic [31:0] b;       // Input b
logic busy;           // Multiplier busy indication
logic [63:0] product; // Miltiplication product

// Put your code here
// ------------------

mult32x32 uut(
    .busy(busy),
    .product(product),
    .clk(clk),
    .reset(reset),
    .start(start),
    .a(a),
    .b(b)
);

initial begin
    clk=1'b1;
end
always begin
    #1 clk=~clk;
end

initial begin
    reset=1'b1;
    a=0;
    b=0;
    start=1'b0;
    repeat (4) begin
        @(posedge clk);
    end
    reset=1'b0;
    @(posedge clk);
    a=32'd211578794;
    b=32'd212209639;
    start=1'b1;
    #2;
    start=1'b0;
    @(negedge busy);
end
// End of your code

endmodule
","You have a bug in your logic.  Your code always executes at least one of your 2 product&lt;=product; lines because they are in separate if/else statements.
This works:
always_ff @(posedge clk, posedge reset) begin
    if (reset) begin
        product&lt;=0;
    end else if (upd_prod) begin
        product&lt;=adder;
    end else if (clr_prod) begin
        product&lt;=0;
    end
end

This prioritizes upd over clr (if that is your intent).",,,,,
chip Mux4way16 not run ontil the end on â€HardwareSimulator (VHDL),"I'm tryng to build this chip:


// This file is part of www.nand2tetris.org
// and the book ""The Elements of Computing Systems""
// by Nisan and Schocken, MIT Press.
// File name: projects/01/Mux4Way16.hdl

/**
 * 4-way 16-bit multiplexor:
 * out = a if sel == 00
 *       b if sel == 01
 *       c if sel == 10
 *       d if sel == 11
 */

CHIP Mux4Way16 {
    IN a[16], b[16], c[16], d[16], sel[2];
    OUT out[16];

    PARTS:
    // Put your code here:



And that what i wrote ontil now -


    PARTS:
    // Put your code here:
    Xor(a=sel[0], b=sel[1], out=finalSel);
    Not(in=finalSel, out=notFinalSel);
    Mux16(a=a, b=b, sel=finalSel, out=aAndB);
    Mux16(a=c, b=d, sel=notFinalSel, out=cAndd);
    Mux16(a=aAndB, b=cAndd, sel=sel[0], out=out);

}



And for some reason it's not working..
Screenshot from the â€â€HardwareSimulator
someone know why?","Your logic for selecting what input to pass through appears to be incorrect. You should test it by creating a truth table for finalSel, notFinalSel, aAndB, cAndd and out for each of the 4 control conditions.
In general, when doing these kinds of problems, the KISS principle holds; Keep It Simple and Stupid. You don't need any fancy logical manipulation of your sel[] bits, you can just use them directly. So once you get your version fixed (and understand where you went wrong), try doing a version that just consists of 3 Mux16's and nothing else. Once you have both versions working, you'll then understand the error that caused you to go down the wrong path in your first attempt, and that will be a valuable lesson going forward.
Have fun!",,,,,
How to test if a 3-bit bus has the first bit set on 1 - verilog,"I'm trying to find out how could I check if a 3-bit bus has the msb set on 1, i.e. 1xx.
When I check bus==3'b1xx nothing seems to happen.","The result of the expression you wrote can only be (1'b0) or (1'bx), which are both considered false for an if statement branch.
Assuming you declared the bus as wire [2:0] bus; you can check it using bus[2] == 1'b1
Now in SystemVerilog, you can do a wildcard match using bus ==? 3'b1xx which treats the RHS X's as don't cares. X's on the LHS are treated the same as ==.",,,,,
Parameterizing the Bit Widths of fields in a packed struct so that modules can infer bit width if used in port map,"Also discussed at:
https://verificationacademy.com/forums/systemverilog/parameterizing-bit-widths-fields-packed-struct-so-modules-can-infer-bit-width-if-used-port-map-virtual-interface-interface-compile-time-configured-struct-bit-width
https://forums.xilinx.com/t5/Synthesis/Parameterizing-the-Bit-Widths-of-fields-in-a-packed-struct-so/td-p/1191678
I am having trouble accomplishing my intent in SystemVerilog trying to use the latest language features to make my code more elegant and less verbose. For synthesis**
I would like to accomplish the following:

be able to parameterize the bit widths of fields in a packed struct that I want to define ... I have attempted to accomplish this using a parameterized interface construct
I would like for modules with that parameterized interface as an INPUT to the module to be able to infer the bit width of a field inside that packed struct defined inside the interface

I have been mostly successful in past experiments but I have run into an issue.
Please see the following simple interface definition:
interface MyInterface #(int DATA_W, ADDR_W) () ;

  typedef struct packed
    { logic valid
    ; logic [ADDR_W-1:0] addr
    ; logic [DATA_W-1:0] data
    ; } SimpleStruct;

  SimpleStruct bus;
  logic ready;

  modport SNK (input bus, output ready);
  modport SRC (output bus, input ready);

endinterface

It is easy enough to instantiate an interface and use it at the input of a simple module in my Top module for this example:
module TopTest 
  ( input wire Clock
  , input wire Reset
  , input wire [31:0] In
  , output wire dummyOut
  ) ;

  MyInterface # ( 32, 3 ) my_interface ();

  assign my_interface.bus.data = In ;
  assign my_interface.bus.addr = 3'h3 ;

  InnerTest inst_mod_inner_test
    ( .Clock( Clock )
    , .Reset( Reset )
    , .Sink( my_interface )
    ) ;

  assign dummyOut = my_interface.ready ;

endmodule

The problem that I am running into is that I do not want to parameterize the actual module with field bit widths, because I believe that at compile time the bit widths of the fields should be already established and accessible. This seems to not be the case, and I am wondering if there is anything I can do to accomplish inferring the bit width of the packed struct in the interface (remember that is the case because I want it parameterized, I know it is easy to get $bits of a field of a struct that is not defined in an interface but instead defined in a package or module)
module InnerTest 
  ( input wire Clock
  , input wire Reset
  , MyInterface.SNK Sink
  ) ;

  localparam BIT_WIDTH_SINK_DATA = $bits( Sink.bus.data ) // this line errors out b/c sink is 'virtual'

  RAM # ( .DATA_WIDTH( BIT_WIDTH_SINK_DATA ) ) ram ( ... // etc

  ... other code to drive output ready of interface ...

endmodule

There are many reasons why a designer would want to make a module &quot;parameterizable&quot; and I have taken that approach in the past, but I am very interested in not duplicating information. If I were to take the easy approach, I would simply parameterize my inner test module so that I provided it DATA_WIDTH, but I would then have two numbers to update and a lot of parameters that I feel I do not need. I think it would be most elegant if I could simply infer characteristics of the parameterized struct somehow. The information I am looking for is truly known at compile time in my opinion. I just can't seem to access it, or this is another shortfall of SystemVerilog.
Follow up Q, in Simulation
The workaround mentioned by Dave was very useful when using QuestaSim, but now running into different issue in QuestaSim:
parameter reference &quot;sink.bus.data&quot; through interface port &quot;sink&quot; is not valid when the actual interface in the instance is an arrayed instance element or below a generate construct
What is the workaround for this, I don't understand why simply being in a generate statement would impact things way downstream. In this case i use a generate statement to choose between different FIFO implementations, a few layers above the line of code where the error happens.
typedef sink.bus.data questasim_workaround;
localparam width = $bits(questasim_workaround);

Follow Up Experiment
I have experimented with passing in type instead of restricting myself to passing in DATA_W.
interface MyInterface #(int ADDR_W, type DATA_TYPE) () ;

  typedef struct packed
    { logic valid
    ; logic [ADDR_W-1:0] addr
    ; DATA_TYPE data
    ; } SimpleStruct;

  SimpleStruct bus;
  logic ready;

  modport SNK (input bus, output ready);
  modport SRC (output bus, input ready);

endinterface

This allows for more flexibility. I have observed that Vivado Simulator and Synthesis tools can handle an example like this without issue.
module SomeModule
  ( MyInterface myInt
  blah...
  );

  localparam SOMETHING = $bits(myInt.DATA_TYPE);
  // or equivalently
  localparam SOMETHING_ELSE = $bits(myInt.data);
  // or even this, for needs of a internal signal for pipelined processing steps
  MyInterface # ($bits(myInt.addr), myInt.DATA_TYPE) internal_0 () ;

In place of this in QUestaSim we have had to implement Dave's work around:
module SomeModule
  ( MyInterface myInt
  blah...
  );

  // this gets less elegant :/
  typedef myInt.data questasim_workaround_data;
  typedef myInt.addr questasim_workaround_addr;

  localparam SOMETHING = $bits(questasim_workaround_data);
  // or equivalently
  localparam SOMETHING_ELSE = $bits(questasim_workaround_data);
  // or even this, for needs of a internal signal for pipelined processing steps

  MyInterface # ($bits(questasim_workaround_addr), questasim_workaround_data) internal_0 () ;
","Whenever you see an error that is unexpected in Vivado around &quot;[Synth 8-27] scoped/hierarchical type name not supported&quot; ... check to see if the instantiation port map matches all the names of the actual module definitions portmap. That was the issue in Vivado only with this code. The spelling didn't match and instead of a &quot;[Synth 8-448] named port connection 'clkkkk' does not exist&quot; I got a &quot;[Synth 8-27] scoped/hierarchical type name not supported&quot; error
As explained in: https://forums.xilinx.com/t5/Synthesis/Parameterizing-the-Bit-Widths-of-fields-in-a-packed-struct-so/td-p/1191678",,,,,
How combine multiple VHDL codes to make one system,"I have multiple VHDL code coming from separate sources, and I want to combine them to make a single system.
My understanding is that I have to extract entities and architectures that I'm interested in from each code then I make a new entity that combines them and same for architecture.
I'm missing the next steps in how to use these in the process.
It would be nice to get some tips and tricks from you guys on how to do it correctly and avoid the mistakes that a newbie in VHDL like me will probably do.
The figure summarizes what I have and what I need.
Multiple VHDL to one
Regards","The example can be if you have two modules, the mdl_sub sub-module:
library ieee;
use ieee.std_logic_1164.all;

entity mdl_sub is
  generic(
    A_L : natural;
    Z_L : natural);
  port(
    clk_i : in  std_logic;
    rst_i : in  std_logic;
    a_i   : in  std_logic_vector(A_L - 1 downto 0);
    z_o   : out std_logic_vector(Z_L - 1 downto 0));
end entity;


library ieee;
use ieee.numeric_std.all;

architecture syn of mdl_sub is
  signal z : std_logic_vector(z_o'range);
begin

  process (clk_i, rst_i) is
  begin
    -- Clock
    if rising_edge(clk_i) then
      z &lt;= std_logic_vector(unsigned(z) + unsigned(a_i));
    end if;
    -- Reset
    if rst_i = '1' then
      z &lt;= (others =&gt; '0');
    end if;
  end process;

  -- Drive output
  z_o &lt;= z;

end architecture;

and the mdl_top top-module:
library ieee;
use ieee.std_logic_1164.all;

entity mdl_top is
  generic(
    M0_A_L : natural := 8;
    M0_Z_L : natural := 8;
    M1_A_L : natural := 4;
    M1_Z_L : natural := 4);
  port(
    clk_i  : in  std_logic;
    rst_i  : in  std_logic;
    m0_a_i : in  std_logic_vector(M0_A_L - 1 downto 0);
    m0_z_o : out std_logic_vector(M0_Z_L - 1 downto 0);
    m1_a_i : in  std_logic_vector(M1_A_L - 1 downto 0);
    m1_z_o : out std_logic_vector(M1_Z_L - 1 downto 0));
end entity;


library ieee;
use ieee.numeric_std.all;

architecture syn of mdl_top is
begin

  -- Sub-module 0
  mdl_sub_0 : entity work.mdl_sub
    generic map(
      A_L =&gt; M0_A_L,
      Z_L =&gt; M0_Z_L)
    port map(
      clk_i =&gt; clk_i,
      rst_i =&gt; rst_i,
      a_i   =&gt; m0_a_i,
      z_o   =&gt; m0_z_o);

  -- Sub-module 1
  mdl_sub_1 : entity work.mdl_sub
    generic map(
      A_L =&gt; M1_A_L,
      Z_L =&gt; M1_Z_L)
    port map(
      clk_i =&gt; clk_i,
      rst_i =&gt; rst_i,
      a_i   =&gt; m1_a_i,
      z_o   =&gt; m1_z_o);

end architecture;

then the two files with the modules can be compiled separately, and the mdl_sub is then integrated into mdl_top, as Brian Drummond describes.
Sorry for the longer modules, but I had those readily available as examples ;-)",,,,,
When are newline characters significant in Verilog compiler directives?,"I'm trying to parse Verilog code including Verilog compiler directives.
My parser presently insists that such directives generally end with a newline, e.g.
`ifdef foo &lt;newline&gt;

This was inspired by an absence of any discussion of compiler directives in early Verilog standards other than roughly &quot;directives may occur anywhere in the source&quot;, and all examples that I had found did not violate this rule.  Given that compiler directives are arguably inspired by &quot;C&quot;, and C's directives must end on a newline, this seemed reasonable.
I've run into the following line in an open source specification a CPU, which I believe to be thoroughly tested (i.e. valid) code:
`ifdef PR_ERROR if ($time &gt; 1 &amp;&amp; rst_l) `PR_ERROR(&quot;dmu_ilu_cib_addr_decode&quot;,`MON_ERROR,&quot;ERROR: Instance ID for module dmu_ilu_cib_csr is bad&quot;); `endif

Note the absence of a newline after PR_ERROR.   Is this legal?
The IEEE1800-2012 Verilog standards document is a little hard to interpret.
Page 639 says

Only white space or a comment may appear on the same line as the
`include compiler directive.

So the standard clearly insists on a newline for `include.
There is no such similar statement made for other compiler directives.
In particular, page 685 discusses `ifdef, `else, `elsif, `endif, and only says:

These directives may appear anywhere in the source description.

If one believes that standard is well-defined, and what is not forbidden is allowed,
one might believe that newlines are not needed for such directives.  I'd be happy to see a chapter-and-verse quote that is explicit.
Regardless, what do the compilers actually accept?","Although Section 22.6 `ifdef, `else, `elsif, `endif, `ifndef of the 1800-2017 LRM says &quot;These directives may appear anywhere in the source description.&quot;, the rest of that section defines the behavior in terms of &quot;groups of lines&quot;. A strict interpretation of that section would mean that the following would not be allowed on one line:
`ifdef A initial $display(&quot;A&quot;); `else initial $display(&quot;not A&quot;); `endif

However all tools seem to support this.
But interaction with other compiler directive can leave room for ambiguity
`ifdef A `define X 2 `endif

If A is not defined, is the  `endif part of the macro not compliled or the end of the  `ifdef?
So my recommendation would be to keep the conditional compilation directives on separate lines.",,,,,
16bit multiplier vhdl code synthesize error,"I want to write a 16bit * 16bit multiplication code. Here is my code:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity mul is
   port
   (
      A, B: IN INTEGER RANGE -32768 TO 32767;

      C: OUT INTEGER RANGE -2147483648 TO +2147483647
   );
end mul;

architecture Behavioral of mul is
begin

   C &lt;= A * B;

end behavioral;

But when I'm trying to sythesize the code on xilinx isim I get this error:
ERROR:Bitgen:342 - This design contains pins which have locations (LOC) that are
not user-assigned or I/O Standards (IOSTANDARD) that are not user-assigned.
This may cause I/O contention or incompatibility with the board power or
connectivity affecting performance, signal integrity or in extreme cases
cause damage to the device or the components to which it is connected.  To
prevent this error, it is highly suggested to specify all pin locations and
I/O standards to avoid potential contention or conflicts and allow proper
bitstream creation.  To demote this error to a warning and allow bitstream
creation with unspecified I/O location or standards, you may apply the
following bitgen switch: -g UnconstrainedPins:Allow
ERROR:Bitgen:157 - Bitgen will terminate because of the above errors.","All the ports defined in the entity should have a pin assignment defined using ucf file. If you are missing an ucf file, the tool will go ahead and place the pins by itself. This is clearly stated in the error message.
NET&quot;A(0)&quot;                LOC =&quot;AB16&quot;       | IOSTANDARD =&quot;LVTTL&quot;;
NET&quot;A(1)&quot;                LOC =&quot;AB16&quot;       | IOSTANDARD =&quot;LVTTL&quot;;
...

In your example, the width of A &amp; B is 16 bits and C is 32 bits. So you need to assign correct pin location and IO standard for all of them.",,,,,
Warning: Inferring latch for variable 'w_addra_t' (in Verilog/SystemVerilog with FOR loop),"I have an inferred latch problem after synthesis when I designed a simple dual port RAM block. Due to large code size, I have just embedded this always block code as follows:
integer i;
always_latch
begin
    for (i=0;i&lt;NUM_RAMS;i=i+1) begin
        if (ena_t == 1) begin   
            w_addra_t[i] = w_addra[i];
        end
        else begin
            w_addra_t[bank_addra[i]] = w_addra[i];
        end
    end
end

My RAM block includes NUM_RAMS numbers of banks. The addresses of respective input data are stored in w_addra.
Data with given w_addra addresses are scrambled into w_addra_t depend on the values of respective bank_addra (depend on access pattern) when ena_t = 0.
I tried to replace for loop with if...else, switch...case, generate but the problem is same. With different always block in my code that the left-side is with only w_addra_t[i] in both if.else of ena_t, there is no error.
I would like to get your suggestion if you have any idea. I did look for similar issue but getting no results.
Thanks very much :)","My guess is the entries for bank_addra are not guaranteed to be unique. If two or more entries hold the same values then an index hole is created for w_addra_t; which will infer a latch.
Here are three possible solution:

Functionally guaranteed that bank_addra entries will have unique values, then the synthesizer should not infer a latch. This can be challenging.

Move the address variation from the LHS to the RHS so that each index of w_addra_t is guaranteed to be assigned a value. Ex change w_addra_t[bank_addra[i]] = w_addra[i]; to w_addra_t[i] = w_addra[bank_addra_lookup[i]];.

Assign all entries of w_addra_t to a known value (constant, flip-flop, or deterministic value) before other logic. You can put this default assignment at the top of your always block (option 1 example) or above the logic where the latches were about to be inferred (option 2 example). This is the simplest solution to implement assuming it still satisfies relational requirements with your other code.
// NOTE: SystemVerilog supports full array assignments (Verilog requires a for-loop)
always_comb
begin
  w_addra_t = '{default:'0}; // &lt;-- default assignment : option 1
  if (ena_t == 1) begin
    w_addra_t = w_addra; 
  end
  else begin
    w_addra_t = w_addra_t_ff; // &lt;-- default assignment : option 2
    for (i=0;i&lt;NUM_RAMS;i=i+1) begin
      w_addra_t[bank_addra[i]] = w_addra[i];
    end
  end
end
always_ff @(posedge clk) begin
  w_addra_t_ff &lt;= w_addra_t; // assuming w_addra_t should hold it current values
end




TL;DR
always_latch is a SystemVerilog keyword to identify explicit latches. Some tools will auto-waive the warning when the keyword is used, but will throw an error/warning if the keyword is used and a latch is not detected.
If you know it should be combinational logic, then use the always_comb SystemVerilog keyword. With always_comb, if the synthesis detects a latch then it should report an error.
Read related question:
What is inferred latch and how it is created when it is missing else statement in if condition. Can anybody explain briefly?",,,,,
4-bit register using D flip-flop with enable and asynchronous reset,"I am modelling a 4-bit register using D flip-flops with enable and asynchronous reset. It contains 4 D FF and 4 2:1 Mux. I used structural Verilog to model the circuit.
My design is shown below.
module DFlipFlop(D,clk,reset,Q);
input D; 
input clk,reset; 
output Q;
reg Q;
always @(posedge clk or posedge reset) 
begin
 if(reset==1'b1)
  Q &lt;= 1'b0; 
 else 
  Q &lt;= D; 
end 
endmodule

module m21(D0, D1, S, Y);
output Y;
input D0, D1, S;
assign Y=(S)?D1:D0;
endmodule

module DFF_with_Enable(D,clk,enable,reset,Q);
  input D,clk,reset,enable;
  output Q;
  reg Q;
  wire in;
      m21 mux(D,in,enable,in);
      DFlipFlop DFF(in,clk,reset,Q); 
endmodule

module fourbitreg(D,clk,reset,enable, Q);
  input[0:3] D; // Data input
input clk,reset,enable;
  output [3:0]Q;
  reg [3:0]Q;
  wire d0,d1,d2,d3;
  wire q0,q1,q2,q3;
  d0 = D[0];
  d1 = D[1];
  d2 = D[2];
  d3 = D[3];
  DFF_with_Enable df0(d0,clk,reset,enable,q0);
  DFF_with_Enable df1(d1,clk,reset,enable,q1);
  DFF_with_Enable df2(d2,clk,reset,enable,q2);
  DFF_with_Enable df3(d3,clk,reset,enable,q3);
        
       assign Q = {q0,q1,q2,q3};
endmodule

I used iverilog for simulation. How do I fix the following errors during compilation?
design.sv:37: syntax error
design.sv:37: error: Invalid module instantiation
design.sv:38: error: Invalid module instantiation
design.sv:39: error: Invalid module instantiation
design.sv:40: error: Invalid module instantiation

The circuit of 1 DFF MUX pair is shown below.
","There are multiple compile errors.
Inside DFF_with_Enable and fourbitreg, do not declare Q as a reg because you make continuous assignments to Q.
You need to use the assign keyword to make continuous assignments to d0, etc.:
  assign d0 = D[0];
  assign d1 = D[1];
  assign d2 = D[2];
  assign d3 = D[3];

You should also try different simulators on edaplayground to get more meaningful error messages.",,,,,
"An issue regarding multiple drivers on a wire, error: [DRC MDRV-1] Multiple Driver Nets: Net led_OBUF[0] has multiple drivers: led_OBUF[0]_inst_i_1/O","I am creating a simple VHDL code which should create two 4 bit binary numbers (A and B) using 8 inputs (4 for each), then based on one of three buttons being pressed, a logic function is performed on A and B, either AND, OR, or XOR.
My concern is that I am trying to map multiple input signals to a single port, and multiple output signals to a single port, however my confusion lies in the fact that I have successfully implemented a very similar description without any errors, I will show the non error description at the end. If my suspicions are correct, please could someone explain to me why the error does not occur on the bottom code?
Code with errors:
use IEEE.STD_LOGIC_1164.ALL;

entity Lab_2_Source_File is
port(A : in STD_LOGIC_VECTOR(3 downto 0);
     B : in STD_LOGIC_VECTOR(3 downto 0);
     btnd : in STD_LOGIC;
     btnl : in STD_LOGIC;
     btnr : in STD_LOGIC;
     led : out STD_LOGIC_VECTOR(3 downto 0)
     );
end Lab_2_Source_File;


architecture Behavioral of Lab_2_Source_File is
begin 

process(btnd)
begin
led(0) &lt;=A(0) and B(0);
led(1) &lt;=A(1) and B(1);
led(2) &lt;=A(2) and B(2);
led(3) &lt;=A(3) and B(3);
end process;

process(btnl)
begin
led(0) &lt;=A(0) or B(0);
led(1) &lt;=A(1) or B(1);
led(2) &lt;=A(2) or B(2);
led(3) &lt;=A(3) or B(3);
end process;

process(btnr)
begin
led(0) &lt;=A(0) xor B(0);
led(1) &lt;=A(1) xor B(1);
led(2) &lt;=A(2) xor B(2);
led(3) &lt;=A(3) xor B(3);
end process;

end Behavioral;

I modified the constraints file accordingly

set_property -dict { PACKAGE_PIN T14   IOSTANDARD LVCMOS25 } [get_ports { led }]; #IO_L15P_T2_DQS_13 Sch=led[0]

## Switches

set_property -dict { PACKAGE_PIN E22  IOSTANDARD LVCMOS12 } [get_ports { A }]; #IO_L22P_T3_16 Sch=sw[0]

set_property -dict { PACKAGE_PIN F21  IOSTANDARD LVCMOS12 } [get_ports { B }]; #IO_25_16 Sch=sw[1]

Here is the error
[DRC MDRV-1] Multiple Driver Nets: Net led_OBUF[0] has multiple drivers:led_OBUF[0]_inst_i_1/O, led_OBUF[0]_inst_i_3/O, and led_OBUF[0]_inst_i_2/O.
The second code, with no errors. I show this code because I am unsure of how 4 inputs (3 downto 0) can be mapped to a single input. I have named the ports using the original port names in the constraint file.
port(sw0 : in STD_LOGIC_VECTOR(3 downto 0);
led0: out STD_LOGIC_VECTOR(3 downto 0)
);

end Lab_2_Source_File;

architecture Behavioral of Lab_2_Source_File is
begin 

process(sw0) 
begin 

led0&lt;=sw0;

end process; 
end Behavioral;

As mentioned above, the error leads me to beleive that it is due to trying to map multiple signals to the led output, however whilst this makes sense, I am confused as the same error does not occur when I map multiple signals to the output on the other code. Please could someone help me explain what's going on?","
the error leads me to beleive that it is due to trying to map multiple signals to the led output

This is correct.

however whilst this makes sense, I am confused as the same error does not occur when I map multiple signals to the output on the other code.

In the last example,
led0&lt;=sw0;

the only driver for led0(0) is sw0(0), and the only driver for led0(1) is sw0(1), and so on. So there are no multiple drivers for one net, as in the first example, which is why there is no error.",,,,,
Width mismatch in assignment: VHDL,"My code:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
library work;
use work.costanti.all;

entity Multiplier is
    generic(nbA:integer:=nbA;
            nbB:integer:=nbB);
    port (
        A: in STD_LOGIC_VECTOR(nbA-1 downto 0);
        B: in STD_LOGIC_VECTOR(nbB-1 downto 0);
        clk: in STD_LOGIC;
        R: out STD_LOGIC_VECTOR(nbA+nbB-1 downto 0));

end Multiplier;

architecture Behavioral of Multiplier is

component AdderTree is
    generic(nbit: integer:=nbA+nbB);
    port (
          IN1: in STD_LOGIC_VECTOR(nbit-1 downto 0);
          IN2: in STD_LOGIC_VECTOR(nbit-1 downto 0);
          IN3: in STD_LOGIC_VECTOR(nbit-1 downto 0);
          IN4: in STD_LOGIC_VECTOR(nbit-1 downto 0);
          IN5: in STD_LOGIC_VECTOR(nbit-1 downto 0);
          IN6: in STD_LOGIC_VECTOR(nbit-1 downto 0);
          IN7: in STD_LOGIC_VECTOR(nbit-1 downto 0);
          IN8: in STD_LOGIC_VECTOR(nbit-1 downto 0);
          IN9: in STD_LOGIC_VECTOR(nbit-1 downto 0);
          S: out STD_LOGIC_VECTOR(nbit-1 downto 0)
          );
end component;

signal V : STD_LOGIC_VECTOR(nbA-1 downto 0);
signal P : STD_LOGIC_VECTOR((nbA*nbB)-1 downto 0);
signal PP_0to6 : STD_LOGIC_VECTOR( (nbA)+(nbA+1)+(nbA+2)+(nbA+3)+(nbA+4)+(nbA+5)+(nbA+6)-1 downto 0); --(dim(pp0+PP1+PP2+PP3+PP4+PP5+PP6) downto 0 )
signal PP7 : STD_LOGIC_VECTOR(nbA+nbB-1 downto 0);
signal P7 : STD_LOGIC_VECTOR(nbA downto 0);
signal PPP : STD_LOGIC_VECTOR((nbA+nbB)*(nbB+1)-1 downto 0);


begin

for_g: for i in 0 to nbB-1 generate
        V &lt;= (others =&gt; B(i));
        P((nbB)*(i)+(nbB-1) downto (nbB)*(i)) &lt;= V and A;
end generate for_g;

P7 &lt;= '0' &amp; P((nbA*nbB)-1 downto (nbA*nbB)-1-(nbB-1));

PP_0to6(nbB-1 downto 0)  &lt;= P(nbB-1 downto 0); --PP0

for_g2: for i in 0 to nbB-3 generate
         PP_0to6((nbB+1)*(i+1)+(i*(i+1)/2)+7 downto (nbB+1)*(i+1)+(i*(i+1)/2)) &lt;= P(nbB*(i+1)+(nbB-1) downto nbB*(i+1)); --PP1 to PP6
         PP_0to6((nbB+1)*(i+1)+(i*(i+1)/2)-1 downto (nbB+1)*(i)+((i-1)*(i)/2)+7+1) &lt;= (others =&gt; '0');
end generate for_g2;

PP7(nbA+nbB-1 downto nbA-1) &lt;= P7;
PP7(nbA-2 downto 0) &lt;= (others =&gt; '0');

PPP_0to6: for i in 3 to nbB-2 generate
            PPP(((i+1)*(nbA+nbB-1)+i)-(8-i) downto i*(nbA+nbB)) &lt;= PP_0to6( (i+1)*(nbB-1)+((1/2)*((i*i)+(3*i))) downto i*(nbB)+(i-1)*i/2); --PP0 to PP6
            PPP(((i+1)*(nbA+nbB-1)+i) downto ((i+1)*(nbA+nbB-1)+i)-(8-i)+1)&lt;= (others =&gt; '0');
end generate PPP_0to6;

-- Fill last 32 bits of PPP
--Insert ADDER TREE
 
end Behavioral;

Portion of the error code: portion of code
PPP_0to6: for i in 0 to nbB-2 generate

        PPP(((i+1)*(nbA+nbB-1)+i)-(8-i) downto i*(nbA+nbB)) &lt;= PP_0to6( (i+1)*(nbB-1)+((1/2)*((i*i)+(3*i))) downto i*(nbB)+(i-1)*i/2); --PP0 to PP6

        PPP(((i+1)*(nbA+nbB-1)+i) downto ((i+1)*(nbA+nbB-1)+i)-(8-i)+1)&lt;= (others =&gt; '0');

end generate PPP_0to6;

Hi, I'm making a multiplier on vhdl, but on line 66 it reports me the following error:
if i=1: [Synth 8-690] width mismatch in assignment; target has 9 bits, source has 7 bits [&quot;...Multiplier.vhd&quot;:66]
if i=2: [Synth 8-690] width mismatch in assignment; target has 10 bits, source has 5 bits [&quot;...Multiplier.vhd&quot;:66]
if i=3: [Synth 8-690] width mismatch in assignment; target has 11 bits, source has 2 bits [&quot;...Multiplier.vhd&quot;:66]
and so on..
I can't understand why, they seem to be the same size ..
my constant are:
nbA=8
nbB=8
and the signal P, PP_0to6 and PPP:
signal P : STD_LOGIC_VECTOR((nbA*nbB)-1 downto 0);
signal PP_0to6 : STD_LOGIC_VECTOR( (nbA)+(nbA+1)+(nbA+2)+(nbA+3)+(nbA+4)+(nbA+5)+(nbA+6)-1 downto 0);
signal PPP : STD_LOGIC_VECTOR((nbA+nbB)*(nbB+1)-1 downto 0);

N.B. I make sure to shift to the rigth by adding zeros as in the figure:
schema
The error is here:
PPP(((i+1)*(nbA+nbB-1)+i)-(8-i) downto i*(nbA+nbB)) &lt;= PP_0to6( (i+1)*(nbB-1)+((1/2)*((i*i)+(3*i))) downto i*(nbB)+(i-1)*i/2);

but if I tried to replace the value of i:
i=0: PPP(7 downto 0) &lt;= PP_0to6(7 downto 0);
i=1: PPP(24 downto 16)&lt;=PP_0to6(16 downto 8)
i=2: PPP(41 downto 32)&lt;=PP_0to6(26 downto 17)
i=3: PPP(58 downto 48)&lt;=PP_0to6(37 downto 27)
...
...

the dimensions look the same.","I guess strictly speaking this answer doesn't really answer your question, since I'm not trying to figure out where your error is. But I'm convinced that if you change your coding style you won't encounter such difficult to debug errors any more.
As mentioned in my comments, your code will become must clearer and easier to debug if you split the signal up properly. I.e. don't create one giant signal for everything.
VHDL has arrays and records, use them, they won't make your circuit any larger, but the code will be much easier to reason about.
It's been a while since I actually wrote VHDL, so the syntax below might contain typo's, but hopefully the idea behind the code is clear:
constant c_AllZeros : std_logic_vector(c_MaxZeros - 1 downto 0) := (others =&gt; '0');

...

type t_P is std_logic_vector(c_SomeLength - 1 downto 0);
subtype t_P_Array is array (natural range &lt;&gt;) of t_P;

...

signal P : t_P_Array(0 to c_NumInputs - 1);

...

PPP_0to6: for i in PPP'range generate
  PP(i)  &lt;= P(i) &amp; c_AllZeros(index downto 0);
  PPP(i) &lt;= c_AllZeros(c_MaxZeros - index downto 0) &amp; PP(i);
end generate PPP_0to6;

As you might notice, I also got rid of the explicit indices for the for-loop in the generate. There's still a magic number when indexing the all_zeroes signal to generate PPP. If I was writing this code, I'd replace that with some (calculated) constant with a meaningful name. This will make the code both more readable and trivial to change later on.
Note that there's other ways to do this. E.g. you could first set all bits of all PP signals to 0 and then assign a slice of them the P value.",,,,,
waveform does not work properly for some operations,"i am newbie in vhdl, modelsim, waveform etc. i've developed a simple operational process and a testbench to test my operations one by one on modelsim waveform.
when i run at simulator i see there are some problems; at multiply operation result is not put to output variable (result_out1) although it is calculated correctly at temp variable (uQ2). furthermore mod and rem operations do not give any output.
although add, sub and div operations work as expected why mul, mod and rem operaions fail?
i am sharing my code and waveform result below.
my code and testbench are below;
 rns.vhd
 library IEEE;
 use IEEE.STD_LOGIC_1164.ALL;
 use IEEE.NUMERIC_STD.ALL;

 entity rns is 
      port(
           en: in std_logic;
           op: in std_logic_vector(2 downto 0);
           reg_a_in: in std_logic_vector(7 downto 0);
           reg_b_in: in std_logic_vector(7 downto 0);
           reg_c_in: in std_logic_vector(7 downto 0);
           result_out1: out std_logic_vector(7 downto 0);
           result_out2: out std_logic_vector(7 downto 0)
      );
 end entity;


 architecture behave of rns is     
      signal uA, uB, uC, uQ, uR: unsigned(8 downto 0);
      signal uQ2: unsigned(17 downto 0);
      signal result: std_logic_vector(8 downto 0);
      
 begin
      
      process(reg_a_in, reg_b_in, op)
      begin
           uA &lt;= unsigned('0' &amp; reg_a_in);
           uB &lt;= unsigned('0' &amp; reg_b_in);
      
           if op = &quot;000&quot; then
                uQ &lt;= uA + uB;
           elsif op = &quot;001&quot; then
                uQ &lt;= uA - uB;
           elsif op = &quot;010&quot; then
                uQ2 &lt;= uA * uB;
                uQ &lt;= resize(uQ2, uQ'length); --uQ2(8 downto 0);
           elsif op = &quot;011&quot; then
                uQ &lt;= uA / uB;
           elsif op = &quot;100&quot; then
                uQ &lt;= uA mod uB;
           elsif op = &quot;101&quot; then
                uQ &lt;= uA rem uB;
           end if;
                
      end process;
       
      result &lt;= std_logic_vector(uQ) when en = '1' else (others=&gt;'Z'); 
      result_out1 &lt;= result(7 downto 0) when en = '1' else (others=&gt;'Z');
      
 end behave;


rns_tb.vhd
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity rns_tb is 
end entity;

architecture behave of rns_tb is

    component rns is
        port(
            en: in std_logic;
            op: in std_logic_vector(2 downto 0);
            reg_a_in: in std_logic_vector(7 downto 0);
            reg_b_in: in std_logic_vector(7 downto 0);
            reg_c_in: in std_logic_vector(7 downto 0);
            result_out1: out std_logic_vector(7 downto 0);
            result_out2: out std_logic_vector(7 downto 0)
        );
    end component;

    signal en_sig: std_logic;
    signal op_sig: std_logic_vector(2 downto 0);
    signal reg_a_in_sig: std_logic_vector(7 downto 0);
    signal reg_b_in_sig: std_logic_vector(7 downto 0);
    signal reg_c_in_sig: std_logic_vector(7 downto 0);  
    signal result_out1_sig: std_logic_vector(7 downto 0);
    signal result_out2_sig: std_logic_vector(7 downto 0);

    constant wait_period: time :=10 ns;

begin
    rns1 : rns port map(en=&gt;en_sig, op=&gt;op_sig, reg_a_in=&gt;reg_a_in_sig, reg_b_in=&gt;reg_b_in_sig, 
    reg_c_in=&gt;reg_c_in_sig, result_out1=&gt;result_out1_sig, result_out2=&gt;result_out2_sig);
    
    process
    begin
    
        op_sig &lt;= (others =&gt; 'Z');
        wait for wait_period * 3;
        reg_a_in_sig &lt;= &quot;00000011&quot;;
        reg_b_in_sig &lt;= &quot;00000010&quot;;
        reg_c_in_sig &lt;= &quot;00000101&quot;;
        
        wait for wait_period;
        en_sig &lt;= '1';
        op_sig &lt;= &quot;000&quot;;
        
        wait for wait_period * 5;
        op_sig &lt;= &quot;001&quot;;
        
        wait for wait_period * 5;
        op_sig &lt;= &quot;010&quot;;
        
        wait for wait_period * 5;
        op_sig &lt;= &quot;011&quot;;

        wait for wait_period * 5;
        op_sig &lt;= &quot;100&quot;;
        
        wait for wait_period * 5;
        op_sig &lt;= &quot;101&quot;;
        wait;
                
    end process;
end behave;

thanks in advance.
","To be honest I'd suggest to use only clocked processes until you fully understand how they work. But let's see if we can fix your problem.
The problem is with the sensitivity list of your process. The simulation tool will evaluate the result of the process whenever a signal in the sensitivity list changes. For all operations this is signal op that changes and the process re-evaluates uQ.
Important note: Sensitivity lists only serve for simulation purpose and signals are assigned after the process evaluation is complete.
The above means that in case of your multiplication, the op changes to 010 and the process evaluates
            uQ2 &lt;= uA * uB;
            uQ &lt;= resize(uQ2, uQ'length); --uQ2(8 downto 0);

but because signals are assigned after evaluation, uQ2 will have the result of the multiplication but uQ is the resize of the previous uQ2. To fix this you can either...

Not use uQ2 and directly write uQ &lt;= resize(uA * uB, uQ'length)
Extend the sensitivity list with uQ2 so that uQ is re-evaluated once uQ2 got updated.
As correctly mentioned in the comment, if you need &quot;signals&quot; in a process that are evaluated immediately use variables instead of signal types.

The result assignment can be optimized and to be honest, I would't use Z in this case.
  --result &lt;= std_logic_vector(uQ) when en = '1' else (others=&gt;'Z');
  result_out1 &lt;= std_logic_vector(uQ(7 downto 0)) when en = '1' else (others=&gt;'0');

In general, this implementation has some pitfalls and you might should add some additional control signals or even make it a clocked process. Check if this solves your issue, I didn't test it and my brain is still in Christmas mode.",,,,,
dumping vcd files in Modelsim simulations,"I am trying to dump a vcd file when simulating with modelsim, however, I don't get anything in my ""dumpVCD.vcd"" file. The syntax I am usingin .do file is as follows:

vcd file dumpVCD.vcd
vcd add -r /dff_TB/* 


however the dumpVCD.vcd file doesn't have the waveforms. 

I have uploaded the test on edaplayground (link).

I would appreciate it if someone could advise me what is the problem with this.",You need to add a runtime optimization switch -voptargs=+acc=npr to preserve signal visibility. I'll put in a request to have this on by default. ,,,,,
Verilog did not give the expected result,"I wrote this Verilog code.  The inner module is an 8-bit mux, and the top module is used to test the mux.  It should display 11110000, but it displayed xxxxxxxx every time.  How do I fix this?

module testbench;

reg CLK;
test mytest(CLK);
initial begin
CLK = 1'b0;
#10
CLK = 1'b1;
end
endmodule

module test(CLK);
input CLK;
reg [7:0] in0,in1;
reg sel;
wire [7:0] out;

mux myux(in0,in1,sel,out);

always @(posedge CLK) begin
    sel = 1'b0;
    in0 = 8'b11110000;
    $display(""%b"",out);
    end
endmodule


This is the mux module:

module mux(in0,in1,sel,out);
    input sel;
    input [7:0] in1,in0;
    output [7:0] out;
    reg out;

    always @(in0,in1,sel) begin

    if(sel == 1'b0) begin

        out = in0;

    end
    else begin

        out = in1;

    end
    end

endmodule
","The problem is that you did not run your simulation long enough.  You only ran it for one clock cycle.  Here is one way to change your testbench module to run many clock cycles:

module testbench;

reg CLK;
test mytest(CLK);

initial begin
    CLK = 1'b0;
    forever #10 CLK =~CLK;
end

initial #1000 $finish;

endmodule


I now see output like this:

xxxxxxxx
11110000
11110000
11110000
11110000


Also, I got a compile error with your code.  In your mux module, you should change:

reg out;


to:

reg [7:0] out;
",,,,,
cocotb simulation with Aldec,"I am doing some EDA tools test with cocotb as a testbench. I am running simulations with icarus and verilator without problem, however, with Aldec I have got a problem at ""runsim.tcl"".

The output of the console is

 Welcome to VSIMSA!
 This message was printed from `startup.do' macro file.

 runsim.tcl(5) error: parse error
 @if [string length&lt;--
 make[1]: *** [/c/users/mehdi/anaconda3/lib/site-packages/cocotb/share/makefiles/simulators/Makefile.aldec:176: results.xml] Error 1
 make[1]: Leaving directory '/c/Users/Mehdi/testcocotbVerilator'
 make: *** [c:\users\mehdi\anaconda3\lib\site-packages\cocotb\share\makefiles/Makefile.sim:82: sim] Error 2


I would appreciate if someone could advise me how to fix this","Your tag says active-hdl - then you should probably use the new SIM=activehdl from cocotb master.
SIM=aldec is for Riviera-PRO. ",,,,,
unnecessary register reset in FPGA,"Assume I have some internal registers that I do not have to reset, for example, if I set them in the state before I use them - like buffer here, I do not give it any value on reset, and when the state transitions to STATE_1 (where I need the buffer) I load it:

always @(posedge clk or negedge reset_n) 
begin
   if(!reset_n) 
      state &lt;= IDLE
   else begin
       case(state)
         IDLE: begin
             if(in1) begin
                buffer &lt;= in2
                state &lt;= STATE_1             
             end
         end
         STATE_1 :begin
             use buffer..
          end       
       endcase
   end
end


Is it really necessary to also include buffer in the async reset and to give it a value upon reset?
will the synthesis tool do it anyway? on what does this depend? what is good practice?
Because intuitively this feels more efficient because the synthesis will not have to find a way to wire the reset to the buffer.","It is safe not to reset a flip-flop. There are advantages to leaving out a reset:


In an IC, that will result in a flip-flop without a reset being
synthesised, which will be slightly smaller than one will a reset.
That probably won't be the case in an FPGA, because a flip-flop with a reset  will
be present anyway. (However, some FPGA synthesisers can make flip-flops
out of LUTs and whether that is possible or not might depend on
whether you have a reset or not.) 
In either an IC or an FPGA, routing resource will not be taken up
routing the reset signal to your flip-flop.


However, in an IC, some design flows might mandate a reset for manufacturing-test purposes. That's not an issue in an FPGA.",,,,,
Can someone explain this strange systemverilog constraint behavior?,"I am having hard time understanding this behavior with randomization in vcs simulation. can someone please help me?

class c;
  rand bit [31:0] base;

  constraint base_c {
    base +32'h40_0000 &lt; 32'hFFFF_FFFF;
  }

endclass

module m;
  c c_obj = new();

  initial begin
    c_obj.randomize() with {
      base == 'hffe6_f6e2;
    };
  end
endmodule


I am not getting constraint error. base is of type bit which is unsigned. If I change the constraint as follows

constraint base_c {
  base &lt; 32'hFFFF_FFFF - 32'h40_0000;
}


I get constraint error now. How does this work?","It's very simple to work out the math here. All you need to do is plug in the values. 

In the first case, you have

32'hffe6_f6e2 + 32'h40_0000 &lt; 32'hFFFF_FFFF


which reduces down to 

32'h0026_f6e2 &lt; 32'hFFFF_FFFF
1'b1 // True


But when you have 

32'hffe6_f6e2 &lt; 32'hFFFF_FFFF - 32'h40_0000


This reduces down to 

32'hffe6_f6e2 &lt; 32'hffbf_ffff
1'b0 // False


It's not clear from your question what you are expecting, but you need to take underflow and overflow into account when writing constraints. 

I just wrote a related blog post on these kind of math issues here.",,,,,
Range Specification Verilog,"I am reading two sources which seem to be giving me contradictory information on rules regarding range specification. This says that, ""Identical instance names cannot appear twice with other range specifications (even if ranges do not overlap each other)"" while Intel's  tutorial on Verilog basics has an example of a 4-bit shifter at timestamp 34:28 with the following code:

integer i;

always@(inp,cnt)begin
  result[7:4] = 0;
  result[3:0] = inp;

  if(cnt==1)begin

    for(i=4; i&lt;=7; i=i+1)begin
      result[i]=result[i-4];
    end

    result[3:0] = 0;

  end

end


Wouldn't ""result[7:4]"" and ""result[3:0]"" be an instance name that occurred twice with ""other range specifications"", one being [7:4] and the other being [3:0]? Or am I misunderstanding what is meant by ""other range specifications""?","'Range Specification' refers to creating multiple module instances at once. E.g. this is invalid:

my_module m [3:0] (...);
my_module m [7:4] (...);


What you have in your example is called 'Part-select'.",,,,,
SystemVerilog: $urandom_range gives values outside of range,"I am getting an odd issue in ModelSim where I set an input variable to a random value in a range, but for some reason, I get a value outside of the range. All my code is included below but the essential line is: 

write_addrs[i] = $urandom_range(1,NUM_ARCH_REGS);

In ModelSim, it is being assigned to 0 when it shouldn't (as shown in the waveform; the highlighted signal)...



The thing that is confounding me is that I don't ever set the write_adresses to zero except for when I set the initial signals in the INITIAL_VECTOR_VALUES block. I only modify the variable by using the $urandom_range function with the range explicitly excluding the number zero.

The main blocks of code in which I write to this variable are here:

    initial begin : INITIAL_VECTOR_VALUES
        advance = 0;
        checkpoint = 0;
        recover = 0;
        write_before_checkpoint = 0;
        for (int i = 0; i &lt; NUM_READ_PORTS; i++)
            read_addrs[i]  = 0;
        for (int i = 0; i &lt; NUM_WRITE_PORTS; i++) begin
            write_addrs[i] = 0;         //&lt;--------------------- HERE!!!
            wr_en[i] = 0;
            write_data[i] = 0;
            commit_en[i] = 0;
            commit_data[i] = 0;
            commit_addrs[i]= 0;
        end
    end


... and here:

    task random_operations(int repeat_num);
        //local vars
        int operation_select, num_write, num_commit;
        int current_checkpoints;
        int loop_idx;
        ##5;

        current_checkpoints = 0; //initialize
        $display(""Begin Random Operations @ %0t"", $time());
        while (loop_idx &lt; repeat_num) begin
            ... other stuff ...
            //operand select (sets the stimulus inputs)

            for (int k = 0; k &lt; num_write; k++) begin
                write_addrs[k] = $urandom_range(1,NUM_ARCH_REGS); //&lt;--------------------- HERE!!!
                $display(""%0t: num_write = %0d"",$time(), num_write);
                $display(""%0t: write_addrs[%0d] = %0d"", $time(), k, write_addrs[k]);
                write_data[k] = $urandom_range(1,128);
                wr_en[k] = 1;
            end
            ...
            loop_idx++;
            ##1;

            //reset signals (reset stimulus inputs)
            ...
        end : end_while
    endtask : random_operations


Does anyone know why this would be happening? 

REFERENCE CODE

`timescale 1ns/1ns

module testbench;

localparam int NUM_CHECKPOINTS = 8;
localparam int NUM_ARCH_REGS = 32; 
localparam int NUM_READ_PORTS = 4; 
localparam int NUM_WRITE_PORTS = 2;

logic clk;
logic rst;
initial begin : CLOCK_INIT
    clk = 1'b0;
    forever #5 clk = ~clk;
end
default clocking tb_clk @(posedge clk); endclocking


logic [$clog2(32)-1:0] read_addrs [4];
logic [$clog2(32)-1:0] write_addrs [2];
logic wr_en [2];
logic advance;      //moves tail pointer forward
logic checkpoint;       //moves head pointer forward
logic recover;      //moves head pointer backward (to tail)
logic write_before_checkpoint;
logic [$clog2(32)-1:0] commit_addrs [2];
logic [$clog2(128)-1:0] commit_data [2];
logic commit_en [2];
logic [$clog2(128)-1:0] write_data [2];
logic [$clog2(128)-1:0] read_data [4]; 
logic [$clog2(128)-1:0] write_evict_data [2];
logic enable_assertions;

cfc_rat dut(.*);
shadow_rat rat_monitor(.*);

initial begin : INITIAL_VECTOR_VALUES
    advance = 0;
    checkpoint = 0;
    recover = 0;
    write_before_checkpoint = 0;
    for (int i = 0; i &lt; NUM_READ_PORTS; i++)
        read_addrs[i]  = 0;
    for (int i = 0; i &lt; NUM_WRITE_PORTS; i++) begin
        write_addrs[i] = 0;
        wr_en[i] = 0;
        write_data[i] = 0;
        commit_en[i] = 0;
        commit_data[i] = 0;
        commit_addrs[i]= 0;
    end
end

task reset();
    rst = 1;
    ##2;
    rst = 0;
    ##1;
endtask : reset


task random_operations(int repeat_num);
    //local vars
    int operation_select, num_write, num_commit;
    int current_checkpoints;
    int loop_idx;

    ##5;

    current_checkpoints = 0; //initialize

    $display(""Begin Random Operations @ %0t"", $time());
    while (loop_idx &lt; repeat_num) begin

        operation_select = (loop_idx &lt; 5) ? 1 : ((dut.dfa.chkpt_empty) ? $urandom_range(0,1) : ((dut.dfa.chkpt_full) ? 1 : $urandom_range(0,2)));
        num_write = $urandom_range(0,NUM_WRITE_PORTS);
        num_commit = $urandom_range(0,NUM_WRITE_PORTS);

        case (operation_select)
            0: begin //checkpoint
                if (current_checkpoints+1 &lt; NUM_CHECKPOINTS) begin
                    $display(""Checkpoint @ %0t"", $time());
                    write_before_checkpoint = $urandom_range(0,1);
                    checkpoint = 1;
                    current_checkpoints++;
                end
                else begin
                    loop_idx--;
                    continue;
                end
            end
            1: $display(""Normal RW @ %0t"",$time()); //no operation, only read and write
            2: begin //advance
                if (current_checkpoints &gt; 0) begin 
                    advance = 1;
                    $display(""Advance @ %0t"", $time());
                    current_checkpoints--;
                end
                else begin
                    loop_idx--;
                    continue;
                end
            end
            3: begin //recover
                $display(""Recover @ %0t"", $time());
                recover = 1;
                current_checkpoints = 0;
            end
            default:;
        endcase // operation_select

        //operand select (sets the stimulus inputs)
        for (int k = 0; k &lt; NUM_READ_PORTS; k++)
            read_addrs[k]  = $urandom_range(0,NUM_ARCH_REGS);

        for (int k = 0; k &lt; num_write; k++) begin
            write_addrs[k] = $urandom_range(1,NUM_ARCH_REGS);
            $display(""%0t: num_write = %0d"",$time(), num_write);
            $display(""%0t: write_addrs[%0d] = %0d"", $time(), k, write_addrs[k]);
            write_data[k] = $urandom_range(1,128);
            wr_en[k] = 1;
        end
        for (int k = 0; k &lt; num_commit; k++) begin
            commit_addrs[k] = $urandom_range(1,NUM_ARCH_REGS);
            commit_data[k] = $urandom_range(1,128); 
            commit_en[k] = 1;
        end
        loop_idx++;
        ##1;

        //reset signals (reset stimulus inputs)
        checkpoint = 0;
        recover = 0;
        advance = 0;
        write_before_checkpoint = 0;
        for (int i = 0; i &lt; NUM_WRITE_PORTS; i++) begin
            write_data[i] = 0;
            wr_en[i] = 0;
        end
        for (int i = 0; i &lt; NUM_READ_PORTS; i++)
            read_addrs[i] = 0;
        for (int i = 0; i &lt; NUM_WRITE_PORTS; i++) begin
            commit_en[i] = 0;
            commit_data[i] = 0; 
        end
    end : end_repeat
endtask : random_operations




initial begin : TEST_VECTORS
    enable_assertions = 1; //for testing the monitor

    reset();
    random_operations(5000);

    ##10;
    $display(""Finished Successfuly! @ %0t"",$time());
    $finish;
end

endmodule
","The problem is that $urandom_range(1, NUM_ARCH_REGS) returns values from 1 to 32.  But, write_addrs is declared as logic [4:0], which means it can only take on values from 0 to 31.  When $urandom_range returns 32 (which is the same as 6'b10_000), the assignment in your code truncates it to 5 bits, dropping the MSB, and 5'b0_0000 is stored in write_addrs.

To fix this, only allow random values up to 31.

Change:

        write_addrs[k] = $urandom_range(1, NUM_ARCH_REGS);


to:

        write_addrs[k] = $urandom_range(1, NUM_ARCH_REGS-1);


Here is a complete example to demonstrate the problem:

module tb;

localparam int NUM_ARCH_REGS = 32; 
logic [$clog2(32)-1:0] write_addrs [2];

initial begin
    repeat (100) begin
        for (int k=0; k&lt;2; k++) begin
            write_addrs[k] = $urandom_range(1, NUM_ARCH_REGS);
            $write(""write_addrs[%0d]=%02d "", k, write_addrs[k]);
        end
        $display;
    end
end
endmodule


The problem you see is not specific to ModelSim;  I am able to see it on 2 other simulators.",,,,,
Why does my kernel module Makefile build a .ko with kernel 4.14 but not 5.6?,"I have a Makefile made by following this example:
cross compile kernel module

I built a 4.14 Linux kernel from an older Xilinx source, and then built a out-of-kernel module with that script, pointing it to the said 4.14 kernel sources, and filling in the blanks for my particular platform architecture.
That worked.
(It's based on this code, if that matters: dma-proxy.c)

Now I need a newer version, and got Xilinx sources with a kernel named 5.6.0-rc1.
(--branch ""zynqmp-soc-for-v5.7"" from here)
Building that kernel also worked fine.
If I now use a scrubbed clean directory (incl. hidden files) with my module source code and that Makefile again, pointing to the newer kernel sources, it does neither produce a .ko file nor an error message.
All I get is:

make ARCH=arm64 CROSS_COMPILE=""aarch64-linux-gnu-"" -C /home/sk/src/XILINX/linux-xlnx SUBDIRS=/home/sk/src/XILINX/dma-proxy/driver modules
make[1]: Entering directory '/home/sk/src/XILINX/linux-xlnx'
CALL    scripts/checksyscalls.sh
CALL    scripts/atomic/check-atomics.sh
MODPOST 28 modules
make[1]: Leaving directory '/home/sk/src/XILINX/linux-xlnx'


No .ko file in my folder as it was before when building with 4.14, and it doesn't list actually compiling anything.
I find it curious that it says ""MODPOST 28  modules"", whereas with pointing it to kernel 4.14, it expectedly says ""1 modules""
Has anything changed between 4.14 and 5.x that would cause this?","Mkay, here is the suggested makefile template by the tutorial I referenced in the question:

PWD := $(shell pwd)
obj-m += hello.o

all:
        make ARCH=arm CROSS_COMPILE=$(CROSS) -C $(KERNEL) SUBDIRS=$(PWD) modules
clean:
        make -C $(KERNEL) SUBDIRS=$(PWD) clean


Turns out that if I replace SUBDIRS=$(PWD) with M=$(PWD), it works. Now if I google explicitly for that M variable in conjunction with building kernel modules, I do find text that show it that way. But the net is also littered with examples using SUBDIRS, and it worked for me with a fairly recent kernel (4.14).

Then I did find references hinting at this being an old way of doing it, like from here:

make -C $KDIR SUBDIRS=$PWD
    Same as M=. The SUBDIRS= syntax is kept for backwards compatibility.


In fact, this seems to be really old, like, kernel 2.6.7 old. Unfortunately, fairly recent tutorials show the old way.",,,,,
multi dimensional array ports support in icarus verilog,"I am trying to use multi dimensional arrays as ports in my systemverilog code. the top module is a 3-dimensional array whereas the submodule is a 2-dimensional one. A simplified test bench and design is as follows:

  module TB();

      wire  [3:0]d_inAll  [0:99][0:9];
      wire  [3:0]d_outAll [0:99][0:9];

      genvar iX;
      for (iX=0; iX&lt;100; iX=iX+1)begin
           someDesign DUT_i(.d_in(d_inAll[iX]) , .d_out(d_outAll[iX]));
      end

   endmodule


and the design is 

module someDesign(input wire [3:0] d_in[0:9],
                  output wire[3:0] d_out [0:9]);

  genvar i;
  for (i=0; i&lt;10; i=i+1)begin
    assign d_out[i] = d_in[i];
  end

endmodule 


I was trying to compile this code with icarus verilog but it fails with following error.

../elaborate.cc:1439: failed assertion rval_net-&gt;pin_count() == prts[0]-&gt;pin_count()


Is this a bug with the compiler or some feature not supported yet? is there any other method I could use to workaround the problem? I am aware I can flatted the arrays, however, I would prefer not to use it as it will make the design more prone to functional bugs. ","It's a bug, therefore it's unsupported. It seems to support 1-D unpacked array ports, so you can move one of the array dimensions to the packed side. 

module TB();

      wire  [0:9][3:0]d_inAll  [0:99];
      wire  [0:9][3:0]d_outAll [0:99];

      genvar iX;
  for (iX=0; iX&lt;100; iX=iX+1)begin : fiX
           someDesign DUT_i(.d_in(d_inAll[iX]) , .d_out(d_outAll[iX]));
      end

   endmodule

module someDesign(input wire [0:9][3:0] d_in,
                  output wire[0:9][3:0] d_out);

  genvar i;
  for (i=0; i&lt;10; i=i+1)begin
    assign d_out[i] = d_in[i];
  end
endmodule
",,,,,
Shift Register not working in Verilog HDL,"I'm trying to design a 64-bit Shift register in Verilog HDL but when I test the code with a testbench, all the bits are zeros. I don't know where I'm going wrong. Here is my code and the test bench result:

module ShiftRegister (shift_out, clk, shift_in, rst); //module ports
 parameter n = 64; //Parameter n declared to store 64
 input rst;
 input [n-1:0] shift_in; //64-bit input shift_in
 input clk; //Input clock
 output [n-1:0] shift_out; //64-bit output shift_out
 reg [n-1:0] ff; //64-bit flipflop
  assign shift_out = ff [n-1:0]; //give the output of the 64th bit
  //The operation of verilog: 
   always @ (posedge clk or posedge rst) //Always at the rising edge of the clock
   begin
     if (rst) begin
     ff &lt;= 0;
   end else begin
     ff &lt;= ff &lt;&lt; 1;  //Shift bits to the left by 1
     ff[0] &lt;= shift_in; //Take the input bits and give it to the first flipflop
   end
   end
 endmodule


 module ShiftRegister_tb; //Module shiftRegister_tb
  parameter n = 64; //Parameter n declared to store 64
  reg [n-1:0] shift_in; //64-bit register input shift_in
  reg clk, rst; //register clock
  wire [n-1:0] shift_out; //64-bit wire output shift_out
  ShiftRegister DUT(shift_out, clk, shift_in,rst); //Calling the module
   initial
   begin
     clk = 0; //clock = 0 initally
     rst = 1;
     shift_in = 64'd34645767785344; //Random decimal number to test the code 
     #100;
     rst = 0;
     #50_000 $finish;
   end   
  always #50 clk =~clk; //invert the clock input after 50ps
 endmodule //ShiftRegister testbench 


","Here ff[0] &lt;= shift_in;, you are trying to assign a 64-bit variable to 1-bit variable. Since you use a even number (64'd34645767785344) for shift_in in your testbench, its LSB is 0. Therefore, you keep inserting 0 to ff.

Make your shift_in input 1-bit and change your testbench such that you will give 1-bit at a time as input.",,,,,
Verilog: Use of register: When are the values actually updated?,"When exactly are the variables inside an always-block in Verilog updated?
E.g. if the reg C is changed multiple times in an always-block: does the value of it always change? Or is the value only ""physically written"" to the reg at the end of the always-block?

Would it be better to use an extra intermediate register which is only actualized at the end of the always-block? Would it make any difference?

reg C;

always @(*)
C = 0;
C = A;
C = 1;
C = B;
end


Other example:
If I have a module with an always block as follows, could the multiple assignments of the output exhibit sort of a glitch, where the output quickly goes to 0 before getting the value of B? Does it make a difference if I use blocking (=) or non-blocking (&lt;=) assignments?

module example1 (output C, input A, input B);

always @(*)
begin
 C = 1â€™b0;
 if (A==1)
   C = B ;
end
endmodule


Example with intermediate register to avoid unwanted change of the output.

module example1 (output C, input A, input B);

reg intermediateReg;

always @(*)
begin
 intermediateReg = 1â€™b0;
 if (A==1)
   intermediateReg = B ;
end
   C &lt;= intermediateReg;
endmodule
","In the examples you provided the code behaves identically to the 'c' code. The variable gets re-assigned new values and the last one wins. In verilog this is true for blocking (=) or non-blocking (&lt;=) assignments, but not for the mix of them. 

As in 'c' it is up to the compiler optimization technique. It can eliminate unneeded assignments, so only the last one is relevant.

In your first example the value of 'C' will be 'B' at the end of the block. The value of 'C' in the second example will either be 0 or B, depending on A.

Now, for the purpose of a simplicity of explanation, mixing of blocking and non-blocking assignments will cause the last 'non-blocking' assignment win. The reason is that all nba's are executed after the block is finished.

always @(*) begin
   C &lt;= A;
   C = B;
end


The value of C will be A at the end of the simulation cycle.

As for the question about using intermediate values, there is no difference. You use them as needed. The simulation compiler or synthesis will optimize your code in any case. The last example is absolutely normal, except that it does not change anything at all. It behaves the same way as this, which is more explicit and more readable in my opinion. The only problem is that you incorrectly use nba assignments int combinational logic (which i fixed).

always @(*)
begin
 if (A==1)
   C = B ;
 else
   C = 1'b0;


I guess there is another silent question in your post, will the intermediate value cause events on 'C', the answer in this case is no. There will be no events produced by the always block till it finishes its execution (or till it hits a delay or starts waiting on an event). So, only the last value is relevant.

In a testbench code you can see a situation like that:

always @* begin
   C = A;
   C = B;
   #5 C = D;
end


In the above case The value of C will become B. The execution of the always block will stop for #5 delays. During that time other blocks will see the value B. In #5 ticks, the value will be changed to D.",,,,,
"I am writing a SystemVerilog Testbench for a module that models a schematic, but don't know why transcript window saying no connection to port Y?","The Following schematic is what I have modeled my module from. This is a SystemVerilog HW assignment in which we must use contiuous assignment(s). The signature model was given to us. Note there is no delays in the circuit. The problem I am having is that I don't really know what I am doing, for I am new to SystemVerilog and this is first time I have to write my own Testbench.
schematic to model

Here is the module code:

module hw2_prob1 (
  input logic A, B, C, D,
  output logic Y
);  

  assign Y = (~(A|D)) &amp; (B &amp; C &amp; ~D);


endmodule     


This is what I have for my testbench code so far:

timeunit 1ns/1ns;

module tb_hw2_prob1();
 reg A, B, C, D;
 wire Y;



hw2_prob1 DUT(A, B, C, D, Y);

initial begin
#5 {A,B,C,D} = 4'b0000;
#5 {A,B,C,D} = 4'b0001;
#5 {A,B,C,D} = 4'b0010;
#5 {A,B,C,D} = 4'b0011;

#5 {A,B,C,D} = 4'b0100;
#5 {A,B,C,D} = 4'b0101;
#5 {A,B,C,D} = 4'b0110;
#5 {A,B,C,D} = 4'b0111;

#5 {A,B,C,D} = 4'b1000;
#5 {A,B,C,D} = 4'b1001;
#5 {A,B,C,D} = 4'b1010;
#5 {A,B,C,D} = 4'b1011;

#5 {A,B,C,D} = 4'b1100;
#5 {A,B,C,D} = 4'b1101;
#5 {A,B,C,D} = 4'b1110;
#5 {A,B,C,D} = 4'b1111;
end

initial begin #500 $finish; 
end

initial begin $monitor ($time,""%h %b"", {A,B,C,D},Y);
end

endmodule


The assignment asks for 'The testbench for this circuit should set up a $monitor() statement in one initial block and generate all of the possible input combinations with a #5 ns delay between changing the inputs.'
We use QuestaSim or ModelSim for the simulations and here is the transcript and wave windows.
Snip of tb project window
Snip of wave window tb

Do I have to add a clock? Why does it say missing connection for port Y? Does my wave window seem correct?","hw2_prob1 DUT(Y, A, B, D); is missing C and has the wrong port order.

Pick one:


hw2_prob1 DUT(A, B, C, D, Y); // connect by port order
hw2_prob1 DUT(.Y(Y), .A(A), .(B), .C(C), .D(D) ); // explicit connect by port name
hw2_prob1 DUT( .Y, .A, .B, .C, .D ); // implicit connect by port name
hw2_prob1 DUT( .* ); // auto connect by port name
",,,,,
Why the vivado 2017.4 is showing error here?,"My code is:

module circuilar_fifo;
localparam B=3,W=2;
input wire clk,reset,wr,rd;
input wire [B-1:0] wr_data;
output wire [B-1:0] rd_data;
output wire full,empty;


Isn't this one of the correct method of declaring input outputs? But why does the Xilinx vivado 2017.4 webpack edition is showing that 


  port rd_data is not defined


Why is it showing like this? Where am I went wrong? I could've designed the code in

module circular_fifo(
input wire [B-1:0] wr_data;
input wire clk,reset
............
 );


But what is wrong in 1st coding design?","In the first style, the module header needs a list of port names thus:

module circular_fifo(clk, reset, wr, rd, rd_data, wr_data, full, empty);
",,,,,
VHDL casting a custom Type signed integer to a std_logic_vector,"Hi I have a signal that is used in many places and subject to being altered down the track. So to simplify maintenance I have made a TYPE declaration called T_RowInt.

I have made two signals ""typed"" and ""untyped"" which both equate to an integer range -63 to 63 to demonstrate the problem.

Code follows:

type T_RowInt is range -63 to 63;
signal typed : T_RowInt;
signal untyped : integer range -63 to 63;

signal text_col : integer range 0 to 127 := 0;
signal bank : std_logic_vector(2 downto 0) := ""111"";
signal page : std_logic_vector(3 downto 0) := ""0000"";


I use the above in the following expressions:

addr_r_dram(19 downto 0)&lt;= bank &amp; page &amp; std_logic_vector(to_unsigned(typed,6)) &amp; std_logic_vector(to_unsigned(text_col, 7));


This fails syntax checking with ""to_unsigned can not have such operands in this context""
However, this expression:

addr_r_dram(19 downto 0)&lt;= bank &amp; page &amp; std_logic_vector(to_unsigned(untyped,6)) &amp; std_logic_vector(to_unsigned(text_col, 7));


Is ok

Is there a way to force conversion of a custom TYPED signal?

Thanks

Mark","If you use type then you have defined a completely new type as far as VHDL is concerned. However, how about using a subtype, eg

subtype T_RowInt is integer range -63 to 63;


then VHDL will not consider T_RowInt as being a completely different type. Your signal untyped is actually using a subtype, a so-called _anonymous subtype`:

signal untyped : integer range -63 to 63;


Perhaps you can see the similarity between these two lines of code?",,,,,
Bidirectional constraint using the implication operator,"In the following code, if a==1, then b==0.  Because of bidirection, if b==0, then my understanding is that a should be 1.  However, the output is different from what I would expect.

class ex_sv;

rand bit a;
rand bit b;

constraint c {
   (a==1) -&gt; (b==0);
 }
endclass

module ex_mod;

ex_sv h = new();

initial begin
for( int i = 0; i&lt;10; i++ ) begin
 void'(h.randomize() with {b==0;});
 $display(""ITER : %0d a = %0d b = %0d"",i, h.a, h.b);
end
end

endmodule


xcelium&gt; run
ITER : 0 a = 0 b = 0
ITER : 1 a = 0 b = 0
ITER : 2 a = 1 b = 0
ITER : 3 a = 0 b = 0
ITER : 4 a = 0 b = 0
ITER : 5 a = 1 b = 0
ITER : 6 a = 1 b = 0
ITER : 7 a = 0 b = 0
ITER : 8 a = 1 b = 0
ITER : 9 a = 1 b = 0
xmsim: *W,RNQUIE: Simulation is complete.
","The implication operator a == 1 -&gt; b == 0 is logically equivalent to (a == 0 || b == 0) (from 18.5.6). 

if  b == 0 then the equation is already satisfied and a can take any value, still satisfying the constraint.

if you try to simulate with a == 0, then b can take any value.

You can experiment with a == 1 then the only way to satisfy the expression is if b == 0.",,,,,
A 4-bit counter D flip flop with + 1 logic,"
I am trying to implement this D flip-flop counter with + 1 logic through Verilog. Bu,t I'm getting a lot of error codes about multiple constant drivers for net. Can anyone give me a hand?  Here is the code so far:
module LAB (clk, clear, Enable, Q);

input clk, clear, Enable;   
    
output[3:0] Q; 
                
reg[3:0] Q;

wire D;

    
assign D = Q;
    
always @ (posedge clk)

begin

if (!clear)

Q &lt;= 1'b0;

else

Q &lt;= D;

end
    
always @ (Enable)

begin

if (Enable == 1)

Q &lt;= D + 1;

else
 
Q &lt;= D;

end 
    
endmodule

Here are the error codes I am getting:
Error (10028): Can't resolve multiple constant drivers for net &quot;Q[3]&quot; at 


LAB.v(17)
Error (10029): Constant driver at LAB.v(9)


Error (10028): Can't resolve multiple constant drivers for net &quot;Q[2]&quot; at LAB.v(17)


Error (10028): Can't resolve multiple constant drivers for net &quot;Q[1]&quot; at LAB.v(22)


Error (10028): Can't resolve multiple constant drivers for net &quot;Q[0]&quot; at LAB.v(22)


Error (12153): Can't elaborate top-level user hierarchy


Error: Quartus II 64-Bit Analysis &amp; Synthesis was unsuccessful. 6 errors, 4 warnings

Error: Peak virtual memory: 4613 megabytes


Error: Processing ended: Sun Apr 19 18:39:09 2020


Error: Elapsed time: 00:00:01


Error: Total CPU time (on all processors): 00:00:00


Error (293001): Quartus II Full Compilation was unsuccessful. 8 errors, 4 
warnings
","You have 2 different always blocks which drive the same register Q. you can think of a separate always block as a separate hardware device. So, in your case, you have 2 flop outputs of which are connected. This violates hardware and synthesis rules. It also creates issues during simulation.
The only way to fix it is to create a single always block which defines all logic needed to drive the flop, something like the following:
always @ (posedge clk or negedge clear) begin
    if (!clear)
        Q &lt;= 1'b0;
    else if (enable)
        Q &lt;= D + 1;
    else 
        Q &lt;= D;
end

I am not commenting on you logic here, just giving an example which should eliminate all errors around multiple drivers for Q.",,,,,
Having trouble in simulating data on verilog,"I made new question sheet for more details.
I'm designing some codes of data bus-system by using ideal SRAM and CPU. I want to write memory mem[0] -> IR, and read memory IR -> mem[1], and finally write memory mem[1] -> DR.

I think that dumping data on mem is not normal now because memory and dout value is coming out ZZZZ all times. Data on SRAMs aren't moving well. How can I fix this? 

module sram(addr,clk,din,dout,we);

parameter addr_width = 12, word_depth = 4096, word_width = 16;

input clk,we;
input [addr_width-1:0] addr;
input [word_width-1:0] din;
output [word_width-1:0] dout;


reg [word_width-1:0]mem[0:word_depth-1];
reg [word_width-1:0] dout;

always @(posedge clk) begin
    if(!we)
        mem[addr] &lt;= din[word_width-1:0];
    end

always @(posedge clk) begin

     dout[word_width-1:0] &lt;= mem[addr];
 end

endmodule




module cpu(clk,load,reset,select,ir,dr,ac,ar,pc,addr,we);

input clk,reset;
input [1:0]select;
input [1:0]load;

output reg[15:0] ir,dr,ac;
output reg[11:0] ar,pc;

input we;
input [11:0] addr;

reg[15:0] din;
wire[15:0] dout;

sram sram(addr,clk,din,dout,we);

always @ (posedge clk or negedge reset) begin
    if(!reset) begin
        ar &lt;= 12'b0;  ir &lt;= 16'b0;  pc &lt;= 12'b0;  dr &lt;= 16'b0;  ac &lt;= 16'b0;
    end

    if(select==2'b01 &amp;&amp; load==2'b01 &amp;&amp; we==1) //read
        ir[15:0] &lt;= dout[15:0];
    else if(select==2'b11 &amp;&amp; load==2'b10 &amp;&amp; we==0) //write
        din[15:0] &lt;= ir[15:0];
    else if(select==2'b10 &amp;&amp; load==2'b11 &amp;&amp; we==1) //read
        dr[15:0] &lt;= dout[15:0];
    end

endmodule




module tb_cpu();
parameter addr_width = 12, word_depth = 4096, word_width = 16;

reg clk,reset,we;
reg [1:0]select;
reg [1:0]load;
reg [addr_width-1:0] addr;
wire [word_width-1:0] ir,dr,ac;
wire [word_width-5:0] ar,pc;
integer file_pointer;
integer file_pointer2;

wire [word_width-1:0]mem[0:word_depth-1];
wire [word_width-1:0] dout;

cpu cpu(clk,load,reset,select,ir,dr,ac,ar,pc,addr,we);

always #5 clk = ~clk;

initial begin
    clk = 0; we = 0; reset = 1;
    #2 reset = 0; 
    #2 reset = 1;

    file_pointer = $fopen(""reg.dat"");
    file_pointer2 = $fopen(""memory.dat"");

    $readmemb(""sram.dat"", tb_cpu.cpu.sram.mem);

    #10 select = 2'b01; load = 2'b01; we = 1; addr = 12'b000000000000; //cycle 1
    #10 select = 2'b11; load = 2'b10; we = 0; addr = 12'b000000000001; //cycle 2
    #10 select = 2'b10; load = 2'b11; we = 1; addr = 12'b000000000001; //cycle 3

    $fdisplay(file_pointer, ""AR = %b"", tb_cpu.cpu.ar);
    $fdisplay(file_pointer, ""IR = %b"", tb_cpu.cpu.ir);
    $fdisplay(file_pointer, ""PC = %b"", tb_cpu.cpu.pc);
    $fdisplay(file_pointer, ""DR = %b"", tb_cpu.cpu.dr);
    $fdisplay(file_pointer, ""AC = %b"", tb_cpu.cpu.ac);

    $fdisplay(file_pointer2, ""mem[0000 0000 0000] = %b"",tb_cpu.cpu.sram.mem[000000000000]);
    $fdisplay(file_pointer2, ""mem[0000 0000 0001] = %b"",tb_cpu.cpu.sram.mem[000000000001]);
    $fdisplay(file_pointer2, ""mem[0000 0000 0010] = %b"",tb_cpu.cpu.sram.mem[000000000010]);

     $fclose(file_pointer);
     $fclose(file_pointer2);

    #10 $finish;
end    
endmodule
","I think the reason is that you need 2 clock cycles to propagate mem-&gt;dout-&gt;ir. 

In your case sram reads dout at posedge clk. At the same posedge you push its value into ir. But hardware and simulation push the old value of dout which was xxx.... You need to give it more time to settle down. So, if you use #20 instead of #10 in your test bench, you should see different results.",,,,,
How do we write a particular C code for a square wave converter? Or what is the logic for that?,"I want to write a c code for square wave converter for some calculation purposes.But I don't have any idea about c code logic for a square wave . 
Please suggest me any logic which can help me to write a c code for the square wave converter.  ","A square wave is the easiest, after all its either high or low, on or off, true of false.

If you're wanting to output a square wave then just toggle an output on your FPGA (if that is what this is) in relation to a timer.

If you're converting an analogue signal to a square wave then you'll need to test against a value, that you set, below which your output is low and above which your output high.

This is the basis of digitizing an analogue signal. ",,,,,
Is there a way to create a loop inside a case statement on vhdl?,"I would like to know if there is a way to create a loop inside a case statement in vhdl.

Currently I have this code

    CASE A1 IS 
        WHEN ""00000"" =&gt; RD1 &lt;= REG0;
        WHEN ""00001"" =&gt; RD1 &lt;= REG1;
        WHEN ""00010"" =&gt; RD1 &lt;= REG2;
        WHEN ""00011"" =&gt; RD1 &lt;= REG3;
        WHEN ""00100"" =&gt; RD1 &lt;= REG4;
        WHEN ""00101"" =&gt; RD1 &lt;= REG5;
        WHEN ""00110"" =&gt; RD1 &lt;= REG6;
        WHEN ""00111"" =&gt; RD1 &lt;= REG7;
        WHEN ""01000"" =&gt; RD1 &lt;= REG8;
        WHEN ""01001"" =&gt; RD1 &lt;= REG9;
        WHEN ""01010"" =&gt; RD1 &lt;= REG10;
        WHEN ""01011"" =&gt; RD1 &lt;= REG11;
        WHEN ""01100"" =&gt; RD1 &lt;= REG12;
        WHEN ""01101"" =&gt; RD1 &lt;= REG13;
        WHEN ""01110"" =&gt; RD1 &lt;= REG14;
        WHEN ""01111"" =&gt; RD1 &lt;= REG15;
        WHEN ""10000"" =&gt; RD1 &lt;= REG16;
        WHEN ""10001"" =&gt; RD1 &lt;= REG17;
        WHEN ""10010"" =&gt; RD1 &lt;= REG18;
        WHEN ""10011"" =&gt; RD1 &lt;= REG19;
        WHEN ""10100"" =&gt; RD1 &lt;= REG20;
        WHEN ""10101"" =&gt; RD1 &lt;= REG21;
        WHEN ""10110"" =&gt; RD1 &lt;= REG22;
        WHEN ""10111"" =&gt; RD1 &lt;= REG23;
        WHEN ""11000"" =&gt; RD1 &lt;= REG24;
        WHEN ""11001"" =&gt; RD1 &lt;= REG25;
        WHEN ""11010"" =&gt; RD1 &lt;= REG26;
        WHEN ""11011"" =&gt; RD1 &lt;= REG27;
        WHEN ""11100"" =&gt; RD1 &lt;= REG28;
        WHEN ""11101"" =&gt; RD1 &lt;= REG29;
        WHEN ""11110"" =&gt; RD1 &lt;= REGZLO;
        WHEN ""11111"" =&gt; RD1 &lt;= REGZHI;
        WHEN OTHERS =&gt; RD1 &lt;= (OTHERS =&gt; '0');
     END CASE; 


As you can see the only thing that changes from one statement to the next is the number of the REG asigned to RD1. Couldn't the fact that it always matches the value of A1 (except on the last 2 cases but those can be done separately) be used to make a loop so that all the statements don't have to be written?

Thank you.","
  Is there a way to create a loop inside a case statement


No, you can not, at least not in the way I think you want to do it.

It would not make sense because if you can use a loop you can use the loop variable as selector/index or you can derive the value from it. 

A case is intended for non-regular and/or sparse selection.



You can of course place a loop inside a case like this:

WHEN ""01100"" =&gt; for ...


But I am pretty sure that is not what you where referring to.",,,,,
Quartus Prime throwing an error at a $error command,"I am having a problem with the following code which should simply throw an error at compilation
if my number of inputs is not divisible by my number of outputs.

module multiplexer #(parameter N_INPUTS, parameter N_OUTPUTS) (in, out, select);

    generate
        if (N_INPUTS % N_OUTPUTS != 0) begin
            $error(""%m ** Illegal Parameter ** NUMBER OF INPUTS(%d) does not divide into NUMBER OF OUTPUTS(%d)"", N_INPUTS, N_OUTPUTS);
        end
    endgenerate

    input wire [N_INPUTS-1:0] in;
    input wire [$clog2(N_INPUTS/N_OUTPUTS) - 1:0] select;
    output wire [N_OUTPUTS-1:0] out;

    always @ (select, in) begin
        out = in[(select + 1) * N_OUTPUTS - 1:(select + 1) * N_OUTPUTS - N_OUTPUTS];
    end

endmodule


But Quartus keep throwing me this error when I proceed to an Analysis:

Error (10170): Verilog HDL syntax error at multiplexer.v(5) near text: ""$error"";  expecting ""end"". Check for and fix any syntax errors that appear immediately before or at the specified keyword. The Intel FPGA Knowledge Database contains many articles with specific details on how to resolve this error. Visit the Knowledge Database at https://www.altera.com/support/support-resources/knowledge-base/search.html and search for this specific error message number.


I am beginning to wonder wether or not the compiler of Quartus supports the $error command (it's my first time using it).

I would greatly appreciate any help on the subject since I am still a beginner in the domain :)","Close your Quartus project and in the .qsf file, change the line pointing to your multiplexer module verilog file from:

set_global_assignment -name VERILOG_FILE multiplexer.v


To:

set_global_assignment -name SYSTEMVERILOG_FILE multiplexer.v


Edit:

Also set: 

set_global_assignment -name VERILOG_INPUT_VERSION SYSTEMVERILOG_2009


Edit 2:

It's a SystemVerilog 2009 feature and Quartus Prime Standard and Quartus Prime Lite don't support VHDL 2008 or SystemVerilog 2009. 

Quartus Prime Pro 19.4:



Quartus Prime Standard 19.1:

",,,,,
Multiple bits gates,"I'd like to know how I could go about using AND, OR and other gates for multiple bits inputs. I was trying to build a 2:1 MUX but I got this error:

Expression width 2 does not match width 1 of logic gate array port 1.

Here's the code

module mux_21 #(parameter width = 1) (
    input [width-1:0] d0, d1,
    input s,
    output [width-1:0] y
);
    wire [width-1:0] ns, y1, y2;
    not  g1 (ns, s);
    and  g2 (y1, d0, ns);
    and  g3 (y2, d1, s);
    or   g4 (y, y1, y2);
endmodule
","Primitive gates are always single bit. You need to create instance for each bit combination.

The most common way to is with a generate for-loop. Generate logic goes through static unrolled during the elaboration phase of compile.

genvar gidx;
wire ns;
wire [width-1:0] y1, y2;
not  g1 (ns, s);
generate
  for(gidx=0; gidx&lt;width; gidx=gidx+1) begin : mux
    and  g2 (y1[gidx], d0[gidx], ns );
    and  g3 (y2[gidx], d1[gidx], s );
    or   g4 (y[gidx], y1[gidx], y2[gidx] );
  end
endgenerate


You could also create a range of instances. This is a feature that has existed longer then the generate construct but less commonly used and I notices some synthesizers don't support it (ex Yosys 0.9 on EDAplayground).

wire ns;
wire [width-1:0] y1, y2;
not  g1 (ns, s);
and  g2 [width-1:0] (y1, d0, ns);
and  g3 [width-1:0] (y2, d1, s);
or   g4 [width-1:0] (y, y1, y2);
",,,,,
Static Variable Usage In C Adress different,"I have a header file where I have declared a structure and declared it as

static Test_t = TESTID;

Have multiple files in the project and files has multiple functions. And want to update these variables from different files and functions. So have tried to get the address of this static variable inside each function like  

Test_t *info = &amp;TESTID;


Update it as info-&gt; ...

But the address of info are different in functions?
 What could be the reason?","One of the main reasons of using static in the first place, is to make a variable local to the scope where it is declared. If you declare it at file scope (outside all functions), then it is local to the translation unit where it was declared. A translation unit means a .c file and all .h files that the .c file includes.

Meaning that if you have a static variable in foo.h, then #include ""foo.h"" from foo.c and bar.c, then you will end up with two different local copies of that variable: one inside the translation unit foo.h + foo.c, and another inside the translation unit foo.h + bar.c.

The solution is to never declare any variables inside header files. In addition to strange hiccups like the one described above, you can also run into various linker errors.

One sensible solution is to have the static Test_t test = TESTID; inside test.c only. Then make setter and getter functions from test.h that other functions will use to access the variable. 

The struct declaration can be placed in test.h if the getters return copies or const pointers and other files should be allowed to access members directly. Or rather, that's fine for simpler stuff, but not recommended for more complex ADTs that should use proper private encapsulation.

(The only drawback with such a design is that it isn't thread-safe unless you implement thread safety inside the setter/getters, but that's another story.)",,,,,
for generate with conditional logic,"I am implementing the following module: 

library ieee;
use ieee.std_logic_1164.all;

entity Grant_Logic is
    generic (
        N : positive := 4
    );
    Port (
        Priority_Logic0 :   in std_logic_vector(N-1 downto 0);
        Priority_Logic1 :   in std_logic_vector(N-1 downto 0);
        Priority_Logic2 :   in std_logic_vector(N-1 downto 0);
        Priority_Logic3 :   in std_logic_vector(N-1 downto 0);
        Gnt             :   out std_logic_vector (N-1 downto 0)
    );
end Grant_Logic;

architecture Behavioral of Grant_Logic is

begin

    gnt(0) &lt;= Priority_Logic0(0) or Priority_Logic1(3) or Priority_Logic2(2) or Priority_Logic3(1);
    gnt(1) &lt;= Priority_Logic0(1) or Priority_Logic1(0) or Priority_Logic2(3) or Priority_Logic3(2);
    gnt(2) &lt;= Priority_Logic0(2) or Priority_Logic1(1) or Priority_Logic2(0) or Priority_Logic3(3);
    gnt(3) &lt;= Priority_Logic0(3) or Priority_Logic1(2) or Priority_Logic2(1) or Priority_Logic3(0);

end Behavioral;


I want to take advantage of for ... generate to implement the same circuit when N changes. I am using Xilinx so Vivado (vhdl'93) does not support custom types for ports in the IP generation. 
However, for the architecture I would like to use for ... generate. The issue is that some logic is needed to generate each bit of gnt. What I have so far is:

gen_gnt_vertical: for y in 0 to N-1 generate 
    constant val, index : integer := 0;
    begin
    s_result &lt;= '0';
    gen_gnt_horizontal: for x in 0 to N-1 generate
        begin
             LOGIC BASED ON val, x and y to obtain the index
             s_result &lt;= s_result or s_Priority_Logic(x)(index);
    end generate;
    gnt(y) &lt;= s_result;        
end generate;


The logic to compute index is: 

    if(x&gt;0)
    {
        val = y - x;
        if (val &lt; 0)
        {
            index = N + val;
        }
        else
            index = val;
    }
    else
    {
        index = y;
    }


I have a script that generates a vhdl file based on N but I would like to do it directly on vhdl. Is that possible?

Thanks for the help

EDIT: As @Tricky replied, a function did the trick. So, I have the following:

function index( N, x,y : natural) return natural is
    variable val     : integer;
    variable index : integer := 0; 
    begin                   
        if(x&gt;0) then
            val := y - x;
            if(val &lt; 0) then
                index := N + val;
            else
                index := val;
            end if;    
        else
            index := y;
        end if;
    return index;
end function;


And the architecture:

architecture Behavioral of Grant_Logic is
    signal s_Priority_Logic : t_Priority_logic;
    signal s_result : std_logic_vector(N-1 downto 0) := (others=&gt;'0');
begin

    s_Priority_Logic(0) &lt;= Priority_Logic0;
    s_Priority_Logic(1) &lt;= Priority_Logic1;
    s_Priority_Logic(2) &lt;= Priority_Logic2;
    s_Priority_Logic(3) &lt;= Priority_Logic3;


    process(s_Priority_Logic)
        variable result : std_logic;
    begin
        for y in 0 to N-1 loop
            result := '0';
            for x in 0 to N-1 loop
                result := result or s_Priority_logic(x)(index(N, x, y));
            end loop;
            gnt_g(y) &lt;= result;
        end loop;
    end process;   

end Behavioral;
",@Tricky using a function was the correct thing to get the index value. Alo for generate was not correct but for loop. I edited my question to show the final result,,,,,
Issue in writing a RTL logic,"Lets suppose that I have a bus B. I want to create a new bus C whose signals are delayed by a magnitude proportional to their index if the corresponding index of B is 1. Let me explain this with an example lets say my original bus B (of width 5) is having a value 10111 and B stays at this value forever. Now I want C to be like this:

clk 0: 00001
clk 1: 00011
clk 2: 00111
clk 3: 10111


(Note that 3rd bit is a 0 in bus B, hence after bit position 2 its the MSB of C (bit position 4) that should be high in the very next clock).

Below shown is the corresponding waveform.


B[0] ,,,|'''''''''''''''''''''''''''''''''
B[1] ,,,|'''''''''''''''''''''''''''''''''
B[2] ,,,|'''''''''''''''''''''''''''''''''
B[3] ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
B[4] ,,,|'''''''''''''''''''''''''''''''''

clk   ,,|''|,,|''|,,|''|,,|''|,,|''|,,|''|

C[0] ,,,|'''''''''''''''''''''''''''''''''
C[1] ,,,,,,,,,|'''''''''''''''''''''''''''
C[2] ,,,,,,,,,,,,,,,|'''''''''''''''''''''
C[3] ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
C[4] ,,,,,,,,,,,,,,,,,,,,,,|''''''''''''''


How can I model this in synthesizable RTL logic using systemverilog and always block.I am looking for something similar to this(This is just a pseuocode):

Logic[width-1:0][width-1:0] temp;
logic hit_zero; //This is a variable seen and modified by all the generated always blocks(I am not sure if that's allowed)
generate
   for (genvar i = 0; i &lt; width; i++) begin
        always @(posedge clk) begin
              if (B[i] == 1) begin
                 temp[i] &lt;= temp[i] &lt;&lt; i;
                 if (hit_zero) begin
                   temp[i] &lt;= temp[i] &lt;&lt; (pos+1);
                   hit_zero &lt;= 0;
                 end
                 pos &lt;= i;
              end else begin
                 temp[i] &lt;= temp[i] &lt;&lt; i;
                 hit_zero &lt;= 1;  
              end
              temp[i][0] &lt;= B[i];
        end
   end
  endgenerate
  generate 
   for (genvar i = 0; i &lt; width; i++) begin 
    assign C[i] = temp[i][i];
   end
  endgenerate

","I have come up with an example of a single always block which seems to do the part which you want, at least in simulation. It should be synthesizable, though i did not try it. It expects a reset signal to set up initial values. So, you can try to use it as a base for your exploration.

It needs pos to point to the current bit position, which gets incremented based on the bit state of the B (incr).

done is needed to make the loop synthesizable. 

  logic clk, reset;
  logic [4:0] B,C;

  reg[4:0]creg;
  int pos;
  int incr;
  bit done;

  always @(posedge clk) begin
    if (reset) begin
      pos &lt;= 0;
      creg &lt;= 0;
    end
    else begin
      incr = 0;
      done = 0;
      for (int i = 0; i &lt; 5; i++) begin
        if (!done &amp;&amp; i &gt;= pos) begin
          incr++;
          creg[i] &lt;= B[i];
          if (B[i])
            done = 1;
        end
      end
      pos &lt;= pos + incr;
    end
  end

  assign C = creg;
",,,,,
Simulation Failed: Transactions not in Ascending Order GHDL,"I'm trying to run a testbench and when I attempt to run the simulation I get the following error:

./rc_symbols_testbench:error: transactions not in ascending order
./rc_symbols_testbench:error: simulation failed
msf_symbols.vhd rc_symbols_testbench.vhd


A reduced version of the testbench that still produces the error:
library IEEE;

use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use STD.textio.all;
use IEEE.std_logic_textio.all;

entity rc_symbols_testbench is
end;

architecture impl of rc_symbols_testbench is

    subtype byte is std_logic_vector(7 downto 0);
    constant byte_null: byte := (others =&gt; '0');
    constant byte_unknown: byte := (others =&gt; 'X');

    constant clk_freq:   integer := 25500;
    constant clk_period: time      := (1 / (clk_freq))*sec;
    constant gate_delay: time      := 0.1 ns;
    constant t_sample:   time      := 100 ms;
        
    signal   eod:         std_logic                       :=            '0';
    signal   clk:         std_logic                       :=            '0';
    signal   rst:         std_logic                       :=            '0';
    signal   dcf_tro:     std_logic                       :=            '0';
    

begin

    process
    begin
    
        while eod = '0' loop
            clk &lt;= not clk;
            --wait for clk_period / 2;
            wait for 19.60784314 us; --19.6us approx = clock period / 2
        end loop;
        
        wait;
    end process;
    
    rst &lt;= '1', '0' after 150 ms;

    process
        file     data_file:   text;
        variable data_line:   line;
        variable dcf_do_var:  byte;
        variable dcf_tro_var: std_logic;
        variable dcf_so_var:  std_logic;
        variable msf_do_var:  byte;
        variable msf_tro_var: std_logic;
        variable msf_so_var:  std_logic;
        variable t_var:       time;
    begin
        file_open(data_file, &quot;rc_symbols.dat&quot;, read_mode);

        while not endfile(data_file) loop
            readline(data_file, data_line);

            hread(data_line, dcf_do_var);
             read(data_line, dcf_so_var);
             read(data_line, dcf_tro_var);
            hread(data_line, msf_do_var);
             read(data_line, msf_so_var);
             read(data_line, msf_tro_var);

             read(data_line, t_var);

            if t_var &gt; now then
                wait for t_var - now;
            end if;

           
            dcf_tro &lt;= dcf_tro_var, '0' after clk_period;
           

        end loop;
        
        file_close(data_file);
        eod &lt;= '1';
        wait;
    end process;

end;

I've also reduced rc_symbols.dat to:
00 0 0 FF 0 1 1736901.960861734 us
00 0 0 FF 0 0 1736941.176548008 us
0C 0 1 FF 0 0 1754705.88243013 us
0C 0 0 FF 0 0 1754745.098116404 us
0C 0 0 31 0 1 1837019.607919256 us
0C 0 0 31 0 0 1837058.82360553 us
00 0 1 31 0 0 1854823.529487652 us
00 0 0 31 0 0 1854862.745173926 us
00 0 0 00 0 1 1937137.254976778 us
00 0 0 00 0 0 1937176.470663052 us
00 0 1 00 0 0 1954901.9608589 us
00 0 0 00 0 0 1954941.176545174 us
00 0 0 00 0 1 2037215.686348026 us
00 0 0 00 0 0 2037254.9020343 us
00 0 1 00 0 0 2055019.607916422 us
00 0 0 00 0 0 2055058.823602696 us
00 0 0 00 0 1 2137333.333405548 us
00 0 0 00 0 0 2137372.549091822 us
00 0 1 00 0 0 2155137.254973944 us

To me, it looks like everything's in ascending order so I'm still not sure.

If I comment out this, it simulates, but I'm not sure how to fix the error:
dcf_tro &lt;= dcf_tro_var, '0' after clk_period;
","Thanks to user1155120 for the helpful comments.

The issue lay in the fact that:

constant clk_period: time      := (1 / (clk_freq))*sec;


was evaluating in such a way that it caused a zero or negative delay. Substituting this line for:

constant clk_period: time      := 39.2157 us;


fixed the issue.",,,,,
VHDL synthesis: connected to following multiple drivers,"I wrote this code for a reservation station:

Library ieee;
use ieee.std_logic_1164.all;

entity RS_unit is
  port(clk: in std_logic;
       reset: in std_logic;  
       wr_enable1: in std_logic;
       instr1: in std_logic_vector(15 downto 0);
       instr1_tag: in std_logic_vector( 4 downto 0);
       I1_opr1: in std_logic_vector(15 downto 0);
       I1_valid1: in std_logic;
       I1_opr2: in std_logic_vector(15 downto 0);
       I1_valid2: in std_logic;

       wr_enable2: in std_logic;
       instr2: in std_logic_vector(15 downto 0);
       instr2_tag: in std_logic_vector( 4 downto 0);
       I2_opr1: in std_logic_vector(15 downto 0);
       I2_valid1: in std_logic;
       I2_opr2: in std_logic_vector(15 downto 0);
       I2_valid2: in std_logic;

       full: out std_logic;


       wb_tag1: in std_logic_vector( 4 downto 0);
       wb_data1: in std_logic_vector(15 downto 0);

       wb_tag2: in std_logic_vector( 4 downto 0);
       wb_data2: in std_logic_vector(15 downto 0);

       disp1_opcode: out std_logic_vector(3 downto 0);
       disp1_info: out std_logic_vector(3 downto 0);
       disp1_opr1: out std_logic_vector(15 downto 0);
       disp1_opr2: out std_logic_vector(15 downto 0);
       disp1_tag: out std_logic_vector( 4 downto 0);

       disp2_opcode: out std_logic_vector(3 downto 0);
       disp2_info: out std_logic_vector(3 downto 0);
       disp2_opr1: out std_logic_vector(15 downto 0);
       disp2_opr2: out std_logic_vector(15 downto 0);
       disp2_tag: out std_logic_vector( 4 downto 0));

end RS_unit;



architecture RS_arch of RS_unit is

 type reservation_entry is record
    free: std_logic;
    tag: std_logic_vector( 4 downto 0);
    op_code: std_logic_vector(3 downto 0);
    op_info: std_logic_vector(3 downto 0);
    opr1: std_logic_vector(15 downto 0);
    valid1: std_logic;
    opr2: std_logic_vector(15 downto 0);
    valid2: std_logic;
  end record;

  type reservation_array is array(0 to 7) of reservation_entry;


signal RS: reservation_array;
signal I1_index: integer:=0;
signal I2_index: integer:=0;

signal disp1_index: integer:=0;
signal disp2_index: integer:=0;

begin


  --priority selector
  --to select first free entry
  I1_index&lt;=0 when RS(0).free='1' else
            1 when RS(1).free='1' else
            2 when RS(2).free='1' else
            3 when RS(3).free='1' else
            4 when RS(4).free='1' else
            5 when RS(5).free='1' else
            6 when RS(6).free='1' else
            7 when RS(7).free='1' else
            8;
  --added the I1_index condition to avoid conflicts             
  I2_index&lt;=0 when RS(0).free='1' and not(I1_index=0) else
            1 when RS(1).free='1' and not(I1_index=1) else
            2 when RS(2).free='1' and not(I1_index=2) else
            3 when RS(3).free='1' and not(I1_index=3) else
            4 when RS(4).free='1' and not(I1_index=4) else
            5 when RS(5).free='1' and not(I1_index=5) else
            6 when RS(6).free='1' and not(I1_index=6) else
            7 when RS(7).free='1' and not(I1_index=7) else
            8;



  --used to search dispachable entries
  --use same method as above
 disp1_index&lt;=0 when RS(0).valid1='1' and RS(0).valid2='1' and RS(0).free='0' else
              1 when RS(1).valid1='1' and RS(1).valid2='1' and RS(1).free='0' else
              2 when RS(2).valid1='1' and RS(2).valid2='1' and RS(2).free='0' else
              3 when RS(3).valid1='1' and RS(3).valid2='1' and RS(3).free='0' else
              4 when RS(4).valid1='1' and RS(4).valid2='1' and RS(4).free='0' else
              5 when RS(5).valid1='1' and RS(5).valid2='1' and RS(5).free='0' else
              6 when RS(6).valid1='1' and RS(6).valid2='1' and RS(6).free='0' else
              7 when RS(7).valid1='1' and RS(7).valid2='1' and RS(7).free='0' else
              8;



 disp2_index&lt;=0 when RS(0).valid1='1' and RS(0).valid2='1' and RS(0).free='0' and disp1_index/=0 else
              1 when RS(1).valid1='1' and RS(1).valid2='1' and RS(1).free='0' and disp1_index/=1 else
              2 when RS(2).valid1='1' and RS(2).valid2='1' and RS(2).free='0' and disp1_index/=2 else
              3 when RS(3).valid1='1' and RS(3).valid2='1' and RS(3).free='0' and disp1_index/=3 else
              4 when RS(4).valid1='1' and RS(4).valid2='1' and RS(4).free='0' and disp1_index/=4 else
              5 when RS(5).valid1='1' and RS(5).valid2='1' and RS(5).free='0' and disp1_index/=5 else
              6 when RS(6).valid1='1' and RS(6).valid2='1' and RS(6).free='0' and disp1_index/=6 else
              7 when RS(7).valid1='1' and RS(7).valid2='1' and RS(7).free='0' and disp1_index/=7 else
              8;


  --CAM on 2 WB ports
  --check both operands for each input tag
  --if data is not valid and tags match
  --replace with proper data and set valid bit
  CAM1: for i in 0 to 7 generate
    RS(i).valid1&lt;='1' when (RS(i).valid1='0' and RS(i).opr1(4 downto 0)=wb_tag1) else RS(i).valid1;
    RS(i).opr1&lt;=wb_data1 when (RS(i).valid1='0' and RS(i).opr1(4 downto 0)=wb_tag1) else RS(i).opr1;

    RS(i).valid2&lt;='1' when (RS(i).valid2='0' and RS(i).opr2(4 downto 0)=wb_tag1) else RS(i).valid2;
    RS(i).opr2&lt;=wb_data1 when (RS(i).valid2='0' and RS(i).opr2(4 downto 0)=wb_tag1) else RS(i).opr2;
  end generate;

  CAM2: for j in 0 to 7 generate
    RS(j).valid1&lt;='1' when (RS(j).valid1='0' and RS(j).opr1(4 downto 0)=wb_tag2) else RS(j).valid1;
    RS(j).opr1&lt;=wb_data1 when (RS(j).valid1='0' and RS(j).opr1(4 downto 0)=wb_tag2) else RS(j).opr1;

    RS(j).valid2&lt;='1' when (RS(j).valid2='0' and RS(j).opr2(4 downto 0)=wb_tag2) else RS(j).valid2;
    RS(j).opr2&lt;=wb_data1 when (RS(j).valid2='0' and RS(j).opr2(4 downto 0)=wb_tag2) else RS(j).opr2;
  end generate;


  --set the full bit directly if any of the two intructions does not find a place
  --this is when we stall at the decode stage
  --whe the reservation station is full
  full&lt;='1' when(I1_index=8 or I2_index=8)  else '0';

pipe: process
begin
  wait until clk'event and clk='1';
  if(reset='1') then
    for i in 0 to 7 loop
      RS(i).free&lt;='1';
    end loop;
  else
  --write the instruction in the proper entry in the RS
  if(wr_enable1='1' and not(I1_index=8) ) then
    RS(I1_index).free&lt;='0';
    RS(I1_index).tag&lt;=instr1_tag;
    RS(I1_index).op_code&lt;=instr1(15 downto 12);
    RS(I1_index).op_info&lt;=instr1(3 downto 0);
    RS(I1_index).opr1&lt;=I1_opr1;
    RS(I1_index).valid1&lt;=I1_valid1;
    RS(I1_index).opr2&lt;=I1_opr2;
    RS(I1_index).valid2&lt;=I1_valid2;
  end if;


  if(wr_enable2='1' and not(I2_index=8)) then
    RS(I2_index).free&lt;='0';
    RS(I2_index).tag&lt;=instr2_tag;
    RS(I2_index).op_code&lt;=instr2(15 downto 12);
    RS(I2_index).op_info&lt;=instr2(3 downto 0);
    RS(I2_index).opr1&lt;=I2_opr1;
    RS(I2_index).valid1&lt;=I2_valid1;
    RS(I2_index).opr2&lt;=I2_opr2;
    RS(I2_index).valid2&lt;=I2_valid2;
  end if;

  --This is a 2 wide superscalar hence we need to sipatch 2 instructions

  --dispatch 1
  if(disp1_index/=8) then
    disp1_opcode&lt;=RS(disp1_index).op_code;
    disp1_info&lt;=RS(disp1_index).op_info;
    disp1_opr1&lt;=RS(disp1_index).opr1;
    disp1_opr2&lt;=RS(disp1_index).opr2;
    disp1_tag&lt;=RS(disp1_index).tag;
    RS(disp1_index).free&lt;='1';
  end if;

  --dispatch 2
  if(disp2_index/=8) then
    disp2_opcode&lt;=RS(disp2_index).op_code;
    disp2_info&lt;=RS(disp2_index).op_info;
    disp2_opr1&lt;=RS(disp2_index).opr1;
    disp2_opr2&lt;=RS(disp2_index).opr2;
    disp2_tag&lt;=RS(disp2_index).tag;
    RS(disp2_index).free&lt;='1';
  end if;
end if;
end process;

end RS_arch;


but when i run synthesis it generates this error:

ERROR:HDLCompiler:1401 - ""D:\the wisso files\AUB\EECE 421\Fall 2013-2014\CPU_SYNTH\rs.vhd"" Line 72: Signal RS[0]_opr1[15] in unit RS_unit is connected to following multiple drivers:


cant seem to see where are the multiple drivers.

I am using xilinx for synthesis

the Idea of the project is to design a 2 wide superscalar with out of order execution
I finished all of the units now i am working on the top level design and I just started using xilinx with it.

I used before but on much simpler projects.

any ideas?","The CAM1 and CAM2 blocks are both driving RS(0) through RS(7). In fact, they appear identical. Are they supposed to operate serially? If so, you need to define an intermediate signal to use as the output of CAM1 and the input of CAM2.",,,,,
LPC FMC to FPGA pin mapping on the Zedboard,"Does anybody know anything about how to map fpga pins to actual physical pin on the FMC connector on a Zedboard? 

Of course I have looked into the user's hardware guide and the master constraint file, but all I have found id a list of the FMC pins out on the FPGA side but nothing on how it is mapped to the LPC FMC pins.","Problem solved. Though there is no table, you can find this info on the schematics. Check the schematic of the FMC on:

http://zedboard.org/sites/default/files/documentations/ZedBoard_RevD.2_Schematic_130516.pdf

and match the pins with the labels in the master UCF file.",,,,,
VHDL: signal cannot be synthesized,"I am very new to VHDL and trying to write code for a project at school. What I want is to have a one dimensional pong game using the LEDs to act as the ball. Note that I do not have a structured understanding of VHDL, I wrote the following code by looking up state machine designs in VHDL and tried to come up with my own. I have an asynchronous RESET and two asynchronous inputs corresponding to the button presses of each player to return the ball. They are asynchronous because I want the players to be able to return the ball even if the button is pressed for a very short time during a clock cycle.

In Xilinx 10.1, simulation runs just the way I want but when I try to synthesise, this is the error I get for the following code:

ERROR:Xst:827 - ""C:/Users/Emre/LED_pong/pong.vhd"" line 49: Signal present_state cannot be synthesized, bad synchronous description. The description style you are using to describe a synchronous element (register, memory, etc.) is not supported in the current software release.


When I remove the elsif statements containing PAD1 and PAD2, it synthesizes, but loses its functionality.

entity pong is
Port ( CLK : in  STD_LOGIC;
       RST : in  STD_LOGIC;
       PAD1 : in  STD_LOGIC;
       PAD2 : in  STD_LOGIC;
       LEDS : out  STD_LOGIC_VECTOR (7 downto 0));
end pong;

architecture Behavioral of pong is

type state is ( P1_SERVE, A1, A2, A3, A4, A5, A6, A7,
                     B0, B1, B2, B3, B4, B5, B6, P2_SERVE,
                     WAIT_FOR_P1, WAIT_FOR_P2, P1_HIT_EARLY, P2_HIT_EARLY,
               P1_SCORED, P2_SCORED );
signal present_state: state;
signal temp : STD_LOGIC_VECTOR (7 downto 0) := ""00000000"";

begin

process (CLK, RST, PAD1, PAD2) begin

    if (RST = '1') then
        temp &lt;= ""10000000"";
        present_state &lt;= P1_SERVE;

    elsif (rising_edge(CLK)) then
        case present_state is

            when P1_SERVE =&gt;
                temp &lt;= ""10000000"";
            when P2_SERVE =&gt;
                temp &lt;= ""00000001"";

            when P1_SCORED =&gt;
                temp &lt;= ""00000000"";
           present_state &lt;= P2_SERVE;
            when P2_SCORED =&gt;
           temp &lt;= ""00000000"";
           present_state &lt;= P1_SERVE;

            when A1 =&gt;
                temp &lt;= ""01000000"";
                present_state &lt;= A2;
            when A2 =&gt;
                temp &lt;= ""00100000"";
                present_state &lt;= A3;
            when A3 =&gt;
                temp &lt;= ""00010000"";
                present_state &lt;= A4;
            when A4 =&gt;
                temp &lt;= ""00001000"";
                present_state &lt;= A5;
            when A5 =&gt;
                temp &lt;= ""00000100"";
                present_state &lt;= A6;
            when A6 =&gt;
                temp &lt;= ""00000010"";
           present_state &lt;= A7;
            when A7 =&gt;
                temp &lt;= ""00000001"";
           present_state &lt;= WAIT_FOR_P2;
        when WAIT_FOR_P2 =&gt;
           temp &lt;= ""00000000"";
           present_state &lt;= P2_SERVE;

            when B6 =&gt;
                temp &lt;= ""00000010"";
                present_state &lt;= B5;
            when B5 =&gt;
                temp &lt;= ""00000100"";
                present_state &lt;= B4;
            when B4 =&gt;
                temp &lt;= ""00001000"";
                present_state &lt;= B3;
            when B3 =&gt;
                temp &lt;= ""00010000"";
                present_state &lt;= B2;
            when B2 =&gt;
                temp &lt;= ""00100000"";
                present_state &lt;= B1;
            when B1 =&gt;
                temp &lt;= ""01000000"";
           present_state &lt;=  B0;
            when B0 =&gt;
                temp &lt;= ""10000000"";
           present_state &lt;= WAIT_FOR_P1;
        when WAIT_FOR_P1 =&gt;
           temp &lt;= ""00000000"";
           present_state &lt;= P1_SERVE;

            when P1_HIT_EARLY =&gt;
                temp &lt;= ""10000000"";
                present_state &lt;= P2_SCORED;
            when P2_HIT_EARLY =&gt;
                temp &lt;= ""00000001"";
                present_state &lt;= P1_SCORED;

        when others =&gt;
           null;
        end case;

  elsif (PAD1 = '1') then
     case present_state is 
        when P1_SERVE =&gt;
           present_state &lt;= A1;
        when B0 =&gt;
           present_state &lt;= P1_HIT_EARLY;
        when WAIT_FOR_P1 =&gt;
           present_state &lt;= A1;
        when others =&gt;
           null;    
     end case;

    elsif (PAD2 = '1') then
        case present_state is
            when P2_SERVE =&gt;
                present_state &lt;= B6;
            when A7 =&gt;
                present_state &lt;= P2_HIT_EARLY;
            when WAIT_FOR_P2 =&gt;
                present_state &lt;= B6;
        when others =&gt;
           null;
        end case;

    end if;
end process;

   LEDS &lt;= temp;

end Behavioral;
","You're trying to use PAD1 and PAD2 as latch enables for present_state in addition to an asynchronous reset and clocked loads in the case statement. 

Your preferred implementation of the behavior you desire doesn't reflect hardware.  For instance you are peering at present_state in the later two case statements while you are using PAD1 and PAD2 as latch enables, effectively combinatorial clocks.

You may want to capture PAD1 and PAD2 as events that are cleared every clock sort of like catching edges for interrupts.  Depending on your clock rate you may need to impulse filter them, the question being whether or not you can get both make and break bounce from the buttons.  There's also the case of setup time to the clock edge to consider, meaning you might want to sample during a particular window insuring setup time.  The model is a flip flop using either PAD1 and PAD2 as clocks followed by a latch.  

With event capture you'd merge all the case statements into one under the rising_edge(CLK) evaluation.  The effect is to give two possible output states in some state cases, based on either PAD1 or PAD2 (stored) events.",,,,,
3D Array in VHDL for Data Buffer,"My 2D array for this RAM worked perfectly. Now I have the task of dealing with multiple triggers before I read out the data. So now I'm trying to make a data buffer in my RAM, so when multiple triggers fire, it can store the data which can be read out later. I just wondered two things:

1) Is this how you set up 3D arrays? There isn't a vast amount of information on them

2) Is there a better way of making a buffer for my data?

The data is in the format: data[buff_num][word_num][binary]

Each word is 32 bits, there are usually 14 words and I think I've made the buffer 8 bits deep. 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;

entity ipbus_dpram is
  generic(
    ADDR_WIDTH: natural
    );
  port(
    clk: in std_logic;
    rst: in std_logic;
    rclk: in std_logic;
    we: in std_logic := '0';
    d: in std_logic_vector(31 downto 0);
    rdata: out std_logic_vector(ADDR_WIDTH - 1 downto 0);
    addr: in std_logic_vector(ADDR_WIDTH - 1 downto 0);
    w_addr: out std_logic(ADDR_WIDTH - 1 downto 0);
    w_buf_shift: in std_logic;
    en_write: in std_logic;

    );

end ipbus_dpram;

architecture rtl of ipbus_dpram is

  type ram_array is array(7 downto 0, 13 downto 0) of std_logic_vector(31 downto 0);    
  shared variable ram: ram_array;
  signal w_shel, r_shel : integer;
  signal sel, wsel: integer;
  signal ack: std_logic;

  signal w_shift: unsigned(7 downto 0);
  signal r_shift: unsigned(7 downto 0);

begin

  sel &lt;= to_integer(unsigned(r_addr(addr_width-1 downto 0)));

  process(clk)
  begin
    if rising_edge(clk) then
      rdata &lt;= ram(r_shel, sel);

      if (en_write='1') then
        r_shel &lt;= to_integer(unsigned(r_shift));
        r_shift &lt;= r_shift +1;
      end if;
    end if;
  end process;

  wsel &lt;= to_integer(unsigned(addr));

  process(rclk)
  begin
    if rising_edge(rclk) then

      if we = '1' then
        ram(w_shel, wsel) := d;
      end if;
      if w_buf_shift = '1' then
        w_shel &lt;= to_integer(unsigned(w_shift));
        w_shift &lt;= w_shift + 1;
      end if;
    end if;
  end process;

end rtl;
","Wow... that is a HUGE amount of registers that you are trying to synthesize!  A 3D vector that is 2^8=256 wide by 2^14=16384 long by 32 deep = 134,217,728 registers!  You're gonna need a bigger boat.  Actually you're going to need a boat that does not yet exist.  Maybe some day they will build an FPGA big enough to handle your requirements, but alas that day is not today.  

You need to be storing your data more intelligently.  You need to use either off-chip storage such as a DRAM or SRAM or you need to temporarily buffer data using a FIFO.  ",,,,,
"VHDL-parse error, unexpected GENERIC, expecting END","I have a piece of code in vhdl:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity UartTX is


    port(clk,reset,tx_start,s_tick:in std_logic;
            datain : in std_logic_vector(7 downto 0);
            tx_done : out std_logic;
            tx:out std_logic);

    generic(DBITS : integer := 8; SB_TICK : integer := 16);

end UartTX;

architecture Behavioral of UartTX is

type tx_state is (idle,start,data,stop);

begin


end Behavioral;


While checking for syntax in Xilinx ISE 10.1,
the error 


  parse error, unexpected GENERIC, expecting END


is coming related to the 


  generic


part of entity declaration. What would be the reason?","The generic clause must be before port clause, so just move the generic clause up inside entity.",,,,,
Why is my design compiled by Quartus II successfully but no logic utilization?,"Sorry for such a general question. I have experience in Verilog but new to FPGA and Quartus II. I use Quartus II to try to compile a design and to see how much logic the design uses. I followed the quick tutorial of Quartus II by Altera. http://www.altera.com/literature/manual/mnl_qts_quick_start.pdf

However, after the step of analysis and synthesis, I noticed there is no logic utilization at all. Only the two Input pins of top module could be seen.



The top module of my design is

RiSC(clk,reset)


Naturally, after compilation, there is still nothing but two pins. 



Have you ever met this problem? Could you give me some hint? The design contains hundreds of lines of verilog codes so there should be logic utilization.

Thanks!",Unused outputs will be optimized out.  You're going to have to route out some outputs otherwise the synthesizer will nuke all of the logic.  ,,,,,
Why does VHDL shift register need 2 clock rising_edge to shift?,"I'm trying to make a 8-bit shift register using D flipflop.
The problem is that when simulating it takes two clock rising edges for the register to shift, one for the D input to change, the other for the Q to change. I don't know why.

entity Registry_8 is
  port (input  : in  std_logic;
        output : out std_logic;
        clk    : in  std_logic;
        clear  : in  std_logic;
        load   : in  std_logic;
        LR     : in  std_logic;
        pIn    : in  std_logic_vector (7 downto 0);
        pOut   : out std_logic_vector (7 downto 0);
        shift  : in  std_logic);
end Registry_8;

architecture Behavioral of Registry_8 is

  component D_flipflop
    port(D, clk, clear, preset : in  std_logic;
         Q, Q_b                : out std_logic);
  end component;
  signal D, Q : std_logic_vector (7 downto 0);

begin

  GEN_FLIP :
  for i in 0 to 7 generate
    D_i : D_flipflop port map(clk =&gt; clk, preset =&gt; '0', clear =&gt; clear, D =&gt; D(i), Q =&gt; Q(i));
  end generate GEN_FLIP;

  process (clk, load, LR, shift)
  begin
    if (load = '1')
    then D &lt;= pIn;
    end if;
    if (clk'event and clk = '1' and shift = '1')
    then
      if (LR = '0')
      then D(7 downto 0) &lt;= Q(6 downto 0) &amp; input;
           output &lt;= Q(7);
      else
        D(7 downto 0) &lt;= input &amp; Q(7 downto 1);
        output        &lt;= Q(0);
      end if;
    end if;
  end process;
  pOut &lt;= Q;

end Behavioral;
","In the process, there is clock edge sensitive condition with the expression:

clk'event and clk = '1'


The process thereby implements an additional level of sequential logic (flip
flops), but you probably wanted to create a process for purely combinatorial
design, like:

process (all) is
begin
  if (load = '1') then
    D &lt;= pIn;
  end if;
  if shift = '1' then
    if (LR = '0') then
      D(7 downto 0) &lt;= Q(6 downto 0) &amp; input;
      output        &lt;= Q(7);
    else
      D(7 downto 0) &lt;= input &amp; Q(7 downto 1);
      output        &lt;= Q(0);
    end if;
  end if;
end process;


Note that VHDL-2008 all is used as sensitivity list above, to automatically
include all signals used in a process for combinatorial design.",,,,,
Generics in hardware description language,"I'm fairly new to HD description languages. I'm finding it a bit hard to change my C-ish programming skills, and I'm looking for a little guaidance to help my throw the following problem.

I want to implement a full tree, that its inner nodes are different than its leaves.
The number of the leaves is generic (asuming there is 2^k leaves so the tree can be full)

Each inner node is a component made out of a simple combinational circuit. 

The leaves are synchronized with a clock, and are connected to the next leaf (breaking the tree structures - and forming something like a shift register)

This means that my design has to have a generic number of components that is connected according to the number of leaves.

While this could be solved recursivly in no time in C-based languages. I can't grasp the idea of solving it in HDL, since this generic form is different than n-bit input signals...

My implementation must be synthesizable, so SystemVerilog can't shine in this area :(

Is it possible to implement the described problem while keeping my code synthesizable?
can anyone guide me throw this or point me to a good reference regarding this topic?","I'll try to provide an answer that allows you to build a generic tree, without recursion, based only on the tree height provided as a generic at compile time. The code itself looks a bit tricky for my taste; however, the principles behind the solution are straigthforward. Here's an outline of the solution:


Imagine your nodes will be placed on a grid, with dimensions V=TREE_HEIGHT+1 and H=2**TREE_HEIGHT (see the ASCII-gram below). Then, all you need is an algorithm to populate the grid with nodes, and to make the right input and output connections.
To connect one level of the tree to the next, you can use a bidimensional array of size TREE_HEIGHT x 2**TREE_HEIGHT (see line 63 in the code example below).
To instantiate the nodes, use two nested loops (for-generate in VHDL, see lines 68-69). You will not populate all nodes; for a given row at depth=i,  only 2**(i-1) nodes are needed (line 71).
You can instantiate different entities for internal and leaf nodes. Just check whether the current value of i equals TREE_HEIGHT (lines 74 and 84).
Finally, you just need to connect the layers of the tree. The arithmetic is a bit tricky, but once you get it right you're done (lines 78-80).
Count on your synthesis tool to remove the unused wires.


Here's a poor rendition of the ""grid"" for HEIGHT=2:

             j = 1           j = 2           j = 3           j = 4      
       +---------------+---------------+---------------+---------------+
i = 1  | Root Node     |    (empty)    |    (empty)    |    (empty)    |
       +---------------+---------------+---------------+---------------+
i = 2  | Internal Node | Internal Node |    (empty)    |    (empty)    |
       +---------------+---------------+---------------+---------------+
i = 3  | Internal Node | Internal Node | Internal Node | Internal Node |
       +---------------+---------------+---------------+---------------+


Here's the code example:

/*  1 */  package tree_types_pkg is
/*  2 */      -- define a data type for the input and output values at each node
/*  3 */      subtype tree_data_type is integer range 0 to 255;
/*  4 */      -- define a vector type to propagate the output of a tree level to the next
/*  5 */      type layer_to_layer_channel_type is array (natural range &lt;&gt;) of tree_data_type;
/*  6 */  end;
/*  7 */  --------------------------------------------------------------------------------
/*  8 */  use work.tree_types_pkg.all;
/*  9 */
/* 10 */  entity internal_node is
/* 11 */      generic (
/* 12 */          TREE_HEIGHT: integer := 3
/* 13 */      );
/* 14 */      port (
/* 15 */          x: in integer range 1 to 2**TREE_HEIGHT;
/* 16 */          y: in integer range 1 to TREE_HEIGHT;
/* 17 */          input: in tree_data_type;
/* 18 */          output_left: out tree_data_type;
/* 19 */          output_right: out tree_data_type
/* 20 */      );
/* 21 */  end;
/* 22 */
/* 23 */  architecture rtl of internal_node is begin
/* 24 */      -- perform some calculation at the node
/* 25 */      output_left &lt;= input + x * y;
/* 26 */      output_right &lt;= input - x * y;
/* 27 */  end;
/* 28 */  --------------------------------------------------------------------------------
/* 29 */  use work.tree_types_pkg.all;
/* 20 */
/* 31 */  entity leaf_node is
/* 32 */      generic (
/* 33 */          TREE_HEIGHT: integer := 3
/* 34 */      );
/* 35 */      port (
/* 36 */          x: in integer range 1 to 2**TREE_HEIGHT;
/* 37 */          y: in integer range 1 to TREE_HEIGHT;
/* 38 */          input: in tree_data_type;
/* 39 */          output: out tree_data_type
/* 30 */      );
/* 41 */  end;
/* 42 */
/* 43 */  architecture rtl of leaf_node is begin
/* 44 */      -- perform some calculation at the node
/* 45 */      output &lt;= input + x * y;
/* 46 */  end;
/* 47 */  --------------------------------------------------------------------------------
/* 48 */  use work.tree_types_pkg.all;
/* 49 */
/* 50 */  entity dirtybit_binary_tree is
/* 51 */      generic (
/* 52 */          TREE_HEIGHT: integer := 4
/* 53 */      );
/* 54 */      port (
/* 55 */          tree_input: in tree_data_type;
/* 56 */          tree_outputs: out layer_to_layer_channel_type(1 to 2**TREE_HEIGHT)
/* 57 */      );
/* 58 */  end;
/* 59 */
/* 60 */  architecture behavior of dirtybit_binary_tree is
/* 61 */      constant LEAF_NODES_COUNT: integer := 2**TREE_HEIGHT;
/* 62 */      type channel_array_type is array (natural range &lt;&gt;) of layer_to_layer_channel_type;
/* 63 */      signal connections: channel_array_type(1 to TREE_HEIGHT)(1 to LEAF_NODES_COUNT);
/* 64 */  begin
/* 65 */
/* 66 */      connections(1)(1) &lt;= tree_input;
/* 67 */
/* 68 */      grid_y: for i in 1 to TREE_HEIGHT generate
/* 69 */          grid_x: for j in 1 to LEAF_NODES_COUNT generate
/* 70 */
/* 71 */              instantiate_nodes: if j &lt;= 2**(i-1) generate
/* 72 */
/* 73 */                  internal_nodes: if (i /= TREE_HEIGHT) generate
/* 74 */                      internal_node: entity work.internal_node 
/* 75 */                          generic map (TREE_HEIGHT =&gt; TREE_HEIGHT)
/* 76 */                          port map (
/* 77 */                              x =&gt; j,
/* 78 */                              y =&gt; i,
/* 79 */                              input        =&gt; connections(i)(j),
/* 80 */                              output_left  =&gt; connections(i+1)((j-1)*i+1),
/* 81 */                              output_right =&gt; connections(i+1)((j-1)*i+2)
/* 82 */                          );
/* 83 */                  end generate;
/* 84 */
/* 85 */                  leaf_nodes: if (i = TREE_HEIGHT) generate
/* 86 */                      leaf_node: entity work.leaf_node 
/* 87 */                          generic map (TREE_HEIGHT =&gt; TREE_HEIGHT)
/* 88 */                          port map (
/* 89 */                              x =&gt; j,
/* 90 */                              y =&gt; i,
/* 91 */                              input  =&gt; connections(i)(j),
/* 92 */                              output =&gt; tree_outputs(j)
/* 93 */                          );
/* 94 */                  end generate;
/* 95 */
/* 96 */              end generate;
/* 97 */
/* 98 */          end generate;
/* 99 */      end generate;
/* 100 */
/* 101 */ end;


Finally, here's what the synthesized circuit looks like on Quartus 12.1 (RTL Viewer):

",,,,,
Not able to get correct simulation waveform result,"module input_ram (clk, en, addr, data);

    input       clk;
    input       en;
    input [6:0] addr;
    output reg [7:0] data;

     always @(posedge clk) 
     begin
       if (en)
          begin 
      case(addr)
        7'b000: data = 8'b00110001;
        7'b001: data = 8'b00010000;
        7'b010: data = 8'b00100000;
        7'b011: data = 8'b11101101;
        7'b100: data = 8'b11100011;
        7'b101: data = 8'b00110011;
        7'b110: data = 8'b11110111;
        7'b111: data = 8'b00111011;

        7'b1000: data = 8'b00110001;
        7'b1001: data = 8'b00010000;
        7'b1010: data = 8'b00100000;
        7'b1011: data = 8'b11101101;
        7'b1100: data = 8'b11100011;
        7'b1101: data = 8'b00110011;
        7'b1110: data = 8'b11110111;
        7'b1111: data = 8'b00111011;

      7'b10000: data = 8'b00110001;
      7'b10001: data = 8'b00010000;
      7'b10010: data = 8'b00100000;
      7'b10011: data = 8'b11101101;
      7'b10100: data = 8'b11100011;
      7'b10101: data = 8'b00110011;
      7'b10110: data = 8'b11110111;
      7'b10111: data = 8'b00111011;

      7'b11000: data = 8'b00110001;
      7'b11001: data = 8'b00010000;
      7'b11010: data = 8'b00100000;
      7'b11011: data = 8'b11101101;
      7'b11100: data = 8'b11100011;
      7'b11101: data = 8'b00110011;
      7'b11110: data = 8'b11110111;
    7'b11111: data = 8'b00111011;

      7'b100000: data = 8'b00110001;
      7'b100001: data = 8'b00010000;
      7'b100010: data = 8'b00100000;
      7'b100011: data = 8'b11101101;
      7'b100100: data = 8'b11100011;
      7'b100101: data = 8'b00110011;
      7'b100110: data = 8'b11110111;
    7'b100111: data = 8'b00111011;

      7'b101000: data = 8'b00110001;
      7'b101001: data = 8'b00010000;
      7'b101010: data = 8'b00100000;
      7'b101011: data = 8'b11101101;
      7'b101100: data = 8'b11100011;
      7'b101101: data = 8'b00110011;
      7'b101110: data = 8'b11110111;
    7'b101111: data = 8'b00111011;


      7'b110000: data = 8'b00110001;
      7'b110001: data = 8'b00010000;
      7'b110010: data = 8'b00100000;
      7'b110011: data = 8'b11101101;
      7'b110100: data = 8'b11100011;
      7'b110101: data = 8'b00110011;
      7'b110110: data = 8'b11110111;
    7'b110111: data = 8'b00111011;

    7'b111000: data = 8'b00110001;
      7'b111001: data = 8'b00010000;
      7'b111010: data = 8'b00100000;
      7'b111011: data = 8'b11101101;
      7'b111100: data = 8'b11100011;
      7'b111101: data = 8'b00110011;
      7'b111110: data = 8'b11110111;
    7'b111111: data = 8'b00111011;
     7'b1000000: data = 8'b00110001;

        default: data = 8'b0000_XXXX;             
        endcase
        end
    end
    endmodule


///////////////////////Testbench///////////////////////

module ram_tst;

// Inputs
reg clk;
reg en;
reg [6:0] addr;

// Outputs
wire [7:0] data;

// Instantiate the Unit Under Test (UUT)
input_ram uut (
    .clk(clk), 
    .en(en), 
    .addr(addr), 
    .data(data)
);

initial 
begin
    clk = 0;
    addr =7'b0;
    en=1;

end
always #5 clk=~clk;

always @ (posedge clk )
begin 
addr = addr  + 7'b1;
$monitor ($time,""clk=%b,addr=%b,data=%b"",clk,addr,data);

end         

endmodule




My question is i want my data when my addr=0 but in simulation result initially address is at 00000000 and there is no data on dataline and suddenly next clock pulse the data available on addr=00000000 data = 8'b00110001; will be available at addr=0000001;
mean final conclusion how to get my data parallel with my addresline where i m doing mistake sir please correct me","You currently sample the address in one cycle, then drive the data in the next cycle using sequential logic.  You need data to be a combinational decode of your address.

Change:

always @(posedge clk) 


to:

always @*


But, then there is no need for the clk input to input_ram.",,,,,
Get a modules data without an entity statement in VHDL?,"I need to get some data from a module I was given, but I don't know if it is even possible or how to approach the problem.

Is it possible to get information from another module if that module doesn't have an entity map? It only has a generic with TIME statements.

Is it at all possible to get anything out of this module? 
It writes to a memory, could I pull things out of that? 

This is the file I have.

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.STD_LOGIC_UNSIGNED.all;
use IEEE.STD_LOGIC_ARITH.all;

use STD.TEXTIO.all;
use IEEE.STD_LOGIC_TEXTIO.all;

entity MIPS is
  generic (
    MEM_DLY : TIME := 0.5 ns;
    CYC_TIME: TIME := 2 ns
  );
end entity MIPS;

architecture MIPS of MIPS is

signal  PC : STD_LOGIC_VECTOR ( 31 downto 0 ) := X""0000_0010"";
signal  READ_DATA2 : STD_LOGIC_VECTOR ( 31 downto 0 ) := ( others =&gt; '0');

signal HUH       : BIT_VECTOR ( 31 downto 0 );
signal HUHINS    : STRING ( 1 to 25 );
signal INSTRUC   : STD_LOGIC_VECTOR ( 31 downto 0 );
signal M_DATA_IN : STD_LOGIC_VECTOR ( 31 downto 0 ) := ( others =&gt; 'Z');
signal M_DATA_OUT : STD_LOGIC_VECTOR ( 31 downto 0 ):= ( others =&gt; 'Z');
signal M_ADDR    : STD_LOGIC_VECTOR ( 11 downto 0 ) := ( others =&gt; '0');
signal CLK       : STD_LOGIC := '0';
signal MEMREAD   : STD_LOGIC := '0';
signal M_DATA_WHEN   : STD_LOGIC := '0';
signal MEMWRITE  : STD_LOGIC := '0';

signal CYCLE     : INTEGER := 1;

begin

CLOCK_PROC:
  process
  begin
    CLK &lt;= '1';
    wait for CYC_TIME/2;
    CLK &lt;= '0';
    wait for CYC_TIME/2;
    CYCLE &lt;= CYCLE + 1;
  end process;

TEST_PC_PROC:
  process ( CLK ) is
  begin
    if RISING_EDGE ( CLK ) then
      PC &lt;= PC + 4;
    end if;
  end process;



INSTR_MEM_PROC:
  process ( PC ) is                       -- make subject only to address
    type INSTR_STR_ARY is array ( 0 to 1023 ) of STRING ( 1 to 25 );
    variable MEMSTRR : INSTR_STR_ARY:=(others =&gt; ""                         "");
    type MEMORY is array ( 0 to 1023 ) of BIT_VECTOR ( 31 downto 0 );
    variable MEM     : MEMORY := ( others =&gt; X""0000_0000"");
    variable IADDR   : INTEGER;               -- integer for address
    variable DTEMP   : BIT_VECTOR ( 31 downto 0 );
    variable INIT    : INTEGER := 0;          -- when to initialize...
    file IN_FILE     : TEXT open READ_MODE is ""instr_mem.txt"";
    variable BUF     : LINE;
    variable ADR_STR : STD_LOGIC_VECTOR ( 31 downto 0 );
    variable TADR    : INTEGER;
    variable TDATA   : STD_LOGIC_VECTOR ( 31 downto 0 );
    variable BDATA   : BIT_VECTOR ( 31 downto 0 );
    variable STR_ING : STRING ( 1 to 25 );
  begin
    if INIT = 0 then
      while not (ENDFILE ( IN_FILE )) loop
        READLINE ( IN_FILE, BUF );
        HREAD    ( BUF, ADR_STR ); -- get the address on the line
        TADR := CONV_INTEGER ( ADR_STR (14 downto 2));
        HREAD    ( BUF, TDATA   ); -- get the data on the line
        BDATA := To_bitvector (TDATA);
        MEM ( TADR ) := BDATA;     -- put into memory
        for J in 1 to 25 loop
          STR_ING(J) := ' ';
        end loop;
        READ     ( BUF, STR_ING ); -- get instruction string
        MEMSTRR ( TADR ) := STR_ING;
        report ""iteration of loop"";
      end loop;
      INIT := 1;                   -- when all data in, set INIT to 1;
    end if;                        -- end of INIT check
    IADDR := CONV_INTEGER ( PC ( 14 downto 2 ));
    HUH &lt;= MEM ( IADDR );
    INSTRUC &lt;= To_StdLogicVector ( MEM ( IADDR )) after MEM_DLY;
    HUHINS &lt;= MEMSTRR ( IADDR );
    report ""should hit  INSTRUC"";
  end process;
M_DATA_IN_STMT:
  M_DATA_IN &lt;= READ_DATA2 ;

-- The following is the magic process
-- User must supply:
--  M_ADDR - memory address (data memory) as a 12 bit STD_LOGIC_VECTOR
--           Remember the M_ADDR is a WORD address
--  M_DATA_IN - value going to memory from hardware (data path)
--           Remember that this is 32 bit STD_LOGIC_VECTOR, user supplied
--  READ_DATA2 - this is to be replaced by user's sourceof info for memory
DATA_MEMORY_PROCESS:                          -- name of process ...
  process ( M_ADDR, CLK, MEMREAD ) is         -- Sens: M_ADDR, CLK, MEMREAD
  file IN_FILE: TEXT open READ_MODE is ""data_mem_init.txt""; -- initial data
  file OUT_FILE: TEXT open WRITE_MODE is ""mem_trans.txt"";   -- results
  variable BUF : LINE;                        -- declare BUF as LINE
  variable TVAL : STD_LOGIC_VECTOR ( 31 downto 0 ); -- var for temp value
  variable TADRHEX : STD_LOGIC_VECTOR ( 31 downto 0 ); -- var for address
  variable TADR : INTEGER;                    -- address as integer
  type MEM_TYPE is array ( 0 to 1023 ) of STD_LOGIC_VECTOR ( 31 downto 0 );
  variable THE_MEMORY : MEM_TYPE := ( others =&gt; X""00000000"" ); -- the memory
  variable FIRST : BOOLEAN := TRUE;           -- flag for first time thru
  constant STR : STRING ( 1 to 3 ) := ""   "";  -- 3 spaces - for printing
  constant WR_STR : STRING ( 1 to 3 ) := ""W  ""; -- for write
  constant RD_STR : STRING ( 1 to 3 ) := ""R  ""; -- for read
  variable TSTR2 : STRING ( 1 to 29 );          -- to create a string
  type MEMSTR_TYPE is array ( 0 to 1023 ) of STRING ( 1 to 29 ); -- 
  variable INSTRS : MEMSTR_TYPE;
  begin                                       -- start here
    if FIRST then                             -- first time thru,
      while FIRST loop                        -- loop on data available - until
        if not ( ENDFILE ( IN_FILE )) then    -- end of file shows up
          READLINE(IN_FILE, BUF);             -- read a line from file,
          HREAD(BUF, TADRHEX);                -- get address from BUF
          TADR := CONV_INTEGER ( TADRHEX );   -- turn it into integer
          HREAD(BUF, TVAL);                   -- next, get value from BUF
          THE_MEMORY(TADR/4) := TVAL;         -- put TVAL into the memory
        else                                  -- the 'else' is for end of file
          FIRST := FALSE;                     -- EOF shows up - set FIRST false
        end if;
      end loop;                               -- where loop ends...
    end if;                                   -- where if FIRST ends ...
    if MEMREAD = '1' then                     -- now, memory function 'read'
      M_DATA_OUT &lt;= THE_MEMORY ( CONV_INTEGER ( M_ADDR ) / 4 ); -- get val from
      M_DATA_WHEN &lt;= not M_DATA_WHEN;         -- and invert M_DATA_WHEN
    else                                      -- if not MEMREAD,
      M_DATA_OUT &lt;= ( others =&gt; 'Z' );        -- set memory out to 'Z's
    end if;
    if RISING_EDGE ( CLK ) then               -- on clock edge...
      if MEMREAD = '1' then                   -- if MEMREAD asserted,
        TADR := CONV_INTEGER ( M_ADDR ) / 4;  -- set TADR to address as int
        TVAL := THE_MEMORY ( TADR );          -- and get contents to TVAL
        WRITE (BUF, RD_STR);                  -- then build BUF; put read indi
        HWRITE (BUF, M_ADDR);                 -- and the address
        WRITE (BUF, STR);                     -- some spaces
        HWRITE (BUF, TVAL);                   -- and the value
        WRITE (BUF, STR);                     -- more spaces
    WRITE (BUF, NOW);                     -- current simulation time
        WRITELINE (OUT_FILE, BUF);            -- and send line to file.
      elsif MEMWRITE = '1' then               -- if not read, but it is write
        TADR := CONV_INTEGER ( M_ADDR ) / 4;  -- set TADR to address as int
        TVAL := M_DATA_IN;                    -- set TVAL as data in value
        WRITE (BUF, WR_STR);                  -- start buffer with write indi
        HWRITE (BUF, M_ADDR);                 -- then the address
        WRITE (BUF, STR);                     -- then some spaces
        HWRITE (BUF, TVAL);                   -- and the value written
        WRITE (BUF, STR);                     -- still more spaces
    WRITE (BUF, NOW);                     -- simulation time
        WRITELINE (OUT_FILE, BUF);            -- and send line to file
        THE_MEMORY ( CONV_INTEGER ( M_ADDR ) / 4) := M_DATA_IN;
                                              -- and finally, value to the mem
      end if;
    end if;
  end process;

end architecture MIPS;
","The code you presented simulates the memories that your MIPS processor will interact with - a program memory and a data memory.

Your MIPS will interact with the program memory by providing a value for PC; the corresponding instruction will be handed to your CPU on signal INSTRUCT. You'll probably delete the lines corresponding to the TEST_PC_PROC process, since the actual PC value will come from the MIPS. The program to be run by the CPU is given in file data_mem_init.txt. This program memory is asynchronous.

Your MIPS will interact with the data memory through signals M_ADDR, M_DATA_OUT, M_DATA_IN, and MEMREAD. To read data, your CPU will set M_ADDR and MEMREAD=1, and provide the address in M_ADDR. The given code will set M_DATA_OUT with the requested data. To write data, you will set M_DATA_IN or READ_DATA2 (or replace READ_DATA2 with a signal of your choice). The data will be written on the rising edge of CLK.

Don't be distracted by the WRITE/HWRITE calls, they just keep a log on file mem_trans.txt.

IMO, this interface is much more complicated than it needed to be. You're probably better or if you keep your MIPS implementation in totally separate files, and just add the signals needed to interact with this model to its ports list.",,,,,
VHDL code : statement in the If condition not getting updated,"I'm new to VHDL language. I'm trying to code a universal shift register using 4:1 mux and D flip flop. when the select line of the 4:1 mux is ""01"" I do shift right operation. I wrote all the statement that must execute when this condition satisfies.

I'm using instances of 4:1 mux in my code.Individually when tested each mux, output is coming correctly .But when put inside the if statement of universal shift register the output of mux still says undefined when simulated.

Can anyone help me??

Below is my code

entity universal_sft_reg is  
    Port ( serial_in_left_ip : in  STD_LOGIC;  
           serial_in_rt_ip : in  STD_LOGIC;  
           parallel_ip : in  STD_LOGIC_VECTOR (7 downto 0);  
           parallel_out : out  STD_LOGIC_VECTOR (7 downto 0);  
              serial_out : out  STD_LOGIC;  
           clk : in  STD_LOGIC;  
           rst : in  STD_LOGIC;  
           sel : in  STD_LOGIC_VECTOR (1 downto 0));  
end universal_sft_reg;

architecture Behavioral of universal_sft_reg is  
component four_one_mux is  
    Port ( in0 : in  STD_LOGIC;  
           in1 : in  STD_LOGIC;  
           in2 : in  STD_LOGIC;
           in3 : in  STD_LOGIC;  
              s0 : in STD_LOGIC;  
              s1 : in STD_LOGIC;  
           y : out  STD_LOGIC);  
end component;

component DFF is  
    Port ( d : in  STD_LOGIC;  
           q : out  STD_LOGIC;  
           rst : in  STD_LOGIC;  
           clk : in  STD_LOGIC);  
end component;  

signal d1,d2,d3,d4,d5,d6,d7,d8 : STD_LOGIC;  
signal y1,y2,y3,y4,y5,y6,y7,y8 : STD_LOGIC;                                                                  signal n0_1,in1_1,in2_1,in3_1,in0_2,in1_2,in2_2,in3_2,in0_3,in1_3,in2_3,in3_3,in0_4,in1_4,in2_4,in3_4,in0_5,in1_5,in2_5,in3_5,in0_6,in1_6,in2_6,in3_6,in0_7,in1_7,in2_7,in3_7,in0_8,in1_8,in2_8,in3_8 :STD_LOGIC;    
signal q1,q2,q3,q4,q5,q6,q7,q8 : STD_LOGIC;



begin

DFF1 : DFF port map(d1,q1,rst,clk);   
DFF2 : DFF port map(d2,q2,rst,clk);                                                                   DFF3 : DFF port map(d3,q3,rst,clk);  
DFF4 : DFF port map(d4,q4,rst,clk);  
DFF5 : DFF port map(d5,q5,rst,clk);                                                                 DFF6 : DFF port map(d6,q6,rst,clk);
DFF7 : DFF port map(d7,q7,rst,clk);
DFF8 : DFF port map(d8,q8,rst,clk);  

MUX1 : four_one_mux port map(in0_1,in1_1,in2_1,in3_1,sel(0),sel(1),y1);   
MUX2 : four_one_mux port map(in0_2,in1_2,in2_2,in3_2,sel(0),sel(1),y2);  
MUX3 : four_one_mux port map(in0_3,in1_3,in2_3,in3_3,sel(0),sel(1),y3);   
MUX4 : four_one_mux port map(in0_4,in1_4,in2_4,in3_4,sel(0),sel(1),y4);   
MUX5 : four_one_mux port map(in0_5,in1_5,in2_5,in3_5,sel(0),sel(1),y5);   
MUX6 : four_one_mux port map(in0_6,in1_6,in2_6,in3_6,sel(0),sel(1),y6);   
MUX7 : four_one_mux port map(in0_7,in1_7,in2_7,in3_7,sel(0),sel(1),y7);   
MUX8 : four_one_mux port map(in0_8,in1_8,in2_8,in3_8,sel(0),sel(1),y8);  

process(clk,sel)   
begin   

if(clk = '1' and clk'event) then   
if sel = ""00"" then   
d1 &lt;= y1;   
d2 &lt;= y2;   
d3 &lt;= y3;   
d4 &lt;= y4;   
d5 &lt;= y5;   
d6 &lt;= y6;   
d7 &lt;= y7;   
d8 &lt;= y8;  
end if;  

if( sel = ""01"") then   

in1_8 &lt;= serial_in_rt_ip;--input to the mux   
--y8 is not getting updated with the input value!!!!.   
d8 &lt;= y8;    
in1_7 &lt;= q8;   
d7 &lt;= y7;   
in1_6 &lt;= q7;   
d6 &lt;= y6;  
in1_5 &lt;= q6;   
d5 &lt;= y5;   
in1_4 &lt;= q5;   
d4 &lt;= y4;   
in1_3 &lt;= q4;   
d3 &lt;= y3;   
in1_2 &lt;= q3;   
d2 &lt;= y2;   
in1_1 &lt;= q2;   
d1 &lt;= y1;   
serial_out &lt;= q1;   

end if;   

if( sel=""10"") then   
in2_1 &lt;= serial_in_left_ip;   
d1 &lt;= y1;   
in2_2 &lt;= q1;   
d2 &lt;= y2;   
in2_3 &lt;= q2;   
d3 &lt;= y3;   
in2_4 &lt;= q3;   
d4 &lt;= y4;   
in2_5 &lt;= q4;   
d5 &lt;= y5;   
in2_6 &lt;=q5;  
d6 &lt;= y6;   
in2_7 &lt;= q6;   
d7 &lt;= y7;   
in2_8 &lt;= q7;   
d8 &lt;= y8;   
serial_out &lt;= q8;  
end if;  

if(sel =""11"") then  

in3_1 &lt;= parallel_ip(0);   
in3_2 &lt;= parallel_ip(1);   
in3_3 &lt;= parallel_ip(2);   
in3_4 &lt;= parallel_ip(3);   
in3_5 &lt;= parallel_ip(4);   
in3_6 &lt;= parallel_ip(5);   
in3_7 &lt;= parallel_ip(6);   
in3_8 &lt;= parallel_ip(7); 

d1 &lt;= y1;    
d2 &lt;= y2;   
d3 &lt;= y3;   
d4 &lt;= y4;   
d5 &lt;= y5;   
d6 &lt;= y6;   
d7 &lt;= y7;   
d8 &lt;= y8;   


parallel_out(0) &lt;= q1;   
parallel_out(1) &lt;= q2;   
parallel_out(2) &lt;= q3;   
parallel_out(3) &lt;= q4;   
parallel_out(4) &lt;= q5;   
parallel_out(5) &lt;= q6;   
parallel_out(6) &lt;= q7;   
parallel_out(7) &lt;= q8;   

end if;  

end if;  

end process;  

end Behavioral;   
","Given your stated goal of coding a shift register using a mux and dff, you shouldn't be using a process in your shift register design at all.

You should be able to directly connect your 8 DFF and MUX components such that you get a shift register. Currently, you are creating additional (and redundant) MUXes and DFFs in your process.

My recommendation to get this working: draw a block diagram using 8 MUXes and 8 DFFs, then write the VHDL to describe your block diagram.",,,,,
VHDL syntaxe error near if,"I'm a trying to find out the problem with this simple VHDL code. I'll be grateful if someone could help me.
PS: I tried the code without the conditional block and it works :S !

*The message error is : Error (10500): VHDL syntax error at Four_Bits_Adder.vhd(18) near text ""if"";  expecting "";"", or an identifier (""if"" is a reserved keyword), or ""architecture""*

The 4 bits adder code is : 

Library ieee;
Use ieee.std_logic_1164.all;
Use ieee.numeric_std.all;
Use ieee.std_logic_unsigned.all;

entity Four_Bits_Adder is 
port(A,B:in std_logic_vector(3 downto 0);
    S:out std_logic_vector(3 downto 0);
    Cout:out std_logic);
end Four_Bits_Adder;
architecture description of Four_Bits_Adder is 
begin 
S&lt;= A+B;
if A(3)=1 then 
    if B(3)=1 then 
        Cout&lt;=1;
        end if;
end if;     
end description;
","An if statement is a sequential statement, and from your usage should either be in a process statement or you should instead use a concurrent signal assignment statement.  It hardly seems complex enough for a process statement.

Concurrent assignment statement:

 Cout &lt;= A(3) and B(3);


Note that concurrent assignment statement using an expression as the value in it's signal assignment can pass values other than '0' or '1'.  

A different style of concurrent signal assignment statement could pass only binary representing enumeration values:

Cout &lt;= '1'  when A(3) = '1' and B(3) = '1' else '0';


(Your if statement also appears to infer a latch and could be optimized as a constant '1').

Note also that your original if nested statements could be expressed with a BOOLEAN and which is a short-circuit operator taking the place of Ada's if expression and then ....
Without one or more intervening statements following an if statement (including it's end if) there is no reason to nest if statements with different expressions.  The short-circuit operator would only evaluate the subsequent expression if the first expression evaluated true.

The form would be along the lines of

if A(3) = '1' and B(3) = '1' then
    Cout &lt;= '1';
end if;


And could still only be used where a sequential statement is appropriate.

Note that std_logic requires enumeration values ('U', 'X', '0', '1',...) while 1 is a numeric value and would result in errors.",,,,,
VHDL Bit Vector Operators,"I'm having a lot of trouble getting some simple math done in VHDL. I'm terrible at this language so if my syntax is stupid or something, I have an excuse :P. I'm trying to implement a very simple random number generator that calculates a pseudo-random number by this formula:

seed = (seed*1103515245) + 12345

How I'm trying to do it:

Signalss here

signal seed: std_logic_vector(31 downto 0) := x""2B4C96B9"";
signal multiply: std_logic_vector(31 downto 0) := x""41C64E6D"";
signal add: std_logic_vector(31 downto 0) := x""00003039"";
signal temp1: std_logic_vector(63 downto 0);
signal temp2: std_logic_vector(31 downto 0);


Computation here (done in a state in a state machine)

temp2 &lt;= seed;
temp1 &lt;= std_logic_vector((unsigned(temp2)*unsigned(multiply)));
seed &lt;= std_logic_vector(unsigned(temp1(31 downto 0)) + unsigned(add));


temp2 always ends up being undefined. Additionally, seed ends up being undefined as well. I've tried it several different ways but all of them were wrong mostly because of the vector sizes and order or operations. I feel like I'm doing it right at the moment based on what I've found through semi-extensive Googling but I just can't figure it out.

The best thing I can think of right now is to do each step of the calculation in its own state in a state machine. Can anyone see what I'm doing wrong here?","VHDL is different from other languages in that signal assign by &lt;= does not take effect for read until after a delta delay, thus if you do:

temp2 &lt;= seed;
temp1 &lt;= std_logic_vector((unsigned(temp2)*unsigned(multiply)));
seed &lt;= std_logic_vector(unsigned(temp1(31 downto 0)) + unsigned(add));


then the temp2 not actually updated for read in the expression used to assign temp1 until a delta delay has passed.

Depending on the details about your design, you can consider declaring the intermediate variables as variables:

variable temp1: std_logic_vector(63 downto 0);
variable temp2: std_logic_vector(31 downto 0);


and then assign like:

temp2 := seed;
temp1 := std_logic_vector((unsigned(temp2)*unsigned(multiply)));
seed &lt;= std_logic_vector(unsigned(temp1(31 downto 0)) + unsigned(add));


In this case the intermediate variables temp1 and temp2 will have the result ready for read right after the assign, and the seed will have the value after a delta delay, assuming that you will not do the next iteration until next cycle.

It will clarify the intention in the code if constants are declared as such, doing:

constant MULTIPLY : std_logic_vector(31 downto 0) := x""41C64E6D"";
constant ADD      : std_logic_vector(31 downto 0) := x""00003039"";


A comment on you calculation, then the VHDL design truncates the result of the multiplication, thus doing:


  seed = (seed*1103515245) mod (2**32) + 12345
",,,,,
resetting values in a VHDL register and stop writing further,"I have simple register and getting single bit values from 5 state machines (all at one time). These values are stored in a register as std_logic_vector and has to be given as an input to another module. Once the output of this register is being processed in another module, the index in the register where there was a change (e,g 0 to 1), the value at that index should reset (e,g 1 to 0) and it should take no further input for that particular index (but there is constant input coming from state machines). Any suggestion, how it should be done?

The register code is:

entity fault_reg is

port (
  clk           : in  std_logic;
  rst           : in  std_logic;
  reg_in        : in  std_logic_vector(NUM_PORTS - 1 downto 0);
  reg_out       : out std_logic_vector(NUM_PORTS - 1 downto 0));
end fault_reg;

architecture Behavioral of fault_reg is
begin

reg_impl : process(clk, rst)
begin
    if rst = '1' then
        reg_out &lt;= (others =&gt; '0');
    elsif clk'event and clk='1' then
        reg_out &lt;= reg_in;
    end if;
end process reg_impl;

end Behavioral;
","I'm not entirely sure what you are asking, but it seems to me you want something like:


initialise your reg_out to all ones
then in the clocked process do a for loop to iterate over all the input bits and clear the bits which are set in the input


Like this:

reg_out &lt;= reg_in;
for i in reg_in'range loop
    if reg_in(i) = '1' then
        masked_bits(i) := '1';
    end if;
    if masked_bits(i) = '1' then
        reg_out(i) &lt;= '0';
    end if;
end loop;
",,,,,
How to handle a BUS in Verilog with multiple drivers,"I'm trying to connect multiple modules in verilog sharing a common ""BUS"" of size 16bits. I'm having trouble connecting multiple inputs(drivers) to the BUS. When I attach more then one driver, I get an error within Xilinx.


  Signal BUS in unit {Top_Module_Name} is connected to following multiple drivers:


The code I have for the modules are

input         en;
output [15:0] BUS;
reg    [15:0] data;

if (en) begin BUS = data;
else BUS = 16'dZ;


In the top module I have something similar to

module1(en1,wBUS);
module2(en2,wBUS);
module3(en3,wBUS);


I have a controller controlling enables with 1 hot encoding.","Your BUS output is not a reg, but a wire. To use BUS in a IF statement (inside a combinational always of course) BUS has to be defined as reg.

Something like this:

module something (input en, 
                  output reg [15:0] bus
                 ); 
  reg [15:0] data = 16'hABCD;  // some value;

  always @* begin
    if (en)
      bus = data;
    else
      bus = 16'hZZZZ;
  end
endmodule


If bus is going to be a wire...

module something (input en, 
                  output [15:0] bus
                 ); 
  reg [15:0] data = 16'hABCD;  // some value;
  assign bus = (en)? data : 16'hZZZZ;
endmodule
",,,,,
"why cant I use XNOR on type ""std_logic_vector"" ?","it seems straightforward but I cant get past it

            din : in std_logic_vector(13 downto 0);
            sin : in std_logic_vector(3 downto 0);
            .
            .
            .

            if ( din(idx downto idx-3) XNOR sin(3 downto 0) ) then


and I get the


  ** Error: Z:/lab_dig_2/1/prep/additionalQ/additionalQ.vhd(30): Type error resolving infix expression ""xnor"" as type std.STANDARD.BOOLEAN.


error

is there a special operator for vectors? I remember that std_logic_vector is a perfect type for this kind of operators?","The xnor in your expression operates on two std_logic_vector type and thus returns another std_logic_vector type, but the if expression expects a boolean type.

You may want to change the expression to the below, if you want a condition that is true when the xnor result is not all zeros:

if (din(idx downto idx-3) XNOR sin(3 downto 0)) /= ""0000"" then


EDIT: More information about implicit type convert in VHDL-2008

VHDL is a strong typed language where the designer typically has to do explicit
type casts so the result matches the required type, and otherwise an error is
generated.

However, VHDL-2008 has added some implicit type casting, in special with the
condition operator ?? which can convert to boolean type.  The operator is
declared in std_logic_1164 system package as:

function ""??"" (l : std_ulogic) return boolean;


The condition operation is automatically applied for if, elsif, until,
assert, and similar places if the expression did not evaluate to a boolean
type.  So, if you are using VHDL-2008, then it is possible to write:

signal test_sl : std_logic;
...
if test_sl then
  ...


Whereby the condition operator ?? is implicitly applied, as if written:

if ?? test_sl then


An equivalent to the below, which is also valid in VHDL-2002:

if (test_sl = '1') or (test_sl = 'H') then


The ?? operator is only declared in standard VHDL-2008 for std_ulogic type,
which thus also applies to std_logic type.  However, the operator can be
overloaded in a user declared function to apply for std_logic_vector, with:

-- Or operation of ?? for all elements in arg
function ""??"" (arg : std_ulogic_vector) return boolean is
  variable res_v : boolean;
begin
  res_v := FALSE;
  for idx in arg'range loop
    res_v := res_v or (?? arg(idx));
  end loop;
  return res_v;
end function;


If the above is declared, then it is possible to use implicit casting of
std_logic_vector to boolean in if statements, like:

signal test_slv : std_logic_vector(3 downto 0);
...
if test_slv then
  ....


Or even:

if din(idx downto idx-3) XNOR sin(3 downto 0) then


A word of caution though, since the code may be become less readable to others
and thus more error prone, if such tricks are used; but it is possible.",,,,,
Integer to String goes wrong in Synthesis (Width Mismatch),"I am trying to convert a integer to string (using integer'image(val)) and either pad or limit it to a specific length. I have made this function which does the job just fine when I use a report statement and simulate.

function integer2string_pad(val: integer; stringSize: integer) return string is
    variable imageString: string(1 to integer'image(val)'length);
    variable returnString: string(1 to stringSize);
begin
    imageString := integer'image(val);

    -- Are we smaller than the desired size?
    if integer'image(val)'length &lt; stringSize then
        -- Pad the string if we are
        returnString := integer'image(val) &amp; (1 to stringSize-integer'image(val)'length =&gt; ' ');

    -- Are we to big for the desired size
    elsif integer'image(val)'length &gt; stringSize then
        -- Only use the top most string bits and append a ""."" to the end signifing that there is more
        returnString := imageString(1 to stringSize-1) &amp; ""."";

    -- Otherwise we are just the right size
    else
        returnString := integer'image(val);
    end if;


    return returnString;
end function;


Here is some sample input, output of that function (underscore = space because SO inline code truncates extra space): 

integer2string_pad(12, 6) : 12____

integer2string_pad(123456, 6) : 123456

integer2string_pad(1234567890, 6) : 12345.

integer2string_pad(0, 6) : 0_____

integer2string_pad(-123, 6) : -123__

integer2string_pad(-1, 6) : -1____

integer2string_pad(-123456, 6) : -1234.



But when I synthesize, I get width mismatch errors on all 4 lines where I assign values to pongScoreLeft or pongScoreRight. It also says they have a constant value of 0 and get trimmed out.

Width mismatch. &lt;pongScoreLeft&gt; has a width of 48 bits but assigned
expression is 6-bit wide. 
Width mismatch. &lt;pongScoreRight&gt; has a width
of 48 bits but assigned expression is 6-bit wide.
Width mismatch. &lt;pongScoreLeft&gt; has a width of 48 bits but assigned expression is 6-bit wide.
Width mismatch. &lt;pongScoreRight&gt; has a width of 48 bits but assigned expression is 6-bit wide.


VHDL that produces those width mismatch errors:

type type_score is
record
    left : integer range 0 to 255;
    right : integer range 0 to 255;
end record;
constant init_type_score: type_score := (left =&gt; 0, right =&gt; 0);

signal pongScore: type_score := init_type_score;
signal pongScoreLeft: string(1 to 6) := (others =&gt; NUL);
signal pongScoreRight: string(1 to 6) := (others =&gt; NUL);

...

scoreToString: process(clk)
begin
    if rising_edge(clk) then
        if reset = '1' then
            pongScoreLeft &lt;= (others =&gt; NUL);
            pongScoreRight &lt;= (others =&gt; NUL);
        else
            pongScoreLeft &lt;= integer2string_pad(pongScore.left, 6);
            pongScoreRight &lt;= integer2string_pad(pongScore.right, 6);
            --report ""|"" &amp; integer2string_pad(pongScore.left, 6) &amp; ""|"";

        end if;
    end if;
end process;


What is wrong with my integer2string_pad function? What goes wrong in synthesis?","I would not expect 'image or 'value to be supported for synthesis - other than in asserts that run at elaboration time. They would involve a lot of processing.

Whenever I have converted integers to ASCII I have processed a character at a time, using character'val and character'pos, which are synthesisable, because they involve no processing; they just convert a character to/from its underlying binary representation.

EDIT: 
Think how you would implement 'image! It involves multiple divisions by 10 : that's a LOT of hardware if you unroll it into a single delta cycle (as required by the semantics of an unclocked function call) 

Processing a digit per (several) clock cycle(s) you can reduce that to a single division, or successive subtraction, or excess-6 addition, or however you want according to your hardware resources and time budget. 

It really doesn't make sense for the synthesis tool to make these decisions on your behalf. So - while I concede it's theoretically possible, I would be surprised to see a synth tool that did it correctly. (OTOH it's such an unlikely scenario I'd not be surprised to see bugs in synth tool's error reporting should you try it)",,,,,
Instancing a parameterized cell in Xilinx schematic,"I have a parameterized cell - a n-bit register, defined as:

module Register #(parameter n = 16)(
    output reg [n-1:0] OUTPUT,
    input [n-1:0] INPUT,
    input RST, EN, CLK);
// bla bla bla
endmodule


In a Xilinx Verilog Module I could instance this n bit register like so:

Register #(8) REG1 (OUT, IN, RST, EN, CLK);


(as seen here).

How do I instance this register with let's say 8 bit INPUT/OUTPUT in a Xilinx Schematic?","Unfortunately in Xilinx Schematics instances are fixed; therefor you cannot set parameters. Your best option would be to create a new module, possibly named Register_8bit, that sets n as a parameter in the module. Then separate sized modules can be named separately, but only the inner parameter must be changed.

module Register_8bit (
    parameter n = 8;
    output reg [n-1:0] OUTPUT,
    input [n-1:0] INPUT,
    input RST, EN, CLK);
// bla bla bla
endmodule


This allows the most reuse of code while still allowing the benefits of the top level schematic view.",,,,,
need concept to understand declaration of array in system verilog,"I am always confusing while declaring an array and Array Querying Function in SystemVerilog. Can you explain me in details for given example:

Example-1

integer matrix[7:0][0:31][15:0];

// 3-dimensional unpacked array of integers i am confuse in size 
// and dimension of given array for 1 and 2 dimension its easy to 
// understand but for 3 and 4-dimension its little bit confusing...


Example-2

//bit [1:5][10:16] foo [21:27][31:38]; 


Example-3

//module array(); 

bit [1:5][10:16] foo1 [21:27][31:38],foo2 [31:27][33:38]; 

initial 

begin 

$display("" dimensions of foo1 is %d foo2 is %d"",$dimensions(foo1),$dimensions(foo2) );

end 


Output ...

dimensions of foo1 is 4 foo2 is 4


I am not getting this also...","See Sec: 7.4.5 Multidimensional arrays of IEEE 1800-2009

The dimensions preceding the identifier set the packed dimensions.
The dimensions following the identifier set the unpacked dimensions.

bit [3:0] [7:0] joe [1:10]; // 10 elements of 4 8-bit bytes 


In a multidimensional declaration, the dimensions declared following the type and before the name
([3:0][7:0] in the preceding declaration) vary more rapidly than the dimensions following the name
([1:10] in the preceding declaration).
When referenced, the packed dimensions ([3:0], [7:0]) follow
the unpacked dimensions ([1:10]).

i.e. In a list of dimensions, the rightmost one varies most rapidly, as in C.
However, a packed dimension varies more rapidly than an unpacked one.

bit [1:10] v1 [1:5]; // 1 to 10 varies most rapidly
bit v2 [1:5] [1:10]; // 1 to 10 varies most rapidly
bit [1:5] [1:10] v3 ; // 1 to 10 varies most rapidly
bit [1:5] [1:6] v4 [1:7] [1:8]; // 1 to 6 varies most rapidly, followed by 1 to 5, then 1 to 8 and then 1 to 7


Example 1: You can view the setup like this:



Example 2:

bit [1:5][10:16] foo [21:27][31:38];


This is similar as example 1. 



Example 3:

module array(); 

bit [1:5][10:16] foo1 [21:27][31:38],foo2 [31:27][33:38]; 

initial 

begin 

$display("" dimensions of foo1 is %d foo2 is %d"",$dimensions(foo1),$dimensions(foo2) );

end 


The declaration in the above module is as same as

bit [1:5][10:16] foo1 [21:27][31:38];
bit [1:5][10:16] foo2 [31:27][33:38];


As Dave has mentioned, $dimensions function gives you the total number of dimensions packed and unpacked. Sice both foo1 and foo2 are 4 dimensional the displayed value is 4.

For more on this topic please go though the following link. This would clear your all doubts. A nice representation is provided here.
http://testbench.in/SV_09_ARRAYS.html",,,,,
FPGA input into Simulink,"I have a DE2i-150 board. I currently have a Simulink model that introduces a sinusoidal input into an external control system. Rather than using the Simulink library for my input how would I use the board instead. I.E. I'd like to output data from the FPGA board which acts as the sinusoidal generator. The board can output data through USB,data, or serial ports. To clarify, the sinusoidal input I'm talking about is merely a Simulink block. Therefore, theoretically I think I should be able to examine the C program that Simulink creates and know which data to output from my board. Would I need to have Quartus running at the same time? Any ideas or advice would be greatly appreciated. ","I didn't quite understand what you want to do exactly, but here are some ideas that you could start looking up:


writing your own S-Functions to call an external API that accesses your FPGA and generating C with Simulink Coder or Embedded Coder 
writing Custom Storage Classes to call an external API and generating C with Embedded Coder 
converting your model to fixed-point and generating VHDL with HDL Coder.
",,,,,
VHDL - FSM Control,"I'm a beginner and I need a little help . My ""current_s"" is changing whenever rising edge of the clock detected. But, I want it to change only once when ""Dot"" or ""Dash"" is '1'.

I tried to create a signal like: Go_s&lt;=Dot or Dash; 
And then tried to use its rising_edge to enable the process, but I've been told that it's not a good idea. But I can't think anything else.

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;
-------------------------------------------------------------------------------
Entity Let5 is
Port(
Clk: in std_logic;
Reset: in std_logic;
Dot: in std_logic;
Dash: in std_logic;
one_spc: in std_logic;
three_spc: in std_logic);
END Let5;
-------------------------------------------------------------------------------
Architecture Let5_a of Let5 is
-------------------------------------------------------------------------------
Type state is (Start, A, B, A_1, A_2, B_1, B_2);
Signal current_s: state;
-------------------------------------------------------------------------------
BEGIN
---------------------------------------------------------------------------------
PROCESS(Clk, Reset)
BEGIN
    IF(Reset='1')Then
    current_s&lt;=Start;   
    ELSIF(Clk='1' and Clk'event)Then
    Case current_s is

        When Start =&gt;
            IF(Dot='1')Then
                current_s&lt;=A;               
            ELSIF(Dash='1')Then
                current_s&lt;=B;               
            END IF;         

        When A =&gt;       
            IF(Dot='1')Then
                current_s&lt;=A_1;             
            ELSIF(Dash='1')Then
                current_s&lt;=A_2;             
            END IF;     

        When B =&gt;
            IF(Dot='1')Then
                current_s&lt;=B_1;
            ELSIF(Dash='1')Then
                current_s&lt;=B_2;
            END IF;

        When OTHERS =&gt; current_s &lt;= Start;
    END Case;
    END IF;
END PROCESS;
-------------------------------------------------------------------------------
END Let5_a;


Simulation: 

","Add an conditional update of current_s inside the clocked process, using:

...
elsif (Clk='1' and Clk'event) then
  if (Dot = '1') or (Dash = '1') then
    case current_s is
      ...


Then current_s is updated only when the condition (Dot = '1') or (Dash = '1') is TRUE.

It is correct what you have been told, that you should not make an additional signal Go_s checking for rising edge of this, since this is not the way to implement standard synchronous designs.  Instead use a signal clock and make updates on rising edge, for example using rising_edge(Clk) instead of Clk='1' and Clk'event, and then make the updated conditional to whatever signal required.  FPGAs and tools are made to implement this kind of design.",,,,,
"If I disable the IOBs in my custom IP, will it still work? What are the IOBs for anyway?",I'm designing an ethernet mac controller which exceeded the number of IOBs in the Spartan 3E starter kit. I'm planning to disable the IOBs.. Will it still work? What are the IOBs for anyway?,"It will almost certainly not work if you don't have enough IOBs.  IOB = Input/Output Block.  It is a block of logic that resides near each pin inside of Xilinx FPGAs.  The tools are telling you that you don't have enough pins to accomplish what you need to do.  You should create a pinout of your FPGA and map it to the pins on your mac controller.  That information is assigned in the UCF (User Constraints File).  If you don't have enough pins, you will need to either get a new custom IP that is less resource hungry or get a bigger FPGA.",,,,,
Pushbutton Debounce,"As the title suggests, and since I don't know a more formal name for it, my problem is that when I push a button in a 4X4 membrane keypad and while it's being pushed, it adds too many inputs to the system. It seems a silly question but I don't want any hardware components to get rid of this problem. I mean if I have chance to solve it by using only VHDL coding, I will be very glad. To clarify myself, I don't want any sort of code that accomplishes the job. What I am asking is that I just want a method name to start with. (like debouncing pushbuttons) And by the way, I don't want to mess with the clock since I've already divided the clock to determine which button is being pressed in the keypad. But if it is the only solution, then I'm okay with it. 

What I want is simply when the user keeps pushing the button such as 4 in the keypad, it should be seen as one input, but if the user push it again not continually but one at a time, then it should be adding another 4 to the system. Finally, I know the question is very subtle since I didn't provide any code. And as you easily notice, I am new to all this stuff. So, sorry for the inconvenience. Any help will be appreciated, thanks in advance!                ","The thing you are experiencing is due to so called bouncing of the key, which is basically very rapid change in the signal level when a key is pressed and released. Since these changes are all recorded, inputs get added in your case.

You will need to include a key debounce method such as the one explained in this link. One could debounce by increasing the sampling interval, but more elegant way is to have a state machine which avoids re-registering of input, once it is registered. This will achieve the desired effect of the key being held pressed and still only one input being registered.",,,,,
change signal inside a process with if statement - VHDL,"I have this code in VHDL.  What I want is to rise rst when sw'event and afterwards, the rst is to fall by itself.  But when I simulate this, rst never falls! 

process(rst,clk,sw)
    begin
        if (clk'EVENT and clk='1') then
              if (rst='1') then 
                  rst&lt;='0';
              elsif (sw'event) then
                  rst&lt;='1';
              elsif (my_counter=""11"") then
                  deb_sw&lt;=sw;   
              end if;    
        end if;
end process;
","finally i solved it like this

process(rst,clk,sw)
    begin
        if (clk'EVENT and clk='1') then
              if (rst='1' and rst'last_value='0') then 
                  rst&lt;='0';
              elsif (sw='1') then 
                 rst&lt;='1';
                 deb_sw&lt;=sw;
              elsif (my_counter=""1010"") then      -- clock cycles=10*f
                  deb_sw&lt;=sw;   
              end if;    
        end if;
end process;    
",,,,,
synthesize-xst in xillinx get a long time,"I am beginner in verilog and xilinx, and I  am writing a quad port ram in verilog, 

I want to synthesize my code, but although my code is small, it takes a very long time for synthesize witch I force to stop it and I can not synthesize my code.

I don't know where is the problem and what should I do?here is my own code..

module Dram(CLKM,WEA,WEB,WEC,WED,ENA,ENB,ENC,END,DIA,DIB,DIC,DID,ADDRA,ADDRB,ADDRC,ADDRD,DOA,DOB,DOC,DOD);
input WEA,WEB,WEC,WED,ENA,ENB,ENC,END;
input [17:0]DIA,DIB,DIC,DID;
input [9:0]ADDRA,ADDRB,ADDRC,ADDRD;
input CLKM;
output reg [17:0] DOA,DOB,DOC,DOD;
reg state_reg,state_next;
reg [17:0]ram[1023:0];
always@(posedge CLKM)
begin
    state_reg=state_next;
end///edn for always
always@(negedge  CLKM)
begin
    case(state_reg)
        1'b0:
        begin
            if(ENA)
            begin
                if(WEA)
                    ram[ADDRA]&lt;=DIA;
                DOA&lt;=ram[ADDRA];
            end//////for enA
            if(ENB)
            begin
                if(WEB)
                    ram[ADDRB]&lt;=DIB;
                DOB&lt;=ram[ADDRB];
            end////for enB
            state_next=1'b1;
        end////for 1'b0
        1'b1:
        begin
            if(ENC)
            begin
                if(WEC)
                    ram[ADDRC]&lt;=DIC;
                DOC&lt;=ram[ADDRC];
            end
            if(END)
            begin
                if(WED==1'b1)
                    ram[ADDRD]&lt;=DID;
                DOD&lt;=ram[ADDRD];
            end
            state_next=1'b0;
        end///end for 1'b1
    endcase
end//end for always

endmodule


I thought it is a simple code and doesn't get very time, but now I can not synthesize my code? where is the problem? plz help me!!!
thanks","The problem lies in how you access the ram array. You are doing that inside a combinational block. This makes XST to build your RAM using distributed RAM, not block RAM, and builds tons of multiplexers to cover all 1024 possible combinations for ADDRA/ADDRB/ADDRC/ADDRD signals. That is why you are experiencing long synthetizing times.

Rethink your logic so that code like ram[ADDR] &lt;= value or value &lt;= ram[ADDR] is always inside a clock triggered always



After your edited code: I then suggest to separate the quadport RAM logic from the RAM logic itself. You relay on a standard single port RAM module, and then using a FSM, makes it act as if it would have many ports, don't you? Your single port RAM, and the source of your headaches can be described as this:

module spram (input wire clk,
  input wire en,
  input wire we,
  input wire [9:0] addr,
  input wire [17:0] din,
  output reg [17:0] dout
  );

  reg [17:0] ram[0:1023];

  always @(negedge clk) begin
    if (en) begin
      if (we) begin
        ram[addr] &lt;= din;
      end
      dout &lt;= ram[addr];
    end
  end
endmodule


Describing the memory this way will help XST to infere it as a block RAM device, as pointed by the advanced syntesis report:

Synthesizing (advanced) Unit &lt;spram&gt;.
INFO:Xst:3040 - The RAM &lt;Mram_ram&gt; will be implemented as a BLOCK RAM, absorbing the following register(s): &lt;dout&gt;
    -----------------------------------------------------------------------
    | ram_type           | Block                               |          |
    -----------------------------------------------------------------------
    | Port A                                                              |
    |     aspect ratio   | 1024-word x 18-bit                  |          |
    |     mode           | read-first                          |          |
    |     clkA           | connected to signal &lt;clk&gt;           | fall     |
    |     enA            | connected to signal &lt;en&gt;            | high     |
    |     weA            | connected to signal &lt;we&gt;            | high     |
    |     addrA          | connected to signal &lt;addr&gt;          |          |
    |     diA            | connected to signal &lt;din&gt;           |          |
    |     doA            | connected to signal &lt;dout&gt;          |          |
    -----------------------------------------------------------------------
    | optimization       | speed                               |          |
    -----------------------------------------------------------------------
Unit &lt;spram&gt; synthesized (advanced).


Then you can instantiate this RAM into your quadport design and multiplex signals depending on what state you are. Something like this:

module qpram (input wire clk,
  input wire [3:0] en,
  input wire [3:0] we,
  input wire [9:0] addra,
  input wire [9:0] addrb,
  input wire [9:0] addrc,
  input wire [9:0] addrd,
  input wire [17:0] dina,
  input wire [17:0] dinb,
  input wire [17:0] dinc,
  input wire [17:0] dind,
  output reg [17:0] douta,
  output reg [17:0] doutb,
  output reg [17:0] doutc,
  output reg [17:0] doutd
  );

  reg [1:0] port = 2'b00; /* indicates which port is active */
  always @(negedge clk) begin
    port &lt;= port + 1;
  end

  /* instantiate single port RAM */
  reg enable,write;
  reg [17:0] din;
  wire [17:0] dout;
  reg [9:0] addr;
  spram myram (clk,enable,write,addr,din,dout);

  /* multiplexers to assign right inputs to RAM
  depending on which port we are in */
  always @* begin
    case (port)
      2'b00 : begin
                addr = addra;
                write = we[0];
                enable = en[0];
                din = dina;
              end
      2'b01 : begin
                addr = addrb;
                write = we[1];
                enable = en[1];
                din = dinb;
              end
      2'b10 : begin
                addr = addrc;
                write = we[2];
                enable = en[2];
                din = dinc;
              end
      2'b11 : begin
                addr = addrd;
                write = we[3];
                enable = en[3];
                din = dinc;
              end
    endcase
  end

  /* data out is available at the end of each clock cycle */
  always @(negedge clk) begin
    case (port)
      2'b00 : douta &lt;= dout;
      2'b01 : doutb &lt;= dout;
      2'b10 : doutc &lt;= dout;
      2'b11 : doutd &lt;= dout;
    endcase
  end
endmodule
",,,,,
How can I create a task which drives an output across time without using globals?,"I want to write some tasks in a package, and then import that package in some files that use those tasks.

One of these tasks toggles a reset signal. The task is reset_board and the code is as follows:

package tb_pkg;
    task reset_board(output logic rst);
        rst &lt;= 1'b0;
        #1;
        rst &lt;= 1'b1;
        #1;
        rst &lt;= 1'b0;
        #1;
    endtask
endpackage


However, if I understand this correctly, outputs are only assigned at the end of execution, so in this case, the rst signal will just get set to 0 at the end of the task's execution, which is obviously not what I want.

If this task were declared locally in the module in which it is used, I could refer to the rst signal directly (since it is declared in the module). However, this would not allow me to put the task in a separate package. I could put the task in a file and then `include it in the module, but I'm trying to avoid the nasty complications that come with the way SystemVerilog handles includes (long-story-short, it doesn't work the way C does).

So, is there any way that the task can drive an output with different values across the duration of its execution without it having to refer to a global variable?","A quick solution is to use a ref that passes the task argument by reference instead of an output argument that is copied after returning from the task.

task reset_board(ref logic rst);

There are a few drawbacks of doing it this way. You can only pass variables of matching types by reference, so when you call reset_board(*signal*), signal cannot be a wire. Another problem is you cannot use an NBA &lt;= to assign a variable passed by reference, you must use a blocking assignment =. This is because you are allowed to pass automatic variables by reference to a task, but automatic variable are not allowed to be assigned by NBAs. There is no way for the task to check the storage type of the argument passed to it.

Standard methodologies like the UVM recommend using virtual interfaces or abstract classes to create these kinds of connections from the testbench to the DUT. See my DVCon paper for more information.",,,,,
Right shifting a carry save number,"Carry save arithmetic uses twice the number of bits, one word to hold the ""virtual sum"", one to hold the ""virtual carry"" to avoid propagating the carry which is the limiting factor in hardware speed.

I have a system that requires dividing these numbers by powers of two, but simply right shifting both numbers does not work in all cases eg. two 16 bit carry save numbers, which you add to produce 4000, C001 is the Virtual Sum, 7FFF is the virtual carry.

C001 + 7FFF = 4000  (discard overflow bits)
but after right shift
6000 + 3FFF = 9FFF   (when it should be 2000)


In short: How do you divide a carry save number by a power of two? (While keeping it a carry save number)","First, right shift by 1 effectively does deleting by 2 with forgetting a remainder. But the remainder could be needed for having the exact result. For instance, change your initial example with adding C000 to 8000, or C002 to 7FFE. Both give the same sum but, sum of shifted values is A000 instead of your 9FFF, and this is definitely more correct. So, you can do such shifting only if sum of LSBs could be lost. In your case with 2 summands and 1 bit shift, this means no more than 1 summand could have 1 in its LSB.

Second, consider this is fixed and you've got A000. A simple ideal math says (a+b)/2 == a/2 + b/2. For your case, the carry bit you initially ignored weighed 0x10000, but after shifting by 1, it weighs 0x8000. That is exactly how A000 differs from your expected 2000. So, if you are sure in other aspects of your method, finish it with logical AND with ~0x8000 == 0x7FFF.",,,,,
Wrong output after implementing given equation,"I am new to Verilog. While implementing this function:

data_out = [ [data_in / ( |data_in| + 1 ) ] + 1 ] / 2


I am not getting correct output. Can someone tell me how to write Verilog code to implement this function? I am sending my code and test bench. Please correct me where I am wrong.

module act_fun(data_out,data_in);
  input  [22:0] data_in;
  output [22:0] data_out;
  reg    [22:0] data_out;
  reg    [22:0] mod;
  reg    [22:0] mod1;
  reg    [22:0] mod2;

  always @(data_in)
  begin 
    mod      = data_in + 23'b1;
    mod1     = data_in/mod;
    mod2     = mod1 + 23'b1;
    data_out = mod2&gt;&gt;1'b1;
  end

endmodule


testbench

module act_tst;
  // Inputs
  reg [22:0] data_in;
  // Outputs
  wire [22:0] data_out;

  // Instantiate the Unit Under Test (UUT)
  act_fun uut (
    .data_out(data_out), 
    .data_in(data_in)
  );

  initial 
  begin
    data_in    = 23'b00000000000000000000000;
    #5 data_in = 23'b00000000000000000010000;
    #5 data_in = 23'b00000000000000001001100;
    #5 data_in = 23'b00000000000000111100010;
  end      
endmodule


output:

data_out = 0000000000000000000000
5 data_out = 0000000000000000000000
5 data_out = 0000000000000000000000
","If you look at this in a wave form window or print more information on you internal mod variables you will notice that mod1 never changes, always 0.

mod1     = data_in/mod;


I previously answered this question regarding how the output from a multiply is expanded based on the input wordlengths. The same is true for Division.

mod1 will never reach 1, i.e. is max value is + ve infinity / (+ve infinity + 1). you are performing an integer divide so the answer is always 0. 

You need to decide how many fractional places you require and pad the numerator. The answer will then be fractional and you have to keep track of the binary point through out your calculations.

Example

module act_fun(
  input      [22:0] data_in,
  output reg [22:0] data_out
);
  reg    [22:0] mod;
  reg    [22:0] mod1;
  reg    [22:0] mod2;

  always @(data_in) begin 
    mod      = data_in + 23'b1;
    mod1     = {data_in, 10'b0}/mod; //Adding 10 fractional bits
    mod2     = mod1 + 23'b1;
    data_out = mod2&gt;&gt;1'b1;
  end

endmodule


Verification

For verification you might want to consider evaluating the equation (model) using reals and applying a tolerance relevant to the number of fractional bits you added.

real data_in_r
real data_out_r 
always @* begin
  data_out_r = (( data_in / ( (data_in+1 ))+1 ) / 2 ;
end
",,,,,
How to Rewrite FSM not to use Latches,"I have an FSM and it works. The synthesizer, however, complains that there are latches for ""acc_x"", ""acc_y"", and ""data_out"" and I understand why and why it is bad. I have no idea, however, how to rewrite the FSM so the state-part goes to the clocked process. Any ideas where to start from? Here is the code of the FSM:



library IEEE;

use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity storage is
    port
    (
        clk_in                           : in  std_logic;
        reset                            : in  std_logic;
        element_in                       : in  std_logic;
        data_in                          : in  signed(11 downto 0);
        addr                             : in  unsigned(9 downto 0);
        add                              : in  std_logic; -- add = '1' means add to RAM
                                                          -- add = '0' means write to RAM
        dump                             : in  std_logic;
        element_out                      : out std_logic;
        data_out                         : out signed(31 downto 0)
    );
end storage;

architecture rtl of storage is
    component bram is
    port
    (
        clk                              : in  std_logic;
        we                               : in  std_logic;
        en                               : in  std_logic;
        addr                             : in  unsigned(9 downto 0);
        di                               : in  signed(31 downto 0);
        do                               : out signed(31 downto 0)
    );
    end component bram;

    type state is (st_startwait, st_add, st_write);

    signal current_state                 : state := st_startwait;
    signal next_state                    : state := st_startwait;

    signal we                            : std_logic;
    signal en                            : std_logic;
    signal di                            : signed(31 downto 0);
    signal do                            : signed(31 downto 0);

    signal acc_x                         : signed(31 downto 0);
    signal acc_y                         : signed(31 downto 0);
begin
    ram : bram port map
    (
        clk  =&gt; clk_in,
        we   =&gt; we,
        en   =&gt; en,
        addr =&gt; addr,
        di   =&gt; di,
        do   =&gt; do  
    );

    process(clk_in)
    begin
        if rising_edge(clk_in) then
            if (reset = '1') then
                current_state           &lt;= st_startwait;
            else
                current_state           &lt;= next_state;
            end if;
        end if;
    end process;

    process(current_state, element_in, add, dump, data_in, do, acc_x, acc_y)
    begin
        element_out                     &lt;= '0';

        en                              &lt;= '1';
        we                              &lt;= '0';

        di                              &lt;= (others =&gt; '0');

        case current_state is
            when st_startwait =&gt;          
                if (element_in = '1') then
                    acc_x               &lt;= resize(data_in, acc_x'length);

                    next_state          &lt;= st_add;
                else
                    next_state          &lt;= st_startwait;
                end if;
            when st_add =&gt;
                if (add = '1') then
                    acc_y               &lt;= acc_x + do;
                else
                    acc_y               &lt;= acc_x;
                end if;

                next_state              &lt;= st_write;
            when st_write =&gt;      
                if (dump = '1') then
                    data_out            &lt;= acc_y;
                    element_out         &lt;= '1';
                else
                    di                  &lt;= acc_y;
                    we                  &lt;= '1';
                end if;

                next_state              &lt;= st_startwait;
        end case;
    end process;  
end rtl;


","This is personal preference, but I think most people on here will agree with me on this one... do not use two processes to control your state machine.  The whole previous_state next_state thing is total garbage in my opinion.  It's really confusing and it tends to make latches - SURPRISE - You found that out.  Try rewriting your state machine with a single clocked process and only one state machine signal.

Here's my attempt at rewriting your state machine.  Note that I'm not sure the functionality that I have below will work for you.  Simulate it to make sure it behaves the way you expect.  For example the signal en is always tied to '1', not sure if you want that...

process (clk_in)
begin
  if rising_edge(clk_in) then
    element_out &lt;= '0';
    en &lt;= '1';                      -- this is set to 1 always?
    we &lt;= '0';

    di &lt;= (others =&gt; '0');

    case state is

      when st_startwait =&gt;
        if (element_in = '1') then
          acc_x &lt;= resize(data_in, acc_x'length);
          state &lt;= st_add;
        end if;

      when st_add =&gt;
        if (add = '1') then
          acc_y &lt;= acc_x + do;
        else
          acc_y &lt;= acc_x;
        end if;
        state &lt;= st_write;

      when st_write =&gt;
        if (dump = '1') then
          data_out    &lt;= acc_y;
          element_out &lt;= '1';
        else
          di &lt;= acc_y;
          we &lt;= '1';
        end if;
        state &lt;= st_startwait;
    end case;
  end if;
end process;
",,,,,
warnings while running code in xilinx,"In the following code: First, I am loading ROM with data and weight at given address. In the same clock I am doing multiplication of data and weight. Finally, I am extending the number of bits from 16-bit to 23-bit. The code compiles without errors but has warnings. I am unable to solve these warnings. 

module main_module(extended_out,mux_out,data,weight,clk,en,addr);
input clk,en;
input [2:0] addr;
output [7:0] data,weight;
output [15:0] mux_out;
output [22:0] extended_out;

ram_input a1 (clk, en, addr, data);
ram_weight a2 (clk, en, addr, weight);
top_module a3 (mux_out,data,weight);
SignExtender a4 (clk,mux_out,extended_out);

endmodule


###################    MODULE 1 ########################################

module ram_input (clk, en, addr, data);
 input clk;
 input en;
 input [2:0] addr;
 output reg [7:0] data;

 reg   [2:0] raddr;
 always @(posedge clk)
 begin
    if (en)
         raddr &lt;= addr;
 end

 always @(raddr,en) 
 begin
    if (en)
    begin
       case(raddr)
         3'b000: data = 8'b0000_0010;
         3'b001: data = 8'b0000_0110;
         3'b010: data = 8'b0000_1110;
         3'b011: data = 8'b0000_0010;
         3'b100: data = 8'b0000_0100;
         3'b101: data = 8'b0000_1010;
         3'b110: data = 8'b0000_1100;
         3'b111: data = 8'b0000_0000;
         default: data = 8'b0000_XXXX;
       endcase
    end  
    else
       data = 8'b0000_0000;
 end

endmodule


####################################### MODULE 2 ########################

module ram_weight (clk, en, addr, weight);
 input clk;
 input en;
 input [2:0] addr;
 output reg [7:0] weight;

 reg   [2:0] raddr;
 always @(posedge clk)
 begin
    if (en)
       raddr &lt;= addr;
 end

 always @(raddr,en) 
 begin
    if (en)
    begin
       case(raddr)
          3'b000: weight = 8'b0000_1000;
          3'b001: weight = 8'b0000_1010;
          3'b010: weight = 8'b0001_1101;
          3'b011: weight = 8'b0001_0100;
          3'b100: weight = 8'b0000_0111;
          3'b101: weight = 8'b0001_0010;
          3'b110: weight = 8'b0010_1000;
          3'b111: weight = 8'b0011_1111;
          default: weight = 8'b0000_XXXX;
       endcase
    end
    else
       weight = 8'b0000_0000;
 end

endmodule


############################33  MODULE--3 #####################

module top_module(p,x,y); 
 output [15:0]p;
 input [7:0]x,y;
 reg [15:0]p;

 reg [15:0]a;
 integer i; 

 always @(x , y)
 begin
    a=x;
    p=0;
    for(i=0;i&lt;8;i=i+1)
    begin
       if(y[i])
          p=p+a;
       a=a&lt;&lt;1;
    end
 end

endmodule


############################## MOdule ----4  #############################

module SignExtender( clk, extend, extended );
 input[15:0] extend;
 input clk;
 output[22:0] extended;
 reg[22:0] extended;
 wire [15:0] extend;

 always @( posedge clk)
 begin
    extended[22:0] &lt;= { {7{extend[15]}}, extend[15:0] };
 end

endmodule


###############################  ERROR   ####################

WARNING 646 - Signal ""a"" is assigned but never used. This unconnected signal will be trimmed during the optimization process.

WARNING 1710 - ""FF/Latch a4/extended_15"" (without init value) has a constant value of 0 in block main_module. This FF/Latch will be trimmed during the optimization process.

WARNING:Xst:1895 - Due to other """"FF/Latch trimming"""", FF/Latch """"a4/extended_14"""" (without init value) has a constant value of 0 in block ""main_module"". This FF/Latch will be trimmed during the optimization process.

WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch """"a4/extended_13"""" (without init value) has a constant value of 0 in block """"main_module"""". This FF/Latch will be trimmed during the optimization process.

WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch """"a4/extended_12"""" (without init value) has a constant value of 0 in block """"main_module"""". This FF/Latch will be trimmed during the optimization process.

WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch """"a4/extended_11"""" (without init value) has a constant value of 0 in block """"main_module"""". This FF/Latch will be trimmed during the optimization process.

WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch """"a4/extended_10"""" (without init value) has a constant value of 0 in block """"main_module"""". This FF/Latch will be trimmed during the optimization process.

WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch """"a4/extended_0"""" (without init value) has a constant value of 0 in block """"main_module"""". This FF/Latch will be trimmed during the optimization process.

warning--1 says you didn't use constant ""a"" variable but while doing multiplication I took as an temporary register but remaining errors I don't understand what they really going to tell...

Please help explain these warnings.","Your basic problem is probably the p=p+a in top_module. This doesn't make sense; try to draw the schematic. This is a combinatorial path with the output of an adder fed back to its input. Get rid of it, and just add together the , depending on the relevant bit of y. This may be enough to get you going.

EDIT

Your code is unlikely to be (correctly) synthesisable (by any sane synthesiser, anyway). Consider this:

always @(x , y)
 begin
    a=x;
    p=0;
    for(i=0;i&lt;8;i=i+1)
    begin
       if(y[i])
          p=p+a;
       a=a&lt;&lt;1;
    end
 end 


This is combinatorial code. You are asking the synthesiser to unroll your i loop. Every time x or y changes, you want the synthesiser to evaluate all 8 loop iterations, shifting a, and accumulating to p. Synthesisers are normally pretty good at loop unrolling, but this one is pushing it. Get rid of the loop, whether or not you think XST understands it; it's just bad practice, and is probably confusing XST. Draw a schematic on paper. All you're doing is shifting a: you've got one unmodified a, and 7 instances where a is shifted by 1 to 7 bits. You need an adder which adds together all 8 busses, but you only add in bus i if the corresponding bit of y is set. In other words, each input to the adder has a multiplexer on it; one input is held to zero, the other is your shifted a. You'll need to write the code yourself. This is how you do hardware design: break everything down into basic units - multiplexers, shifters, adders, whatever, and wire them togehter. Don't write behavioural code that your synthesiser has to try to work out for you; that's software, not hardware.

Greg may be right in that your actual circuit can be simplified according to your actual input conditions, and that this circuit is eventually unused anyway; it's not a 5-minute job to confirm that, and it's pointless anyway. You're trying to write a multiplier, and your input conditions will change, and you need to get the code right. XST may, or may not, be able to work out that in any particular situation it can simplify the logic, but you have to fix your input code first.

You have other issues. Don't assign X's to your variables as Don't Cares. This is very bad practice, and will go wrong. Read Mike Turpin's paper, among others. In short, never use X's unless you know exactly what you're doing. Use non-blocking assignments in the x/y always block. There may be other issues, which aren't obvious on a very quick read-through.",,,,,
Why Does This VHDL Work in Sumulation and Does not Work on the Virtex 5 Device,"I have spent the whole day trying to solve the following problem. I am building a small averaging multichannel oscilloscope and I have the following module for storing the signal:



library IEEE;

use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;
use IEEE.numeric_std.all;

entity storage is
    port
    (
        clk_in                           : in  std_logic;
        reset                            : in  std_logic;
        element_in                       : in  std_logic;
        data_in                          : in  std_logic_vector(11 downto 0);
        addr                             : in  std_logic_vector(9 downto 0);
        add                              : in  std_logic; -- add = '1' means add to RAM
                                                          -- add = '0' means write to RAM
        dump                             : in  std_logic;
        element_out                      : out std_logic;
        data_out                         : out std_logic_vector(31 downto 0)
    );
end storage;

architecture rtl of storage is
    component bram is
    port
    (
        clk                              : in  std_logic;
        we                               : in  std_logic;
        en                               : in  std_logic;
        addr                             : in  std_logic_vector(9 downto 0);
        di                               : in  std_logic_vector(31 downto 0);
        do                               : out std_logic_vector(31 downto 0)
    );
    end component bram;

    type state is (st_startwait, st_add, st_write);

    signal current_state                 : state := st_startwait;
    signal next_state                    : state := st_startwait;

    signal start                         : std_logic;

    signal we                            : std_logic;
    signal en                            : std_logic;
    signal di                            : std_logic_vector(31 downto 0);
    signal do                            : std_logic_vector(31 downto 0);

    signal data                          : std_logic_vector(11 downto 0);
begin
    ram : bram port map
    (
        clk  =&gt; clk_in,
        we   =&gt; we,
        en   =&gt; en,
        addr =&gt; addr,
        di   =&gt; di,
        do   =&gt; do  
    );

    process(clk_in, reset, start)
    begin
        if rising_edge(clk_in) then
            if (reset = '1') then
                current_state           &lt;= st_startwait;
            else
                start                   &lt;= '0';
                current_state           &lt;= next_state;

                if (element_in = '1') then
                    start               &lt;= '1';
                end if;
            end if;
        end if;
    end process;

    process(current_state, start, dump)
        variable acc                    : std_logic_vector(31 downto 0);
    begin
        element_out                       &lt;= '0';

        en                                &lt;= '1';
        we                                &lt;= '0';

        case current_state is
            when st_startwait =&gt;          
                if (start = '1') then
                    acc(11 downto 0)    := data_in;
                    acc(31 downto 12)   := (others =&gt; '0');

                    next_state          &lt;= st_add;
                else
                    next_state          &lt;= st_startwait;
                end if;
            when st_add =&gt;
                if (add = '1') then
                    acc                 := acc + do;
                end if;

                we                      &lt;= '1';
                di                      &lt;= acc;

                next_state              &lt;= st_write;
            when st_write =&gt;      
                if (dump = '1') then
                    data_out            &lt;= acc;
                    element_out         &lt;= '1';
                end if;

                next_state              &lt;= st_startwait;
        end case;
    end process;  
end rtl;




Below is the BRAM module as copied from the XST manual. This is a no-change type of BRAM and I believe there is the problem. The symptom is that, while this simulates fine, I read only zeroes from the memory when I use the design on the device.



library IEEE;

use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;

entity bram is
    port
    (
        clk  : in  std_logic;
        we   : in  std_logic;
        en   : in  std_logic;
        addr : in  std_logic_vector(9 downto 0);
        di   : in  std_logic_vector(31 downto 0);
        do   : out std_logic_vector(31 downto 0)
    );
end bram;

architecture rtl of bram is
    type ram_type is array (0 to 999) of std_logic_vector (31 downto 0);
    signal buf : ram_type;
begin
    process(clk, en, we)
    begin
        if rising_edge(clk) then
            if en = '1' then
                if we = '1' then
                    buf(conv_integer(addr)) &lt;= di;
                else
                    do &lt;= buf(conv_integer(addr));
                end if;
            end if;
        end if;
    end process;
end rtl;




What follows is a description of the chip use and the expected output. ""clk_in"" is a 50 MHz clock. ""element_in"" is '1' for 20 ns and '0' for 60 ns. ""addr_in"" iterates from 0 to 999 and changes every 80 ns. ""element_in"", ""data_in"", and ""addr"" are all aligned and synchronous. Now ""add"" is '1' for 1000 elements, then both ""add"" and ""dump"" are zero for 8000 elements and, finally ""dump"" is '1' for 1000 elements. Now, if I have a test bench that supplies ""data_in"" from 0 to 999, I expect data_out to be 0, 10, 20, 30, ..., 9990 when ""dump"" is '1'. That is according to the simulation. In reality I get 0, 1, 2, 3, ..., 999....","Some initial issues to address are listed below.



The process(current_state, start, dump) in storage entity looks like it is
intended to implement a combinatorial element (gates), but the signal (port)
data_in is not in the sensitivity list.

This is very likely to cause a difference between simulation and synthesis
behavior, since simulation will typically only react to the signals in the
sensitivity list, where synthesis will implement the combinatorial design and
react on all used signals, but may give a warning about incomplete sensitivity
list or inferred latches.  If you are using VHDL-2008 then use can use a
sensitivity list of (all) to have the process sensitivity to all used
signals, and otherwise you need to add missing signals manually.



The case current_state is in process(current_state, start, dump) lacks an
when others =&gt; ..., so the synthesis tool has probably given you a warning
about inferred latches.  This should be fixed by adding the when others =&gt;
with and assign all signals driven by the process to the relevant value.



The use clause lists:

use IEEE.std_logic_unsigned.all;
use IEEE.numeric_std.all;


But both of these should not be used at the same time, since they declare some
of the same identifiers, for example is unsigned declared in both.  Since the
RAM uses std_logic_unsigned I suggest that you stick with that only, and
delete use of numeric_std.  For new code I would though recommend use of
numeric_std.



Also the process(clk_in, reset, start) in storage entity implements a
sequential element (flip flop) sensitive to only rising edge of clk_in, so
the two last signals in sensitivity list ..., reset, start) are unnecessary,
but does not cause a problem.",,,,,
FF/Latches: signal (xxx) has a constant value of 0 - VHDL Synthesis,"This question has been asked before but still I am unable to fix the problem in my code. What is wrong in my code, which is giving these warnings?

use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.all;

use work.switch_param.all;


entity fault_gen is
port (
  clk           : in  std_logic;
  rst           : in  std_logic;
  buff_free     : in  std_logic;
  i_fault_gen   : in  std_logic_vector(NUM_PORTS -1 downto 0);
  o_sel         : out std_logic_vector(NUM_PORTS -1 downto 0);
  o_valid       : out std_logic;
  o_fault_gen   : out flit_t
  );
end fault_gen;

architecture Behavioral of fault_gen is
type ftgen_state is (idle, compt, final);
signal current_state, next_state : ftgen_state;
signal ft_current, ft_next : flit_t;
signal temp_gen : std_logic_vector(FT_INFO_BITS - 1 downto 0);
signal enable : std_logic;

begin
proc_state: process(clk, rst)
begin 
    if (rst = '1') then
        current_state &lt;= idle;
        ft_current &lt;= (others =&gt; '0');
    elsif (clk'event and clk='1') then
        current_state &lt;= next_state;
        ft_current &lt;= ft_next;
    end if;
end process proc_state;


proc_fault: process(current_state, ft_current, i_fault_gen, buff_free)
begin
    temp_gen &lt;= (others =&gt; '0');
    o_sel &lt;= (others =&gt; '0');
    o_valid &lt;= '0';
    enable &lt;= '0';
    ft_next &lt;= ft_current;

    case current_state is

      when idle     =&gt;
        if (buff_free = '1')  then
            if (i_fault_gen = (i_fault_gen'range =&gt; '0')) then
                next_state &lt;= idle;
            else
                next_state &lt;= compt;
            end if;
        else
          next_state &lt;= idle;
        end if;

      when compt    =&gt;
        next_state &lt;= final;
        ftgen_inst: for i in NUM_PORTS -1 downto 0 loop
            if (i_fault_gen(i) = '1')  then
              temp_gen &lt;= std_logic_vector(to_unsigned(i,FT_INFO_BITS));
              o_sel(i) &lt;= '1';
              enable &lt;= '1';
              exit ftgen_inst;
            end if;
        end loop;  -- i

      when final    =&gt;
        next_state &lt;= idle;
        if (enable = '1') then
            ft_next &lt;= FT_INFO &amp; link_fault &amp; temp_gen &amp; switch_ID &amp; reserved_bits;
            o_valid &lt;= '1';
        else
            next_state &lt;= idle;
        end if;

      when others   =&gt;
        next_state &lt;= idle;

    end case;
end process proc_fault;

o_fault_gen &lt;= ft_current;    

end Behavioral;


In this program, the value of signal temp_gen is changing and rest of parameters are constant.

switch parameters are:

package switch_param is
constant NUM_PORTS    : natural       := 5;
constant FLIT_WIDTH   : natural:= 36;
subtype flit_t is std_logic_vector(FLIT_WIDTH - 1 downto 0);
constant FT_INFO : std_logic_vector(3 downto 0) := ""0011"";
constant link_fault : std_logic_vector(2 downto 0) := ""000"";
constant reserved_bits : std_logic_vector(17 downto 0) := (others =&gt; '0');
constant FT_INFO_BITS : integer := 3;
constant switch_ID : std_logic_vector(7 downto 0)       := ""11111111"";    -- switch ID

end switch_param;


warnings are: 

WARNING:Xst:2404 -  FFs/Latches &lt;ft_current&lt;35:34&gt;&gt; (without init value) have a constant value of 0 in block &lt;fault_gen&gt;.
WARNING:Xst:1710 - FF/Latch &lt;ft_current_31&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_30&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_29&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_17&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_16&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_15&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_14&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_13&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_12&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_11&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_10&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_9&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_8&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_7&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_6&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_5&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_4&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_3&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_2&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_1&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_0&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1710 - FF/Latch &lt;ft_current_18&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_26&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_27&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_28&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1710 - FF/Latch &lt;ft_current_18&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_26&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_27&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_28&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1710 - FF/Latch &lt;ft_current_18&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_26&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_27&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_28&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1710 - FF/Latch &lt;ft_current_18&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_26&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_27&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
WARNING:Xst:1895 - Due to other FF/Latch trimming, FF/Latch &lt;ft_current_28&gt; (without init value) has a constant value of 0 in block &lt;fault_gen&gt;. This FF/Latch will be trimmed during the optimization process.
","From you package values I generated this:

    -- Field      Size              Contents         ft_next range   static?
    ------------------------------------------------------------------------
    -- FT_INFO    (3 downto 0)      ""0011""            35 downto 32 static
    -- link_fault (2 downto 0)      ""000""             31 downto 29 static
    -- temp_gen   (2 downto 0)      ""011""             28 downto 26 changeable
    -- switch_ID  (7 downto 0)      ""11111111""        25 downto 18 static
    -- reserved_bits (17 downto 0)  (other s=&gt; '0')   17 downto 0  static


       ft_next &lt;= FT_INFO &amp; link_fault &amp; temp_gen &amp; switch_ID &amp; reserved_bits;


There are only three non-static bits assigned to ft_next (temp_gen - possible values ""100"", ""011"" ,""010"", ""001"" and ""000"").

All the rest of the locally static (known at analysis time), meaning they don't need flip flops.  You ended up with three.

I'd originally gotten the order of the arguments to TO_UNISIGNED backward, but after getting that straight (and it tells you to verify everything you rely on in an answer) you notice the loop:

  when compt    =&gt;
    next_state &lt;= final;
    ftgen_inst: for i in NUM_PORTS -1 downto 0 loop
        if (i_fault_gen(i) = '1')  then
          temp_gen &lt;= std_logic_vector(to_unsigned(i,FT_INFO_BITS));
          o_sel(i) &lt;= '1';
          enable &lt;= '1';
          exit ftgen_inst;
        end if;
    end loop;  -- i


One of the characteristics of assigning signals in a process statement is that there is only one future value for a signal.  It means the last fault_gen(i) with a '1' is the one that actually gets reported, with ascending priority downto 0.  You might consider having temp_gen replaced by i_fault_gen should that be unacceptable.

Anyway, the way you have defined ft_next, there are only three flip flops needed, the rest of the bits are all static.",,,,,
iCE40 Ultra Plus 5k â€?how to set PLL (without propietary GUI tools) (continued),"In this question, I was suggested to use the existing libraries in order to test a PLL for the iCE40 Ultra Plus 5k.
I bought the Icebreaker V1.0e board and it looks like this:

External 12 MHz oscilator is connected to the pin 35 (marked green) of the Lattice iCE40UP5k (package SG48).

Pin 35 has function: IOT_46b_G0, type: DPIO/GBIN0 and is located
in bank: 0).

When I searched the library that I posted above, I found a nice primitive SB_PLL40_PAD on the page 98. This primitive's description precisely matches what was done on the Icebreaker V1.0e schematics. Here is the description:

Please observe that it matches with the pin description above! Now, I want to use this in my VHDL so for start I only wrote a VHDL wrapper for this primitive:
-- A:
library ieee;
use ieee.std_logic_1164.all;

-- B:
entity pll_icebreaker is port(
    C1_1: in std_ulogic;
    C1_2: out std_ulogic;
    C1_3: out std_ulogic;
    C1_4: out std_ulogic;
    C1_5: in std_ulogic;
    C1_6: in std_ulogic_vector (6 downto 0);
    C1_7: in std_ulogic;
    C1_8: in std_ulogic;
    C1_9: in std_ulogic
);
end pll_icebreaker;

-- C:
architecture logic_001 of pll_icebreaker is

    -- D:
    component SB_PLL_40_PAD is port (
        PACKAGEPIN: in std_ulogic;
        PLLOUTGLOBAL: out std_ulogic;
        PLLOUTCORE: out std_ulogic;
        LOCK: out std_ulogic;
        EXTFEEDBACK: in std_ulogic;
        DYNAMICDELAY: in std_ulogic_vector (6 downto 0);
        RESETB: in std_ulogic;
        BYPASS: in std_ulogic;
        LATCHINPUTVALUE: in std_ulogic
    );
    end component;

begin

    -- E:
    C1: SB_PLL_40_PAD port map(
        PACKAGEPIN =&gt; C1_1,
        PLLOUTGLOBAL =&gt; C1_2,
        PLLOUTCORE =&gt; C1_3,
        LOCK =&gt; C1_4,
        EXTFEEDBACK =&gt; C1_5,
        DYNAMICDELAY =&gt; C1_6,
        RESETB =&gt; C1_7,
        BYPASS =&gt; C1_8,
        LATCHINPUTVALUE =&gt; C1_9
    );

end architecture logic_001;

Now I try to compile this VHDL design using this makefile target all (only FOSS tools are used):
# A:
file_main = pll_icebreaker
file_pcf = icebreaker

module_top = pll_icebreaker
entity_top = $(module_top)

####################################################################################################

# B:
all:
    yosys \
        -m ghdl \
        -p &quot;ghdl $(file_main).vhdl -e $(entity_top); write_verilog $(file_main).v&quot;
    yosys \
        -p &quot;synth_ice40 -top $(module_top) -blif $(file_main).blif&quot; \
        $(file_main).v
    arachne-pnr \
        -d 5k \
        -P sg48 \
        -o $(file_main).asc \
        -p $(file_pcf).pcf $(file_main).blif
    icepack $(file_main).asc $(file_main).bin

And my toolchain complains that it can not find the module SB_PLL_40_PAD:
2.2.1. Analyzing design hierarchy..
Top module:  \pll_icebreaker
ERROR: Module `\SB_PLL_40_PAD' referenced in module `\pll_icebreaker' in cell `\c1' is not part of the design.
make: *** [makefile:81: all] Error 1

How come? Isn't the Lattice technology library implemented in Yosys tools? I am a bit confused... How can I solve this problem?","It looks like I can't read. Lattice technology library mentions SB_PLL40_PAD:

and I used SB_PLL_40_PAD... So of course it could not work! Now it compiles!
So I have a start here in order to create a nice PLL example that is using pre-existing hardware inside FPGA!",,,,,
Error (10448): VHDL error at teste.vhd(33): record type std_ulogic is used but not declared,"I was trying to do a work and this error is boring me, i pass to a new project teste.vhdl and this keep happening, i need to have two barriers of clock one for input and another to output, to use timequest with combinational logic.
The 'and' is just a example.
library ieee;
use ieee.std_logic_1164.all;
--use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;

ENTITY teste IS
PORT(
    clock :     in std_logic;
    clear :     in std_logic;
    a       :   in std_logic_vector(3 downto 0);
    b       :   in std_logic_vector(3 downto 0);
    s       :   out std_logic_vector(3 downto 0)
);
END teste;

ARCHITECTURE comportamento OF teste IS
signal a1,b1,s1 : std_logic_vector(3 downto 0);
begin

FF_in: process(clock.clear)
 begin
    if clear = '1' then
        a1 &lt;= &quot;0000&quot;;
        b1 &lt;= &quot;0000&quot;;
    elsif clock'event and clock = '1' then
        a1 &lt;= a;
        b1 &lt;= b;
    end if;
end process;
    
    s1 &lt;= a1 and b1;
    
FF_out: process(clock.clear)
 begin
    if clear = '1' then
        s &lt;= &quot;0000&quot;;
    elsif clock'event and clock = '1' then
        s &lt;= s1;
    end if;
end process;
    
END comportamento;
","You have used a . Rather than , in the process sensitivity list. Using a . Is trying to access a record field.",,,,,
"After installing Libreoffice service on Linux server with ROOT user, normal user cannot call Libreoffice API","System: Centos 7.
Installed Libreoffice service with root user, and when switching to normal user abc to call the API, it prompts.
javaldx failed!
Warning: failed to read path from javaldx

Call command:  /usr/bin/libreoffice7.0 --headless --convert-to pdf a.xlsx --outdir a.pdf
originally intended to use php exec to execute the Libreoffice API to convert PDF documents command.
So what is the solution, you can use ordinary users (including www) to call the Libreoffice API?","The correct answer:
/usr/bin/libreoffice7 -env:UserInstallation=file:///$HOME/.libreoffice-headless/ --convert-to pdf '.$infile_path.' --outdir '.$outfile_path
The point is -env:UserInstallation=file:///$HOME/.libreoffice-headless/",,,,,
GHDL testbench build error - how can I fix it?,"I am a beginner in VHDL. I am using GHDL to implement my VHDL code on and to test it. I wrote a simple VHDL Behavioral Code for XOR Gate. I am trying to write a testbench to test the XOR Gate.
XOR VHDL Code:
library ieee;
use ieee.std_logic_1164.all;

entity XORGate is
port(
    xora, xorb : in std_logic;
    xorout : out std_logic
);
end XORGate;

architecture behave of XORGate is
begin
   process(xora, xorb)
   begin
       xorout &lt;= xora xor xorb;
   end process;
end behave;

XOR Testbench VHDL Code:
library ieee;
use ieee.std_logic_1164.all;

entity XORGate_tb is
end XORGate_tb;

architecture structural of XORGate_tb is
component XORGate
   port(
      xa, xb : in std_logic;
      xout : out std_logic
   );
end component;

signal xa, xb, xout : std_ulogic;

begin
xorgate1 : XORGate port map(xa, xb, xout);
process
  begin
     xa &lt;= '0';
     xb &lt;= '0';
     wait for 100 ns;

     xa &lt;= '0';
     xb &lt;= '1';
     wait for 100 ns;

     xa &lt;= '1';
     xb &lt;= '0';
     wait for 100 ns;

     xa &lt;= '1';
     xb &lt;= '1';
     wait for 100 ns;

     assert false report &quot;Reached end of test&quot;;
     wait;
end process;
end structural;

When I use the following commands:
&quot;ghdl -s XORGate_tb.vhdl&quot; to check the syntax
&quot;ghdl -a XORGate_tb.vhdl&quot; to analyze the file
no errors are given. When I use the following command
&quot;ghdl -e XORGate_tb&quot;
I get the following errors
XORGate_tb.vhdl:18:1:error: for default port binding of component instance &quot;xorgate1&quot;:
XORGate_tb.vhdl:18:1:error: signal interface &quot;xa&quot; has no association in entity &quot;xorgate&quot;
XORGate_tb.vhdl:18:1:error: signal interface &quot;xb&quot; has no association in entity &quot;xorgate&quot;
XORGate_tb.vhdl:18:1:error: signal interface &quot;xout&quot; has no association in entity &quot;xorgate&quot;

I am unable to fix the error. Tried changing signal names and still got the same error. How can I fix the above error?","The port names in the entity do not match the component. In the component you have xa, xb and xout. But in the entity they are xora, xorb and xorout.
To avoid issues like this, I recommend using direct instantiation as mismatches between an instantiation and the entity are a syntax error and you can simply delete the component and not have what is effectively the same code in two different places:
xorgate1 : entity work.XORGate port map(xa, xb, xout);
",,,,,
Am i using $fscanf correctly? Want to use values as an input to testbench,"I'm trying to read 16384 values in from a .txt file and use them as values in my testbench. I'm using $fopen and trying to use $fscanf. The error I'm getting back is that 'A' is an unpacked array, I'm not sure if my method is correct even without this error. Thanks for any help!
module tb2_fir;
// Inputs
reg Clk,rst_n;
reg signed [7:0] Xin;

// Outputs
wire signed [15:0] Yout;
reg signed [15:0]A[0:16383];
integer file,fd,i,file1,file2;


// Instantiate the Unit Under Test (UUT)
fir uut (
    .Clk(Clk), 
    .Xin(Xin), 
    .Yout(Yout),
    .rst_n(rst_n)
);

//Generate a clock with 10 ns clock period.
initial Clk = 0;
always #5 Clk =~Clk;
always @(negedge Clk)
begin
if(rst_n)
Xin&lt;='0;
end

//Initialize and apply the inputs.
initial begin 
file=$fopen(&quot;data_1.txt&quot;,&quot;r&quot;);
file2=$fscanf(file,&quot;%d&quot;,A);

for(i=0;i&lt;16383;i=i+1)
@(negedge Clk) Xin=A[i];
$finish;
end   
endmodule
","No, you cannot read in your data in a single call to $fscanf to fill your array. In order to read in all the data from your file (which in the comment you specify as a CSV), you'll need to loop over the elements one at a time:
reg signed [15:0] A[0:16383];
integer fd, i, scanRet;
...
initial begin
  fd = $fopen(&quot;data_1.txt&quot;, &quot;r&quot;);
  
  i = 0;
  do begin
    // Note that if you have data like '0, 0, -10, 23, 1000, ...' in your file, you need the comma in the format string
    scanRet = $fscanf(fd, &quot;%d,&quot;, A[i]);
    i = i + 1;
  end while (i &lt; $size(A) &amp;&amp; scanRet &gt; 0);
  
  for (i = 0; i &lt; $size(A); i = i + 1) begin
    @(negedge Clk) Xin = A[i]; // Note that you declare Xin as reg signed [7:0], while A[i] is reg signed [15:0]; are you sure you only want to truncate A[i] to a byte?
  end
  $finish;
end

Be sure to account for how your data is actually formatted in the file in your format string.",,,,,
Is this a valid way to code a VHDL async reset?,"I have picked up some VHDL code to maintain that has a reset written in a way I'm not familiar with. I'm not sure if it's valid, and my simulator (Modelsim) is giving warnings that I wouldn't expect. Example of the pattern:
process(clk, reset_n)
begin
  if reset_n = '0' then
    counter &lt;= (others=&gt;'0');
  end if;
  if rising_edge(clk) then
    case state is
    when IDLE      =&gt;
      if signal_a = signal_b then
        state &lt;= DATA;
      end if;
    when DATA =&gt; 
      state &lt;= IDLE;
    when others =&gt;
    end case;
    if state = DATA then
      counter &lt;= counter + 1;
    else
      counter &lt;= (others =&gt; '0');
    end if;
  end if;
end process;

Modelsim warns that state, signal_a and signal_b are &quot;read in the process but is not in the sensitivity list&quot;. I would not expect that as they are in a clocked block and the process is sensitive to the clock.
Is this a valid coding style for an async reset? I would expect to see elsif rising_edge(clk) instead, but understand this would cause problems here with the mix of other non-reset signals (state).","This pattern likely wont behave as you expect, and also likely wont synthesise (and if it does, it wont match the code).
This code has the clock overriding the reset. If reset is asserted ('0') then the counter will be reset, but if clk is running it will the run as if reset_n is '1'. This is because processes are only triggered by a 'event' on a signal in the sensitivity list, so the reset will only occur when reset_n changes to '0'. This doesnt usually matter in VHDL as the reset branch will have higher priority than the clock. So if it is clocked, the reset branch is taken. But here, because the reset has lower priority, it is as if reset_n is a negitive edge clock.
On the actual hardware, this is different. Sensitivity lists are normally ignored and the hardware is built from the code in the process. I would expect that this will fail to build either because it will complain about no logic matching the template, or dual edge flops are not allowed.
To fix this, either make the clock branch an elsif as you suggested, and you would also need to add state to the reset to avoid an accidental clock enable on state, or move the reset to the bottom of the process, where it will override the clock assignment properly, and allow you to have a mix of reset and non-reset registers in the same process.",,,,,
Assign multiple values to a signal during 1 process,"If you assign a value to a signal in a process, does it only become the correct value of the signal at the end of the process?
So there would be no point in assigning a value to a signal more than once per process, because the last assignment would be the only one that would be implemented, correct?
I'm a bit desperate because I'm trying to implement the booth algorithm in VHDL with signals and I can't get it baked. It wasn't a problem with variables, but signals make it all more difficult.
I tried a for loop, but that doesn't work because I have to update the values within the loop.
My next idea is a counter in the testbench.
Would be very thanksful for an idea!
my current Code look like this:
architecture behave of booth is
signal buffer_result1, buffer_result2, buffer_result3: std_logic_vector(7 downto 0) := &quot;0000&quot;&amp;b;
signal s: std_logic:= '0';
signal count1, count2: integer:=0;

begin

    
    assignment: process(counter) is
    begin
        if counter = &quot;000&quot; then
            buffer_result1 &lt;= &quot;0000&quot;&amp;b;
        end if;
    end process;
    
    
    add_sub: process(counter) is
    begin
        if counter &lt;= &quot;011&quot; then
            if(buffer_result1(0) = '1' and s = '0') then
                buffer_result2 &lt;= buffer_result1(7 downto 4)-a;
            else if (buffer_result1(0) = '0' and s = '1') then
                buffer_result2 &lt;= buffer_result1(7 downto 4)+a;
            end if;
        end if;
    end process;
    
    shift:process(counter) is
    begin
        if counter &lt;= &quot;011&quot;
            buffer_result3(7) &lt;= buffer_result2(7);
            buffer_result3(6 downto 0) &lt;= buffer_result2(7 downto 1);
            s&lt;= buffer_result3(0);
        else
            result&lt;=buffer_result3;
        end if;
end behave;
","Short answer: that's correct. A signal's value will not update until the end of your process.
Long answer: A signal will only update when its assignment takes effect. Some signal assignments will use after and specify a time, making the transaction time explicit. Without an explicit time given, signals will update after the default &quot;time-delta,&quot; an &quot;instant&quot; of simulation time that passes as soon as all concurrently executing statements at the given sim time have completed (e.g. a process). So your signals will hold their initial values until the process completes, at which point sim time moves forward one &quot;delta,&quot; and the values update.
That does not mean that multiple signal assignment statements to the same signal don't accomplish anything in a process. VHDL will take note of all assignments, but of a series of assignments given with the same transaction time, only the last assignment will take effect. This can be used for a few tricky things, although I've encountered differences of opinion on how often they should be tried. For instance:
-- Assume I have a 'clk' coming in

signal pulse   : std_ulogic;
signal counter : unsigned(2 downto 0);

pulse_on_wrap : process(clk) is
begin
    clock : if rising_edge(clk):
        pulse   &lt;= '0'; -- Default assignment to &quot;pulse&quot; is 0
        counter &lt;= counter + 1; -- Counter will increment each clock cycle
        if counter = 2**3-1 then
            pulse &lt;= '1'; -- Pulse high when the counter drops to 0 (after this cycle)
        end if;
    end if clock;
end process pulse_on_wrap;

Here, the typical behavior is to assign the value '0' to pulse on each clock cycle. But if counter hits its max value, there will be a following assignment to pulse, which will set it to '1' once simulation time advances. Because it comes after the '0' assignment and also has a &quot;delta&quot; transaction delay, it will override the earlier assignment. So this process will cause the signal pulse, fittingly, to go high for one cycle each time the counter wraps to zero and then drop the next - it's a pulse, after all! :^)
I provide that example only to illustrate the potential benefit of multiple assignments within a process, as you mention that in your question. I do not advise trying anything fancy with assignments until you're clear on the difference between variable assignment and signal assignment - and how that needs to be reflected in your code!
Try to think of things in terms of simulation time and hardware when it comes to signals. Everything is static until time moves forward, then you can handle the new values. It's a learning curve, but it'll happen! ;^)",,,,,
"WARNING: ""__aeabi_uldivmod"" Undefined symbol in opendla.ko","I am trying to build kernel module driver (KMD) for NVDLA NVIDIA's Deep Learning Accelerator and got the following error at the end.
enter image description here
After doing some research on google I found that it is due to 64bit operations (especially 64bit division) present in the kmd that is causing the errors. After further investigation I found that the kmd was written for 64bit architecture while I am trying to compile it for 32bit (ARM cortex A9) processor. some people online have suggested to use -lgcc, which will take care the issue.
Could anyone help me in editing the makefile to link the linker library libgcc.
Thanks in advance.","Linux kernel code that uses 64-bit division should use the functions provided by #include &lt;linux/math64.h&gt;. Otherwise, when building for 32-bit architectures, GCC will attempt to use functions from libgcc which is not used by the kernel.
For example, the div_u64 function divides a 64-bit unsigned dividend by a 32-bit unsigned divisor and returns a 64-bit unsigned quotient. The KMD code referenced by OP contains this function:
int64_t dla_get_time_us(void)
{
    return ktime_get_ns() / NSEC_PER_USEC;
}

After adding #include &lt;linux/math64.h&gt;, it can be rewritten to use the div_u64 function as follows:
int64_t dla_get_time_us(void)
{
    return div_u64(ktime_get_ns(), NSEC_PER_USEC);
}

(Note that ktime_get_ns() returns a u64 (an unsigned 64-bit integer) and NSEC_PER_USEC has the value 1000 so can be used as a 32-bit divisor.)
There may be other places in the code where 64-bit division is used, but that is the first one I spotted.",,,,,
Memory-Maped Node in a Device Tree is not getting shown in /proc/iomem,"I am trying to add a custom memory-mapped component in intel FPGA based soc system. I have connected the custom component(NVDLA) with light-weight axi bridge (HPS to FPGA bridge). Device Tree File.
/dts-v1/;
/ {
    #address-cells = &lt;0x1&gt;;
    #size-cells = &lt;0x1&gt;;
    model = &quot;Terasic HAN Pilot (Arria 10 SX) &quot;;
    compatible = &quot;altr,socfpga-arria10&quot;, &quot;altr,socfpga&quot;;

    cpus {
        #address-cells = &lt;0x1&gt;;
        #size-cells = &lt;0x0&gt;;
        enable-method = &quot;altr,socfpga-a10-smp&quot;;

        cpu@0 {
            compatible = &quot;arm,cortex-a9&quot;;
            device_type = &quot;cpu&quot;;
            reg = &lt;0x0&gt;;
            next-level-cache = &lt;0x1&gt;;
        };

        cpu@1 {
            compatible =  &quot;arm,cortex-a9&quot;;
            device_type = &quot;cpu&quot;;
            reg = &lt;0x1&gt;;
            next-level-cache = &lt;0x1&gt;;
        };
    };

    intc@ffffd000 {
        compatible = &quot;arm,cortex-a9-gic-20.1&quot;, &quot;arm,cortex-a9-gic&quot;;
        #interrupt-cells = &lt;0x3&gt;;
        interrupt-controller;
        reg = &lt;0xffffd000 0x1000 0xffffc100 0x100&gt;;
        phandle = &lt;0x2&gt;;
    };
    reserved-memory {
        #address-cells = &lt;2&gt;;
        #size-cells = &lt;2&gt;;
        ranges;
        nvdla_mem: buffer@0x40000000 {
            no-map ;
            reg = &lt;0x0 0x40000000 0x0 0x40000000&gt;;
            
        };
    };
    soc {
        #address-cells = &lt;0x1&gt;;
        #size-cells = &lt;0x1&gt;;
        compatible = &quot;simple-bus&quot;;
        device_type = &quot;soc&quot;;
        interrupt-parent = &lt;0x2&gt;;
        ranges;

    
    arria10_hps_bridges: bridge@0xff200000 {
            compatible = &quot;simple-bus&quot;;
            reg = &lt;0xff200000 0x00200000&gt;;
            clocks = &lt;0x2c 0x2c&gt;;
            clock-names = &quot;h2f_lw_axi_clock&quot;, &quot;f2sdram0_clock&quot;;
            #address-cells = &lt;2&gt;;
            #size-cells = &lt;1&gt;;
            ranges = &lt;0x00000001 0x00000000 0xff200000 0x00040000&gt;;

            NVDLA_IP_0: nvdla@0x100000000 {
                compatible = &quot;nvidia,nv_small&quot;;
                reg = &lt;0x00000001 0x00000000 0x00040000&gt;;
                interrupt-parent = &lt;0x2&gt;;
                interrupts = &lt;0 19 4&gt;;
                clocks = &lt;0x2c 0x2c 0x2c&gt;;
                clock-names = &quot;clock&quot;, &quot;dla_core_clock&quot;, &quot;dla_csb_clock&quot;;
                memory-region = &lt;&amp;nvdla_mem&gt;;
            }; //end unknown@0x100000000 (NVDLA_IP_0)
        }; //end bridge@0xff200000 (arria10_hps_bridges)
    
        amba {
            compatible = &quot;simple-bus&quot;;
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x1&gt;;
            ranges;

            pdma@ffda1000 {
                compatible = &quot;arm,pl330-20.1&quot;, &quot;arm,pl330&quot;, &quot;arm,primecell&quot;;
                reg = &lt;0xffda1000 0x1000&gt;;
                interrupts = &lt;0x0 0x53 0x4 0x0 0x54 0x4 0x0 0x55 0x4 0x0 0x56 0x4 0x0 0x57 0x4 0x0 0x58 0x4 0x0 0x59 0x4 0x0 0x5a 0x4 0x0 0x5b 0x4&gt;;
                #dma-cells = &lt;0x1&gt;;
                #dma-channels = &lt;0x8&gt;;
                #dma-requests = &lt;0x20&gt;;
                clocks = &lt;0x3&gt;;
                clock-names = &quot;apb_pclk&quot;;
                microcode-cached;
                phandle = &lt;0x1e&gt;;
            };
        };

        clkmgr@ffd04000 {
            compatible = &quot;altr,clk-mgr-20.1&quot;, &quot;altr,clk-mgr&quot;;
            reg = &lt;0xffd04000 0x1000&gt;;

            clocks {
                #address-cells = &lt;0x1&gt;;
                #size-cells = &lt;0x0&gt;;

                clk_100 {
                    compatible = &quot;fixed-clock&quot;;
                    #clock-cells = &lt;0x0&gt;;
                    clock-frequency = &lt;0x5f5e100&gt;;
                    clock-output-names = &quot;clk_100-clk&quot;;
                    phandle = &lt;0x2c&gt;;
                };

                clk_50 {
                    compatible = &quot;fixed-clock&quot;;
                    #clock-cells = &lt;0x0&gt;;
                    clock-frequency = &lt;0x2faf080&gt;;
                    clock-output-names = &quot;clk_50-clk&quot;;
                };

                cb_intosc_hs_div2_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;fixed-clock&quot;;
                    phandle = &lt;0xd&gt;;
                };

                cb_intosc_ls_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;fixed-clock&quot;;
                    phandle = &lt;0x6&gt;;
                };

                f2s_free_clk {
                    #clock-cells = &lt;0x0&gt;;
                    clock-frequency = &lt;0x2faf080&gt;;
                    compatible = &quot;fixed-clock&quot;;
                    phandle = &lt;0x7&gt;;
                };

                osc1 {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;fixed-clock&quot;;
                    clock-frequency = &lt;0x17d7840&gt;;
                    phandle = &lt;0x5&gt;;
                };

                main_pll@40 {
                    #address-cells = &lt;0x1&gt;;
                    #size-cells = &lt;0x0&gt;;
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-pll-clock&quot;;
                    clocks = &lt;0x5 0x6 0x7&gt;;
                    reg = &lt;0x40&gt;;
                    phandle = &lt;0x8&gt;;

                    main_mpu_base_clk {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0x8&gt;;
                        div-reg = &lt;0x140 0x0 0xb&gt;;
                        phandle = &lt;0xb&gt;;
                    };

                    main_noc_base_clk {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0x8&gt;;
                        div-reg = &lt;0x144 0x0 0xb&gt;;
                        phandle = &lt;0xe&gt;;
                    };

                    main_emaca_clk@68 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0x8&gt;;
                        reg = &lt;0x68&gt;;
                        phandle = &lt;0x2d&gt;;
                    };

                    main_emacb_clk@6c {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0x8&gt;;
                        reg = &lt;0x6c&gt;;
                        phandle = &lt;0x2e&gt;;
                    };

                    main_emac_ptp_clk@70 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0x8&gt;;
                        reg = &lt;0x70&gt;;
                        phandle = &lt;0x2f&gt;;
                    };

                    main_gpio_db_clk@74 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0x8&gt;;
                        reg = &lt;0x74&gt;;
                        phandle = &lt;0x30&gt;;
                    };

                    main_sdmmc_clk@78 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0x8&gt;;
                        reg = &lt;0x78&gt;;
                        phandle = &lt;0x12&gt;;
                    };

                    main_s2f_usr0_clk@7c {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0x8&gt;;
                        reg = &lt;0x7c&gt;;
                        phandle = &lt;0x31&gt;;
                    };

                    main_s2f_usr1_clk@80 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0x8&gt;;
                        reg = &lt;0x80&gt;;
                        phandle = &lt;0x10&gt;;
                    };

                    main_hmc_pll_ref_clk@84 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0x8&gt;;
                        reg = &lt;0x84&gt;;
                        phandle = &lt;0x32&gt;;
                    };

                    main_periph_ref_clk@9c {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0x8&gt;;
                        reg = &lt;0x9c&gt;;
                        phandle = &lt;0x9&gt;;
                    };
                };

                periph_pll@c0 {
                    #address-cells = &lt;0x1&gt;;
                    #size-cells = &lt;0x0&gt;;
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-pll-clock&quot;;
                    clocks = &lt;0x5 0x6 0x7 0x9&gt;;
                    reg = &lt;0xc0&gt;;
                    phandle = &lt;0xa&gt;;

                    peri_mpu_base_clk {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0xa&gt;;
                        div-reg = &lt;0x140 0x10 0xb&gt;;
                        phandle = &lt;0xc&gt;;
                    };

                    peri_noc_base_clk {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0xa&gt;;
                        div-reg = &lt;0x144 0x10 0xb&gt;;
                        phandle = &lt;0xf&gt;;
                    };

                    peri_emaca_clk@e8 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0xa&gt;;
                        reg = &lt;0xe8&gt;;
                        phandle = &lt;0x33&gt;;
                    };

                    peri_emacb_clk@ec {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0xa&gt;;
                        reg = &lt;0xec&gt;;
                        phandle = &lt;0x34&gt;;
                    };

                    peri_emac_ptp_clk@f0 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0xa&gt;;
                        reg = &lt;0xf0&gt;;
                        phandle = &lt;0x35&gt;;
                    };

                    peri_gpio_db_clk@f4 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0xa&gt;;
                        reg = &lt;0xf4&gt;;
                        phandle = &lt;0x36&gt;;
                    };

                    peri_sdmmc_clk@f8 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0xa&gt;;
                        reg = &lt;0xf8&gt;;
                        phandle = &lt;0x13&gt;;
                    };

                    peri_s2f_usr0_clk@fc {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0xa&gt;;
                        reg = &lt;0xfc&gt;;
                        phandle = &lt;0x37&gt;;
                    };

                    peri_s2f_usr1_clk@100 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0xa&gt;;
                        reg = &lt;0x100&gt;;
                        phandle = &lt;0x11&gt;;
                    };

                    peri_hmc_pll_ref_clk@104 {
                        #clock-cells = &lt;0x0&gt;;
                        compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                        clocks = &lt;0xa&gt;;
                        reg = &lt;0x104&gt;;
                        phandle = &lt;0x38&gt;;
                    };
                };

                mpu_free_clk@60 {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                    clocks = &lt;0xb 0xc 0x5 0xd 0x7&gt;;
                    reg = &lt;0x60&gt;;
                    phandle = &lt;0x15&gt;;
                };

                noc_free_clk@64 {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                    clocks = &lt;0xe 0xf 0x5 0xd 0x7&gt;;
                    reg = &lt;0x64&gt;;
                    phandle = &lt;0x14&gt;;
                };

                s2f_user1_free_clk@104 {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                    clocks = &lt;0x10 0x11 0x5 0xd 0x7&gt;;
                    reg = &lt;0x104&gt;;
                    phandle = &lt;0x39&gt;;
                };

                sdmmc_free_clk@f8 {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                    clocks = &lt;0x12 0x13 0x5 0xd 0x7&gt;;
                    fixed-divider = &lt;0x4&gt;;
                    reg = &lt;0xf8&gt;;
                    phandle = &lt;0x16&gt;;
                };

                l4_sys_free_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-perip-clk&quot;;
                    clocks = &lt;0x14&gt;;
                    fixed-divider = &lt;0x4&gt;;
                    phandle = &lt;0x29&gt;;
                };

                l4_main_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x14&gt;;
                    div-reg = &lt;0xa8 0x0 0x2&gt;;
                    clk-gate = &lt;0x48 0x1&gt;;
                    phandle = &lt;0x3&gt;;
                };

                l4_mp_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x14&gt;;
                    div-reg = &lt;0xa8 0x8 0x2&gt;;
                    clk-gate = &lt;0x48 0x2&gt;;
                    phandle = &lt;0x17&gt;;
                };

                l4_sp_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x14&gt;;
                    div-reg = &lt;0xa8 0x10 0x2&gt;;
                    clk-gate = &lt;0x48 0x3&gt;;
                    phandle = &lt;0x1c&gt;;
                };

                mpu_periph_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x15&gt;;
                    fixed-divider = &lt;0x4&gt;;
                    clk-gate = &lt;0x48 0x0&gt;;
                    phandle = &lt;0x28&gt;;
                };

                sdmmc_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x16&gt;;
                    clk-gate = &lt;0xc8 0x5&gt;;
                    clk-phase = &lt;0x0 0x87&gt;;
                    phandle = &lt;0x20&gt;;
                };

                qspi_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x3&gt;;
                    clk-gate = &lt;0xc8 0xb&gt;;
                    phandle = &lt;0x27&gt;;
                };

                nand_x_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x17&gt;;
                    clk-gate = &lt;0xc8 0xa&gt;;
                    phandle = &lt;0x18&gt;;
                };

                nand_ecc_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x18&gt;;
                    clk-gate = &lt;0xc8 0xa&gt;;
                    phandle = &lt;0x22&gt;;
                };

                nand_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x18&gt;;
                    fixed-divider = &lt;0x4&gt;;
                    clk-gate = &lt;0xc8 0xa&gt;;
                    phandle = &lt;0x21&gt;;
                };

                spi_m_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x3&gt;;
                    clk-gate = &lt;0xc8 0x9&gt;;
                    phandle = &lt;0x1d&gt;;
                };

                usb_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x17&gt;;
                    clk-gate = &lt;0xc8 0x8&gt;;
                    phandle = &lt;0x2a&gt;;
                };

                s2f_usr1_clk {
                    #clock-cells = &lt;0x0&gt;;
                    compatible = &quot;altr,socfpga-a10-gate-clk&quot;;
                    clocks = &lt;0x11&gt;;
                    clk-gate = &lt;0xc8 0x6&gt;;
                    phandle = &lt;0x3a&gt;;
                };
            };
        };

        stmmac-axi-config {
            snps,wr_osr_lmt = &lt;0xf&gt;;
            snps,rd_osr_lmt = &lt;0xf&gt;;
            snps,blen = &lt;0x0 0x0 0x0 0x0 0x10 0x0 0x0&gt;;
            phandle = &lt;0x1b&gt;;
        };

        ethernet@ff800000 {
            compatible = &quot;altr,socfpga-stmmac&quot;, &quot;snps,dwmac-3.72a&quot;, &quot;snps,dwmac&quot;;
            altr,sysmgr-syscon = &lt;0x19 0x44 0x0&gt;;
            reg = &lt;0xff800000 0x2000&gt;;
            interrupts = &lt;0x0 0x5c 0x4&gt;;
            interrupt-names = &quot;macirq&quot;;
            mac-address = [d6 7d ae b3 0e bc];
            snps,multicast-filter-bins = &lt;0x100&gt;;
            snps,perfect-filter-entries = &lt;0x80&gt;;
            tx-fifo-depth = &lt;0x1000&gt;;
            rx-fifo-depth = &lt;0x4000&gt;;
            clocks = &lt;0x17&gt;;
            clock-names = &quot;stmmaceth&quot;;
            resets = &lt;0x1a 0x20&gt;;
            reset-names = &quot;stmmaceth&quot;;
            snps,axi-config = &lt;0x1b&gt;;
            status = &quot;okay&quot;;
            phy-mode = &quot;rgmii&quot;;
            phy-addr = &lt;0xffffffff&gt;;
            txd0-skew-ps = &lt;0x0&gt;;
            txd1-skew-ps = &lt;0x0&gt;;
            txd2-skew-ps = &lt;0x0&gt;;
            txd3-skew-ps = &lt;0x0&gt;;
            rxd0-skew-ps = &lt;0x1a4&gt;;
            rxd1-skew-ps = &lt;0x1a4&gt;;
            rxd2-skew-ps = &lt;0x1a4&gt;;
            rxd3-skew-ps = &lt;0x1a4&gt;;
            txen-skew-ps = &lt;0x0&gt;;
            txc-skew-ps = &lt;0x744&gt;;
            rxdv-skew-ps = &lt;0x1a4&gt;;
            rxc-skew-ps = &lt;0x690&gt;;
            max-frame-size = &lt;0xed8&gt;;
            phandle = &lt;0x24&gt;;
        };

        ethernet@ff802000 {
            compatible = &quot;altr,socfpga-stmmac&quot;, &quot;snps,dwmac-3.72a&quot;, &quot;snps,dwmac&quot;;
            altr,sysmgr-syscon = &lt;0x19 0x48 0x0&gt;;
            reg = &lt;0xff802000 0x2000&gt;;
            interrupts = &lt;0x0 0x5d 0x4&gt;;
            interrupt-names = &quot;macirq&quot;;
            mac-address = [00 00 00 00 00 00];
            snps,multicast-filter-bins = &lt;0x100&gt;;
            snps,perfect-filter-entries = &lt;0x80&gt;;
            tx-fifo-depth = &lt;0x1000&gt;;
            rx-fifo-depth = &lt;0x4000&gt;;
            clocks = &lt;0x17&gt;;
            clock-names = &quot;stmmaceth&quot;;
            resets = &lt;0x1a 0x21&gt;;
            reset-names = &quot;stmmaceth&quot;;
            snps,axi-config = &lt;0x1b&gt;;
            status = &quot;disabled&quot;;
            phandle = &lt;0x3b&gt;;
        };

        ethernet@ff804000 {
            compatible = &quot;altr,socfpga-stmmac&quot;, &quot;snps,dwmac-3.72a&quot;, &quot;snps,dwmac&quot;;
            altr,sysmgr-syscon = &lt;0x19 0x4c 0x0&gt;;
            reg = &lt;0xff804000 0x2000&gt;;
            interrupts = &lt;0x0 0x5e 0x4&gt;;
            interrupt-names = &quot;macirq&quot;;
            mac-address = [00 00 00 00 00 00];
            snps,multicast-filter-bins = &lt;0x100&gt;;
            snps,perfect-filter-entries = &lt;0x80&gt;;
            tx-fifo-depth = &lt;0x1000&gt;;
            rx-fifo-depth = &lt;0x4000&gt;;
            clocks = &lt;0x17&gt;;
            clock-names = &quot;stmmaceth&quot;;
            snps,axi-config = &lt;0x1b&gt;;
            status = &quot;disabled&quot;;
            phandle = &lt;0x3c&gt;;
        };

        gpio@ffc02900 {
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            compatible = &quot;snps,dw-apb-gpio&quot;;
            reg = &lt;0xffc02900 0x100&gt;;
            status = &quot;disabled&quot;;
            phandle = &lt;0x3d&gt;;

            gpio-controller@0 {
                compatible = &quot;snps,dw-apb-gpio-port&quot;;
                gpio-controller;
                #gpio-cells = &lt;0x2&gt;;
                snps,nr-gpios = &lt;0x1d&gt;;
                reg = &lt;0x0&gt;;
                interrupt-controller;
                #interrupt-cells = &lt;0x2&gt;;
                interrupts = &lt;0x0 0x70 0x4&gt;;
                phandle = &lt;0x3e&gt;;
            };
        };

        gpio@ffc02a00 {
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            compatible = &quot;snps,dw-apb-gpio&quot;;
            reg = &lt;0xffc02a00 0x100&gt;;
            status = &quot;okay&quot;;
            phandle = &lt;0x3f&gt;;

            gpio-controller@0 {
                compatible = &quot;snps,dw-apb-gpio-port&quot;;
                gpio-controller;
                #gpio-cells = &lt;0x2&gt;;
                snps,nr-gpios = &lt;0x1d&gt;;
                reg = &lt;0x0&gt;;
                interrupt-controller;
                #interrupt-cells = &lt;0x2&gt;;
                interrupts = &lt;0x0 0x71 0x4&gt;;
                phandle = &lt;0x1f&gt;;
            };
        };

        gpio@ffc02b00 {
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            compatible = &quot;snps,dw-apb-gpio&quot;;
            reg = &lt;0xffc02b00 0x100&gt;;
            status = &quot;disabled&quot;;
            phandle = &lt;0x40&gt;;

            gpio-controller@0 {
                compatible = &quot;snps,dw-apb-gpio-port&quot;;
                gpio-controller;
                #gpio-cells = &lt;0x2&gt;;
                snps,nr-gpios = &lt;0x1b&gt;;
                reg = &lt;0x0&gt;;
                interrupt-controller;
                #interrupt-cells = &lt;0x2&gt;;
                interrupts = &lt;0x0 0x72 0x4&gt;;
                phandle = &lt;0x41&gt;;
            };
        };

        fpga-mgr@ffd03000 {
            compatible = &quot;altr,socfpga-a10-fpga-mgr&quot;;
            reg = &lt;0xffd03000 0x100 0xffcfe400 0x20&gt;;
            clocks = &lt;0x17&gt;;
            resets = &lt;0x1a 0x83&gt;;
            reset-names = &quot;fpgamgr&quot;;
            phandle = &lt;0x4&gt;;
        };

        i2c@ffc02200 {
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            compatible = &quot;snps,designware-i2c&quot;;
            reg = &lt;0xffc02200 0x100&gt;;
            interrupts = &lt;0x0 0x69 0x4&gt;;
            clocks = &lt;0x1c&gt;;
            status = &quot;okay&quot;;
            phandle = &lt;0x42&gt;;

            ds1339@68 {
                compatible = &quot;dallas,ds1339&quot;, &quot;mxim,ds1339&quot;;
                reg = &lt;0x68&gt;;
                trickle-resistor-ohms = &lt;0xfa&gt;;
                trickle-diode-disable;
            };
        };

        i2c@ffc02300 {
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            compatible = &quot;snps,designware-i2c&quot;;
            reg = &lt;0xffc02300 0x100&gt;;
            interrupts = &lt;0x0 0x6a 0x4&gt;;
            clocks = &lt;0x1c&gt;;
            status = &quot;disabled&quot;;
            clock-frequency = &lt;0x186a0&gt;;
            i2c-sda-falling-time-ns = &lt;0x1770&gt;;
            i2c-scl-falling-time-ns = &lt;0x1770&gt;;
            phandle = &lt;0x43&gt;;
        };

        i2c@ffc02400 {
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            compatible = &quot;snps,designware-i2c&quot;;
            reg = &lt;0xffc02400 0x100&gt;;
            interrupts = &lt;0x0 0x6b 0x4&gt;;
            clocks = &lt;0x1c&gt;;
            status = &quot;disabled&quot;;
            phandle = &lt;0x45&gt;;
        };

        i2c@ffc02500 {
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            compatible = &quot;snps,designware-i2c&quot;;
            reg = &lt;0xffc02500 0x100&gt;;
            interrupts = &lt;0x0 0x6c 0x4&gt;;
            clocks = &lt;0x1c&gt;;
            status = &quot;disabled&quot;;
            phandle = &lt;0x46&gt;;
        };

        i2c@ffc02600 {
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            compatible = &quot;snps,designware-i2c&quot;;
            reg = &lt;0xffc02600 0x100&gt;;
            interrupts = &lt;0x0 0x6d 0x4&gt;;
            clocks = &lt;0x1c&gt;;
            status = &quot;disabled&quot;;
            phandle = &lt;0x47&gt;;
        };

        spi@ffda4000 {
            compatible = &quot;snps,dw-apb-ssi&quot;;
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            reg = &lt;0xffda4000 0x100&gt;;
            interrupts = &lt;0x0 0x65 0x4&gt;;
            num-cs = &lt;0x4&gt;;
            clocks = &lt;0x1d&gt;;
            status = &quot;disabled&quot;;
            phandle = &lt;0x48&gt;;
        };

        spi@ffda5000 {
            compatible = &quot;snps,dw-apb-ssi&quot;;
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            reg = &lt;0xffda5000 0x100&gt;;
            interrupts = &lt;0x0 0x66 0x4&gt;;
            num-cs = &lt;0x4&gt;;
            tx-dma-channel = &lt;0x1e 0x10&gt;;
            rx-dma-channel = &lt;0x1e 0x11&gt;;
            clocks = &lt;0x1d&gt;;
            status = &quot;disabled&quot;;
            phandle = &lt;0x49&gt;;
        };

        sdr@ffcfb100 {
            compatible = &quot;altr,sdr-ctl&quot;, &quot;syscon&quot;;
            reg = &lt;0xffcfb100 0x80&gt;;
            phandle = &lt;0x23&gt;;
        };

        l2-cache@fffff000 {
            compatible = &quot;arm,pl310-cache&quot;;
            reg = &lt;0xfffff000 0x1000&gt;;
            interrupts = &lt;0x0 0x12 0x4&gt;;
            cache-unified;
            cache-level = &lt;0x2&gt;;
            prefetch-data = &lt;0x1&gt;;
            prefetch-instr = &lt;0x1&gt;;
            arm,shared-override;
            phandle = &lt;0x1&gt;;
        };

        dwmmc0@ff808000 {
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            compatible = &quot;altr,socfpga-dw-mshc&quot;;
            reg = &lt;0xff808000 0x1000&gt;;
            interrupts = &lt;0x0 0x62 0x4&gt;;
            fifo-depth = &lt;0x400&gt;;
            clocks = &lt;0x17 0x20&gt;;
            clock-names = &quot;biu&quot;, &quot;ciu&quot;;
            status = &quot;okay&quot;;
            cap-sd-highspeed;
            cap-mmc-highspeed;
            broken-cd;
            bus-width = &lt;0x4&gt;;
            phandle = &lt;0x26&gt;;
        };

        nand@ffb90000 {
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x1&gt;;
            compatible = &quot;altr,socfpga-denali-nand&quot;;
            reg = &lt;0xffb90000 0x72000 0xffb80000 0x10000&gt;;
            reg-names = &quot;nand_data&quot;, &quot;denali_reg&quot;;
            interrupts = &lt;0x0 0x63 0x4&gt;;
            clocks = &lt;0x21 0x18 0x22&gt;;
            clock-names = &quot;nand&quot;, &quot;nand_x&quot;, &quot;ecc&quot;;
            status = &quot;disabled&quot;;
            phandle = &lt;0x4b&gt;;
        };

        sram@ffe00000 {
            compatible = &quot;mmio-sram&quot;;
            reg = &lt;0xffe00000 0x40000&gt;;
            phandle = &lt;0x4c&gt;;
        };

        eccmgr {
            compatible = &quot;altr,socfpga-a10-ecc-manager&quot;;
            altr,sysmgr-syscon = &lt;0x19&gt;;
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x1&gt;;
            interrupts = &lt;0x0 0x2 0x4 0x0 0x0 0x4&gt;;
            interrupt-controller;
            #interrupt-cells = &lt;0x2&gt;;
            ranges;
            phandle = &lt;0x4d&gt;;

            sdramedac {
                compatible = &quot;altr,sdram-edac-a10&quot;;
                altr,sdr-syscon = &lt;0x23&gt;;
                interrupts = &lt;0x11 0x4 0x31 0x4&gt;;
            };

            l2-ecc@ffd06010 {
                compatible = &quot;altr,socfpga-a10-l2-ecc&quot;;
                reg = &lt;0xffd06010 0x4&gt;;
                interrupts = &lt;0x0 0x4 0x20 0x4&gt;;
            };

            ocram-ecc@ff8c3000 {
                compatible = &quot;altr,socfpga-a10-ocram-ecc&quot;;
                reg = &lt;0xff8c3000 0x400&gt;;
                interrupts = &lt;0x1 0x4 0x21 0x4&gt;;
            };

            emac0-rx-ecc@ff8c0800 {
                compatible = &quot;altr,socfpga-eth-mac-ecc&quot;;
                reg = &lt;0xff8c0800 0x400&gt;;
                altr,ecc-parent = &lt;0x24&gt;;
                interrupts = &lt;0x4 0x4 0x24 0x4&gt;;
            };

            emac0-tx-ecc@ff8c0c00 {
                compatible = &quot;altr,socfpga-eth-mac-ecc&quot;;
                reg = &lt;0xff8c0c00 0x400&gt;;
                altr,ecc-parent = &lt;0x24&gt;;
                interrupts = &lt;0x5 0x4 0x25 0x4&gt;;
            };

            dma-ecc@ff8c8000 {
                compatible = &quot;altr,socfpga-dma-ecc&quot;;
                reg = &lt;0xff8c8000 0x400&gt;;
                altr,ecc-parent = &lt;0x1e&gt;;
                interrupts = &lt;0xa 0x4 0x2a 0x4&gt;;
            };

            usb0-ecc@ff8c8800 {
                compatible = &quot;altr,socfpga-usb-ecc&quot;;
                reg = &lt;0xff8c8800 0x400&gt;;
                altr,ecc-parent = &lt;0x25&gt;;
                interrupts = &lt;0x2 0x4 0x22 0x4&gt;;
            };

            sdmmca-ecc@ff8c2c00 {
                compatible = &quot;altr,socfpga-sdmmc-ecc&quot;;
                reg = &lt;0xff8c2c00 0x400&gt;;
                altr,ecc-parent = &lt;0x26&gt;;
                interrupts = &lt;0xf 0x4 0x2f 0x4 0x10 0x4 0x30 0x4&gt;;
            };
        };

        spi@ff809000 {
            compatible = &quot;cdns,qspi-nor&quot;;
            #address-cells = &lt;0x1&gt;;
            #size-cells = &lt;0x0&gt;;
            reg = &lt;0xff809000 0x100 0xffa00000 0x100000&gt;;
            interrupts = &lt;0x0 0x64 0x4&gt;;
            cdns,fifo-depth = &lt;0x80&gt;;
            cdns,fifo-width = &lt;0x4&gt;;
            cdns,trigger-address = &lt;0x0&gt;;
            clocks = &lt;0x27&gt;;
     ",,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
rst-mgr&quot;;,,,,,,,
,,,,,,,
modrst-offset = &lt;0x20&gt;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
cortex-a9-scu&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
sys-mgr&quot;, &quot;syscon&quot;;,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
cortex-a9-twd-timer&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-timer&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-timer&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-timer&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-timer&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-uart&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-uart&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dwc2&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dwc2&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-wdt&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-wdt&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
default-trigger = &quot;heartbeat&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
code = &lt;0x67&gt;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
"This issue was resolved. After running the KMD driver for the NVDLA_IP_0 through the instruction mention in the comments and here by Ian Abbott, the node appeared in /pro/iomem.",0,0,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
rst-mgr&quot;;,,,,,,,
,,,,,,,
modrst-offset = &lt;0x20&gt;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
cortex-a9-scu&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
sys-mgr&quot;, &quot;syscon&quot;;,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
cortex-a9-twd-timer&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-timer&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-timer&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-timer&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-timer&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-uart&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-apb-uart&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dwc2&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dwc2&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-wdt&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
dw-wdt&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
default-trigger = &quot;heartbeat&quot;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
code = &lt;0x67&gt;;,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
" the node appeared in /pro/iomem.""",,,,,,,
VHDL decimation(?) of data in specific way,"My VHDL code doesn't behave as i expected.

What i want: i have 32 bit input data stream, and decimated 32 bit data output in some specific order. 

Let's say each 32 bit data split into two 16 bit data.


first case: every second 16 bit of 32 bit data present on output; 
second case: every fourth 16 bit of 32 bit data present on output; 
third case fourth 16 bit of 32 bit data present on output
and so on.


Like in the picture:pic1

Here is first case of implementation:

process (CLK_IN, RST_IN)
begin
    if (RST_IN = '1') then
        rx_data_half_a &lt;= (others =&gt; '0');
    elsif rising_edge(CLK_IN) then
        rx_data_half_a &lt;= DATA_IN(15 downto 0);
    end if;
end process;

process (CLK_IN, RST_IN)
begin
    if (RST_IN = '1') then
        rx_data_half_a0 &lt;= (others =&gt; '0');
        rx_data_half_a1 &lt;= (others =&gt; '0');
    elsif rising_edge(CLK_IN) then
        rx_data_half_a0 &lt;= rx_data_half_a;
        rx_data_half_a1 &lt;= rx_data_half_a0; 
        rx_data_half_a2 &lt;= rx_data_half_a1; 
        DATA_OUT &lt;= rx_data_half_a0 &amp; rx_data_half_a;
    end if;
end process;


And the testbench is looking like that:
sim

Instead of 00002222 44446666 ...

I get: 00002222 22224444 44446666 ...

I already do this job using memory (just counting specific addresses) but i dont' want to use it. I think there's much easiest way to implement this.

It is possible to do with registers without reducing the frequency?
Can you give me some advise?","You need a minimal state machine (eg: a counter) to track the input and update the data registers at the appropriate time.  You logic is running every clock cycle and has no idea it needs to ""skip"" any of the incoming samples.

Since you are decimating, it is not possible to do this in registers or in memory without ""reducing the frequency"" in that you will have half (or 1/4 or whatever your decimation ratio is set to) as many output elements as input elements.  If you use a memory you could burst at the full rate for a while, but you will still have to pause periodically and ""re-fill"" the buffer.",,,,,
I need modelsim to look at inner variables,"I have VHDL code with INs , OUTs and inner SIGNAL constants such as counters that I want to simulate. I have looked at examples on the web and I only see Modelsim monitoring the INs and OUTs. However, I would also like to look at internal signals such as a counter. I saw one guy writing only simulation code. I need a simple example of the following: A code with some INs and OUTs and some internal signals. A simple universal TB code with just a clk increment or similar. I saw a sample that looked correct but when I adapted it to my code, the internal signals were undefined in Modelsim. I could be missing something but my understanding is that one important feature of Modelsim is writing a generic test-bench with a clock and using it to view a histogram of my logic. As your code progresses, you would only have to add variables as needed to the tb. If anyone had some generic code or location of the code in both original and tb, they would share would be very helpful. Thanks","I've never had a problem getting modelsim to plot internal signals onto the waveforms. I just drag and drop the signal from the ""objects"" window onto the Wave window.



Here is a simple example. This is TestModule.vhd:

library ieee;
use ieee.std_logic_1164.all;
use IEEE.NUMERIC_STD.ALL;

entity TestModule is
port (
          ip_sl_ClkIn                : in std_logic;
          ip_slv_InputVal            : in std_logic_vector(7 downto 0);
          ip_sl_InputValid           : in std_logic;

          op_slv_OutputVal           : out std_logic_vector(7 downto 0);
          op_sl_OutputValid          : out std_logic
);
end TestModule;


architecture Behavioral of TestModule is

  --==========================
  --== INTERNAL SIGNALS
  --==========================
  signal s_slv_InputNibbleSwap_1d : std_logic_vector(7 downto 0) := (others =&gt; 'X');
  signal s_slv_Inverted_2d : std_logic_vector(7 downto 0) := (others =&gt; 'X');

  signal s_sl_InputValid_1d : std_logic := '0';
  signal s_sl_InputValid_2d : std_logic := '0';

begin


   RegisterProc : process(ip_sl_ClkIn)
    begin
      if(rising_edge(ip_sl_ClkIn)) then

      --Clock Cycle 1:
      --=======================
      --Take the input and swap nibble locations
      s_slv_InputNibbleSwap_1d &lt;= ip_slv_InputVal(3 downto 0) &amp; ip_slv_InputVal(7 downto 4);
      s_sl_InputValid_1d       &lt;= ip_sl_InputValid;

      --Clock Cycle 2:
      --=======================          
      --Invert the bits
      s_slv_Inverted_2d        &lt;= not(s_slv_InputNibbleSwap_1d);
      s_sl_InputValid_2d       &lt;= s_sl_InputValid_1d;

      end if; --rising_edge(ip_sl_ClkIn)
    end process RegisterProc;



    --Route Outputs:
    --=====================
    op_slv_OutputVal  &lt;= s_slv_Inverted_2d;
    op_sl_OutputValid &lt;= s_sl_InputValid_2d;

end Behavioral;


Here is the testbench, TestModule_tb.vhd:

 LIBRARY ieee;
  USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
  use std.textio.all;
ENTITY TestModule_tb IS
END TestModule_tb;

architecture behavior of TestModule_tb is

-- Component Declaration
-------------------------
  component TestModule
  Port ( 
        ip_sl_ClkIn : in std_logic;
        ip_slv_InputVal : in std_logic_vector ( 7 downto 0 );
        ip_sl_InputValid : in std_logic;
        op_slv_OutputVal : out std_logic_vector ( 7 downto 0 );
        op_sl_OutputValid : out std_logic
    );
  end component;



--Signals Driven by Entity: TestModule
-------------------------
    signal s_slv_OutputVal : std_logic_vector ( 7 downto 0 );
    signal s_sl_OutputValid : std_logic;


--Test Stimulus Signals:
-------------------------
    signal s_sl_ClkIn : std_logic;
    signal s_slv_InputVal : std_logic_vector ( 7 downto 0 );
    signal s_sl_InputValid : std_logic;


BEGIN

--Component Instantiation
    uut : TestModule
    Port Map (
        ip_sl_ClkIn         =&gt; s_sl_ClkIn   ,  --in std_logic
        ip_slv_InputVal     =&gt; s_slv_InputVal   ,  --in std_logic_vector ( 7 downto 0 )
        ip_sl_InputValid    =&gt; s_sl_InputValid   ,  --in std_logic
        op_slv_OutputVal    =&gt; s_slv_OutputVal   ,  --out std_logic_vector ( 7 downto 0 )
        op_sl_OutputValid   =&gt; s_sl_OutputValid     --out std_logic
    );


    clkProc : process
    begin
        s_sl_ClkIn &lt;= '1';
        wait for 10 ns;
        s_sl_ClkIn &lt;= '0';
        wait for 10 ns;
    end process;


MainTestProcess : Process
Begin

     s_slv_InputVal &lt;= (others =&gt; '0');
     s_sl_InputValid &lt;= '0';
     wait for 100 ns; 

     wait until rising_edge(s_sl_ClkIn); wait for 1 ps;
     s_slv_InputVal &lt;= X""AB"";
     s_sl_InputValid &lt;= '1';

     wait until rising_edge(s_sl_ClkIn); wait for 1 ps;
     s_slv_InputVal &lt;= X""FF"";
     s_sl_InputValid &lt;= '0';     

     wait for 100 ns;

    --Not a failure, but stops the simulation
    assert false report ""&lt;---- NOT a failure. Testbench Complete"" severity failure;

    wait; -- Will wait forever
end process;

END;


Here is a modelsim DO file for compiling and simulating, TestModule_tb.do:

vlib work
vcom -reportprogress 300 -work work TestModule.vhd
vcom -reportprogress 300 -work work TestModule_tb.vhd 
vsim -gui work.testmodule_tb
do TestModule_tb_wave.do
run -all


And here is the modelsim waveform DO file, TestModule_tb_wave.do:

onerror {resume}
quietly WaveActivateNextPane {} 0
add wave -noupdate /testmodule_tb/uut/ip_sl_ClkIn
add wave -noupdate /testmodule_tb/uut/ip_slv_InputVal
add wave -noupdate /testmodule_tb/uut/ip_sl_InputValid
add wave -noupdate /testmodule_tb/uut/op_slv_OutputVal
add wave -noupdate /testmodule_tb/uut/op_sl_OutputValid
add wave -noupdate /testmodule_tb/uut/s_slv_InputNibbleSwap_1d
add wave -noupdate /testmodule_tb/uut/s_slv_Inverted_2d
add wave -noupdate /testmodule_tb/uut/s_sl_InputValid_1d
add wave -noupdate /testmodule_tb/uut/s_sl_InputValid_2d
TreeUpdate [SetDefaultTree]
WaveRestoreCursors {{Cursor 1} {90738 ps} 0}
quietly wave cursor active 1
configure wave -namecolwidth 331
configure wave -valuecolwidth 100
configure wave -justifyvalue left
configure wave -signalnamewidth 0
configure wave -snapdistance 10
configure wave -datasetprefix 0
configure wave -rowmargin 4
configure wave -childrowmargin 2
configure wave -gridoffset 0
configure wave -gridperiod 1
configure wave -griddelta 40
configure wave -timeline 0
configure wave -timelineunits ps
update
WaveRestoreZoom {0 ps} {231001 ps}
",,,,,
Why am I getting errors in lines 56-61?,"I am trying to set up a problem for state machines in lab and I keep receiving errors when trying to compile in Quartus

I have tried using commas, else statements and nothing seems to work

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.All;

ENTITY SM_VHDL IS  -- Do not modify this entity statement!
  PORT(X       : IN STD_LOGIC_VECTOR(1 DOWNTO 0);
       RESETN,
       CLOCK   : IN  STD_LOGIC;
       Z       : OUT STD_LOGIC;
       Q       : OUT STD_LOGIC_VECTOR(1 DOWNTO 0)  );
END SM_VHDL;       -- Do not modify this entity statement!


ARCHITECTURE behavior of SM_VHDL IS
  TYPE STATE_TYPE IS (A, B, C);
  SIGNAL state : STATE_TYPE;

BEGIN
    PROCESS(CLOCK, RESETN)
      BEGIN
        IF RESETN = '0' THEN
          state &lt;= A;
        ELSIF CLOCK'EVENT AND CLOCK = '1' THEN
          CASE state IS
            WHEN A =&gt;
              CASE X IS
                WHEN ""00""   =&gt;
                                        state &lt;= B;
                                WHEN ""11""   =&gt;
                                        state &lt;= C;
                                WHEN OTHERS =&gt;
                                        state &lt;= A;
              END CASE;
            WHEN B =&gt;
              CASE X IS
                WHEN ""10""   =&gt;
                                        state &lt;= A;
                                WHEN ""11""   =&gt;
                                        state &lt;= C;
                                WHEN OTHERS =&gt;
                                        state &lt;= B;
              END CASE;
            WHEN C =&gt;
              CASE X IS
                WHEN ""00""   =&gt;
                                        state &lt;= B;
                                WHEN ""01""   =&gt;
                                        state &lt;= A;
                                WHEN OTHERS =&gt;
                                        state &lt;= C;
              END CASE;
          END CASE;
        END IF;
      END PROCESS;

    Z  &lt;= '1' WHEN C;
                  '0' WHEN A;
                  '0' WHEN B;

    Q  &lt;= ""00"" WHEN A;
                  ""01"" WHEN B;
                  ""10"" WHEN C;
                  ""11"" WHEN ""-"";

END behavior;


I need it to compile","The syntax for assigning to Z and Q is wrong for multiple issues:


Missing WITH state SELECT ... before assign
Uses "";"" between when parts, use , instead
Cant use ""-"" (don't care) after last when, use OTHERS instead


So updated code:

WITH state SELECT Z &lt;=
      '1' WHEN C,
      '0' WHEN A,
      '0' WHEN B;

WITH state SELECT Q &lt;=
      ""00"" WHEN A,
      ""01"" WHEN B,
      ""10"" WHEN C,
      ""11"" WHEN OTHERS;


Btw. consider using ModelSim Starter Edition as compiler/simulator before moving to Quartus, since the compile time is faster and messages often better.",,,,,
Why do I get syntax error for reassignment in verilog code?,"module test;
    reg[8:0] a;

    initial begin
        a= 4'b0001;
        a= 4'b0002;
    end
endmodule


I am a beginner to Verilog. Why do I get syntax error for second a assignment?","It is not the re-assignment. 

You are using base 2: 4'b and then the digit 2. Try 4'b0010 :-)

Post edit: Why are you assigning 4 bits when the variable is 9 bits long?",,,,,
Inter & Intra Delay Confusion with Blocking & NBA in Verilog,"Here is the code.

module temp();
  bit a;
  bit w_inter_nonblocking, x_inter_blocking, y_intra_blocking, z_intra_nonblocking;

  always @ (a)
  begin 
    $display(""@%0t : Blocking x_inter_blocking"", $time());
    #7 x_inter_blocking = a;
  end

  always @ (a)
  begin 
    $display(""@%0t : Nonblocking w_inter_nonblocking"", $time());
    #7 w_inter_nonblocking &lt;= a;
  end

  always @ (a)
  begin 
    $display(""@%0t : Nonblocking z_intra_nonblocking"", $time());
    z_intra_nonblocking &lt;= #7 a;
  end

  always @ (a)
  begin
    $display(""@%0t : Blocking y_intra_blocking"", $time());
    y_intra_blocking = #7 a;
  end

  initial
    forever #5 a = $random();

  initial 
    #150 $finish();

  // initial 
  //   #40 disable karan;

  initial 
  begin
    $dumpvars(0, temp);
    $dumpfile(""temp.vcd"");
  end
endmodule


Here is the corresponding print statements and waveform.

@10 : Nonblocking z_intra_nonblocking
@10 : Blocking x_inter_blocking
@10 : Nonblocking w_inter_nonblocking
@10 : Blocking y_intra_blocking
@40 : Nonblocking z_intra_nonblocking
@40 : Blocking x_inter_blocking
@40 : Nonblocking w_inter_nonblocking
@40 : Blocking y_intra_blocking
@45 : Nonblocking z_intra_nonblocking
@55 : Nonblocking z_intra_nonblocking
@55 : Blocking x_inter_blocking
@55 : Nonblocking w_inter_nonblocking
@55 : Blocking y_intra_blocking
@60 : Nonblocking z_intra_nonblocking
@70 : Nonblocking z_intra_nonblocking
@70 : Blocking x_inter_blocking
@70 : Nonblocking w_inter_nonblocking
@70 : Blocking y_intra_blocking
@75 : Nonblocking z_intra_nonblocking
@80 : Nonblocking z_intra_nonblocking
@80 : Blocking x_inter_blocking
@80 : Nonblocking w_inter_nonblocking
@80 : Blocking y_intra_blocking
@85 : Nonblocking z_intra_nonblocking
@90 : Nonblocking z_intra_nonblocking
@90 : Blocking x_inter_blocking
@90 : Nonblocking w_inter_nonblocking
@90 : Blocking y_intra_blocking
@95 : Nonblocking z_intra_nonblocking
@105 : Nonblocking z_intra_nonblocking
@105 : Blocking x_inter_blocking
@105 : Nonblocking w_inter_nonblocking
@105 : Blocking y_intra_blocking
@110 : Nonblocking z_intra_nonblocking
@115 : Nonblocking z_intra_nonblocking
@115 : Blocking x_inter_blocking
@115 : Nonblocking w_inter_nonblocking
@115 : Blocking y_intra_blocking
@130 : Nonblocking z_intra_nonblocking
@130 : Blocking x_inter_blocking
@130 : Nonblocking w_inter_nonblocking
@130 : Blocking y_intra_blocking
@135 : Nonblocking z_intra_nonblocking
@140 : Nonblocking z_intra_nonblocking
@140 : Blocking x_inter_blocking
@140 : Nonblocking w_inter_nonblocking
@140 : Blocking y_intra_blocking




As you can see that only Intra Delay with Nonblocking Assignments gives delayed output, rest all delays/assignments give different output.

I know the difference between Inter/Intra delays, however it seems that the always blocks are not getting triggered on alternative events (With delay of #7, if any signal change happens with &lt; #7 delay). However Intra Delay with NBA always block gets triggered properly.

Can anyone please help me here?","always @(expression) statement does not mean execute the statement eveytime the expression changes. It means wait fo the expression to change, execute the statement, then repeat going back to waiting for the expression to change. 

The problem is when the expression changes while in the process of executing the statement, the change is lost. You can only wait for changes that happen after you start waiting. 

It's the same issue as this one I answered earlier. ",,,,,
Ouput of adder module is always don't care [Verilog],"I know VHDL and now I try to do a bit of verilog. I have two files, one that contains a counter and another that contains a 32 bit full adder.

Counter.v:

module counter (
    input clk,
    input enable,
    input reset,
    output reg [3:0] count
    );


    wire [31:0] temp2 = 0;
    reg [31:0] clk_count = 0;
    wire [31:0] test = 32'b1;

    parameter integer number_of_clk_cycles = 15;
    adder adder1(clk_count, test, temp2);


    always @(posedge clk) begin
        if (reset) begin
            count = 0;
        end else if (enable) begin
            clk_count &lt;= temp2;    
            if(clk_count == number_of_clk_cycles) begin
                count &lt;= count + 1;
                clk_count &lt;= 0;
            end
        end
    end

endmodule


Adder.v:

module adder(
    input [31:0] a,
    input [31:0] b,
    output [31:0] c
    );

    wire [32:0] cin;    //The internal Carry signal
    assign cin[0] = 0;     //Force the carry line to 0, since the first adder has no carry

    genvar i;
    for(i=0; i&lt;32;i = i + 1) begin
        fa fa1( a[i], b[i], cin[i], c[i], cin[i+1]);
    end

endmodule

module ha( a, b, s, c);
    input a, b;
    output s, c;

    xor xor1(s ,a, b);      //Output first, then inputs
    and and1(c, a ,b);        //Output first, then inputs
endmodule

module fa (a , b, cin, s, cout);
    input a, b, cin;
    output s, cout;

    ha ha1(a, b, ha1_sum, ha1_cout);        //Half adder 1
    ha ha2(ha1_sum, cin, s, ha2_cout);        //Half adder 2
    or or1(cout, ha1_cout, ha2_cout);        //Carry out
endmodule


I verified my full adder code in ModelSIM, and it works all the time. But when I try to run the counter.v code, the output adder1 is always 'X' (don't care).
If the enable is set to '1' the don't care will ripple through the adder (clk_count &lt;= temp1;). What am I missing?","In verilog, if you drive the same wire with different non-z values, resulting value will be x.

In you case you drive temp2 twice. First time here:

 wire [31:0] temp2 = 0;


which is equivalent to 

 wire [31:0] temp2;
 assign temp2 = 0;


and the second time, with the output of your adder.

As a result, if the value produced by the output of the adder is non-zero, temp2 will become x, otherwise it will be 0.

So, do not assign 0 to it. ",,,,,
Does enum literal deceleration of states guarantee a glitch free state machine?,"does the enum literal deceleration of states for a state machine, guarantee a glitch free behavior as same as one would to assign order as below to the states?

enum { a,b,c} states; 

//vs if you were to declare

parameter a = 3'b000;
parameter b= 3'b010;
parameter c = 3'b011;

/////////////////////////

always @(posedge clk) begin  
  if ( reset) begin
    // initial condition 
    end
  else begin
    case ( state) begin
      a: begin
        state&lt;=b;
      end
      b: begin   
        state&lt;=c;
      end
      c: begin
        state&lt;= a;
      end
      default: state&lt;=c;
    endcase
  end
end
","By default, the enum labels get the encodings a=0, b=1, c=2. And you can give explicit encodings:

enum { a=0,b=2,c=3} states; 


But many synthesis tools have directives to let the tool decide the best encodings for the FSM styles they recognize. ",,,,,
Error (10734): Verilog HDL error at m.v(156): cnt is not a constant,"I need to write 4 bytes from input pins to different parts of a register depending on a counter, with the code i have now I get this error:
    Error (10734): Verilog HDL error at m.v(156): cnt is not a constant
    How should I deal with it?

wire wren, rst;     
wire [3:0] abcd;    
reg [31:0] my_reg;    
reg [3:0] cnt;   


always @(posedge wren or posedge rst)   
begin   
   if (rst == 1) 
   begin 
      my_reg &lt;= 0; 
   end    
   else 
   begin   
      if (wren == 1) 
      begin    
         my_reg [4*cnt+3:4*cnt] &lt;= abcd;   
      end   
   end          
end  
","As for your error: you should use the +: syntax [4*cnt +: 4] 
See here for more information. 

Even if that would be semantically allowed your values would be wrong:


[4*cnt-1:4*cnt] would give a low:high index e.g. if cnt=1 you get [3:4]
[4*cnt-1:4*cnt] gives a negative index if cnt==0 [-1:0] which is outside the range [31:0] of reg.


You probably meant to use [4*cnt+3:4*cnt]

But you have other errors too.

First it is very dangerous to use a keyword for a variable. (reg)

Second you are clocking using a non-clock signal: wren. This creates another clock tree. The normal procedure is to use an if with the standard system clock:

always @(posedge clk or posedge rst)   
begin   
   if (rst == 1) 
   begin 
      my_reg &lt;= 0; 
   end    
   else 
   begin   
      if (wren == 1) 
      begin    
         my_reg [4*cnt +: 4] &lt;= abcd;   
      end   
   end          
end  
",,,,,
Sigasi in Eclipse,"I have just installed the Sigasi Studio pluginin Eclipse (version: Eclipse IDE 2018-12). When I try to launch it,to make a new VHDL file, I get the following:


  The selected wizard could not be started. org/eclipse/lsp4j/Range
  (occurred in com.sigasi.hdt.vhdl.ui.VhdlExecutableExtensionFactory)
  org/eclipse/lsp4j/Range


How I could solve it, please?
Thank you in advance.","SIGASI + GHDL + GTKWAVE (all in one)

It is very powerful combo that you can set up. ATTENTION i use macOS 10.13.6: 

Step 1  

Make sure you have both installed GHDL and GTKWAVE typing 

$ which gtkwave
/usr/local/bin/gtkwave
$ which ghdl
/usr/local/bin/ghdl


Step 2  

Open Sigasi an make new Project and create an additional compile.sh file with:

#!/bin/sh

PROJECT_NAME=""PWM_Generator""
PROJECT_NAME_TB=""PWM_Generator_tb""
WORKING_DIR=""/Users/imeksbank/Dropbox/UMHDL""

/usr/local/bin/ghdl -a --workdir=$WORKING_DIR/work.ghdl $WORKING_DIR/$PROJECT_NAME/$PROJECT_NAME.vhd;
/usr/local/bin/ghdl -a --workdir=$WORKING_DIR/work.ghdl $WORKING_DIR/$PROJECT_NAME/$PROJECT_NAME_TB.vhd;
/usr/local/bin/ghdl -e --workdir=$WORKING_DIR/work.ghdl $PROJECT_NAME_TB;
/usr/local/bin/ghdl -r --workdir=$WORKING_DIR/work.ghdl $PROJECT_NAME_TB --vcd=$WORKING_DIR/$PROJECT_NAME/simulation.vcd;


now, be aware, for each project you create your own variables like  


PROJECT_NAME 
PROJECT_NAME_TB 
WORKING_DIR


I use always Dropbox for such approach because then i can access via Windows as well.
And of course, there is a possibility to create custom variables in Sigasi ->  External Tool Configurator -> Program -> compile_sh -> environment to pass them to make compile.sh independent. Here you have to deal with it by yourself =)

Step 3 . 

Set up you External Tools Configurations to let shell script be executed by Sigasi Studio and create the .vcd file for gtkwave:  

Click on currently created Project (in my case it is the PWM_Generator).
After that click on Run -> External Tools -> External Tools Configurations ....
Then go to the left sidebar and under Program create your own anchor like compile_sh.  

Finally you have your route :


Program  
--compile_sh


And now extend this anchor by a custom created shell script :  

Main->Location gets ${workspace_loc:/PWM_Generator/compile.sh}
Main->Working Directory gets ${workspace_loc:/PWM_Generator}  

Click Apply and Run and that's it !!! After this you can program VHDL / Verilog and compile via Run -> External Tools -> compile_sh having created .vcd. In your project appears the gtkwave file and there just double click and it starts. =) ",,,,,
Variable slicing vector Systemverilog,"I am struggling with the error ""Range must be constant"" when I think it is!

The operation I've to implement is this:

Given a 8 bits signed/unsigned vector and VARIABLE point like : 
b7b6b5b4b3b2.b1b0 or b7b6b5b4b3.b2b1b0

I have to add the integer part with the first fractional bit, for example:

b7b6b5b4b3b2 + b1 for the first word,
b7b6b5b4b3+b2 for the second case.

The number of fractional bits are given by a port named ""port_scale"" wide C_SHIFT_BITS.

This is my code, I want to generate all the combinations:

C_SHIFT_BITS = 4; 

always_comb begin
   for (int k=1; k&lt;2**(C_SHIFT_BITS-1); k++) begin
       dout_temp[k-1][8:0] = din[(k-1)+:8-k] + din[(k-1)+:1]
   end
   for (int k=1; k&lt;2**(C_SHIFT_BITS-1); k++) begin
       if (port_scale == k) begin
          dout = dout_temp[k][8:0];
       end
   end
end


Do you have another solution or way to code this to make it general? I wouldn't code a massive case statement, since the parameter C_SHIFT_BITS might be any number, less than the width of din. The for loop should workaround the illegal din[port_scale...] but it's not working as expected.

Thanks","I think you simply need to shift by k

 dout_temp[k-1][8:0] = (din &gt;&gt; k-1) + din[k];


Also you can get rid off your second for loop and do

  dout = dout_temp[port_scale][8:0];
",,,,,
randomizing number of 1's in an array in UVM without using $countones?,"In UVM , I want to constraint an array such that I can fix the number of ones in an array to 3, I have written the following code using constraint which uses $countones, but how to do it without using $countones ??  

class class_1;
rand bit[31:0] array;

constraint three_ones {
$countones(array) == 3;
}
endclass
","What you wrote is equivalent to

constraint three_ones {
int'(array[0]) + int'(array[1]) + int'(array[2]) + ... + int'(array[31]) )
   == 3;
}
endclass


Update

To do this programmatically without any functions, you can create another array with a list of indexes that should be set to one. The size of the array is the number of one you want set.

bit [0:255] array;
int countones = 5;
rand int unsigned bitset[]; 
constraint c_bits { bitset.size == countones;
                    foreach(bitset[i]) bitset[i] inside {[0;$bits(array)-1];
                    unique {bitset};
                  }
function void post_randomize();
   array = 0;
   foreach(bitset[i]) array[bitset[i]] = 1'b1;
endfunction


Now there is a way to do this without the unique constraint, and without post_randomize, but that's too much work for me.                   ",,,,,
How to flag an issue in SystemVerilog spec,"I found an issue in an Electronics Design Automation proprietary language and decided to look it up to see how things were handled in SystemVerilog and found that the LRM just skated over a topic that needs clarification.

I tried to find a blog or email on the IEEE and Accellera sites but failed.

My question is: how do I contact that IEE group working on SystemVerilog, to indicate an issue that could do with clarification in their spec?

Thanks :-)","I am a member of the IEEE working group.

The IEEE has a bug tracking system that you visit as a guest to see if the issue is already reported. You can also post your issue on a popular SystemVerilog forum like https://verificationacademy.com/forums/systemverilog or https://www.quora.com/topic/SystemVerilog and there is usually someone for the group there to respond. ",,,,,
How does this Verilog Code work? It has two separate but same negedge conditions within the same always block statement,"I am wondering this code works perfectly. I want to understand how the two negedge states work within the always block.

#5 clk = ~clk;

always
begin
@(negedge clk) din = 1;
@(negedge clk) din = 0;
end ```


","simulation will do the following:


start the always block execution
wait for negedge of clk
assign 1 to din
wait for negedge of clk (the next one)
assign 0 to din
re-start execution of the always block, go to step 1.


So, value of din will alternate between negedges of clk.",,,,,
XOR in always sensitivity list. Verilog,"can someone explaine what is happening in this line ""always @ (posedge (sclk ^ (CPHA ^ CPOL)) or posedge spi_word_send"". Im beginer in verilog, and dont understand how possible use XOR in sensitivity list. Thank you.","In general, procedural blocks can contain delay or wait-on-event statements that block the procedure until the time or event is satisfied. These statements are used in both simulation and synthesis for writing testbenches and describing logic; the flexibility of these constructs (like the # delay or the @ event wait) is rather extensive. However, when using these to actually describe hardware, you can only using these in limited situations.

Your case: @(posedge (sclk ^ (CPHA ^ CPOL)) or posedge spi_word_send) is simply saying Wait until either the expression sclk ^ CPHA ^ CPOL goes from low to high (posedge) or spi_word_send to go from low to high, then do the expressions contained in the always block (one example of the xor expression changing from low to high would be sclk = 1, CPHA = 1, CPOL = 0 becoming sclk = 1, CPHA = 1, CPOL = 1, (1 ^ 1 ^ 0 = 0, 1 ^ 1 ^ 1 = 1). 

The language allows you to have such complex wait expressions and simulation tools will generally run it as expected, but if the expression is supposed to be synthesized, you need to be sure you are actually describing the hardware you want. As toolic mentioned, this is not good style and is describing a flipflop with a rather complex clock signal (or maybe set/reset, the synthesis tool will try its best but it will probably generate something strange for this if it passes at all); its certainly asynchronous logic. Most designs are synchronous and synthesis tools generally are designed to handle synchronous designs when they are described behaviorally like the one above. As such, there are significant restrictions put on the always @ blocks, ie to be something like always @(posedge some_clock or negedge some_asserted_low_reset), to make sure the code infer clean flipflops will clear clocks and resets.",,,,,
How to program a delay in Verilog?,"I'm trying to make a morse code display using an led. I need a half second pulse of the light to represent a dot and a 1.5 second pulse to represent a dash. 

I'm really stuck here. I have made a counter using an internal 50MHz clock on my FPGA. The machine I have to make will take as input a 3 bit number and translate that to a morse letter, A-H with A being 000, B being 001 and so on. I just need to figure out how to tell the FPGA to keep the led on for the specified time and then turn off for about a second (that would be the delay between a dot pulse and a dash pulse).

Any tips would be greatly appreciated.
Also, it has to be synthesizable.

Here is my code. It's not functioning yet. The error message it keeps giving me is:


  Error (10028): Can't resolve multiple constant drivers for net ""c3[0]""
  at part4.v(149)


module part4 (SELECT, CLK, CLOCK_50, RESET, led);
input [2:0]SELECT;
input RESET, CLK, CLOCK_50;
output reg led=0;
reg [26:0] COUNT=0; //register that keeps track of count
reg [1:0] COUNT2=0; //keeps track of half seconds
reg halfsecflag=0;  //goes high every time half second passes
reg dashflag=0;     //goes high every time 1 and half second passes
reg [3:0] code;     //1 is dot and 0 is dash. There are 4 total
reg [1:0] c3;       //keeps track of the index we are on in the code.
reg [3:0] STATE;    //register to keep track of states in the state machine
reg done=0;         //a flag that goes up when one morse pulse is done.
reg ending=0;       //another flag that goes up when a whole morse letter has flashed
reg [1:0] length;   //This is the length of the morse letter. It varies from 1 to 4
wire i;             // if i is 1, then the state machine goes to ""dot"". if 0 ""dash""

assign i = code[c3];

parameter START= 4'b000, DOT= 4'b001, DASH= 4'b010, DELAY= 4'b011, IDLE= 
4'b100;

parameter A= 3'b000, B=3'b001, C=3'b010, D=3'b011, E=3'b100, F=3'b101, 
G=3'b110, H=3'b111;


always @(posedge CLOCK_50 or posedge RESET) //making counter
begin
    if (RESET == 1)
        COUNT &lt;= 0;
    else if (COUNT==8'd25000000)
    begin
        COUNT &lt;= 0;
        halfsecflag &lt;= 1;
    end
    else
    begin
        COUNT &lt;= COUNT+1;
        halfsecflag &lt;=0;
    end
end

always @(posedge CLOCK_50 or posedge RESET)
begin
    if (RESET == 1)
        COUNT2 &lt;= 0;
    else if ((COUNT2==2)&amp;&amp;(halfsecflag==1))
    begin
        COUNT2 = 0;
        dashflag=1;
    end
    else if (halfsecflag==1)
        COUNT2= COUNT2+1;
end



always @(RESET) //asynchronous reset
begin
    STATE=IDLE;
end


always@(STATE) //State machine
begin
    done=0;
    case(STATE)

        START: begin
            led = 1;
            if (i) STATE = DOT;
            else STATE = DASH;
        end

        DOT: begin
            if (halfsecflag &amp;&amp; ~ending) STATE = DELAY;
            else if (ending) STATE= IDLE;
            else STATE=DOT;
        end

        DASH: begin
            if ((dashflag)&amp;&amp; (~ending))
                STATE = DELAY;
            else if (ending)
                STATE = IDLE;
            else STATE = DASH;
        end

        DELAY: begin
            led = 0;
            if ((halfsecflag)&amp;&amp;(ending))
                STATE=IDLE;
            else if ((halfsecflag)&amp;&amp;(~ending))
            begin
                done=1;
                STATE=START;
            end
            else STATE = DELAY;
        end

        IDLE: begin
            c3=0;
            if (CLK) STATE=START;
            else STATE=IDLE;
        end

        default: STATE = IDLE;

    endcase
end


always @(posedge CLK)
begin
    case (SELECT)
        A: length=2'b01;
        B: length=2'b11;
        C: length=2'b11;
        D: length=2'b10;
        E: length=2'b00;
        F: length=2'b11;
        G: length=2'b10;
        H: length=2'b11;
        default: length=2'bxx;
    endcase
end

always @(posedge CLK)
begin
    case (SELECT)
        A: code= 4'b0001;
        B: code= 4'b1110;
        C: code= 4'b1010;
        D: code= 4'b0110;
        E: code= 4'b0001;
        F: code= 4'b1011;
        G: code= 4'b0100;
        H: code= 4'b1111;
        default: code=4'bxxxx;
    endcase
end

always @(posedge CLK)
begin 
    if (c3==length) 
    begin
        c3&lt;=0; ending=1;
    end
    else if (done)
        c3&lt;= c3+1;
    end 
endmodule 
","Okay a year later, I know exactly what one should do if they want to create a delay in their verilog program! Essentially, what you should do is create a timer using one of the clocks on your FPGA. For me on my Altera DE1-SoC, the timer I could use is the 50MHz clock known as CLOCK_50. What you do is make a timer module that triggers on the positive (or negative, doesn't matter) edge of the 50MHz clock. Set up a count register that holds a constant value. For example, reg [24:0] timer_limit = 25'd25000000; This is a register that can hold 25 bits. I've set this register to hold the number 25 million. The idea is to flip a bit every time the value in this register is exceeded. Here's some pseudocode to help you understand:
    //Your variable declarations
    reg [24:0] timer_limit = 25'd25000000; //defining our timer limit register
    reg [25:0] timer_count = 0; //See note A
    reg half_sec_clock;

    always@(posedge of CLOCK_50) begin
    if timer_count &gt;= timer_limit then begin
       reset timer_count to 0;
       half_sec_clock = ~half_sec_clock; //toggle your half_sec_clock
    end

Note A: Setting it to zero may or may not initialize count, it's always best to include a reset function that clears your count to zero because you don't know what the initial state is when you're dealing with hardware.
This is the basic idea of how to introduce timing into your hardware. You need to use an onboard clock on your device, trigger on the edge of that clock and create your own slower clock to measure things like seconds. The example above will give you a clock that triggers periodically every half second. For me, this allowed me to easily make a morse code light that could flash on either 1 half second count, or 3 half seconds. My best advice to you beginners is to work in a modular fashion. For example build your half second clock and then test it out to see if you can get a light on your FPGA to toggle once every half second (or whatever interval you want). :) I really hope this is the answer that helps you. I know this is what I was looking for when I originally posted this question so long ago.",,,,,
Declaring and using a static array of constants,"I just got into verilog and I want to write a simple module that gets a 4 bit value in (called data) and outputs an 8bit value for a 7 segment display (called seven_seg).

module LCD_Encoder (
    input clk,
    input rst,
    input [3:0] data,       // digit to write 0-F
    output [6:0] seven_seg, // 7 segment out, LSB -&gt; A, B, C, D, E, F, G &lt;- MSB
    output dp               // decimal point
    );


I didn't want to write if statements all over checking for every 16 different values of the input data and then decide what to display, so I came up with an array like so:

// define 7 segment display, 16(different characters) * 7 bits(7 segment)
localparam [6:0] display [15:0] = {
    // GFE_DCBA
    7'b011_1111, // 0
    7'b000_0110, // 1
    7'b101_1011, // 2
    7'b100_1111, // 3
    7'b110_0110, // 4
    7'b110_1101, // 5
    7'b111_1101, // 6
    7'b000_0111, // 7
    7'b111_1111, // 8
    7'b110_1111, // 9
    7'b111_0111, // A
    7'b111_1100, // B
    7'b011_1001, // C
    7'b101_1110, // D
    7'b111_1001, // E
    7'b111_0001  // F
};


The decimal point on the 7segment display is handled seperately.
However I get this error:


  Constant value or constant expression must be used for initialization


Later I want to use the array like so:

always @(posedge clk or posedge rst) begin
    if (rst == 1'b1) begin
        seven_seg &lt;= 7'b0;
    end
    else begin
        // use 4-bit (0-F) data as address for the array
        seven_seg &lt;= display[data]; // does this work??
    end
end


however I fear that this will end in yet another failure.

I use ISE from Xilinx and for now and I simulate a spartan 6 xc6slx9 (my board arrives next month).

What am I doing wrong here?

Also since display is always going to be static, is there a way to only have it once and not create the circuit every time you instantiate a new module?","You need SystemVerilog support to have a localparam array. That requires Vivado, not ISE. To model this in Verilog, you need to pack the array into a single vector and take a slice out of the vector

localparam [0:(7*16)-1] display  = {
    // GFE_DCBA
    7'b011_1111, // 0
    7'b000_0110, // 1
    7'b101_1011, // 2
    7'b100_1111, // 3
    7'b110_0110, // 4
    7'b110_1101, // 5
    7'b111_1101, // 6
    7'b000_0111, // 7
    7'b111_1111, // 8
    7'b110_1111, // 9
    7'b111_0111, // A
    7'b111_1100, // B
    7'b011_1001, // C
    7'b101_1110, // D
    7'b111_1001, // E
    7'b111_0001  // F
};
seven_seg &lt;= display[data*7+:7];


Also, your output ports need to be declared as reg

output reg [6:0] seven_seg,
",,,,,
Calling tasks from different testbenches systemverilog,"I am trying to call tasks defined in an interface file from a testbench file. the task is defined as 

task master_monitor(
                   output bit [ADDR_WIDTH-1:0] addr,
                   output bit [DATA_WIDTH-1:0] data,
                   output bit we                    
                  );

          while (!cyc_o) @(posedge clk_i);                                                  
          while (!ack_i) @(posedge clk_i);
          addr = adr_o;
          we = we_o;
          if (we_o) begin
            data = dat_o;
          end else begin
            data = dat_i;
          end
          while (cyc_o) @(posedge clk_i);                                                  
     endtask 


In my testbench, the interface is instantiated as wb_bus and I am trying to call the task in the following way:

wire [WB_DATA_WIDTH-1:0] dat_wr_o;
wire [WB_DATA_WIDTH-1:0] adr;
wire we;
initial
begin
    repeat(10) begin
    wb_bus.master_monitor(adr, dat_wr_o, we);

    end
end


when I simulate this on modelsim, I end up with these errors:

   ** Error: (vsim-3047) ../testbench/top.sv(52): actual value for formal 'data' of 'master_read' must be assignable.
#    Time: 0 ps  Iteration: 0  Instance: /top File: ../testbench/top.sv
# ** Error: (vsim-3047) ../testbench/top.sv(53): actual value for formal 'we' of 'master_monitor' must be assignable.
#    Time: 0 ps  Iteration: 0  Instance: /top File: ../testbench/top.sv
# ** Error: (vsim-3047) ../testbench/top.sv(53): actual value for formal 'data' of 'master_monitor' must be assignable.
#    Time: 0 ps  Iteration: 0  Instance: /top File: ../testbench/top.sv
# ** Error: (vsim-3047) ../testbench/top.sv(53): actual value for formal 'addr' of 'master_monitor' must be assignable.
#    Time: 0 ps  Iteration: 0  Instance: /top File: ../testbench/top.sv


Am i passing the variables in the right way? Can someone help me out?","You cannot pass wire signals like adr to the output arugment of a task. Either change them to logic, or create intermediate variables that you pass to the task arguments, and then assign them to the wires. ",,,,,
XADC testbench vivado simulation - analog signal problems,"I've finished my project that pass the data from XADC to other components once UART_RXD_PIN is set to ""1"". I'm using BASYS3 board for this project. And now its time to create testbench that simulate ANALOG signal and pass it to 4 different xadc's pins. 

I've tried few examples out there (in the internet), however they are using VERILOG instead of VHDL and XADC isn't used as component like in my project. I've created ""supermain.vhdl"" in which top_main is component so vivado might simulate XADC for itself, however it doesnt work. 

Here is my code:

entity top_main is
    Port (
        CLK              : IN  STD_LOGIC;   
        UART_TXD_pin     : IN  STD_LOGIC;
        UART_RXD_pin     : OUT STD_LOGIC
    );  
end top_main;

architecture Behavioral of top_main is

    -- COMPONENTS --
-- XADC --
COMPONENT XADC_block_input
PORT (
    di_in               : IN  STD_LOGIC_VECTOR(15 DOWNTO 0);
    daddr_in            : IN  STD_LOGIC_VECTOR(6 DOWNTO 0);
    den_in              : IN  STD_LOGIC;
    dwe_in              : IN  STD_LOGIC;
    drdy_out            : OUT STD_LOGIC;
    do_out              : OUT STD_LOGIC_VECTOR(15 DOWNTO 0);
    dclk_in             : IN  STD_LOGIC;
    vp_in               : IN  STD_LOGIC;
    vn_in               : IN  STD_LOGIC;
    reset_in            : IN  STD_LOGIC;
    ------------------------------------    
    vauxp6              : IN  STD_LOGIC;
    vauxn6              : IN  STD_LOGIC;
    vauxp7              : IN  STD_LOGIC;
    vauxn7              : IN  STD_LOGIC;
    vauxp14             : IN  STD_LOGIC;
    vauxn14             : IN  STD_LOGIC;
    vauxp15             : IN  STD_LOGIC;
    vauxn15             : IN  STD_LOGIC;
    ------------------------------------    
    channel_out         : OUT STD_LOGIC_VECTOR(4 DOWNTO 0);
    eoc_out             : OUT STD_LOGIC;
    alarm_out           : OUT STD_LOGIC;
    eos_out             : OUT STD_LOGIC;
    busy_out            : OUT STD_LOGIC
);
END COMPONENT;








type    pmod_addresses is array (0 to 3) of std_logic_vector(6 downto 0); 
constant adress_pmod        : pmod_addresses :=(""0010110"",""0010111"",""0011110"",""0011111"");   -- 6/7/14/15 -&gt; PORTS XADC --
signal  DataValid           : STD_LOGIC;                                                    -- DATA IN VALID
signal  DataReady           : STD_LOGIC;                                                    -- DATA READY (FOR FFT)
signal  index               : INTEGER := 0;                                                 -- INDEX FOR ADC
signal  DataOut             : STD_LOGIC_VECTOR(15 DOWNTO 0);                                -- DATA ADC OUT
signal  nr_adc              : STD_LOGIC_VECTOR(6 downto 0) := adress_pmod(0);   

    -- PORT MAPS --
-- ADC --
XADC_PORT_MAP: XADC_block_input
PORT MAP (
    di_in       =&gt; X""0000"",
    daddr_in    =&gt; nr_adc,
    den_in      =&gt; DataValid,
    dwe_in      =&gt; '0',
    drdy_out    =&gt; DataReady,
    do_out      =&gt; DataOut,
    dclk_in     =&gt; CLK_128MHz,
    vp_in       =&gt; '0',
    vn_in       =&gt; '0',
    reset_in    =&gt; MASTER_RESET, 
    ------------------------------------    
    vauxp6      =&gt; ADC_6P_J3,
    vauxn6      =&gt; ADC_6N_K3,
    vauxp7      =&gt; ADC_7P_M2,
    vauxn7      =&gt; ADC_7N_M1,
    vauxp14     =&gt; ADC_14P_L3,
    vauxn14     =&gt; ADC_14N_M3,
    vauxp15     =&gt; ADC_15P_N2,
    vauxn15     =&gt; ADC_15N_N1,
    ------------------------------------    
    channel_out =&gt; open,
    eoc_out     =&gt; DataValid,
    alarm_out   =&gt; open,
    eos_out     =&gt; open,
    busy_out    =&gt; open
);

-- ADC DATA FORWARDING --
p_XADC_PORT_ADDRESING: process(CLK_128MHz)
begin
    if(rising_edge(CLK_128MHz)) then
        if(DataReady = '1') then       
            case nr_adc is
                when adress_pmod(0) =&gt;   
                    XADC_1_FIR_1 &lt;= DataOut ;
                when adress_pmod(1) =&gt;   
                    XADC_2_FIR_2 &lt;= DataOut ;
                when adress_pmod(2) =&gt;   
                    XADC_3_FIR_3 &lt;= DataOut ;
                when adress_pmod(3) =&gt;   
                    XADC_4_FIR_4 &lt;= DataOut ;
                when others =&gt;
                    XADC_1_FIR_1 &lt;= (others=&gt;'0'); 
                    XADC_2_FIR_2 &lt;= (others=&gt;'0'); 
                    XADC_3_FIR_3 &lt;= (others=&gt;'0'); 
                    XADC_4_FIR_4 &lt;= (others=&gt;'0'); 
                end case;
            if index = 0 then
                index &lt;= 1;
            else 
                index &lt;= 0;
            end if;
            nr_adc  &lt;= adress_pmod(index);
        end if;
    end if;
end process p_XADC_PORT_ADDRESING;


And here is super main with just entity and testbench code.

entity supermain is
     Port (
    CLK              : IN  STD_LOGIC;    
    UART_TXD_pin     : IN  STD_LOGIC;
    UART_RXD_pin     : OUT STD_LOGIC
);

end supermain;

architecture Behavioral of supermain is

component top_main
    Port (
        CLK              : IN  STD_LOGIC;   
        UART_TXD_pin     : IN  STD_LOGIC;
        UART_RXD_pin     : OUT STD_LOGIC
    );  
end component;

begin

symulacja : top_main
  PORT MAP (
    CLK                 =&gt; CLK,
    UART_TXD_pin        =&gt; UART_TXD_pin,
    UART_RXD_pin        =&gt; UART_RXD_pin
    );  



    end Behavioral;


    entity supermain_tb is
end;

architecture bench of supermain_tb is

  component supermain
       Port (
      CLK              : IN  STD_LOGIC;    
      UART_TXD_pin     : IN  STD_LOGIC;
      UART_RXD_pin     : OUT STD_LOGIC
  );
  end component;

  signal CLK: STD_LOGIC;
  signal UART_TXD_pin: STD_LOGIC;
  signal UART_RXD_pin: STD_LOGIC ;

  constant clock_period: time := 1 ms;
  signal stop_the_clock: boolean;


begin

  uut: supermain port map ( CLK          =&gt; CLK,
                            UART_TXD_pin =&gt; UART_TXD_pin,
                            UART_RXD_pin =&gt; UART_RXD_pin );

  stimulus: process
  begin
   UART_TXD_pin &lt;= '1' after 100 ns, '0' after 100 ns;
    -- Put initialisation code here


    -- Put test bench stimulus code here
    wait;
  end process;

  clocking: process
  begin
    while not stop_the_clock loop
      CLK &lt;= '0', '1' after clock_period / 2;
      wait for clock_period;
    end loop;
    wait;
  end process;

end;


Could you please tell me how to simulate ANALOG signal in testbench? Because for now it doesn't even ","To simulate the Analog input you need to use the Analog Stimulus file. 

In UG480 http://www.xilinx.com/support/documentation/user_guides/ug480_7Series_XADC.pdf there is an example including the Stimulus file and testbench. 

SIM_MONITOR_FILE => ""design.txt""  -- Analog simulation data file name

You can also see an example of the stimulus file in the Vivado Language Templates
Vivado Language Template",,,,,
Can you make an array of types in VHDL?,"Vivado Simulation cannot support unconstrained types which have a signed component to them.

i.e.

type A is array (natural range &lt;&gt;) of signed;


I have been using this in a design where type A is used in port declarations as I wish to have a parallel design which I control through a generic as well as the current stage word length e.g.

port (
inputdata : A(0 to number_of_parallel_generic-1)(stage_wordlength_generic-1 downto 0)
);


As I use the type A with many variations of the generics controling them e.g. 4 wide arrays with 16 wordlengths and other variations (often controled by a for generate loop)

for i in 0 to length_of_generate_statement-1 generate
    signal example_signal : A(0 to 3)(stage_wordlength_generic + i - 1 downto 0);
begin
    &lt;functional code&gt;
end generate;


This sort of code would allow me to gain bit growth from sequential sections of my archetecture - e.g. from an addition.

Now... getting to the question at hand.

One way I could get round this rather than initiating a signal with a forever changing generate statement could actually be in the creation of an ""array of types"".

Lend me your eyes this is written in a not quite vhdl way but hopefully you can see what Im trying to do.

type my_arr_of_types is array(0 to length_of_array-1) of type;

for i in 0 to length_of_array-1 generate
    my_arr_of_types(i) &lt;= &lt;type declaration with some dependance on i&gt;;
end generate;


Hopefully you can see what I am trying to do.

This would allow you to then call an element of the my_arr_of_types which itself is a type to then assign to a signal/variable.

i.e.
    signal my_sig : my_arr_of_types(n);

*Where n is any valid index of the array.

Obviously this is not allowed in VHDL or any simulation tool. But can anyone see a potential solution to my problem?

Remember I use most of these types on port statements so any solution has to fit within the limitations of the port declarations.","Using two dimensional arrays as a solution:

Package

library ieee;
use     ieee.numeric_std.all;

package utilities is
  type T_SLM is array(natural range &lt;&gt;, natural range &lt;&gt;) of std_logic;
end package;


Entity

Now you can use this type in a port declaration together with two generic parameters. As sizes are now known in the architecture, you can create your used defined type of signed values and you can use either generate statements or a function to convert from the T_SLM to myArray type.

library ieee;
use     ieee.numeric_std.all;

library myLib;
use     myLib.utilities.all;

entity foo is
  generic (
    number_of_parallel : natural;
    stage_wordlength   : natural
  );
  port (
    Input : T_SLM(0 to number_of_parallel - 1, stage_wordlength - 1 downto 0)
  );
end entity;

architecture a of foo is
  type myArray is array (natural range &lt;&gt;) of signed(Input'range(2));

  function convert(matrix : T_SLM) return myArray is
    variable result : myArray(matrix'range(1));
  begin
    for i in matrix'range(1) loop
      for k in matrix'range(2) loop
        result(i)(j) := matrix(i, j);
      end loop;
    end loop;
    return result;
  end function;

  signal InputData1 : myArray(Input'range(1));
  signal InputData2 : myArray(Input'range(1));
begin
  genInput: for i in Input'range(1) generate
    genInput: for j in Input'range(2) generate
      InputData1(i)(j) &lt;= Input(i, j);
    end generate;
  end generate;

  InputData2 &lt;= convert(Input);
end architecture;


Many helper functions like this have been implemented in the PoC Library in package PoC.vectors.",,,,,
Verilog For loop with no condition gives error: expecting operand,"I am using Verilog (not SystemVerilog) and trying to use a for loop with no condition in the middle.

It says ""expecting operand"".

for(x=5;;x++ ) begin
            led[x] &lt;= 1;
",Verilog for loop requires a middle condition. Verilog does not have the ++ operator either. ,,,,,
What does the line in bold mean regarding $monitor in Verilog?,"This is from Verilog IEEE reference manual: 


  ""The $monitor and $strobe system tasks (see 17.1) create monitor events for their arguments. These events are continuously re-enabled in every successive time step. The monitor events are unique in that they cannot create any other events.""


What does the line in bold mean?

Link for the manual: http://www-inst.eecs.berkeley.edu/~cs150/fa06/Labs/verilog-ieee.pdf

Topic 5.3, Page 78","The Verilog 1364-2001 LRM is 18 years old and has been updated several times. 

The current LRM has completely re-written this section and formally defined this as the postponed event region. This is the last event region before advancing time to the next time slot. All other regions have the opportunity to schedule more events and repeat event regions. The Postponed region is read-only.

For both $monitor and $strobe, this means that the signals it prints are the final values for that time slot. There is no possibility for further changes to the signals in the current time slot.",,,,,
Instantaneous module does not perform subtraction properly,"I am trying to perform subtraction when ALX is 1 and ALY is 0 using instantaneous carry look ahead adder but it does not work properly. It works fine for addition.
 


if ALX is 0 and ALY is also 0 it will load input to output
if ALX is 0 and ALY is  1 it will add input to output
if ALX is 1 and ALY is 0 it will sub input to output
if ALX is 1 and ALY is also 1 it will and input to output


Here is some of my alu module

module alu (CLK, RST, ALE, ALX , ALY, iDATA, oDATA , flags,aDATA);
input wire CLK, ALE, ALX, ALY,RST;
input wire [3:0] iDATA;
output reg [3:0] oDATA;
output reg [3:0] flags;
output reg [2:0] aDATA;

//declare variables

reg [3:0] nextflags;
wire [3:0] ALU;
wire [3:0] SUM;
wire CIN;
wire claCF,claZF,claNF,claVF;

cla4 test(iDATA,oDATA,CIN,SUM,claCF,claZF,claNF,claVF);
assign CIN = ALX;
assign ALU = ALX ? (ALY ? iDATA &amp; oDATA : SUM) : (ALY ? SUM : iDATA ); //loop 
always @ (posedge CLK, posedge RST) begin
if (RST) begin
oDATA &lt;= 0;
flags &lt;= 0;
end

else if(ALE) begin
oDATA &lt;= ALU;
flags &lt;= nextflags;
end

else begin
oDATA &lt;= oDATA;
flags &lt;= flags;
end

always @ (*) begin
aDATA[2:0] = {ALE,ALX,~CIN};
nextflags[3] = ALX ? ( ALY ? flags[3]: claCF ) : (ALY ? claCF : 0 );
nextflags[2] = (ALU==0);
nextflags[1] = ALU[3];
nextflags[0] = ALX ? ( ALY ? flags[0] : claVF ) : (ALY ? claVF : 0 );
end
endmodule


Here is my output


 time:                   0 OUTPUT:0000 ADATA:001 C:0 Z:0 N:0 V:0 
 time:                   1 OUTPUT:0000 ADATA:110 C:0 Z:0 N:0 V:0 
 time:                   2 OUTPUT:0001 ADATA:110 C:1 Z:0 N:0 V:0 
 time:                   4 OUTPUT:0000 ADATA:110 C:1 Z:1 N:0 V:0 
 time:                   6 OUTPUT:0001 ADATA:110 C:1 Z:0 N:0 V:0 
 time:                   8 OUTPUT:0000 ADATA:110 C:1 Z:1 N:0 V:0 
 time:                  10 OUTPUT:0001 ADATA:110 C:1 Z:0 N:0 V:0 
 time:                  12 OUTPUT:0000 ADATA:110 C:1 Z:1 N:0 V:0 
 time:                  14 OUTPUT:0001 ADATA:110 C:1 Z:0 N:0 V:0 
 time:                  16 OUTPUT:0000 ADATA:110 C:1 Z:1 N:0 V:0 
 time:                  18 OUTPUT:0001 ADATA:110 C:1 Z:0 N:0 V:0 
 time:                  20 OUTPUT:0000 ADATA:110 C:1 Z:1 N:0 V:0 
","I made a stupid mistake and I fixed it by changing the oDATA and iDATA location for the carry look ahead adder function calling 

cla4 test(oDATA,iDATA,CIN,SUM,claCF,claZF,claNF,claVF);


because in my carry look ahead adder module, I declare the first variable as the variable who needs to be added to.

module cla4 (X,Y,M,S,CF,ZF,NF,VF);

assign G = X &amp; (Y ^ {4{CIN}});
assign P = X ^ (Y ^ {4{CIN}});


so the output will be running into  a loop because it will basically xor it with carry in to itself. The value just changing back and forth between xor value and its original value.",,,,,
"""Syntax in assignment statement l-value"" Why is this code not compiling?","module FiniteStateMachine(output reg [2:0] Count, input clock, reset);
reg[2:0] state, next_state;

parameter S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100, S5 = 3'b101, S6 = 3'b110, S7 = 3'b111;
always @ (posedge clock, negedge reset)
    if(reset==0) state&lt;=S0;
    else state &lt;= next_state;
    
always @ (state)
    case(state)
        S0: begin
                Count = S0;
                next_state = S1;
            end
        S1: begin
                Count = S1;
                next_state = S2;
            end
        S2: begin
                Count = S3;
                next_state = S3;
            end
        S3: begin
                Count = S7;
                next_state = S4:
            end
        S4: begin
                Count = S6;
                next_state = S5;
            end
        S5: begin
            Count = S4;
                next_state = S0;
            end
        endcase
endmodule

Getting the error:

Syntax in assignment statement l-value

I've also tried &quot;&lt;=&quot; instead of &quot;=&quot; for all the assignments in case, but I'm getting the same error.","You used a colon instead of a semicolon.  Change:

        next_state = S4:


to:

        next_state = S4;
",,,,,
Verilog high impedance inout synthesis,"I generally don't use inout or high impedance states in verilog for synthesis (under the assumption that the internal logic ultimately has to implement it as standard CMOS 2 state logic anyways).

However, I'm finding a lot of verilog that is destined for synthesis that looks like the following:

module top(
    inout signal1,
    inout signal2
);

    submodule sub1 ( 
        //outputs from sub1
        signal1, 
        signal2
    );
    submodule sub2 ( 
        //outputs from sub2
        signal1, 
        signal2
    );

endmodule


Where signal1 and signal2 are only driven to either 1'b0 or 1'bz and they are declare as open-drain ports in the contraints file.

Do most synthesis tools support synthesizing this?  I'm targeting a lattice CPLD and it seems to work fine, but I'm curious if other tools synthesize things like this ok?

Do you typically have to explicitly tell the tools to pull-up the signal? or is this generally not necessary ( I cannot find any mention of pull-ups in the code I'm looking at)","FPGA is equipped with configurable IO banks and depending on how tool is instructed with constraints file you might have an â€˜enableâ€?at your disposal. For driving the open-drain bus generally tri-state buffers are used where (1) output signal (directed towards the bus) is tied to constant zero, (2) enable signal (connected to enable of tri-state buffer) is considered as actual control logic that provides switching between high-Z (generated by physical Bus implementation, i.e. pull-up resistor) and strong 0 (that is sourced from our output signal), (3) input signal (directed towards our internal logic (used for data acquisition and bus arbitration).

Iâ€™ve never seen signals driven with 1â€™bz in RTL code in any of commercial projects iâ€™ve been involved in and my recommendation would be to avoid it as I believe there is always more conventional way to approach it  (solely with logic 1â€™b1 and 1â€™b0 in combination with tri-state buffer)",,,,,
How is it possible to send out a bit every counter update (variable integer range)?,"I've made a code for my I2S transceiver in VHDL (simple). I have to know how it's possible to send after each counter update 1,2,3 one of the 24 bits of the (24 bit) I2S word (with a short statement). for example:

if cnt = 2 =&gt; load bit 1 of left channel
if cnt = 3 =&gt; load bit 2
if cnt = 25 =&gt; load bit 24 of left channel
if cnt = 26 =&gt; load bit 1 of right channel
if cnt = 48 =&gt; load bit 24 of right channel


As you can see, the WS in my code selects the left or right channel. In my testbench I add the testword (2 x 24 bit word).

It's parallel data in and serial out (PISO), so it has to be something like a shift register. 

I've been studying VHDL lately, because I'm a newbie in VHDL, but I don't know how to do this.

Here you can see my written code. Maybe it's a foolish question, but I already searched the whole Internet. Thanks in advance for answer my question.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity Simple_I2S_transceiver_V1 is
generic  (
    DATAWIDTH: integer := 24     
   );

port  
   (
    RST  : in std_logic;
    SCK  : in std_logic;             -- Serial Clock
    BCLK   : in std_logic;             -- Bit Clock
    WS   : inout std_logic;            -- Word Select or Left/Right channel select
    SD     : out std_logic;             -- Serial Data
    PDL  : in std_logic_vector(DATAWIDTH - 1 downto 0);   -- Parallel Data Left
    PDR  : in std_logic_vector(DATAWIDTH - 1 downto 0);   -- Parallel Data Right
    UPD  : inout std_logic;             -- Update data
    READY  : out std_logic;             -- check if data is ready to send (it depends on ""VALID"")
    VALID  : out std_logic             -- Check if data is valid (length) 
   );

end Simple_I2S_transceiver_V1;

architecture behavior of Simple_I2S_transceiver_V1 is
signal PDL_BUF : std_logic_vector(DATAWIDTH - 1 downto 0);
signal PDR_BUF : std_logic_vector(DATAWIDTH - 1 downto 0);
begin 

process(BCLK)

 -- Declaration of optional variables 
 variable bitcounter  : integer range 0 to 48;

 begin
  -------------------------------------------------
  -- RESET all     
  -------------------------------------------------

  if RST = '1' then
   WS  &lt;= '0';
   SD  &lt;= '0';
   READY &lt;= '0';
   VALID &lt;= '0';
   UPD   &lt;= '0';
   PDL_BUF &lt;= (OTHERS =&gt; '0');                                         -- Clear left channel buffer
   PDR_BUF &lt;= (OTHERS =&gt; '0');                 -- Clear right channel buffer
      -------------------------------------------------
  -- Set WS / left/right-channel
      -------------------------------------------------

  elsif (BCLK'event and BCLK = '1') then
   PDL_BUF &lt;= PDL;
   PDR_BUF &lt;= PDR;

   bitcounter := bitcounter + 1;

   if bitcounter = 1 then
    UPD &lt;= '1';
   else 
    UPD &lt;= '0';

   if bitcounter &gt;= 1 and bitcounter &lt;= 24 then  
    WS &lt;= '0';
   else
    WS &lt;= '1';
    UPD &lt;= '0'; 

   if WS = '0' then
    SD &lt;= PDL(23);         &lt;-- Parallel load -&gt; it has to be serial load
   elsif WS = '1' then
    SD &lt;= PDR(23);         &lt;-- The same as PDL

   if bitcounter = 48 then
    bitcounter := 0;

   ----------------------------------------------
     -- transmitt data
   ---------------------------------------------- 
   -- add transmission 

     end if;
       end if;
      end if;
    end if;
   end if;
end process;

end behavior;

","As I2S is MSB first, shift left and use the MSbit of PDx for SD out , something like.  

For left channel (transmit)

SD &lt;= PDL_BUF (23); -- use most significant bit
PDL_BUF &lt;= PDL_BUF (22 downto 0) &amp; '0'; -- 22nd bit becomes 23 and puts a zero into unused bit 0


Similar for right channel. For receive you'll still want to shift left too. 

Sorry I don't know much about I2S, but 


be careful of when loading PDL/PDR such that they can't be modified whilst sending (state machine perhaps?)
be careful when sending data out when setting data clock out high at the same time, you might want to output the data on falling edge of data clock such that the data is latched correctly on the rising edge at the other side correctly. You could always state machine the clock - however this will slow down the data rate.
know when to switch between WS 0 and 1 on transmit
",,,,,
"How to fix ""Indexed name is not a std_logic_vector"" error in my code","I am trying to make a gray code counter by simply counting normal code and then convert it to gray code.

I get this error 

Line 52: Indexed name is not a std_logic_vector


even if I declared that signal as std_logic_vector.

GrayCount &lt;= count(3) &amp; count(3) xor count(2) &amp; count(2) xor count (1) &amp; count (1) xor count(0);


This is 52. line

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity GrayCounter is
     Port ( clock : in  STD_LOGIC;
              ud : in  STD_LOGIC;
              freq_sel : in  STD_LOGIC_VECTOR (1 downto 0);
              GrayCount : out  std_logic_vector (3 downto 0));
end GrayCounter;

architecture Behavioral of GrayCounter is
    signal count : std_logic_vector(3 downto 0);
    signal hz : integer range 0 to 100000000;
    signal clk  : std_logic;
begin
    process(clock)
    begin 
        case freq_sel is
            when ""00"" =&gt; hz &lt;= 2000000;  
            when ""01"" =&gt; hz &lt;= 4000000;
            when ""10"" =&gt; hz &lt;= 10000000;
            when others =&gt; hz &lt;= 100000000;
        end case;
    end process;

    process(clock)
    variable temp : integer range 0 to 100000000;
    begin
        if(clock'event and clock = '1') then
            temp := temp + 1;
            if (temp&gt;(hz/2)) then 
                clk &lt;= not clk;
                temp := 0;
            end if;
        end if;
    end process;

    process(clk)
    begin
        if(clk'event and clk = '1') then
            if(ud = '1') then
                count &lt;= count + 1;
            else
                count &lt;= count - 1 ;
            end if;
        end if;
    end process;

    GrayCount &lt;= count(3) &amp; count(3) xor count(2) &amp; count(2) xor count (1) &amp; count (1) xor count(0);

end Behavioral;
","The operator precedence is not what you probably expected.

You should add brackets:

GrayCount  &lt;= count(3) &amp; (count(3) xor count(2)) &amp; (count(2) xor count (1)) &amp; (count (1) xor count(0));
",,,,,
How to handle multiple simultaneous inputs to a FIFO?,"My verilog code generates DAC ramp signals (channel, value) for 8 channels. I am adding this functionality to a project that already has a DAC controller/communicator and associated FIFO. I would like to add the data I generate simultaneously for all 8 channels to this existing FIFO. I have easily done this for a single channel, but I am not sure the best way to include all the channels. 

The ramps are not very fast, and all the clocks are 50 MHz. So, I have many clock cycles (~150+) to work with. However, data could come from multiple channels in the same clock cycle. 

Should I create 8 FIFOs (only big enough for a few instructions), 1 per channel? Or is there a more efficient way to do this? 

If I lose an occasional data point, that wouldn't be a big problem.","Not sure if this is simple CDC fifo or something else but this can be done in many ways, if You have plenty of time before arrival of next data packet then You can:


(1) In push domain implement simple round-robin algorithm that will push data from each channel sequentially. You might want to add 3bit side-band signal for channel identification so that pop domain could distribute it further based on actual data origin.
(2) aggregate all data before push to the FIFO and just make FIFO data port width equal to width of 8x input channels. In the pop domain You can de-aggregate it again (if needed), positioning should be deterministic so this operation would be very straightforward.


If there is need for some sort of more sophisticated data flow management You might be forced to use 8 separate FIFOs.",,,,,
What is the best way to detect pulses between two clock domains?,"I want to transfer a pulse from a clock domain clk1 to another clock domain clk2, but we don't know which one is faster than the other!
What is the best way to do that?

Thanks,","You need a strobe synchronizer.

A strobe synchronizer translates a rising edge on input to a level change (T-FF). This level change is transferred to the second clock domain via 2-FF synchronizer. The information is then restored by an XOR gate. (Note: A T-FF is a D-FF with a XOR to invert the state on every high input.)

In addition, a busy state can be calculated to notify the sending clock domain about the state of the overall circuit. This busy signal can be used to lock the input's rising edge detection.

The circuit looks like this:


Source Code for multiple bits at once:

library IEEE;
use     IEEE.STD_LOGIC_1164.all;
use     IEEE.NUMERIC_STD.all;

library PoC;
use     PoC.sync.all;


entity sync_Strobe is
    generic (
        BITS                : positive            := 1;                       -- number of bit to be synchronized
        GATED_INPUT_BY_BUSY : boolean             := TRUE;                    -- use gated input (by busy signal)
        SYNC_DEPTH          : T_MISC_SYNC_DEPTH   := T_MISC_SYNC_DEPTH'low    -- generate SYNC_DEPTH many stages, at least 2
    );
    port (
        Clock1              : in  std_logic;                            -- &lt;Clock&gt;  input clock domain
        Clock2              : in  std_logic;                            -- &lt;Clock&gt;  output clock domain
        Input               : in  std_logic_vector(BITS - 1 downto 0);  -- @Clock1:  input bits
        Output              : out std_logic_vector(BITS - 1 downto 0);  -- @Clock2:  output bits
        Busy                : out  std_logic_vector(BITS - 1 downto 0)  -- @Clock1:  busy bits
    );
end entity;


architecture rtl of sync_Strobe is
    attribute SHREG_EXTRACT : string;

    signal syncClk1_In      : std_logic_vector(BITS - 1 downto 0);
    signal syncClk1_Out     : std_logic_vector(BITS - 1 downto 0);
    signal syncClk2_In      : std_logic_vector(BITS - 1 downto 0);
    signal syncClk2_Out     : std_logic_vector(BITS - 1 downto 0);

begin
    gen : for i in 0 to BITS - 1 generate
        signal D0             : std_logic      := '0';
        signal T1             : std_logic      := '0';
        signal D2             : std_logic      := '0';

        signal Changed_Clk1   : std_logic;
        signal Changed_Clk2   : std_logic;
        signal Busy_i         : std_logic;

        -- Prevent XST from translating two FFs into SRL plus FF
        attribute SHREG_EXTRACT of D0  : signal is ""NO"";
        attribute SHREG_EXTRACT of T1  : signal is ""NO"";
        attribute SHREG_EXTRACT of D2  : signal is ""NO"";

    begin
        process(Clock1)
        begin
            if rising_edge(Clock1) then
                -- input delay for rising edge detection
                D0    &lt;= Input(i);

                -- T-FF to converts a strobe to a flag signal
                if GATED_INPUT_BY_BUSY then
                    T1  &lt;= (Changed_Clk1 and not Busy_i) xor T1;
                else
                    T1  &lt;= Changed_Clk1 xor T1;
                end if;
            end if;
        end process;

        -- D-FF for level change detection (both edges)
        D2  &lt;= syncClk2_Out(i) when rising_edge(Clock2);

        -- assign syncClk*_In signals
        syncClk2_In(i)  &lt;= T1;
        syncClk1_In(i)  &lt;= syncClk2_Out(i);         -- D2

        Changed_Clk1    &lt;= not D0 and Input(i);     -- rising edge detection
        Changed_Clk2    &lt;= syncClk2_Out(i) xor D2;  -- level change detection; restore strobe signal from flag
        Busy_i          &lt;= T1 xor syncClk1_Out(i);  -- calculate busy signal

        -- output signals
        Output(i)        &lt;= Changed_Clk2;
        Busy(i)          &lt;= Busy_i;
    end generate;

    syncClk2 : entity PoC.sync_Bits
        generic map (
            BITS        =&gt; BITS,          -- number of bit to be synchronized
            SYNC_DEPTH  =&gt; SYNC_DEPTH
        )
        port map (
            Clock       =&gt; Clock2,        -- &lt;Clock&gt;  output clock domain
            Input       =&gt; syncClk2_In,   -- @async:  input bits
            Output      =&gt; syncClk2_Out   -- @Clock:  output bits
        );

    syncClk1 : entity PoC.sync_Bits
        generic map (
            BITS        =&gt; BITS,          -- number of bit to be synchronized
            SYNC_DEPTH  =&gt; SYNC_DEPTH
        )
        port map (
            Clock       =&gt; Clock1,        -- &lt;Clock&gt;  output clock domain
            Input       =&gt; syncClk1_In,   -- @async:  input bits
            Output      =&gt; syncClk1_Out   -- @Clock:  output bits
        );
end architecture;


The source code can be found here: PoC.misc.sync.Strobe",,,,,
infinite loop in verilog when vvp,"This code stuck in infinite loop when I run vvp, and I do not know why.

This code is compiled without any error.

Is there anyone that can figure out why this code stuck in infinite loop?

module full_adder(a, b, m, s);
parameter W = 4;
output [W-1:0] s;
input [W-1:0] a, b;
input [W:0] m;

reg i;
reg [W-1:0] s_;
always @(*) begin
    for (i = 0; i &lt; W; i = i + 1) begin
        if (a[i] &amp; b[i] &amp; m[i]) s_[i] = 1;
        else if (a[i] &amp; ~b[i] &amp; ~m[i] | ~a[i] &amp; b[i] &amp; ~m[i] | ~a[i] &amp; ~b[i] &amp; ~m[i]) s_[i] = 1;
        else s_[i] = 0;
        // when 1 is odd between a, b and carry then s is 1
    end
end
assign s[W-1:0] = s_[W-1:0];
endmodule

module cla_gen(C, P, G, C0);
parameter W = 4;
output [W:0] C;
input [W-1:0] P, G;
input C0;

reg [W:0] c;
reg i;
always @(*) begin
    for (i = 1; i &lt;= W; i = i + 1) begin
        c[i] = G[i-1] + P[i-1] &amp; c[i-1];
    end
end
assign C = c;
endmodule

module addsub_cla(S, C, V, A, B, M);
parameter W = 4;
output [W-1:0] S;
output C, V;
input [W-1:0] A, B;
input M;

wire [W:0] carry;
cla_gen CLAGEN(.C(carry), .P(A &amp; ~B | ~A &amp; B), .G(A &amp; B), .C0(M));
assign carry[0] = M;
full_adder FA(.a(A), .b(B), .m(carry), .s(S));
assign C = carry[W];
assign V = (carry[W] != carry[W-1]) ? 1 : 0;
endmodule
","You have coded two infinite loops. In this declaration, i is one bit wide:

reg i;


So, this is an infinite loop (because i is always less than W):

for (i = 1; i &lt;= W; i = i + 1) begin


Surely, you meant 

integer i;


I would recommend always using an integer for a loop variable, rather than some other type with a more limited bit width. ",,,,,
Register type variable gives error : unknown type,"I'm making a 1 bit positive edge Dflipflop. All outputs should be assigned only when there is a positive edge of the clock signal.
Q is same as D, Qbar is the negation of D.

It somehow works when I try this with Qbar as a wire. 

assign Qbar = ~Q;


outside of the always block. But the original code as below gives an error that ""Syntax error near ="" and ""Qbar is an unknown type""

I've tried to make Qbar assignment a non blocking type, but it has no effect.

module DFlipFlop(
    input D,
    input clk,
    output reg Qbar,
    output reg Q
    );
//assign Qbar = ~D;
always @(posedge clk)
     Q = D;
     Qbar = ~D; 
endmodule


What am I missing here? I'm new to verilog.","Your error message is caused by the fact that in Verilog if you have more than one statement in an always block (and in other places too) it must be enclosed within a begin - end construct. So, you needed this:

module DFlipFlop(
    input D,
    input clk,
    output reg Qbar,
    output reg Q
    );

  always @(posedge clk) begin
     Q = D;
     Qbar = ~D; 
  end
endmodule


However, that isn't a good solution, because

i) (unless you know what you're doing) always use non-blocking assignments for variables that are to become flip-flops after synthesis and

ii) using a wire and assign statement is probably a better solution anyway, because (initially at least) if you assign to two separate variables within a clocked always block, your synthesiser with output two flip-flops - one for Q and one for Qbar. 

This is a better solution:

module DFlipFlop(
    input D,
    input clk,
    output Qbar,
    output reg Q
    );

  always @(posedge clk)
     Q &lt;= D;

  assign Qbar = ~Q;

endmodule
",,,,,
Add functional coverage to signal with condition,"I'm new to functional coverage in system-verilog. I want to write a covergroup when two signal are not equal.

For example, I have two separate coverages for each signal.

    covergroup group1 @(posedge `TB_TOP.clk); 
    cpb_1 : coverpoint `TB_TOP.sig1 {
        bins r_zero = {0};
        bins r_one = {1};
     endgroup
    covergroup group2 @(posedge `TB_TOP.clk); 
    cpb_2 : coverpoint `TB_TOP.sig2 {
        bins r_zero = {0};
        bins r_one = {1};
     endgroup


Now I want to add another when sig1 not equal to sig2 at posedge of clock. 
Thanks","You mean something like this?

covergroup group3 @(posedge `TB_TOP.clk);
  // coverpoint can take an expression, so provide sig1!=sig2
  cpb_3: coverpoint (`TB_TOP.sig1 != `TB_TOP.sig2) {
    // Since we only want to cover this case, sample a true value (1) only
    bins covered = {1};
  }
endgroup
",,,,,
sintaxis error that i can t understand with port map,"i am trying to do a fulladder of 4 bits from a fulladder 1bit but the plataform vivado that i am using give a syntaxis error but i don t know why?
 here is the first module (the name is HA2(Fulladder1bits(i have to change the letters HA2 for FA but i know how to do it yet)))

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity HA2 is
    Port ( a : in  STD_LOGIC;
           b : in  STD_LOGIC;
           s : out  STD_LOGIC;
           cin : in  STD_LOGIC;
           count : out  STD_LOGIC);
end HA2;

architecture Behavioral of HA2 is

begin

s &lt;= a xor b xor cin;
count &lt;= (a and b) or (cin and (a or b));

end Behavioral;


and the error is in this next module (named ""fulladder4bits"" ) :

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity fulladder4bits is
    Port ( A : in STD_LOGIC_VECTOR (3 downto 0);
           B : in STD_LOGIC_VECTOR (3 downto 0);
           S : out STD_LOGIC_VECTOR (3 downto 0);
           C3 : out STD_LOGIC);
end fulladder4bits;

architecture Behavioral of fulladder4bits is

COMPONENT HA2
    Port ( a : in  STD_LOGIC;
           b : in  STD_LOGIC;
           s : out  STD_LOGIC;
           cin : in  STD_LOGIC;
           count : out  STD_LOGIC);
end COMPONENT;
signal C0,C1,C2 : std_logic ;
begin

fa1 : HA2 port map(A(0),B(0),'0',S(0),C0) ;**HERE the plataform vivado give me a syntaxis error but i don t know why 
fa2 : HA2 port map(A(1),B(1),'C0',S(1),C1) ;**HERE 
fa3 : HA2 port map(A(2),B(2),'C1',S(2),C2) ;**HERE 
fa4 : HA2 port map(A(3),B(3),'C2',S(3),C3) ;**HERE 

end Behavioral;


however with the errors and everything i could do the synthesis and the implementation so i really don t know what is the problem.","The order of the ports in the component is important. Instantiate has used with another order. The order of s and cin is not correct. Therefore, you can use to way to solve problem.

fa1: HA2 port map(A(0), B(0), S(0),'0', C0);
fa2: HA2 port map(A(1), B(1), S(1), C0, C1);
fa3: HA2 port map(A(2), B(2), S(2), C1, C2);
fa4: HA2 port map(A(3), B(3), S(3), C2, C3);


or (this way is better choice)

fa0:HA2 port map(a=&gt;A(0), b=&gt;B(0), cin=&gt;'0', s=&gt;S(0), count=&gt;C0);
fa1:HA2 port map(a=&gt;A(1), b=&gt;B(1), cin=&gt;C0, s=&gt;S(1), count=&gt;C1);
fa2:HA2 port map(a=&gt;A(2), b=&gt;B(2), cin=&gt;C1, s=&gt;S(2), count=&gt;C2);
fa3:HA2 port map(a=&gt;A(3), b=&gt;B(3), cin=&gt;C2, s=&gt;S(3), count=&gt;C3);



  The second problem of your code is 'C0' ('C1', 'C2') in port map. it
  should be C0 (C1, C2).
",,,,,
how to use sensitivity list in multiple processes that are dependent,"I'm writing a code for a simple arithmetic equation d=1+(k*o). I have three processes in my code.the third process is dependent on second and second is dependent on first.I'm unable to keep the sensitivity list correct. The output goes undefined.

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity dcalc is
    Port ( k : in  STD_LOGIC_VECTOR (7 downto 0);
           o : in  STD_LOGIC_VECTOR (7 downto 0);
           e : in  STD_LOGIC_VECTOR (7 downto 0);
           d : out  STD_LOGIC_VECTOR (7 downto 0);
              clk: in  STD_LOGIC);
end dcalc;

architecture Behavioral of dcalc is
COMPONENT divd
    PORT(
         d1 : IN  std_logic_vector(7 downto 0);
         e : IN  std_logic_vector(7 downto 0);
         remi : OUT  std_logic_vector(7 downto 0);
         clk : IN  std_logic
        );
    END COMPONENT;
signal  endp1,d2,k1,o1,e1,d3: unsigned (7 downto 0);
--signal d3:std_logic_vector(7 downto 0);
begin

--process 1
process(k,o,e)
begin
if(clk'event and clk='1') then
k1&lt;=unsigned(k);
o1&lt;=unsigned(o);
e1&lt;=unsigned(e);
endp1&lt;=x""01"";
end if;
end process; 

--process 2
process(endp1)
begin
if(clk'event and clk='1') then
d2&lt;=1+(k1*o1);
end if;
end process;

--process 3
process(d2)
begin
if(clk'event and clk='1') then
d&lt;=std_logic_vector(d2);
end if;
end process;

end Behavioral;


In the first process, conversion is done. When process 1 is done then the d2 should be calculated in process 2. when d2 is calculated in process 2, d should be updated in the process 3. here is my testbench code:

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY ccalctb IS
END ccalctb;

ARCHITECTURE behavior OF ccalctb IS 

    -- Component Declaration for the Unit Under Test (UUT)

    COMPONENT dcalc
    PORT(
         k : IN  std_logic_vector(7 downto 0);
         o : IN  std_logic_vector(7 downto 0);
         e : IN  std_logic_vector(7 downto 0);
         d : OUT  std_logic_vector(7 downto 0);
         clk : IN  std_logic
        );
    END COMPONENT;


   --Inputs
   signal k : std_logic_vector(7 downto 0) := (others =&gt; '0');
   signal o : std_logic_vector(7 downto 0) := (others =&gt; '0');
   signal e : std_logic_vector(7 downto 0) := (others =&gt; '0');
   signal clk : std_logic := '0';

    --Outputs
   signal d : std_logic_vector(7 downto 0);

   -- Clock period definitions
   constant clk_period : time := 10 ns;

BEGIN

    -- Instantiate the Unit Under Test (UUT)
   uut: dcalc PORT MAP (
          k =&gt; k,
          o =&gt; o,
          e =&gt; e,
          d =&gt; d,
          clk =&gt; clk
        );

   -- Clock process definitions
   clk_process :process
   begin
        clk &lt;= '0';
        wait for clk_period/2;
        clk &lt;= '1';
        wait for clk_period/2;
   end process;


   -- Stimulus process
   stim_proc: process
   begin        
      -- hold reset state for 100 ns.
      wait for 100 ns;  
k&lt;=x""07"";
o&lt;=x""08"";
e&lt;=x""07"";
      wait for clk_period*10;

      -- insert stimulus here 

      wait;
   end process;

END;


Please help.
Here is the simulation result after changing all the process sensitivity list to only clk:

","In a synchronous (clocked) process, the sensitivity list is required to be only the clock (and possibly asynchronous reset):

process(clk)
begin
  if RISING_EDGE(clk) then
    k1&lt;=unsigned(k);
    o1&lt;=unsigned(o);
    e1&lt;=unsigned(e);
    endp1&lt;=x""01"";
  end if;
end process;


With your original sensitivity list, changes on the D flip-flop (or register which is a vector of D flip-flops) inputs triggered process execution, but as we know the output doesn't change immediately, it waits for the clock edge.  And then when the clock edge came, clk wasn't in the sensitivity list, so the simulation ignored it.  As a result, your outputs never update in simulation.

(In contrast, synthesis tends to ignore your sensitivity list and just place a logic element configured as a genuine D flip-flop, which will update properly on the clock edge)",,,,,
System Verilog Nested Associative Array,"How do you declare an initialize a nested associative array in System Verilog?

/*
  Creating an associative array(AA) called timings such that
  each key contains an AA with a list of relevant key value pairs
*/
typedef string timingObj [string];
timingObj timings [string] = {""A"": {""B"" : ""C""}, ""X"": {""Y"" : ""Z""} };
//string timings [timingObj] = {""A"": {""B"" : ""C""}, ""X"": {""Y"" : ""Z""} }; //Same error

timingObj t;
$cast(t, timings[""A""]); // t = {""B"" : ""C""}
$display(""%s"", timings[""A""]);
$display(""%s"", t[""B""]);



The code above results in a compiler error

""Syntax error. Unexpected token: }. Expected tokens: ':'."" ""testbench.sv"" 2
""Syntax error. Unexpected token: $cast[_SYSTEM_CAST]. Expected tokens: ';' , 'checker' , 'function' , 'task' , 'timeprecision' ... ."" ""testbench.sv"" 6  6
","Assignment patterns for associative arrays need a '{} mark in front to distinguish it from a concatenation {}. There are some cases where it is ambiguous (but not here). So write 

timingObj timings [string] = '{""A"": '{""B"" : ""C""}, ""X"": '{""Y"" : ""Z""} };
",,,,,
Add delay between sampling and checking,"I have written an assertion property. I want to add delay between sampling and checking action. 

Basically below assertion says that assert_sig should be stable when sig1 or sig2 1. 

property check_assert(assert_sig, assert_sig_dis);
    @(assert_sig)
    disable iff(!lane_assertion_enabled || assert_sig_dis)
    ((sig1!==1'b1) &amp;&amp; (sig2!==1'b1));
  endproperty


Now the issue is assert_sig de-assert same time as sig1 asserts. That's why the assertion fails. I want to add a delay of 1ps between checking action and sampling. Is it possible? Or any other approach would also be appreciated. 
Thanks in advance.","Clocking blocks provide sampling skew

clocking as @(assert_sig)
input #1ps sig1;
endclocking


Then use as.sig1 in your property.",,,,,
How do I fix 'unknown module type error'?,"When I run the Verilog code in terminal, it says there is an error in the first line of my code.


  num_7seg_B.v:2: syntax error


module num_7seg_B SEG_B(out, w, x, y, z);
    output out;
    input w, x, y, z;
    wire y1;
    wire z1;
    wire y_out;
    wire z_out;
    not G1 (y1, y);
    not G2 (z1. z);
    and G3 (y_out, x, y1);
    and G4 (z_out, x, y, z1);
    or  G5 (out, z_out, y_out, w);
endmodule


Here is test base code:

   module TOP;

   wire w,x,y,z,out;
   reg [3:0] num;
   // instantiation of the module
   num_7seg_B SEG_B(out,w,x,y,z);


   // simulation ends at time 200
   initial #200 $finish;


   // num change from 0 to 15, incremented every 5 seconds
    initial begin
     num=0;
     repeat (15)
    #5 num=num+1; 
   end

   // dump files
   initial
   begin
     $dumpfile(""h1_output.vcd"");
     $dumpvars;
   end

   // assignment of signals
   assign w=num[3];
   assign x=num[2];
   assign y=num[1];
   assign z=num[0];
   endmodule
","Fist of all,  a module name cannot contain space.
You can define your module name as:

module num_7seg_B(out, w, x, y, z);


However, using module num_7seg_B SEG_B(out, w, x, y, z); is not an option, since it has 
space between num_7seg_B and SEG_B. 

If you change the module name to module num_7seg_B(out, w, x, y, z);, you will get rid of the syntax error.

You can still use SEG_B as your instance name.",,,,,
Method to delete particular index in dynamic array,"Is there any other method to delete a particular index value from the dynamic array?

Here is my eg to delete index 2 of array a which I am storing it into array b

module top;
  bit[3:0] a [];
  bit[3:0] b [];
  int k=0;
  initial 
  begin
    a={5,6,7,8,9};
    foreach (a[i])
      $display (""a[%0d]:%d"",i,a[i]);   
     b = new [a.size-1]; 
    foreach (a[i]) begin
      if (i == 2) begin
       continue; 
      end
        b[k++] = a[i]; 
    end
    foreach (b[i])
      $display (""b[%0d]:%d"",i,b[i]);
  end
endmodule


output:

a[0]: 5
a[1]: 6
a[2]: 7
a[3]: 8
a[4]: 9
b[0]: 5
b[1]: 6
b[2]: 8
b[3]: 9
","No. Dynamic arrays are designed to be allocated as a whole. Queues are what you want&mdash;they are specifically designed for addition and deletion of one element at a time.

module top;
  bit[3:0] a [];
  bit[3:0] b [$];
  initial 
  begin
    a={5,6,7,8,9};
    foreach (a[i])
      $display (""a[%0d]:%d"",i,a[i]);   
     b = a
     b.delete(2);
    foreach (b[i])
      $display (""b[%0d]:%d"",i,b[i]);
  end
endmodule
",,,,,
Loop for lines and for position of lines,"I want to have a loop that runs the all lines of my code and also that runs every position of all lines.
My problem is in selecting the line that the loop will run, and I want to have simple way to do it without making to write every single line one-by-one, cause the final code will have 66 lines to scan.

Hope you can help me.

Entity of this code will have 66 lines, but I'm just testing it this 10 lines right now:

library ieee;  
use ieee.std_logic_1164.all;  
use ieee.numeric_std.all;  

 entity lshift is  
  port( RED_Buffer1 : in std_logic_vector(6 downto 0);
    RED_Buffer2 : in std_logic_vector(6 downto 0);
    RED_Buffer3 : in std_logic_vector(6 downto 0);
    RED_Buffer4 : in std_logic_vector(6 downto 0);
    RED_Buffer5 : in std_logic_vector(6 downto 0);
    IR_Buffer1 : in std_logic_vector(6 downto 0);
    IR_Buffer2 : in std_logic_vector(6 downto 0);
    IR_Buffer3 : in std_logic_vector(6 downto 0);
    IR_Buffer4 : in std_logic_vector(6 downto 0);
    IR_Buffer5 : in std_logic_vector(6 downto 0);

    output : out bit_vector(1 downto 0)); 
 end lshift;


What I have done so far but with no success:

ARCHITECTURE main OF lshift IS
SIGNAL condition1: boolean;
signal valor : std_ulogic;

BEGIN

PROCESS(IR_Buffer5)
    BEGIN
        FOR I IN 1 TO 5 LOOP
            FOR J IN 1 TO 5 LOOP
                CONSTANT linha_cond : string(1 to 12) := string((""RED_Buffer"") &amp;&amp; I);
                IF (linha_cond(J) = '1') THEN
                    output &lt;= ""01"";
                END IF;
            END LOOP;
        END LOOP;
END PROCESS;


END main;","The purpose of this answer is to demonstrate indexing the subelement values of RED_Buffer1 through RED_Buffer5. Without the purpose of the code being revealed this could easily prove to be an XY Problem question. 

While it is possible to organize RED_Buffer1 through RED_Buffer5 into a value that can be indexed as shown below, there are other issues as well.

library ieee;  
use ieee.std_logic_1164.all;  

entity lshift is  
    port (
        red_buffer1:    in  std_logic_vector (6 downto 0);
        red_buffer2:    in  std_logic_vector (6 downto 0);
        red_buffer3:    in  std_logic_vector (6 downto 0);
        red_buffer4:    in  std_logic_vector (6 downto 0);
        red_buffer5:    in  std_logic_vector (6 downto 0);
        ir_buffer1:     in  std_logic_vector (6 downto 0);
        ir_buffer2:     in  std_logic_vector (6 downto 0);
        ir_buffer3:     in  std_logic_vector (6 downto 0);
        ir_buffer4:     in  std_logic_vector (6 downto 0);
        ir_buffer5:     in  std_logic_vector (6 downto 0);
        output:         out bit_vector (1 downto 0)
    ); 
 end entity lshift;

architecture indexed_array of lshift is 
    signal condition1:  boolean;
    signal valor:       std_ulogic;
    type lbuffer is array (1 to 5) of std_logic_vector (6 downto 0);
    signal red_buffer:  lbuffer;
begin
    red_buffer &lt;= (red_buffer1, red_buffer2, red_buffer3, red_buffer4,
                   red_buffer5);       
    process (red_buffer)
    begin
        for i in 1 to 5 loop
            for j in red_buffer'range loop
                if red_buffer(i)(j) = '1' then
                    output &lt;= ""01"";
                end if;
            end loop;
        end loop;
    end process;
end architecture indexed_array;


How the indexing is implemented here

A composite type (lbuffer) having the requisite number of elements with required element subtype is declared. This is possible because the declarations for ports RED_Buffer1 through RED_Buffer5 share a common subtype indication. Assignment to elements of an object of the type lbuffer would be compatible, having matching elements between the target and right hand expression. 

A signal red_buffer with a type mark of lbuffer is declared.

A concurrent assignment was made to the signal in a concurrent signal assignment statement in the architecture statement part from an aggregate. The association in the aggregate is positional. It could as easily use named association:

    -- red_buffer &lt;= (red_buffer1, red_buffer2, red_buffer3, red_buffer4,
    --                red_buffer5);
   red_buffer &lt;= (1 =&gt; red_buffer1, 2 =&gt; red_buffer2, 3 =&gt; red_buffer3,
                  4 =&gt; red_buffer4, 5 =&gt; red_buffer5);


The type of the aggregate is taken from context, here the assignment statement where red_buffer has the subtype lbuffer.

A selected element of the composite red_buffer is selected by an index name (red_buffer(i)). A subelement of red_buffer(i) is selected by use of an indexed name where the name red_buffer(i) where 'iis a constant using 'j from the inner loop - red_buffer(i)(j). 

Note the range of the j parameter doesn't match the index range of subtype of the lbuffer element subtype here identical to the subtype of RED_Buffer1 through RED_Buffer5. This signifies a further potential semantic issue with the original code, whose purpose isn't made clear here. The only hint present in the original code comes from linha_cond where linha means line in Portuguese or Catalan indicating j is used to index within a 'line'.

The original code fails for two reasons

First an object can't be declared inline in VHDL. The for loop parameter is dynamically elaborated from an implicit declaration, the loop parameter is only visible within the loop statement's sequence of statements. The syntax doesn't allow for additional object declarations.

Second a name for a object declaration is conveyed in an identifier list consisting of one or more identifiers which are lexical elements (lexemes) that cannot be manipulated programmatically. 

Other semantic issues with the question's code

The assignment to output without the passage of time doesn't appear useful.

A process statement is an independently executing concurrent statement wherein the loop statement containing an assignment to the same signal output will overwrite the projected output waveform for elements of output without any intervening passage of time. 

There's only one entry in a projected output waveform queue for any particular simulation time. A simulation cycle consists of signal updates followed by the resumption and subsequent suspension of any processes sensitive to signal updates. The purpose is to emulate parallelism in hardware while describing behavior with sequential statements.

Here that would mean output would be updated to the value ""01"" if any of the if statement conditions in the unrolled loops evaluate to TRUE. That's likely not the intended behavior (without more information from the original poster).

Also note there is no output assignment to a different value and no default or otherwise assigned value. For synthesis this would represent a hold over delay on output until a '1' is first found. 

In both cases this refers to an implicit latch for output.

This issue with the sample code can't be addressed without knowing how it is supposed to work and the only hint that has been shown here on Stackoverflow to date is by a question deleted by the user requiring 10K+ reputation to access (others will see aPage not found message, see revision 1).

Also concepts conveyed from programming or scripting languages don't generally port to Hardware Description Languages which are generally formal notations defined self-referentially (here in IEEE Std 1076, the VHDL Language Reference Manual) requiring inculcation or persistent effort to learn. HDLs generally describe hardware behaviorally and structurally not by programmatic equivalence.",,,,,
Is there a way to print an assert only once at the beggining of a simulation in vhdl?,"I have a vhdl entity which I instanciate in a testbench. 

I would like it to print a report just once at the beginning of the simulation to show which generic was used.

Is that possible with synthetisable code ?

Thanks,

SLP","process
begin
    report ""Integer parameter FOO value = "" &amp; integer'image(FOO);
    wait;
end process;


Caution on the wait; statement! As @user1155120 notes, processes without a sensitivity list will loop infinitely, unless stopped with a wait; statement.",,,,,
System function to read value of a signal,"Error: : (vlog-7027) Hierarchical reference not allowed from within a package.


Is there a system function which can be used to get past this? I know that that using an interface is the right way to read a signal.

What is the reason for not allowing hierarchical references in a package(apart from portability)?","The package construct is all about sharing and portability. The use of packages demands a strict compilation order dependency. Adding hierarchical references to a package breaks this ordering. 

It most cases, using virtual interfaces is a solution to this issue. There are other suggestions in my DVCon paper. Of course, if you could share exactly what you are attempting to do, then I could direct you towards the best course of action.",,,,,
How to fix 'port multiply driven' warnings System Verilog,"I have an AXI UVC which can be configured to be either Master or Slave and an interface with 3 clocking blocks (mst_cb, slv_cb, mon_cb). I get warning messages telling me that a port is multiply driven. How do you fix these warning messages?

I'm not sure but I think the problem lies with the ports having different directions depending on the clocking block used (i.e AWREADY is an input for Master and output for Slave). 

interface axi_if();
  logic aclk;
  logic awready;

  clocking mst_cb @(posedge aclk);
     input awready;
  endclocking

  clocking slv_cb @(posedge aclk);
    ouput awready;
  endclocking

endinterface


I tried to temporarily remove the Slave clocking block and the warning messages were gone. However, I need the Slave clocking block for when the UVC is configured as a Slave.",Most likely this is because someone has a continuous assignment to aready. Change the declaration to a wire. ,,,,,
I put scrambler and descrambler module in vhdl respectively but the result of descrambler is not as same as the input of scrambler,"I have coded the scrambler of the 10G Ethernet. I found out the polynomial from the ieee802.3ae standard. in the document was figured a block diagram(49-10,49-8). when I put scrambler and descrambler module respectively. I can not see the input of scrambler at the output of descrambler.where is my problem? and how can I fix that? 

I have already tried a reverse bit order but it doesn't help me. :(

--I0 is the descrambler input
--my descrambler

    O0(  38 downto  0 ) &lt;= I0(  38 downto  0 ) XOR I1( 63 downto 25 ) XOR 
    I1( 44 downto  6 );
    O0( 57 downto  39 ) &lt;= I0( 57 downto  39 ) XOR I0( 18 downto  0 ) XOR 
    I1( 63 downto 45 );
    O0( 63 downto 58 ) &lt;= I0( 63 downto 58 ) XOR I0( 24 downto 19 ) XOR 
    I0(  5 downto  0 );
    I1  &lt;= I0;


--I0 is the scrambler input
--my scrambler

    OO1 &lt;= O0;
    O0( 38 downto  0  ) &lt;= OO1( 63 downto 25 )  XOR OO1( 44 downto 06 ) 
    XOR I0( 38 downto  0  );
    O0( 57 downto  39 ) &lt;= O0 ( 18 downto  0 )  XOR OO1( 63 downto 45 ) 
    XOR I0( 57 downto 39  );
    O0( 63 downto  58 ) &lt;= O0 ( 24 downto 19 )  XOR  O0( 5  downto 0  ) 
    XOR I0( 63 downto 58  );


my expected result is the similarity between data that I fetch into the scrambler and result of descrambler.Figure 49-8 scrambler ieee802.3ae
Figure 49-10 descrambler ieee802.3ae","I have solved my problem, my problem was a misunderstanding of Fig49-8. 
I implement 64-bit scrambler in one clock.",,,,,
"How can I use the operation ""+"" in vhdl?","I have written some code that contains a procedure that does addition operation.I use ""+"" symbol and compiler does not recognize it.I know that vhdl does not support this symbol, but our professor has asked us to use it in our code.Is there any way I can use ""+"" without being wrong?

I used all the libraries I know without results. Here is my code :

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;
use ieee.std_logic_signed.all;
use ieee.std_logic_arith.all;

package arith_operation is
  constant size: integer :=8;
  constant select_bits: integer :=3;
  procedure add( x,y: in bit_vector(size-1 downto 0);
                 sum: out bit_vector(size-1 downto 0); c_out: out bit );
end arith_operation;

package body arith_operation is
  procedure add
         ( x,y: in bit_vector(size-1 downto 0);
           sum: out bit_vector(size-1 downto 0);
           c_out: out bit) is
  variable s: bit_vector(size downto 0);
  begin
    s:= (""0"" &amp; x) + (""0"" &amp; y);
    sum:= s(size-1 downto 0);
    c_out:= s(size);
  end procedure add;
end arith_operation;


Here is the error that appears :

Error (10327): VHDL error at arith_operation.vhd(22): can't determine definition of operator """"+"""" -- found 0 possible definitions
","This is because your code has not included any packages that perform arithmetic with bit-vectors. Up until VHDL 2008, there was no package for this. VHDL 2008 introduced numeric_bit_unsigned to allow unsigned arithmetic with bit_vectors, as well as numeric_bit that defines unsigned and signed types using bit. (This is in contrast to numeric_std that has the same types defined using std_logic as the base element type).

You also have the issue of conflicting and non-standard libraries. non-standard std_logic_arith should be removed as it clashes with numierc_std. std_logic_unsigned and std_logic_signed are both non-standard and perform arithmetic using std_logic_vectors, and also define the same functions. Ideally you would not use either library as they are non-standard VHDL, but if you have to use them, its easiest way to use them is only include one or the other, not both. (You can use both, but then you will need to use functions with their full path). You could instead use numeric_std_unsigned that was added in VHDL 2008 for unsigned arithmetic with SLVs.",,,,,
Assigning values to signals within for-generate statements,"I cannot figure out why the signal assignment for ""sig2"" in the following example won't happen successfully, while for ""sig1"" it does. With the rising clock edge ""sig2"" becomes 'X'!

What is the reason?

library IEEE;

use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.STD_LOGIC_UNSIGNED.all;

entity Test_tb is
end entity Test_tb;

architecture Structural of Test_tb is

    signal sig1 : std_logic_vector (3 downto 0) := (others =&gt; '0');
    signal sig2 : std_logic_vector (7 downto 0) := (others =&gt; '0');
    signal clk : std_logic := '0';

begin
    clk_generate: process is
    begin
        wait for 5 ns;
        clk &lt;= not clk;        
    end process clk_generate;

    gen_label : for gen_indx in 0 to 3 generate
    begin
        process (clk) is 
        begin
            if clk = '1' and clk'event then
                sig1 (gen_indx) &lt;= '1';
                for loop_indx in 0 to 1 loop
                    sig2 (gen_indx * 2 + loop_indx) &lt;= '1';
                end loop;
            end if; 
        end process;
    end generate gen_label;

end architecture Structural;
","This is because, when a signal is assigned inside a for loop, it is assumed that the driver affects ALL elements of the array (or record). This is because it cannot work out the bounds of the for-loop at elaboration time, as it is a run time concept. This is different from a generate loop where the bounds can be deduced at elaboration time.

So you need to remove the for loop from inside the process, or create a signal local to the generate loop which is assigned to the outer sig2. eg:

gen_label : for gen_indx in 0 to 3 generate
  signal local_sig  : std_logic_vector(1 downto 0);
begin
    process (clk) is 
    begin
        if clk = '1' and clk'event then
            sig1 (gen_indx) &lt;= '1';
            for loop_indx in 0 to 1 loop
                local_sig(loop_indx) &lt;= '1';
            end loop;
        end if; 
    end process;

    sig2(gen_indx*2+1 downto gen_indx*2)  &lt;= local_sig;
end generate gen_label; 
",,,,,
Problem in VHDL: led tratrix displayed even button wasn't pressed,"Sorry for unclearly title, becasue i don't know how to describe it in one sentence.

This is my problem, i'm trying to make a led matrix 8x8 with altera EPM240T100 kit, which display text throught UART. 
  When text transmitted to altera kit, there is a button to active led matrix. Button is linked with a led, when button is pressed, led will be ON state. But this is my problem,after the kit was programmed, the led matrix has displayed immediately even when the button hasn't press yet. And the led, it only active when i press the button. I think i've confused about state of button and i tried to change state of button from button = '1' to button = '0' but nothing changed except that the state of led is  reversed.

My code is showed following:

library IEEE;
library giang;
use giang.define.all;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity UART_arr is
    Port( Clk : in std_logic;
            button: in std_logic;
            led: out std_logic;
            input: in std_logic;
            output: out std_logic;
            msg_input: out msg);
end UART_arr;

architecture Behavioral of UART_arr is
    component UART_RX is
        Port( Clk: in std_logic;
                RX : in std_logic;
                data_out : out std_logic_vector(7 downto 0);
                RX_done  : out std_logic
             );
    end component;
    component UART_TX is
        Port( Clk: in std_logic;
                TX_En : in std_logic;
                data_in : in std_logic_vector(7 downto 0);
                TX : out std_logic
             );
    end component;
    signal msg_buff: msg := (others=&gt;""00000000"");
    signal rx_byte,tx_byte : std_logic_vector(7 downto 0) := (others =&gt; '0');
    signal rx_done,tx_en     : std_logic := '0';
    signal i: integer range 0 to 32 := 0;
    signal led_t: std_logic := '1';
begin
    RX: UART_RX port map (Clk,input,rx_byte,rx_done);
    TX: UART_TX port map (Clk,tx_en,tx_byte,output);

    button_check: process(button)
    begin
        if button = '0' then
            led_t &lt;= '0';
            msg_buff(1) &lt;= ""01100001"";
            msg_input &lt;= msg_buff;
        else
            led_t &lt;= '1';
        end if;
    end process;
    led &lt;= led_t;


This is only a part of my code and it hasn't done yet. There are some data type i have defined in other package: 
type msg is array (1 to max_char) of std_logic_vector(7 downto 0);

And one more thing is when i delete code line else led_t &lt;= '1', both of led and led matrix didn't work.

So can anyone solve this problem?
If there are something unclearly due to my bad english, please question.
Thanks.","I have relized why my poblem happended. Acording to simulation result, i saw that my sigal is at high level state in first clock period cause unexpected result.",,,,,
Bits do not get shifted when performing shift operation in Verilog,"I am trying to build an SPI module in verilog which transmits 8 bits of data, but when doing the shift operation I have noticed that shifting does not shift bits at all, while MOSI and MISO only take value of zero after the first cycle, which results in data on both side decaying to zero. What can I do to fix this?

Code for master:

module Master(input clk, input MISO, 
              output reg MOSI, output reg SS);
  initial SS = 0;
  reg [2:0] counter;
  reg [7:0] Master_reg = 8'b11011011;
  always @ (posedge clk)
    begin
      if(!SS)
        begin
          if(^counter === 1'bx)
            counter = 0;
          else
            counter = counter + 1;
          MOSI = Master_reg[7];
          Master_reg = Master_reg &gt;&gt; 1;
          Master_reg[0] = MISO;
        end
      if(counter == 7)
          SS = 1; 
    end
endmodule


Code for slave:

module Slave(input clk, input MOSI, input SS,
            output reg MISO);
  reg [2:0] counter;
  reg [7:0] Slave_reg = 8'b11111111;
  always @ (posedge clk)
    begin
      if(!SS)
        begin
          if(^counter === 1'bx)
            counter = 0;
          else
            counter = counter + 1;
          MISO = Slave_reg[0];
          Slave_reg = Slave_reg &lt;&lt; 1;
          Slave_reg[7] = MOSI;
        end
    end
endmodule


Transmission of given data (11011011 from master, 11111111 from slave) gives following result:


Edit: I am using EDA Playground as a simulator","There's a mistake in both master and slave. You're sending out the most significant bit of master_reg, but shifting that register to the right. You must shift it left instead.

Same with slave, the bit that's being sent is not the one toward which the data is shifted.

Btw, both the master and slave must shift to the same direction. Otherwise you'll get data reversed between master and slave.",,,,,
Creating 1-bit ALU in vhdl,"The following problem is a homework.

I need to create an 1-bit slice ALU that can do the following between two 1 bit inputs:
and, or, addition using full adder, subtraction by using addition and inverting the inputs, xor. I need a 4 to 1 multiplexer to choose between the those functions of the alu.

This picture summarizes what I need to create 

I am asked to do this with with hierarchical design(structural). So, I need to create components. This is the part one of the whole project. In the second part I need to use this 1 bit ALU to create a 16 bit ALU. But my question for now is focused on the first part.

I have created an and gate, or gate, ADD for full adder, two not gates to invert inputs and mux 4 to 1.

library IEEE;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Entity or &amp; and 

ENTITY orGate IS
    PORT( a, b: in std_logic;
        s: out std_logic);
END orGate;

ARCHITECTURE structure OF orGate IS
BEGIN
    s &lt;= a OR b;
END structure;

ENTITY andGate IS
    PORT( a, b: in std_logic;
        s: out std_logic);
END andGate;

ARCHITECTURE structure OF andGate IS
BEGIN
    s &lt;= a AND b;
END structure;

--Entity add 

ENTITY ADD IS
PORT(   cin, a, b : in std_logic;
        s, cout     : out std_logic)
END ADD;

ARCHITECTURE structure OF ADD IS
BEGIN
    s &lt;= (a AND (NOT b) AND (NOT cin)) OR ((NOT a) AND b AND (NOT 
cin)) OR ((NOT a) AND (NOT b) AND cin) OR (a AND b AND cin);
    cout &lt;=( a AND b) OR (cin AND a) OR (cin AND b);
END ADD

-- Inverter, Sub, nor

ENTITY notB IS
    PORT( b: in std_logic;
        s: out std_logic);
END notB;

ARCHITECTURE structure OF notB IS
BEGIN
    s &lt;= NOT b;
END structure;

ENTITY notA IS
    PORT( a: in std_logic;
        s: out std_logic);
END notA;

ARCHITECTURE structure OF notA IS
BEGIN
    s &lt;= NOT a;
END structure;

ENTITY xorGate IS
    PORT( a, b: in std_logic;
        s: out std_logic);
END xorGate;

ARCHITECTURE structure OF xorGate IS
BEGIN
    s &lt;= a XOR b;
END structure;

-- MUX 4 TO 1

ENTITY mux4 IS
PORT(
    andGate      : in  std_logic_vector(2 downto 0);
    orGate      : in  std_logic_vector(2 downto 0);
    sum      : in  std_logic_vector(2 downto 0);
    xorGate      : in  std_logic_vector(2 downto 0);
    operation     : in  std_logic_vector(1 downto 0);
    rslt       : out std_logic_vector(2 downto 0));
END mux4;

ARCHITECTURE rtl OF mux4 IS
BEGIN
WITH operation SELECT
        rslt &lt;= andGate WHEN ""00"",
        orGate WHEN ""01"",
        sum WHEN ""10"",
        xorGate WHEN OTHERS;
end rtl;


So my question is: How can I use components and then put all these together to create a functioning 1 bit alu? Also, I am not sure about A inverter and B inverter because in the picture there are 2 mux of 2 to 1.","Use the structure COMPONENT to add the entities you just described between the ARCHITECTURE and BEGIN keywords of your final entity.

Once you've done that, you will have to bind the components between them using signals. You have as much signals as wires in your provided graph.

Here an example :
https://www.doulos.com/knowhow/vhdl_designers_guide/components_and_port_maps/",,,,,
How to initialize a wire[4:0] array in Verilog?,"I want to initialize a 5-bit wire with a constant. How to do that in Verilog?

wire [4:0] master_data_out = [1'b0, 1'b1, 1'b1, 1'b0, 1'b0];","Maybe you are looking for

wire [4:0] master_data_out = 5'b01100;


or

wire [4:0] master_data_out = {1'b0, 1'b1, 1'b1, 1'b0, 1'b0};


BTW a simple web search would have yield that very basic concept mostlikely very quickly.",,,,,
No warning concerning port and assignment in Questa 10.7b,"I have a simple code:

module test (
  input a, 
  output b
  );    

  assign a=0;
  assign b=0;

endmodule 


As you can see a is input, which assigned, thats wrong.. but no warning is shown; my script for compile.do:

set work work
vlib -type directory $work

vlog -work $work +acc    ../src/test.sv +incdir+../inc


and sim.do:

set work work
vlib -type directory $work
vlog -work $work +acc    ../src/test.sv +incdir+../inc


How can I see the warning?
In case I do assign a=b; (also error should be since b is output)
also no error, just a is h'x;","You must be coming from VHDL. &#128527; This is specifically allowed by Verilog when dealing with nets (which you have implicitly specified)


  Section 23.3.3.1 Port coercion of the IEEE 1800-2017 LRMA port that is declared as input (output) but used as an output (input) or inout may be coerced to inout.


SystemVerilog can enforce port direction when using variables instead of nets because only there can only be one continuous driver to a variable. However, there is nothing from preventing you from reading the value of a module output from within the module. ",,,,,
Reading a matrix from file,"I am trying to read a matrix from a file, it contains the colors of the pixels of a gray scale image. After this I will have to put the data I read into a register and perform some operations on it. When I am trying to simulate my code, the data is read alright in the ""data"" signal, but when I try to store an element, I read in the ""test"" signal to show it in the ""last_elem"" output it shows -2147483648. What am I doing wrong and why can't I access the data I read? 

entity Main is
Port(
rstb:in std_logic;
clk:in std_logic;
row:out integer;
col:out integer;
last_elem:out integer
);
end Main;

architecture Behavioral of Main is
type matrixData is array(0 to 240, 0 to 217) of integer;
signal data:matrixData;
signal test:integer;

begin
    process(clk)
    file read_file:text;
    VARIABLE file_line:LINE;
    VARIABLE row_counter:INTEGER:=0;
    variable rows:integer;
    variable cols:integer;
    variable read_value:integer;
    begin


    file_open(read_file, ""D:\Faculta\An 3 Sem 2\SCS\image.txt"", read_mode);
    readline(read_file,file_line);
    read(file_line, rows);
    read(file_line, cols);
    row&lt;=rows;
    col&lt;=cols;

    for i in 0 to rows-1 loop
        readline(read_file,file_line);
        for j in 0 to cols-1 loop
                read(file_line, read_value);
                data(i,j)&lt;=read_value;
        end loop;
    end loop;



    test&lt;=data(0,0);
    last_elem&lt;=test;

    file_close(read_file);
    end process;

end Behavioral;
","Providing a Minimal, Complete, and Verifiable example for your code:

library ieee;
use ieee.std_logic_1164.all;
use std.textio.all;

entity main is
    port (
        rstb:       in  std_logic;
        clk:        in  std_logic;
        row:        out integer;
        col:        out integer;
        last_elem:  out integer
    );
end entity main;

architecture behavioral of main is
    -- type matrixdata is array (0 to 240, 0 to 217) of integer;
    type matrixdata is array (0 to 3, 0 to 2) of integer;
    signal data:    matrixdata;
    signal test:    integer;

begin
    process (clk)
        file read_file:         text;
        variable file_line:     line;
        variable row_counter:   integer := 0;
        variable rows:          integer;
        variable cols:          integer;
        variable read_value:    integer;
    begin
        --file_open(read_file, ""d:\faculta\an 3 sem 2\scs\image.txt"", read_mode);
        file_open (read_file, ""image.txt"", read_mode);
        readline (read_file, file_line);
        read (file_line, rows);
        read (file_line, cols);
        row &lt;= rows;
        col &lt;= cols;

        for i in 0 to rows - 1 loop
            readline (read_file, file_line);
            for j in 0 to cols - 1 loop
                    read(file_line, read_value);
                    data(i,j) &lt;= read_value;
            end loop;
        end loop;

        test &lt;= data(0, 0);
        last_elem &lt;= test;

        file_close(read_file);
    end process;
end behavioral;

library ieee;
use ieee.std_logic_1164.all;

entity main_tb is
end entity;

architecture foo of main_tb is
    component main is
        port (
            rstb:       in  std_logic;
            clk:        in  std_logic;
            row:        out integer;
            col:        out integer;
            last_elem:  out integer
        );
    end component main;
    signal rstb:       std_logic := '1';
    signal clk:        std_logic := '0';
    signal row:        integer;
    signal col:        integer;
    signal last_elem:  integer;
begin
DUT:
    main
        port map (
            rstb =&gt; rstb,
            clk =&gt; clk,
            row =&gt; row,
            col =&gt; col,
            last_elem =&gt; last_elem
        );
WAVEFORM_DISPLAY_STIMULUS:
    process
    begin
        wait for 0 ns;
        wait for 1 ns;
        wait;
    end process;
end architecture;


Modified for a smaller two dimensional matrixdata type and supplied with a an input file:

images.txt  

4 3
0 0 0
1 1 1
2 2 2
3 3 3


We see:



Where the matrix values appear to be read in correctly. The last_elem signal has the default value (INTEGER'LOW, -2147483648) as does test,  both declarations lacking an initial value.

Neither Data nor test are in the process sensitivity list assignments will not occur in the same simulation cycle an assignment is scheduled. Every process executes at least once.

There's also an issue with the process sensitivity list. The process will execute for each event on clk, repetitively opening the file, reading in data and closing the file.

The proper fix for these two issues would be to remove the process sensitivity list and add a final wait statement (wait;) after the file_close. Also add a wait statement with zero incremental simulation time (e.g. wait for 0 ns;) prior to each signal assignment depending on a previous signal assignment value in the process. 

There's also the issue of error detection during TEXTIO operations (file_open, read_line). You've gone to all the trouble to close the file. How about checking for a successful file open and ENDFILE before executing procedure read_line?


    process
        file read_file:         text;
        variable file_line:     line;
        variable row_counter:   integer := 0;
        variable rows:          integer;
        variable cols:          integer;
        variable read_value:    integer;
        variable open_status:   FILE_OPEN_STATUS; -- ADDED
    begin
        --file_open(read_file, ""d:\faculta\an 3 sem 2\scs\image.txt"", read_mode);
        -- file_open (read_file, ""image.txt"", read_mode);
        file_open (open_status, read_file, ""image.txt"", read_mode);

        case open_status is  -- ADDED
             when OPEN_OK =&gt;
                report ""read_file opened for read"" severity NOTE;
            when STATUS_ERROR =&gt;
                report ""read_file already open"" severity FAILURE;
            when NAME_ERROR =&gt;
                report ""read_file file name not found"" severity FAILURE;
            when MODE_ERROR =&gt;
                report ""read_file can't be opened for read"" severity FAILURE;
        end case;

        if endfile(read_file) then  -- ADDED
            report ""can't read first line from read_file""
            severity FAILURE;
        end if;
        readline (read_file, file_line);
        read (file_line, rows);
        read (file_line, cols);
        row &lt;= rows;
        col &lt;= cols;

        for i in 0 to rows - 1 loop
            if endfile(read_file) then   -- ADDED
                report ""can't read line for all rows from read_file""
                severity FAILURE;
            end if;
            readline (read_file, file_line);
            for j in 0 to cols - 1 loop
                    read(file_line, read_value);
                    data(i,j) &lt;= read_value;
            end loop;
        end loop;
        wait for 0 ns;  --  ADDED causes a delta cycle, data is updated
        test &lt;= data(0, 0);
        wait for 0 ns;  -- ADDED causes a delta cycle, test is updated
        last_elem &lt;= test;
        file_close(read_file);
        wait;           -- ADDED
    end process;


This loads the array once at initialization and last_elem value will be updated after successive delta simulation cycles. 

A wait statement causes an executing process to suspend until a condition is met. A wait statement without a condition assumes a timeout clause of TIME'HIGH. 

A wait statement with a timeout clause (here 0 ns for the first two) will suspend the process until the condition is met. The incremental delay is equivalent to the current simulation time plus the time expression. 

Because there's a further event scheduled for the current simulation time, a delta simulation cycle will occur in which the process resumes. At the beginning of each simulation cycle projected output waveform values scheduled for the current simulation time cause signal updates where the effective value of the signal can be evaluated (as in an assignment statement). This will occur for both of the first two wait statements.

Hitting the final wait statement without a timeout clause assume a timeout clause of TIME'HIGH, the process won't resume again during simulation.

You can prove the open_status and endfile tests work by manipulating the host file system (path and permissions) and image.txt file contents. 

With an additional change to the testbench:

CLOCK:
    process
    begin
        wait for 5 ns;
        clk &lt;= not clk;
        if now &gt; 40 ns then
            wait;
        end if;
    end process;
-- WAVEFORM_DISPLAY_STIMULUS:
--     process
--     begin
--         wait for 0 ns;
--         wait for 1 ns;
--         wait;
--     end process;


You can demonstrate the code appears functional through simulation:



When simulating you'll only start the process at the first line once, only resume twice waiting on signal updates and only get one message from

                report ""read_file opened for read"" severity NOTE; 


when evaluating open_status.

As Tricky points out in a comment test is assigned the value of Data(0, 0) which is then assigned to last_element and actually contains the first element of the matrix.",,,,,
How to subtract input std_vector with local variable integer?,"I have this input vector that i have to subtract from my internal variable 

entity f11 is
    Port ( CLK : in  STD_LOGIC;
             ANIMATE : in  STD_LOGIC;
             MAKE : in STD_LOGIC;
             X_vga : in STD_logic_vector(6 downto 0);
             Y_vga : in STD_logic_vector(6 downto 0);
             X_pos : out STD_logic_vector(6 downto 0);
             Y_pos : out STD_logic_vector(6 downto 0);
          VALID : out STD_LOGIC
      );
end f11;

architecture basic of f11 is

TYPE data_out IS ARRAY(0 TO 5) OF std_logic; 
TYPE mem_data IS ARRAY(0 TO 6) OF data_out; 
SIGNAL ALIVE : STD_LOGIC := '0';
variable f11_data : mem_data := (
        ( '0', '0', '0', '0', '1', '0'),
          ( '0', '0', '0', '1', '0', '1'),
          ( '0', '1', '1', '0', '1', '0'),
          ( '1', '1', '1', '1', '0', '1'),
          ( '0', '1', '1', '0', '1', '0'),
          ( '0', '0', '0', '1', '0', '1'),
          ( '0', '0', '0', '0', '1', '0')
          );

variable pos_x : integer := 8;  
variable pos_y : integer := 8;  


variable xvga : integer ;  
variable yvga : integer ;  
process(CLK) 
 begin
    if(rising_edge(CLK)) then
        xvga:= to_integer(unsigned(X_vga));
        yvga:= to_integer(unsigned(Y_vga));
        if(MAKE = '1')then ALIVE &lt;= MAKE;end if;
        if( xvga &lt;= pos_x + 5 and  yvga &lt;= pos_y + 6 ) then 
        VALID &lt;= f11_data ( xvga - pos_x )(xvga - pos_y) and ALIVE ;
        end if;
    end if;


end process;


X_pos &lt;= pos_x;
 Y_pos &lt;= pos_y;

end basic;


It keeps giving me an error that 

Error (10482): VHDL error at f11.vhd(53): object ""to_integer"" is used but not declared


and I really don't know how to get around this problem or is there any other way for me to subtract these two values, is there some reference material that i can look into couse I'm really new to this stuff, THANKS !","You need to use numeric_std from the IEEE library to use to_integer.

Add this to the top of your file:

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
",,,,,
Why there is a dely between 2 memory block of the while accesing?,"I am building a Modulo reduction module for the Elleptic Curve Crypto System. I want to access the Ram such that 2 address is read in 2 clock pulses. but my code is giving a lag such that it is becoming 3.

    module memtest3(
    input memread,
    input memwrite,
    input [3:0] addr0,
    input [3:0] addr1,
    input clk,load0,load1,
    input [31:0] write_data1,
    input [31:0] write_data0,
    output reg [31:0] read_data1,
    output reg [31:0] read_data0);
    reg [3:0] addr [1:0];
    reg [31:0] memo [10:0]; 
    //----------------&lt;Memory module&gt;-----------------//
    integer i,j;
    initial begin
       for(i=0;i&lt;11;i=i+1)begin
        memo[i]&lt;=i;
       end
    end
    always @(posedge clk)begin
        if(memwrite==1'b1)begin
            memo[addr[0]]&lt;=write_data0;
            memo[addr[1]]&lt;=write_data1;
        end
        else if(memread==1'b1) begin
            read_data0&lt;=memo[addr[0]];
            read_data1&lt;=memo[addr[1]];
        end     
    end
  //----------------&lt;Memory Addressing&gt;----------------//
    always @(posedge clk)begin
    /*if(memread==1'b1)begin
            if(i&lt;&lt;5)begin
                addr[0]&lt;=i;
                addr[1]&lt;=i+1;
           i&lt;=i+2;
             end
        end*/
       if(memread==1'b1)begin
            if(i&lt;&lt;4)begin
               if(load0==1'b1)begin
                    addr[0]&lt;=i;
                    addr[1]&lt;=i+1;
               end
               else if(load1==1'b1)begin
                    addr[0]&lt;=i;
                    addr[1]&lt;=i+1;
               end
               i&lt;=i+2;
             end
         end
      end

      endmodule


if i change i to i+7 then it is taking a more time to read the data of addr[0]. Can you help me out. I'm out of clue.","When you have 2 latches like this:

always @(posedge clk)
    a &lt;= b;

always @(posedge clk)
    b &lt;= c;


the result of a after the posedge will be the old value of b.
So, if b was 1 and c was 2, at the posedge 

a --&gt; 1 (old b)
b --&gt; 2 (old c)


if you need to guarantee that a gets new value of b, you have a couple of choices:

1) calculate b using a combinational process:

  always @(*)
     b = c;


2) assign b at negedge of clk

  always @(negedge clk)
      b &lt;= c;


3) you can make sure that your b has the value which you need at the particular clockedge by evaluating it in the current phase, something like the following. 

always @(posedge clk) begin
     a &lt;= b;
     next_b &lt;= c;
end

always @*
   b = next_b;


there are other ways which could but limitation on the variables. For example, if b is just a temporary variable used inside the flop logic, you can use blocking assignments to evaluate it. But do not use it anywhere else:

 always @(posedge clk) begin
    b = c;  // b only used inside this block and uses BA
    a &lt;= b;
 end


You have to think  which method better suits you better. Probably incrementing i at the negedge can work. You have to understand how the 'memread' is evaluated too. ",,,,,
How to simplify code using a temporal int variable,"I want CODE 1 and CODE 2 to do the same
module testModule #(    parameter LEN = 4,
                        parameter logic [0:0] OPTION = 1'b0 )
(
    input                         Clk,
    input         [ 7:0][LEN-1:0] DataIn,
    input         [ 7:0][LEN-1:0] Factor,
    output        [15:0][LEN-1:0] DataOut_1,
    output        [15:0][LEN-1:0] DataOut_2
);

    // CODE 1
    always_ff @(posedge Clk) begin
        for (int i = 0; i &lt; LEN; i++) begin
            if (OPTION == 1'b0) begin
                DataOut_1[i] &lt;= DataIn[i] * Factor[0];
            end else begin
                DataOut_1[i] &lt;= DataIn[i] * Factor[i];
            end
        end
    end

    // CODE 2
    always_ff @(posedge Clk) begin
        for (int i = 0; i &lt; LEN; i++) begin
            int select = (OPTION == 1'b0) ? 0 : i;
            DataOut_2[i] &lt;= DataIn[i] * Factor[select];
        end
    end

endmodule

OPTION can be either 0 of 1.
But I get the following errors in CODE 2 in line
int select = (OPTION == 1'b0) ? 0 : i;
Local static variable with initializer requires 'static' keyword
automatic variable illegal in static variable initializer
I don't want to simplify the for loop because the in my original code I need it
This question is a variant on this other but I didn't want to change the original code question","You have a couple of issues there:

you cannot assign to a net inside an always block. bpoth, DataOut_1/2 are declared as nets. So, you should declare them as regs at minimum:

    output        reg [15:0][LEN-1:0] DataOut_1,
    output        reg [15:0][LEN-1:0] DataOut_2


All variables defined in the module are static by nature. Except in some cases. The i defined in the 'for' loop is automatic. Therefore you cannot use it as an initializer  to a static variable. You need to declare 'select' as automatic:

automatic int select = (OPTION == 1'b0) ? 0 : i;
",,,,,
Superlint on Verilog LAT_NR_BLAS/MXCB error,"Superlint on Verilog LAT_NR_BLAS/MXCB error
Superlint_Image
I check my Verilog code style with Superlint.
Although I got an expected correct simulation result, it pop up with 2 problem in Superlint. I've read superlint_reference.pdf
and have no idea how to fix it correctly.
1.Problem_1_LAT_NR_MXCB
According to superlint_reference.pdf, does it mean I have to assign ALL reg in
all branches. It doesn't seem to be the solution.
2.Problem_2_LAT_NR_BLAS -The design has one or more latches that are coded using a blocking
assignment.
I replace all =in always block with &lt;= , i.e. blocking to non-blocking and it does't work tho.
timescale 1ns/10ps

// ---------------------- define ---------------------- //

`define DataSize  32
`define ALUopSize  5
//define ALUop
`define ADDop     5'b00000
`define SUBop     5'b00001
`define ANDop     5'b00010
`define ORop      5'b00011
`define XORop     5'b00100
`define NORop     5'b00101
`define SRLop     5'b00110
`define ROTRop    5'b00111
`define NOTop     5'b01000
`define NANDop    5'b01001
`define MAXop     5'b01010
`define MINop     5'b01011
`define ABSop     5'b01100
`define SLTSop    5'b01101
`define SLLop     5'b01110
`define ROTLop    5'b01111
`define ADDUop    5'b10000
`define SRLUop    5'b10001

module ALU (alu_enable, alu_op, src1, src2, alu_out, alu_overflow);

// ---------------------- input  ---------------------- //
input                     alu_enable;
input   [`ALUopSize-1:0]  alu_op;
input   [`DataSize-1:0]   src1;
input   [`DataSize-1:0]   src2;

// ---------------------- output ---------------------- //
output   [`DataSize-1:0]  alu_out;
output                    alu_overflow;

// ----------------------  reg   ---------------------- //
reg    [`DataSize-1:0]    alu_out;
reg                       alu_overflow;
reg    [63:0]             temp;
reg    [63:0]             temp2;
reg                       carry;

always@(*)begin
  alu_overflow = 1'b0;
  if(alu_enable)begin
/************************************/
    case(alu_op)
        `ADDop  :  begin
            alu_out = src1 + src2;
            if((src1[31]==1'b0 &amp;&amp; src2[31]==1'b0 &amp;&amp; alu_out[31]==1'b1)||
                 (src1[31]==1'b1 &amp;&amp; src2[31]==1'b1 &amp;&amp; alu_out[31]==1'b0))
                alu_overflow = 1'b1;
            else
                alu_overflow = 1'b0;
            end
        `SUBop  :  begin
            alu_out = src1 - src2;
            if((src1[31]==1'b0 &amp;&amp; src2[31]==1'b1 &amp;&amp; alu_out[31]==1'b1)||
                 (src1[31]==1'b1 &amp;&amp; src2[31]==1'b0 &amp;&amp; alu_out[31]==1'b0))
                alu_overflow = 1'b1;
            else
                alu_overflow = 1'b0;
            end
        `ANDop  :  alu_out = src1 &amp; src2;
        `ORop   :  alu_out = src1 | src2;
        `XORop  :  alu_out = src1 ^ src2;
        `NORop  :  alu_out = ~(src1 | src2);
        `SRLop  :  alu_out = $signed(src1) &gt;&gt;&gt; $signed(src2);
        `ROTRop :  begin
            temp = {src1,src1};
            temp = temp &gt;&gt; (src2%32);
            alu_out = temp[31:0];
            end
        `NOTop  : alu_out = ~src1;
        `NANDop : alu_out = ~(src1&amp;src2);
        `MAXop  : begin
            if($signed(src1) &gt; $signed(src2))
                alu_out = src1;
            else
                alu_out = src2;
            end 
        `MINop  : begin
            if($signed(src1) &lt; $signed(src2))
                alu_out = src1;
            else
                alu_out = src2;
            end 
        `ABSop  : begin
            if(src1[31] == 1'b1)
                    alu_out = (~src1) + 32'h01;
                else
                alu_out = src1;
            end
        `SLTSop  : begin
            if($signed(src1) &lt; $signed(src2))
                alu_out = 32'h01;
            else
                alu_out = 32'h00;
            end
        `SLLop  :  alu_out = $signed(src1) &lt;&lt;&lt; $signed(src2);
        `ROTLop :  begin
            temp2 = {src1,src1};
            temp2 = temp2 &lt;&lt; (src2%32);
            alu_out = temp2[63:32];
            end
        `ADDUop : begin
            {carry,alu_out} = src1 + src2;
            if(carry)
                alu_overflow = 1'b1;
            else
                alu_overflow = 1'b0;
            end
        `SRLUop : alu_out = src1 &gt;&gt; src2;
    default : alu_out = 32'b0;
      endcase
/************************************/
    end
  else
    alu_out = 32'b0;
  end
endmodule
","Your case statement represents a latch because you do not assigh all its output in every branch of the statements. You have at least two other signals, carry and alu_out which make the latch. Is it a latch behavior that you need?
If you need a latch then

If you code a state device such as 'latch' you should use non blocking assignments &lt;= for the outputs of the block.

So, you have to replace blocking assignment to non-blocking everywhere except when you assign to 'temp' and 'temp2'.


If you need a combinational logic than I suggest that you initialize everything upfront with default values.
always @* begin
   alu_overflow = 1'b0;
   alu_out = 0;
   cary = 0;
   if (alu_enable)
      ...
",,,,,
how to restrict certain data in $random in verilog?,"I want to randomize a variable in verilog. So I am using $random for that.But $random may generate 0 which I don't want 0 avlue for my the variable.
how to restrict the value?","You can use $dist_uniform ( seed , start , end ) in Verilog, or its replacement  $urandom_range(max [,min]) in SystemVerilog.",,,,,
8bit ALU line 46: Can not simplify operator DIV,"Hello guys I just wanted to ask how to debug this one in line 46 in says &quot;Can not simplify operator DIV.&quot; in Verilog Module (Xilinx). Thank you in advance for the tip and help :))


Here's the code of my 8bit ALU
module alu_8fctn (a, b, opcode, rslt, rslt_mul);
input [3:0] a, b;
input [2:0] opcode;
output [3:0] rslt;
output [7:0] rslt_mul;
wire [3:0] a, b; //inputs are wire
wire [2:0] opcode;
reg [3:0] rslt; //outputs are reg
reg [7:0] rslt_mul;
//define operation codes
parameter add_op = 3'b000,
            sub_op = 3'b001,
            mul_op = 3'b010,
            div_op = 3'b011,
            and_op = 3'b100,
            or_op = 3'b101,
            xor_op = 3'b110,
            xnor_op = 3'b111;
//perform the operations
always @(a or b or opcode)
begin
case (opcode)
            add_op : rslt = a + b;
            sub_op : rslt = a - b;
            mul_op : rslt_mul = a * b;
            div_op : rslt = a / b;
            and_op : rslt = a &amp; b;
            or_op : rslt = a | b;
            xor_op : rslt = a ^ b;
            xnor_op: rslt = a ^~ b;
            default: rslt = 8'b0000_0000;
endcase
end
endmodule
","Your Xilinx appears to have trouble with a / b. Synthesizers can have a hard time optimizing with variable divisors; especially if they can be zero.
Xilinx should have some predefined modules for division (if not you can always make your own)
wire [3:0] rslt_div;
&lt;XilinxPrividedDividerModuleName&gt; div ( rslt_div, a, b);
always @*
  ...
  div_op : rslt = a / b;
  ...


Other issue:
rslt and rslt_mul are inferred latches because they are not assign in all conditions. In mul_op  and rslt_mul is only assigned in mul_op and that is the only condition rslt is not assigned.
Refer to What is inferred latch and how it is created when it is missing else statement in if condition. Can anybody explain briefly?
Simple solution is give the rslt and rslt_mul an initial/default value before the case statement.
always @*
begin
  rslt = 4'h0;
  rslt_mul = 8'h00;
  case (opcode)
    // ... you other code
  endcase
end


Also note that always @(a or b or opcode) is the Verilog-1995 way of writing a sensitivity list. Since Verilog-2001 the preferred way is always @* (or the synonymous always @(*)). SystemVerilog goes a step further with always_comb where a good tool should flag an error if a latch is inferred.
You may also want to consider ANSI style module headers (also available since Verilog-2001) which is less verbose and less prone to typos then the Verilog-1995 module header style.
module alu_8fctn (
  input [3:0] a, b,
  input [2:0] opcode,
  output reg [3:0] rslt,
  output reg [7:0] rslt_mul );

  //define operation codes
  parameter add_op = 3'b000,
  ...
",,,,,
How to make 4 bit ring counter with 4 flip flops?,"I have this 4 bit ring counter that I'm trying to make, and I feel like I'm so close, but I can't figure out how to make one input depend on the previous state's output. Here's what I have:
`default_nettype none
// Empty top module

module top (
  // I/O ports
  input  logic hz100, reset,
  input  logic [20:0] pb,
  output logic [7:0] left, right
);

  // Your code goes here...
  q[3:0];
  
  assign q[3:0] = right[3:0];
  
  hc74_set setFF(.c(pb[0]), .d(pb[1]), .q(right[0]), .sn(pb[16]));
  hc74_reset resetFF1(.c(pb[0]), .d(pb[1]), .q0(right[1]), .rn(pb[16]));
  hc74_reset resetFF2(.c(pb[0]), .d(pb[1]), .q1(right[2]), .rn(pb[16]));
  hc74_reset resetFF3(.c(pb[0]), .d(pb[1]), .q2(right[3]), .rn(pb[16]));
  
  
endmodule

// Add more modules down here...
// This is a single D flip-flop with an active-low asynchronous set (preset).
// It has no asynchronous reset because the simulator does not allow it.
// Other than the lack of a reset, it is half of a 74HC74 chip.
module hc74_set(input logic d, c, sn,
                  output logic q, qn);
  assign qn = ~q;
  always_ff @(posedge c, negedge sn)
    if (sn == 1'b0)
      q &lt;= 1'b1;
    else
      q &lt;= d;
endmodule

// This is a single D flip-flop with an active-low asynchronous reset (clear).
// It has no asynchronous set because the simulator does not allow it.
// Other than the lack of a set, it is half of a 74HC74 chip.

module hc74_reset(input logic d, c, rn,
                  output logic q, qn);
  assign qn = ~q;
  always_ff @(posedge c, negedge rn)
    if (rn == 1'b0)
      q &lt;= 1'b0;
    else
      q &lt;= d;
endmodule

This is on an FPGA simulator, which is why there are a few things like pb (these are push buttons) and left, right outputs which are sets of 8 LEDs each.","Let's first make sure we are on the same page
Based on wikipedia description of a ring counter
This could be implemented as follows:
module top (
  // I/O ports
  input  logic reset_n,
  input  logic clk,
  output logic [3:0] ring
);

  // Your code goes here...
  always @(posedge clk or negedge reset_n) begin
    if(~reset_n) begin
      ring = 4'b0001;
    end
    else begin
      ring[0] &lt;= ring[3];
      ring[1] &lt;= ring[0];
      ring[2] &lt;= ring[1];
      ring[3] &lt;= ring[2];
    end
  end
endmodule


The output ring is a 4-bit one hot vector, reset_n = 0 makes ring = 0001 every clock with reset_n = 1 rolls the ring to the right, [0001, 0010, 0100, 1000, 0001, ...].
But you want to use instances of the flops you defined. Notice that in an assignment a &lt;= b, a is the output of the flop (q port), and b is the input of the flop (d port).
module top (
  // I/O ports
  input  logic reset_n,
  input  logic clk,
  output logic [3:0] ring
);

  // Your code goes here...
  
  hc74_set setFF(.c(clk), .d(ring[3]), .q(ring[0]), .sn(reset_n));
  hc74_reset resetFF1(.c(clk), .d(ring[0]), .q0(ring[1]), .rn(reset_n));
  hc74_reset resetFF2(.c(clk), .d(ring[1]), .q1(ring[2]), .rn(reset_n));
  hc74_reset resetFF3(.c(clk), .d(ring[2]), .q2(ring[3]), .rn(reset_n));  
endmodule


You have to connect the ports accordingly, I just used clk for the clock and reset_n for the negated reset signal.",,,,,
sva event scheduling with $display/uvm_error,"So I recall when an assertion triggers the data signals in the assertion are from just prior to the clock edge.
I'd like to put a helpful error message in my assertion to let the user know what went wrong, but by the time $display() happens the data has already changed.
As an example the below assertion will fail whenever data=0 when a ready/valid handshake occurs.  However the $display that is printed will show data=1 if there is coincidentally a rising edge of data when the assertion fired.
  default clocking CLK @(posedge clk);
  endclocking
  //Assertion triggers an error if data is not = 1 when new data is clocked into the DUT.
  POS_DATA: assert property ((ready &amp; valid) |-&gt; data) else $display(&quot;[%t] POS_DATA fail data:%d&quot;,$time,data);

Is there a better way to code this assertion?
Created an EDAPlayground Example and looks like all the simulators do the same thing, so seems like it's my fault.","All you need to do is add $sampled(data)
POS_DATA: assert property ((ready &amp; valid) |-&gt; data) else $error(&quot; POS_DATA fail data:%d&quot;,$sampled(data));

And you should be using $error instead of $display. You'll thank me later when you start running regressions and getting coverage reports.",,,,,
Approach to get the weight values from the pre-trained weights from Darknet?,"I'm currently trying to implement YOLOv3 object detection model in C(only detection, not training).
I have tested my convolution method with arbitrary values and it seems to be working as I expected.
Before stacking up multiple method calls to do forward propagation, I thought it would be safe to test with the actual pretrained weight file data.
When I look up Darknet's pre-trained weight file, it was a huge chunk of binary files. I tried to convert it to hex and decimals, but it still doesn't look simple to pinpoint what part of values to use.
So, my question is, what should I do to extract the decimal numbers of the weights or the filter values so that I can use them in the same order of the forward propagation happening in YOLOv3?
*I'm currently trying to build my c version of YOLOv3 using the structure image shown in https://www.itread01.com/content/1541167345.html
*My c code will be run on an FPGA board called MicroZed, along with other HDL code.
*I tried to plug some printf functions into some places of Darknet code to see what kinds of data are moving around when YOLOv3 runs, however, when I ran it on in Linux terminal, it didn't show anything new and kept outputting the same results.
Any help or advice will be really appreciated. Thank you!","I am not too sure if there is a direct way to read darknet weights, but you can convert it into .h5 format and obtain the weight values from it
You can convert the darknet yolov3 weights into .h5 format (used by keras) by using the appropriate command from this repository.
You can choose the command based on your Yolo version from the list shown in the ReadMe of the linked repo. For the standard yolov3, the command for converting is
python tools/model_converter/convert.py cfg/yolov3.cfg weights/yolov3.weights weights/yolov3.h5 
Once you have the .h5weights, you can use the below code snippet for obtaining the
values from the weights. credit/source
import h5py

path = &quot;&lt;path to weights&gt;.h5&quot;
weights = {}
keys = []
with h5py.File(path, 'r') as f: # open file
  f.visit(keys.append) # append all keys to list
  for key in keys:
      if ':' in key: # contains data if ':' in key
          param_name = f[key].name
          weights[f[key].name] = f[key].value
          print(param_name,weights[f[key].name])
",,,,,
CRC-16 and/or Frame Check Sequence,"I have an incoming packet that reads 7E0302403F387E from a serial port.
start and end flag is 7E, FCS/CRC is 3F38 and the data is 030240. The FCS is calculated per the algorithm specified in RFC 1662. https://www.rfc-editor.org/rfc/rfc1662#appendix-A
This is the code I'm using to generate the FCS for 030240:
static byte[] HexToBytes(string input)
    {
        byte[] result = new byte[input.Length / 2];
        for (int i = 0; i &lt; result.Length; i++)
        {
            result[i] = Convert.ToByte(input.Substring(2 * i, 2), 16);
        }
        return result;
    }


    public static class Crc16
    {
        const ushort polynomial = 0x8408;
        static readonly ushort[] table = new ushort[256];

        public static ushort ComputeChecksum(byte[] bytes)
        {
            ushort crc = 0;
            for (int i = 0; i &lt; bytes.Length; ++i)
            {
                byte index = (byte)(crc ^ bytes[i]);
                crc = (ushort)((crc &gt;&gt; 8) ^ table[index]);
            }
            return crc;
        }

        static Crc16()
        {
            ushort value;
            ushort temp;
            for (ushort i = 0; i &lt; table.Length; ++i)
            {
                value = 0;
                temp = i;
                for (byte j = 0; j &lt; 8; ++j)
                {
                    if (((value ^ temp) &amp; 0x0001) != 0)
                    {
                        value = (ushort)((value &gt;&gt; 1) ^ polynomial);
                    }
                    else
                    {
                        value &gt;&gt;= 1;
                    }
                    temp &gt;&gt;= 1;
                }
                table[i] = value;
            }
        }
    }

This is how I call it:
//string input = &quot;00 03 00 02 04 00&quot;;
string input = &quot;030240&quot;;
var bytes = HexToBytes(input);
string hexe = Crc16.ComputeChecksum(bytes).ToString(&quot;x2&quot;);

I should get an FCS of 3F38 but instead I'm getting 9ED0. What am I doing wrong?
Edit 1:
I'm reading ~\0\u0003\0\u0002\u0004\0?8~ from the serial port. I am able to convert that into either 7E-03-02-40-3F-38-7E or 7e-5c-30-5c-75-30-30-30-33-5c-30-5c-75-30-30-30-32-5c-75-30-30-30-34-5c-30-3f-38-7e. The first is too short and the second is too long. I should be getting 10 bytes. Any tips?
Edit 2:
I am using ASCII_To_Hex to convert ~\0\u0003\0\u0002\u0004\0?8~ to 7E-03-02-40-3F-38-7E
public string ASCII_To_Hex(string ASCII)
    {
        char[] charValues = dataIN.ToCharArray();
        string hexOutput = &quot;&quot;;
        foreach (char _eachChar in charValues)
        {
            // Get the integral value of the character.
            int value = Convert.ToInt32(_eachChar);
            // Convert the decimal value to a hexadecimal value in string form.
            hexOutput += String.Format(&quot;{0:X}&quot;, value);
            // to make output as your eg 
            //  hexOutput +=&quot; &quot;+ String.Format(&quot;{0:X}&quot;, value);

        }
        return hexOutput;
    }

What changes can I make here to correctly decipher the incoming packet?
Edit 3:
I made the following changes based on Mark's suggestion:
public static class Crc16
    {
        const ushort polynomial = 0x1021;

        static readonly ushort[] table = new ushort[256];

        public static ushort ComputeChecksum(byte[] bytes)
        {
            ushort crc = 0xffff;
            for (int i = 0; i &lt; bytes.Length; ++i)
            {
                byte index = (byte)(crc ^ bytes[i]);
                crc = (ushort)((crc &gt;&gt; 8) ^ table[index]);
            }
            return (ushort)~crc;
        }

        static Crc16()
        {
            ushort value;
            ushort temp;
            for (ushort i = 0; i &lt; table.Length; ++i)
            {
                value = 0;
                temp = i;
                for (byte j = 0; j &lt; 8; ++j)
                {
                    if (((value ^ temp) &amp; 0x0001) != 0)
                    {
                        value = (ushort)((value &gt;&gt; 1) ^ polynomial);
                    }
                    else
                    {
                        value &gt;&gt;= 1;
                    }
                    temp &gt;&gt;= 1;
                }
                table[i] = value;
            }
        }
    }

This is how I'm calling it:
string hex = &quot;00-03-00-02-04-00&quot;;
        hex = hex.Replace(&quot;-&quot;, &quot;&quot;);
        var bytes = HexToBytes(hex);
        string hexe = Crc16.ComputeChecksum(bytes).ToString(&quot;X2&quot;);

I'm getting FO93 instead of 389B","Based on the linked appendix, the initial value of the CRC is 0xffff, not 0, and you need to exclusive-or the result with 0xffff to get the FCS to put in the packet.
However that still doesn't work for your example packet. I can only guess that your example packet was not correctly extracted or identified.
Update:
From the OP comment below and some deduction, the actual data in the message is &quot;~\x00\x03\x00\x02\x04\x00\x9b\x38~&quot;. The OP left out three zero bytes for some reason, and the OP printed it in a way that obscured one byte as a question mark.
Now the CRC calculates correctly as 0x389b, stored in the message little-endian as 0x9b 0x38. To get that, you must apply my comments above on the initial value and final exclusive-or.",,,,,
Difference between { } and '{ },"What's the difference between these two operator? (In System Verilog).
I know that { } is the bit squeezing operator but i wonder if there is difference with '{ }","yes, there is a difference.
The first one {} means concatenation. It results in a vector that consists of bits of its operands. It is used in generic verilog operations.
The second one '{} is a definition of a anonymous aggregate structure such as an array or struct. It is used in aggregate/pattern assignments. It also has a set of features to do pattern expression to assign to specified members of structs and arrays.
In case of packed arrays and structs and without pattern expressions both operators behave similarly.",,,,,
Verilog - Changing a reg in sensitivity list in Always block,"reg A,B,C;
always @(*)begin
//some other computations
C=B;
//some other computations
A=C;
end

always @(posedge clk)begin
B&lt;=A;
end

Hi there,
In the code above, at the posedge of clk reg A changes the value of reg B and that starts the process of first always block since B is in the sensitivity list. My question is what will be happening at the line &quot;C=B&quot; since reg C is also in the sensitivity list? Will that start the process of the first loop again and causes an infinite loop?
I check that on simulation and it works fine. But I don't know want would happen on hardware.
My guess is it will not cause a problem. Since Verilog only creates a LUT to mimic the algorithm inside of the always block, that will not cause a problem on hardware. However, I am not sure so I would like to ask.
Thank you,","Remember that procedural code executes one statement at a time. Your code is effectively interpreted the same as
initial begin
       @(B or C) // wait for a change on B or C
       C = B;
       A = C;
       @(B or C) // wait for a change on B or C
       C = B;
       A = C;
       @(B or C) // wait for a change on B or C
       C = B;
       A = C;
       ...
       end

The assignment to C happens, but any change to C has already happened before you get to the next @. Synthesis interprets C as an intermediate value.",,,,,
Input a reference to another module in a module instantiation? (SystemVerilog),"I have dedicated testbench module for printing/tracing information about the DUT in my testbench. I would like to avoid having to wire all the interesting (internal) signals down into the tb module.
As an example let's say I have an internal signal a in my DUT. How can I access it in printer.sv without having to create a matching input? Sketch:
/---- TB.sv -----------------------------------------\
|                                                    |
|   /--dut.sv--\       /--printer.sv-------------\   |
|   | wire a;  |   -&gt;  | always @(posedge clk)   |   |
|   |          |       | $display(&quot;a is %d&quot;, a); |   |
|   \----------/       \-------------------------/   |
|                                                    |
\----------------------------------------------------/

I have been looking at the bind keyword to see if it could help me, but I don't understand it.
The number of signals needed by the printer.vs is large, so I would really like to avoid having to declare everything as inputs, it's very tedious.
Is there some way to pass in a hierarchical reference to the instantiated dut module?","You can use an upwards reference in the bound printer module.
module DUT(input clk);     
     wire a;
     function void hello;
       $display(&quot;Hello from %m&quot;);
     endfunction
      
endmodule
    
module printer(input clk);
      always @(posedge clk)
        $display(&quot;a is %d&quot;, DUT.a);
      initial DUT.hello;
endmodule
    
module TB;
      reg clock;
      DUT d1(clock);
      DUT d2(clock);
      
      bind DUT printer p(clk);
      
endmodule

Not that upwards name referencing is a feature of Verilog independent of bind. The bind feature works exactly as if you had written the instance inside the DUT. It the same reason you can use the top-level module name as the beginning of a reference.
module DUT(input clk);     
     wire a;
     function void hello;
       $display(&quot;Hello from %m&quot;);
     endfunction

      printer p(clk);  // what bind is actually doing

      
endmodule
    
module printer(input clk);
      always @(posedge clk)
        $display(&quot;a is %d&quot;, DUT.a);
      initial DUT.hello;
endmodule
    
module TB;
      reg clock;
      DUT d1(clock);
      DUT d2(clock);      
endmodule
",,,,,
2 bit signed Multiplier,"
Design a 2-bit signed multiplier using one instantiation of your 4-bit adder. Remember that you need to sign extend your two 2-bit inputs to a full 4-bits.

This was my assignment and I came up with following code but some of my outputs are wrong. Can anyone tell me what I am doing wrong?
module mult(C,A,B);
    output signed[3:0]C;
    input signed[1:0]A,B;
    reg signed[3:0]sA,sB;

    assign sA = {A[1],A[1],A};
    assign sB = {B[1],B[1],B};
    
    wire carry;
    wire signed[3:0] A1;
    wire signed[3:0] A2;
    wire signed[3:0] sum0;
    
    and(A1[0],sA[0],sB[0]);
    and(A1[1],sA[1],sB[0]);
    and(A1[2],sA[2],sB[0]);
    and(A1[3],sA[3],sB[0]);
    
    
    assign A2[0] = 0;
    and(A2[1],sA[0],sB[1]);
    and(A2[2],sA[1],sB[1]);
    and(A2[3],sA[2],sB[1]);
    
 
    adder4bit a1(.A(A1),.B(A2),.Co(carry),.sum(sum0));
    assign C[0] = sum0[0];
    assign C[1] = sum0[1];
    assign C[2] = sum0[2];
    assign C[3] = sum0[3];
endmodule

module adder4bit(A,B,sum,Co);
    input signed[3:0]A,B;
    output signed [4:0]sum;
    reg signed[4:0]a,b;
    output Co;
    
    wire Ci;
    assign Ci = 1'b0;
    assign a = {A[3],A};
    assign b = {B[3],B};
    
    FA a0(.A(a[0]),.B(b[0]),.Ci(Ci),.sum(sum[0]),.Co(w1));
    FA a1(.A(a[1]),.B(b[1]),.Ci(w1),.sum(sum[1]),.Co(w2));
    FA a2(.A(a[2]),.B(b[2]),.Ci(w2),.sum(sum[2]),.Co(w3));
    FA a3(.A(a[3]),.B(b[3]),.Ci(w3),.sum(sum[3]),.Co(w4));
    FA a4(.A(a[4]),.B(b[4]),.Ci(w4),.sum(sum[4]),.Co(Co));
endmodule

module FA(A,B,Ci,Co,sum);
    
    input A,B,Ci;
    output sum,Co;
    
    assign sum = (A^B)^Ci;
    assign Co = (B&amp;Ci) | (A&amp;Ci) | (A&amp;B);
    
endmodule
","There were some signals declared as reg connected to port outputs, reg must be assigned in procedural blocks.
I also made the carry bits in the adder an explicit wire vector, instead of multiple implicit wires. Implicit wires are dangerous a typo leads to a disconnection.
Also I declared the sum0 in the multiplier to have the same width as the output in of the sum port where it is connected, even though the bit 4 will not be used.
In terms of logic you made only one mistake, the A * B = A * B[0] - 2*A * B[1] instead of A * B[0] + 2*B[1] if B is a 2-bit signed integer. Because B[1] is the sign bit, thus B = B[0] - 2*B[1]. I fixed this by using the unary - directly in the port connection, I will leave it to you to write this structurally.
module mult(C,A,B);
  output signed[3:0]C;
  input signed[1:0]A,B;
  wire signed[3:0]sA,sB;

  assign sA = {A[1],A[1],A};
  assign sB = {B[1],B[1],B};

  wire carry;
  wire signed[3:0] A1;
  wire signed[3:0] A2;
  wire signed[4:0] sum0;

  and(A1[0],sA[0],sB[0]);
  and(A1[1],sA[1],sB[0]);
  and(A1[2],sA[2],sB[0]);
  and(A1[3],sA[3],sB[0]);


  assign A2[0] = 0;
  and(A2[1],sA[0],sB[1]);
  and(A2[2],sA[1],sB[1]);
  and(A2[3],sA[2],sB[1]);

  // FIXME: Notice that I am passing -A2, the simulator will
  // negate the signal automatically. Maybe for your assignment
  // you are requried to expand this using logic primitives...
  adder4bit a1(.A(A1),.B(-A2),.Co(carry),.sum(sum0));
  assign C[0] = sum0[0];
  assign C[1] = sum0[1];
  assign C[2] = sum0[2];
  assign C[3] = sum0[3];
endmodule

module adder4bit(A,B,sum,Co);
  input signed[3:0]A,B;
  output signed [4:0]sum;
  wire signed[4:0]a,b;
  output Co;
  wire [4:1] w;  
  wire Ci;
  assign Ci = 1'b0;
  assign a = {A[3],A};
  assign b = {B[3],B};
  
  
  FA a0(.A(a[0]),.B(b[0]),.Ci(Ci),.sum(sum[0]),.Co(w[1]));
  FA a1(.A(a[1]),.B(b[1]),.Ci(w[1]),.sum(sum[1]),.Co(w[2]));
  FA a2(.A(a[2]),.B(b[2]),.Ci(w[2]),.sum(sum[2]),.Co(w[3]));
  FA a3(.A(a[3]),.B(b[3]),.Ci(w[3]),.sum(sum[3]),.Co(w[4]));
  FA a4(.A(a[4]),.B(b[4]),.Ci(w[4]),.sum(sum[4]),.Co(Co));
endmodule


module FA(A,B,Ci,Co,sum);
    
  input A,B,Ci;
  output sum,Co;

  assign sum = (A^B)^Ci;
  assign Co = (B&amp;Ci) | (A&amp;Ci) | (A&amp;B);
    
endmodule
",,,,,
How to generate uniform single precision floating point random number between 0 and 1 in FPGA?,"I am trying to generate single precision floating point random number using FPGA by generating number between 0 and 0x3f80000 (IEEE format for 1). But since there are more number of discreet points near to zero than 1, I am not getting uniform generation. Is there any transformation which I can apply to mimic uniform generation. I am using LFSR(32 Bit) and Xoshiro random number generation.","A standard way to generate uniformly distributed floats in [0,1) from uniformly distributed 32-bit unsigned integers is to multiply the integers with 2-32. Obviously we wouldn't instantiate a floating-point multiplier on the FPGA just for this purpose, and we do not have to, since the multiplier is a power of two. In essence what is needed is a conversion of the integer to a floating-point number, then decrementing the exponent of the floating-point number by 32. This does not work for a zero input which has to be handled as a special case. In the ISO-C99 code below I am assuming that float is mapped to IEEE-754 binary32 type.
Other than for certain special cases, the significand of an IEEE-754 binary floating-point number is normalized to [1,2). To convert an integer into the significand, we need to normalize it, so the most significant bit is set. We can do this by counting the number of leading zero bits, then left shifting the number by that amount. The count of leading zeros is also needed to adjust the exponent.
The significand of a binary32 number comprises 24 bits, of which only 23 bits are stored; the most significant bit (the integer bit) is always one and therefore implicit. This means not all of the 32 bits of the integer can be incorporated into the binary32, so in converting a 32-bit unsigned integer one usually rounds to 24-bit precision. To simplify the implementation, in the code below I simply truncate by cutting off the least significant eight bits, which should have no noticeable effect on the uniform distribution. For the exponent part, we can combine the adjustments due to normalization step with the subtraction due to the scale factor of 2-32.
The code below is written using hardware-centric primitives. Extracting a bit is just a question of grabbing the correct wire, and shifts by fixed amounts are likewise simply wire shifts. The circuit needed to count the number of leading zeros is typically called a priority encoder.
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

#define USE_FP_MULTIPLY  (0)

uint32_t bit (uint32_t, uint32_t);
uint32_t mux (uint32_t, uint32_t, uint32_t);
uint32_t clz (uint32_t);
float uint32_as_float (uint32_t);

/* uniform float in [0, 1) from uniformly distributed random integers */
float uniform_rand_01 (uint32_t i)
{
    const uint32_t FP32_EXPO_BIAS = 127;
    const uint32_t FP32_MANT_BITS = 24;
    const uint32_t FP32_STORED_MANT_BITS = FP32_MANT_BITS - 1;
    uint32_t lz, r;

    // compute shift amount needed for normalization
    lz = clz (i);
    // normalize so that msb is set, except when input is zero
    i = mux (bit (lz, 4), i &lt;&lt; 16, i);
    i = mux (bit (lz, 3), i &lt;&lt;  8, i);
    i = mux (bit (lz, 2), i &lt;&lt;  4, i);
    i = mux (bit (lz, 1), i &lt;&lt;  2, i);
    i = mux (bit (lz, 0), i &lt;&lt;  1, i);
    // build bit pattern for IEEE-754 binary32 floating-point number
    r = (((FP32_EXPO_BIAS - 2 - lz) &lt;&lt; FP32_STORED_MANT_BITS) + 
         (i &gt;&gt; (32 - FP32_MANT_BITS)));
    // handle special case of zero input
    r = mux (i == 0, i, r);
    // treat bit-pattern as 'float'
    return uint32_as_float (r);
}

// extract bit i from x
uint32_t bit (uint32_t x, uint32_t i)
{
    return (x &gt;&gt; i) &amp; 1;
}

// simulate 2-to-1 multiplexer: c ? a : b ; c must be in {0,1}
uint32_t mux (uint32_t c, uint32_t a, uint32_t b)
{
    uint32_t m = c * 0xffffffff;
    return (a &amp; m) | (b &amp; ~m);
}

// count leading zeros. A priority encoder in hardware.
uint32_t clz (uint32_t x)
{
    uint32_t m, c, y, n = 32;

    y = x &gt;&gt; 16; m = n - 16; c = (y != 0); n = mux (c, m, n); x = mux (c, y, x);
    y = x &gt;&gt;  8; m = n -  8; c = (y != 0); n = mux (c, m, n); x = mux (c, y, x);
    y = x &gt;&gt;  4; m = n -  4; c = (y != 0); n = mux (c, m, n); x = mux (c, y, x);
    y = x &gt;&gt;  2; m = n -  2; c = (y != 0); n = mux (c, m, n); x = mux (c, y, x);
    y = x &gt;&gt;  1; m = n -  2; c = (y != 0); n = mux (c, m, n - x);
    return n;
}

// re-interpret bit pattern of a 32-bit integer as an IEEE-754 binary32 
float uint32_as_float (uint32_t a)
{
    float r;
    memcpy (&amp;r, &amp;a, sizeof r);
    return r;
}

// George Marsaglia's KISS PRNG, period 2**123. Newsgroup sci.math, 21 Jan 1999
// Bug fix: Greg Rose, &quot;KISS: A Bit Too Simple&quot; http://eprint.iacr.org/2011/007
static uint32_t kiss_z=362436069, kiss_w=521288629;
static uint32_t kiss_jsr=123456789, kiss_jcong=380116160;
#define znew (kiss_z=36969*(kiss_z&amp;65535)+(kiss_z&gt;&gt;16))
#define wnew (kiss_w=18000*(kiss_w&amp;65535)+(kiss_w&gt;&gt;16))
#define MWC  ((znew&lt;&lt;16)+wnew )
#define SHR3 (kiss_jsr^=(kiss_jsr&lt;&lt;13),kiss_jsr^=(kiss_jsr&gt;&gt;17), \
              kiss_jsr^=(kiss_jsr&lt;&lt;5))
#define CONG (kiss_jcong=69069*kiss_jcong+1234567)
#define KISS ((MWC^CONG)+SHR3)

#define N 100

uint32_t bucket [N];

int main (void)
{
    for (int i = 0; i &lt; 100000; i++) {
        uint32_t i = KISS;
#if USE_FP_MULTIPLY
        float r = i * 0x1.0p-32f;
#else // USE_FP_MULTIPLY
        float r = uniform_rand_01 (i);
#endif // USE_FP_MULTIPLY
        bucket [(int)(r * N)]++;
    }
    for (int i = 0; i &lt; N; i++) {
        printf (&quot;bucket [%2d]: [%.5f,%.5f): %u\n&quot;, 
                i, 1.0f*i/N, (i+1.0f)/N, bucket[i]);
    }
    return EXIT_SUCCESS;
}
",,,,,
Any Neon equivalent for RISC V?,"I'm trying to port an ARM library to RISC-V. Source code includes references to arm_neon.h. The RISC-V toolchain does not contain any NEON sources, so, I was wondering if any equivalent exists.
Moreover, any resource on porting ARM libraries to RISC-V?","I guess it depends on what you mean by &quot;equivalent&quot;.
RISC-V doesn't really have SIMD yet.  Work on an extension, the RISC-V V specification is ongoing, and AFAICT (from an outsider's perspective) it's getting pretty close.  The API is probably going to be more like SVE than NEON, but if you're just asking about a SIMD API for RISC-V, that's probably your best bet.
NEON also supports 64-bit vectors, which is pretty rare.  MMX kind of supports them, but nobody really uses MMX anymore and Intel doesn't really add new functionality which operates on 64-bit vectors.  If 64-bit vectors are your thing, you might be more interested in the RISC-V P specification.  It's not as far along, so you'll likely be waiting longer for hardware support.
If what you care about is matching the API so you don't have to manually port your code, your best bet is probably one of my projects, SIMD Everywhere (SIMDe) (so obviously take the recommendation with a grain of salt).  Work on implementing NEON is ongoing, but we're currently a bit more than halfway through it.  There aren't any RISC-V specific implementations yet (we'll probably start trying to add support after compilers start to support it), but since there is no generally available hardware which implements the V spec it doesn't really matter.",,,,,
When will this variable be assigned?,"Here is the code:
process(SRSTN, CSN, WRN,AB) is
begin  
    if SRSTN = '0' then
        WR0 &lt;= (OTHERS =&gt; '0');
    elsif CSN = '0' then
        if WRN = '0' then
            case AB(15 downto 0) is
                when &quot;0101000100010000&quot; =&gt;
                    WR0(15 downto 0) &lt;= DB(15 downto 0);
                when OTHERS   =&gt;    NULL;
                     WR0(15 downto 8) &lt;= &quot;00000000&quot; ;
                end case;
        end if;
    end if;
end process;

I'm wondering when will
WR0(15 downto 8) &lt;= &quot;00000000&quot;be executed. Is it assigned everytime except AB equals 0101000100010000?","You have to use signal or variable (inside the process). A possible solution could be:
architecture Beh of Test is
    signal temp : std_logic_vector((WR0'LENGTH - 1) downto 0) := (others =&gt; '0');
 begin
 
    WR0 &lt;= std_logic_vector(temp);
 
    process(SRSTN, CSN, WRN,AB) is
    begin  
        if SRSTN = '0' then
            temp &lt;= (OTHERS =&gt; '0');
        elsif CSN = '0' then
            if WRN = '0' then
                case AB(15 downto 0) is
                    when &quot;0101000100010000&quot; =&gt;
                        temp(15 downto 0) &lt;= DB(15 downto 0);
                    when OTHERS   =&gt;
                        temp(15 downto 8) &lt;= &quot;00000000&quot; ;
                    end case;
            end if;
        end if;
    end process;
end Beh;


The WR0 output will be imediatly assigned if one of the inputs SRSTN, CSN, WRN, AB is changing.
",,,,,
Vitis: Store 16 byte variable into 4 32-bit registers,"I have a const unsigned char input, 16 byte. And I need to store it into 4 32-bit registers. Vitis allows to store 32 bit variable to 32 bit register using Xil_Out32. But I do not know how can I separate a 16 byte input to 4 pieces.
#define MY_REGISTER  XPAR_AES_ENCDEC_0_S00_AXI_BASEADDR /*Get the register address*/
#define MY_REGISTER_1  MY_REGISTER + 0
#define MY_REGISTER_2  MY_REGISTER + 4
#define MY_REGISTER_3  MY_REGISTER + 8
#define MY_REGISTER_4  MY_REGISTER + 12

void key_init(const unsigned char key[]);
     Xil_Out32(MY_REGISTER, /*4 byte key*/);


This is the key I will receive. Input testbench from VHDL code:
key &lt;= x&quot;00112233445566778899aabbccddeeff&quot;;
And I want to put it into 4 register. I already got the register base address:
00112233 to MY_REGISTER_1,
44556677 to MY_REGISTER_2,
8899aabb to MY_REGISTER_3,
ccddeeff to MY_REGISTER_4.","You can cast the pointer to the bytes into a pointer to 32-bit values, and use this to read the values for the registers.
void key_init(const unsigned char key[]) {
    const u32* pointer = (const u32*)key;
    Xil_Out32(MY_REGISTER_1, pointer[0]);
    Xil_Out32(MY_REGISTER_2, pointer[1]);
    Xil_Out32(MY_REGISTER_3, pointer[2]);
    Xil_Out32(MY_REGISTER_4, pointer[3]);
}

Notes:
An array given as a function parameter is converted to a pointer.
Accessing pointer[index] is equivalent to *(pointer + index).
Please consider endianness, you might need to use Xil_Out32BE() or Xil_Out32LE() or change the sequence of indexes to pointer.
Your byte array needs to be aligned on a u32 boundary, if your processor needs this. Anyway, if the byte address is not convertible to a u32 pointer because of alignment, this is Undefined Behavior. It might work, but only for your specific target.",,,,,
How to return an array in systemVerilog,"I am having some issues returning an array from a function in systemVerilog. However, I keep having a syntax error. I am not sure if referencing an array works here since I need to send args to my function.
Code :
module VGA_Setup 
(
        input wire clk, reset,
        output wire hsync, vsync,
        output wire [3:0] r, g, b
        
    );
    
    // constant declarations for VGA sync parameters
    localparam H_DISPLAY       = 640; // horizontal display area
    localparam H_L_BORDER      =  48; // horizontal left border
    localparam H_R_BORDER      =  16; // horizontal right border
    localparam H_RETRACE       =  96; // horizontal retrace
    localparam H_MAX           = H_DISPLAY + H_L_BORDER + H_R_BORDER + H_RETRACE - 1;
    localparam START_H_RETRACE = H_DISPLAY + H_R_BORDER;
    localparam END_H_RETRACE   = H_DISPLAY + H_R_BORDER + H_RETRACE - 1;
    
    localparam V_DISPLAY       = 480; // vertical display area
    localparam V_T_BORDER      =  10; // vertical top border
    localparam V_B_BORDER      =  33; // vertical bottom border
    localparam V_RETRACE       =   2; // vertical retrace
    localparam V_MAX           = V_DISPLAY + V_T_BORDER + V_B_BORDER + V_RETRACE - 1;
   localparam START_V_RETRACE = V_DISPLAY + V_B_BORDER;
    localparam END_V_RETRACE   = V_DISPLAY + V_B_BORDER + V_RETRACE - 1;
    int sq_pix = 80;
    
    wire video_on, p_tick;
    int colours [3];

    
    reg [3:0] red_reg, green_reg, blue_reg;
    reg [11:0] rbg;
    
    // mod-2 counter to generate 25 MHz pixel tick
    reg pixel_reg = 0;
    wire pixel_next;
    wire    pixel_tick;
    
    always @(posedge clk)
        pixel_reg &lt;= pixel_next;
    
    assign pixel_next = ~pixel_reg; // next state is complement of current
    
    assign pixel_tick = (pixel_reg == 0); // assert tick half of the time
    
    // registers to keep track of current pixel location
    reg [9:0] h_count_reg, h_count_next, v_count_reg, v_count_next;
    
    // register to keep track of vsync and hsync signal states
    reg vsync_reg, hsync_reg;
    wire vsync_next, hsync_next;
 
    // infer registers
    always @(posedge clk)
        if(~reset)
            begin
                    v_count_reg &lt;= 0;
                    h_count_reg &lt;= 0;
                    vsync_reg   &lt;= 0;
                    hsync_reg   &lt;= 0;
                end
        else
            begin
                    v_count_reg &lt;= v_count_next;
                    h_count_reg &lt;= h_count_next;
                    vsync_reg   &lt;= vsync_next;
                    hsync_reg   &lt;= hsync_next;
                end
            
    // next-state logic of horizontal vertical sync counters
    always @*
        begin
        h_count_next = pixel_tick ? 
                       h_count_reg == H_MAX ? 0 : h_count_reg + 1
                   : h_count_reg;
        
        v_count_next = pixel_tick &amp;&amp; h_count_reg == H_MAX ? 
                       (v_count_reg == V_MAX ? 0 : v_count_reg + 1) 
                   : v_count_reg;
                     
                     
            
                     
                     
                     
        end 
                
            
        // hsync and vsync are active low signals
        // hsync signal asserted during horizontal retrace
        assign hsync_next = h_count_reg &gt;= START_H_RETRACE 
                            &amp;&amp; h_count_reg &lt;= END_H_RETRACE;
   
        // vsync signal asserted during vertical retrace
        assign vsync_next = v_count_reg &gt;= START_V_RETRACE 
                            &amp;&amp; v_count_reg &lt;= END_V_RETRACE;

        // video only on when pixels are in both horizontal and vertical display region
        assign video_on = (h_count_reg &lt; H_DISPLAY) 
                           &amp;&amp; (v_count_reg &lt; V_DISPLAY);

        // output signals
        assign hsync  = hsync_reg;
        assign vsync  = vsync_reg;
        assign p_tick = pixel_tick; 
          
          
         colours = Letter_J(h_count_reg,v_count_reg);
          
          
// output
        assign r = (video_on) ? colours[0] : 4'b0;
          assign g = (video_on) ? colours[1] : 4'b0;
          assign b = (video_on) ? colours[2] : 4'b0;
          

                    
endmodule


function int[] Letter_J (int h_count_reg, int v_count_reg);

int colours_red = 0;
int colours_green = 0;
int colours_blue = 0;
int colours [3];

if ((h_count_reg &gt; 160) &amp;&amp; (h_count_reg &lt; 400)) begin
    if ((h_count_reg &gt; 240) &amp;&amp; (h_count_reg &lt; 320)) begin
        if ((v_count_reg &gt; 80) &amp;&amp; (v_count_reg &lt; 240)) begin
            colours_red = 4'b1111;
            colours_green = 4'b1111;
            colours_blue = 4'b1111;
        end
    
    end

end else begin
            colours_red = 4'b0000;
            colours_green = 4'b0000;
            colours_blue = 4'b0000;

end

colours [0] = colours_red;
colours [1] = colours_green;
colours [2] = colours_blue;
return colours;
endfunction


Error :

Error (10170): Verilog HDL syntax error at VGA_Setup.sv(108) near text: &quot;=&quot;;  expecting &quot;.&quot;, or &quot;(&quot;. Check for and fix any syntax errors that appear immediately before or at the specified keyword...

Thank you for your help.
Joe","The SystemVerilog BNF requires that you use a typedef for the return type of a function when that type is an aggregate. So you must do:
typedef int intDA_t[];
function intDA_t Letter_J (int h_count_reg, int v_count_reg);
",,,,,
Why doesn't 'd0 extend the full width of the signal (as '0 does)?,"Using SystemVerilog and Modelsim SE 2020.1, I was surprised to see a behavior:
bus_address is a 64b signal input logic [63:0] bus_address
Using '0
.bus_address         ('0),

Using 'd0
.bus_address         ('d0),

Riviera-Pro 2020.04 (too buggy, we gave up using it and we are in a dispute with Aldec)

'd0:



'0:


Investigation/Answer:

11.3.3 Using integer literals in expressions: An unsized, based integer (e.g., 'd12 , 'sd12 )

5.7.1 Integer literal constants:



The number of bits that make up an unsized number (which is a simple
decimal number or a number with a base specifier but no size
specification) shall be at least 32. Unsized unsigned literal
constants where the high-order bit is unknown ( X or x ) or
three-state ( Z or z ) shall be extended to the size of the expression
containing the literal constant.

That was tricky and I thought it would set 0 all the other bits as '0 does.
I hope specs' authors will think more when defining such non-sense behaviors.","This problem has more with port connections with mismatched sizes than anything to do with numeric literals. It's just that the issue does not present itself when using the fill literals. This is because the fill literal automatically sizes itself eliminating port width mismatch.
The problem you see exists whether you use literals or other signals like in this example:
module top;
  wire [31:0] a = 0;
  dut d(a);
endmodule
module dut(input wire [63:0] p1);
  initial $strobeb(p1);
endmodule

According to section 23.3.3.7 Port connections with dissimilar net types (net and port collapsing), the nets a and p1 might get merged into a single 64-bit net, but only the lower 32-bits remain driven, or 64'hzzzzzzzz00000000.
If you change the port connection to a sized literal, dut d(32'b0);, you see the same behavior 64'hzzzzzzzz00000000.
Now let's get back to the unsized numeric literal 'd0. Unsized is a misnomerâ€”all numbers have a size. It's just that the size is implicit and never the size you want it to be.  How many people write {'b1,'b0,'b1,'b0} thinking they've just wrote the same thing as 4'b1010? This is actually illegal in the LRM, but some tools silently interpret it as {32'b1,32'b0,32'b1,32'b0}.
Just never use an unsized literal.",,,,,
always_ff or always_comb for clock generation in a simple TestBench,"Which one is to be used with clock generation for a simple testbench? 
For eg:

always #20 clk &lt;= ~clk


if I change it to either always_ff or always_comb both gives error 

Statements in an always_comb shall not include those that block, have 
  blocking timing or event controls, or forkjoin statements. The always_ff 
  procedure imposes the restriction that it contains one and only one event 
  control and no blocking timing controls.
",Neither. Stick to the ordinary always.  always_comb and always_ff are for your design.,,,,,
System Verilog Associative Array,"Is it possible to define a associated array of different element types - something like below ?

typedef enum {M1, M2} mod_t;
typedef struct {...} m1_reg_t;
typedef struct {...} m2_reg_t;

array[mod_t] = {
   M1: { string name;
         m1_reg_t cfg
       }
   M2: { string name;
         m2_reg_t cfg;
         int m2_indx;
       }
}
","No, all arrays must have the same element type. 

If you really want an array with just two elements of a different type, use another struct instead of an array.

typedef struct { 
         string name;
         m1_reg_t cfg;
       } M1_t;
typedef struct { 
         string name;
         m2_reg_t cfg;
         int m2_indx;
       } M2_t;
struct { M1_t M1;
         M2_t M2;
} opcodes;


But if you are looking for an array of many elements where each element might hold a different opcode, consider a dynamic array of tagged unions.

typedef union tagged {
   struct { 
             string name;
             m1_reg_t cfg;
           } M1;
   struct { 
             string name;
             m2_reg_t cfg;
             int m2_indx;
           } M2;
} opcode_t;

opcode_t opcodes[];


Accessing tagged unions requires pattern matching statements. See section 12.6 in the 1800-2017 LRM.",,,,,
When should I use uvm_config_db?,"The only use with uvm_config_db is when we have more than one testbench in our system?
I`ll be glad to have some explanation about this macro.","The uvm_config_db class (it's not a macro) has many uses besides multiple testbenches. The most common is sharing data from the top-level testbench module, like the location of interface instances, with the drivers and monitor classes that need to access the virtual interfaces. 

It also gets used for communicating data between components and sequences, not just for passing values, but notifiers when data has been set.

You could certainly write a testbench without using the uvm_config_db, or the entire UVM for that matter. But that misses the whole point about writing testbenches for maintainability within the same testbench and reusability with other testbenches. ",,,,,
My testbench has errors and can't compile this character ( â€?),"I want to calculate with it, but if you think you can write a better testbench for me, please help.

`timescale 1ns / 1ps


  module testbenchDR();
  reg Clk , r , c , i , l ;
  wire  [15:0] dout1 ;
  wire [15:0] bus;
   DR   U0 ( clk, r , c , i , l , dout1 , bus ) ; 
  initial   begin
  clk   =    0 ;
  forever  begin
  clk  =  ~ clk;                                                                                                                                                              
  #20;
  end
  end

  initial    begin
  { r  ,c , i ,  l }   =   4â€™b0100   ;  /* bus    =  16 â€?h0f0f;  #200;*/
  { r  ,c , i ,  l }   =   4â€™b0001   ;   #200;
  { r  ,c , i ,  l }   =   4â€™b0010  ;   #200;
  { r  ,c , i ,  l }   =   4â€™b0011      ;   #200;
  { r  ,c , i ,  l }   =   4â€™b1000  ;   #200;
  { r  ,c , i ,  l }   =   4â€™b0110      ;   #200;
   end
  endmodule
","It's strange.  Visually, your apostrophe looks odd to me.  However, when I copy and paste your code into my editor, it looks good.  Just try copy and pasting this code:

initial begin
      { r  ,c , i ,  l }   =   4'b0100;
      { r  ,c , i ,  l }   =   4'b0001;   #200;
      { r  ,c , i ,  l }   =   4'b0010;   #200;
      { r  ,c , i ,  l }   =   4'b0011;   #200;
      { r  ,c , i ,  l }   =   4'b1000;   #200;
      { r  ,c , i ,  l }   =   4'b0110;   #200;
end




On a side note, I got a compile error.  Change:

  reg Clk , r , c , i , l ;


to (lower-case clk):

  reg clk , r , c , i , l ;




Here is your code running on edaplayground, without the DR module (since you didn't post that code).",,,,,
Passing a single row of a 2d array as an input to a module in verilog,"I was wondering if there is any way to pass a single row of a 2d array of values as the input to a module in Verilog.

Say my array is defined like this:

   reg[15:0] arr[0:9][0:63];
   ...
   ...
   mod1 m(..., arr[5], ....);


mod1 has the definition of:

module mod1 (..., input[15:0] arr[0:63],...);
...
...
endmodule


I use icarus verilog as my compiler. When I compile using the -g2012 flag, it throws the following error:

assert: elaborate.cc:1456: failed assertion rval_net-&gt;pin_count() == prts[0]-&gt;pin_count()


Can someone help me with this?","iverilog's SystemVerilog support is limited. With the -g2012 flag enabled it can pass multi-dimensional arrays across ports. The version you are using and the version available on EDAplayground, cannot automatically convert multi-dimensional structure into another multi-dimensional structure. This is a tool limitation, not a limitation in the IEEE1800 LRM.

With the version available to me (which is from 2014), I had to create an intermediate translation.

reg[15:0] arr[0:9][0:63];
reg[15:0] arr5[0:63];
...
always @* begin // should be always_comb; 2014 version does not support it
  foreach(arr5[idx])
    arr5[idx] = arr[5][idx];
end
...
mod1 m(..., arr5, ....);
",,,,,
What is a virtual accessor?,"This phrase is from ""uvm users guide 1.1"" page 20:

""In SystemVerilog, an important use model is to add randomization constraints to a transaction type. This is most often done with inheritanceâ€”take a derived object and add constraints to a base class. These
constraints can further be modified or extended by deriving a new class, and so on. To support this use
model, the accessor functions are virtual, and the members are protected and not local.""

What is an accessor ? and why it has to be virtual?","Accessor means a get_* function, that simply returns a value, without changing the object's state. The value returned could be a member variable or it could be a more complicated expression depending on member variables. An example would be a point class, which can deliver coordinates in both cartesian and polar (https://en.wikipedia.org/wiki/Polar_coordinate_system):

class point;

  local int x;
  local int y;

  // Accessor for x coordinate, cartesian
  function int get_x();
    return x;
  endfunction

  // Accessor for r coordinate, polar
  function int get_r();
    return sqrt(x**2 + y**2);
  endfunction

  // accessors would also exist for y and phi

endclass


If a function is virtual it can be overridden in a sub-class.

Why it's important for the accessors you mention to be virtual is not apparent from your question.",,,,,
How to view a SystemVerilog dynamic array in waveform,"I'm trying to implement a FIFO using SV taking dynamic arrays &amp; queues. However i'm unable to view waveform of the dynamic array/queues in the waveviewer. Does anyone know how to view waveform of dynamic arrays or it is not possible?

Result  in EDA Playground:


  Error message : [2020-05-28 01:53:22 EDT] iverilog '-Wall' '-g2012'
  design.sv testbench.sv  &amp;&amp; unbuffer vvp a.out   ivl: eval_object.c:65:
  eval_darray_new: Assertion `0' failed. Aborted (core dumped) Exit code
  expected: 0, received: 1


In SNPS VCS : 


  failed to add certain signals to waveform because they cant be found
  in FSDB.


 module dynamic_array_data();
      reg [7:0] mem [];
      initial begin
      $dumpfile(""dump.vcd"");
      $dumpvars;
      #10000 $finish;
    end
      initial begin
      mem = new[4];
      for (int i = 0; i &lt; 4; i ++) begin
      mem[i] = i;
      end
      end
    endmodule
","The VCD text format was never enhanced to support many of the datatypes that SystemVerilog introduced to Verilog, especially none of the dynamically sized arrays.  

You won't be able to use any of the tools on EDAPlayground since it relies on VCD files from $dumpvars to show waveforms.",,,,,
How to link source files into Eclipse based IDE,I am now at the beginning of software project for Xilinx Zynq SoC hardware platform. Xilinx company offers for software development their own Eclipse based IDE called Vitis. Due to version control reasons I need to have application source codes and custom IP peripheral drivers source codes in separate directories  (letÂ´s say App_src and Drivers_src) and I need to link the Vitis project with the aforementioned source codes in such a manner that the source codes modification occurs in the directory which is under version control. It means that I need to prevent any copying of source codes into the workspace. Can anybody tell me how to resolve that in system manner i.e. with respect to the version control system usage? Thanks in advance for any ideas. ,"I have found the solution. There is the ""Link folder"" option in the project Properties. This enables to link given folder without copying it into the workspace. ",,,,,
What`s the differences between Sequences and Sequence Items?,"What are the main differences ? 
When should I choose to work with sequences and when with sequence items? ","A sequence generates a series of sequence_itemâ€™s and sends it to the driver via sequencer. Thus, body() method of a sequence defines sequence_itemâ€™s that will be used.

On the other hand, a sequence item is the basic transaction used by the driver to drive the interface.

The following picture from UVM Basics tutorial explains it fully:

",,,,,
How can I use genvar variable to access input signals?,"I have a module with 30-vector inputs.. I need help in the for loop assignment.

module test (
  input [3:0] i0,
  input [3:0] i1,
  input [3:0] i2,
  ...
  input [3:0] i29

);

wire [3:0] int_i [0:29];

genvar j;
generate
  for (j=0; j&lt;30; j=j+1) begin
    assign int_i[j] = i(j) //need help here 
  end
endgenerate


endmodule


Is there a easy way to do this in Verilog. I know I can do this in System verilog by creating a 2-d vector of inputs. But is there a way to do this in Verilog?","The only way to do this in Verilog is to flatten out the 2-D array into a single vector.

module test (
  input [30*4-1:0] i;
);
wire [3:0] int_i [0:29];
genvar j;
for (j=0; j&lt;30; j=j+1) begin
    assign int_i[j] = i[4*j+:4];
end
",,,,,
Handle mutliple write operations to the same signal in vhdl,"I have n components that compute a certain hash and I don't know when they will be done. When they are done, they should send their found hash to a master component, where it doesn't matter which of the hashes reaches the master first, as long as he receives one. 

Is there a way of implementing this that avoids race conditions in the case where 2 or more components finish computing their hash at the exact same time without needing n signals (one for each hash) coming into the master?

I tried to implement the following that would lay between the master and the n components, but realized that this does not make much sense as there is still a race condition with all components writing to the same hash_in signal.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- System to connect multiple components to one master
-- When a component finds a hash, it writes to hash_in. Bus saves hash_in to an internal signal
-- and waits until master_ready is set to 1 to pass it the next signal
-- (Master sets master_ready to 0 while it's processing the last hash).

entity connector is
  port(
    -- The signal that all n components write to
    hash_in             : in    std_logic_vector(255 downto 0);
    -- Signal indicating if master is ready for the next hash
    master_ready        : in    std_logic;
    -- Hash we give to master
    hash_out            : out   std_logic_vector(255 downto 0)
  );
end connector;

architecture arch of connector is

  signal hash_internal : std_logic_vector(255 downto 0) := (others =&gt; '0');

begin

  hash_out &lt;= hash_internal;

  process(master_ready, hash_in)
  begin

    if(master_ready) then
      hash_internal &lt;= hash_in;
    end if;

  end process;

end architecture;


Thanks a ton in advance!","Based on your question, I assume you must minimize the size of the resulting design.

VHDL is (only) a way to describe a hardware design.  So before you write any VHDL, you should determine how the function can be implemented with the minimal size in the target technology.

It is unlikely that the target technology supports signals with multiple drivers, so this means that you can't write the design in VHDL where you try to use such a feature, since the synthesis tool will be unable to map the VHDL design to the target technology.

It may be that the smallest possible design is by using a mux that can select the appropriate component based on the decode of all the ready signals, as Tricky writes in the comment.  

It may seam like a rather large solution, but if that is the best the target technology allows, then it is the minimal solution.

So button line: Understand what the target technology allows, write the VHDL so the design is efficiently mapped by the synthesis tool to the target technology, and finally check that resulting implementation is as expected.",,,,,
Rounding of bits during different arithmetic operation in verilog?,"I am new to HDL coding.
I have a problem regarding rounding and there are different types of rounding available, like Round half away from zero, Round half to even, Round half to odd etc. (found in https://en.wikipedia.org/wiki/Rounding). I wrote a verilog code of rounding for my multiplication, addition etc. with the help of internet and the code is working properly. But, I want to know what type of rounding the code is performing. Whether it is Round half to odd or Round half to even or anything else. Can anybody tell me what type of rounding the code is performing? The code is given below
`timescale 1ns / 1ps

module rounding();
    parameter  x = 16;
    parameter y = 8;
    reg [(x)-1:0] A=16'b0010011010110011;
    reg          [(x)-1:0] B;
initial begin
 B = (A[y-1:0]) &gt;= (1 &lt;&lt; y-1) ? (A &gt;&gt;&gt; y) + 1 : (A &gt;&gt;&gt; y);
$display(&quot;%b&quot;, B); 
end 
endmodule

If I give input A=16'b0010011010110011; output is coming as 0000000000100111;
if A=16'b0000111100001111; output is coming as 0000000000001111","Your code divides input value A by 256 and apply rounding to the nearest integer:

A=16'b0010011010110011 -&gt; 9907 (dec) -&gt; 9907/256 = 38.69 (round up) ~ 39 -&gt; 0000000000100111
A=16'b0000111100001111 -&gt; 3855 (dec) -&gt; 3855/256 = 15.06 (round down) ~ 15 -&gt; 0000000000001111
",,,,,
clock gating verilog code not working correctly,"I'm to trying to code a clock gating logic  that allows data to pass only at the posedge write_clk_en. the code is compiled correctly in EDA playground but the output is not as intended.So according to code, 

@ (posedge write_clk_en)begin
 data_in[3] &lt;= 1'b1;
end


at this instance the write_clk_en is disabled, so data_in[3] NBA should be halted and it waits for next valid posedge (which is the next posedge of write_clk_en here), data_in[3] should be written. But that is not happening, rather the gated clock period is also getting considered and the NBA assignment is occurring even when write_clk_en is gated for 4th pulse.What could be the issue ?.the wave form is shown here.



the sv code :

module tb;

logic [4:0]  data_in;
logic  write_clk;
logic  write_clk_en;
logic write_clk_mod;  
logic [5:0] write_clk_init;

always//write_clk 500M
  begin
        write_clk  =0;
    #10 write_clk = 1;
    #10 write_clk = 0;
  end


initial begin
  $dumpfile(""dump.vcd"");
  $dumpvars;
  #10000 $finish;
end  

initial begin
data_in=5'b00000;
write_clk_init = 6'b000000;
write_clk_mod=0;
end

initial begin
write_clk_init =6'b110111;
end

initial begin
repeat (3) begin
@(posedge write_clk)begin
if(write_clk_init[0]==1 || write_clk_init[0]==0)
write_clk_mod&lt;=write_clk_init[0];
end
@(posedge write_clk)begin
if(write_clk_init[1]==1 || write_clk_init[1]==0)
write_clk_mod&lt;=write_clk_init[1];
end
@(posedge write_clk)begin
if(write_clk_init[2]==1 || write_clk_init[2]==0)
write_clk_mod&lt;=write_clk_init[2];
end
@(posedge write_clk)begin
if(write_clk_init[3]==1 || write_clk_init[3]==0)
write_clk_mod&lt;=write_clk_init[3];
end
@(posedge write_clk)begin
if(write_clk_init[4]==1 || write_clk_init[4]==0)
write_clk_mod&lt;=write_clk_init[4];
end
@(posedge write_clk)begin
if(write_clk_init[5]==1 || write_clk_init[5]==0)
write_clk_mod&lt;=write_clk_init[5];
end
end
end

  always @ (*) begin 
  write_clk_en  = write_clk &amp; write_clk_mod;
end

initial begin 

@ (posedge write_clk_en)begin
data_in[0] &lt;= 1'b1;
end
@ (posedge write_clk_en)begin
data_in[1] &lt;= 1'b1;
end
@ (posedge write_clk_en)begin
 data_in[2] &lt;= 1'b1;
 end
@ (posedge write_clk_en)begin
 data_in[3] &lt;= 1'b1;
end
@ (posedge write_clk_en)begin
data_in[4] &lt;= 1'b1;
end

end


endmodule
","Within initial blocks, change your NBAs to BAs. NBAs should only be used within an always @(posedge clocksignal) block

Take also into account that in simulations, @(posedge clocksignal) blocks (without the reserved word always) are treated as delays (wait until a rising edge clk event happens, then continue simulation). By the way you have written these blocks in your initial statements, I didn't know for sure if you were aware of their true behaviour. I've rewritten those @(posedge) blocks to make the simulation flow a bit clear.

I have also merged some of your initial blocks into one. Every initial block you have is started at the same time (simulation time 0). Particulary, write_clk_init is assigned in two different initial blocks.

This edited code works as expected. It is also available at https://www.edaplayground.com/x/3VYk



module tb;
  reg [4:0]  data_in;
  reg  write_clk;
  reg  write_clk_en;
  reg write_clk_mod;  
  reg [5:0] write_clk_init;

  initial begin
    $dumpfile(""dump.vcd"");
    $dumpvars;
    #10000 $finish;
  end  

  initial begin
    data_in = 5'b00000;
    write_clk_init = 6'b110111;
    write_clk_mod = 0;
    write_clk = 0;

    repeat (3) begin
      @(posedge write_clk);
      if(write_clk_init[0]==1 || write_clk_init[0]==0)
          write_clk_mod = write_clk_init[0];

      @(posedge write_clk);
      if(write_clk_init[1]==1 || write_clk_init[1]==0)
          write_clk_mod = write_clk_init[1];

      @(posedge write_clk);
      if(write_clk_init[2]==1 || write_clk_init[2]==0)
          write_clk_mod = write_clk_init[2];

      @(posedge write_clk);
      if(write_clk_init[3]==1 || write_clk_init[3]==0)
          write_clk_mod = write_clk_init[3];

      @(posedge write_clk);
      if(write_clk_init[4]==1 || write_clk_init[4]==0)
          write_clk_mod = write_clk_init[4];

      @(posedge write_clk);
      if(write_clk_init[5]==1 || write_clk_init[5]==0)
          write_clk_mod = write_clk_init[5];
    end
  end

  always @* begin 
    write_clk_en  = write_clk &amp; write_clk_mod;
  end

  initial begin 
    @(posedge write_clk_en);
    data_in[0] = 1'b1;

    @(posedge write_clk_en);
    data_in[1] = 1'b1;

    @(posedge write_clk_en);
    data_in[2] = 1'b1;

    @(posedge write_clk_en);
    data_in[3] = 1'b1;

    @(posedge write_clk_en);
    data_in[4] = 1'b1;
  end

  always begin
    write_clk = #10 ~write_clk;
  end      
endmodule
",,,,,
Best way to port map to multiple entities,"If a certain entity needs to be referenced many times in another ""top-level"" entity, what is the best way to do that?

For instance, given a certain entity My_Entity (simplified description here):

entity My_Entity is
    port (
        etc ...
    );
end My_Entity;


...how would I describe a top-level entity that uses 10 My_Entity's?

entity Top_Entity is
    port (
        etc ...
    );
end Top_Entity;

architecture rtl of Top_Entity is
begin
    entity1 : entity work.My_Entity(rtl) port map (
        etc ...
    );

    entity2 : entity work.My_Entity(rtl) port map (
        etc ...
    );

    -- repeat 10 times? or is there a better way?
end rtl;
","Yes. Use a generate loop:

entity Top_Entity is
    port (
        etc ...
    );
end Top_Entity;

architecture rtl of Top_Entity is
begin

    G: for I in 1 to 10 generate   -- the label ""G"" is compulsory here
        -- I varies between 1 and 10 here
        -- you can use it to distinguish between instances
        -- eg to connect each to a different element of an array
        entity1 : entity work.My_Entity(rtl) port map (
             etc ...
        );
    end generate;

end rtl;
",,,,,
Errors in VHDL using WHEN ELSE,"I'm new in VHDL and have simple errors.

Basically I have 4 binary inputs and 3 binary outputs.
The conditions are simple, if in all 4 inputs I have only one '1', output l3 receives '1' and the others '0', if I have two '1', output l2 receives '1' and the too much '0' and if I have more than two '1' the output l1 receives '1' and the others '0'.

Basically J1, J2, J3 and J4 are inputs. L1, L2 and L3 are outputs.
You can verify the truth table.

I'm tryind solve this with this code in EDA Playground (https://www.edaplayground.com/)

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;

ENTITY SistemaVotacion IS
PORT (j1, j2, j3, j4: IN std_logic;
      l1, l2, l3: OUT std_logic);
END SistemaVotacion;

ARCHITECTURE SistemaArchitecture OF SistemaVotacion IS
BEGIN
    l1 &lt;= '1' WHEN (j1 = '0' and j2 = '1' and j3 = '1' and j4 = '1')
    ELSE '1' WHEN (j1 = '1' and j2 = '0' and j3 = '1' and j4 = '1')
    ELSE '1' WHEN (j1 = '1' and j2 = '1' and j3 = '0' and j4 = '1')
    ELSE '1' WHEN (j1 = '1' and j2 = '1' and j3 = '1' and j4 = '0')
    ELSE '1' WHEN (j1 = '1' and j2 = '1' and j3 = '1' and j4 = '1')
    ELSE '0';
    l2 &lt;= '1' WHEN (j1 = '0' and j2 = '0' and j3 = '1' and j4 = '1')
    ELSE '1' WHEN (j1 = '0' and j2 = '1' and j3 = '0' and j4 = '1')
    ELSE '1' WHEN (j1 = '0' and j2 = '1' and j3 = '1' and j4 = '0')
    ELSE '1' WHEN (j1 = '1' and j2 = '0' and j3 = '0' and j4 = '1')
    ELSE '1' WHEN (j1 = '1' and j2 = '0' and j3 = '1' and j4 = '0')
    ELSE '1' WHEN (j1 = '1' and j2 = '1' and j3 = '0' and j4 = '0')
    ELSE '0';
    l3 =&gt; '1' WHEN (j1 = '0' and j2 = '0' and j3 = '0' and j4 = '0')
    ELSE '1' WHEN (j1 = '0' and j2 = '0' and j3 = '0' and j4 = '1')
    ELSE '1' WHEN (j1 = '0' and j2 = '0' and j3 = '1' and j4 = '0')
    ELSE '1' WHEN (j1 = '0' and j2 = '1' and j3 = '0' and j4 = '0')
    ELSE '1' WHEN (j1 = '1' and j2 = '0' and j3 = '0' and j4 = '0')
    ELSE '0';
END SistemaArchitecture;


But I'm getting some many errors like:


COMP96 ERROR COMP96_0015: ""';' expected."" ""design.vhd"" 24 8
COMP96 ERROR COMP96_0019: ""Keyword 'end' expected."" ""design.vhd"" 24 8
COMP96 ERROR COMP96_0016: ""Design unit declaration expected."" ""design.vhd"" 24 11


How I can do that?","As stated by the user1155120 the problem was in this:

What happens if l3 =&gt;  on line 24 becomes l3 &lt;= ? The parentheses
aren't required here, a condition is bounded by reserved words.

I changed and works.",,,,,
Why does the output signals post-synthesis not work as usual?,"I had written a small VHD file for simulating the behavior of a quadrature decoder, enclosed below. Simulating the design with a generic testbench works as expected. But after generating a synthesizable design with Quartus, I run into one of two problems (while playing with using unsigned, for example)
1. The position and direction signal are always at a constant 0 value throughout the post-synthesis simulation.
2. The position value seems to jump 10 values every 3-4 clock cycles, which I attribute to some jitter in data.
Does anyone have any recommendations to solve this issue? Is this mainly a timing problem or is there a major flaw in my design?  

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.NUMERIC_STD.ALL;

entity quad_decoder is
  port(rst   : in  std_logic;
       clk   : in  std_logic;
       a    : in  std_logic;
       b    : in  std_logic;
       direction : out std_logic;
       position : out std_logic_vector(8 DOWNTO 0));
end quad_decoder;


architecture behavioral of quad_decoder is
begin
    process(clk)
        variable counter : integer range 0 to 360 := 0;
        variable chanA,chanB : std_logic;
        variable int_direction : std_logic; 
            begin
                if (rst = '0') then 
                    int_direction := '0';
                    counter := 0;
                elsif (rising_edge(clk)) then                   
                    chanA := a;
                    chanB := b;
                    if (chanA = '1') and (chanB = '0') then
                        if (counter = 360) then
                            counter := 0;
                        else
                            counter:= counter + 1;
                        end if;
                        int_direction := '1';
                    elsif (chanA = '0') and (chanB = '1') then
                        if (counter = 0) then 
                            counter := 360; 
                        else 
                            counter := counter-1;
                        end if;
                        int_direction := '0';
                    else
                        counter := counter;
                        int_direction := int_direction;
                    end if;
                    position &lt;= std_logic_vector(to_unsigned(counter,9));
                    direction &lt;= int_direction;
                end if;
    end process;
end behavioral;


The expected pre-synthesis snap is here. 

I've linked an example snap of the post-synthesis simulation here. As seen, no change to position nor direction in multiple clock cycles. ","If anyone is inquisitive, doing assignments right at the clock edge as well as turning the reset signal high proved to introduce all kinds of timing issues, which passed the multi-corner timing analysis test, but failed other tests in Quartus that I had failed to notice.
I can go into more details if my answer is vague.",,,,,
How would you write a SystemVerilog Function that adds an even parity bit to a 7-bit vector?,"Would you take a 7-bit logic variable as an input and return an 8-bit logic output with the parity bit being the MSB (leftmost bit) of the output?
In a system that uses even parity you want the total number of 1 bits in the output vector to be even, right?
Can the the unary ^ operator can be used to calculate even parity?

Trying to figure out what that would look like? 

I started something like this:

Code for parity

Sorry if this is more than one question.","I would do this like this:

input logic [N-1:0] data_in;
output logic [N:0] data_out;

assign data_out = {^data_in, data_in};


The ^ reduction operator does an XOR operation on all the bits in the operand. (So, it will return '1 if data_in has an odd number of ones.)",,,,,
"Extra variable assignment in VHDL code makes it not work and get error ""can't infer register"" and ""couldn't implement registers""","I am facing a error in the code below every time I got an extra ""i2c_send_flag&lt;='1';"" line inside my process.

I don't understand why the code works before I add this line and stop working after I add it.

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY MAIN IS
    PORT(
        PIN_CLOCK_50MHZ : IN std_logic;
        PIN_KEY             : IN std_logic_vector (3 downto 0); 
        LEDR                : OUT std_logic_vector (17 downto 0):=""000000000000000000"";
        LEDG                : OUT std_logic_vector (8 downto 0):=""000000000"";
        PIN_SW            : IN std_logic_vector (2 downto 0); 
        PIN_I2C_SCLK        : OUT std_logic;
        PIN_I2C_SDA         : INOUT std_logic;
        PIN_MCLK                : OUT std_logic;    
        PIN_BCLK                : OUT std_logic;    
        PIN_ADC_DATA        : IN std_logic; 
        PIN_ADC_LRCK        : OUT std_logic;                                                                                
        PIN_DAC_DATA        : OUT std_logic;    
        PIN_DAC_LRCK        : OUT std_logic                                         
    );
END MAIN;

ARCHITECTURE main OF MAIN IS

    SIGNAL i2c_busy      : std_logic;
    SIGNAL i2c_send_flag : std_logic;
    SIGNAL i2c_data      : std_logic_vector(15 downto 0);
    SIGNAL i2c_done     : std_logic;
    SIGNAL clock_12mhz      : std_logic;
    SIGNAL clock_2m4hz          : std_logic;
    SIGNAL clock_100hz      : std_logic;
    SIGNAL clock_6mhz           : std_logic;
    SIGNAL adc_dac_bclk     : std_logic;
    SIGNAL adc_data         : std_logic;
    SIGNAL adc_lrck         : std_logic;
    SIGNAL dac_data         : std_logic;
    SIGNAL dac_lrck         : std_logic;

    COMPONENT i2c IS
        PORT(
            I2C_CLOCK_12MHZ: IN std_logic                               :='0';
            I2C_DEVICE_ADDR: IN std_logic_vector (7 downto 0)   :=""00000000"";
            I2C_DATA            : IN std_logic_vector (15 downto 0) :=""0000000000000000"";

            I2C_START_FLAG  : IN std_logic                              :='0';
            I2C_BUSY            : OUT std_logic                         :='0';
            I2C_DONE            : OUT std_logic                         :='0';

            I2C_SCLK            : OUT std_logic                         :='1';
            I2C_SDA         : INOUT std_logic                           :='1'
        );
    END COMPONENT i2c;

    COMPONENT pll IS
        PORT (
            inclk0  : IN STD_LOGIC  := '0';
            c0          : OUT STD_LOGIC 
        );
    END COMPONENT pll;

    COMPONENT divclk_12M_2M4 IS
        PORT (
            clk_in   : IN std_logic;
            clk_out  : OUT std_logic
        );
    END COMPONENT divclk_12M_2M4;

    COMPONENT divclk_12M_100 IS
        PORT (
            clk_in   : IN std_logic;
            clk_out  : OUT std_logic
        );
    END COMPONENT divclk_12M_100;

    COMPONENT divclk_12M_6M IS
        PORT (
            clk_in   : IN std_logic;
            clk_out  : OUT std_logic
        );
    END COMPONENT divclk_12M_6M;    

    COMPONENT adc_dac_controller IS
        PORT(
            CTRL_BCLK       :  IN std_logic;

            CTRL_ADC_DATA   :  IN  std_logic;
            CTRL_ADC_LRCK   :  OUT std_logic;

            CTRL_DAC_DATA   :  OUT std_logic;
            CTRL_DAC_LRCK   :  OUT std_logic
        );
    END COMPONENT adc_dac_controller;

    BEGIN

            WM8731: COMPONENT i2c 
                            PORT MAP(
                                I2C_CLOCK_12MHZ=&gt;   clock_12mhz,
                                I2C_DEVICE_ADDR=&gt;   ""00110100"",
                                I2C_DATA            =&gt;  i2c_data,

                                I2C_START_FLAG  =&gt;  i2c_send_flag,
                                I2C_BUSY            =&gt;  i2c_busy,

                                I2C_DONE            =&gt;  i2c_done,

                                I2C_SCLK            =&gt;  PIN_I2C_SCLK,
                                I2C_SDA         =&gt;  PIN_I2C_SDA 
                            );  
            PLL12:  COMPONENT pll 
                            PORT MAP(
                                inclk0          =&gt;  PIN_CLOCK_50MHZ,
                                c0                  =&gt;  clock_12mhz 
                            );

            Divclk_2M4Hz:   COMPONENT divclk_12M_2M4 
                                    PORT MAP(
                                        clk_in  =&gt;  clock_12mhz,
                                        clk_out =&gt;  clock_2m4hz
                                    );                                              
            Divclk_6MHz:    COMPONENT divclk_12M_6M 
                                    PORT MAP(
                                        clk_in  =&gt;  clock_12mhz,
                                        clk_out =&gt;  clock_6mhz
                                    );                              
            Divclk_100Hz:   COMPONENT divclk_12M_100 
                                    PORT MAP(
                                        clk_in  =&gt;  clock_12mhz,
                                        clk_out =&gt;  clock_100hz
                                    );                                              

            adc_dac_ctrl:   COMPONENT adc_dac_controller
                                    PORT MAP(

                                        CTRL_BCLK       =&gt; clock_12mhz,


                                        CTRL_ADC_DATA   =&gt; adc_data,
                                        CTRL_ADC_LRCK   =&gt; adc_lrck,

                                        CTRL_DAC_DATA   =&gt; dac_data,
                                        CTRL_DAC_LRCK   =&gt; dac_lrck
                                    );                                  


    PIN_MCLK        &lt;= clock_12mhz;
    PIN_BCLK        &lt;= clock_12mhz;
    adc_data        &lt;= PIN_ADC_DATA;
    PIN_ADC_LRCK&lt;= adc_lrck;
    PIN_DAC_DATA&lt;= dac_data;
    PIN_DAC_LRCK&lt;= dac_lrck;
    LEDG(7)     &lt;= i2c_done;

    PROCESS (clock_100hz)
    BEGIN

        IF rising_edge (clock_100hz) THEN
            IF (PIN_KEY=""1111"") THEN
                 i2c_send_flag &lt;='0';
            END IF;
        END IF;

        IF rising_edge(clock_100hz) AND i2c_busy='0' THEN

            IF (PIN_SW (0)='1' AND PIN_KEY(0)='0') THEN                             
                        i2c_data(15 downto 9)&lt;=""0000000"";
                        i2c_data(8)&lt;='0'; 
                        i2c_data(7)&lt;='0';
                        i2c_data(6 downto 5)&lt;=""00"";
                        i2c_data(4 downto 0)&lt;=""11111"";
                        i2c_send_flag&lt;='1'; 
                    ------------------------------------------------------
            ELSIF (PIN_SW (0)='1' AND PIN_KEY(1)='0') THEN
                        i2c_data(15 downto 9)&lt;=""0000001"";
                        i2c_data(8)&lt;='1';
                        i2c_data(7)&lt;='0';
                        i2c_data(4 downto 0)&lt;=""11111"";
                        i2c_send_flag&lt;='1';
                    ------------------------------------------------------
            ELSIF (PIN_SW (0)='1' AND PIN_KEY(2)='0') THEN      
                        i2c_data(15 downto 9)&lt;=""0000010"";
                        i2c_data(8)&lt;='0';
                        i2c_data(7)&lt;='1';
                        i2c_data(6 downto 0)&lt;=""1111000"";
                        i2c_send_flag&lt;='1';
            ELSIF (PIN_SW (0)='1' AND PIN_KEY(3)='0') THEN
                        i2c_data(15 downto 9)&lt;=""0000011"";
                        i2c_data(8)&lt;='1';
                        i2c_data(7)&lt;='1'; 
                        i2c_data(6 downto 0)&lt;=""1111000"";
                        i2c_send_flag&lt;='1';             
            ELSIF (PIN_SW (1)='1' AND PIN_KEY(0)='0') THEN
                        i2c_data(15 downto 9)&lt;=""0000100"";
                        i2c_data(8)&lt;='0';                       
                        i2c_data(7 downto 6)&lt;=""11"";
                        i2c_data(5)&lt;='0'; 
                        i2c_data(4)&lt;='1'; 
                        i2c_data(3)&lt;='0';
                        i2c_data(2)&lt;='0';
                        i2c_data(1)&lt;='1';
                        i2c_data(0)&lt;='0';
                        i2c_send_flag&lt;='1';
            ELSIF (PIN_SW (1)='1' AND PIN_KEY(1)='0') THEN
                        i2c_data(15 downto 9)&lt;=""0000101"";
                        i2c_data(8 downto 5)&lt;=""0000"";   
                        i2c_data(4)&lt;='0'; 
                        i2c_data(3)&lt;='0'; 
                        i2c_data(2 downto 1)&lt;=""11"";
                        i2c_data(0)&lt;='0'; 
                        i2c_send_flag&lt;='1';                             
            ELSIF (PIN_SW (1)='1' AND PIN_KEY(2)='0') THEN
                        i2c_data(15 downto 9)&lt;=""0000110"";
                        i2c_data(8)&lt;='0';
                        i2c_data(7)&lt;='0';
                        i2c_data(6)&lt;='1';
                        i2c_data(5)&lt;='1';
                        i2c_data(4)&lt;='0';
                        i2c_data(3)&lt;='0';
                        i2c_data(2)&lt;='0'; 
                        i2c_data(1)&lt;='1'; 
                        i2c_data(0)&lt;='0';
                        i2c_send_flag&lt;='1';                             
            ELSIF (PIN_SW (1)='1' AND PIN_KEY(3)='0') THEN
                        i2c_data(15 downto 9)&lt;=""0000111"";
                        i2c_data(8)&lt;='0';
                        i2c_data(7)&lt;='0';
                        i2c_data(6)&lt;='0';
                        i2c_data(5)&lt;='0';
                        i2c_data(4)&lt;='1';
                        i2c_data(3 downto 2)&lt;=""00"";
                        i2c_data(1 downto 0)&lt;=""10"";
                        i2c_send_flag&lt;='1';                         
            ELSIF (PIN_SW (2)='1' AND PIN_KEY(0)='0') THEN
                        i2c_data(15 downto 9)&lt;=""0001000"";
                        i2c_data(8)&lt;='0';
                        i2c_data(7)&lt;='0';
                        i2c_data(6)&lt;='0';
                        i2c_data(5 downto 2)&lt;=""0000"";
                        i2c_data(1)&lt;='0'; 
                        i2c_data(0)&lt;='1';
                        i2c_send_flag&lt;='1';                         
            ELSIF (PIN_SW (2)='1' AND PIN_KEY(1)='0') THEN
                        i2c_data(15 downto 9)&lt;=""0001001""; 
                        i2c_data(8 downto 1)&lt;=""00000000"";
                        i2c_data(0)&lt;='1';
                        i2c_send_flag&lt;='1';         
--          ELSIF (PIN_SW (2)='1' AND PIN_KEY(3)='0') THEN
--                      i2c_data(15 downto 9)&lt;=""0001111"";
--                      i2c_data(8 downto 0)&lt;=""000000000"";
--                      i2c_data(15 downto 0)&lt;=""0001111000000000"";
--                      i2c_send_flag&lt;='1';
            END IF;

        END IF;
    END PROCESS;

END main;


When I Uncomment the last part of code in the If statment I get the following erros:


Error (10821): HDL error at MAIN.vhd(304): can't infer register for ""i2c_send_flag"" because its behavior does not match any supported register model
Error (10822): HDL error at MAIN.vhd(298): couldn't implement registers for assignments on this clock edge


I can't understand why this piecce of code (which i use in the ""Elsif"" below and work) fail when I added it one more time.","Generally speaking to make the synthesis tools happy, you need one clock per process and no logic in the clock statement.   Applied to your code it would need to be restructured as:

PROCESS (clock_100hz)
BEGIN

    IF rising_edge (clock_100hz) THEN
        IF (PIN_KEY=""1111"") THEN
             i2c_send_flag &lt;='0';
        END IF;
        if i2c_busy='0' THEN

          IF (PIN_SW (0)='1' AND PIN_KEY(0)='0') THEN                             
                    i2c_data(15 downto 9)&lt;=""0000000"";
                    i2c_data(8)&lt;='0'; 
                    i2c_data(7)&lt;='0';
                    i2c_data(6 downto 5)&lt;=""00"";
                    i2c_data(4 downto 0)&lt;=""11111"";
                    i2c_send_flag&lt;='1'; 
                ------------------------------------------------------
          ELSIF (PIN_SW (0)='1' AND PIN_KEY(1)='0') THEN
                    i2c_data(15 downto 9)&lt;=""0000001"";
                    i2c_data(8)&lt;='1';
                    i2c_data(7)&lt;='0';
                    i2c_data(4 downto 0)&lt;=""11111"";
                    i2c_send_flag&lt;='1';
          ELSIF ...
                ...
          END IF;
        END IF;
      END IF;
",,,,,
Verilog Temporary Variable,"I tried to make a CMP instruction in Verilog. To keep the result of the substraction, I declared a wire. This is what the code looks like (It is executed in an always statement).

wire [data_width:0] tmp_wire = reg_accumulator - reg_x;

f_zero &lt;= tmp_wire &amp; 'hFF == 0;
f_carry &lt;= tmp_wire &amp; 'h100;


Now Icarus Verilog complains about a syntax error and that reg_accumulator - reg_x is not an l-value:

cpu.v:149: syntax error
cpu.v:149: Syntax in assignment statement l-value.


And why does it complain? What would be the right approach to declare a temporary variable in a function / task?

module comparator(
    input clk,
    input [7:0] op_a,
    input [7:0] op_b
);

reg f_zero;
reg f_carry;

function compare;
    input [data_width-1:0] a;
    input [data_width-1:0] b;
begin
    wire [7:0] tmp_wire = reg_accumulator - reg_x;

    f_zero &lt;= tmp_wire &amp; 'hFF == 0;
    f_carry &lt;= tmp_wire &amp; 'h100;
end
endfunction

always @(posedge clk) begin
    compare(op_a, op_b);
end

endmodule // comparator
","Either you should use systemverilog and include this in a class or you can create a parameterized module:

module compare_zero_n_carry
# (
    parameter DATA_WIDTH = 8
  )
(zero, carry, a, b);

  /* ports */
  input [DATA_WIDTH-1:0] a;  //..""reg_accumulator""
  input [DATA_WIDTH-1:0] b;  //..""reg_x""
  output zero;
  output carry;

  wire [DATA_WIDTH-1:0] tmp_wire = a - b;

  assign zero = (tmp_wire &amp; {DATA_WIDTH{1'b1}}) == {DATA_WIDTH{1'b0}};
  //..HERE IM NOT REALLY SURE WHAT IS THE LOGIC FOR THE CARRY,
  //..IT SHOULD BE ONE BIT
  assign carry = (tmp_wire &amp; {1'b1,{(DATA_WIDTH-1){1'b0}}});     
endmodule // compare_zero_n_carry


And instantiate it in the main comparator module as:

  input                   clk;
  input [DATA_WIDTH-1:0]  op_a;
  input [DATA_WIDTH-1:0]  op_b;

  wire f_zero;
  wire f_carry;
  reg f_zero_reg;
  reg f_carry_reg;

  compare_zero_n_carry
    # (
        .DATA_WIDTH (DATA_WIDTH)
      )
    compare_zero_n_carry_inst (
        .a      (op_a),
        .b      (op_b),
        .zero   (f_zero),
        .carry  (f_carry)
      );

  always @ (posedge clk) begin
    f_zero_reg &lt;= f_zero;
    f_carry_reg &lt;= f_carry;
  end
",,,,,
Does the following verilog code have a race condition issue?,"I am working with a verilog module (shown below) has two always blocks. Won't there be some sort of race condition since one block sets a register and the other uses the register.  What kind of issues would this cause?

Thanks,
Stephen 

module XYZ
(                               
    input  wire         CLK,    
    input  wire         Reset,    
    input  wire         nReset,   
    input  wire [15:0]  X,      
    input  wire [15:0]  A,    
    input  wire         T,  
    input  wire         B,  
    output reg          M     
);

assign C = X &gt; A;

reg P;  
reg N;

always @(posedge CLK, negedge nReset)
begin
    if (~nReset)
    begin
        P &lt;= 1;
        N &lt;= 1;
    end else begin
        if (Reset)
        begin
            P &lt;= 1;
            N &lt;= 1;
        end else begin
            P &lt;= T?  1:  ((C &amp; ~M)?  0:  P);
            N &lt;= B?  1:  ((M &amp; ~C)?  0:  N);
        end
    end
end

always @(posedge CLK, negedge nReset)
begin
    if (~nReset)
    begin
        M &lt;= 0;
    end else begin
        if (Reset)
        begin
            M &lt;= 0;
        end else begin
            M &lt;= M?  ~(N &amp; ~C):  (P &amp; C);
         end
    end
end


endmodule","No, there is no race condition.  Verilog is an event-driven simulator. Posedge (unless there is a glitch in the clock or reset) is usually executed once per the simulation tick. If you use non-blocking assignments correctly (and it looks like you did), every always block triggered by an edge will use old versions of the input variable values, the values which existed before the clock edge. 

Here is a simplified example:

always @(posedge clk)
   r &lt;= in;
always @(posedge clk)
   out &lt;= r;


What happens in this situation is the following:


r will be assigned the value of in later at the simulation tick, after the always blocks have been evaluated (see the nba scheduling region).
since r has not been yet really changed, the out will be scheduled to be assigned the value of r with the value before the edge. 


If r was 0 before the edge and in was 1, at the end of the simulation r will become 1 and out will become 0.

This mimics behavior for real flops in hardware. 

In your case it might look as a loop dependency. In reality it it none. For the same reason as above the M value will be the one from before the the posedge and will not cause any race. Flops cannot be involved in the combinational loops due to their properties logical properties. ",,,,,
"simple adder + testbench returning ""dont care"" input","i have a simple test bench for an adder module, but I am getting the wrong input:

module adderTestbench;

    wire [31:0] fromAdd;

    adder lol(32'h00000000,fromAdd);


    initial begin //forcing program to be sequential
    #100; //wait 100
    end //end begin

    initial begin
    $display(""%h"",fromAdd);
    end

endmodule

module adder(addIn,addOut);
input [31:0] addIn;
output reg [0:31] addOut;
always @(addIn) 
begin
addOut &lt;= addIn + 32'h00000004;
end
endmodule


It displays xxxxxxxx.

Can anyone explain why it is not displaying 4, instead it's displaying x's?","The code marked as  ""//forcing program to be sequential"" does not make any code sequential.
Your two initial statements will still run in parallel. You probably mean:

initial
begin
   #100; //wait 100
   $display(""%h"",fromAdd);
end
",,,,,
use ft2232H on lattice machXO3 dev. board,"first sorry if this is a simple question but I can't figure this out. I have this development board and on page 19 on the kits user guide the block diagram shows a RS232 line and on page 20 and 22 the schematic show the pins I need to connect to use RS232. My problem is that, despite being able to configure the fpga/cpld, I cannot find the com port on my computer (using pyserial and the following code(I tried changing COM%s in line 15 to FTUSB-%s)). So my questions are: 

What interface does the FTDI, ft2232h USB to UART/FIFO,  chip use (Serial, parallel... ) on the computer's end (like arduino's virtual COM port)?

On lattice's software there are 3 options to program the device. the program shows the following: HW-USBN-2b (FTDI) (with port as FTUSB-0), HW-USBN-2b (with port as ezUSB-0) and HW-DLN-3C. How can I use either of them to communicate with the device outside of Lattice's software?

thanks for you time.","1) RS232 is a combination of UART with certain voltage levels for the high and low (i.e. +3 to +15V and -3 to -15V afaik. Never ever connect a RS232 adapter to standard 3.3V  or 5V devices e.g. UART, TTL-UART etc. The Lattice Semiconductor document just plainly missuses the term RS232 - try not to fall for it (IMHO the performance of their products strongly anticorrelates with the quality of their documentation and support). 

2) page 19 of the linked doc shows the sections: Ordering Information, Technical Support Assistance, Revision History. Shifted by one page?

3) The FT2232H can be used in multiple modes. This depends on the way how it is addressed and of the settings flashed to the EEPROM connected to it (on the dev board is one placed but the FT2232H can be used without as well). The dev board is in the standard configuration designed to be programmed via the JTAG pins and the FT2232H is opened via the D2XX driver by lattice diamond. For that reason they flashed the EEPROM with settings which prohibits the use as virtual com port. The FTDI flash software can be used to change that behavior - for each bank seperately.

4) The solder bridges can be used to rearrange the connections (e.g. if one wants to change from the JTAG interface to the SPI or I2C programming interface). In your case you most likely want to place bridges on R14 and R15 to make the proper connection for an UART link to the port B of the FT2232H. EDIT: This way Port A can be used in JTAG mode to program the FT2232H and port B to communicate via e.g. UART or even other modes like the fast opto or the parallel bus/FIFO - if the correct bridges are soldered. Changing the EEPROM settings might be still required to make Port B visible as VCP if one want to avoid the usage of the D2XXX driver.",,,,,
How do I cast to longint unsigned in systemverilog?,"I want to cast logic packed array into longint unsigned in systemverilog and then I can export it using DPI-C to C++ unsigned long. The simulator I am using is Verilator. Check the example below.

logic[31:0] v1;
logic[63:0] v2;

int a = signed'(v1); //cast to signed int
int b = int'(v1); //cast to signed int
int unsigned c = unsigned'(v1); //cast to unsigned int
longint d = longint'(v2); //cast to signed long
//longint unsigned e = longint unsigned'(v2); //This doesn't work. I need to cast to unsigned long.
","You need to create a SystemVerilog type without a space in it using typedef. Here's an example:

// ..
typedef longint unsigned uint64_t;
uint64_t e = uint64_t'(v2);
",,,,,
Is it possible to train YOLO - object detection model on FPGA?,"Training on images needs a lot of computations to derive at least a considerable amount of precision for object detection. As I studied on fully training of object detection models like YOLO, it is said that it takes from hours to days on GPU. 
    However, we are trying to implement a hardware accelerator for CNN training using FPGA for an object detection model like YOLO and we are doing it for the final year project in our university. Since we are trying to find out the feasibility of the project before moving further, any suggessions in this regard would be helpful.","You never really want to train on FPGAs or on similar ""low cost"" hardware. Training needs a lot more memory and a lot more computational power.

The common approach is to train the network normally on GPUs and then quantize it to whatever you need to let it run on the FPGA. Once this is done you can try to load the architecture and weights onto the FPGA.

I would assume just getting a single network architecture to run is challenging enough, so start with this and maybe then think about extending it so arbitrary architectures and be run.",,,,,
Is it possible to conditionally generate a for loop in System Verilog?,"Currently when I try to conditionally generate a for loop I get a compile error stating that I ""Cannot nest generate regions"".

Example of what I'm trying to do:

generate 
   if (x == 0) begin
      for (genvar i = 0; i &lt; 16; i++) begin
          *some code here*
      end
   end
   else begin
      for (genvar k = 0; k &lt; 16; k++) begin
          *some code here*
   end
endgenerate


Edit: 
Thank you all for the responses and help, but I've discovered the problem. Thank you Greg for reminding me about not being able to use generate within another generate.

Here's the Minimal Reproducible example that was causing me problems.

module test ();
  parameter x = 1;
  parameter y = 1;
  if (y == 1) begin
    generate 
     if (x == 1) begin
        for (genvar i = 0; i &lt; 16; i++) begin
            test_inner test_inner1();
        end
     end
     else begin
        for (genvar k = 0; k &lt; 16; k++) begin
            test_inner test_inner2();
        end
     end
    endgenerate
  end

endmodule


As you can see I had a conditional statement nested within another conditional statement. Because I didn't use the generate keyword in the outer conditional I didn't realize that it counted as a generate within another generate.

To solve the problem I moved the generate to the outer conditional, as such:

module test ();
  parameter x = 1;
  parameter y = 1;
  generate 
  if (y == 1) begin
     if (x == 1) begin
        for (genvar i = 0; i &lt; 16; i++) begin
            test_inner test_inner1();
        end
     end
     else begin
        for (genvar k = 0; k &lt; 16; k++) begin
            test_inner test_inner2();
        end
     end
  end
  endgenerate

endmodule
","keyword generate is optional in system verilog. If used, its starts a new generate block. Such generate blocks cannot be nested. 

However, if you use generate if or for statements without the generate keyword, the compiler will take care of correct generate block boundaries for you. 

In your case #1 you are missing the end keyword, it cannot be compiled.

In your case #2 you use if (y == 1) begin which starts a generate block. Then you use the keyword generate inside the already started block. It makes them nested.

Case #3 is correct use of the generate block.

You do not have case #4, but if you just get rid or both generate and endgenerate, it should work the same way as #3. 

It always a good idea to name your generated blocks in order to control generated instance names. Like this:

module test ();
  parameter x = 1;
  parameter y = 1;
  if (y == 1) begin: y1
     if (x == 1) begin: x1
        for (genvar i = 0; i &lt; 16; i++) begin: x1_loop
            test_inner test_inner1();
        end
     end
     else begin
        for (genvar k = 0; k &lt; 16; k++) begin: x2_loop
            test_inner test_inner2();
        end
     end
  end 
endmodule
",,,,,
verilog $time based clock period,"I am generating a PLL simulation model. I can find the input ref clock period by using $time and divide the period with pll divider to generate pll output clock. as shown below, but simulator doesn't show anything on waveform , no syntax error though. What is wrong with this approach ?

 time prev_t, periodd;
 reg clk = 0;

  always @(posedge CLK_PLL_IN) begin
    periodd = $time - prev_t;
    prev_t  = $time;
  end 

  always #(periodd/pll_div) clk = ~clk;


","The initial value of periodd is 0, so you get into a zero delay loop if the second always block begins before the first. I also suggest using realtime and $realtime instead of time and $time in case the factional part of periodd/pll_div is smaller than the timescale. 

realtime prev_t, periodd=0;
reg clk = 0;

  always @(posedge CLK_PLL_IN) begin
    periodd = $time - prev_t;
    prev_t  = $time;
  end 

  initial wait(periodd &gt;0)
      forever #(periodd/pll_div) clk = ~clk;
",,,,,
"Why are you giving an error in ""="" in my VHDL code","LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;

ENTITY f_4fir_cont IS
    PORT (
        rst, clk : IN std_logic;
        ctrl : OUT std_logic
    );
END f_4fir_cont;
ARCHITECTURE bhvrl OF f_4fir_cont IS TYPE state_enum IS (s0, s1);
    SIGNAL state : state_enum := s0;
    SIGNAL nexts : state_enum := s1;

BEGIN
    clkp : PROCESS (clk, rst)
    BEGIN
        IF (rst = &quot;0&quot;) THEN
            state &lt;= s0;
        ELSIF (clk'EVENT AND clk = &quot;1&quot; AND
            clk'LAST_VALUE = &quot;0&quot;) THEN
            state &lt;= nexts;
        END IF;
    END PROCESS clkp;

    transp : PROCESS (state)

    BEGIN
        CASE state IS
            WHEN s0 =&gt; nexts &lt;= s1;
            ctrl &lt;= &quot;0&quot;;
            WHEN s1 =&gt; nexts &lt;= s0;
            ctrl &lt;= &quot;1&quot;;
        END CASE;
    END PROCESS transp;
END bhvrl;

I found this code in a book and am giving this error IF (rst = &quot;0&quot;) THEN:
Error (10327): VHDL error at f_4fir_cont.vhd(17): can't determine definition of operator &quot;&quot;=&quot;&quot; -- found 0
I have already researched and found nothing to solve, I am starting in VHDL and I need help.","Both rst and clk are std_logic, which is an enumerated type. You are comparing them to arrays. Change all of the compares to single characters:
if rst = '0' then

etc.",,,,,
"In Verilog, is it possible to check the conditions of a loop after executing the logic?","Effectively, I'm looking for a way to loop 8 times using only a 3-bit variable for incrementation.
I do realise that a simple solution is to use a 4-bit variable and use
for(i=0; i&lt;8; i = i+1)

But if it is possible to check the conditions of a loop only after executing its contents, then a solution like the following (which is written in SystemVerilog using do...while) can be written.
  initial begin
    reg [2:0] i = 3'b000;    
    do begin 
      $display(&quot;i = %g&quot;, i);
      i++;
    end while (i !== 3'b000);
  end

Thanks!","do..while construct exists in system verilog and the soulution you showed works there. It does not work in plain verilog though.
For plain verilog you can use any programming trick to do so, i.e. use a flag:
  reg [2:0] i;
  reg flag;

  initial begin
    flag = 0;
    i = 0;
    while(flag == 0) begin
      $display(&quot;i = %g&quot;, i);
      i = i+1;
      if (i == 0) flag = 1;
    end
  end

you can unroll one iteration manually:
  initial begin
   i = 0;
   $display(&quot;i = %g&quot;, i);
   i = 1;
   while( i != 0) begin
      $display(&quot;i = %g&quot;, i);
      i = i+1;
    end
  end

you can use repeat:
  initial begin
    i = 0;
    repeat(8) begin
      $display(&quot;i = %g&quot;, i);
      i = i+1;
    end
  end

and so on.",,,,,
Can someone explain the control flow of modules in System Verilog,"I know how to link modules but could someone explain the flow of calling the modules to be used when I want it to be used.
Like have a state machine and depending on the state I can call a module to activate, or like if I need to repeat a process how to go back to a module earlier in a state machine.
again I get the instantiating part like this
  wire clk;
  wire sig;
  wire out;

  A a(clk, sig, topout);
 B b(clk, sig);
endmodule

but can someone explain how to call modules and how the control flow works in general for them?
(I am new to HDLs so I appreciate any help)","Verilog is a language specifically developed to simulate behavior of hardware. Hardware is a set of transistors and other elements which always statically presented and function in parallel. Functioning of such elements could be enabled or disabled, but the hardware is still present.
Verilog is similar to the hardware in the sense that all its elements are always present, intended for parallel functioning.
The basic functional elements of Verilog are gates, primitives and procedural blocks (i.e., always blocks). Those blocks are connected by wires.
All those elements are then grouped in modules. Modules are used to create logical partitioning of the hardware mode. They cannot be 'called'. They can be instantiated in a hierarchical manner to describe a logical structure of the model. They cannot be instantiated conditionally since they represent pieces of hardware. Different module instances are connected via wires to express hierarchical connectivity between lower-level elements.
There is one exception however, the contents of an always block is pure software. It describes an algorithmic behavior of it and as such, software flow constructs are allowed inside always block (specific considerations must be used to make it synthesizable).
As it comes to simulation, Verilog implements an event-driven simulation mode which is intended to mimic parallel execution of hardware. In other words, a Verilog low level primitive (gate or always block) is executed only if at least one of its inputs changes.
The only flow control which is usually used in such models is a sequence of input events and clocks. The latter are used to synchronize results of multiple parallel operations and to organize pipes or other sequential functions.
As I mentioned before, hardware elements can be enabled/disabled by different methods, so the only further control you can use by implementing such methods in your hardware description. For example, all hardware inside a particular module can be turned off by disabling clock signal which the module uses. There could be specific enable/disable signals on wires or in registers, and so on.
Now to your question: your code defines hierarchical instantiation of a couple of modules.
module top(out);
 output wire out;

 wire clk;
 wire sig;

 A a(clk, sig, out);
 B b(clk, sig);
endmodule 

Module 'top' (missing in your example) contains instances of two other modules, A and B.  A and B are module definitions. They are instantiated as corresponding instances 'a' and 'b'. The instances are connected by signals 'clk', which is probably a clock signal, some signal 'sig' which is probably an output of one of the modules and input in another. 'out' is output of module top, which is probably connected to another module or an element in a higher level of hierarchy, not shown here.
The flow control in some sense is defined by the input/output relation between modules 'A' and 'B'. For example:
module A(input clk, input sig, output out);
  assign out = sig;
  ...
endmodule

module B(input clk, output sig);
  always@(posedge clk) sig &lt;= some-new-value;
  ...
endmodule

However, in general it is defined by the input/output relation of the internal elements inside module (always blocks in the above example). input/output at the module port level is mostly used for semantic checking.
In the event-driven simulation it does not matter hardware of which module is executed first. However as soon as the value of the 'sig' changes in always@(posedge clk) of module 'B', simulation will cause hardware in module 'A' (the assign statement to be evaluated (or re-evaluated). This is the only way you can express a sequence in the flow at this level. Same as in hardware.",,,,,
What is the Open CL command that actually updates the FPGA of an accelerator card with the bitstream of a .xclbin file created in Vitis?,"What is the Open CL command that actually updates the FPGA of an accelerator card with the bitstream included within an .xclbin file created in Vitis with v++ --link -t hw ...?
Otherwise, what are all the possible methods to update the FPGA of an accelerator card with the bitstream included within the .xclbin file created in Vitis?
Thanks","cl::Program program(context, devices, bins)",,,,,
SystemVerilog disable cover property after hit,"I have a few cover property's that I expect to fire pretty frequently, and I'm seeing they are starting to impact my simulation performance because they are firing so frequently. I don't want to remove them because I want to make sure I am still hitting these properties, but I don't care how many times I hit them. Is there a way to disable the cover property after it's hit once so it won't hinder simulation performance?
B2BReq : cover property ( 
  @(posedge CLK iff !RESET)
  Intf.ReqValid ##1 Intf.ReqValid
);

I'm thinking of something like this:
bit cov_disable;
B2BReq : cover property ( 
  @(posedge CLK iff !RESET) disable iff(cov_disable)
  Intf.ReqValid ##1 Intf.ReqValid |=&gt; cov_disable = 1
);

But this is incorrect syntax. Is there a way to achieve something like this?","Some tools automatically disable a cover directive when it hits a certain limit. I know that in Questa, the default is disabling after 1 hit.
Also, you may get better performance modeling what you want with a simple implication
B2BReq : cover property ( 
  @(posedge CLK iff !RESET)
  Intf.ReqValid |-&gt; ##1 Intf.ReqValid;
);

BTW, the syntax you were looking for was
bit cov_disable;
B2BReq : cover property ( 
  @(posedge CLK iff !RESET) disable iff(cov_disable)
  Intf.ReqValid ##1 Intf.ReqValid |=&gt; (1,cov_disable = 1);
);
",,,,,
"Do you have any idea how I can make this code generate numbers only between 1 and 6, it generates between 1 and 7","entity LFSR is
  Port (   clk : in STD_LOGIC; 
           en: in STD_LOGIC; 
           reset: in STD_LOGIC;  
           output_lfsr: out STD_LOGIC_VECTOR(2 downto 0) 
           ); 
end LFSR;

architecture Behavioral of LFSR is
    signal lfsr : std_logic_vector(2 downto 0); 
    constant poly : std_logic_vector(2 downto 0) := &quot;011&quot;; 
    begin 
        process(clk, reset, lfsr)  
        variable ext_inbit: std_logic_vector(2 downto 0);
        variable inbit: std_logic;  
    begin 
        inbit:=lfsr(2);   -- preia valoarea iesirii Q2 
            for i in 0 to 2 loop    
        ext_inbit(i):=inbit; 
            end loop; 
        if (reset='1') then   
          lfsr&lt;=&quot;111&quot;;
        elsif (clk'event and clk='1') then 
            if(en='1') then   
                   lfsr&lt;=(lfsr(1 downto 0) &amp; '0') xor (ext_inbit and poly);  
                                 
            end if; 
        end if; 
    end process; 
    output_lfsr &lt;= lfsr;   
end Behavioral;
","This is a quick and dirty solution. There are ways to clean it up and pipeline it.
Do the operation once again if the value is 7.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity lfsr is
  port (clk         : in  std_logic;
        en          : in  std_logic;
        reset       : in  std_logic;
        output_lfsr : out std_logic_vector(2 downto 0)
        );
end lfsr;

architecture behavioral of lfsr is

  signal s_lfsr     : std_logic_vector(2 downto 0);
  constant poly     : std_logic_vector(2 downto 0) := &quot;011&quot;;

begin
  process(clk, reset)
    variable v_lfsr_int : std_logic_vector(2 downto 0);
    variable ext_inbit : std_logic_vector(2 downto 0);
    variable inbit     : std_logic;
  begin

    if (reset = '1') then
      s_lfsr &lt;= &quot;011&quot;;
    elsif (rising_edge(clk)) then
    
      inbit := s_lfsr(2);               -- preia valoarea iesirii Q2
      for i in 0 to 2 loop
        ext_inbit(i) := inbit;
      end loop;
      
      if(en = '1') then
        v_lfsr_int := (s_lfsr(1 downto 0) &amp; '0') xor (ext_inbit and poly);
        if(v_lfsr_int = &quot;111&quot;) then
          s_lfsr &lt;= (v_lfsr_int(1 downto 0) &amp; '0') xor (ext_inbit and poly);
        else
          s_lfsr &lt;= v_lfsr_int;
        end if;
      end if;
    end if;

  end process;

  output_lfsr &lt;= s_lfsr;

end behavioral;

As you can see, I've changed a few things as well:

Added ieee libraries
process sensitivity list updated for a asynchronous reset
rearranged the ext_inbit to avoid the tool shouting that the sensitivity list is incomplete. Considering that the value is same as lfsr(2) after elaboration, you can even put this outside the process.
signal name and entity name was the same. renamed to increase readability. Recheck the standard to see if it is allowed.
",,,,,
Expression width 32 does not match width 1 of logic gate array port 1,"I have two questions.

No output
Expression width 32 does not match width 1 of logic gate array port 1.

When I write and( OutAnd, a, b);, it shows an error.
Expression width 32 does not match width 1 of logic gate array port 1.

How can I fix it?
By the way. I forbid to use &amp; operator, Procedure Assignment, and always block.
Here's my code:
ALU.v
module ALU( 
  input [5:0] Signal, 
  input [31:0] a, b,
  output reg[31:0] Output
  );
  
  wire[31:0] OutAnd;
  
  and( OutAnd, a, b); // AND  &lt;-- error
  AluMux alumax0( .Signal(Signal), .in_And( OutAnd ) ); // AND
endmodule

AluMax.v
module AluMux(
  input [5:0] Signal,
  input [31:0] in_And, in_Or,
  output reg[31:0] Output
  );
  
  parameter AND = 6'd36;
  
  always @ ( * )
  begin
    case ( Signal )
        AND : Output = in_And;
         default : Output = 32'd11;
    endcase
  end
endmodule
","The output of the and gate defined to be 1 bit and you want to put 32 bits in it which may cause an error or a warning to solve this you have 2 way either instantiate 32 and gates with the following syntax
and u1 (OutAnd[0], a[0], b[0]);
and u1 (OutAnd[1], a[1], b[1]);
and u1 (OutAnd[2], a[2], b[2]);
.
.
.
and u1 (OutAnd[31], a[31], b[31]);

or use a generate statement here is a sample code
genvar i;

generate 

for(i = 0;i &lt; 32;i = i + 1) begin 

and u1(OutAnd[i], a[i], b[i]);


end

endgenerate

",,,,,
"Yosys -- compilation of .dot file suceeds, but viewer (xdot) can't preview it","I have two modules, each in sepparate verilog file. One file is double_shift_reg.v with the top module double_shift_reg:
`include &quot;./shift_reg.v&quot;

`default_nettype none

module double_shift_reg(clk, shi, in, out);

    input wire clk; // Clock
    input wire shi; // Shift enable
    input wire in; // Input information
    output wire out; // Output information

    wire d1; // Data 1
    wire d2; // Data 2

    shift_reg r1(.clk(clk), .rst(1'b0), .shi(shi), .in(in), .out(d1));
    shift_reg r2(.clk(clk), .rst(1'b0), .shi(shi), .in(in), .out(d2));

    assign out = d1 ^ d2;


    `ifdef FORMAL
        
        reg [2:0] f_counter;
        always @(posedge clk)
        begin
            assert(out == 0);
            f_counter = f_counter + 1;
            if (f_counter == 1'b1111)
                assume(shi);

        end

    `endif // FORMAL  

endmodule

The other file is a shift_reg.v with a module shift_reg that is used inside the top module:
`default_nettype none

module shift_reg(clk, rst, shi, in, out);

    input wire clk; // Input clock
    input wire rst; // Input reset
    input wire shi; // Shift enable
    input wire in; // Input information
    output wire out; // Output bit

    parameter wid = 8; // Shift register's width
    
    parameter ini = {{(wid - 1){1'b0}}, 1'b1}; // Shift register's initial state

    reg [(wid - 1):0] s_reg;
    initial s_reg = ini;

    always @(posedge clk)
    begin
        if(rst)
            s_reg &lt;= ini;
        else if(shi)
            s_reg[(wid - 1):0] &lt;= {in, s_reg[(wid - 1):1]};
    end

    assign out = s_reg[0];

endmodule

Then I try to create and preview a .dot file with:
yosys \
    -p &quot;read_verilog -sv -formal double_shift_reg.v&quot; \
    -p &quot;hierarchy -check -top double_shift_reg&quot; \
    -p &quot;proc&quot; \
    -p &quot;show -prefix $(file_main) -notitle -colors 2 -width -format dot&quot;
xdot $(file_main).dot

Compilation messages for the last part i.e. -p &quot;show -prefix $(file_main) -notitle -colors 2 -width -format dot&quot; looks like this:
-- Running command `show -prefix double_shift_reg -notitle -colors 2 -width -format dot' --

4. Generating Graphviz representation of design.
Writing dot description to `double_shift_reg.dot'.
Dumping module double_shift_reg to page 1.
Dumping module shift_reg to page 2.

Warnings: 1 unique messages, 1 total
End of script. Logfile hash: e53dd145db
CPU: user 0.02s system 0.01s, 

There is just one warning, no errors... But when I .dot is opened by previewer, I get an error:

This never happened when I was creating .dot files for only a single verilog file with a single module inside. Am I missing some crutial part?","I found a solution! I was missing one line that adds the library. This makefile target works:
dot:
    yosys \
        -p &quot;read_verilog -sv -formal $(file_main).v&quot; \
        -p &quot;read_verilog -lib +/ice40/cells_sim.v&quot; \
        -p &quot;hierarchy -check -top $(module_top)&quot; \
        -p &quot;proc&quot; \
        -p &quot;show -prefix $(file_main) -notitle -colors 2 -width -format dot&quot;
    xdot $(file_main).dot
",,,,,
when will be factory registration will happen for the uvm testcase included in the package,"For the testcase included in the test package, When will be  factory registration of UVM testcase will happen ? is during import ?","Importing packages is part of the compilation process before the execution of any code. UVM factory registration is tied to the initialization of static variables of parameterized classes at simulation time 0. (I have a DVCon paper going over the details of that).
But this issue you may be facing is that you have put your test cases in a SystemVerilog package and never imported that package. There are different approaches to handling this depending on which tools you are using, and the compilation process you are using.",,,,,
defparam for array of modules in verilog,"I am trying to implement a parametrized special purpose memory with an array of my own defined register.
my_register:
module my_register(clk,
                   data_in,
                   write_enable,
                   equal);

parameter WORD_SIZE = 4;

input                           clk;
input       [WORD_SIZE - 1 : 0] data_in;
input                           write_enable;
output                          equal;

reg [WORD_SIZE - 1 : 0] register;

always @(posedge clk) begin
     if (write_enable)
         register = data_in;
end

assign equal = data_in ^ register;
endmodule

in the top module I have:
module my_memory(clk,
                 data_in,
                 write_enable, 
                 matches);

parameter MY_WORD_SIZE = 8;

input                                           clk;
input  [WORD_SIZE - 1 : 0]                      data_in;
input  [(2'b1 &lt;&lt; MEMORY_ADDRESS_WIDTH) - 1 : 0] write_enable;
output [(2'b1 &lt;&lt; MEMORY_ADDRESS_WIDTH) - 1 : 0] matches;

my_register memory [(2'b1 &lt;&lt; MEMORY_ADDRESS_WIDTH) - 1 : 0] (clk, data_in, write_enable, matches);
endmodule

but the problem is I can't override the parameter WORD_SIZE of my_register in the top module.
I tried:
defparam memory.WORD_SIZE = MY_WORD_SIZE;

but this does't work and gives an error:

WORD_SIZE is not declared under prefix memory

Is there a way to override the parameter of an array of custom modules?
thanks in advance","You cannot use defparam to override an array of instances in one statement. You would have to repeat the defparam for each instance. But there is no need to use defparam statements in Verilog-2001 or SystemVerilog. You can pass parameters inline with instantiating statement.
module my_memory #(parameter MY_WORD_SIZE = 8) ( 
input                                           clk,
input  [WORD_SIZE - 1 : 0]                      data_in,
input  [(2'b1 &lt;&lt; MEMORY_ADDRESS_WIDTH) - 1 : 0] write_enable,
output [(2'b1 &lt;&lt; MEMORY_ADDRESS_WIDTH) - 1 : 0] matches
);

my_register #(.WORD_SIZE(MY_WORD_SIZE))
     memory [(2'b1 &lt;&lt; MEMORY_ADDRESS_WIDTH) - 1 : 0] (clk, data_in, write_enable, matches);
endmodule
",,,,,
How to randomize 1 of 100 variables,"Let's say we have a class with a bunch of random variables (around 100 rand variables). Now, I want to randomize only one of the variables from that class and the rest of the variables should be the same. How do I do that?
class rand_var extends vmm_data;
    rand bit abc;
    rand bit [3:0] cde;
    rand bit en;
    ...
endclass

Now from one of the task, I want to randomize abc only, not any other variables of rand_var.
task custom_task();
    rand_var rand1;
    rand1 = new config

    if (config.randomize () with {

    }) 
    else $display(&quot;randomization failed&quot;);
","The easiest way of randomizing a single variable is using the std::randomize instead of the randomize method of the class.
task custom_task();
    rand_var config;
    config = new();

    if (std::randomize(config.abc) with {
    /* constraints on config.abc */
    }) 
    else $display(&quot;randomization failed&quot;);

You can also use what's called in-line randomization control when calling the class randomize method as in
if (!config.randomize(abc)) $display(&quot;randomization failed&quot;);

But you have to be careful when doing it this way because all of the active class constraints in the config object must still be satisfied, even on variables not being randomized.",,,,,
What is best way to call another module?,"I'm confused about connection, I want to use ALU to call RippleCarry module, and I need to do branch without always block and Procedure Assignment.
I don't know what method is best. I see others have written in TestBench.v or ALU.v.
Here's my code.
ALU.v
module ALU( Signal, a, b, Output );
  input [31:0] a, b;
  input [5:0] Signal; 
 
  output [31:0] Output;
 
  //  write here ? or write into test bench?
  // if Signal is 6'd35, do RippleCarry.

  /*RippleCarry RC( .a(a), .b(b), .Sum(Output) ); */

endmodule

RippleCarray.v
module RippleCarry(
  input  [31:0] a, b,
  input Cin,
  output Cout,
  output [31:0] Sum
);
  
","In verilog, modules are not called, but instantiated. Unlike traditional programming, verilog is a hardware descriptive language; meaning it is code describing hardware, not specifying instructions to be run by a cpu as you do in typically programming languages. Hardware doesn't materialize and dematerialize when signals take on different values; the control signals simply define which of many different data paths is connected between input and output.
In your case, you wouldnt write something like this:
module ALU(...)
  if (Signal == 6'd35) begin
    RippleCarry RC(...);
  end
endmodule

Since Signal is a control line that changes value as the hardware runs, this would imply the ripple carry adder exists when the Signal is 35 and disappears when it's not.
Instead, the adder should be instantiated, it exists in the design and it always there. The problem now is to direct it's output to the output of the ALU only when Signal is 35.
module ALU(input [5:0] Signal,
  input [31:0] a, b,
  output reg [31:0] Output); // Note, I made Output a reg so I can use always, it doesn't mean it's actually a register

  wire [31:0] rcOutput;

  // Instantiate the RC adder so it exists in the hardware
  RippleCarry RC(.a(a), .b(b), .Sum(rcOutput));

  // Direct the output of the RippleCarry adder to the output only when signal is 35, otherwise just leave it at 0.
  // Use switch here to make it easy to add more operations later
  always @(*) begin
    Output = 32'd0; // default

    case (Signal)
      6'd35: Output = rcOutput; // rc add
    endcase
  end
endmodule

Edit: I see now you want to do it without using always or assign, which doesn't change the fundamental design but makes it more obscure and less scalable, which is why I'm leaving the above as a reference. In the case we only have one op code for signal, we can simply implement the logic that compares signal to 35 and masks output if not equal in gates:
// Replace the always block with the below, though it's certainly not as nice, it's a possible implementation of that always block in gates
wire [5:0] SignalN;
wire SignalIs35;
not g1[5:0](SignalN, Signal);
// 35 is 100011 in binary, so see if Signal is that value
and g2(SignalIs35, Signal[5], SignalN[4], SignalN[3], SignalN[2], Signal[1], Signal[0]);
and g3[31:0](Output, rcOutput, {32{SignalIs35}});
",,,,,
Precedence of initialized port/signal assigned to port in VHDL,"I have a question regarding initialization in VHDL. If I have an entity output port that is initialized to a certain value, but is assigned to a signal that is initialized to a different value, what initial value will the output assume. I mean a situation like the following:
entity TEST_ENTITY is
    Port (port0    : out    STD_LOGIC    := '0');
end TEST_ENTITY;

architecture Behavioral of TEST_ENTITY is
    signal signal0    : STD_LOGIC    := '1';

begin

    port0    &lt;= signal0;
end Behavioral;

I would assume that the initialization value of the signal will take precedence. Is this correct?","There is no precedence here. Signal assignments take at least one delta cycle to pass. So at time 0, port0 will be '0' and signal0 will be '1'. Port0 will become '1' after 1 delta cycle has elapsed.",,,,,
ModelSim: Intel On-Chip Flash IP: Error: (vsim-3033) Instantiation of 'altera_onchip_flash_block' failed,"I am getting this vsim error when I'm trying to use an Intel On-Chip Flash IP generated by Quartus. There's an altera_onchip_flash_block.v file in the submodules/rtl folder but it's only hex numbers in it so it's not compilable by ModelSim.
#    Time: 0 ps  Iteration: 0  Instance: /ufm_testbench/ufm_inst/flash/onchip_flash_0 File: ../../FFB900_UFM/verilog/altera_onchip_flash.v Line: 309
#         Searched libraries:
(all my libraries)

The altera_onchip_flash_block gets instantiated in the altera_onchip_flash.v as seen above.
When I'm only compiling the IP it's working but when I'm using it from my Top-Level testbench I always get this error. I am using VHDL in all my files, except the verilog files generated by quartus.
Any help is appreciated.","As you already realized, this is a precompiled IP-Core. Normally these precompiled IP-Cores come with files for simulation.
This pdf includes a step-by-step tutorial to instantiate the IP-Core and generate simulation files with Quartus (on page 12 of 36 or section 4-2).",,,,,
"<Verilog> May I know why EQ=1, but the output no response?","I am trying to build a Finite State Machine vending machine which consists of Datapath Unit and Control Unit. The attached links is the Control unit which consists the input of EQ(Equal), GT(Greater) and product. When product is &quot;1&quot; and either EQ or GT is &quot;1&quot;, the output will be out=product. However, in my problem, the verilog code shows correct for GT but not EQ. It seem that the output cannot response to EQ when it is high.
My design of the state diagram.  State Diagram
My Verilog code. Verilog code
The result. Result Waveform
module dispense(
  input [1:0] product,
  input GT, EQ, rst, clk,
  output [1:0] out,
  output reg done,
  output R
  );
  reg [1:0] ps,ns; //Present State and Next State
  assign R=EQ||GT;
  //State encoding
  parameter [1:0] S0=2'b00, S1=2'b01, S2=2'b10;
  //Verilog segment Next State logic and Output logic
  always @*
    begin
     //out=0;
     done=0;
     case(ps)
       S0: if(product&gt;0) ns=S1; else ns=S0; 
        S1: if(R) ns=S2; else ns=S1;
        S2: begin  done=1; ns=S0; end
        endcase
      end
        //out=product;
    
    assign out = (done==1)?product:0;

    //State Register
    always@(posedge clk)
        if (!rst) ps=S0;
        else ps=ns;
endmodule
","The answer is very simple. Add ps and ns to your simulation charts and you will understand why.
At the beginning of your simulation you are in state S0. When the product is bigger than 0 (first yellow mark) you go to state S1. Then you are waiting for EQ or GT, but EQ fall down one clock cycle ago so next GT arrive.
Set EQ and GT one clock cycle later.",,,,,
Initializing matrix in VHDL takes enormous number of blocks of type logic cell,"I'm trying to build a little game in VHDL and, therefore, I need to use two matrices of std_logic elements. Here is how I initialized my two matrices :
type matrix_type is array (0 to 7) of std_logic_vector(7 downto 0);

shared variable matrix : matrix_type := (
    others =&gt; (others =&gt; '0')
);

shared variable frozen : matrix_type := (
    others =&gt; (others =&gt; '0')
);

But this takes A HUGE amount of blocks of logic cell to be done. Without doing this, I am only using 75/160 logic elements, while when I am doing this, I'm using 207/160 logic elements! Quartus can't even compile this code because of the amount of logic elements that are used.
Why is this so? How is that possible that initializing such matrices needs so many logic elements? Do you have a solution to use less of them, or to initialize them another way?
Thank you!","Because probably you are using slices of the fpga to store the initial value.
The best way to do store values on a fpga is use a block ram. You can infer it with vhdl code or create the memory with the fpga vendor tool and connect it.",,,,,
SystemVerilog hierarchical reference in nonblocking assigment,"I'm seeing strange behavior in my testbench where a nonblocking assignment is acting as a continuous assignment instead of outputting the RHS delayed by one cycle.
My testbench binds a module &quot;cov&quot; to the DUT at cpu.cache via bind cache cov cov_top, and inside the &quot;cov&quot; module I have this nonblocking assignment:
module cov
  import cachePkg::*;
(
  input logic clk,
  input logic rst
);
  clocking cclk @(posedge clk iff !rst); endclocking

  logic [1:0] LinkState_d1, LinkState_d2;
  always @(cclk) begin
    LinkState_d1 &lt;= cache.cntrl.LinkState;
    LinkState_d2 &lt;= LinkState_d1;
  end
endmodule

And the cache.cntrl.LinkState in the DUT is the output of a nonblocking assignment, so I would expect LinkState_d1 to simply follow LinkState from the DUT just delayed by one cycle. However in the waveform viewer I see LinkState_d1 is exactly matching LinkState as if it were a continuous assignment, here's the clock diagram of what I'm seeing in the waveform:
             __    __    __
clk       __|  |__|  |__|  |__
                   ________
LinkState    _____|
                   ________
LinkState_d1 _____|
                         __
LinkState_d2 ___________|

Is there something different that happens when we use a hierarchical reference in the RHS of a continuous assignment? Or is this just a simulator bug? I'm using questasim 2019.4","Your edited question is very different from the original. The problem is you are using different clocks. It has nothing to do with hierarchical references or that you are using an NBA statement in the module cov.
The clocking block event cclk gets scheduled in the observed region, which is presumably after cache.cntrl.LinkState gets updated with its new value.
You should not mix clocking blocks with signals from outside the clocking block. Either stop using the clocking block, or move everything inside it.
logic [1:0] LinkState_d1, LinkState_d2;

clocking cclk @(posedge clk iff !rst); 
  input LinkState = cache.cntrl.LinkState;
  inout LinkState_d1l
  output LinkState_d2;
endclocking

  always @(cclk) begin
    cclk.LinkState_d1 &lt;= cclk.LinkState;
    cclk.LinkState_d2 &lt;= cclk.LinkState_d1;
  end
endmodule
",,,,,
How do i make a synthesizable parameterized encoder on Verilog?,"I have tried to do it this way:
module encoder 
#(
    parameter WIDTH = 4
 )
(
    input wire [WIDTH-1: 0] in,
    output reg [$clog2(WIDTH)-1: 0] out
);

  genvar i; 
  generate
    for (i = 0;i &lt; WIDTH;i = i+1) 
    begin :gen_block
      always @* 
      begin
        if (in[i]==1'b1) 
          out = i;
      end
    end
  endgenerate
endmodule


It works well in the simulation, but I'm not sure if this can be synthesized. The generate block will produce multiple copies of the always block, and I'm guessing there will be a race condition between the previous value of out and the updated value of out.
Am I correct about assuming that this code can't be synthesized? If so, What do I change to make it synthesize correctly?","Yes, you do have a race condition in simulation and it is not synthesizable. You cannot have multiple always blocks making assignments to the same variable in parallel( happens when more than one bit in in is set). You want a regular procedural-for loop, not a generate-for loop.
module encoder 
#(
    parameter WIDTH = 4
 )
(
    input wire [WIDTH-1: 0] in,
    output logic [$clog2(WIDTH)-1: 0] out
);
      always_comb begin
        out = 'x; // don't care if no 'in' bits set
        for (int i = 0;i &lt; WIDTH;i++)
            if (in[i]==1'b1) begin
               out = i;
               break; // priority goes from LSB-to-MSB
        end
    end
endmodule

Edit:
For tools that do not support break yet
always_comb begin
        bit Break;
        Break = 0;
        out = 'x; // don't care if no 'in' bits set
        for (int i = 0;i &lt; WIDTH;i++)
            if (in[i]==1'b1 &amp;&amp; !Break) begin
               out = i;
               Break = 1;
        end
    end
",,,,,
chart speed labview FPGA reading signal,"Im reading a sine wave from a wave generator with a Labview FPGA code, when the frequency is around 1Hz, this is what I read (as expected)

However when I increase the frequency, this happens.

I see that the ticking speed does not change, so I think it would be solved if it accelerated just as much as I needed to match my sine wave. Also, I passed the data through a FIFO and to a .txt file that I then plotted and I cant see the sine wave either, so its not only a problem of the chart display.
How can I control this?
PS. I checked my hardware and it supports 50 MS/s, so it should not be a problem to nicely read a 10 Hz sine wave. In particular, Im using the NI 5751 ADC, FPGA 7951R, PXI 1071 chassis.
This is the code
","You are seeing Aliasing of the data being presented in your waveform.
In this case it is due to a significant under-sample rate of the data that is being passed up to your waveform.
As @Kerghan mentioned, the primary issue here appears to be that your data rate for grabbing is not correctly related for the data sampling you are trying to see.
I would suggest that if you are trying to see a 10 Hz waveform you should be using a minimum display rate of 20 Hz ( 50000 uS ).
As an aside, you have fallen into a traditional LabVIEW trap for developers coming from text based languages. I would recommend that you remove the Flat Sequence Structure from the code, as this is enforcing the following logic:

Wait X uS of time
THEN read data from the AI
If the time taken to read the data and write to the DMA is non-zero, your timing will be off by just the slightest amount and it will be very hard to tell why.
",,,,,
VHDL RGB to YUV444 implementation mismatch,"The design
I'm trying to implement a RGB to YUV444 conversion algorithm in hardware based in the next approximation I've got working in a C based program:
#define CLIP(X) ( (X) &gt; 255 ? 255 : (X) &lt; 0 ? 0 : X)
#define RGB2Y(R, G, B) CLIP(( (  66 * (R) + 129 * (G) +  25 * (B) + 128) &gt;&gt; 8) +  16)
#define RGB2U(R, G, B) CLIP(( ( -38 * (R) -  74 * (G) + 112 * (B) + 128) &gt;&gt; 8) + 128)
#define RGB2V(R, G, B) CLIP(( ( 112 * (R) -  94 * (G) -  18 * (B) + 128) &gt;&gt; 8) + 128)

Simulation/verification done so far
I simulated and verified the VHDL code  using a self-checking approach. I compared the VHDL output against a 'golden' reference YUV444 values generated by the know working C algorithm using several images and all simulations run successfully.
The problem
When I implemented it in hardware and inserted within a video pipeline, the video output looks fine in terms of sync and there are not obvious issues in the frame rate, flickering...etc but the problem is that the colours are not right, there's a magenta/purple cast, e.g. yellow will look light magenta and red a bit darker...etc
I'm thinking that it is likely that the UV values are clipped/saturated and Y (luminance) works fine and this is what I'm seeing in the resulting video.
The code
Please note that for simplicity I only posted the part which is doing the conversion and the relevant signal declaration types and function. The rest of the code is just a axi video stream signal wrapper which works well in terms of video synchronisation and there are not video issues in that sense, let me know if you think it would be helpful and I'll post it too.
--Functions:
  -- Absolute operation of: &quot;op1 - op2 + op3&quot; for the UV components
  function uv_op_abs(op1 : unsigned(15 downto 0); op2 : unsigned(15 downto 0); op3 : unsigned(15 downto 0))
  return unsigned is
    variable res1 : unsigned(15 downto 0);
  begin
    if op2 &gt; op1 then
      res1 := (op2 - op1);
      if res1 &gt; op3 then
        return res1 - op3;
      else 
        return op3 - res1;
      end if;
    else
      return (op1 - op2) + op3;
    end if;
  end uv_op_abs;

 function clip(mult_in : unsigned(15 downto 0))
  return unsigned is
  begin
    if to_integer(unsigned(mult_in)) &gt; 240 then
      return unsigned(to_unsigned(240,8));
    else
      return unsigned(mult_in(7 downto 0));
    end if;
  end clip;

-- Signals/Constants declarations:
  --Constants
  constant coeff_0 : unsigned(7 downto 0) := &quot;01000010&quot;;  --66
  constant coeff_1 : unsigned(7 downto 0) := &quot;10000001&quot;;  --129  
  constant coeff_2 : unsigned(7 downto 0) := &quot;00011001&quot;;  --25 
  constant coeff_3 : unsigned(7 downto 0) := &quot;00100110&quot;;  --38
  constant coeff_4 : unsigned(7 downto 0) := &quot;01001010&quot;;  --74
  constant coeff_5 : unsigned(7 downto 0) := &quot;01110000&quot;;  --112
  constant coeff_6 : unsigned(7 downto 0) := &quot;01011110&quot;;  --94
  constant coeff_7 : unsigned(7 downto 0) := &quot;00010010&quot;;  --18
  constant coeff_8 : unsigned(7 downto 0) := &quot;10000000&quot;;  --128
  constant coeff_9 : unsigned(7 downto 0) := &quot;00010000&quot;;  --16

  --Pipeline registers
  signal red_reg : unsigned(7 downto 0);
  signal green_reg : unsigned(7 downto 0);
  signal blue_reg : unsigned(7 downto 0);

  signal y_red_reg_op1 : unsigned(15 downto 0);
  signal y_green_reg_op1 : unsigned(15 downto 0);
  signal y_blue_reg_op1 : unsigned(15 downto 0);

  signal u_red_reg_op1 : unsigned(15 downto 0);
  signal u_green_reg_op1 : unsigned(15 downto 0);
  signal u_blue_reg_op1 : unsigned(15 downto 0);

  signal v_red_reg_op1 : unsigned(15 downto 0);
  signal v_green_reg_op1 : unsigned(15 downto 0);
  signal v_blue_reg_op1 : unsigned(15 downto 0);

  signal y_reg_op2 : unsigned(15 downto 0);
  signal u_reg_op2 : unsigned(15 downto 0);
  signal v_reg_op2 : unsigned(15 downto 0);

  signal y_reg_op3 : unsigned(7 downto 0);
  signal u_reg_op3 : unsigned(7 downto 0);
  signal v_reg_op3 : unsigned(7 downto 0);

-- The process for YUV444 conversion:
  RGB_YUV_PROC : process(clk)
  begin
    if rising_edge(clk) then
      if rst = '1' then
        red_reg &lt;= (others =&gt; '0');
        green_reg &lt;= (others =&gt; '0');
        blue_reg &lt;= (others =&gt; '0');
        y_red_reg_op1 &lt;= (others =&gt; '0');
        y_green_reg_op1 &lt;= (others =&gt; '0');
        y_blue_reg_op1 &lt;= (others =&gt; '0');
        u_red_reg_op1 &lt;= (others =&gt; '0');
        u_green_reg_op1 &lt;= (others =&gt; '0');
        u_blue_reg_op1 &lt;= (others =&gt; '0');
        v_red_reg_op1 &lt;= (others =&gt; '0');
        v_green_reg_op1 &lt;= (others =&gt; '0');
        v_blue_reg_op1 &lt;= (others =&gt; '0');
        y_reg_op2 &lt;= (others =&gt; '0');
        u_reg_op2 &lt;= (others =&gt; '0');
        v_reg_op2 &lt;= (others =&gt; '0');
        y_reg_op3 &lt;= (others =&gt; '0');
        u_reg_op3 &lt;= (others =&gt; '0');
        v_reg_op3 &lt;= (others =&gt; '0');
        yuv444_out &lt;= (others =&gt; '0');
        soff_sync &lt;= '0';
      else

        --Sync with first video frame with the tuser (sof) input signal
        if rgb_sof_in = '1' then
          soff_sync &lt;= '1';
        end if;

        --Fetch a pixel
        if (rgb_sof_in = '1' or soff_sync = '1') and rgb_valid_in = '1' and yuv444_ready_out = '1' and bypass = '0' then
          green_reg &lt;= unsigned(rgb_in(7 downto 0));
          blue_reg &lt;= unsigned(rgb_in(15 downto 8));
          red_reg &lt;= unsigned(rgb_in(23 downto 16));
        end if;

        -- RGB to YUV conversion
        -- Y--&gt; CLIP(( (  66 * (R) + 129 * (G) +  25 * (B) + 128) &gt;&gt; 8) +  16)
        -- U--&gt; CLIP(( ( -38 * (R) -  74 * (G) + 112 * (B) + 128) &gt;&gt; 8) + 128)
        -- V--&gt; CLIP(( ( 112 * (R) -  94 * (G) -  18 * (B) + 128) &gt;&gt; 8) + 128)
        if (rgb_sof_in = '1' or soff_sync = '1') and (valid_delay = '1' or validff1 = '1') and yuv444_ready_out = '1' and bypass = '0' then
          --Y calc (  66 * (R) + 129 * (G) +  25 * (B) + 128) &gt;&gt; 8) +  16)
          y_red_reg_op1 &lt;= coeff_0 * red_reg;
          y_green_reg_op1 &lt;= coeff_1 * green_reg;
          y_blue_reg_op1 &lt;= coeff_2 * blue_reg; 
          y_reg_op2 &lt;=  y_red_reg_op1 + y_green_reg_op1 + y_blue_reg_op1 + (X&quot;00&quot; &amp; coeff_8);
          y_reg_op3 &lt;= (y_reg_op2(15 downto 8) + coeff_9);

          --U calc ( -38 * (R) -  74 * (G) + 112 * (B) + 128) &gt;&gt; 8) + 128)
          u_red_reg_op1 &lt;= coeff_3 * red_reg;
          u_green_reg_op1 &lt;= coeff_4 * green_reg;
          u_blue_reg_op1 &lt;= coeff_5 * blue_reg;
          u_reg_op2 &lt;= uv_op_abs(u_blue_reg_op1, (u_red_reg_op1 + u_green_reg_op1), (X&quot;00&quot; &amp; coeff_8));
          u_reg_op3 &lt;= (u_reg_op2(15 downto 8) + coeff_8);

          --V calc ( 112 * (R) -  94 * (G) -  18 * (B) + 128) &gt;&gt; 8) + 128)
          v_red_reg_op1 &lt;= coeff_5 * red_reg;
          v_green_reg_op1 &lt;= coeff_6 * green_reg;
          v_blue_reg_op1 &lt;= coeff_7 * blue_reg;
          v_reg_op2 &lt;= uv_op_abs(v_red_reg_op1, (v_blue_reg_op1 + v_green_reg_op1), (X&quot;00&quot; &amp; coeff_8));
          v_reg_op3 &lt;= (v_reg_op2(15 downto 8) + coeff_8);

          --Output data
          yuv444_out &lt;= std_logic_vector(v_reg_op3) &amp; std_logic_vector(u_reg_op3) &amp; std_logic_vector(y_reg_op3);
        elsif yuv444_ready_out = '1' and rgb_valid_in = '1' and bypass = '1' then
          yuv444_out &lt;= rgb_in;
        end if;

      end if;
    end if;
  end process; -- RGB_YUV_PROC

I've also tried adding the 'clip; function to control overflow thinking that it'll help to the the synthesis tool in case of 'clipping' but it didn't help, the issue persists:
if (rgb_sof_in = '1' or soff_sync = '1') and (valid_delay = '1' or validff1 = '1') and yuv444_ready_out = '1' and bypass = '0' then
  --Y calc (  66 * (R) + 129 * (G) +  25 * (B) + 128) &gt;&gt; 8) +  16)
  y_red_reg_op1 &lt;= coeff_0 * red_reg;
  y_green_reg_op1 &lt;= coeff_1 * green_reg;
  y_blue_reg_op1 &lt;= coeff_2 * blue_reg; 
  y_reg_op2 &lt;=  y_red_reg_op1 + y_green_reg_op1 + y_blue_reg_op1 + (X&quot;00&quot; &amp; coeff_8);
  y_reg_op3 &lt;= clip( X&quot;00&quot; &amp; (y_reg_op2(15 downto 8) + coeff_9));

  --U calc ( -38 * (R) -  74 * (G) + 112 * (B) + 128) &gt;&gt; 8) + 128)
  u_red_reg_op1 &lt;= coeff_3 * red_reg;
  u_green_reg_op1 &lt;= coeff_4 * green_reg;
  u_blue_reg_op1 &lt;= coeff_5 * blue_reg;
  u_reg_op2 &lt;= uv_op_abs(u_blue_reg_op1, (u_red_reg_op1 + u_green_reg_op1), (X&quot;00&quot; &amp; coeff_8));
  u_reg_op3 &lt;= clip( X&quot;00&quot; &amp; (u_reg_op2(15 downto 8) + coeff_8));

  --V calc ( 112 * (R) -  94 * (G) -  18 * (B) + 128) &gt;&gt; 8) + 128)
  v_red_reg_op1 &lt;= coeff_5 * red_reg;
  v_green_reg_op1 &lt;= coeff_6 * green_reg;
  v_blue_reg_op1 &lt;= coeff_7 * blue_reg;
  v_reg_op2 &lt;= uv_op_abs(v_red_reg_op1, (v_blue_reg_op1 + v_green_reg_op1), (X&quot;00&quot; &amp; coeff_8));
  v_reg_op3 &lt;= clip( X&quot;00&quot;&amp; (v_reg_op2(15 downto 8) + coeff_8));

Question
I'm aware that in hardware design a successful simulation doesn't necessarily mean that the the design is going to work in the same way after synthesis and I'm sure there are lots of things can be improved in the code. There's something fundamentally wrong in this approach but I can't see it so far, does anyone have an idea what could be wrong and why?","First things first: check if you're using YUV or YCbCr. Those are often confused and not the same!!! Don't mix them.
Then I see:
#define CLIP(X) ( (X) &gt; 255 ? 255 : (X) &lt; 0 ? 0 : X)

and
function clip(mult_in : unsigned(15 downto 0))
  return unsigned is
  begin
    if to_integer(unsigned(mult_in)) &gt; 240 then
      return unsigned(to_unsigned(240,8));
    else
      return unsigned(mult_in(7 downto 0));
    end if;
  end clip;

Those are very different functions. The first uses a signed data type and clips between 255 and 0 and the second one only clips 240 positive, and possible arithmetic overflow due to subtraction will not be handled properly. For some reason you're using unsigned arithmetic throughout the code! (Why? What's wrong with signed?)
So you're already comparing apples with oranges.
Next it seems you are using a absolute function?! Why? That's not part of the original code at all. That will of course produce artifacts. You cant just flip the sign on negative values and expect them to be correct?
Also, please use proper naming. A constant value of 16 should not be named coeff_9. Makes the code hard to read and maintain. If you want flexibility, use a different structure altogether. A name like coeff_X tells you nothing: sure it's probably a coefficient, but what's it used for and such.
Actually, you can just write (note, I will already assume signed arithmetic)
y_red_reg_op1 &lt;= red_reg * to_signed(66, 8);

or, because red_reg'length is already 8, even
y_red_reg_op1 &lt;= red_reg * 66;

which is much easier to read
Then the code can become something like (again assuming you will be using signed)
  --U calc (( -38 * (R) -  74 * (G) + 112 * (B) + 128) &gt;&gt; 8) + 128)
  u_red_reg_op1 &lt;= -38 * red_reg;
  u_green_reg_op1 &lt;= 74 * green_reg;
  u_blue_reg_op1 &lt;= 112 * blue_reg;
  u_reg_op2 &lt;= u_red_reg_op1 - u_green_reg_op1 + u_blue_reg_op1 + 128;
  u_reg_op3 &lt;= clip(shift_right(u_reg_op2, 8) + 128);

and clip should of course be
function clip(value : signed(15 downto 0))
  return signed is
begin
  if value &gt; 255 then
    return to_signed(255, 8);
  elsif value &lt; 0 then
    return to_signed(0, 8);
  else
    return value;
  end if;
end clip;

p.s. I'm hoping you're using numeric_std.
If all of this still produces artifacts, check if you haven't mixed up the RGB or YCbCr signal component order. That's a common mistake.
Final p.s. VHDL actually has a fixed-point library, with saturation logic. And it is supported by the big FPGA manufacturers. You could even consider using that to write a 'better' solution then the C one.
edit: I just read wikipedia and the whole algorithm doesn't require clipping or abs or any of that at all.

Basic transform from 8-bit RGB to 16-bit values (Yâ€? unsigned, U/V: signed, matrix values got rounded so that the later-on desired Yâ€²UV range of each [0..255] is reached whilst no overflow can happen):
Scale down (&quot;&gt;&gt;8&quot;) to 8-bit values with rounding (&quot;+128&quot;) (Yâ€? unsigned, U/V: signed):
Add an offset to the values to eliminate any negative values (all results are 8-bit unsigned):

you should implement your algo's likewise
Will probably become something like
  --U calc ((- 38 * (R) -  74 * (G) + 112 * (B) + 128) &gt;&gt; 8) + 128)
  u_red_reg_op1 &lt;= -38 * red_reg; -- 16 bit signed
  u_green_reg_op1 &lt;= -74 * green_reg; -- 16 bit signed
  u_blue_reg_op1 &lt;= 112 * blue_reg; -- 16 bit signed
  u_reg_op2 &lt;= u_red_reg_op1 + u_green_reg_op1 + u_blue_reg_op1 + 128; -- 16 bit signed
  u_reg_op3 &lt;= unsigned(resize(shift_right(u_reg_op2, 8), 8) + 128); -- 8 bit unsigned

(CHECK!)
And last be not least: you need better testbenches, that confirm the results of the 'golden' source with the output of your implementation.",,,,,
is there any way to edit an inout port without using assign?,"My goal is to implement a module that has an inout port, the description of this module is behavioral, to implement this module, my teacher said, I should not use the assign command.
So is there any way to edit an inout port without using assign?
This is my code :
module DRAM(addr,rw,data);

parameter N=8;
parameter M=8;


input rw;
input [N-1:0] addr;
inout [M-1:0] data;


reg [M-1:0] data;
reg [M-1:0] loc_data [512:0];


always @(*)
 begin

 if(rw)
  begin
   loc_data[addr]=data;
  end
 else if(!rw) 
 begin
  data=loc_data[addr]; //this is my problem.

 end 
 else
 begin
 end
end

endmodule
","If you simply need to avoid the assign keyword, you can use a wire declaration assignment instead.
module DRAM#(parameter N=8,M=8) (
    input         rw,
    input [N-1:0] addr,
    inout [M-1:0] .data(data_w)
);

reg  [M-1:0] data_r;
wire [M-1:0] data_w = rw ? {M{1'bz}} : data_r;
reg  [M-1:0] loc_data [512:0];

always @(*)
 if(rw)
   loc_data[addr]=data_w;
 else if(!rw) 
  data_r=loc_data[addr];
 
endmodule
",,,,,
How do I fix â€œLatches may be generated from incomplete case or if statementsâ€?messages in a case-when?,"Please Help me
I was trying to do ALU for 4 bit with selector.
I'm getting errors like this:

**WARNING:Xst:737 - Found 1-bit latch for signal &lt;Z&lt;1&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.


WARNING:Xst:737 - Found 1-bit latch for signal &lt;Z&lt;0&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.


WARNING:Xst:737 - Found 1-bit latch for signal &lt;Znot&lt;3&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.


WARNING:Xst:737 - Found 1-bit latch for signal &lt;Znot&lt;2&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.


WARNING:Xst:737 - Found 1-bit latch for signal &lt;Znot&lt;1&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.


WARNING:Xst:737 - Found 1-bit latch for signal &lt;Znot&lt;0&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.


WARNING:Xst:737 - Found 1-bit latch for signal &lt;Z&lt;2&gt;&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.**

I wrote this code:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Multiplexor is
    Port ( A, B, C, D : in  STD_LOGIC;
           S : in  STD_LOGIC_VECTOR (2 downto 0);
           Z : out  STD_LOGIC_VECTOR (2 downto 0);
           Znot : out  STD_LOGIC_VECTOR (3 downto 0));
end Multiplexor;

architecture tabla of Multiplexor is

begin

process(S, A, B, C, D)

begin

   case (S) is 
      when &quot;000&quot; =&gt; --Suma--
         Z(2) &lt;= ((A and C) or (B and C and D) or (A and B and D));
            Z(1) &lt;= (((not(A))and (not (B))and C) or ((not(A)) and C and (not(D))) or (A and (not (B)) and (not (C))) or (A and (not (C)) and (not (D))) or ((not (A)) and B and (not (C)) and D) or (A and B and C and D));
            Z(0) &lt;= (((not(B)) and D) or (B and (not(D))));
      when &quot;001&quot; =&gt; --Resta--
         Z(2) &lt;= (((not(A)) and C) or ((not(A)) and C and D) or (A and (not(C)) and (not(D))) or (A and B and (not(C))));
            Z(1) &lt;= (((not(A)) and (not(B)) and C) or ((not(A)) and C and D) or (A and (not(C)) and (not(D))) or (A and B and (not(C))));
            Z(0) &lt;= (((not(B)) and D) or (B and (not(D))));
      when &quot;010&quot; =&gt; --ComparaciÃ³n--
         Z(2) &lt;= (((not(A)) and C) or ((not(A)) and (not(B)) and D) or ((not(B)) and C and D));
            Z(1) &lt;= ((A and (not(C))) or (B and (not(C)) and (not(D))) or (A and B and (not(D))));
            Z(0) &lt;= (((not(A)) and (not(B)) and (not(C)) and (not(D))) or ((not(A)) and B and (not(C)) and D) or (A and (not(B)) and C and (not(D))) or (A and B and C and D));
      when &quot;011&quot; =&gt; --AND--
         Z(2) &lt;= '0';
            Z(1) &lt;= (A and C);
            Z(0) &lt;= (B and D);
      when &quot;100&quot; =&gt; --OR--
         Z(2) &lt;= '0';
            Z(1) &lt;= (C or A);
            Z(0) &lt;= (D or B);
      when &quot;101&quot; =&gt; --XOR--
         Z(2) &lt;= '0';
            Z(1) &lt;= (((not(A)) and C) or (A and (not(C))));
            Z(0) &lt;= (((not(B)) and D) or (B and ((not(D)))));
      when &quot;110&quot; =&gt; --NOT--
            Znot(3) &lt;= (not(A));
         Znot(2) &lt;= (not(B));
            Znot(1) &lt;= (not(C));
            Znot(0) &lt;= (not(D));
        when others =&gt;
            Znot(3) &lt;= '0';
         Znot(2) &lt;= '0';
            Znot(1) &lt;= '0';
            Znot(0) &lt;= '0';
            Z(2) &lt;= '0';
            Z(1) &lt;= '0';
            Z(0) &lt;= '0';
   end case;
end process;
end tabla;
","As has been stated in the comments, you don't assign a value to all your output signals from the Case statement for each case. As the extract from the language standard can use language that is bit technical and opaque, I will try to write an explanation that is beginner friendly.
You case statement has seven outputs, Z(0..2) and Znot(0..3). Your process is of a type known as combinatorial (i.e. it is not clocked). The standard description of this structure would be to assign all outputs, for all cases. If you look at your first evaluation (when = &quot;000&quot;) you can see that you are only assigning values to Z. This implies that you want Znot to retain its previous value, which implies a memory element. A non-clocked memory element is called a Latch.
The reason you get a warning is that Latches violate synchronous design practices. FPGAs are designed to work synchronously. The tools know this, and since in 99% of cases a latch is unintended, will raise a warning. The reason they don't raise an error is that there are some corner cases where a latch is intended, but this is for expert use only.
The correct way to imply a memory element is to use a register. In this case, to imply this would be to drive your process with a clock. If that is not desirable then explicitly state the desired value for every output in every case.",,,,,
< bit half-byte byte ... > memory access in 32-bit memory using verilog,"This is my synthesizable memory model in Verilog.

    module memory(
        output reg [31:0] data_out,
        input [31:0] address,
        input [31:0] data_in, 
        input write_enable,
        input clk
    );
        reg [31:0] memory [0:255];

        always @(posedge clk) begin
            if (write_enable) begin
                memory[address] &lt;= data_in;
            end
            data_out &lt;= memory[address];
        end

    endmodule


For example:

memory[32'h10] contains 0xAAAAAAAA 

I just want to write one byte of data 0xFF in memory address 0x10 so that

memory[32'h10] contains 0xFFAAAAAA 

Can you recommend a good way to change my code so that I can access only one bit, half-byte, byte, halfword, or word in my memory module?","What 'a good way' is depends on your synthesis target. If it's an FPGA you should consider that bit-wise write access for large memories is generally not a good idea. This will possibly prevent the memory from mapping to RAM resources, dramatically increasing routing costs.  

Byte enables are generally directly supported. You can view the Xilinx coding guidelines here where it describes byte enables on page 159. ",,,,,
Can anyone help me with this VHDL code (currently malfunctioning)?,"This code should be (and is) very simple, and I don't know what I am doing wrong. 
Here is description of what it should do:

It should display a number on one 7-segment display. That number should be increased by one every time someone presses the push button. There is also reset button which sets the number to 0. That's it. Here is VHDL code:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity PWM is
    Port ( cp_in : in  STD_LOGIC;
           inc : in  STD_LOGIC;
              rst: in std_logic;
           AN : out  STD_LOGIC_VECTOR (3 downto 0);
           segments : out  STD_LOGIC_VECTOR (6 downto 0));
end PWM;

architecture Behavioral of PWM is
    signal cp: std_logic;

    signal CurrentPWMState: integer range 0 to 10;
    signal inco: std_logic;
    signal temp: std_logic_vector (3 downto 0);
begin
    --cp = 100 Hz
    counter: entity djelitelj generic map (CountTo =&gt; 250000) port map (cp_in, cp);
    debounce: entity debounce port map (inc, cp, inco);
    temp &lt;= conv_std_logic_vector(CurrentPWMState, 4);
    ss: entity decoder7seg port map (temp, segments);

    process (inco, rst)
    begin
        if inco = '1' then
            CurrentPWMState &lt;= CurrentPWMState + 1;
        elsif rst='1' then
            CurrentPWMState &lt;= 0;
        end if;
    end process;

    AN &lt;= ""1110"";
end Behavioral;


Entity djelitelj (the counter used to divide 50MHz clock):

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity PWM is
    Port ( cp_in : in  STD_LOGIC;
           inc : in  STD_LOGIC;
              rst: in std_logic;
           AN : out  STD_LOGIC_VECTOR (3 downto 0);
           segments : out  STD_LOGIC_VECTOR (6 downto 0));
end PWM;

architecture Behavioral of PWM is
    signal cp: std_logic;

    signal CurrentPWMState: integer range 0 to 10;
    signal inco: std_logic;
    signal temp: std_logic_vector (3 downto 0);
begin
    --cp = 100 Hz
    counter: entity djelitelj generic map (CountTo =&gt; 250000) port map (cp_in, cp);
    debounce: entity debounce port map (inc, cp, inco);
    temp &lt;= conv_std_logic_vector(CurrentPWMState, 4);
    ss: entity decoder7seg port map (temp, segments);

    process (inco, rst)
    begin
        if inco = '1' then
            CurrentPWMState &lt;= CurrentPWMState + 1;
        elsif rst='1' then
            CurrentPWMState &lt;= 0;
        end if;
    end process;

    AN &lt;= ""1110"";
end Behavioral;


Debouncing entity:

library IEEE;
use  IEEE.STD_LOGIC_1164.all;
use  IEEE.STD_LOGIC_ARITH.all;
use  IEEE.STD_LOGIC_UNSIGNED.all;
ENTITY debounce IS
    PORT(pb, clock_100Hz : IN    STD_LOGIC;
         pb_debounced     : OUT    STD_LOGIC);
END debounce;

ARCHITECTURE a OF debounce IS
    SIGNAL SHIFT_PB : STD_LOGIC_VECTOR(3 DOWNTO 0);
BEGIN

-- Debounce Button: Filters out mechanical switch bounce for around 40Ms.
-- Debounce clock should be approximately 10ms
process 
begin
  wait until (clock_100Hz'EVENT) AND (clock_100Hz = '1');
      SHIFT_PB(2 Downto 0) &lt;= SHIFT_PB(3 Downto 1);
      SHIFT_PB(3) &lt;= NOT PB;
      If SHIFT_PB(3 Downto 0)=""0000"" THEN
        PB_DEBOUNCED &lt;= '1';
      ELSE 
        PB_DEBOUNCED &lt;= '0';
      End if;
end process;
end a;


And here is BCD to 7-segment decoder:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity decoder7seg is
    port (
        bcd: in std_logic_vector (3 downto 0);
        segm: out std_logic_vector (6 downto 0));
end decoder7seg;

architecture Behavioral of decoder7seg is
begin
    with bcd select
        segm&lt;= ""0000001"" when ""0000"", -- 0
        ""1001111"" when ""0001"",        -- 1
        ""0010010"" when ""0010"",        -- 2
        ""0000110"" when ""0011"",        -- 3
        ""1001100"" when ""0100"",        -- 4
        ""0100100"" when ""0101"",        -- 5
        ""0100000"" when ""0110"",        -- 6
        ""0001111"" when ""0111"",        -- 7
        ""0000000"" when ""1000"",        -- 8
        ""0000100"" when ""1001"",        -- 9
        ""1111110"" when others;        -- just - character

end Behavioral;


Does anyone see where I made my mistake(s) ?
I've tried that design on Spartan-3 Started board and it isn't working ... Every time I press the push button, I get crazy (random) values. The reset button is working properly.
Thanks !!!!","I guess the problem is here:  

process (inco, rst)
begin
    if inco = '1' then
        CurrentPWMState &lt;= CurrentPWMState + 1;
    elsif rst='1' then
        CurrentPWMState &lt;= 0;
    end if;
end process;


When rst='1' you will reset CurrentPWMState. But when inco='1' the you endlessly add 1 to  CurrentPWMState. That's something like an asynchronous feedback loop through a latch. You should do something edge sensitive here. Probably you should capture inco using your clock signal, detect a 0->1 change and then add 1.",,,,,
Start again input signals when rst=' 1',"I'm trying to reset the values of the inputs in a circuit when a reset signal starts.

I'm writing on Vivado by Xilinx in VHLD. 

signal Xin : signed(4 downto 0) := (others =&gt; '0');


...

   stim_process: process
   begin
        Xin &lt;= to_signed(1030,5); wait for clk_period;
        Xin &lt;= to_signed(1050,5); wait for clk_period;
        Xin &lt;= to_signed(1040,5); wait for clk_period;
        Xin &lt;= to_signed(1080,5); wait for clk_period;
        Xin &lt;= to_signed(1100,5); wait for clk_period;
        Xin &lt;= to_signed(0,5);    wait until Rst= '1';
        Xin &lt;= to_signed(1030,5); wait for clk_period;
        Xin &lt;= to_signed(1050,5); wait for clk_period;
        Xin &lt;= to_signed(1040,5); wait for clk_period;
        Xin &lt;= to_signed(1080,5); wait for clk_period;
        Xin &lt;= to_signed(1100,5); wait for clk_period;
        Xin &lt;= to_signed(0,5);            
        wait;
   end process; 


In this way, by sending a reset signal after ALL the inputs have been assigned, I obtain the desired result.

The problems is : 


  I can not find a way to reset the sequence of input signals at any time and how many times I want.
","Rewrite it to keep information about place in the sequence as state information, like:

process (rst, clk) is
begin
  if rst = '1' then
    State &lt;= 0;
    Xin &lt;= to_signed(1030,5);
  elsif rising_edge(clk) then
    case State is
      when 0      =&gt; Xin &lt;= to_signed(1030,5);
      when 1      =&gt; Xin &lt;= to_signed(1050,5);
      when 2      =&gt; Xin &lt;= to_signed(1040,5);
      when 3      =&gt; Xin &lt;= to_signed(1080,5);
      when 4      =&gt; Xin &lt;= to_signed(1100,5);
      when others =&gt; Xin &lt;= to_signed(0,5);
    end case;
    State &lt;= State + 1;
  end if;
end process;


Reset in rst can thereby take immediate effect, and be repeated.  

Minor updates to the above may be required depending on the timing you want, but code along the lines of this should do the job.

Btw. doing to_signed conversion of value 1030 into a 5 bit Xin looks odd, since a value of 1030 required at least 12 bits for signed representation.",,,,,
Polymorphism behavior,"Could someone help explain this behavior difference? Shouldn't functions that are virtual be always virtual? Does it matter where it is made virtual-parent/child class.

Variant 1:

module test;
   class A;
      virtual function void showMsg(int val);
         $display(""This is A"");
      endfunction
   endclass
   class B extends A;
       function void showMsg(int val);
         $display(""This is B, val = %0d"", val);
      endfunction
   endclass
   class C extends B;
      function void showMsg(int val);
         $display(""This is C, val=%0d"", val+1);
      endfunction
   endclass
   initial begin
      A a;
      B b;
      C c;
      b = new();
      a = b;
     a.showMsg(1);
      c = new();
      b = c;
     b.showMsg(7); 
   end
endmodule


Variant 2:

module test;
   class A;
       function void showMsg(int val);
         $display(""This is A"");
      endfunction
   endclass
   class B extends A;
       virtual function void showMsg(int val);
         $display(""This is B, val = %0d"", val);
      endfunction
   endclass
   class C extends B;
      function void showMsg(int val);
         $display(""This is C, val=%0d"", val+1);
      endfunction
   endclass
   initial begin
      A a;
      B b;
      C c;
      b = new();
      a = b;
     a.showMsg(1);
      c = new();
      b = c;
     b.showMsg(7); 
   end
endmodule


Variant1 results-


  This is B, val = 1 This is C, val=8


Variant2 results-


  This is A This is C, val=8


https://www.edaplayground.com/x/3RMZ","In variant 2, A::showMsg is non-virtual. The code calling a.showMsg must behave as non-virtual because is has no knowledge the class will be extended. That means A::showMsg could have a completely different prototype from B::showMsg if you wanted (i.e. a different number of argument). But once B::showMsg is declared virtual, all derived methods are virtual and must have the same prototype.",,,,,
The output of the following code is unexpected:,"I am trying to display time. But it returns the value 0. What's wrong?

CODE:

module hello_world;
integer in_reg;
initial
begin
  in_reg = 3'd2;
  $monitor($time, "" In register value = %b\n"",in_reg[2:0]);
end
endmodule


OUTPUT:  


  0 In register value = 010
","Nothing is wrong. When the $monitor statement outputs its line, simulation time is 0.

As I guess you know, $monitor outputs a line whenever any of its inputs changes. It does not do this for $time, however, because it makes little sense to do so. (When would it output a line? Every ns? Every ps? Every fs?) 

So, your code sets in_reg to 3'd2 and then $monitor displays that. Then the simulation finishes. Nothing else happens.",,,,,
Xilinx FIFO IP block output in simulation,"I was playing around with Xilinx FIFO IP block and there are some things that I cannot explain in the following output :


Test Bench code :

`define wrclk_period 20 ;
`define rdclk_period 10 ;

module testbench;
reg rst;
reg wr_clk ;
reg rd_clk ;
reg [7:0] din ; 
reg wr_en ;
reg rd_en ;
wire [7:0] dout ;
wire full ; 
wire empty ;

fifo_generator_0 FG0(rst,wr_clk,rd_clk,din,wr_en,rd_en,dout,full,empty) ;


initial wr_clk = 1 ;
always #10 wr_clk = ~wr_clk ;

initial rd_clk = 1 ;
always #5 rd_clk = ~rd_clk ;




integer i,j ;

initial begin 
rst = 1 ; 
#10
   din = 0 ;
   wr_en = 0 ;
   rd_en = 0 ;
   rst = 0 ;
   #`wrclk_period ;
   rst = 1 ;
   #`wrclk_period ;
   rst = 0 ;
   #60;


   for(i= 0 ; i&lt;=5 ; i = i+1  ) begin 
     wr_en = 1 ;
     din = i ;
     #`wrclk_period ;
   end 

   wr_en = 0 ;
   #`wrclk_period ;

   #`rdclk_period ;

   for( j= 0 ; j&lt;=5 ; j = j+1  ) begin 
        rd_en = 1 ;
        #`rdclk_period ;
    end

      rd_en = 0 ;
      #`rdclk_period ;

      $stop ;
   end
endmodule


1) Question 1: The output variable full is high in the beginning . Why is this the case ?

2) Question 2 : Why do we miss the data 1 in the dout ? I can see 2,3,4,5 but 1 does not show up .

3) After rd_en is set to 1 , the dout change from 3 to 4 takes 2 clock cycles while the change from 2 to 3 happens at the immediate next posedge of the read clock ? ","Sorry had this in a comment but ran heavily out of space.

I am not familiar wit the IP but can make some educated guesses.

1/ I suspect you have to wait longer after a reset before you start using the FIFO. Maybe by that time the full flag is low.
The problem with the 'full' flag may be because after the reset the FIFO level has to pass the clock domain crossing which takes a few cycles. As a precaution the designer set it to 'full' as that is the fail safe state.

2/ I also suspect the value 0x01 is not written because the FIFO still thinks it is full. 

3/ Study the waveform more carefully: 2->3 is one clock, 3->4 is one clock but then you are reading when the FIFO is empty!! Thus 5 comes out only after the FIFO is no longer empty.

In general if you test a block like this for the first time, make your timings are a lot longer. So wait longer after the reset before writing, wait longer after the writing before reading. 

Last comment: Your rd_en seem to run of the rising edge of the rd_clk fine, no problem. But the your wr_en signal is running of the falling edge of the wr_clk or of the rising edge of rd_clk. If it is the latter it is wrong!",,,,,
Verilog - Is it possible to create two vcd files during the same simulation,"I have to create two vcd files. One which starts at zero time and ends when a specific signal changes, and one which start right after.

Is it possible to do it with verilog?","The Verilog standard does not provide a way of doing this in one simulation. Your first simulation would run up until the specific signal changes creating your first VCD file. Your second simulation would have to start dumping to the second VCD file when the specific signal changes.

Some tools, like ModelSim/Questa, provide Tcl command line options for dumping to multiple VCD files. You would turn off dumping to the first VCD file at same time start dumping to the second VCD file. Please read your tools user manual. ",,,,,
Defining generated clock as synchronous in RTL simulation,"I am generating a divided clock, something like this:

logic div_clk;
always_ff @(posedge clk or negedge rstb) begin 
   if(!rstb) div_clk &lt;= 1'b0;
   else div_clk &lt;= !div_clk;
end


I then launch data on clk and capture on div_clk. Something like this:

always_ff @(posedge clk) begin 
   clk_data &lt;= something;
end

always_ff @(posedge div_clk) begin 
   div_clk_data &lt;= clk_data;
end


In my simulations I am getting a race condition since clk_data updates coincident with div_clk and the div_clk_data gets the wrong value.

In synthesis I define these two clocks to be synchronous by creating a generated clock:

create_clock -name CLK [get_ports clk]
create_generated_clock -name GEN_DIV_CLK -source [get_ports clk] -divide_by 2 [get_pins div_clk]


Is there something equivalent that I can put into my RTL, or something I can do to tell my simulator that div_clk is synchronous to clk and prevent the race condition from happening? ",This is a case where NBA's should not be used. You should not have any NBA's in your clock tree (including gated clocks) if you want the clocks to remain synchronous. ,,,,,
"systemverilog parameter array in module , how to set parameter array single element when instantiating module","i am trying to create a module which has other module of memory , I am trying to have one parameter which of array , and using this parameter following code will generate modules instance , now I am trying to instantiate this module with setting only one element of this parameter array of only one index 

Now the below code will give you the idea what I have tried , but the compiler is giving an error as --  """" MEM_AT_CS  is not an array""""

/////////////////////////////////////////////////////////

typedef enum   {NONE , SSRAM_X16 , SSRAM_X32 , SDRAM_X8 , SDRAM_X16 , 
                SDRAM_X32 , SYNC , ASYNC} memory_config_type;

module MEM_MODEL_WRAPPER (mem_intf intf , input logic mc_clk);

  parameter no_of_chip_select = 8;
  parameter memory_config_type MEM_AT_CS[no_of_chip_select-1 :0] = 
         '{NONE ,NONE ,NONE ,NONE ,NONE ,NONE ,NONE ,NONE  };


  genvar i;

  generate
    for(i=0 ; i&lt;no_of_chip_select;i++) begin    

       case(MEM_AT_CS[i]) 
       SDRAM_X8:begin       
             .
             .
             .




now top module

module top ;

  //////////here i want to set the parameter array by index 

  defparam mem_dut.MEM_AT_CS[2] = SSRAM_X16;

  MEM_MODEL_WRAPPER  mem_dut(mem_intf , mc_clk);

endmodule       


I have tried this too

MEM_MODEL_WRAPPER #( .MEM_AT_CS[2] (SSRAM_X16) ) 
                                    mem_dut(mem_intf , mc_clk);
","You cannot do it for a slice of the parameter. You need to set the whole array. Here is an example:

module M#(parameter int array[2] = '{1,2})();
   initial $display(""%m {%0d,%0d}"", array[0], array[1]);
endmodule // M

module top();
   M m1();

   M m2();
   defparam m2.array = '{3, 4};

   M #(.array('{5,6}))m3()   ;
endmodule // top
",,,,,
Type std_logic is not an array type and cannot be indexed,"Checking the syntax of this code: gave me ""Type std_logic is not an array type and cannot be indexed."" on line 12 and 14.

WHY?!

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Tot_and_module is
Port ( s : in  STD_LOGIC_VECTOR(0 to 39);
res : out  STD_LOGIC);
end Tot_and_module;

architecture Behavioral of Tot_and_module is
signal temp: std_logic_vector(0 to 39);
begin
temp(0) &lt;= res(0);
gen: for i in 1 to 39 generate
temp(i) &lt;= temp(i-1) and res(i);
end generate; 
res &lt;= temp(39);
end Behavioral;
","res is a std_logic - a single bit.
temp and s are std_logic_vectors - arrays of type std_logic

You have:

temp(0) &lt;= res(0);


This is not possible because res is not an array. Fix it with:

temp(0) &lt;= res;
",,,,,
How to implement a watchdog timer on a Cyclone II FPGA in quartus ii,"I need to implement a watchdog timer on my Cyclone II FPGA board.
I have designed the system using QSYS, i need to know what are the next steps to implement and test a watchdog Timer.","To implement a watchdog with qsys you can use the ""Interval Timer"" in library : ""Processors and Peripherals"" -> ""Peripherals"" -> ""Interval Timer"".
Then configure it as a watchdog.

For testing it, it depend to your application. We need more information on your project architecture. ",,,,,
My outputs in 4bits fullAdder are always z and don't change,"I'm writing 4 bits full adder with verilog in Active-hdl I think my code and test-bench are right but the value of sum and cout are always z in waveform can anybody help me what the problem is.this my code and test-bech

    module fullAdder(A, B, cin, sum, cout);
    input A,B,cin;
    output sum,cout;
    assign {cout , sum} = A + B + cin;
endmodule

module fullAdder4bits(A, B, cin, sum, cout);
    input [3:0] A,B;
    input cin;
    output [3:0] sum;
    output cout;
    wire w1,w2,w3;
    fullAdder I0(A[0],B[0],cin,sum[0],w1);  
    fullAdder I1(A[1],B[1],w1,sum[1],w2);
    fullAdder I2(A[2],B[2],w2,sum[2],w3);
    fullAdder I3(A[3],B[3],w3,sum[3],cout);
endmodule   
`timescale 1 ns/1 ps  
module testbench;
    reg tcin;
    reg [3:0] tA,tB;
    wire [3:0] tsum;
    wire tcout;
    fullAdder4bits dut(tA, tB, tcin, tsum, tcout);
    initial 
        begin
        tA = 0;
        tB = 0;
        tcin = 0;
        #10 tA = 5;
        #10 tB = 8;
        #10 tA = 7;
        #10 tcin = 1;
    end
    initial $monitor(""A = %d , B = %d , cin = %b , sum = %d , cout = %b"",tA,tB,tcin,tsum,tcout);  
    initial #60 $finish;
    endmodule


","I could not spot any errors so I decided to throw your design at Vivado.

It helps that you have given the complete code inclusive test-bench!

Your code seem fine and in Vivado I do not see the 'z' status:

",,,,,
Quartus 14.1 encrypted files used in Quartus 17.1,Are there any issues with using Quartus encrypted files version specific to Quartus 14.1 in Quartus prime 17.1 ? ,"The issue is not with the encryption, but the original source code. Sometimes ""fixes"" to the compiler breaks what you thought was working code. You have to try it yourself, or ask the originator of the encrypted code to verify it for you with the latest version. ",,,,,
"How to Overcome ""warning: Port 8 (Destination) of instruction_reg expects 8 bits, got 1."" in verilog?","My task is to implement a Processor with Data Memory using verilog. Instructions are hard coded (32 bit instructions). I have completed inserting a Data Memory.
For load and store instructions
But when complied i get- ""warning: Port 8 (Destination) of instruction_reg expects 8 bits, got 1."" 

This a verilog code for a instruction set architecture    

&lt;pre&gt;&lt;code&gt;
//ALU created

module ALU(out,DATA1,DATA2,Select); //module for ALU
input [7:0]DATA1,DATA2;//8 bit data inputs
    input [2:0] Select;//three bit selection 
    output [7:0]out;//8 bit data output
    reg out;//outputt register
    always@(DATA1,DATA2,Select)
    begin
        case(Select)
            3'b000: out=DATA1;//forward
            3'b001: out=DATA1+DATA2;//add
            3'b010: out=DATA1 &amp; DATA2;//and
            3'b011: out=DATA1| DATA2; //or

        endcase
    end

endmodule
//here no need of its test bench

//registerFile created in part2
module Register(clk,busy_wait,INaddr,IN,OUT1addr,OUT1,OUT2addr,OUT2);
    input clk;
 input [2:0] INaddr;
 input [7:0] IN;
 input [2:0] OUT1addr;
 output[7:0] OUT1;
 input [2:0] OUT2addr;
 output[7:0] OUT2;
 input busy_wait;       //new

reg [7:0] reg0, reg1, reg2, reg3,reg4,reg5,reg6,reg7;
assign OUT1 =   OUT1addr == 0 ? reg0 :
                OUT1addr == 1 ? reg1 :
                OUT1addr == 2 ? reg2 :
                OUT1addr == 3 ? reg3 :
                OUT1addr == 4 ? reg4 :
                OUT1addr == 5 ? reg5 :
                OUT1addr == 6 ? reg6 :
                OUT1addr == 7 ? reg7 : 0;


assign OUT2 =   OUT2addr == 0 ? reg0 :
                OUT2addr == 1 ? reg1 :
                OUT2addr == 2 ? reg2 :
                OUT2addr == 3 ? reg3 :
                OUT2addr == 4 ? reg4 :
                OUT2addr == 5 ? reg5 :
                OUT2addr ==  6? reg6 :
                OUT2addr == 7 ? reg7 : 0;


 always @(negedge clk) 
    begin
    //check weather it is not busy
    if (!busy_wait) begin
        case(INaddr)
            3'b000: reg0=IN;
            3'b001: reg1=IN;
            3'b010: reg2=IN;
            3'b011: reg3=IN;
            3'b100: reg4=IN;
            3'b101: reg5=IN;
            3'b110: reg6=IN;
            3'b111: reg7=IN;
        endcase
     end
     end 
endmodule

//we need control unit

//we need twos compliment when substractor is called

module twos_compliment(IN,OUT);     //twos complement
    input [7:0] IN;
    output signed [7:0] OUT;

    assign OUT=-IN;
endmodule

//multiplexer is used to select value or compliment
module multiplex(IN1,IN2,OUT,SELECT);       //multiplexer
    input [7:0] IN1,IN2;
    input SELECT;
    output [7:0] OUT;

    assign OUT = (SELECT) ? IN2 : IN1 ;

endmodule

//program counter is needed
module counter(clk,reset,busy_wait,addr);       //module program counter
    input clk,reset;
    output [31:0] addr;
    reg addr;
    input busy_wait;
//in hardcoded instructions Memroy start is hexadecimal 00000000 
    always @(reset) begin
        addr = 32'h00000000;
    end

    always @(negedge clk) begin
    //now we have to check busy wait also
    if(~reset &amp;&amp; !busy_wait)
            begin
        addr = addr + 1;//addr is incremented by 1
        end

    else if (busy_wait) begin
        addr &lt;= addr ;
    end
    end
endmodule


//control unit
//input should be instruction opcode
//output should be select for alu and input to muxes

module CU(Instruction,busy_wait,opcode,SELECT,mulx1,mulx2,memRead,memWrite,regWrite,Destination,address);   //control unit
    input [7:0] opcode;
    input [31:0] Instruction;
    input [7:0] Destination;
    //input [31:0] Instruction_code;//to extract load or Store Adress the Instruction code [23-16]
    output [2:0] SELECT;
    output mulx1,mulx2;
    input busy_wait; //new
     output memRead; //new
     output memWrite;//new
         output regWrite;//new
         output [7:0] address;//new
         reg mulx1,mulx2,memRead,memWrite,regWrite,address;


    assign SELECT = opcode [2:0]; //select should be opcodes last three bits for alu
    always @(opcode) begin
        case(opcode)
            8'b00000000:begin   //for mov   
                mulx1 = 1'b1;
                mulx2 = 1'b0;
                end
            8'b00000001:begin   //for add   
                mulx1 = 1'b1;
                mulx2 = 1'b0;
                end
            8'b00001001:begin   //sub   
                mulx1 = 1'b1;
                mulx2 = 1'b1;
                end
            8'b00000010:begin   //and   
                mulx1 = 1'b1;
                mulx2 = 1'b0;
                end
            8'b00000011:begin   //or    
                mulx1 = 1'b1;
                mulx2 = 1'b0;
                end
            8'b00001000:begin   //for loadImmediate 
                mulx1 = 1'b0;
                end

                /*4'b0101:
            begin
                memRead = 1'b0;
                memWrite = 1'b1;
                address = instruction[23:16];
                $display(""oper = store"");
            end                     
            // store to memory
                */

            8'b00000101:begin   //for store to Data memory(selected 00000101)   
                memRead = 1'b0;
                memWrite = 1'b1;
                assign address = Destination;
                mulx1 = 1'b1;
                mulx2 = 1'b1;
                end
                /*4'b0100:
            // load from memory 
            begin
                memWrite = 1'b0;
                memRead = 1'b1;
                address = instruction[7:0];
                $display(""oper = load"");    
            end

                */

            8'b00000100:begin   //for load To register From Data memory (selected 00000100)
                memWrite = 1'b0;
                memRead = 1'b1;
                assign address = Instruction[7:0];
                mulx1 = 1'b1;
                mulx2 = 1'b1;
                end

                default : 
        begin
            memWrite = 1'b0;
            memRead = 1'b0; 
        end     
        endcase

    end
endmodule
//instruction memory 32 bits instead of memory
module instruction_mem(Read_addr,Instruction_code);
    output [31:0] Instruction_code;
    reg Instruction_code;
    input [31:0] Read_addr;

    always @(Read_addr) begin
        case(Read_addr)

            /*32'h00000000: Instruction_code = 32'b00001000 00000 100 00000000 11111111;// loadi 4 X 0xFF(255)
            32'h00000001: Instruction_code = 32'b00001000 00000 110 00000000 10101010;// loadi 6 X 0xAA(170)

            32'h00000002: Instruction_code = 32'b00001000 00000 011 00000000 10111011;// loadi 3 X 0xBB(187)

            32'h00000003: Instruction_code = 32'b00000001 00000 101 00000 110 00000 011;// add   5 6 3

            32'h00000004: Instruction_code = 32'b00000010 00000 001 00000 100 00000 101;// and   1 4 5

            32'h00000005: Instruction_code = 32'b00000011 00000 010 00000 001 00000 110;// or    2 1 6

            32'h00000006: Instruction_code = 32'b00000000 00000 111 00000 000 00000 010;// mov   7 x 2

            32'h00000007: Instruction_code = 32'b00001001 00000 100 00000 111 00000 011;// sub   4 7 3
            32'h00000008: Instruction_code = 32'b00000101 00000000 00000 000 00000 100;     // store 0, X, 4
            32'h00000009: Instruction_code = 32'b00000100 00000101 00000 000 00000 000;     // load 5, X, 0*/


            /*Hard coded instructions for Processor without memry is commented*/
            /*32'h00000000: Instruction_code = 32'b00001000000001000000000011111111;// loadi 4 X 0xFF(255)
            32'h00000001: Instruction_code = 32'b00001000000001100000000010101010;// loadi 6 X 0xAA(170)
            32'h00000002: Instruction_code = 32'b00001000000000110000000010111011;// loadi 3 X 0xBB(187)
            32'h00000003: Instruction_code = 32'b00000001000001010000011000000011;// add   5 6 3
            32'h00000004: Instruction_code = 32'b00000010000000010000010000000101;// and   1 4 5
            32'h00000005: Instruction_code = 32'b00000011000000100000000100000110;// or    2 1 6
            32'h00000006: Instruction_code = 32'b00000000000001110000000000000010;// mov   7 x 2
            32'h00000007: Instruction_code = 32'b00001001000001000000011100000011;// sub   4 7 3*/


            //new instructions
            32'h00000000: Instruction_code = 32'b00000101000000000000000000000100;      // store 0, X, 4
            32'h00000001: Instruction_code = 32'b00000100000001010000000000000000;      // load 5, X, 0


        endcase
    end
endmodule



//inside the control unit a opcode should be divided in instruction reg

module instruction_reg(Instruction,clk,OPCODE,OUT1addr,OUT2addr,INaddr,Immediate,Destination);
    input [31:0] Instruction;
    input clk;
    output[2:0] OUT1addr,OUT2addr,INaddr;
    output [7:0] OPCODE,Immediate,Destination;


    assign INaddr = Instruction[18:16];
    assign OPCODE = Instruction[31:24];//31-24 taken declared as op code
    assign Immediate = Instruction[7:0];//immediate value is 7-0
    assign OUT1addr = Instruction[2:0]; //output1addr addredd of output data by the registerFile
    assign OUT2addr = Instruction[10:8];
    assign Destination=Instruction[23:16];//new
endmodule

//data memory
module data_mem(
    clk,
    rst,
    read,
    write,
    address,
    write_data,
    read_data,
    busy_wait
);
input           clk;
input           rst;
input           read;
input           write;
input[7:0]      address;
input[7:0]      write_data;
output[7:0]     read_data;
output          busy_wait;

reg[7:0]     read_data;
reg busy_wait,clkMem=1'b0;
integer  i;

// Declare memory 256x8 bits 
reg [7:0] memory_array [255:0];
//reg [7:0] memory_ram_q [255:0];



always @(posedge rst)
begin
    if (rst)
    begin
        for (i=0;i&lt;256; i=i+1)
            memory_array[i] &lt;= 0;
    end
end

always #1 clkMem = ~clkMem;

always @(posedge clkMem)
begin
    if (write &amp;&amp; !read &amp;&amp; !busy_wait)
    begin
        busy_wait &lt;= 1;
        // artificially delay 100 cycles
        repeat(10)
        begin
        @(posedge clk);
        end
        $display(""writing to memory"");
        memory_array[address] = write_data;
        busy_wait &lt;= 0;
    end
    if (!write &amp;&amp; read &amp;&amp; !busy_wait)
    begin
        busy_wait &lt;= 1;
        // artificially delay 100 cycles
        repeat(10)
        begin
        @(posedge clk);
        end
        $display(""reading from memory"");
        read_data = memory_array[address];
        busy_wait &lt;= 0;
    end
end

endmodule


//test bench

module for_processor_test();
    wire [2:0] SELECT,OUT1addr,OUT2addr,INaddr;
    wire mux1OUT,mux2OUT;
    reg clk,reset,reset_reg;
    wire [31:0] Read_addr,Instruction_code;
    wire [7:0] OPCODE,Immediate,OUT1,OUT2,RESULT,twosComplement,mux2out,mux1out;


    counter c1(clk,reset,busy_wait,Read_addr);
    instruction_mem instruct_mem1(Read_addr,Instruction_code);
    instruction_reg instruct_reg1(Instruction_code,clk,OPCODE,OUT1addr,OUT2addr,INaddr,Immediate,Destination);
    CU cu1(Instruction_code,busy_wait,OPCODE,SELECT,mulx1,mulx2,memRead,memWrite,regWrite,Destination,address);
    //CU cu1(Instruction_code,busy_wait,opcode,SELECT,mulx1,mulx2,memRead,memWrite,regWrite,address);
    //CU myCU(busy_wait,instruction, out_addr1, out_addr2, in_addr, select, data2_compli_control, immediate_control, immediate_value, memRead,memWrite,regWrite,address);

    //(opcode,SELECT,mulx1,mulx2,memRead,memWrite,regWrite)
    Register regfile(clk,busy_wait,INaddr,RESULT,OUT1addr,OUT1,OUT2addr,OUT2);
    twos_compliment tcmplmnt(OUT1,twosComplement);
    multiplex mulx2(OUT1,twosComplement,mux2out,mux2OUT);
    multiplex mulx1(Immediate,mux2out,mux1out,mux1OUT);
    ALU alu(RESULT,mux1out,OUT2,SELECT);
        data_mem mdata_mem(clk,rst,memRead,memWrite,address,write_data,read_data,busy_wait);
    always #10 clk = ~clk;

    initial begin

        clk = 0;
        reset = 1;
        reset = 0;
        reset_reg = 1;
        reset_reg = 0;
        #160 

        $finish;
    end

    initial begin
        while(1) begin
        #10 $display(""INSTRUCTION=%b RESULT=%d clock=%d"",Instruction_code,RESULT,clk);
        //#20 $display(""INSTRUCTION=%b RESULT=%d clock=%d"",Instruction_code,RESULT,clk);
        end
    end
endmodule

&lt;/code&gt;&lt;/pre&gt;
","In module for_processor_test you have not declared Destination. Verilog is a pretty liberal language (by default), so it has implicitly declared a wire called Destination for you. However, this implicit wire will be only 1 bit wide. Hence, your error message.

If you want to tighten up this liberal behaviour (you do), then you can add this compile directive:

`default_nettype none


Had you done this, you would have got a more descriptive error message.",,,,,
Quartus Prime compilation ROM,"Hi I am designing a ISA RISCV 32 bits microcontroller and I have organized the ROM in arrays of 8 bits (1 byte), then the out is 32 bit width. Because I need it.

rom.txt: (each line is a instruction)

00000011 00100000 00000111 10010011                 
00000001 01000000 00001000 00010011 
00000001 00000111 10001000 10110011                 
00000001 00010001 00100000 00100011     
00000000 00000001 00101001 00000011
00000001 00100001 00100100 00100011
00000000 10000001 00101001 10000011
01000001 00000111 10001010 00110011
11111100 11101000 00001010 10010011     
11111101 01100000 00001110 11100011


ROM RTL:

module ROM(RADDRESS, DATA_OUT);

    parameter WIDTH = 32;    // out width
    parameter SIZE = 128;    // Total elements of 8 bytes

    input   [WIDTH-1:0]     RADDRESS ;
    output  [WIDTH-1:0]     DATA_OUT;
    reg     [7:0]           MEMORY [SIZE-1:0]; 

    initial // Read instructions 
    begin
        $readmemb(""rom.txt"", MEMORY); 
    end

    assign DATA_OUT = {MEMORY[RADDRESS], MEMORY[RADDRESS+1], MEMORY[RADDRESS+2], MEMORY[RADDRESS+3]}; // Big endian

endmodule


When I simulate with a testbench in Questasim/Modelsim the microcontroller works fine and the instructions are executing properly.

But in Quartus Prime when I compile it just compiles fine but in Compilation Report I get a total of 0 logic elements and 0 registers. 

Of course I have a RAM and another components inside microcontroller than are also using registers and logic cells.

Also I have input and output pins for/from microcontroller. The top hierarchy level module has output and input.

It's like Quartus syntethizer is just not detecting my RTL because my ROM.","I would try the following:


Use the ROM template in Quartus (open your design file, then right click and choose ""insert template""). Quartus is often confused about exact syntax when inferring IP, for example reading four entries at a time might cause problems.
If you're still having problems, run the embedded memory IP wizard and choose your rom.txt file as the ROM contents.


If you send a support request to Intel, I'm pretty sure this is what they will tell you to do. Note that both of these options probably involve changing your hex file to have 32-bit entries instead of 8-bit.",,,,,
How do I do a BCD to unsigned integer conversion in vhdl or Labview,"I am programming an application in vhdl for a National Instruments CompactRio. One of the inputs is from a scale that only outputs an ASCII string of the weight on the scale. I know I can convert the ASCII digits to Binary Coded Decimal simply by removing the 4 MSBs, but how do I convert that do an unsigned integer using vhdl?  What is the fastest algorithm for values that range from 0 to 9999?","Sorry looked into BCD and realised it's not an ASCII representation of a numeric.
I would convert the string into an U8 (using String To Byte Array), and feed that into a for-loop and multiply that with a constant array, this array would  be [1000, 100, 10, 1], and summate all the elements of the resulting product, that should give you the numeric data of the string.",,,,,
How to initiate BRAMs with image data,"I would like to initiate some BRAMs (I'm using Xilinx FPGAs and ISE) with data from an image. It's bound to be through coe files but how? I could write a Java applet to manually construct the coe files (have done so before with C++) but I'm looking for a quicker solution.

Thanks","Various possibilities:


If you are inferring the BRAMs, you can initialise them in the HDL source with an array of data.
You can use Data2MEM to update an existing bitstream with new BRAM contents
As you say, COE files are a possibility
I believe you can use $readmem functions if you are using Verilog


None of which directly takes your source image in I'm afraid.

If you can get your image into PGM format, and are using VHDL, you might be able to use functions from here:

https://github.com/martinjthompson/image_processing_examples

A full description of the code can be found here:

http://www.parallelpoints.com/node/65/ and http://www.parallelpoints.com/node/66/

I've never tried to use them to initialise memory in synthesisable code though...",,,,,
Export Xilinx ISE RTL/Technology Schematic into Netlist Text File,"I'm using VHDL on Xilinx ISE to generate a schematic of the register transfer logic in my project. I know ISE does a number of optimizations and gate reductions before spitting out the RTL and Technology schematics. What I want to do is to export the netlist of these schematics into some file so I can use that for my own program. Is there any way to do this? I keep reading about ngc files, but the contents of the ngc file generated upon synthesis make absolutely no sense.

Please let me know if you've done this before, I'd love to see how this is done. If it's not doable on ISE, can you recommend a tool that could do it?","EDIF is an industry standard format for describing netlists - there are numerous tools for interpreting them and you could easily roll your own since it's a documented textual format.

You can convert an .ngc into an edif file by running the Xilinx tool ngc2edif included in the ISE suite.",,,,,
IEEE Float type to std_logic_vector conversion,"I have a 2 D matrix where each element should be 64 bit std_logic_vector.

Now I want to store certain values into the matrix as shown in the below manner. How do I do that?
For example:

type a is array (0 to 10,0 to 10) of std_logic_vector(63 downto 0);
signal a1: a;
a1(0,0) &lt;= std_logic_vector( to_float64(12.23) );


Basically I dont know how to convert float64 to std_logic_vector.

I am using float_pkg library from ieee_proposed.","Why not do:

type aftype is array (0 to 10,0 to 10) of float64;
signal af: aftype;


Then there's no conversion.

In terms of conversions, the to_float function requires a type to know how to format the real input:

signal f : float64;
f &lt;= to_float(12.34, f);
-- or
af(0,0) &lt;= to_float(12.34,f);


If you must have a std_logic_vector, you can use to_std_logic_vector from the package (aliased to to_slv):

a1(0,0) &lt;= to_slv(to_float(12.34,f));
",,,,,
Why is my mux not producing an output in Verilog?,"I've written what I thought would be a working MUX, but my output is stubbornly staying at high-impedance. Can someone please provide me with guidance?

module mux_in #(parameter WIDTH = 1, parameter LOG_CHOICES = 1)
(
    input  [LOG_CHOICES - 1 : 0] choice,
    input  [(1 &lt;&lt; LOG_CHOICES) * WIDTH - 1 : 0] data_i,
    output [WIDTH - 1 : 0] data_o
);
    assign data_o = data_i[WIDTH * choice + WIDTH - 1 : WIDTH * choice];
endmodule


Here's my (bad) output:

data_i: 11111010101111100001001100100010
data_o: zzzzzzzz
Choice 0: (Expected  34) Output:   z
Choice 1: (Expected  19) Output:   z
Choice 2: (Expected 190) Output:   z
Choice 3: (Expected 250) Output:   z
","This should not compile because the range expression is not constant.

assign data_o = data_i[WIDTH * choice + WIDTH - 1 : WIDTH * choice];


Try this instead.

assign data_o = data_i[WIDTH * choice + WIDTH - 1 -: WIDTH];
",,,,,
Finding Absolute Value In Verilog Data Designated by System C/Xilinx X,"I have been trying to find the Absolute value of an integer which is designated to Verilog core using Xilinx SystemC, what I have seen is that Verilog treats the negative number as a positive number.

I have tried all data types : signed int , int, Xuint32.

my SystemC or Xilinx C code is:

signed int data,value;
data=-20;value=0;
putfsl(data,0);
getfsl(value,0);
signed int data1,value1;
data=20;value=0;
putfsl(data1,0);
getfsl(value1,0);


After getting the values of variables I printed them on Hyperterminal.

On my Verilog side the code was:

out &lt;=(in&lt;0)?-in:in;


I also tried this code but results were similar

if(in&lt;0)
out=-in;
else 
out=in;


Kindly help me out!

I have also tried other data types and changed parameters but results have not worked out to be I always get 
The same number I input i.e 

in&lt;0


statement is not being true, I also tried in&lt;=0;","I can't help with System C, but based on your comments the Verilog code is using an unsigned type for the signal in.

reg [31:0] in;
if(in&lt;0) //This will always be false since reg is unsigned
  out=-in;
else 
  out=in;


In order for this to work in would have to be declared as signed.

signed reg [31:0] in;


You can still test an unsigned value for a negative value(assuming in actually holds a two-complement value) by looking at the MSB.

//If negative
if(in[31])
  out = -in;
else
  out = in;
",,,,,
Provide input data to FPGA using USB,"I am working on Xilinx Spartan 3E platform, using this development board:

http://www.xilinx.com/products/boards-and-kits/HW-SPAR3E-SK-US-G.htm

My program operates on certain data and then provides output. I wish to transfer the input signals externally. The input data is a stream of 8-bit signals. 

So, how do I send the input signals from my laptop to the FPGA via USB? Does Xilinx support this or is there standard software to do this?

Thanks.","It sounds like you are describing a uart more than a native USB interface.   You can get a USB to logic level serial adapter that will let you easily transfer data to and from a Pc at up to 921.6k baud.  A uart/serial port is easy to implement in the Fpga and PCs are easy to use with serial ports.

Here is the cable: 
http://www.ftdichip.com/Products/Cables/USBTTLSerial.htm
 If you have a development card it is very possible this type of interface is present.

On the software side you can use your programming language of choice as if it was interfacing with a seal port or use a terminal program like hyper terminal or Download teraterm http://ttssh2.sourceforge.jp/

Updated response:
100Hz is not a hard interface to make.  At that rate you should use the serial interface if at all possible.  The board you referenced has 2 full RS-232 connections.  At that point you only need a way to connect that to your computer.  If you have a PC with RS-232 connectors you only need a cable if you have a newer computer without you need a RS-232 to USB translator cable (like this one: http://search.digikey.com/scripts/DkSearch/dksus.dll?Detail&amp;name=768-1014-ND or google rs232 usb).  This will give you a virtual com port on the pc to interface with the previously mentioned terminal programs or your custom software.

Update 2:
on the resource tab of the development board page you linked to there are several UART based fpga designs that you should be able to use as a starting point.
i.e. the ""PicoBlaze Processor SPI Flash Programmer"".",,,,,
Accessing Verilog genvar generated instances in simulation code,"This is a Verilog releated question. I am working with XILINX ISE as a dev environment.

I am trying to access variables in the simulation that are automatically generated using genvar but I am receiving the following error -> HDLCompiler:71

Problem Example:

genvar i;

generate

for(i=0; i &lt; N; i=i+1)

begin:Sys_Modules

  TypeXModule #(.width(10)) xmod(.dataY(dataY)));

end

endgenerate 


When I ran synthesis or simulation I can see that Sys_Modules[0..N-1].xmod instances are created.

When I try to add a line to the simulation accessing the Sys_Modules array:

Sys_Modules[i].xmod.dataY

I get the following error:

HDLCompiler:71 dataY is not declared under prefix xmod

Is there any way to access automatically generated values in the simulation?

Thanks!","It is legal to write a hierarchical reference to a generated instance. The functionality is described in sections 2.7.2 and 12.1.3 of the IEEE Verilog standard. However, the instance subscript must be a constant so that it can be resolved at compile time.",,,,,
"In Verilog, counting and outputting the number of 1's in an 8bit input?","What I am trying to do in my mind is take 8 1-bit inputs and count the 1's. Then represent those 1's. 

01010111 should output 0101 (There are five 1's from input)

module 8to4 (in,out,hold,clk,reset);
input [7:0] in; //1 bit inputs
reg [7:0] hold; //possible use for case statement
output [3:0] out; //Shows the count of bits

always @(clk)
  begin
    out = in[0] + in[1] + in[2] + in[3] + in[4] + in[5] + in[6] + in[7]; //Adds the inputs from testbench and outputs it
  end
endmodule


Questions:


Is that the proper way to have 8 1-bit inputs? Or do I need to declare each variable as one bit ex: input A,B,C,D,E,F,G,H;
If my above code is close to being correct, is that the proper way to get out to display the count of 1's? Would I need a case statement?


I'm really new to verilog, so I don't even want to think about a test bench yet. ","The way you wrote it is probably the better way of writing it because it makes it easier to parameterize the number of bits. But technically, you have one 8-bit input. 

module 8to4 #(parameter WIDTH=8) (input [WIDTH-1:0] in, 
                        output reg [3:0] out,hold,
                        input clk,reset);
  reg [WIDTH-1:0] temp;
  integer ii;
  always @(clk)
    begin
      temp = 0;
      for(ii=0; ii&lt;WIDTH; i = i + 1)   
         temp = temp + in[ii];
      out &lt;= temp;
    end
endmodule
",,,,,
is there any way to Simulate DCM in ISIM?,"I have a DCM with different clock outputs which is working fine in real FPGA implementation, but could not see any input while simulate this DCM in Xilinx ISIM. Can we simulate DCM in ISIM testbench? Is there any trick?
Regards","It should work, make sure that simulation is running and wait enough time.",,,,,
Synopsys VCS message severity change from warning to error,"I want to change the severity of a VCS message from warning to error.

E.g.:

Warning-[TMR] Text macro redefined


I want to change TMR to Error severity instead of warning.

Please suggest me a way of doing this. Where am I supposed to do this setting?","You should add the next flag to your VCS command:
 -error=""TMR""",,,,,
VHDL NxM -bit parallel block multiplier,"I am trying to create schematics for a NxM -bit parallel block multiplier using generic parameters to define the size of the multiplier, and generate statements to describe the internal structure. I am having some trouble with my sums and carries and I am not able to implement what I want to do in VHDL code.

Here is what I got so far:

1-bit multiplier:

library IEEE;  
use IEEE.std_logic_1164.all;  
use IEEE.std_logic_arith.all;  
use ieee.numeric_std.all;  
use ieee.std_logic_unsigned.all;

entity mult is  
 port (  
  a     :  in std_logic;  
  b     :  in std_logic;  
  Sin   :  in std_logic;        --sum-in  
  Cin   :  in std_logic;        --carry-in  
  Sout  :  out std_logic;       --sum-out  
  Cout  :  out std_logic        --carry-out  
);  
end mult;  

architecture mult of mult is  
  begin  

    Sout &lt;= '1' when a = '0' and b = '0' and Sin = '0' and Cin = '1' else
            '1' when a = '0' and b = '0' and Sin = '1' and Cin = '0' else
            '1' when a = '0' and b = '1' and Sin = '1' and Cin = '0' else
            '1' when a = '0' and b = '1' and Sin = '0' and Cin = '1' else
            '1' when a = '1' and b = '0' and Sin = '0' and Cin = '1' else
            '1' when a = '1' and b = '0' and Sin = '1' and Cin = '0' else
            '1' when a = '1' and b = '1' and Sin = '0' and Cin = '0' else
            '1' when a = '1' and b = '1' and Sin = '1' and Cin = '1' else
            '0';
    Cout &lt;= '1' when a = '0' and b = '0' and Sin = '1' and Cin = '1' else
            '1' when a = '0' and b = '1' and Sin = '1' and Cin = '1' else
            '1' when a = '1' and b = '0' and Sin = '1' and Cin = '1' else
            '1' when a = '1' and b = '1' and Sin = '0' and Cin = '1' else
            '1' when a = '1' and b = '1' and Sin = '1' and Cin = '0' else
            '1' when a = '1' and b = '1' and Sin = '1' and Cin = '1' else
            '0';

end mult;


Used it as a component in an NxM multiplier:

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

entity generic_mult is
        generic (bits: integer);
 port (
  a     :  in std_logic_vector(bits-1 downto 0);
  b     :  in std_logic_vector(bits-1 downto 0);
  answer:  out std_logic_vector(bits*2-1 downto 0)      --sum-out
  );
end entity generic_mult;

architecture behavioral of generic_mult is

 component mult is
  port (
    a    :  in std_logic;
    b    :  in std_logic;
    Sin  :  in std_logic;       --sum-in
    Cin  :  in std_logic;       --carry-in
    Sout :  out std_logic;      --sum-out
    Cout :  out std_logic       --carry-out
  );
 end component;

        type mem_word  is array (0 to bits) of std_logic_vector(bits downto 0);

        signal  carry_internal : mem_word;
        signal  sum_internal : mem_word;

  begin
    this_is_label: for N in 1 to bits generate --Im sorry, my labels are horrible :(
        this_is_label3: for M in 0 to bits-1 generate

            this_is_label2: mult
          port map (
            a =&gt; a(N-1),
            b =&gt; b(M),
            Cin =&gt; carry_internal(M)(N),
            Cout =&gt; carry_internal(M+1)(N),
            Sin =&gt; sum_internal(M)(N),
            Sout =&gt; sum_internal(M+1)(N-1)
        );
    end generate;
end generate;
    labellll: for N in 0 to bits-1 generate
        sum_internal(N+1)(N) &lt;= carry_internal(N)(N);
    carry_internal(0) &lt;= (others =&gt; '0');
    sum_internal(0)   &lt;= (others =&gt; '0');

    answer(bits*2-1) &lt;= carry_internal(bits)(bits);
    answer(bits downto 0) &lt;= sum_internal(bits);
    end generate;
end behavioral;


And a testbench for it:

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

entity NM_mult_tb is
end NM_mult_tb;

architecture behavioral of NM_mult_tb is
    component generic_mult

        generic (bits: integer := 4);
 port (
  a     :  in std_logic_vector(bits-1 downto 0);
  b     :  in std_logic_vector(bits-1 downto 0);
  answer:  out std_logic_vector(bits*2-1 downto 0)      --sum-out
  );
    end component;
   --declaring inputs and initializing them
        signal a  :  std_logic_vector(3 downto 0) :=""0101"";
        signal b  :  std_logic_vector(3 downto 0) :=""1010"";
        signal Sin:  std_logic_vector(3 downto 0) :=""0000"";
        signal Cin:  std_logic := '0';
   --declaring outputs and initializing them
        signal answer :  std_logic_vector(7 downto 0);  --sum-out
        signal correct:  std_logic;                     --carry-out

BEGIN
    -- Instantiating the Design Under Test (DUT)
   dut: generic_mult
        GENERIC MAP (4)
        PORT MAP (
          a =&gt; a,
          b =&gt; b,
         answer =&gt; answer
        );

   -- Stimulus process
    correct &lt;= '1' when to_integer(unsigned(a))*to_integer(unsigned(b)) = 
to_integer(unsigned(answer)) else '0';
  stim_proc: process
   begin
        wait for 1 ns;
        a &lt;= a + 1;
        if a = ""0"" then b &lt;= b + 1; end if;
  end process;

END;


When I simulate it I see that there is something wrong with carry-ins and sum-ins and outs and my answer has undefined bits in it:



If you have read my post this far, thank you very much for your attention. If someone could find the time to help me out with my problem I would be very grateful!

Sincerely,
A confused VHDL beginner","Libraries

So, for doing arithmetic you only need one arithmetic library: numeric_std. Don't use std_logic_arith because it is not standardized, so behavior can differ between implementations.

Then std_logic_unsigned could be risky. Jim Lewis explains here that its could be a good idea to use it, but I think that you should not. Better to use integer, unsigned and signed data types for all comparisons.



Entity mult

What you are implementing is lookup-tables. Combinatorial logic statements. This is not arithmetic, so no arithmetic libraries are needed.

However, you could simplify the code.
Let's take this description ar reference.

The 1x1 multiplier can be defined using logic operators (based on a full adder described here):

architecture rtl of mult is
    signal FA_a, FA_b : std_logic;
begin
    FA_a &lt;= Sin;
    FA_b &lt;= a AND b;
    Sout &lt;= FA_a XOR FA_b XOR Cin;
    Cout &lt;= (FA_a AND FA_b) OR (Cin AND (FA_a XOR FA_b));
end architecture;


Or just skip this all and use the addition operator, which does the logic for you.

architecture rtl of mult is
    use ieee.numeric_std.all;
    signal FA_a, FA_b, FA_Cin : unsigned(1 downto 0) := (others =&gt; '0');
    signal FA_out : unsigned(1 downto 0);
begin
    FA_a(0) &lt;= Sin;
    FA_b(0) &lt;= a AND b;
    FA_Cin(0) &lt;= Cin;
    FA_out &lt;= FA_a + FA_b + FA_Cin;
    Sout &lt;= FA_out(0);
    Cout &lt;= FA_out(1);
end architecture;




Entity generic_mult

First off, your multiplier is MxM, not MxN.
Next you complain about your labels in the comments... would take just as much effort to change them ;).

Regarding your implementation, you are assigning signals multiple times in the labellll generate block. It should be:

labellll: for N in 0 to bits-1 generate
    sum_internal(N+1)(N) &lt;= carry_internal(N)(N);
end generate;

carry_internal(0) &lt;= (others =&gt; '0');
sum_internal(0)   &lt;= (others =&gt; '0');

answer(bits*2-1) &lt;= carry_internal(bits)(bits);
answer(bits downto 0) &lt;= sum_internal(bits);


but this is not the biggest problem, as it can be resolved.
The problem you do have, has to do with multiple drivers. In this_is_label2 you have the line:

Sout =&gt; sum_internal(M+1)(N-1)


And in labellll you have the line:

sum_internal(N+1)(N) &lt;= carry_internal(N)(N);


Two statements, which are both assigning a value to sum_internal. If both 1 and 0 are assigned, this will resolve to X.

But this is not necesary, because it is the result of an error in your design. Please see my link again to see how you should implement the multiplier. I'm not going to do it for you (it's not that difficult and probably your homework. You don't learn anything if other people do your homework for you. ;) )



Testbench

You're combining unsigned arithmetic (to_integer(unsigned(a))*to_integer(unsigned(b))) with std_logic_vector arithmetic (a &lt;= a + 1;). Don't do that. Preferably only use unsigned.



using the multiplication operator

As stated by pev.hall, you could just simplify everything and use the multiplication operator from the numeric_std package.

entity generic_mult is
    generic (
        M: positive;
        N: positive
        );
    port (
        a : in std_logic_vector(M-1 downto 0);
        b : in std_logic_vector(N-1 downto 0);
        answer : out std_logic_vector(M+N-1 downto 0)
    );
end entity;

architecture rtl of generic_mult is
    use ieee.numeric_std.all;
begin
    answer &lt;= std_logic_vector(unsigned(a)*unsigned(b));
end architecture;
",,,,,
How to check for unknown registers in verilog,"When getting three inputs from the console, I am wondering how to check and 'warn' the user that a register may not have been initialized. 

to do this I am trying:

flag = $value$plusargs(""a=%b"", a);
if (flag != 0 &amp;&amp; flag != 1) begin
    $display(""a might not be initialized"");
end
flag = $value$plusargs(""b=%b"", b);
flag = $value$plusargs(""c=%b"", c);

#1 $display(""a=%b b=%b c=%b z=%b"", a, b, c, z);


However with my limited knowledge I am having a difficult time figuring out what to do. When I run my compiled code with no paramaters I get:

a = x, b = x, c = x, z = x;

but no warning, even though the flag(a) is clearly not 1 and not 0 ","flag returns true(1) if $value$plusargs finds +a=value on the command line and sets the value of a. So you want

if (flag == 0) begin
    $display(""a might not be initialized"");


You can do this in one step

  if ( !$value$plusargs(""a=%b"", a) ) begin
        $display(""a might not be initialized"");


And if you use SystemVerilog, you can use $warning() instead of $display(). ",,,,,
Counting of different channels diverge and jumps,"I'm trying to realize a counting module. My basic setup:
FPGA (Digilent's Arty with Xilinx Artix-35T) with two BNC cables attached to IO ports connected to a signal generator and via USB/UART to the PC for reading out. My signal generator produces with, say, 1 Hz some TTL signal.

I now want to count the amount of events in channel 1, in channel 2 and the coincidences of channels 1 and 2. While the basic principle works, I see channels 1 and 2 separate, even though they have the same input (via BNC-T connector). Also, sometimes one of the output channels jumps - in either direction, see figure.

The violet channel (""Channel 1"") has a different slope than green (""Channel 2""). Also the coincidences make here two little lossy jumps. 

My sequential counting code looks like

reg [15:0] coinciInt [(numCoincidences -1):0]; // internally store events
always @(posedge clk or posedge reset)    // every time the clock rises...
begin
    signalDelay &lt;= signal;                // delayed signal for not counting the same event twice

    if(reset)                             // reset
    begin
        for(i=0;i&lt;numCoincidences;i=i+1) 
            coinciInt[i] &lt;= 16'b0;
    end
    else                                  // No reset
    begin
        for(i=1;i&lt;numCoincidences;i=i+1)   // loop through all coincidence possibilities:
        begin 
            if( ((signal &amp; i) == i) &amp;&amp; ((signalDelay &amp; i) != i) )   // only if signal give coincidence, but did not give before, it's a coincidence
            begin                         // ""(signal &amp; i) == i"" means that ""signal"" is checked if bitmask of ""i"" is contained: 
                                          // ((0011 &amp; 0010) == 0010) is true, since 0011 &amp; 0010 = 0010 == 0010  
                coinciInt[i] &lt;= coinciInt[i] + 1'b1;    // the i-th coincidence triggered, store it
            end
        end
    end
end // end of always

assign coinci = coinciInt;  // the output variable is called coinci, so assign to this one


Please note that all events are in the register coinci - coincidences as well as 'single events'. Ideally, coinci[1] should store events of channel 1, coinci[2] these of channel 2 and coinci[3] coincidences between 1 and 2, since channels are labelled by 1,2,4,8,...,2^n and coincidences by the respective sum. coinci[0] is used for some kind of checksum, but that's off-topic now.

Are there any ideas for the missing counts? For the different slopes? 

Thank you very much

Edit 1

@Brian Magnuson pointed to the meta stability issue. Using multi-buffered inputs solved the issue of diverging channels. That works nicely. Although I don't fully understand the reason for this, I also did not see any jumps in the coincidence channel so far. You probably save me a lot of time, thanks!","I would suspect a meta-stability problem.  Your incoming pulses on ch1/ch2 are probably not synchronized with the system clock you are using. See here.

Because of this you are probably sometimes catching the counter updates 'mid-stride' so to speak which will cause unexpected behavior.

To fix this you can flop the inputs twice (called a dual-rank synchronizer) before feeding them into the rest of your logic.  Usually multi-bit synchronization requires a bit more careful handling but in your case each bit can be treated independently.",,,,,
VHDL and Verilog not dependent on technology?,"When designing something(for example CPU) in VHDL or Verilog and the design is completed, is design limited to a certant manufacturing process(14nm) or it can work on any(10,7,5,3nm) process that is currently available?",It's a hardware description language and thus technology independent. Both support technology specifics by instantiation of technology primitives.,,,,,
Representing 2 binary digits in hex for vhdl,"In VHDL, If X'1 => ""0001"", X'3 => ""0011"". i.e, 1 hex digit represents 4 binary values, how do i represent only 2 binary values in hex given that i have only a specific bit range in memory. In this case 2. For instance, the space left in memory can only take 2 bits. I know i can still use the initial representation and mask out either the two msb's or lsb's but is there another way ? ","You can do this if you are using VHDL-2008:

2X""2"" = ""0010""


Further examples from web:

unsigned notation (default):

7UX""F""  = ""0001111"" -- extend
7UX""0F"" = ""0001111"" -- reduce


signed noataion:

7SX""F""  = ""1111111"" -- extend
7SX""CF"" = ""1001111"" -- reduce
",,,,,
How to toggle a std_logic between 1 and 0,"I want to toggle a std_logic vector '1' and '0' everytime the input sel='1'.
I tried this with the following method but both lines give an error.

selected &lt;= not selected when sel='1';



  ERROR: This construct is only supported in VHDL 1076-2008


selected &lt;= ~selected when sel='1';



  ERROR: Syntax error near ""~""


Is there a better way to toggle, or what is the right syntax for a 'not' function.

Here is the code for the entire architecture:

architecture Behavioral of selWeerg is

signal selected : std_logic;

begin   
process(sel,digl,sysclk)
begin
    if rising_edge(sysclk) then

        selected &lt;= ~selected when sel='1';

        if selected = '0' then
            digO1&lt;=digl(3 downto 0);
        else
            digO2&lt;=digl(3 downto 0);
        end if;
    end if;
end process;
end Behavioral;
","The error message is telling you it doesn't work: the code you are writing is only supported in VHDL-2008, not in previous versions. In previous versions, it is illegal to use the when-else construct inside a process. Why? Who knows? Which is probably why it was made legal in VHDL-2008.

So, you either need to enable VHDL-2008 compilation on your simulator or use an if statement instead. Using VHDL-2008 is not a decision to be taken lightly, because many tools don't understand it. ",,,,,
"Error: D:/velilog/bubu.vhd(3): near ""clock_in"": (vcom-1576) expecting END","I am trying to make a fsm in vhdl using modelsim but when i try and compile my code i have this errors

enter code here
entity timer_50Mhz is
    generic(count : integer range 0 to 50000000 := 2);    
        clock_in : in  STD_LOGIC;
           clock_out : out  STD_LOGIC);
end timer_50Mh
z;
architecture Behavioral of timer_50Mhz is
begin
 process(clock_in)
 variable temp :integer range 0 to 5000000 := 0; 
 begin
  if(rising_edge(clock_in)) then 
   if(temp = count-1) then
    temp :=0;
    clock_out &lt;='1';
   else
    temp := temp + 1;
    clock_out &lt;='0';
 end process;

end Behavioral;


I would appreciate it if you could solve it.","This

entity timer_50Mhz is
    generic(count : integer range 0 to 50000000 := 2);    
        clock_in : in  STD_LOGIC;
        clock_out : out  STD_LOGIC);
end timer_50Mhz;


should be this:

entity timer_50Mhz is
    generic(count : integer range 0 to 50000000 := 2);    
    port(
        clock_in : in  STD_LOGIC;
        clock_out : out  STD_LOGIC);
end timer_50Mhz;
",,,,,
Verilog task based TB issue,"I am quite new to verilog, specially using it for TB coding and I am facing the following issue - 

I am working on verifying round-robin (RR) arbiter and want to check the DUT grant with a TB modeled grant. I am writing a task to implement the TB model and then calling the task at every posedge of clock as follows - 

  always @(posedge clk or posedge reset) begin 
  if(reset) reset_state;//task to reset state
  else begin
    //Initialising req vector every cycle
    req_vc = {req4, req3, req2, req1, req0};
    for (index=0; index&lt;5; index=index+1) begin 
      temp[index] = rr_pri_state[index]; 
    end
    chk_grant; //task that gives out checker grant
    **if(gnt_id_checker != gnt_id)** begin//logic to compare checker grant with DUT grant (gnt_id) and end test if false 
    $display (""\tERROR!! Model grant and DUT grant IDs MISMATCH.\n\t\tModel grant = %d\n\t\tDUT grant = %d "", gnt_id_checker, gnt_id);
    #1 $finish;
    end
  end
 end


All my variables are globally defined

The issue is with the if comparison just after chk_grant task is called. When I simulate this I see that the values for gnt_id and gnt_id_checker used for comparison are not being updated to the latest one for that cycle. It is still performing comparison on old values. If i introduce #1 delay before if statement then everything works as expected with the correct values. 

So I want to understand if this is expected or if I have approached this incorrectly? 

Here is how my chk_grant task looks like for your reference. It basically finds out highest priority requestor and updated memory to reflect the new priority order

//task to calculate checker grant AND update priority state for next cycle
task chk_grant;
begin
i=0;
while (i&lt;5) begin
  req_index = rr_pri_state[i]; 
  if(req_vc[req_index]) begin //we have found the req getting grant this cycle
    gnt_id_checker = req_index; 
    k = 5-(i+1); //i+1 req will have the highest priority next cycle
    for (j=0; j&lt;k; j=j+1) begin
      rr_pri_state[j] = temp[i+j+1];
    end
    for (j=0; j&lt;=i; j=j+1) begin
      rr_pri_state[j+k] = temp[j];
    end
    i=5; 
    end //end of if
  i=i+1;
  end //end of while loop
end
endtask


PS - I have no particular reason for using task here. If you think an event/function is better here please do let me know how and why so. Any other inputs for improving this would be much appreciated. Thanks!","Not sure if theres anything wrong with the approach you are taking (ie, doing the work in a separate task, which in my mind makes more sense than a function as you are updating a few globals, not just getting the gnt_id_checker. If it was just getting a single value out, I would use a function).

The reason you need a #1 is that when the design run, I assume gnt_id comes from a NBA (&lt;=) from some register. Thus you are updating your gnt_id_checker in the current process right away (blocking assignment, =) but the assignment of gnt_id is delayed into the postponed region and thus not being used by the if-statement in performing the check. If it happens you are updating gnt_id combinationally, then theres a race condition between this block and that assigning gnt_id. Im assuming theres another block actually providing the stimulus to the design which is hard to tell without more information on your variables. If this same block is providing the stimulus, you definitely not giving your design a chance to run before checking the result (which it basically comes down to either way).

So to answer you directly, yes, this is expected and no, your general approach looks fine. Though for stylistic comments, I would suggest calling your checker a golden model as that is what you are doing. So, the task might be called run_golden instead (checkers are a thing in SystemVerilog as a separate concept). And would move temp into the task so the golden model is entirely contained within the task.",,,,,
Carry/Borrow in VHDL ALU,"I am making a generic N-bit ALU in VHDL.  I am having trouble assigning the value for the carry for addition, or borrow for subtraction.  I have tried the following: 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL; 

entity alu is
    generic(n: integer :=1); --Default to 1
    port (
        a : in std_logic_vector(n-1 downto 0);
        b : in std_logic_vector(n-1 downto 0);
        op : in std_logic_vector(1 downto 0);
        output : out std_logic_vector(n-1 downto 0);
        carryborrow: out std_logic 
    );
end alu;

architecture Behavioral of alu is
    signal result: std_logic_vector(n downto 0); 
begin
process( a, b, op )
begin
    case op is
    when ""00"" =&gt; 
        result(n) &lt;= '0'; 
        result(n-1 downto 0) &lt;= a and b; --and gate 
        output &lt;= result(n-1 downto 0); 
        carryborrow &lt;= '0'; 
    when ""01"" =&gt; 
        result(n) &lt;= '0'; 
        result(n-1 downto 0) &lt;= a or b; --or gate 
        output &lt;= result(n-1 downto 0); 
        carryborrow &lt;= '0'; 
    when ""10"" =&gt; 
        result(n) &lt;= '0'; 
        result(n-1 downto 0) &lt;= std_logic_vector(signed(a) + signed(b)); --addition
        output &lt;= result(n-1 downto 0); 
        carryborrow &lt;= result(n); 
    when ""11"" =&gt; 
        result(n) &lt;= '0';
        result(n-1 downto 0) &lt;= std_logic_vector(signed(a) - signed(b)); --subtraction
        output &lt;= result(n-1 downto 0); 
        carryborrow &lt;= result(n); 
    when others =&gt; 
        NULL; 
    end case; 

end process;

end Behavioral;


This seems to set the carryborrow bit to always be 0.  How can I assign it to what it should be without type errors? ","There are bugs in your code:

i) You have not taken into account the fact that signals are not updated immediately. Consequently, the following lines will not do as I think you are expecting:

    result(n) &lt;= '0'; 
    result(n-1 downto 0) &lt;= a and b; --and gate 
    output &lt;= result(n-1 downto 0); 


Instead, you need to take the lines driving output and carryborrow outside the combinational process, as you can see below.
ii) Assuming you wish this code to be synthesisable, simply putting NULL in your always branch will result in latches being inferred. You need to drive result in the others branch, too.

So, making an assumption about how your carry output is to behave with the and and or operations, this is how I would have written your code:

architecture Behavioral of alu is
    signal result: std_logic_vector(n downto 0); 
begin
process( a, b, op )
begin
    case op is
    when ""00"" =&gt; 
        result &lt;= '0' &amp; (a and b); --and gate 
    when ""01"" =&gt; 
        result &lt;= '0' &amp; (a or b); --or gate 
    when ""10"" =&gt; 
        result &lt;= std_logic_vector(resize(signed(a), n+1) + resize(signed(b), n+1)); --addition
    when ""11"" =&gt; 
        result &lt;= std_logic_vector(resize(signed(a), n+1) - resize(signed(b), n+1)); --subtraction
    when others =&gt; 
        result &lt;= (others =&gt; 'X');
    end case; 
  end process;

  output &lt;= result(n-1 downto 0); 
  carryborrow &lt;= result(n); 

end Behavioral;
",,,,,
Assigning Records VHDL,"Good time to everyone.

Resently I try to improve code in new project and found some interesting decoder.
It has 2 processes: in first all data formed and in second all bus triggered in out registers by control signal. But some wires need to be reset in some period of time (in second process).

So I deside to write this code for correct resettind some signals ([cm_regA/cm_regB] are records with different types of data):

----------------------------------------
LOAD_DATA_PROCESS: process(clk_i)
begin
  if rising_edge(clk_i) then
    if (reset_reg) then
      cm_regB.reg_1 &lt;= '0';
      cm_regB.reg_2 &lt;= '0';
      cm_regB.reg_3 &lt;= '0';
      cm_regB.reg_4 &lt;= '0';
    else
      if (load_reg) then
        cm_regB &lt;= cm_regA;
      else null;
      end if;
    end if;
  end if;
end process;
----------------------------------------


But this construction Synthesized with lot of multiplexers betwen reg_5...reg_10, so next code give me good synthesized construction and great speed:

----------------------------------------
LOAD_DATA_PROCESS: process(clk_i)
begin
  if rising_edge(clk_i) then
    if (reset_reg) then
      cm_regB.reg_1 &lt;= '0';
      cm_regB.reg_2 &lt;= '0';
      cm_regB.reg_3 &lt;= '0';
      cm_regB.reg_4 &lt;= '0';
    else
      if (load_reg) then
        cm_regB.reg_1 &lt;= cm_regA.reg_1;
        cm_regB.reg_2 &lt;= cm_regA.reg_2;
        cm_regB.reg_3 &lt;= cm_regA.reg_3;
        cm_regB.reg_4 &lt;= cm_regA.reg_4;
      else null;
      end if;
    end if;

    if (load_reg) then
      cm_regB.reg_5  &lt;= cm_regA.reg_5;
      cm_regB.reg_6  &lt;= cm_regA.reg_6;
      cm_regB.reg_7  &lt;= cm_regA.reg_7;
      cm_regB.reg_8  &lt;= cm_regA.reg_8;
      cm_regB.reg_9  &lt;= cm_regA.reg_9;
      cm_regB.reg_10  &lt;= cm_regA.reg_10;
    else null;
    end if;

  end if;
end process;
----------------------------------------


So the questions next:


How make this construction more compact (like first example)?
Or how to make any changes in buses [cm_regA/cm_regB] visible for second example (in case changing first process and forgot add this changes to LOAD_DATA_PROCESS)?


P.S. Type of cm_regA and cm_regB are declarated in package. Here it is:

----------------------------------------
type cm_t is record
    reg_1   : STD_LOGIC;
    reg_2   : STD_LOGIC;
    reg_3   : STD_LOGIC;   
    reg_4   : STD_LOGIC;
    reg_5   : STD_LOGIC;
    reg_6   : BOOLEAN;
    reg_7   : STD_LOGIC;
    reg_8   : STD_LOGIC;
    reg_9   : STD_LOGIC_VECTOR(CONST_1-1 downto 0);
    reg_10  : STD_LOGIC_VECTOR(CONST_2-1 downto 0);
end record cm_t;
----------------------------------------
","In the case of your first code, you are indeed adding a dependency to reset for reg_5 to reg_10. This is because of the if-else statement. This is the effective code you write for these registers.

if not(reset_reg) and load_reg then
    cm_regB.reg_5 &lt;= cm_regA.reg_5;
    [...]
    cm_regB.reg_10 &lt;= cm_regA.reg_10;
end if;


So, you should separate the reset block from the other assignment. You can achieve that by using the fact that for signals only the last assignment in a process will be applied the next delta cycle. So something like this:

LOAD_DATA_PROCESS: process(clk_i)
begin
    if rising_edge(clk_i) then
        if load_reg then
            cm_regB &lt;= cm_regA;
        end if;
        if reset_reg then
            cm_regB.reg_1 &lt;= '0';
            cm_regB.reg_2 &lt;= '0';
            cm_regB.reg_3 &lt;= '0';
            cm_regB.reg_4 &lt;= '0';
        end if;
    end if;
end process;
",,,,,
return unconstrained array in vhdl,"what's the best way to return an unconstrained vector in vhdl?

function func(selector : natural) return std_logic_vector is
begin
    case selector is
        when 3 =&gt; return std_logic_vector(""11"");
        when 4 =&gt; return std_logic_vector(""101"");
        when others =&gt; return std_logic_vector(""0"");
    end case;
end function;


In this case i get string literal cannot be a type conversion operand, so it doesn't work. The signal selector is generic, so it don't have to be synthesizeable. ","You can't do this. The return value from your function will need to be associated with something when it is called and that something will have to be of a fixed width. In other words, you'll have to say thing like:

s &lt;= func(n);


and s will have a fixed width, so all the return values from your function will have to have the same width. ",,,,,
System verilog: if loop inside always block not executing,"I wrote a piece of code to assert a signal (val_changed) synchronously when another 64-bit signal (val) changes value by more than a threshold. Later this signal need to be de-asserted based on a third signal's (adj_in_prog) negedge.

Here clk and val are inputs to the block.

logic [63:0] val_reg;

 always @(posedge clk) begin
    val_reg &lt;= val;
 end

 always @(posedge clk) begin
    if ((val - val_reg) &gt; 64'hFFFFF) //Threshold = 64'hFFFFF
          val_changed &lt;= 1'b1;
    @(negedge adj_in_prog);
    val_changed &lt;= 1'b0;
 end


I understand that the above method is not the cleanest of ways to do it, but since this is test-bench code and so I don't need to synthesis this, thought of experimenting. But this code is not working as val_changed is not going 1. I would like to know why the if loop won't execute. As per me, val_changed should have gone high at the clock edge where marker is positioned in the waveform attached. Can someone please help? (waveform values are in hex)

","in your case at the very first posedge of clk the second always block starts executing and processes the 'if' statement. Then it sticks at the @(negedge adj_in_prog) statement, waiting for the event. On the next clock edge it will continue waiting and will not re-enter and evaluate the 'if' statement, and so on. So, this explains why it is not progressing. 

so, assuming that the adj_in_prog is turned on at val_changed changing to one, the following should work for you.

always @(posedge clk) begin
    if ((val - val_reg) &gt; 64'hFFFFF) //Threshold = 64'hFFFFF
      val_changed &lt;= 1'b1;
    else if (!adj_in_prog);
      val_changed &lt;= 1'b0;
end
",,,,,
FSM Mealy Machine Sequence Detector. How to use multiple flip flops?,"Right now I am working on a small project in Vivado, a Mealy FSM. The program must detect a 6 bits sequence 001011, and output ""1"" when the sequence is detected. 

The code concerning the sequence detection is doing just fine, but besides that, it must also use Three Flip Flops: JK, D, and T.

Any advice or suggestions on how to add them?  

Thank you for your time.

This is the FSM code:

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;


entity sequence is
port(
    clk : in std_logic;
    reset : in std_logic;
    x: in std_logic;
    z : out std_logic;
    a : out std_logic;
    b : out std_logic;
    c : out std_logic;
    d : out std_logic;
    e : out std_logic;
    f : out std_logic);
end sequence;

architecture behavioral of sequence is


type state_type is (Q0, Q1, Q2, Q3, Q4, Q5);


signal state, next_state : state_type;

begin


state_register: process (clk, reset)
  begin
    if (reset = '1') then   --if reset is high, goto state Q0
       state &lt;= Q0;
    elsif (clk'event and clk = '1') then    --if not, and rising 
       state &lt;= next_state;                 --edge, go to next state
    end if;
end process;  


next_state_func: process (x, state)
begin 
  case state is 
      when Q0 =&gt;
          if x = '0' then
             next_state &lt;= Q1;
          else 
             next_state &lt;= Q0;
          end if;
      when Q1 =&gt;
           if x = '0' then
             next_state &lt;= Q2;
           else
             next_state &lt;= Q0;
           end if;
      when Q2 =&gt;
           if x = '1' then
              next_state &lt;= Q3;
           else 
              next_state &lt;= Q2;
           end if;
      when Q3 =&gt;
           if x ='0' then
              next_state &lt;= Q4;
           else
              next_state &lt;= Q0;
           end if;
      when Q4 =&gt;
           if x = '1' then
              next_state &lt;= Q5;
           else
              next_state &lt;= Q2;
           end if;
      when Q5 =&gt;
           if x = '1' then
              next_state &lt;= Q0;
           else
              next_state &lt;= Q1;                       
           end if;
      end case;
end process;

-- This process controls the output of the sequence detector.
-- Each state has it's own output along with 'z' which indicates
-- the entire sequence 001011 has been detected.
output_func:  process (x, state)
  begin
  case state is 
      when Q0 =&gt; z &lt;= '0';
           a &lt;= '1';
           b &lt;= '0';
           c &lt;= '0';
           d &lt;= '0';
           e &lt;= '0';
           f &lt;= '0';
      when Q1 =&gt; z &lt;= '0';
           a &lt;= '0';
           b &lt;= '1';
           c &lt;= '0';
           d &lt;= '0';
           e &lt;= '0';
           f &lt;= '0';
      when Q2 =&gt; z &lt;= '0';
           a &lt;= '0';
           b &lt;= '0';
           c &lt;= '1';
           d &lt;= '0';
           e &lt;= '0';
           f &lt;= '0';
      when Q3 =&gt; z &lt;= '0';
           a &lt;= '0';
           b &lt;= '0';
           c &lt;= '0';
           d &lt;= '1';
           e &lt;= '0';
           f &lt;= '0';
      when Q4 =&gt; z &lt;= '0';
           a &lt;= '0';
           b &lt;= '0';
           c &lt;= '0';
           d &lt;= '0';
           e &lt;= '1';
           f &lt;= '0';
      when Q5 =&gt; z &lt;= '1';
           a &lt;= '0';
           b &lt;= '0';
           c &lt;= '0';
           d &lt;= '0';
           e &lt;= '0';
           f &lt;= '1';
    end case;
  end process;

end behavioral;


[1]: https://i.stack.imgur.com/pVwxL.jpg - and here is the table that contains the State Diagram Table of the FSM.","Your code is wrong. Take a look at the output_func process; this is combinatorial, and just decodes the current state, without looking at x. The a to f outputs aren't necessary, and are just a 6-bit decode of the current state - why? The z output is set when the current state is Q5, which isn't what you want - the whole process is redundant. You need to set z in your main FSM, when the current state is Q5, and x is 1 - ie. on the next_state &lt;= Q0 transition.

On your actual question - you can't force selection of any particular F/F type with this code - the synthesiser will do whatever it wants, which means that it will implement the whole thing in D types, since JKs have been obsolete for the last 20 years. The same is probably true of T types. You need to start again, and pretend that you have a technology and a library with T, D, and JK. Write these yourself as separate entities, and re-write your code to instantiate these components, instead of allowing the synthesiser to infer them. Re-write your FSM to use JKs - the diagram you gave shows you how. In other words, derive the J and K inputs to each F/F. The z output can be a D-type. You should be able to fit in a T somewhere - I've left that as an exercise for you. ",,,,,
"Why verilog ""always_comb block contains only one event control"" error flagged on always procedural block with multiple ""@""","the following code below generates this error message:


  ""verilog always_comb imposes the restriction that it contains one and only one event control and no blocking timing controls""


always_comb begin
if (sig_a)begin
 @(posedge sig_b); // wait for a sig_b posedge event
 @(negedge sig_b); // then wait for a sig_b negedge event
 event_true=1;  
end

if (event_true)begin
  @((sig_c==1)&amp;&amp;(sig_a==0)); //wait for sig_a to deassert and sig_c assert event to be true
  yes =1;
 end
 else yes =0;

end


Why does the combi logic procedural block generate this error ?

And would an always block with @ event wait be synthesizable ? ","The message reported by that error is misleading. You are not allowed ANY event controls in an always_comb block. It creates the event sensitivity list automatically for you. Maybe it is combining the implicit event control with the ones you added to it, then generating the error. 

Unless you are using a high-level synthesis tool, you are restricted to having one event control at the beginning of a basic always block.",,,,,
Trouble with setting my inputs and outputs ( A complement is direct input(-ed) ),"This is the circuit-> http://prntscr.com/lceyql i want to implement(structural) and i am having trouble setting inputs and outputs due to the A complement(A and A complement). 

I am new to verilog. 

I also want to run a test on the circuit(running it on ModelSim) and i dont know how can i achieve all the 0-1 combinations since there is A and A'(probably will be autoanswered if first question is answered)...meaning something like that:

initial
begin
    InA=0; InB=0; InC=0; InD=0; InE=0;
    # 10 InA=0; InB=0; InC=1;
    # 10 InA=0; InB=1; InC=0;
    # 10 InA=0; InB=1; InC=1;
    # 10 InA=1; InB=0; InC=0;
    # 10 InA=1; InB=0; InC=1;
    # 10 InA=1; InB=1; InC=0;
    # 10 InA=1; InB=1; InC=1;
    # 10 $stop;
end


The module:

module circuit1 (A, B, C, D, E, F);

input A, B, C, D, E;
output F; 
wire w1, w2, w3, w4, w5; 

nand G1 (w1, A, B);
or G2 (w2, C, D); 
nor G3 (w3, E, C);
nor G4 (w4, w1, w2);
nand G5 (w5, w2, w3);
xor G6 (F, w4, w5);


endmodule
","I think in order to achieve what you want you can remove E input and replace nor G3 line with nor G3 (w3, ~A, C); That means you provide the complement of A as input",,,,,
Yocto find the recipe or class that defines a task,"I am a yocto noob, trying to decipher how the device tree is built from a Xilinx hardware definition (.hdf) file. But my question is more general. 

Is there a yocto way to find the source of task?
Given a task name is it possible to find where the tasks source code lives? (presumably in a recipe or class)

As an example, where is the source for the Python task do_create_yaml which is called by recipes in the meta-xilinx-bsp layer that compile the device tree blob? 

bitbake -e device-tree


Will dump the python source for do_create_yaml (amongst the rest of it prodigious output) but how can I find where that is coming from?","I found that the datastore contains the filename for tasks as a VarFlag,
from a devpyshell

pydevshell&gt; d.getVarFlags(""do_create_yaml"")


gives

{'filename': '.....yocto/sources/core/../meta-xilinx-tools/classes/xsctyaml.bbclass', 'lineno': '61', 'func': 1, 'task': 1, 'python': '1', 'deps':   ['do_prepare_recipe_sysroot']}


So for the example in my question the active definition for the do_create_yaml task is in xsctyaml.bbclass.  ",,,,,
Individual binding for unpacked array elements in SystemVerilog,"In synthesizable SystemC I can bind each element of vector of ports individually:

SC_MODULE(submodule)
{
    sc_vector&lt;sc_in&lt;int&gt; &gt;  SC_NAMED(in_vec, 3);  
};

SC_MODULE(top) {
    submodule               SC_NAMED(submod_inst);
    sc_signal&lt;int&gt;          SC_NAMED(a);
    sc_signal&lt;int&gt;          SC_NAMED(b);
    sc_signal&lt;int&gt;          SC_NAMED(c);

    SC_CTOR(top) {
        submod_inst.in_vec[0].bind(a);
        submod_inst.in_vec[1].bind(b);
        submod_inst.in_vec[2].bind(c);
    }
};


Is there a way to do the same in synthesizable SystemVerilog?

module submodule (
    input logic[31:0]   in_vec[3];
);

endmodule

module top ();

    logic [31:0] a;
    logic [31:0] b;
    logic [31:0] c;

    submodule submod_inst (
//        What should I put here?
//        .in_vec[0] (a),  /// ERROR!!
//        .in_vec[1] (b),
//        .in_vec[2] (c)
    );


endmodule
","Have you tried 

.in_vec('{a, b, c})


Or you can create a array and assign individual value to it. Then bind the array signal to sub module.",,,,,
Eclipse SVEditor plugin not finding path,"I'm new to Verilog, so I apologize for my question doesn't make sense, but I've been trying to set up an eclipse plug-in called SVEditor, and I'm getting this error in the output: [SVDBArgFileParser] Argument file ""${workspace_loc}/chip1/sim/files.f"" (""${workspace_loc}/chip1/sim"") does not exist

Here is the tutorial I was following: http://sveditor.sourceforge.net/tutorial/sveditor_tutorial.html

What am I doing wrong?","Use

 ${workspace_loc:/chip1/sim/files.f}


which works in contrast to ${workspace_loc}/chip1/sim/files.f also when e. g. the project folder chip1 is not a subfolder of the workspace directory, but linked to a different location (which e. g. is usually the case when you use Git).",,,,,
"Error (10500): VHDL syntax error------expecting ""("", or an identifier (""others"" is a reserved keyword), or unary operator","Can anyone see what is wrong with my code?

I copied the code from my textbook, but there are some errors which is not contained in my book.

This are the errors:

library IEEE;
use IEEE.std_logic_1164.all;

entity Moore_State is
port(
    CLK: in STD_LOGIC;
    S: in STD_LOGIC;
    FB: in STD_LOGIC;
    BACK_OUT: out STD_LOGIC;
    FORWARD_OUT: out STD_LOGIC
    );
end Moore_State;

architecture Moore1_arch of Moore_State is
type StateType is (idle,ready,back,forward);
signal state:StateType;
begin
Process(CLK)
begin
if(CLK'event and CLK='1') then

case state is

when idle=&gt;
        if S='1' then state&lt;=ready;
        else state&lt;=idle;
        end if;
when ready=&gt;
        if FB='0' then state&lt;=back;
        else state&lt;=forward;
        end if;
when back=&gt;
        if S='1' then state&lt;=idle;
        else state&lt;=back;
        end if;
when forward=&gt;
        if S='1' then state&lt;=idle;
        else state&lt;=forward;
        end if;

        end case;
    end if;
end Process;

with state select
    BACK_OUT &lt;='1' when back,
            '0' when others;
    FORWARD_OUT &lt;='1' when forward,
            '0' when others;

end Moore1_arch;


and the error messages appear in the last paragraph: 

1.Error (10500): VHDL syntax error at VHDL1.vhd(48) near text "","";  expecting "";""

2.Error (10500): VHDL syntax error at VHDL1.vhd(49) near text ""others"";  expecting ""("", or an identifier (""others"" is a reserved keyword), or  unary operator","You forgot the with-select statement in the second part:

with state select
    BACK_OUT     &lt;= '1' when back,
                    '0' when others;

with state select
    FORWARD_OUT  &lt;= '1' when forward,
                    '0' when others;
",,,,,
How to access Verilog genvar generated instances and their signals,"I need to initialize arrays in generated instances via generate block in Verilog. I'm trying to use the syntax below, however, I get an error as 


  External reference foo[0].bar.array[0] remains unresolved.


in Xilinx ISE.

    integer i, j;
    initial begin
        // initialization of arrays
        for(i=0; i&lt;(2**7); i=i+1) begin
            valid_array[i] = 0;
            for(j=0; j&lt;N; j=j+1) begin
                foo[j].bar.array[i] = 0;
            end
        end
    end


This is my generate block:

    genvar jj;
    generate
        for(jj = 0; jj &lt; N; jj = jj + 1) begin : foo
            Memory_v3
            #(
                .ADDRESS_WIDTH(INDEX),
                .DATA_WIDTH(TAG)
            ) bar
            (
                .clock(clock),
                .we(we),
                .addr_a(addra),
                .addr_b(addrb),
                .din(din),
                .dout(dout)
            );
        end
    endgenerate


What is the correct way to do this?","the problem is that foo block gets resolved at compile time. So, the names like foo[0], foo[1] are pre-generated and are compile-time names, they not work with dynamic index resolution at run-time. Therefore foo[j] will not work.

the solution in this case is to use another generate block to initialize them. Something like the following.

 generate
   for(jj = 0; jj &lt; N; jj = jj + 1) begin : foo_init
      initial begin
         // initialization of arrays
         for(i=0; i&lt;(2**7); i=i+1) begin
            foo[jj].bar.array[i] = 0;
         end
      end
   end
endgenerate


Same story is with array of instances. 

FOO bar[3:0](); // array of instances

int i,j;
generate
   for(jj = 0; jj &lt; 4; jj = jj + 1) begin : foo_init
      initial begin
         for(i=0; i&lt;(2**7); i=i+1) begin
            bar[jj].array[i] = 0;
         end
      end
   end
endgenerate


BTW, in system verilog you can avoid using generate/endgenerate pairs:",,,,,
What happens if we use async reset block with sync reset?,"Consider that I have a common verilog module that I want to be exported to 2 different kinds of designs - one on sync reset and the other on async reset.

What would be the right way to code an always block within this common module so that it works fine in both kinds of designs? I am thinking we can use the async reset block like this - 

always @(posedge clk or negedge reset_) begin
  if(!reset_) temp &lt;= 'd0;
  else &lt;do something&gt;
end


If i use sync reset then in async reset designs i have a problem if clocks start much later than reset assertion-deassertion so the required reset can be completely missed.

In sync reset we know the posedge of clk and negedge of reset_ will coincide always, so is there any issue with that?","You could do this:

always @(posedge clk or negedge async_reset) begin
  if(!async_reset) 
    temp &lt;= 'd0;
  else 
    if (!sync_reset)
      temp &lt;= 'd0;
    else
      &lt;do something&gt; 
end


and then tie one or the other reset to INACTIVE (1'b1 in this case). If you're synthesising to an FPGA, I would imagine it would cost you nothing in area or speed. If you're synthesising to an IC, then I'd check what the synthesiser does with it. ",,,,,
Declare vector ports without specifying their size in Verilog,"When declaring a module in Verilog (2001?), is it possible to tell that some ports are vectors without indicating their size? The goal here is to handle vector ports of any size, without having to specify the sizes through parameters.

I know I can write something like what follows in Verilog, but I'd like to know if there's a way to get rid of the extra WIDTH_DATA parameter:

module my_module
#(
  parameter  WIDTH_DATA = 48
)
(
  input  Clk, En,
  input  [WIDTH_DATA-1:0] Data_in,
  output Ready,
  output reg [WIDTH_DATA-1:0] Data_out
);


This is possible in VHDL, using a declaration like that:

entity my_module is
  port (
    Clk      : in std_ulogic;
    En       : in std_ulogic;
    Data_in  : in std_ulogic_vector;
    Ready    : out std_ulogic;
    Data_out : out std_ulogic_vector
  );
end entity;


The module implementation can then know the size of Data_in at compile time using Data_in'length (same for Data_out).","This is not possible in Verilog.

You can do something close to what you want in SystemVerilog using the interface construct. You can parameterize an interface, and connect that interface (or set of interfaces) to my_module.

interface my_intf #(int WIDTH);
  logic [WIDTH-1:0] data;
endinterface
module my_module(input clk, en,
                 my_intf in, out,
                 output ready);
  // $bits(in.data) - gives you the WIDTH
  // typedef type(out.data)  out_type // local typedef 
endmodule
module top;
  my_intf #(8) I1;
  my_intf #(16) I2;
  bit clk, en, ready;
  my_module M1 (.clk,.en, .in(I1), .out(I2), .ready);
endmodule
",,,,,
Passing an 8-bit value to a 1-bit port?,"I'm using System Verilog. My top-level design file has a 1-bit output bsOut. I'm also using a register called shift_reg, which outputs an 8-bit number from the port dOut. I want to do this:

module FinalTop (
    input clk,
    output bsOut
    );
Shift_Reg shift_reg(.clk(clk), .dOut(bsOut));


I believe that Vivado/Basys3 will truncate dOut by using only the LSB --> bsOut, but what if I want to specify a different bit? For example, what if I want to send .dOut[7](bsOut)? Obviously this won't work (I tried), but I don't know how to do it properly. I could make a logic [7:0] dOutTemp = dOut, then assign bsOut = dOutTemp[7];, but this seems clunky. ","You can use a port expression.

module FinalTop (
    input clk,
    output .bsOut(dOut[7])
    );
logic [7:0] dOut;
Shift_Reg shift_reg(.clk, .dOut);


Note that .clk is equivalent to .clk(clk), etc.",,,,,
Verilog d flipflop circuit testing,"I'm trying to construct a structural implementation of a circuit that consists of a d flipflop, it has inputs x and y, x and y are exclusive or'd and that result is exclusive or'd with the current state, and used as the input to the d flip flop. and it'll use the result state from the flipflop in the next run, etc. But I'm not too sure how to construct it.

The circuit looks like so:


module dff(D,clk,q);
input D,clk;
output q;
reg q;
always @ (posedge clk)
 begin
  q&lt;=D;
 end
endmodule


I'm pretty sure the d flip flop code is correct but when I try to test this my d and state values are just x for some reason. When I put in different x and y values in my testbench nothing happens, ""state"" and ""d"" just always says it has value ""1'hx"" in the simulation. Why is this happening and how do I actually assign an value to them? ","All signals in verilog simulation are initialized to 'x'. So are the values of A and D. Your second xor is applied to xoy ^ A. Since A  is x, the result of this xor is always x. you need to break this loop, as oldfart suggested. 

The usual way for doing it is to introduce a reset in the flop, synchronous or asynchronous. Here is an example of a synchronous reset flop:

always @(posedge clk)
    if (reset)
        q &lt;= 0;
    else 
        q &lt;= D;


So, now, if you set your reset to '1' for at least one posedge of clk and then set it to '0', you will break the loop by pushing a non-'x' value in the data path. ",,,,,
Passing array as argument to a module in SystemVerilog Xilinx,"I have declared the following systemverilog module:

module module_top
    (
        input  logic                              clk,
        input  logic                              rst,
        input  logic signed [7  : 0 ] x_in,
        input  logic signed [5  : 0 ] y_in [24:0]
    );
    module_1 module_1_inst_1( .clk(clk), .rst(rst), .x_in(x_in), .y_in(y_in[4 : 0 ]));
    module_1 module_1_inst_2( .clk(clk), .rst(rst), .x_in(x_in), .y_in(y_in[9 : 5 ]));
    module_1 module_1_inst_3( .clk(clk), .rst(rst), .x_in(x_in), .y_in(y_in[14: 10]));
    module_1 module_1_inst_4( .clk(clk), .rst(rst), .x_in(x_in), .y_in(y_in[19: 15]));
    module_1 module_1_inst_5( .clk(clk), .rst(rst), .x_in(x_in), .y_in(y_in[24: 20]));
endmodule

module module_1
    (
        input  logic                              clk,
        input  logic                              rst,
        input  logic signed [7 : 0 ] x_in,
        input  logic signed [5 : 0 ] y_in [4:0]
    );
always_ff @(posedge clk) begin
    $display(""INFO: "", $sformatf(""y_in=%p"", y_in));
end

endmodule


I am using Vivado 2018.2 to run a functional test on this module. I pass the following array in my testbench to module_top:

    y_in =  {
                6'b001111, 6'b001111, 6'b001111, 6'b001111, 6'b001111,
                6'b001111, 6'b001111, 6'b001111, 6'b001111, 6'b001111,
                6'b001111, 6'b001111, 6'b001111, 6'b001111, 6'b001111,
                6'b001111, 6'b001111, 6'b001111, 6'b001111, 6'b000000,
                6'b001111, 6'b001111, 6'b001111, 6'b001111, 6'b001111
            };


When I look in wavforms, all the instantiation of module_1 are getting the correct y_in slice excpet module_1_inst_2. Supersingly to me, I am getting Z for y_in in module_1_inst_2. For instance if I run simulation, since I am printing y_in values every pos edge of clock, I am getting the following:

INFO: y_in='{15,15,15,15,15}
INFO: y_in='{6'bzzzzzz,6'bzzzzzz,6'bzzzzzz,6'bzzzzzz,0}
INFO: y_in='{15,15,15,15,15}
INFO: y_in='{15,15,15,15,15}
INFO: y_in='{15,15,15,15,15}


However, if I move this print one level up the hierarchy (module_top), y_in has all the values correctly. I got the same observation when I checked the waveform. 

On the otherhand, if I change the y_in width from 6 to 7 bits it works! So I am guessing Xilinx does not properly support passign arrays to modules? or am I doing something wrong?","It would help to give a complete example like below, that works fine with other simulators. Either array concatenation {,,,} or assignment pattern '{,,,} should work.
So I suspect you either have a tool issue, or something wrong with what you have not shown.

module module_top
    (
        input  logic                              clk,
        input  logic                              rst,
        input  logic signed [7  : 0 ] x_in,
        input  logic signed [5  : 0 ] y_in [24:0]
    );
    module_1 module_1_inst_1( .clk(clk), .rst(rst), .x_in(x_in), .y_in(y_in[4 : 0 ]));
    module_1 module_1_inst_2( .clk(clk), .rst(rst), .x_in(x_in), .y_in(y_in[9 : 5 ]));
    module_1 module_1_inst_3( .clk(clk), .rst(rst), .x_in(x_in), .y_in(y_in[14: 10]));
    module_1 module_1_inst_4( .clk(clk), .rst(rst), .x_in(x_in), .y_in(y_in[19: 15]));
    module_1 module_1_inst_5( .clk(clk), .rst(rst), .x_in(x_in), .y_in(y_in[24: 20]));
endmodule

module module_1
    (
        input  logic                              clk,
        input  logic                              rst,
        input  logic signed [7 : 0 ] x_in,
        input  logic signed [5 : 0 ] y_in [4:0]
    );
always_ff @(posedge clk) begin
  $display(""%m INFO: "", $sformatf(""y_in=%p"", y_in));
end

endmodule
module top;
  logic signed [5  : 0 ] y_in [24:0];
  bit clk,rst;
  logic signed [7  : 0 ] x_in;
  module_top dut (.*);
  always #2 clk++;
  initial begin
     y_in =  {
                1,2,3,4,5,
                6'b001111, 6'b001111, 6'b001111, 6'b001111, 6'b001111,
                6'b001111, 6'b001111, 6'b001111, 6'b001111, 6'b001111,
                6'b001111, 6'b001111, 6'b001111, 6'b001111, 6'b000000,
                6'b001111, 6'b001111, 6'b001111, 6'b001111, 6'b001111
            };
    #10 $finish;
  end
endmodule
",,,,,
How to interpret this discussion of Verilog relational operators,"This discussion of Verilog relational operators at ASIC World clearly has at least one mistake:


  
  The result is a scalar value (example a &lt; b) 
  0 if the relation is false (a is bigger then b) 
  1 if the relation is true (a is smaller then b) 
  x if any of the operands has unknown x bits (if a or b contains X)
  
  
  Note: If any operand is x or z, then the result of that test is
  treated as false (0)


Clearly, ""a is bigger than b"" should be ""a is bigger than or equal to b"". 

There is something else that looks wrong to me, but I don't know if it's just because I'm a Verilog novice. The last bullet point seems to contradict the subsequent note, unless there is a difference between an operand having all unknown bits (in which case the result of a relational operator will be x) and an operand being x (in which case the result will be 0).

Is there a difference between an operand being x and all of its bits being X? I know Verilog is case-sensitive. ","verilog is known for its x-propagation pessimism. 

From lrm 11.4.4


  An expression using these relational operators shall yield the scalar value 0 if the specified relation is false
  or the value 1 if it is true. If either operand of a relational operator contains an unknown (x) or highimpedance
  (z) value, then the result shall be a 1-bit unknown value (x).


so, if any of the values contains 'x' bits the result will be 'x'.

Now in case, when the result is used as a conditional expression, the if statement will take true brunch if and only if the result is '1'. Otherwise it will take the false branch. Also, there are conversion rules in verilog, where x and z values are converted to 0 in binary operations, which conditional operation is. 

so, the comment on the site is correct, it is talking of the results of a test (as in if statement)


  If any operand is x or z, then the result of that test is treated as false (0)
",,,,,
Break or return from always_ff / always_comb,"Is it possible to break from always block in Verilog? I have a large block and it will be more readable with breaks, comparing to multiple nested if/else statements.

So I want something like this:

always_ff @(posedge clk) begin
   ...

   if (x) begin
      ... 
      break;
   end

   ...
end


I've found one solution, but it looks like a hack:

always_ff @(posedge clk) begin
repeat(1) begin

   ...

   if (x) begin
      ... 
      break;
   end

   ...
end
end
","You can put your code in a function, and use return instead of break

always_ff @(posedge clk) func1;
function void func1;
   if (x) begin
      ... 
      return;
   end

   ...
endfunction


This is synthesizable and takes almost the same amount of keystrokes. ",,,,,
For Loop In Verilog Does Not Converge,"I'm attempting to using a for loop to count the repeated leading bit in a 32-bit number. For this, I am doing:

input[31:0] A;
output reg result;
Integer i;
for (i = 31; i &gt; -1; i = i - 1) begin
    if (A[i] == 0) begin
        result = result + 1;
    end
    else if (A[i] == 1) begin
        i = -1;
    end
end


However, when I synthesize the program, I receive a warning saying that the program does not converge. Am I using the for loop wrong? Before this I used i >= 0 and even used a while instead but it doesn't change the outcome. I would appreciate any help. Should I set result to 0 before running the loop?","A[i] == 1 makes number of iterations non-deterministic and causes synthesis to fail. The way around it is letting the loop to unroll till the end and use a conditional variable to handle your calculations. Something like the following:

input[31:0] A;
output reg result;
Integer i;
reg flag;

flag = 0;
for (i = 31; i &gt; -1; i = i - 1) begin
    if (flag == 0 &amp;&amp; A[i] == 0) begin
        result = result + 1;
    end
    else if (A[i] == 1) begin
        flag = 1;
    end
end


I assume that it was some type of a flop logic, since in any case this would produce state elements. So, you need to use correct nbas for result and flag. ",,,,,
Error (10734): Verilog HDL error at SWSelector.v(13): selector is not a constant,"Referring to my previous post: 
Error (10482): VHDL error: object &quot;select_vector&quot; is used but not declared

I converted my code from VHDL to verilog, but I'm getting this error now:


  (Error (10734): Verilog HDL error at SWSelector.v(13): selector is not
  a constant),


Any suggestions how do I deal with it?  There are 8 possibilities for selector switch which are coming from a decoder. So whenever the value of selector matches 3'b000, I want rq to be assigned to requests. Here is my code:

module SWSelector(
input [7:0] rq,
input [2:0] selector,
output [7:0] request
);
localparam NUM=3'b000;
generate
genvar i;
for(i=0;i&lt;7;i=i+1)
    begin: label
    if(selector == NUM)
        begin
            assign request[i] = rq[i];
        end 
    else 
        begin
        assign request[i]=0;
        end
    end
endgenerate
endmodule
","Since your if-statement is in a generate, you're asking the tool to pre-evaluate what selector is set to in order to figure out selecter == NUM evaluates to, but your tool doesn't know because it's a signal, not a parameter.

You want to use the generate to create an always block that you can check the value of selector in, like so:

module SWSelector(
    input [7:0] rq,
    input [2:0] selector,
    output reg [7:0] request
);
    localparam NUM=3'b000;
    generate
        genvar i;
        for(i=0;i&lt;7;i=i+1)
        begin: label
            always @* begin
                if(selector == NUM)
                    request[i] = rq[i];
                else
                    request[i]=0;
            end
        end
    endgenerate
endmodule


Or, as toolic said, you can use a ternary and an assign. 

Edit: 

Without generate:

module SWSelector(
    input [7:0] rq,
    input [2:0] selector,
    output reg [7:0] request
);
    localparam NUM=3'b000;

    integer i;
    always @* begin
        for(i=0;i&lt;7;i=i+1) 
            if(selector == NUM)
                request[i] = rq[i];
            else
                request[i]=0;
     end
endmodule
",,,,,
Calling Arrays in Verilog Structural Description,"I am trying to pass only partial arrays from one verilog module to another and encounter an error every time i modify the code.

The code is as follows: 

module 1:

module Koge_4(A,B,Cin,S,Cout);
input [3:0] A,B;
input Cin;
output [3:0]S;
output Cout;


Module 2: 

module Koge_64(A,B,Cin,S,Cout);
input [63:0]A,B;
input Cin;
output [63:0]S;
output Cout;
wire [15:0]c;
Koge_4 K1  ([3:0]A,[3:0]B,Cin,[3;0]S,c[0]); // sample structural code


I am basically trying to call the 4 bit (module 1) for every 4 bit of the input vector in module 2. Hence calling it 16 times for 64 bits.","You are missing endmodule in the example and have complete mess with verilog syntax (see toolic's comment). Please read a Verilog tutorial.

Here is a cleaned up version of your code which you can compile.   

module Koge_4(A,B,Cin,S,Cout);
   input [3:0] A,B;
   input Cin;
   output [3:0]S;
   output Cout;
endmodule

module Koge_64(A,B,Cin,S,Cout);
   input [63:0]A,B;
   input Cin;
   output [63:0]S;
   output Cout;

   wire [15:0]c;

   Koge_4 K1  (A[3:0], B[3:0], Cin, S[3:0], c[0]); // sample structural code
endmodule // Koge_64
",,,,,
Using DMA to communicatte PCIe,"Xilinx corp. released some programs for working with its DMA PCIe IPcore which is available here. Whitin these programs, there are some programs that performs C2H or vise versa high speed operations.

Is it basically using DMA in host side or something redundant must be written in these codes? For instance, the code snippet that does writing/reading in AXI-ST mode is as follows:

void do_transfers_in_parallel(unsigned index, device_file&amp; h2c, device_file&amp; c2h, 
                       std::array&lt;uint32_t, array_size&gt;&amp; h2c_data, 
                       std::array&lt;uint32_t, array_size&gt;&amp; c2h_data) {

std::cout &lt;&lt; ""    Initiating H2C_"" &lt;&lt; index &lt;&lt; "" transfer of "" &lt;&lt; h2c_data.size() * sizeof(uint32_t) &lt;&lt; "" bytes...\n"";
std::thread read_thread(&amp;device_file::write, &amp;h2c, (void*)h2c_data.data(), 
                        h2c_data.size() * sizeof(uint32_t));
std::cout &lt;&lt; ""    Initiating C2H_"" &lt;&lt; index &lt;&lt; "" transfer of "" &lt;&lt; c2h_data.size() * sizeof(uint32_t) &lt;&lt; "" bytes...\n"";
std::thread write_thread(&amp;device_file::read, &amp;c2h, (void*)c2h_data.data(), 
                         c2h_data.size() * sizeof(uint32_t));

write_thread.join();
read_thread.join();


}",I think this is absolutely relied on nature of PCIe specification and Also Xilinx PCIe driver which fully described in PG195.,,,,,
Connection width does not match width of port,"I have a problem! My code its doesn't working and I dont why. help me please. I try make a carry skip adder nbits and a error occured. 

this is my the error :


  Warning: C:/Users/Gerson/Desktop/cska1/cska1.v(102): Connection width does not match width of port 'a'.


And this error occurred in all my mux a,b,sel an out.

thanks for all help guys.

module ha_w ( a, b, co, s ); // modulo de meio somador half adder wire 

  input wire a, b; // declaraco das entradas a e b
  output wire 
          co,  // declaracao das saidas carry out 
          s;   // e saida

assign s  = a ^ b; // funcao xor representada pelo simbolo ^
assign co = a &amp; b; // funcao and representada pelo simbolo &amp;

endmodule // fim do modulo ha_w  


module fulladd( a, b, cin, co, s); //declaracao das variaveis 
// bloco full adder feito com a juncao de dois half adders adders

  input a, b;     // entradas do full adder
  input wire cin; // declaracao entrada carry input
  output wire co; // declaracao da saida carry out
  output wire s;  // tava faltando
  wire x,y,z;     // fios dentro do bloco de projeto x(liga o primeiro half adder ao segundo half adder), 
  //y(liga o segundo half adder a porta OR ), z(liga o primeiro half adder a porta OR)

// ha_w   ( a,   b, co, s )
  ha_w ha_1 (                   // mapeamento do primeiro half adder(entradas e saidas)
              .a (a), .b(b),    // inputs connection
              .co(z),           // cout  
              .s(x)             // saida   //nao vai virgula
             ); 
  ha_w ha_2 ( cin, x, y,  s ); // mapeamento do segundo half adder (entradas e saidas)

  assign co = y | z;        // saida co obtida pelo resultado de y e z pela porta OR

   endmodule // fulladd  

module mux(a,b,sel,out);

    parameter Nbits = 8;

    input  wire   [Nbits-1:0] a,b;
    output wire   [Nbits  :0] out;
    input  wire   [Nbits-1:0] sel;  
    wire          [Nbits-1:0] a1,b1,so;

     genvar r;

         generate
            for (r=0; r&lt;Nbits;r=r+1) begin
                 nand u1(so[r],sel[r],sel[r]);
                 nand u2(a1[r],so[r],a[r]);
                 nand u3(b1[r],sel[r],b[r]);
                 nand u4(out[r],a1[r],b1[r]);
            end
        endgenerate
endmodule   


module cska(a,b,co);

        parameter Nbits = 8;

    input [Nbits-1:0]a,b;
    output[Nbits  :0]co;

    wire  [Nbits  :0] cin;
    wire  [Nbits-1:0] p,s;
    wire  [Nbits  :0] clinha   ;   // fios de ligacao entre os full adders, cout vai ligado no cin
  wire  [Nbits  :0] c0;
    wire  [Nbits  :0] bp;
    genvar m;

        generate 

            for ( m=0; m&lt;Nbits; m=m+1 ) begin
                // fulladd(     a,    b,       cin,          co,   s);
                fulladd fa1( a[m], b[m], clinha[m], clinha[m+1], s[m] );  // mapeamento de portas do full adder para assim generaliza-las para o RCA
            end

        endgenerate

    //assign clinha[0] = cin;
    //assign co        = clinha [Nbits];   

    genvar n;

        generate

            for (n=0; n&lt;Nbits; n=n+1) begin
                assign p[n]     = a[n] | b[n];               // Propagate = P=A+B
                assign bp = &amp;p ;
            end
        endgenerate 

    //assign Cin[0]= 1'b0; // carry in = 0  
    //assign co = {Cin[Nbits], S}; //Concatenacao entre a previsao de carry in's e a saida soma

    genvar z;

        generate

            for (z=0; z&lt;Nbits; z=z+1) begin
                mux mux1(c0[z+1], cin[z+1], bp[z+1], co[z+1]);
            end
        endgenerate


endmodule 
","your mux is connected to '1' bit signals:

mux mux1(c0[z+1], cin[z+1], bp[z+1], co[z+1]);


the mux itself is declared with 8-bit ports:

parameter Nbits = 8;
input  wire   [Nbits-1:0] a,b;


So, there is port-width mismatch.",,,,,
how to make Modelsim run another application,i'm working on designing a mips processor using verilog in modelsim student version and we developed a c++ tool that converts assembly operations to machine code and save the result in .txt file so is there a way to make modelsim runs this tool when simulation starts ?,"You can use $system(""foo""); to run any system call from system verilog, including invoking your external C++ program, like (""echo hi""); or :

$system(""path/to/my/cpp_binary.exe arg1 arg2 arg3"");


If you wrap it in an initial block, you can run it at the beginning of simulation.  See this answer.",,,,,
Order of wire statements change behavior,"I have the following data transition in my state machine:

wire VALID_PKT = (FIFO_DATAIN[7] == 1) &amp; (FIFO_DATAIN[6] == 0)&amp; (FIFO_DATAIN[5] == 1) &amp; (FIFO_DATAIN[1] == 1) &amp; (FIFO_DATAIN[0] == 1);
wire SET_RESET = FIFO_DATAIN[3];

reg RESET;
always @(*) begin
    case (CurrentState)
        STATE_DECODE: begin
            if(VALID_PKT) begin
                RESET = SET_RESET;
            end
        end
    endcase
end


This is the one place where RESET is changed.

My intention is: Only in state DECODE, when the packet is valid, then assign the value to the register. Where it should stay until the next (valid) packet comes and changes it.

When I simulate this with iVerilog I get unexpected results. Specifically, when an invalid packet (8'b00000000) comes, RESET is set to zero. But this should not happen because VALID_PKT is not true.

Now the strange part: If I swap the wire assignments, i.e. I write

wire SET_RESET = FIFO_DATAIN[3];
wire VALID_PKT = (FIFO_DATAIN[7] == 1) &amp; (FIFO_DATAIN[6] == 0)&amp; (FIFO_DATAIN[5] == 1) &amp; (FIFO_DATAIN[1] == 1) &amp; (FIFO_DATAIN[0] == 1);


then I get the expected result.
This is weird since I think the order of wire assignments should not matter.

Is there any subtlety about wire assignments that I am not aware?","You have a race condition. You have a combinational always block and have not assigned RESET in all possible branches. Specifically, if VALID_PKT goes false, how could RESET go back to its previous value? You might want to conver your always block from combinational to synchronous. ",,,,,
Quartus 2 verliog using curly craces to set particular bits,"Hi I am new to verilog and I try to set some particular bits from one reg variable to another reg but it didn't work for me. what am Ä± doing wrong?  

reg [31:0] a;
reg [31:0] b;

initial begin
 a =32'b0;
 b =32'b1;
 $display(""current value of a = %32b "",a);
 a ={b[5:0]};
 $display(""value of a %32b "",a);
 #10 $finish;
 end


bit of a from a[0] to a[5] should be 1 but only a[0] became 1 ","In you code b = 32'b1 yields {31{1'b0},1'b1}, so only b[0] is equal to one.

In SystemVerilog (check: IEEE1800-2012, 5.7.1 Integer literal constants) you can use automatic left padding of constant literal numbers using a single-bit value, i.e. b = '1 to set all bits of b to one.

Using Verilog, simply assign another value to b (i.e. b = 32'b11111) or change your code to following:

a[4:0] = {5{b[0]}}
",,,,,
"making counter in verilog, Modelsim","i'm trying to make round robin counter in verilog

module rr_arbiter (
clk, // positive edge trigger
reset,  // negative edge trigger
req0, req1, req2, req3, 
grant0, grant1, grant2, grant3,
priority, priority_req);

input clk, reset;
input req0, req1, req2, req3;
input priority;
input [1:0] priority_req;

output grant0, grant1, grant2, grant3;  

reg x 

always(posedge clk or negedge reset) begin
pirority_req = priority;

if (reset) begin
    grant0 &lt;= 1'b0;
    grant1 &lt;= 1'b0;
    grant2 &lt;= 1'b0;
    grant3 &lt;= 1'b0;
   end
else
begin
    if(priority == 1)
        if (priority req == 2b'00)
            begin
            x=1;
            grant0 &lt;= (grant0*(~x))+(grant1*x);     
            x=0;
            grant0 &lt;= (grant0*(~x))+(grant1*x);
            grant1 &lt;= grant2;
            grant2 &lt;= grant3;
            grant3 &lt;= grant1;
            //  counter 0012300123
            end
        else if (priority req == 2b'01)
            begin
            grant0 &lt;= grant1;
            x=1;
            grant1 &lt;= (grant1*(~x))+(grant2*x);
            x=0;
            grant1 &lt;= (grant1*(~x))+(grant2*x);
            grant2 &lt;= grant3;
            grant3 &lt;= grant1;
            //  counter 0112301123
            end
        else if (priority req == 2b'10)
            begin
            grant0 &lt;= grant1;
            grant1 &lt;= grant2;
            x=1;
            grant2 &lt;= (grant2*(~x))+(grant3*x);
            x=0;
            grant2 &lt;= (grant2*(~x))+(grant3*x);
            grant3 &lt;= grant1;
            //  counter 0122301223
            end
        else if (priority req == 2b'11)
            begin
            grant0 &lt;= grant1;
            grant1 &lt;= grant2;
            grant2 &lt;= grant3;
            x=1;
            grant3 &lt;= (grant3*(~x))+(grant1*x);
            x=0;
            grant3 &lt;= (grant3*(~x))+(grant1*x);
            //  counter 0123301233
            end
    end

    else 
    begin
        grant0 &lt;= ~grant2 * grant3;
        grant1 &lt;= grant0;
        grant2 &lt;= grant1;
        grant3 &lt;= grant2;
        //counter 01230123
    end
end
end

end

endmodule 


as you can see, i'm trying to make round robin counter.
each case it's like (grant)01230123.., 0012300123.., 0112301123.., 0122301223.., 0123301233...


** Error: (vlog-13069) C:/Modeltech_pe_edu_10.4a/examples/rr_arbiter.v(17): near &quot;always&quot;: syntax error, unexpected always, expecting ';' or ','.
** Error: (vlog-13069) C:/Modeltech_pe_edu_10.4a/examples/rr_arbiter.v(22): near &quot;&lt;=&quot;: syntax error, unexpected &lt;=.
** Error: C:/Modeltech_pe_edu_10.4a/examples/rr_arbiter.v(22): (vlog-13205) Syntax error found in the scope following 'grant0'. Is there a missing '::'?
","The error message for line 17 is self-explanatory. It is expecting a ';'. You are missing a ';' on line 15.

If an error message appears to make no sense, always cast your eye up the screen to see whether the problem is with a previous line.",,,,,
Concatenation operator not allow in module instantiation,"MUX32_16x1 inst9(muxR, dontNeed, addSub, AddSub, mult, shift, shift, wireAnd, wireOr, wireNor, {31{0}, addSub[31]}, dontNeed, dontNeed, dontNeed, dontNeed, dontNeed, dontNeed, OPRN[3:0]);


Above is my instantiation of a 16x1 mux, I'm trying to set one parameter to 0 for the first 31 bits leaving only the last bit as an input by doing this  

{31{0}, addSub[31]}


I'm not sure why the program is giving out this error

near "","": syntax error, unexpected ',', expecting '}'.


is curly braces operator not allow in module instantiation?

sorry, I'm very new to Verilog programming ","When you're doing repeated concatenation, you need to enclose it in another set of braces, so {31{1'b0}} is the same as 31'd0.

Try:  

{{31{1'b0}}, addSub[31]}


Or:

{31'd0, addSub[31]}
",,,,,
Take the sum of 3 adc data for 3 sampling,"
Hi everyone,

I am a newbie in programming FPGA by verilog language. At the present, I am trying to design the firmware to calculate the sum of adc data at 3 sampling. Firstly, I will explain about one adc at one sampling in my code. When you look at the code, you can see that with rising-edge of clkr clock and adcIfEnb == 1, the adc_data will get the value from adcIfData and this is the data for one sampling. In the next rising-edge of clkr clock and adcIfEnb == 1, this data is stored in iradcTrg. Finally, I will have the 3 data of adc_data for 3 sampling which are stored in iradcTrg and then I summarize 3 these data. 


wire adcIfData[79:0];
reg 
always @(posedge clkr) begin
if(adcIfEnb) begin
adc_data[9:0] &lt;= adcIfData[9:0];
end
end
reg [29:0] iradcTrg;
reg [9:0]  adcTrg; 
always @(posedge clkr) begin
if (adcIfEnb) begin 
iradcTrg[29:0] &lt;= {adc_trg[19:10],adc_trg[9:0],adc_data[9:0]};
adcTrg[9:0] &lt;= adc_trg[29:20] + adc_trg[19:10] + adc_trg[9:0];
end
end



However, there are 2 problems which I do not know how to solve.   

Firstly, at the beginning time, when the first data of adc_data is stored at iradcTrg and adcTrg also take the sum. It means that adcTrg = 0 + 0 + first_adc_data but this sum need to be avoided.

Secondly, according to my design, I see that adc_data is serialized into iradcTrg. It means that the adc_data will be stored like this:

[1 2 3] 4 5 6 => 1 [2 3 4] 5 6=> 1 2 [3 4 5] 6

But in my case, I would like that the adc_data will be stored like this to get the sum

[1 2 3] 4 5 6 => 1 2 3 [4 5 6]

Therefore, how should I repair my code to get the result that I expected or are there any documents can help me in this case ?","To start: make sure your code is correctly indented when you put it on stackexchange. Secondly: I assume you have edited the code before posting it here because that code will not compile e.g. there is a floating 'reg' at the top and no module declaration.Thirdly: you have defined a wire adcIfData[79:0] I am going to assume you meant that to be [9:0].Forthly: You use variables which are not defined: adc_data, adc_trg. 
Fifthly: I suggest you give your variables more meaningfull names like: gater_samples, sum_off_samples.
Now lets look at the core of the code. You want to take samples and shift them into a 30 bit register. There is no need to write ""adc_trg[19:10],adc_trg[9:0]"" adc_trg[19:0] will suffice. Also there is no need to put it in a different register beforehand. I would just use:

always @(posedge clkr) 
   if (adcIfEnb) 
      iradcTrg[29:0] &lt;= {iradcTrg[19:0],adcIfData[9:0]};


As to your basic problem of gathering samples and not using the first two: all you have to do is add a counter which counts to three. Then you add the result on the third count. You will need a reset to give the counter a known value at startup but I don't see a reset signal. I always try to use minimal logic so I would make iradcTrg 20 bits wide to only store the intermediate result and at the count of three add it up with the latest sample. Saves another 10 registers. Here is some code. I wrote this without simulating or compiling. It is just a guide of how it all should look like. 

reg [ 1:0] count;
reg [19:0] gather_samples;
reg [ 9:0] sum_of_samples;
reg        sum_valid;

always @(posedge clkr) 
begin
   if (some_reset)
      count &lt;= 2'd0;
   else
   if (adcIfEnb) 
   begin
      if (count==2'd2)
      begin // third sample arriving, add it to the previous 2
         sum_of_samples &lt;= gather_samples[19:10] + gather_samples[9:0] + adcIfData;   
         count &lt;= 2'd0;
      else
      begin // intermediate: gather samples
         gather_samples &lt;= {gather_samples[9:0],adcIfData};
         count &lt;= count + 2'd1;
      end
      sum_valid &lt;= (count==2'd2);                
   end // if (adcIfEnb) 
end // clocked
",,,,,
Number of independent AES 256 CBC decryption operations per second with AES-NI or GPU acceleration,"AES-NI seems to be optimized to encrypt/decrypt big chunks of data. However I'm trying to decrypt a password and I have many very small bits to try (iv + first cbc block, 32 bytes in total). 

I'm using openssl at the moment, calling EVP_DecryptInit_ex, EVP_DecryptUpdate for every cycle (and EVP_CIPHER_CTX_init once per thread).

I can do this around 2 million times per second on a single core.

I assume this is the sort of performance I can expect using AES-NI instructions and I shouldn't worry about optimising this further. Is this correct?

Does anyone have any idea how much faster this might be on a high end GPU or not-too-expensive FPGA?","FPGA: You can convert an input block to an output block on any reasonable FPGA with a 2-cycle throughput at several hundred MHz, with a latency of 16 cycles. So, possibly 256 Mblocks/s pipelined, or maybe 32 Mblocks/s not pipelined. You could get maybe 5 of these on a reasonably cheap FPGA, or 30+ on an expensive one. YMMV.",,,,,
VHDL: How to convert an iterator of generate block to std_logic_vector?,"I want to get binary std_logic_vector from integer inside the generate.

For example,

0 -> 0000

1 -> 0001

2 -> 0010

...

15 -> 1111

I could write 16 if-else statements for each integer number, but I don't like this idea. (What if I will have much more than 16 integer numbers?)

I've tried to use two methods, but neither of them works:
address and hit are both std_logic_vector

G_1 : for i in 0 to 15 generate
    address &lt;= conv_std_logic_vector(i, 4) when hit(i) = '1';
end generate G_1;   

G_2 : for i in 0 to 15 generate
    address &lt;= std_logic_vector(to_unsigned(i, 4)) when hit(i) = '1';
end generate G_2;


Also I noticed that if I use number instead of the i, it works. (Example: I get ""0101"" when I use conv_std_logic_vector(5, 4))

What am I doing wrong? Is there any possible way to do it using vhdl?","For a start, do not use ieee.std_logic_arith.all. Instead, use ieee.numeric_std.all, and get rid of any nasty conv_integer functions; the preferred style is to use types like unsigned, and then convert or cast these as you have in your second code example.

Moving on to your loop, you are using generate loop:

G_1 : for i in 0 to 15 generate
  address &lt;= conv_std_logic_vector(i, 4) when hit(i) = '1';
end generate G_1;


This will generate 16 lines of the form:

address &lt;= conv_std_logic_vector(0, 4) when hit(0) = '1';
address &lt;= conv_std_logic_vector(1, 4) when hit(1) = '1';
address &lt;= conv_std_logic_vector(2, 4) when hit(2) = '1';


etc. Since each concurrent assignment infers its own process, your design will have multiple drivers on the address signal, which is not allowed in a synthesis-eligible design.

It seems like the objective is to set address according to the lowest set ('1') bit in the hit vector. This is called a priority encoder. Something like this would be better:

process (hit)
begin
  for i in 0 to 15 loop
    address &lt;= (others =&gt; '0');  -- Default assignment, any later assignment takes priority
    if (hit(i) = '1') then
      address &lt;= std_logic_vector(to_unsigned(i, address`length));
      exit;
    end if;
  end loop;
end process;


Since address seems to represent an unsigned number, you could use type unsigned for this signal, and save a type cast.",,,,,
Verilog: Changing multiple states in one case statement,"Basically I'm trying to display the sum or product of two numbers (inputted using switches on an FPGA) onto a 7-segment display. I know that both my addition and multiplication bits work fine, as I've tested them separately.

I'm having trouble with the LSB though. No matter what it just defaults to F and never changes. I think Verilog doesn't allow me to modify both Cout1 and Cout0 in the same case statement. Is there a workaround for this? See my code, below.

always@*
    if (key1press)
    casex(PrintSum)

        // Hex 1 (MSB)
        // Works!
        5'b0xxxx : Cout1 = 7'b1000000;  //0 if S[4] = 0
        5'b1xxxx : Cout1 = 7'b1111001;  //1 if S[4] = 1

        // Hex 0 (LSB)
        // Doesn't work :(
        5'bx0000 : Cout0 = 7'b1000000;  //0
        ...
        5'bx1111 : Cout0 = 7'b0001110;  //F
        //default  : begin
        //            Cout1 = 7'b1000000;   //0 by default
        //            Cout0 = 7'b1000000;   //0 by default
        //end
    endcase


Thanks in advance everyone :)","In simulations, case statements will execute first match. Everything will match the first two conditions (5'b0xxxx, 5'b1xxxx).  If you move these conditions to the end, then they will never be reached as there will be a match in the 5'bx0000 to 5'bx1111 range.

There isn't overlap between the care bits. Therefore, the simplest solution is to split Cout1 and Cout0 into separate constitutional statements:

begin
  if (PrintSum[4]) begin
    Cout1 = 7'b1111001;  //1 if S[4] = 1
  end
  else begin
    Cout1 = 7'b1000000;  //0 if S[4] = 0
  end

  case(PrintSum[3:0])
    4'b0000 : Cout0 = 7'b1000000;  //0
    // ...
    4'b1111 : Cout0 = 7'b0001110;  //F
  endcase
end




Other things to be aware of:


Don't use casex  


Casex vs Casez in Verilog 
read &sect; 4.3 of RTL Coding Styles That Yield Simulation and
Synthesis Mismatches

for details.

Cout0 and Cout1 are inferred latches (level-sensitive). FPGAs have limited or no support for latches. Plus latches can be glitch prone if not done properly.


What is inferred latch and how it is created when it is missing else statement in if condition.can anybody explain briefly?
StackOverflow search result for inferred latch

",,,,,
Dont count respectively vhdl,"library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;


entity A is
  Port (
        clk : in STD_LOGIC;
        reset: in std_logic; -- reset input 
        counter: out std_logic_vector(3 downto 0) := ""0000""-- output 4-bit counter
);
end A;

architecture Behavioral of A is
 signal counter_up: std_logic_vector(3 downto 0) := ""0000"";
 signal countOf : integer := -1;
 signal count : integer := 0;
 signal temp : std_logic := '0';
begin
-- up counter

      process(clk)
     begin
if(clk'event and clk='1') then
count &lt;=count+1;
if(count = 50000000) then
temp &lt;= not temp;
count &lt;=1;
end if;
end if;
end process;

process(temp,reset)
begin
if(reset = '1') then
    countOf &lt;= 0;
 else
        if(temp = '1') then 

             if( countOf &lt; 4) then countOf &lt;= countOf + 1;
             else countOf &lt;= 0; end if;

            if(countOf = 0) then counter_up &lt;= ""0000""; end if;
            if(countOf = 1) then counter_up &lt;= ""0001""; end if;
            if(countOf = 2) then counter_up &lt;= ""0010""; end if;
            if(countOf = 3) then counter_up &lt;= ""0100""; end if;
            if(countOf = 4) then counter_up &lt;= ""1000""; end if;


        end if;

 end if;
end process;

counter &lt;= counter_up;

end Behavioral;


Hi I want to make a counter from 0 up to 4. As you see I divide my clock to 1 HZ and in the process of temp and reset, I assigned all conditions however it doesnt count how Ä± want. It is very weird . How can I fix it? Thanks in advance.","Your process(temp, reset) cannot work, because you made it combinatoric, which is not what you need in this instance. Works fine in simulation, doesn't work at all in hardware.

What you wrote generates a loop in hardware: The state of countOf is dependent on the state of temp and the state of countOf itself. Since your process contains no clock, the state of countOf changes as fast as gate delay allows it(if this code will be synthesized correctly at all). 

If your software is any good, it'll give you a warning like this:

[Synth 8-614] signal 'countOf' is read in the process but is not in the sensitivity list


which you should never ignore, because in 99% of the cases, that means you'll get undesired behaviour and/or simulation mismatches.

What you need to do is make temp your clock. It is generated by a clock divider, so logically you almost certainly want it to be a clock as well. If you replace if (temp = '1') then with if rising_edge(temp) then, your code will work as desired. 

Side note: Please remove use IEEE.STD_LOGIC_ARITH.ALL; and use IEEE.STD_LOGIC_UNSIGNED.ALL;. Not only do you not need any unsigned library for your code at all, but IEEE.STD_LOGIC_ARITH is deprecated and should no longer be used. It has been for years. Use IEEE.NUMERIC_STD instead.",,,,,
Which FPGA should I choose? (or should I choose another hardware),"You see guys, I've always been interesting in buying one of this development boards, but they were too expensive to me as a student since I had to spent in other proyects, however, I sold some things i don't use and finally made the money to buy one.

So my problem is, I am currently studying electronic engineering, but I've been dedicating a lot of time to programing, reverse engineering stuff and undesrtanding some a little bit complex math cryptographic algorithms (mainly the ones used for hashing) and prime number testing, NP-hard kind of algorithms and some graph path search algorithms, so i wanted to buy an FPGA that was anywhere under $200 that could do the job if i wanted to compute this kind of tasks with him, right now i use my computer for some.

Lets say as example  if i wanted to make an architecture for wpa or md5 brute-forcing, we all know that the numbers go nuts if the password is longer than 8, and eventhough im more interested on understanding deeply how the protocols work and how to implement this ideas, it just would be nice to see it working.

Right now the options I've looked at so far are:

-Cyclone V GX Starter Kit ($179)
which has: Cyclone V GX 5CGXFC5C6F27C7N  Device
https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;CategoryNo=167&amp;No=830

-DE10-Nano Kit ($130)
which has : Cyclone V 5CSEBA6U2317N Device
https://www.terasic.com.tw/cgi-bin/page/archive.pl?Language=English&amp;CategoryNo=167&amp;No=1046

But since im kind of new to FPGA, I mean I've worked with them but used for university projects, with their FPGA's, so i didn't get to know them a lot.
So my final question is, does the FPGA speed depends only on the amount of logif elemnts it has? or, should i care more about that than the other ""add-ons"" the boards have? because eventhough the second one is cheaper it has lie 30% more Logic elements than the first on, but I don't know if that would mean i would have better performance.

Also, here's the datasheet fot the cyclone V devices:
https://www.altera.com/en_US/pdfs/literature/hb/cyclone-v/cv_51001.pdf

Also thank you for your time on reading this guys, I know it's usually more interesting to solve programming issues and that kind of stuff haha

EDIT: Forgot the ""1"" on the ""$179""","The boards you've listed has similar speed grade, so won't be any different in raw speed.

GX series include 3Gbps transceivers, and that exact Starter kit has 2.5v levels on HSMC connector. Unless you will be using that connector with some really fast hardware (like 80Msps ADC/DAC, etc), it's unlikely you will benefit from GX. If only due to a bit larger number of hw multipliers available, but that depends on your exact project and needs.

Lots of gpio lines will be lost to hsmc connector. There's boards to fan out hsmc connector into convenient 40-pin gpio connectors, but that will cost another $56. And still you might have difficulties with external hw you will be playing with, since i/o banks on those lines will be using 2.5v levels, while most likely you will have lots of 3.3v devices. It's compatible to a degree and under some conditions, but it's safer to assume there will be issues.

If you will be playing with DIY stuff eventually, then you will need more i/o lines at more convenient voltage of 3.3v. DE10-nano kit looks more promising to me in general case. There's two arm cores that you can use to run higher level logic in linux. It has arduino-compatible connectors, so you can play with existing shields. It's also larger than Starter kit in terms of ALM and on-chip memory, you will need those to instantiate lots of parallel blocks to crunch your numbers. 

Sure, if you already have some daughter boards in hsmc format, or planning to have one - you will need some kit with hsmc support.",,,,,
assume() does not work for initial statement,"For https://i.imgur.com/NCUjYmr.png , why doesn't the signal ""reset"" assumed to be '1' initially ? Anyone have any idea why the assume does not work ? ","I found the solution. I am in temporal induction where it starts at a state which is not the initial state of the system. Therefore, the signal ""reset"" is not assumed to be '1' initially ",,,,,
Can not use component in active -hdl 10,"I use active-hdl 10 for compile and simulation a DFlipFlop structural.
my code compiled successfully without any error or warning but when I simulate it,  my output have unknown value .(see picture)


(click to enlarge)

I compile and simulate this code in xilinx and active-hdl 8 without any problem.

D_FlipFlop code:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity D_FlipFlop is
Port ( D : in  STD_LOGIC;
       Clk : in  STD_LOGIC;
       Q : inout  STD_LOGIC);
end D_FlipFlop;

architecture Behavioral of D_FlipFlop is
component DLach Port ( D : in  STD_LOGIC;
                          C : in  STD_LOGIC;
                          Q : inout  STD_LOGIC;
                          Qprim : inout  STD_LOGIC);                            

end component;                                                
Signal Y : STd_logic;
Signal Clk_Not : Std_Logic;
Signal out1 : Std_Logic;
Signal out2 : Std_Logic;
begin
Clk_Not&lt;=not(clk);
h1 : DLach port map(D=&gt;D,C=&gt;clk,Q=&gt;Y,Qprim=&gt;out1);
h2 : DLach port map(Y,Clk_Not,Q,out2);
end Behavioral;


Dlach code:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity DLach is
Port ( D : in  STD_LOGIC;
       C : in  STD_LOGIC;
       Q : inout  STD_LOGIC:= '0';
       Qprim : inout  STD_LOGIC:= '1');
end DLach;

architecture Behavioral of DLach is

Signal first : Std_logic ;
Signal second : Std_logic ;
Signal D_not : Std_logic ;

begin      

D_Not &lt;= not(D);

first &lt;= D Nand C;
second &lt;= D_not nand C;

Q &lt;= first nand Qprim;
Qprim &lt;= second nand Q ;

end Behavioral;




I research a lot but I cant find the answer.
so I think this dosent work for who they use trial version of active -hdl.","I search a lot about this problem, it seems no one appear with this problem. so I think this problem occured on trial version of active -hdl 10 or cracked versions.",,,,,
"Verilog, testing for Zero flag","module NOR31_1x1(Y,A);
input [31:0] A;
output Y;

wire [29:0] norWire;

    nor nor1(norWire[0], A[0], A[1]);
        nor nor2(norWire[1], norWire[0], A[2]);
    nor nor3(norWire[2], norWire[1], A[3]);
    nor nor4(norWire[3], norWire[2], A[4]);
    nor nor5(norWire[4], norWire[3], A[5]);
    nor nor6(norWire[5], norWire[4], A[6]);
    nor nor7(norWire[6], norWire[5], A[7]);
    nor nor8(norWire[7], norWire[6], A[8]);
    nor nor9(norWire[8], norWire[7], A[9]);
    nor nor10(norWire[9], norWire[8], A[10]);
    nor nor11(norWire[10], norWire[9], A[11]);
    nor nor12(norWire[11], norWire[10], A[12]);
    nor nor13(norWire[12], norWire[11], A[13]);
    nor nor14(norWire[13], norWire[12], A[14]);
    nor nor15(norWire[14], norWire[13], A[15]);
    nor nor16(norWire[15], norWire[14], A[16]);
    nor nor17(norWire[16], norWire[15], A[17]);
    nor nor18(norWire[17], norWire[16], A[18]);
    nor nor19(norWire[18], norWire[17], A[19]);
    nor nor20(norWire[19], norWire[18], A[20]);
    nor nor21(norWire[20], norWire[19], A[21]);
    nor nor22(norWire[21], norWire[20], A[22]);
    nor nor23(norWire[22], norWire[21], A[23]);
    nor nor24(norWire[23], norWire[22], A[24]);
    nor nor25(norWire[24], norWire[23], A[25]);
    nor nor26(norWire[25], norWire[24], A[26]);
    nor nor27(norWire[26], norWire[25], A[27]);
    nor nor28(norWire[27], norWire[26], A[28]);
    nor nor29(norWire[28], norWire[27], A[29]);
    nor nor30(norWire[29], norWire[28], A[30]); 
        nor result(Y, norWire[29], A[31]);
endmodule


Hi, so I wrote the code above to test if Zero flag is set by nor each bit against another, It seems that the logic is correct, but the result keeps return 1 for zero flag regardless of any input. I ran through the simulation to test and it seems that norWire already contain some value despite not being set any value yet. Can I get some help debugging this please. I'm having a hard time debugging this due to being new to Verilog and the ModelSim simulator.","Let's limit this to three bits to illustrate the problem.  If we label the bits A, B, and C what you're trying to express is:

!(A | B | C)


What you've written is:

!(!(A | B) | C)


where the output of one NOR (complete with the final negation) is being fed forward to the next stage.

So some judicious use of 'or' and 'not' primatives should get you there.",,,,,
"Bit shifting in sequential block fails, in combinational not. Why?","I am debugging a piece of Verilog code for days, particularly sending and receiving bytes from an FX2LP (Cypress CY7C68016A) USB controller. Without going into many details, data is sent and transmitted byte-wise in each cycle. For my test, I use a 16 byte buffer which I first fill and then transmit back (echo test).

The significant part of my code looks like:

reg [127:0] dataBuf; // 16 byte buffer for USB data

reg [7:0] cntByte; // counter for number of bytes
reg [7:0] nextCntByte;

reg shiftBufRx, shiftBufTx; // flags whether buffer should be shifted
reg [7:0] currentByte; // current read byte

// in transmit cycle, byte is read from USB_DATAOUT
assign USB_DATAOUT = dataBuf[7:0];

always @(posedge FIFO_CLK) begin
    // update state variables
    CurrentState &lt;= NextState;  
    cntByte &lt;= nextCntByte;

    if(shiftBufRx) begin // cycle was a receive
        dataBuf &lt;= { currentByte , dataBuf[127:8] };
    end
    if(shiftBufTx) begin // cycle was a transmit
        dataBuf &lt;= { dataBuf[127-8:0] , 8'h00 };
    end
end

always @(*) begin
    // avoid race conditions
    NextState = CurrentState;
    nextCntByte = cntByte;
    nextDataBuf = dataBuf;
    currentByte = 0;
    shiftBufRx = 0;
    shiftBufTx = 0;

    case(CurrentState)
        [...]
        STATE_USBRX: begin
            if(cntByte &lt; 16) begin
                nextCntByte = cntByte + 1;
                currentByte = USB_DATAIN; // contains received byte in receive cycle
                shiftBufRx = 1; // shift buffer after this cycle
            end
            [...]
        end
        STATE_USBTX: begin
            if(cntByte &lt; 15) begin
                shiftBufTx = 1; // shift buffer after this cycle
                nextCntByte = cntByte + 1;
            end
            [...]
        end
        [...]
    endcase
end


This code works perfectly in simulation (iVerilog). But when synthesizing and executing on an Altera Cyclone, I get very strange errors. For example, most of the time the first byte transmitted to the FPGA is read for each byte. For example, sending 11 22 33 44 55 66 ... would receive 11 11 11 11 11 11 ....

Now when I instead introduce a new variable:

reg [127:0] nextDataBuf;


and replace the part in the sequential always @(posedge FIFO_CLK) block with:

if(shiftBufRx) begin
    dataBuf &lt;= nextDataBuf;
end
if(shiftBufTx) begin
    dataBuf &lt;= nextDataBuf;
end


and in the combinational part:

        STATE_USBRX: begin
            if(cntByte &lt; 16) begin
                nextCntByte = cntByte + 1;
                //currentByte = FIFO_DATAIN;
                nextDataBuf = { dataBuf[127-8:0] , FIFO_DATAIN };
                shiftBufRx = 1;
            end
            [...]
        end
        STATE_USBTX: begin
            if(cntByte &lt; 15) begin
                shiftBufTx = 1;
                nextCntByte = cntByte + 1;
                nextDataBuf = { 8'h00 , dataBuf[127:8] };
            end
            [...]
        end


Then it works!

That means: All I am doing is to move the shifting of the register from the sequential block to the combinational block.

I do not see any race conditions in my code and in simulation (iVerilog) both versions are identical.

What could be the reason?","First of all you should definitely post a MVCE. This is almost an MVCE, but it doesn't contain a testbench and the ellipsis [...] obscures things that could be relevant like the state transitions from RX to TX.

Never the less, as it was close, I built a small test bench and added some minimal code to get it running. In my case it did NOT work ""perfectly in simulation"". In fact, as @greg pointed out, there is a definite error in the shift register.

In your before code, you are shifting left out of register, but are transmitting the low bytes. The first cycle they will be 8'h11 and afterward will either be 8'h00 or stay the same, depending on when shiftBufTx is true, and this depends on logic that isn't posted. There is enough posted to see that it cannot possibly work correctly as is.

    assign USB_DATAOUT = dataBuf[7:0];
    ...
    if(shiftBufTx) begin // cycle was a transmit
        dataBuf &lt;= { dataBuf[127-8:0] , 8'h00 };
    end


In the after code, you are shifting right and this is why it works:

nextDataBuf = { 8'h00 , dataBuf[127:8] };


It is possible that the sim does not match synthesis for a similar reason. The code looks fairly synthesizable. Some suggestions:


There is no reason to have independent flags for Tx and Rx
As @serge pointed out, what happens if they conflict? This may sim okay but will not work in hardware.
You could just use a single flag and set it in the output of each state.
If you need more than one condition, you must have an else that insures that only one path can modify each non-blocking assignment to a var is active at any clock edge:

if(shiftBufRx) begin // cycle was a receive
    dataBuf &lt;= { currentByte , dataBuf[127:8] };
end
**else** if(shiftBufTx) begin // cycle was a transmit
    dataBuf &lt;= **{ 8'h00 , dataBuf[127:8] }**;
end



Why did it appear to work in sim? Beyond small typos or transpositions of supposedly identical code, the sim is very forgiving of multiple writes to the same var (the later will ""win"").

But the synthesis tool must intuit your intent into registers. Depending on how complex the logic is, it might not be able to know that both flags can't be true at the same time. Sometimes it will interpret things like this as two parallel ""write enable"" conditions for dataBuf and create two parallel registers. The 2nd copy probably just never shifted back out after being set to 8'h11 which matches the symptoms. You should examine the actual output circuit after elaboration to detect this kind of error. Unfortunately not all of them fail or even give obvious warnings. In Xilinx Vivado you can pull up the schematic. ",,,,,
multiple drive issue when receiving inputs from external source in verilog synthesis,"The synthesis I'm trying to do is on a GCD algorithm Finite State Machine that works using the ""subtract if bigger"" method. I will attach the code and try and formulate a decent question.  

module GCD_R (A,B,out,nrst,act,clk,fla_g);
  input [31:0] A, B;
  input clk, act, nrst;
  output reg fla_g;     
  output reg [31:0] out;
  reg [3:0] state, next_state;
  reg [31:0] A_reg, B_reg, Aint_reg, Bint_reg, out_reg;//2 registers will keep intermediate numbers+out, and next numbers
  parameter IDLE = 3'b001;
  parameter ABIG = 3'b010;
  parameter BBIG = 3'b100;
  reg next_flag;


  always @(*)   
    case (state)
      IDLE: begin
        $display(""start"");
        if(act == 0) begin
          A_reg = A; //A,B are wires that contain numbers from an external source
          B_reg = B; //first assign to A_reg and B_reg
          out_reg = 31'bx;
          next_flag = 1'b0;
          next_state = IDLE;
        end
        if(act == 1)
          if(A_reg==0) begin
            out_reg = B_reg;
            next_flag = 1'b1; //testbench will know when we stopped 
            Aint_reg = A_reg; //taking care not to infer latches
            Bint_reg = B_reg; 
            next_state = IDLE;
          end
          else if (B_reg==0) begin  
            out_reg = A_reg;
            next_flag = 1'b1;
            Aint_reg = A_reg; //taking care not to infer latches
            Bint_reg = B_reg;
            next_state = IDLE;
          end                       
          else if (A_reg &gt;= B_reg) begin
            out_reg = 31'bx;
            next_flag = 1'b0;
            Aint_reg = A_reg;
            Bint_reg = B_reg;
            next_state = ABIG;
          end
          else begin
            out_reg = 4'bxxx;
            next_flag = 1'b0;
            Aint_reg = A_reg;
            Bint_reg = B_reg;
            next_state = BBIG;
         end
       else
        begin
         Aint_reg = A_reg;
         Bint_reg = B_reg;
         out_reg = 4'bxxx;
         next_flag = 1'b0;  
         next_state = 4'bx;
        end
     end

     ABIG: begin
       if (A_reg==0 | B_reg==0) begin
         out_reg = 31'bx;
         next_flag = 1'b0;
         next_state = IDLE;
         Aint_reg = A_reg;
         Bint_reg = B_reg;
       end
       else if (B_reg &gt; A_reg) begin
         out_reg = 31'bx;
         next_flag = 1'b0;
         next_state = BBIG;
         Aint_reg = A_reg;
         Bint_reg = B_reg;
       end
       else begin
         out_reg = 31'bx;
         next_flag = 1'b0;
         next_state = ABIG; 
         Aint_reg = A_reg - B_reg;
         Bint_reg = B_reg;
       end
     end

     BBIG: begin 
       if (A_reg==0 | B_reg==0) begin
         out_reg = 31'bx;
         next_flag = 1'b0;
         next_state = IDLE;
         Aint_reg = A_reg;
         Bint_reg = B_reg;
       end 
       else if (A_reg &gt; B_reg) begin 
         out_reg = 31'bx;
         next_flag = 1'b0;
         next_state = ABIG;
         Aint_reg = A_reg;
         Bint_reg = B_reg;
       end
       else begin 
         out_reg = 31'bx;
         next_flag = 1'b0;
         next_state = BBIG; 
         Aint_reg = A_reg;
         Bint_reg = B_reg - A_reg;
       end  
     end

     default: begin
       out_reg = 31'bx;
       next_flag = 1'b0;
       next_state = 4'bx;
       Aint_reg = A_reg;
       Bint_reg = B_reg;
       $display(""%t: State machine not initialized/n"",$time);
     end
   endcase

 always @(posedge clk or negedge nrst)
   if (~nrst) begin
     state &lt;=  IDLE;//we get the new values by resetting first
     out &lt;= 4'bx;//we don't want anything there at the reset
     fla_g &lt;= 1'b0;
   end
   else begin
     state &lt;=  next_state;//otherwise, get the next state and the next registers to the intermediate ones
     A_reg &lt;=  Aint_reg;// 2nd assign to A_reg and B_reg- that's the problem
     B_reg &lt;=  Bint_reg;
     out &lt;=  out_reg;
     fla_g &lt;= next_flag;
   end

endmodule


first, A and B are wires that will receive a list of numbers to compare via external source(some textfile in a testbench).    

A_reg and B_reg are the intermediate registers that keep the numbers that we are checking the ""if"" statements on,     

Aint_reg and Bint_reg are registers that keep the intermediate values of registers after the operations only to send them back to A_reg and B_reg when the clock is rising,  

act decides whether the machine is on ""on"" mode and can perform the algorithm  

nrst is the negative reset toggle  

how was the problem formed:  

you can see that at the beginning, there is an if(act == 0) condition. It was put there to ensure that the values at the A,B wires(received externally) will enter the registers there, instead of entering them in the sequential block while we were on the if(~nrst) condition since it made no sense entering a dynamic value while in reset.  

This takes us to the current problem- I know that assigning a value to A and B both in the sequential and combinatoric blocks is what creates the problem, but I just can't find an alternative.  

p.s. the fact that I'm using A_reg = A creates latches since I don't assign to A_reg anywhere else, and that's another problem since writing
Aint_reg = A_reg;
 A_reg = Aint_reg;
to satisfy latches doesn't sit right with me.  

p.s.2. I tried looking into the similar questions on the site, but owing to my lack of enough knowledge on the subject I couldn't relate my problem to the ones out there   

I'll be glad to receive any help, thanks  

EDIT: I deleted the nonblocking assignments in the if(~nrst) sequential block so as to not to multiple assign A_reg &lt;= 0 there and A_reg = A in the combinatoric block, but the multiple assignment problem still bugs it somehow  

EDIT2: seems that I forgot a fundamental thing- don't assign to the same variable in two different ""always"" block, but I just can't think of a good enough solution to assign the wires A,B to a register and not assign to it again in the sequential block","You are correct in identifying the major problem in your code is that you are not handling registers and combinational logic correctly. Whenever you have a register (register, not reg type, they are not the same and it is confusing for those new to Verilog), you need to define it in a particular way so synthesis and simulation tools can handle it. The safest practice is to create a clean separation between combinational logic and sequential storage (ie, actual registers). You started to do this with Aint_reg, Bint_reg, out_reg, etc; but you need to do it for all registered values whose values come from conbinational blocks. So, all these ideas together yields a struct for code like this (not completely your code but something similar):

input [31:0] A, B;
output reg [31:0] out;

reg [31:0] regA, regB;
reg [3:0] state, nextState;

always @(posedge clk or negedge rst) begin
  if (~rst) begin
    regA &lt;= '0;
    regB &lt;= '0;
    state &lt;= IDLE;
  end
  else begin
    regA &lt;= nextA;
    regB &lt;= nextB;
    state &lt;= nextState;
  end
end

always @(*) begin
  // Default; I always do this here to ensure there are no cases in which I dont assign a combinational value for this block
  // it always helps me keep track of which variables are assigned in which block
  nextA = regA;
  nextB = regB;
  nextState = state;

  out = '0;

  case (state)
    // In here is your case body, where you can reassign nextA, nextB, nextState and out
    // where the assignments are only dependent on A, B, regA, regB and state (ie, the values NOT assigned in this block)  
  endcase
end


With this in mind, you need to have only the Aint_reg, Bint_reg, etc in the combinational block; so you dont need to assign A_reg, Breg, etc in the combinational block. Note also that if this will mean the timing of out will be delayed, so you can always bypass the register if you need to push a value out from a combination block immediately. From what I understand, you might be having issues with loading during a reset, which is understandable as so long as reset (nrst) is asserted (ie, 0), nothing will load. That is the entire point of a reset, to hold the system in a known state until it is lifted. So until nrst is deasserted, your module shouldnt do anything. A few other points:


Formating your code correctly is very important, make sure your code is always clean as it helps spot bugs. I reformatted it and there seems to be a missing begin..end in the last block of the IDLE state
Always begin..end your blocks, it will avoid so many bugs
Watch out for the size of things, I see you declared your variables to be 32 bits reg [31:0] but are only assigning them using 31'd which is 31 bits. Use '0 syntax to zero fill for any size.
Setting registers to 'x is not ideal, you should have registers just retain their state (as you do thing for register values and next register values).


Hope this clarifies things for you.",,,,,
Verilog: bit slice vector twice,"Suppose we have a 128 bit reg:

reg [127:0] line;


And we first select a 32-bit word out of it, and then select byte from this word, all using slicing:

word = line[(127-32*byte_addr[3:2])-:32];
byte = word[7:0];


That works fine. But if I wan't to combine both operators, in same line, it seems it is not permitted.

mybyte = line[(127-32*byte_addr[3:2])-:32][7:0]; //all the hell breaks loose


Unfortunately I couldn't find a clear rule in SV 3.1a spec that forbids this.","Please delete your SystemVerilog 3.1a spec and get a free copy of the 1800-2012 LRM

The concatenation operator described in section 11.4.12 does what you want.

mybyte = {line[(127-32*byte_addr[3:2])-:32]}[7:0];
",,,,,
"VHDL - My code is synthesizable and works the way i want on simulation, but it doesn't on the fpga","My VHDL-Code is functionaly correct, in simulation it does what it's thought for. I tested in many variations and the code works correct.

But when i program the fpga (Nexyx 4 ddr) everything works well except the preload of the counter.

I don't know if the load enable (load_e) output from the fsm doesn't reach the counter or if the output signal that sais the counter is loaded (counter_loaded) doesn't reach the fsm but when i program the fpga it never pases from state C or D (waiting for counter loaded) to state E or F (where it makes a countdown).

I tested the other parts of the code in the target and it works properly, so the only problema so far is that one and i can't find the error, i'm thinking about timming, but i have no idea of how to solve it.

I leave here the counter and fsm code, as well as the TOP code, i`m new in VHDL and it might be lots of bad practice mistakes.

I'm spanish, that's the reason of my bad English and also the spanish name of some signal, but i add a comment next to them. 

--------COUNTER---------------------------------------

entity counter is
Generic (NBITS    : positive := 15
        );
Port    (clk      : in STD_LOGIC;
        rst      : in STD_LOGIC;
        ce       : in STD_LOGIC;
        load     : in STD_LOGIC_VECTOR (NBITS-1 downto 0);
        load_e   : in STD_LOGIC;
        unit     : out STD_LOGIC_VECTOR(3 downto 0); 
        dec      : out STD_LOGIC_VECTOR(3 downto 0); 
        zero_n   : out STD_LOGIC;                   --true si cuenta = 0
        loaded   : out STD_LOGIC);
end counter;

architecture Behavioral of counter is
signal q_i : unsigned (NBITS-1 downto 0) := (others =&gt; '1');
begin  
    process(clk,rst)
        begin
            if rst = '1'    then
                q_i &lt;= (OTHERS =&gt; '1');
                loaded &lt;= '0';
            elsif rising_edge(clk)  then
                if CE = '1' then
                    if load_e = '1' then             --ONE OF MY GUESSES OF THE PROBLEM
                        q_i &lt;= unsigned(load);
                        loaded &lt;= '1';
                    else
                        q_i &lt;= q_i - 1;
                        loaded &lt;= '0';                        
                    end if;
                end if;
            end if;              
        end process;     
    dec &lt;= std_logic_vector(to_unsigned((to_integer(q_i(14 downto 10)) / 10),dec'length));      --first 5 bits are the tens        
    unit &lt;= std_logic_vector(to_unsigned((to_integer(q_i(14 downto 10)) rem 10),unit'length));  --fist 5 bits are the unit
    zero_n &lt;= '1' WHEN q_i &lt; ""000010000000000"" ELSE '0';        --cout is zero if the first 5 bits are less tan 1 in binary
end Behavioral;

------FINITE STATE MACHINE--------------------------------

entity maquina_estados is
Port ( 
    clk : in STD_LOGIC;
    rst : in STD_LOGIC;
    corto : in STD_LOGIC;
    largo : in STD_LOGIC;
    b_on : in STD_LOGIC;
    zero_n : in STD_LOGIC;
    counter_loaded : in STD_LOGIC;
    load_e : out STD_LOGIC;
    load : out STD_LOGIC_VECTOR(14 downto 0);
    bomba_led : out STD_LOGIC;
    indica_on : out STD_LOGIC);
end maquina_estados;

architecture Behavioral of maquina_estados is

type state_type is (A, B, C, D, E, F);  --define state(A = powered off, B = powered on, C = short coffee preload, D = large coffee preload, E = short coffee, F = large coffee)

signal state, next_state : state_type;  --type state signal

begin 
    process(clk,rst)
        begin
            if rst = '1' then
                state &lt;= A;
            elsif rising_edge(clk) then
                state &lt;= next_state;
            end if;
    end process;

    process(state, b_on, corto, largo, zero_n, counter_loaded)
        begin
            CASE state IS
                WHEN A =&gt;   if b_on = '1' then
                                next_state &lt;= B;
                            else
                                next_state &lt;= A;
                            end if;
                WHEN B =&gt;   if b_on = '0' then
                                next_state &lt;= A;
                            elsif corto = '1' then
                                next_state &lt;= C;
                            elsif largo = '1' then
                                next_state &lt;= D;
                            else
                                next_state &lt;= B;
                            end if;
                WHEN C =&gt;   if counter_loaded = '1' then
                                next_state &lt;= E;
                            else
                                next_state &lt;= C;
                            end if;
                WHEN D =&gt;   if counter_loaded = '1' then
                                next_state &lt;= F;
                            else
                                next_state &lt;= D;
                            end if;
                WHEN E =&gt;   if zero_n = '1' then
                                next_state &lt;= B;
                            else
                                next_state &lt;= E;
                            end if;
                WHEN F =&gt;   if zero_n = '1' then
                                next_state &lt;= B;
                            else
                                next_state &lt;= F;
                            end if;
                WHEN OTHERS =&gt; next_state &lt;= A;
            end case;
    end process;

    process(state)
        begin
            CASE state IS
                WHEN A =&gt;   load        &lt;= ""111111111111111"";  --default value of the count 
                            load_e      &lt;= '0';
                            bomba_led   &lt;= '0';
                            indica_on   &lt;= '0';
                WHEN B =&gt;   load        &lt;= ""111111111111111"";
                            load_e      &lt;= '0';
                            bomba_led   &lt;= '0';
                            indica_on   &lt;= '1';
                WHEN C =&gt;   load        &lt;= ""010101111111111"";  --10 second, this in addition to a 1024 hz clock made posible to use the first 5 bits as the number
                            load_e      &lt;= '1';
                            bomba_led   &lt;= '0';
                            indica_on   &lt;= '1';
                WHEN D =&gt;   load        &lt;= ""101001111111111"";  --20 seconds
                            load_e      &lt;= '1';
                            bomba_led   &lt;= '0';
                            indica_on   &lt;= '1';
                WHEN E =&gt;   load        &lt;= ""111111111111111"";
                            load_e      &lt;= '0';
                            bomba_led   &lt;= '1';
                            indica_on   &lt;= '1';
                WHEN F =&gt;   load        &lt;= ""111111111111111"";
                            load_e      &lt;= '0';
                            bomba_led   &lt;= '1';
                            indica_on   &lt;= '1';
            end case;
    end process;
end behavioral;

------TOP-----------------------

entity TOP is
Generic(
FIN     : positive := 100000000;
FOUT    : positive := 1024);
Port ( clk : in STD_LOGIC;
       rst : in STD_LOGIC;
       corto : in STD_LOGIC;
       largo : in STD_LOGIC;
       b_on : in STD_LOGIC;
       display_number : out STD_LOGIC_VECTOR (6 downto 0);
       display_selection : out STD_LOGIC_VECTOR (7 downto 0);
       bomba_led : out STD_LOGIC;
       indica_on : out STD_LOGIC);
end TOP;

architecture Behavioral of TOP is



  --instancies

  component clk_divider is
   --  Port ( );
   generic(
FIN     :   positive;
FOUT    :   positive
);
port ( 
Clk     :   in STD_LOGIC;
Reset   :   in STD_LOGIC;
Clk_out :   out STD_LOGIC
);
end component;


component maquina_estados is
Port ( clk : in STD_LOGIC;
       rst : in STD_LOGIC;
       corto : in STD_LOGIC;
       largo : in STD_LOGIC;
       b_on : in STD_LOGIC;
       zero_n : in STD_LOGIC;
       counter_loaded : in STD_LOGIC;
       load_e : out STD_LOGIC;
       load : out STD_LOGIC_VECTOR(14 downto 0);
       bomba_led : out STD_LOGIC;
       indica_on : out STD_LOGIC);
end component;

component counter is
Generic (NBITS    : positive
        );
Port    (clk      : in STD_LOGIC;
        rst      : in STD_LOGIC;
        ce       : in STD_LOGIC;
        load     : in STD_LOGIC_VECTOR (NBITS-1 downto 0);
        load_e   : in STD_LOGIC;
        unit     : out STD_LOGIC_VECTOR(3 downto 0); 
        dec      : out STD_LOGIC_VECTOR(3 downto 0); 
        zero_n   : out STD_LOGIC;                   
        loaded   : out STD_LOGIC);
end component;


component clk_manager is
generic(
CLK_FREQ : positive
);
Port (
clk : in STD_LOGIC;
rst : in STD_LOGIC;
strobe_1024Hz : out STD_LOGIC;
strobe_128Hz : out STD_LOGIC
);
end component;

component decoder is
Port ( code : in STD_LOGIC_VECTOR(3 downto 0);
       led : out STD_LOGIC_vector(6 downto 0)
      );
end component;

component display_refresh is
Port ( clk                  : in STD_LOGIC;
       ce                   : in STD_LOGIC;
       segment_unit         : in STD_LOGIC_VECTOR (6 downto 0);
       segment_dec          : in STD_LOGIC_VECTOR (6 downto 0);
       display_number       : out STD_LOGIC_VECTOR (6 downto 0);
       display_selection    : out STD_LOGIC_VECTOR (1 downto 0));   --cada elemento del vector corresponde a un 7 seg, true se ve false no
end component;                                                   


-- prescaler signals

signal prescaler_clk_out : STD_LOGIC;

--maquina estados signals
signal zero_n_fsm : STD_LOGIC;
signal load_e_fsm : STD_LOGIC;
signal load_fsm : STD_LOGIC_VECTOR(14 downto 0);
signal bomba_led_fsm: STD_LOGIC;
--counter signals
signal unit : STD_LOGIC_VECTOR(3 downto 0); 
signal dec      : STD_LOGIC_VECTOR(3 downto 0); 
signal zero_n_cntr : STD_LOGIC;
signal load_e_cntr : STD_LOGIC;
signal load_cntr : STD_LOGIC_VECTOR(14 downto 0);
signal counter_loaded : STD_LOGIC;
--clk_manager signals
signal strobe_1024Hz : STD_LOGIC;
signal strobe_128Hz : STD_LOGIC;

signal ce_clkm : STD_LOGIC;
signal rst_clkm : STD_LOGIC;

--decoders signals

signal unit_code : STD_LOGIC_VECTOR(6 downto 0);
signal dec_code : STD_LOGIC_VECTOR(6 downto 0);

--display refresh signals

signal display_refresh_number : STD_LOGIC_VECTOR(6 downto 0);
signal display_refresh_selection : STD_LOGIC_VECTOR(1 downto 0); 

begin

prescaler: clk_divider
    generic map(
    FIN     =&gt;   FIN,
    FOUT    =&gt;   FOUT
    )
    port map( 
    Clk     =&gt;   clk,
    Reset   =&gt;   rst,
    Clk_out =&gt;   prescaler_clk_out
    ); 

sm: maquina_estados
    Port map( clk =&gt; prescaler_clk_out,
           rst =&gt; rst,
           corto =&gt; corto,
           largo =&gt; largo,
           b_on =&gt; b_on,
           zero_n =&gt; zero_n_fsm,
           counter_loaded =&gt; counter_loaded,
           load_e =&gt; load_e_fsm,
           load =&gt; load_fsm,
           bomba_led =&gt; bomba_led_fsm,
           indica_on =&gt; indica_on);

cntr: counter 
Generic map(NBITS    =&gt; 15
        )
Port map(clk      =&gt; clk,
        rst      =&gt; rst,
        ce       =&gt; strobe_1024Hz,
        load     =&gt; load_cntr,
        load_e   =&gt; load_e_fsm,
        unit     =&gt; unit,
        dec      =&gt; dec,
        zero_n   =&gt; zero_n_cntr,                 
        loaded   =&gt; counter_loaded);

   clk_m: clk_manager 
       generic map(
       CLK_FREQ =&gt; FIN
       )
       Port map(
       clk =&gt; clk,        
       rst =&gt; rst,
       strobe_1024Hz =&gt; strobe_1024Hz,
       strobe_128Hz =&gt; strobe_128Hz
       ); 

   unit_dcd: decoder 
       Port map( 
       code =&gt; unit,
       led =&gt; unit_code
       );

    dec_dcd: decoder 
      Port map( 
      code =&gt; dec,
      led =&gt; dec_code
      );

    dr: display_refresh 
     Port map(
     clk                  =&gt; clk,       
     ce                   =&gt; strobe_128Hz,
     segment_unit         =&gt; unit_code,
     segment_dec          =&gt; dec_code,
     display_number       =&gt; display_refresh_number,
     display_selection    =&gt; display_refresh_selection);   


    display_number &lt;= display_refresh_number WHEN bomba_led_fsm = '1' ELSE ""1111111"";
    display_selection &lt;= (""111111"" &amp; display_refresh_selection) WHEN bomba_led_fsm = '1' ELSE ""11111111"";
    zero_n_fsm &lt;= zero_n_cntr;
    bomba_led &lt;= bomba_led_fsm;
    load_cntr &lt;= load_fsm;      
end Behavioral;


Here are all the reports that the implementation ans sythesis gave me:

Synthesis reports

implementation reports 1/6

implementation reports 2/6

implementation reports 3/6

implementation reports 4/6

implementation reports 5/6

implementation reports 6/6

I hope someone could find the problema and give me a solution or a way of how to debug this problem. 

Thanks.","Your FSM is clocked on prescaler_clk_out, and your counter is clocked on clk, which is a red flag. This could easily lead to an implementation failure.


Draw a timing diagram showing all your clocks and resets, and your lower-frequency enables (in particular, strobe_1024Hz)
Try to clock all the logic on the same clock, presumably clk, and make sure that everything is synchronous to this clock (in other words, inputs have sufficient setup and hold times relative to this clock)
Make sure you are actually resetting the chip


Once you've done the timing diagram, write a constraints file that tells the synthesiser what your clocks are. clk_manager and clk_divider may be an issue here, but hopefully everything will be clocked on just 'clk', and the contstraints file will contain only the clock name and frequency. If you still can't get it to work, ask a new question, showing your timing diagram, and your attempt at a constraints file.",,,,,
"Verilog, Parallel in Series out Shift Register","I am learning and practicing Verilog HDL. I wanted to design a 16 bit parallel in series out shift register. 

module verilog_shift_register_test_PISO( din, clk, load, dout );

output reg dout ;

input [15:0] din ;
input clk ;
input load ;

reg [15:0]temp;

always @ (clk or load) begin
 if (load)
  temp &lt;= din;
 else begin
  dout &lt;= temp[0];
  temp &lt;= {1'b0, temp[15:1]};
 end
end
endmodule  


I wrote this code and tried to simulate it.

simulation result

simulation_result
I could not understand the reason why data output (dout) signal is always LOW","It works for me.

BUT!
That code can no be turned into gates.
You must use 'posedge clk' or 'negedge clk'. 
Also your load is a-synchronous which is very unusual and can
give race conditions against the clock edge.

always @ (posedge clk)
begin
   if (load)
      temp &lt;= din;
   else
   begin
     dout &lt;= temp[0];
     temp &lt;= {1'b0, temp[15:1]};
   end
end


Furthermore it is usual to have a reset condition. As long as there is no 'load' signal the dout will produce X-es. This can very much upset the rest of your circuit. Also you have an extra clock delay in dout. You could, if you want, save a clock cycle there. Here its is with an a-synchronous active low reset:

always @ (posedge clk or negedge reset_n)
begin
   if (!reset_n)
      temp &lt;= 16'h0000;
   else
   if (load)
      temp &lt;= din;
   else
     temp &lt;= {1'b0, temp[15:1]};
end

assign dout = temp[0];
",,,,,
Clock toggles only once from 0 to 1 and then stops toggling,"initial begin 

clock =0 ;

end

always@(clock) begin 

$display(""Inside clock always block"");
#40 clock = ~ clock;
end


When I simulate this , clock changes from 0 to 1 and then stays 1. Why do I see just one toggle ?","You want:

always
  #40 clock = ~ clock;


Presumably nothing else is driving clock, so because you had clock in the sensitivity list, clock never changed again and so the always block never executed again.",,,,,
Can we synthesis a simple generic memory?,"I'm trying to synthesis with simple generic memory model within design compiler.

but I do find that some error messages as the below,

and I used the simple generic memory model as the below

module RAM_generic
 (clk,
 enb,
 wr_din,
 wr_addr,
 wr_en,
 rd_addr,
 rd_dout);

 parameter AddrWidth = 1;
 parameter DataWidth = 1;

 input clk;
 input enb;
 input signed [DataWidth - 1:0] wr_din;
 input [AddrWidth - 1:0] wr_addr;
 input wr_en;
 input [AddrWidth - 1:0] rd_addr;
 output signed [DataWidth - 1:0] rd_dout;

 reg [DataWidth - 1:0] ram [2**AddrWidth - 1:0];
 reg [DataWidth - 1:0] data_int;


 always @(posedge clk)
 begin
 if (enb == 1'b1) begin
 if (wr_en == 1'b1) begin
 ram[wr_addr] &lt;= wr_din;
 end
 data_int &lt;= ram[rd_addr];
 end
 end

 assign rd_dout = data_int;
endmodule


I want to know Can't we synthesis a simple generic memory? If yes, What am I supposed to do to synthesis the generic memory synthesis error?","Yes you can. 

In FPGA's a single or dual ported memory will be mapped on the internal memory structures. (At least if you use the right syntax! Look for the FPGA application notes how to do that)

In an ASIC it will be made from registers. I needed a small triple ported memory (Two read and a write port all simultaneous) a few years back and it came out fine. Most FIFO's have a memory in them and 90% of them are made from registers. 

Your code is missing 'endmodule'. I don't spot any other obvious errors. 

Some tips:  


Using ((1 &lt;&lt; AddrWidth) -1) will also work in old fashion Verilog.  
I would not use a default width/depth of 1 for a memory. You get [0:0] constructs which work, but why should you if e.g. 8x8 is more likely to be used.
A generic memory should not be signed. By convention a generic memory is unsigned.
Parameters are by convention all uppercase. (At least in every firm I worked it was)
",,,,,
Verilog select bit depending on input,"I am writing a behavioral verilog module where a different bit is selected based upon one of the input variables.  I wrote the following code to reference the 3-S position in the D vector:

module Part4(input [3:0] D, input [1:0] S, output F);
    always @(D, S)
        F = D[3-S];
endmodule


This gives the following errors: ""ERROR:HDLCompilers:247 - ""Part4.v"" line 5 Reference to scalar wire 'F' is not a legal reg or variable lvalue
ERROR:HDLCompilers:44 - ""Part4.v"" line 5 Illegal left hand side of blocking assignment""

How do I go about selecting a different bit based upon the input S?","If F is a wire, then you can't assign to it inside an always @ block. Either change it to a reg, or do the assignment outside of an always @ block like this:

module Part4(input [3:0] D, input [1:0] S, output F);
    assign F = D[3-S];
endmodule
",,,,,
Removing Multi-driver nets,"I have a static array in verilog and I'm reading a value and trying to find the index of that value in the array. 

For this I've done 

array[0:200] = {32h'14151,...};
reg[8:0] val_idx = 511;
reg[31:0] val; 
generate begin: hash
for(genvar i = 0 ; i &lt; 200; i = i + 1) begin: hash_loop
   always@ (posedge clk) begin
     case(value)
     array[i]:
       val_idx &lt;= i;
     endcase
   end  
end
end endgenerate


However when I try to synthesise it using Vivado I get Multiple Driver Nets 200 times and it bails. What is the correct way to do this? I'm new to verilog so apologies if the question is stupid. ","A generate for-loop reproduces the code. Thus what you are writing gets expanded to:

   always@ (posedge clk) begin
   case(value)
   array[0]:
     val_idx &lt;= 0;
   endcase
 end  

 always@ (posedge clk) begin
   case(value)
   array[1]:
     val_idx &lt;= 1;
   endcase
 end  

etc.


From that you can see that val_idx is driven from two always statements. 

You might think that the statements are independent but they are not. 
That is because you did not specify an default thus the rule is that in that case val_id should remain unchanged.

Remove the genvar and use a normal for-loop inside the clocked section.

Notes:  

reg[8:0] val_idx = 511; Does not work the way you probably think it does!
use val_idx &lt;= 511; as first statement in the 'always' section.

Your piece of code will expand into a huge amount of logic. You get 200 eight-bit comparators which will get partly optimized. There is a reason why associative memories are done as a dedicated piece of logic. ",,,,,
Why cant my verilog testbench display intermediate variables?,"I want to see what value is stored in a1 and b1 but I get only ""xxxxxx"" as output. Why?

My code is designed to take values of a and b which are 4 bit signed numbers. I am using intermediate variables a1 and b1 to make 2's complement of those numbers if the MSB of a or b is 1 otherwise use the same a and b for my main code. But I am not able to get the intermediate values. 

Relevant code and testbench;

module xx(a,b,z);
    input   signed [3:0] a,b;
    output  signed [7:0] z;
    integer i;
    wire w1,w2,w3,w4,w5,w6,w7,w8,w9,w10,w11,w12;    
    reg [3:0] pp0,pp1,pp2,pp3;
    reg [3:0] a1,b1;

   always @ (a or b)  begin  
      if ( a[3] == 1 &amp;&amp; b[3] == 1) begin
          a1 &lt;= ~a + 1;
          b1 &lt;= ~b + 1;
      end else if ( a[3] == 1 &amp;&amp; b[3] == 0) begin
          a1 &lt;= ~a + 1;
          b1 &lt;=b;
      end else if ( a[3] == 0 &amp;&amp; b[3] == 1) begin
          a1 &lt;= a;
          b1 &lt;= ~b + 1;
      end else begin
          a1 &lt;= a;
          b1 &lt;= b;
      end
   end
.....
endmodule


Testbench

module xxt();
    reg  signed [3:0]a,b;
    wire  signed [7:0]z;
    reg [3:0] a1,b1; 

    xx w1(a,b,z);

    integer i;
    integer j;

    initial
    begin
        for ( i = 0; i&lt;16; i = i + 1)
        begin
            for ( j = 16; j&gt;0; j = j - 1)
            begin
                #10 b=j; a=i;
                //$display(""a*b=z %d %d %d"", a, b, z);
                //$display(""a*b=z %b %b %b"", a, b, z);
                $display(""%t\ta\tb\ta1\tb1\tz\n\t\t%b\t%b\t%b\t%b\t%b"", $time, a, b, a1, b1, z);
                $display(""%t\t%d\t%d\t%d\t%d\t%d"", $time, a, b, a1, b1, z);
            end
        end
    end


endmodule


My transcript displays only this

 10 a   b   a1  b1  z
#       0000    0000    xxxx    xxxx    xxxxxxxx
#                   10    0   0  x   x     x
#                   20  a   b   a1  b1  z
#       0000    1111    xxxx    xxxx    xxxxxxxx
#                   20    0  -1  x   x     x
#                   30  a   b   a1  b1  z
#       0000    1110    xxxx    xxxx    00000000
#                   30    0  -2  x   x     0
#                   40  a   b   a1  b1  z
#       0000    1101    xxxx    xxxx    00000000
#                   40    0  -3  x   x     0
#                   50  a   b   a1  b1  z
#       0000    1100    xxxx    xxxx    00000000
#                   50    0  -4  x   x     0
#                   60  a   b   a1  b1  z
#       0000    1011    xxxx    xxxx    00000000
#                   60    0  -5  x   x     0
#                   70  a   b   a1  b1  z
#       0000    1010    xxxx    xxxx    00000000
#                   70    0  -6  x   x     0
#                   80  a   b   a1  b1  z
#       0000    1001    xxxx    xxxx    00000000
#                   80    0  -7  x   x     0
#                   90  a   b   a1  b1  z
#       0000    1000    xxxx    xxxx    00000000
#                   90    0  -8  x   x     0
#                  100  a   b   a1  b1  z
#       0000    0111    xxxx    xxxx    00000000
#                  100    0   7  x   x     0
#                  110  a   b   a1  b1  z
#       0000    0110    xxxx    xxxx    00000000
#                  110    0   6  x   x     0
#                  120  a   b   a1  b1  z
#       0000    0101    xxxx    xxxx    00000000
#                  120    0   5  x   x     0
#                  130  a   b   a1  b1  z
#       0000    0100    xxxx    xxxx    00000000
#                  130    0   4  x   x     0
#                  140  a   b   a1  b1  z
#       0000    0011    xxxx    xxxx    00000000
#                  140    0   3  x   x     0
#                  150  a   b   a1  b1  z
#       0000    0010    xxxx    xxxx    00000000
#                  150    0   2  x   x     0
#                  160  a   b   a1  b1  z
#       0000    0001    xxxx    xxxx    00000000
#                  160    0   1  x   x     0
....

and so on
","The scope of your testbench variables and the module are different. You need xx.a1, and no declaration of a1, b1 at the testbench level.

You'd also be better off with a more generic 'always', and a case statement (but those are style/performance/defensive, and won't affect the end result).",,,,,
Behaviour of Blocking Assignments inside Tasks called from within always_ff blocks,"Have looked for an answer to this question online everywhere but I haven't managed to find an answer yet. 

I've got a SystemVerilog project at the moment where I've implemented a circular buffer in a separate module to the main module. The queue module itself has a synchronous portion that acquires data from a set of signals but it also has a combinatorial section that responds to an input. Now when I want to query the state of this queue in my main module a task, inside an always_ff block sets the input using a blocking assignment, then the next statement reads the output and acts on that.

An example would look something like this in almost SystemVerilog:

module foo(clk, ...)

    queue = queue(clk, ...)   

    always_ff@(posedge clk)
    begin
        check_queue(...)
    end

    task check_queue();
    begin
        query_in = 3;
        if (query_out == 5)
        begin
            &lt;&lt;THINGS HAPPEN&gt;&gt;
        end
    end
    endtask
endmodule

module queue(clk, query_in, query_out)
    always_comb
    begin
      query_out = query_in + 2;
    end
endmodule


My question essentially comes down to, does this idea work? In my head because the queue is combinatorial it should respond as soon as the input stimulus is applied it should be fine but because it's within a task within an always_ff block I'm a bit concerned about the use of blocking assignments.

Can someone help? If you need more information then let me know and I can give some clarifications.",This creates a race condition and most likely will not work. It has nothing to do with your use of a task. You are trying to read the value of a signal (queue_out) that is being assigned in another concurrent process. Whether it gets updated or not by the time you get to the If statement is a race. U?se a non-blocking assignment to all variable that go outside of the always_ff block and it guarantees you get the previous value.,,,,,
Interface from DE1 board to PC in VHDL,"I am designing a simple IC tester using the DE1 altera board, and I really want to implement a simple user interface which a user can use to input variables into the VHDL program (e.g a small C++ app/form/yougetmypoint) so my basic idea is:

1) start FPGA (after programming)
2) FPGA launches app on PC screen asking for some simple info
3) user enters info, and it is implemented in the VHDL code.
4) from there it conducts some tests.

Basically I wanna know if this is even a possibility? At least if it is possible to implement this in a simple way perhaps using a UART? I've only been learning VHDL for a few days, so please be patient if this is dumb.  ","Looks like you don't get the idea of FPGA and VHDL.

You cannot implement in VHDL any user interface, that will show up in PC. VHDL is not programming language, but hardware description language. What you write in VHDL is code, that describes what FPGA does. You specify functions, and then some tool translates (synthesizes) it to digital electronic circuit. In this circuit all kind of FPGA's stuff is used - LUT tables, registers, buffers, etc. When you launch FPGA and program it, you send it bitstream file, with instruction how all this elements has to be connected to do what you specify in VHDL. It has nothing to do with program, that you can launch on PC.

To do what you want, you can implement UART interface in FPGA, and connect it to PC using some USB to UART converter. Then you can write some app in whatever programming, or scripting language you prefer (for example C++, or Python). In this program you can get some input from user, and send it via UART to FPGA.",,,,,
Converting finite state machine diagram into verilog code,"I've been trying to convert this Mealy finite state machine into Verilog code and it never manages to work for all combinations of states/inputs/etc.



Here is the Verilog code:

 1  `timescale 1ns/100ps
 2  `default_nettype none
 3  
 4  module OddFunction(
 5      output  reg     A,
 6      input   wire    x, y, clk, reset_b
 7  );
 8      
 9      parameter S0 = 1'b0, S1 = 1'b1;
10      
11      reg [1: 0] state, next;
12      initial next = S0;
13      
14      always @(posedge clk) begin
15          if (reset_b == 0) state &lt;= S0;
16          else state &lt;= next;
17          case (state)
18              S0: if ((x || y) &amp;&amp; !(x &amp;&amp; y)) next = S1; else next = S0;
19              S1: if (!((x || y) &amp;&amp; !(x &amp;&amp; y))) next = S0; else next = S1;
20          endcase
21          case (state)
22              S0: A = ((x || y) &amp;&amp; !(x &amp;&amp; y));
23              S1: A = !((x || y) &amp;&amp; !(x &amp;&amp; y));
24          endcase
25      end
26      
27  endmodule
","For the minimum change, the logic assignment to next should be moved into an separate combinational block (always @*). With next as combinational, there is not need to give it an initial value. That should give you the behavior you expect.

Also note you have unnecessary logic. A and state are logically equivalent. Any reasonable synthesizer will merge them. Similarly, you expanded the xor logic into it's equivalent with logic operators. You could simply use the xor bit-wise operator (^). 

Case statements are common for state-machines. However they are not necessary when the state is encoded with two states. You could simplify and rewrite write the always logic as:

always @(posedge clk) begin
  if (reset_b) A &lt;= 0;
  else         A &lt;= A ^ x ^ y;
end
",,,,,
VHDL shift_left/shift_right stopped working,"I had this alu working with the shift left/right function when and the shift amount was being sent in on rd_data2, a 16 bit std_logic_vector.  However I've been forced to change that to a 4 bit std_logic_vector called 'shift' and now it won't shift anymore.

Here's my code.  I can't figure out where I've gone wrong.  Any ideas?

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_unsigned.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
use IEEE.NUMERIC_STD.ALL;
--use IEEE.STD_LOGIC_ARITH.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity alu_v2 is
Port ( rd_data1 : in  STD_LOGIC_VECTOR (15 downto 0);
       rd_data2 : in  STD_LOGIC_VECTOR (15 downto 0);
       alu_mode : in  STD_LOGIC_VECTOR (2 downto 0);
       result : out  STD_LOGIC_VECTOR (15 downto 0);
            clk :   in  std_logic;
         shift  :   in  std_logic_vector (3 downto 0);
         rst    :   in  STD_LOGIC;
       z_flag : out  STD_LOGIC;
       n_flag : out  STD_LOGIC);
end alu_v2;

architecture Behavioral of alu_v2 is

begin

process(rd_data1,rd_data2,alu_mode,rst)

variable    temp :  STD_LOGIC_VECTOR(15 downto 0):=X""0000"";
variable    m_temp  :   std_logic_vector(31 downto 0);

begin

if (rst = '1' ) then
    n_flag &lt;= '0';
    z_flag &lt;= '0';
    result &lt;= X""0000"";

    else if (rst = '0') then

        case alu_mode(2 downto 0) is

            when    ""000""   =&gt;  NULL;
            when    ""001""   =&gt;  temp    := rd_data1 + rd_data2 ;
            when    ""010""   =&gt;  temp    :=  rd_data1 - rd_data2 ;
            when    ""011""   =&gt;  m_temp  :=  rd_data1 * rd_data2;
                                temp    :=  m_temp(15 downto 0);
            when    ""100""   =&gt;  temp    :=  rd_data1 NAND rd_data2 ;
            when    ""101""   =&gt;  temp    :=  std_logic_vector(shift_left(unsigned(rd_data1),to_integer(unsigned(shift))));
            when    ""110""   =&gt;  temp    :=  std_logic_vector(shift_right((unsigned(rd_data1)),to_integer(unsigned(shift))));
            when    ""111""   =&gt;  z_flag  &lt;=  '0';
                                n_flag  &lt;=  '0';

            when    others  =&gt;  NULL;
            end case;

            if (temp    =   X""0000"" )   then    z_flag  &lt;=  '1';
                                                    n_flag  &lt;=  '0';
            end if;
            if  (temp(15)   =   '1' )   then    n_flag  &lt;=  '1';
                                                    z_flag  &lt;=  '0';
                else if(temp(15)    =   '0')and(temp &gt; 0)   then    n_flag  &lt;=  '0';
                                                                            z_flag  &lt;=  '0';
                end if;
            end if;
        end if;

end if;

result &lt;= temp;

end process;

end Behavioral;
","Yes, multiple things are wrong. First of all, even though you have a clock input port, your design is asynchronous. That's probably wrong.

You should either have a synchronous process with an asynchronous reset

main_proc: process(rst, clk)
begin
    if rst='1' then
        -- reset stuff
    elsif rising_edge(clk) then
        -- do stuff
    end if;
end process;


Or -preferably- a synchronous process with synchronous reset

main_proc: process(clk)
begin
    if rising_edge(clk) then
        if rst='1' then
            -- reset stuff
        else
            -- do stuff
        end if;
    end if;
end process;


This way it will no longer be a problem that signals are missing from the sensitivity list.

Secondly, your flag setting is screwed up. If alu_mode(2 downto 0)=""111"" you first set both flags, but immediately overwrite them if (temp = x""0000"" ) or if (temp(15) = '1' ). No use in setting them before.

Try to avoid the use of variables anyhow. In this case you can avoid the variables by detecting the zero and n-flag outside of the process statement.

    signal result_int : unsigned(result'range) := (others =&gt; '0');
begin
    -- main_process
    result &lt;= std_logic_vector(result_int);
    z_flag &lt;= '1' when to_integer(result_int) = 0 else '0';
    n_flag &lt;= result_int(result_int'length-1);


Thirdly else if --> elsif... no extra end if; needed... And if you type if rst='1' then you never have to follow by elsif rst='0': of course rst='0' if it's not '1'...

Finally, don't use the STD_LOGIC_unsigned package. It's not standardized. Everything you need is in NUMERIC_STD.

p.s. if you don't want to worry about signals missing from the sensitivity list, you can use the VHDL-2008 method process(all). This will automatically include all the relevant signals. You will have to compile in VHDL-2008 mode for this to work.",,,,,
How do I make IO ports which by made of generate function in verilog?,"I'm trying to make a simple DUT witch is including so many instances to implement to FPGA.

How do I make I/O ports which by made to instantiated DUT?

AS you can see the below code, there are TEST DUT, and I want to make 84 input_data I/O in TOP module.

If I use a way of using the below, top's input_data is connected to all of instances's input_data.

But I want to make each 84's I/O ports and connect them.

But I don't know how to do that.

Would you please help me what am I supposed to do ?

module top(

   input_data0,
   input_data1,
   input_data2,
   //...
   input_data83,

// TODO make I/O ports
);
// to declare reg/wire signals.

  input  signed [49:0] input_data0;
  input  signed [49:0] input_data1;
  input  signed [49:0] input_data2;
   //....
  input  signed [49:0] input_data83;


  // I'd like to connect between input_data0~input_data83 and u_test's 83 input_data 



genvar i;
generate

    for (i=0; i&lt;84; i=i+1) begin : amp
    TEST u_test (
        .in_input       (   input_data  )
    );  
end 



endgenerate

endmodule
","You can't do this in Verilog. In SystemVerilog, you would make your input_data port an array.

The best you can do in Verilog, is create a very big vector, and take a slice of it to connect to each TEST module

module top( input wire [(84*50)-1:0] input_data,

// TODO make I/O ports
);

genvar i;
for (i=0; i&lt;84; i=i+1) begin : amp
    TEST u_test (
        .in_input       (   input_data[i*50 +:50] )
    );  
end 
endmodule
",,,,,
How to access record elements and assign value to them?,"I've created a record in VHDL

type direction is record
  left : std_logic;
  right : std_logic;
end record direction;


And I have function that should return this record with assigned values to left and right of either 0 or 1. 

That part of function looks like this:

begin

if (x = 0) then
    direction.left &lt;= '0';
else
    direction.left &lt;= '1';
end if;
....

return direction;
end;


but I keep getting error that it cannot be used as a prefix in a selected name. I've never worked with a record inside a function, so I feel like I'm doing something wrong while accessing the elements of record.

Thank you for any help!","What you have defined is a type

A type is a descriptor to an item, usually a signal or a variable.

Common types in VHDL are std_logic, std_logic_vector, integer, etc... and you have the right to create your own type. The type direction you describe is OK.

To use it, you have to declare in your function a variable defined with this very type :

variable my_direction : direction;


Then you can use the variable my_direction in your function.

type direction is record
  left : std_logic;
  right : std_logic;
end record direction;

function my_func (x...) return direction is
  variable my_direction : direction;
begin

if (x = 0) then
    my_direction.left := '0';
else
    my_direction.left := '1';
end if;
....

return my_direction;
end;
",,,,,
Bit by bit comparison between two variables in Verilog,"Currently, I am beginning to write the firmware by Verilog for one idea. It is comparing bit by bit between two variables and then using one binary counter to count the number of different bits.

For example: 

I have two variables in verilog

A : 8'b00100001;

B : 8'b01000000;

Then I give the condition to compare bit by bit between two variables. If there is difference between 1 bit of A and 1 bit of B at same bit position, binary counter will count.

This is my verilog code:

module BERT_test(
  input CLK,
  input RST,
  input [7:0] SIG_IN,
  input [7:0] SIG_OUT,
  output [7:0] NUM_ERR
);
  integer i;
  reg[7:0] sign_in;
  reg[7:0] sign_out;

  always @(posedge CLK) begin
    sign_in[7:0] &lt;= SIG_IN[7:0];
    sign_out[7:0] &lt;= SIG_OUT[7:0];
  end

  reg [15:0] bit_err; 

  // Combinational Logic
  always @* begin
    bit_err = 8'b0;
    for (i=0;i&lt;8;i=i+1) begin
      if (sign_in[i] == sign_out[i]) begin
        bit_err = bit_err + 8'b0;
      end else begin
        bit_err = bit_err + 8'b1;
      end
    end
    assign NUM_ERR = bit_err;
  end
endmodule 


Then I had a mistake


  Reference to vector wire 'NUM_ERR' is not a legal reg or variable lvalue


I do not know how to solve this problem. Are there any solutions for this problem or how I need to modify my firmware, please suggest me.","You are driving NUM_ERR (a net) from an always block. It is not permitted to drive nets from always blocks (or initial blocks). You need to move this line:

assign NUM_ERR = bit_err;


outside the always block. 

You should not use an assign statement inside an always block. This is legal but is deprecated and means something weird. If you have included this line inside the always block by mistake, then indenting you code properly would have shown it up.",,,,,
How to more easily make coverpoints for each bit in a bus?,"In a design there is a bus with 4 bits, thus alfa[3:0], and I want to make a covergroup that shows if all bit have been both 0 and 1.

One way to do this coule be to write it out like:

covergroup alfa_cv @(posedge clk);
  coverpoint alfa[0];
  coverpoint alfa[1];
  coverpoint alfa[2];
  coverpoint alfa[3];
endgroup

alfa_cv alfa_covergroup = new;


But is there an easier way to make coverpoints to cover each of the bits in a bus?","Usually code coverage includes toggle coverage. You shouldn't have to create a covergroup for this. But you can create an array of covergroups

covergroup cg(input int index, ref bit [31:0] bus) @(posedge clk);
  each_bit: coverpoint bus[index];
  option.per_instance = 1;
endgroup

cg cgbits[32];

for (int index=0; index&lt;$size(alfa);index++)  
   cgbits[index] = new(index,alfa);
",,,,,
SystemVerilog constraint for mapping between two 2D arrays,"There are two MxN 2D arrays: 

rand bit [M-1:0] src [N-1:0]; 
rand bit [M-1:0] dst [N-1:0];


Both of them will be randomized separately so that they both have P number of 1'b1 in them and rest are 1'b0. 

A third MxN array of integers named 'map' establishes a one to one mapping between the two arrays 'src' and 'dst'. 

rand int [M-1:0] map [N-1:0]; 


Need a constraint for 'map' such that after randomization, for each element of src[i][j] where src[i][j] == 1'b1, map[i][j] == M*k+l when dst[k][l] == 1. The k and l must be unique for each non-zero element of map. 

To give an example: 
Let M = 3 and N = 2. 

Let src be 

[1   0   1
 0   1   0]


Let dst be

[0   1   1
 1   0   0]


Then one possible randomization of 'map' will be: 

[3   0   1
 0   2   0]


In the above map: 


3 indicates pointing from src[0,0] to dst[1,0] (3 = 1*M+0) 
1 indicates pointing from src[0,2] to dst[0,1] (1 = 0*M+1) 
2 indicates pointing from src[1,1] to dst[0,2] (2 = 0*M+2)
","This is very difficult to express as a SystemVerilog constraint because 


there is no way to conditionally select elements of an array to be unique
You cannot have random variables as part of index expression to an array element.


Since you are randomizing src and dst separately, it might be easier to compute the pointers and then randomly choose the pointers to fill in the map.

  module top;
   parameter M=3,N=4,P=4;
   bit  [M-1:0] src [N];
   bit  [M-1:0] dst [N];
   int  map [N][M]; 
   int  pointers[$];

   initial begin
      assert( randomize(src) with {src.sum() with ($countones(item)) == P;} );
      assert( randomize(dst) with {dst.sum() with ($countones(item)) == P;} );
      foreach(dst[K,L]) if (dst[K][L]) pointers.push_back(K*M+L);
      pointers.shuffle();
      foreach(map[I,J]) map[I][J] = pointers.pop_back();
      $displayb(""%p\n%p"",src,dst);
      $display(""%p"",map);
   end
endmodule
",,,,,
Number of Clock Cycles between events in SV,"I want to calculate the number of clock cycles between a signal's high and low value. I have a signal SIG, it goes high and low multiple times during a simulation. I would like to calculate the average number of cycles when it's high/low. 

Can someone please guide me how to achieve it.Let me know if you need more clarification.","You could have a counter for the clock cycles, starting to count when the signal SIG is high, and stop counting when SIG goes low, in order to measure the number of clock cycles while SIG = ""1"":

int counter = 0; // counter initialization
@(posedge SIG); // waits for SIG to go high
while(SIG == 1) begin // while SIG = ""1""
      @(posedge CLK); // when clock signal gets high
      counter++; // increase counter by 1
end


You could do the same while SIG = ""0"", with @(negedge SIG);.",,,,,
How to get dimensions of a verilog vector port using PLI routines?,"How can I fetch the dimensions of a vector port using the vpi PLI routines? For example, for the vector port declaration ""output [2:1] out;"", how can I get the left dimension as 2 and right dimension as 1?
I tried using vpiRange property but it seems that vpiRange property is not supported for Ports. Thanks!  Putting the code here for clarity.

vpiHandle lowconn = vpi_handle(vpiLowConn, portH);   
int dim = 0;
int ldim[10];
int rdim[10];

vpiHandle range_itr = vpi_iterate(vpiRange, lowconn );

vpiHandle range;
while ((range = vpi_scan(range_itr))) {
  ldim[dim] = vpi_get(vpiLeftRange, range);
  rdim[dim] = vpi_get(vpiRightRange, range);
  dim++;
}
int size = vpi_get(vpiSize, portH);
cout &lt;&lt; endl &lt;&lt; vpi_get_str(vpiName, portH) &lt;&lt; "" size = "" &lt;&lt; size &lt;&lt; "" LeftRange = "" &lt;&lt; vpi_get(vpiLeftRange, lowconn ) &lt;&lt; "" RightRange = "" &lt;&lt; vpi_get(vpiRightRange, lowconn );
for ( int i = 0; i &lt; dim; i++ ) {
  cout &lt;&lt; vpi_get_str(vpiName, portH) &lt;&lt; "" = "" &lt;&lt; ldim[i] &lt;&lt; "":"" &lt;&lt; rdim[i];
}


I am getting -1 from vpi_get(vpiLeft/RightRange) as well as in ldim and rdim. Is there anything erroneos with my code?","Your problem is that both vpiLeftRange and vpiRightRange return vpiHandle, not the value. When you instantiate a module. They could be constant expressions, or variable index expressions (for highcon). so, you can try to get values for them. Here is an example which works for vcs. 

the verilog module looks like this:

module pvpi (pa, pb);
   input wire [3:0] pa;
   input wire [7:6] pb;

   child child_inst(.a(pa), .b(pb));
   initial $report_ports;
endmodule 

module child(input [4:1] a, input [1:2] b);
endmodule // child


c-code is here

#include ""vpi_user.h""

static int getExprValue(vpiHandle conn, int r) {
    vpiHandle expr = vpi_handle(r, conn);

    s_vpi_value val = {vpiIntVal};
    vpi_get_value(expr, &amp;val);
    return val.value.integer;
}

void report_ports() {
    vpiHandle moduleInst = vpi_handle_by_name(""pvpi.child_inst"", 0);
    vpiHandle ports = vpi_iterate(vpiPort, moduleInst);
    vpiHandle port;

    vpi_printf(""%s %s\n"", vpi_get_str(vpiDefName, moduleInst), vpi_get_str(vpiFullName, moduleInst));

    while ((port = vpi_scan(ports))) {

        vpiHandle highConn = vpi_handle(vpiHighConn, port);
        vpiHandle lowConn = vpi_handle(vpiLowConn, port);

        vpi_printf(""   %d %s [%d:%d]/[%d:%d]\n"", vpi_get(vpiDirection, port),  vpi_get_str(vpiFullName, port),
                   getExprValue(highConn, vpiLeftRange), getExprValue(highConn, vpiRightRange),
                   getExprValue(lowConn, vpiLeftRange), getExprValue(lowConn, vpiRightRange)); 

    }
}


here is the result

child pvpi.child_inst
   1 pvpi.child_inst.a [3:0]/[3:0]
   1 pvpi.child_inst.b [7:6]/[1:2]


This should work for simple constant expressions with parameters and literals.",,,,,
Randomize a queue of objects in systemverilog,"I have seen techniques used to randomize queues of integral values, but I am having difficulties with queues of objects. An example code:

class int_queue_class;
  rand int x[$];

  function void print;
    $display($sformatf(""Size: %0d"", x.size()));
    foreach(x[i])
      $display($sformatf(""x[%0d] = %0d"", i, x[i]));
  endfunction : print

endclass : int_queue_class


class obj;
  rand int value;
endclass : obj

class obj_queue_class;
  rand obj x[$];

  function void print;
    $display($sformatf(""Size: %0d"", x.size()));
    foreach(x[i])
      $display($sformatf(""x[%0d] = %0d"", i, x[i].value));
  endfunction : print

endclass : obj_queue_class


program top();
  initial
  begin
    int_queue_class iqc;
    obj_queue_class oqc;
    iqc = new();
    iqc.randomize() with {x.size() == 5; x[2] == 5;};
    iqc.print();
    oqc = new();
    oqc.randomize() with {x.size() == 5; x[2].value == 5;};
    oqc.print();
  end
endprogram : top


It seems that the same approach cannot be used when it comes to objects. Is there a way to randomize such a queue while keeping the ability to simultaneously constrain the queue size and individual element fields? The ideas that I've come up with that use pre/post randomize methods all loose at least one of those two options.","Randomization doesn't create new objects. When you randomize the size of a queue it will create new entries which contain the default values, which for class types is null.

The only thing you can do is to pre-allocate objects inside your queue, to have some to spare. You won't be able to randomize more objects than you initially created, so this limits the value of the queue's size:

class obj_queue_class;
  rand obj x[$];
  local const max_size;

  constraint legal_size {
    x.size() &lt;= max_size;
  }

  function void pre_randomize();
    x = new[max_size];
    foreach (x[i])
      x[i] = new();
  endfunction

  function void print();
    $display($sformatf(""Size: %0d"", x.size()));
    foreach(x[i])
      $display($sformatf(""x[%0d] = %0d"", i, x[i].value));
  endfunction

endclass


I've made max_size a local constant value, but it can be something that you can set from outside, a package parameter, etc.

In pre_randomize() you instantiate max_size objects. Since x.size() is always smaller or equal to max_size, whatever value gets randomized will lead to a queue that contains object instances and no null. The rest of the objects will get thrown away when the queue shrinks.",,,,,
PCIe DMA Driver for Linux,"I am currently working on a Virtex 7 FPGA . I am trying to install the driver for the PCIe DMA driver for linux . But it is giving me the following error :

error: implicit declaration of function â€˜pci_enable_msixâ€?[-Werror=implicit-function-declaration]

Can someone help me with this error ?","Linux cross reference is a very good resource for this kind of problem, because you can explore the change in API over kernel version.",,,,,
Reading binary file in vhdl,"I want to get access to binary file content pixel of image from ENVI logiciel :size (100*100) pixel coded each pixel in 16 bits in vhdl. 

 library IEEE;
    USE ieee.std_logic_1164.ALL;
    Use ieee.numeric_bit.ALL;

    library std;
    use std.textio.all;

    entity image_bin is
    end entity;

    architecture behavioral of image_bin is
    type image is array(0 to 99,0 to 99) of std_logic_vector(15 downto 0);
    signal image(i,j):bit_vector(15 downto 0);

    begin
      process
      type t_file is file of bit_vector;
      file infile: text is in ""C:\Users\hp\Desktop\file\T4.bin"";
      variable pixel_image:bit_vector(15 downto 0);
         begin
         IF start'EVENT AND start = '1' THEN
         for i in to 99 loop
         for j in to 99 loop
         read(infile,pixel_image);
         image(i,j)&lt;=pixel_image;
         end loop;
         end loop;
         file_close (infile);
         end if;
         end process;
","Way before you start coding VHDL for an FPGA, especially complex algorithms, you should do two things:


Learn basic VHDL
Understand the capabilities of FPGAs


You can use file-I/O in VHDL to initialize FPGA memories (RAM/ROM) or in simulation constructs. But not in real-time data processing applications. As I say in the comments: A normal FPGA does not have file-I/O capabilities in a hardwired block. If you want something like this, it is probably best to use a microcontroller/CPU or us a SOC FPGA, which has a hard-wired ARM core on board and perform this in software. But when you're there, why use a an FPGA at all?



Mistakes in your code

There are several programming mistakes in your code, which could have easily been prevented if you'd followed some tutorial. 

With the first mistake, I am questioning if you have any programing experience. You define a type, and next you probably want define an object of that new type. But instead you type some illegal code:

signal image(i,j) : bit_vector(15 downto 0);


How would the parser know what i and j is? You don't define them until the declaration part of the code. Secondly, why are you suddenly using bit_vector, while you were using std_logic_vector just before?

Example of how it should be:

type [type name] is [type details];
signal [object name] : [type name] := [optional initialization details];


Next mistake: the process has no sensitivity list. A process statement is the start of a sequential processing block. Without any sensitivity list, it automatically starts. That's a problem: nothing blocks this, thus the process will try to loop infinitely within an infinitesimal time. This will of course cause problems. Solution: use the sensitivity list.

[label:] process ([trigger signal names])
begin
end process;


Internally the process actually has a trigger condition: start'event and start='1'... Where's this start coming from? Probably missing an input port on the entity? But this start should be the trigger for your process.



How then?

What you can do, is read a file and initialize an array. (Please note that multi-dimensional arrays are not supported in synthesis, as there is no such thing as multi-dimensional RAM, so you will have to flatten your array and perform some index arithmetic). For the next example, I created a file ""test.bin"" and filled it with the string ""12345678"" = 8 characters = 8*8 bit = 256 bit = 2*2*16 bit -> good for a 2 by 2 array.

Then you should realize that the textio package can only read text! So the easiest is to read every 8 bits as a character and then concatenate two to form a 16-bit value.

Example code:

entity read_bin is end entity;

library ieee;

architecture behavioral of read_bin is
    use ieee.std_logic_1164.all;
    subtype data_type is std_logic_vector(15 downto 0);
    type two_dim_array_type is array(0 to 1, 0 to 1) of data_type;

    impure function init_two_dim_array return two_dim_array_type is
        use std.textio.all;
        type character_file is file of character;
        file file_pointer : character_file;
        variable upper : character;
        variable lower : character;
        variable output : two_dim_array_type;
        use ieee.numeric_std.all;
    begin
        file_open(file_pointer, ""test.bin"", READ_MODE);
        for i in 0 to 1 loop
            for j in 0 to 1 loop
                read(file_pointer, upper); -- first 8 bits
                read(file_pointer, lower); -- second 8 bits
                output(i, j) := 
                    std_logic_vector(to_unsigned(character'pos(upper),8))&amp;
                    std_logic_vector(to_unsigned(character'pos(lower),8));
            end loop;
        end loop;
        file_close(file_pointer);
        return output;
    end function;

    signal two_dim_array : two_dim_array_type := init_two_dim_array;
begin
end architecture;


Voila:





The big question

The big question for me is: how come you get a PhD position in telecommunication and embedded system when you make these programming mistakes? Or lacking knowledge om the capabilities of FPGAs. I'm a PhD candidate Electrical Engineering myself and this is stuff we teach our first-year bachelors students. When I wanted my PhD position, I went through a few rounds of assessments, where my knowledge was extensively tested. There's a lot of competition going on for these positions.

My advice: Please get some local support for realizing this. You don't want to spend the next 3 years of your PhD trying to learn VHDL to an adequate level and then finding out you only have 1 year to do some actual research to be able to publish results...",,,,,
How to add a LUT in VHDL to generate a sine,"I've made an I2S transmitter to generate a ""sound"" out of my FPGA. The next step I would like to do, is create a sine. I've made 16 samples in a LUT. My question is how to implement something like this in VHDL. And also how you load the samples in sequence. Who has tried this already, and could share his knowledge?

I've made a Lookup table with 16 samples:

0               0Ï€
0,382683432     1/16Ï€
0,707106781     1/8Ï€
0,923879533     3/16Ï€
1               1/4Ï€
0,923879533     5/16Ï€
0,707106781     3/8Ï€
0,382683432     7/16Ï€
3,23114E-15     1Ï€
-0,382683432    1 1/16Ï€
-0,707106781    1 1/8Ï€
-0,923879533    1 3/16Ï€
-1              1 1/4Ï€
-0,923879533    1 5/16Ï€
-0,707106781    1 3/8Ï€
-0,382683432    1 7/16Ï€
-6,46228E-15    2Ï€
","The simplest solution is to make a ROM which is just a big case statement.

FPGA synthesis tools will map this on ore more LUT's.

Note that for bigger tables only 1/4 of the wave is stored, the other values are derived. 




  I would like to send out a 24 bit samples, do you also know how to do that with this data (binary!)?


24 bits (signed) mean you have to convert your floating point values to integer values in the range -8388608..8388607. (For symmetry reason you would use -8388608..8388607) 

Thus multiply the sine values (which you know are in the range -1..1) with 8388607.

The frequency of the sine depends on how fast (many samples per second) you send.",,,,,
Merging events doesn't trigger both events,"I'm trying to run some code from chipverify website in Modelsim and my output is different than on website. Example from website is about event merging.

module tb;
 // Create event variables
  event event_a, event_b;

  initial begin
    fork
      // Thread1: waits for event_a to be triggered
      begin
        wait(event_a.triggered);
        $display (""[%0t] Thread1: Wait for event_a is over"", $time);
      end
      // Thread2: waits for event_b to be triggered    
      begin
        wait(event_b.triggered);
        $display (""[%0t] Thread2: Wait for event_b is over"", $time);
      end

      // Thread3: triggers event_a at 20ns
      #20 -&gt;event_a;

      // Thread4: triggers event_b at 30ns
      #30 -&gt;event_b;

      // Thread5: Assigns event_b to event_a at 10ns
      begin
        #10 event_b = event_a;
      end
    join
  end
endmodule


I expected output like this on website:

[20] Thread1: Wait for event_a is over
[20] Thread2: Wait for event_b is over


But instead i get something like this:

[20] Thread1: Wait for event_a is over


The same result is when I try to run this code on edaplayground (aldec riviera pro or icarus verilog simulator). Why event_b is not triggered when event_a and event_b are merged?","The LRM is has a little ambiguity here. If you tried one more tool on EDAPlayground, you get different results.

It's not clear that writing to the event handle should cause a re-evaluation of the triggered method.

See this link for a description of the problem.",,,,,
How to write to console a custom array type,"I am fairly new to VHDL and I am running some snippets from a code I was given to see what it is doing. There is a custom array type I want to see in the console, but I get and error when I try to write it.

entity hello_world is 
end entity hello_world;

library STD;                          
library IEEE;                        
use IEEE.std_logic_1164.all;           
use STD.textio.all;                  
use IEEE.std_logic_textio.all;         
use IEEE.numeric_std.all;                                    

architecture test of hello_world is 

    type row_type is array(0 to 2)  of std_logic_vector(3 downto 0);
    type new_type is array(0 to 1)  of row_type;
    signal  max_new : new_type := (others =&gt; (others =&gt; (others =&gt; '0')));

    begin
    my_print :  process is                  
        variable my_line : line;    
        begin
            write(my_line, string'(""Value of max_new""));      
            write(my_line, max_new);    
            writeline(output, my_line);            
            wait;
    end process my_print;
end architecture test;


The error I get while running the simulation is:

 Error: type error near 'max_new': expected type 'std_ulogic'. Error: formal 'l' of mode inout must have an associated actual. Error: formal 'value' has no actual or default value. Error: indexed name prefix type 'void' is not an array type


If I understood correctly, row type is an array of size 3, in each position I have a vector made of 4 bits. new_type is an array of size 2, in each position I have a row_type, which is an array of size 3 with a 4 bits vector in each position. Is this correct? Since it is initialized to 0, I expect to see only that.

I am using Vivado 2018.3 for the simulation.

Any help would be highly appreciated!","The function write of std.textio can take the following arguments as value (https://www.hdlworks.com/hdl_corner/vhdl_ref/VHDLContents/TEXTIOPackage.htm) : 


bit
bit_vector
boolean
character
integer
real
string
time


IEEE.std_logic_textio add std_logic and his derivated to this list but Array is not handled by write.

You can print your array like that :

my_print :  process is                  
  variable my_line : line;    
begin
  write(my_line, string'(""Value of max_new""));
  for I in 0 to 1 loop
    for J in 0 to 2 loop 
      write(my_line, max_new(I)(J));
    end loop;
  end loop;    
  writeline(output, my_line);            
  wait;
end process my_print;
",,,,,
Indexing array of instances and interfaces,"I have an array of interfaces. I know that array of instances and interfaces are not like ordinary arrays that can be indexed with a variable, here we have to index with a constant(or using generate block)and that is exactly the problem.

I am using a generate block to store the destination slave id to which a master is sending the packets according to the address provided.Here m_ahb is the array of master interfaces. I also got the destination slave id stored, ie, for master 0 the destination id is in dest_slave[0], for master 1 it is in dest_slave[1] and so on..

Till here all is well.

Then, say for master 0, I am using the dest_slave[0] value to index the the array of slave interfaces (s_ahb) and pick out that corresponding destination slave interface to probe a signal and use it in an assertion. But now I am getting the error 'non constant array index into instance array'.

Any help/advice about this would be greatly appreciated. Thank you.

int dest_slave[NUM_MASTERS];
generate
  for (genvar i = 0; i &lt; NUM_MASTERS; i++) begin
    always_ff @(posedge clk, negedge resetn) begin
      if (m_ahb[i].haddr &gt;= 'h0000_0000 &amp;&amp; m_ahb[i].haddr &lt;= 'h0000_ffff) dest_slave[i] = 0;
      if (m_ahb[i].haddr &gt;= 'h1000_0000 &amp;&amp; m_ahb[i].haddr &lt;= 'h1000_ffff) dest_slave[i] = 1;
      if (m_ahb[i].haddr &gt;= 'h4000_0000 &amp;&amp; m_ahb[i].haddr &lt;= 'h4000_ffff) dest_slave[i] = 2;
    end
  end
endgenerate
generate
  for (genvar i = 0; i &lt; NUM_MASTERS; i++) begin
    assert property my_proprty(m_ahb[i].hburst,s_ahb[dest_slave[i]]].hburst); //this line creates error it is not liking s_ahb[dest_slave[i]]
  end
endgenerate

","My guess is s_ahb is a module instance or non-virtual interface instance. These types of arrayed paths cannot be dynamically accessed. You can create in logic to separate probing and mapping.

int dest_slave[NUM_MASTERS];
int slave_hburst_val[NUM_MASTERS]; // &lt;- change data type as needed
generate
  for (genvar i = 0; i &lt; NUM_MASTERS; i++) begin
    always_ff @(posedge clk, negedge resetn) begin
      if (m_ahb[i].haddr &gt;= 'h0000_0000 &amp;&amp; m_ahb[i].haddr &lt;= 'h0000_ffff) dest_slave[i] = 0;
      if (m_ahb[i].haddr &gt;= 'h1000_0000 &amp;&amp; m_ahb[i].haddr &lt;= 'h1000_ffff) dest_slave[i] = 1;
      if (m_ahb[i].haddr &gt;= 'h4000_0000 &amp;&amp; m_ahb[i].haddr &lt;= 'h4000_ffff) dest_slave[i] = 2;
    end

    assign slave_hburst_val[i] = s_ahb[i].hburst; // intermediate assignment

    assert property my_proprty( m_ahb[i].hburst, slave_hburst_val[ dest_slave[i] ] );
  end
endgenerate


FYI: your original code you has an extra ]. s_ahb[dest_slave[i]]].hburst",,,,,
"What exactly is ""Current Simulation Time"" and Event Queue in Verilog?","Consider the below example:

module test;
 reg a;
 initial begin
  a = 1'b0;
  a &lt;= 1'b1;
  $display(a);
 end
endmodule


The above example displays 0. My reason is because the non-blocking assignment will be assigned at step 3 of the ""Stratified Event Queue"" while the blocking assignment and $display are done at step 1. If I modify the example as:

module test;
 reg a;
 initial begin
  a = 1'b0;
  a &lt;= 1'b1;
  $display(a);
  $monitor(a);
 end
endmodule


Then 0 and 1 are printed because, I assume $monitor is executed at step 4 of the Event Queue(?). But if I modify the example further:

module test;
 reg a;
 initial begin
  a = 1'b0;
  a &lt;= 1'b1;
  $monitor(a);
  $display(a);
 end
endmodule


Again the output is: 0 and 1 -- which I did not expect. I expected 1 and 1 to be printed because $monitor will be evaluated at step 4 of the Event Queue, by which time, ""a"" is already 1. After that we have $display, which should print 1.

References I could find talk about ""current simulation time"" and the ""stratified event queue"" but I'm not sure how it works. 

I appreciate your explanation!
Thanks","Verilog simulation is event driven. Event is a change of the value of a verilog variable (or a named event). Simulation is done in steps. 

A step starts with input events put on an event queue. Every new change in values because of the evaluation creates new events which are added to the queue. Simulation ends when the queue is empty (there are no more active events). Every such a step advances simulation time. 

The step itself is divided in multiple zones which are executed using algorithm defined in the standard. 

For verilog 2K, there are roughly 3 main zones:


blocking assignment zone. Verilog executes all the procedural blocks scheduled by the event queue and reacts to new blocking assignment events. It just schedules nbas events to be executed later. When all blocking events are done, it gets to the next zone. 
non-blocking assignment zone. Here it executes all blocks which react to the schedules nba events. It will put both ba, and nba event on the queue. When all nba is done, it might get back to the zone '1' if there are ba event and do all over.  
monitor/strobe zone -- this is the zone when $monitor (and $strob) work. It gets execute after both ba and nba zones are done (no more events).


In your case a = 1 is executed in the blocking assignment zone. this value is persistent till the end of this zone. $display will also be executed in this zone. So, it will see the value of the 'a == 0`.

a &lt;= 1 will be schedule for execution in the non-blocking zone, after $dislpay is done. 
$monitor will pick events in the monitor zone, after the non-blocking is done. So, it will show you the value of 1.

Your statements are executed in the initial block. As a result, there is no event propagation. Events only are picked by always and assign statements. If you put your $display in an always block, you will see more interesting results.   always @* $display(a);

You should read about standard simulation semantics in verilog to get more information. ",,,,,
Problem with wait_order in Modelsim - unexpected keyword,"I'm trying to run some code from chipverify website in Modelsim and it doesn't work - and I have no idea why. Example from website is about wait_order.

module tb;
  // Declare three events that can be triggered separately
  event a, b, c;

  // This block triggers each event one by one
  initial begin
    #10 -&gt; a;
    #10 -&gt; b;
    #10 -&gt; c;
  end

  // This block waits until each event is triggered in the given order
  initial begin

    wait_order (a,b,c) 
      $display (""Events were executed in the correct order"");
    else 
        $display (""Events were NOT executed in the correct order !"");  
  end
endmodule


I expect output:

Events were executed in the correct order.


But insted i get something like this:

syntax error, unexpected ""SystemVerilog keyword 'wait_order'""
","This is an unimplemented feature of SystemVerilog in Modelsim. Check the documentation.

SystemVerilog sequences with assertions give you much of the same functionality. ",,,,,
Verilog: How to have a signal which have specific delay after clock positive edge?,"I have a test bench module such as below:

`timescale 1ns / 1ps
module RandomDelay_tb;
    reg t_clk=1;
    reg t_rst_n=1;
    reg t_input_signal = 1;
    wire t_out_signal;
    MyModle r1(t_clk,t_rst_n,2'b11,t_input_signal,t_out_signal);
    initial
    begin
            t_rst_n = 0;
            #930 t_rst_n = 1;
    end

    always
        #100 t_clk = ~t_clk;
    always
        #50  t_input_signal = ~ t_input_signal;

endmodule


In this module frequency of t_input_signal is twice of t_clk. I want to modify it such that it have a toggle period same as t_clk, i.e.  100ns but it a have a delay after edge of my clock signal like 10ns.

In other words I want t_input_signal be t_clk but shifted for 10ns.

How can I implement such a thing?","There are several ways but looking at your code the least amount of typing would be:

always @(t_clk )
   t_input_signal &lt;= #10 t_clk;
",,,,,
What is the difference between a wait statement and using a while loop in SystemVerilog?,"I was wondering what is the difference between waiting for a flag to be set using a wait statement or a tradition loop until the flag is set.

wait (flag === 1); //Implementation 1

while ( flag != 1); //Implementation 2
","The wait statement blocks the current process until the expression becomes true.

The while loop you wrote becomes an infinite zero-delay loop if the expression is true (flag is false). This will hang simulation. ",,,,,
When do we need wand/wor in Verilog?,"The Verilog standard clearly states that there is no functional difference between a wire and a tri. The differentiation is that of convention. A wire net is used for nets driven by a single gate or continuous assignment while the tri net can be used where multiple drivers drive a net [$4.6.1]. Given this fact, I have these questions:


What exactly do we need tri for? By convention, it should be used when multiple drivers are driving a net. But then, if multiple drivers are driving a net, we should be using triand/trior for resolution, right? Or could there be a case where multiple drivers are driving a net and we don't want to use any of triand/trior for resolution but use tri instead?
What is the use for wand and wor? If multiple drivers are involved, by convention, we should use triand and trior. So why do they exist? And when do we need them?


Thanks,","The wire and tri keywords were designed to document the user's intent that a signal could have the tristate Z value at some point in time. However Verilog never implemented any kind of check to enforce this usage. So now they are simply keyword synonyms (same as reg and logic being synonyms with no functional difference).

Wired-or or Wired-and logic get created by certain transistor technologies. (See open-collector circuits)",,,,,
How to make a signal stable for quite some time in the assertion,"Suppose I have an assertion as follows. Now here I want signal A to remain stable for some time after rising up. That is, A should be high until the first occurrence of D == 4 after that it can go low at any time it wants.
Also I dont want to use ##[0:$] in this assertion.

Any help/advice would be very much appreciated. Thank you.

property p_check(A,B,C,D,E);
     @(posedge clk) disable iff(!resetn)
      $rose(A) ##1 B ##0 (C == 3) ##0 (D != 2) |=&gt; (D == 4)[-&gt;1] ##[0:2] (!E throughout A);
   endproperty : p_check


","You should write this as a separate property. 

 @(posedge clk) disable iff(!resetn)
    $rose(A) |=&gt; $stable(A) until (D==4); 
",,,,,
i have some problem about current time in vhdl,"I am the first student to start vhdl recently. It is currently working on the FPGA board.
I wish my seven-segment would have the current time whenever I pressed the RESET button. Is there a way to solve it?

I searched stackoverflow all day. but i can not find solution..

  -- Time information
  constant HOUR_INT   : integer                       := 00;  --  I think we should put the current time in here.
  constant HOUR_HEX   : std_logic_vector(7 downto 0)  := X""00"";
  constant MINUTE_INT : integer                       := 00;
  constant MINUTE_HEX : std_logic_vector(7 downto 0)  := X""00"";


if reset = '0' then
      hour &lt;= conv_std_logic_vector(datetime.hour_int, 5)


in this code proportion, why i have to input 5 next to hout_int?","I think it isn't possible to get the current time of the system (considering the attempts / questions of other people on this forum). So it's also impossible to use reset for get the current time. 

Maybe it's usefull to take a look here

someone who has already tried it in a different way with an RTC (with success):
- here non-manually set clock
- here manually set clock",,,,,
Does a Verilog event control block execution of a procedure?,"Does a Verilog event control block execution of a procedure till the event happens? Consider the example below.

module test;
  reg a;
  initial begin
    @(a) $display(""%b"", a);
    $display(""the_message"");
  end
endmodule


If I run the above, the simulation ends without the_message printed. Why? 

Does this mean that @(a) blocks till a changes? If so, why doesn't the simulation hang forever instead of terminating without printing the_message?

Thanks","Event driven simulators run until there are no more active events scheduled, or explicitly terminated ($finish).",,,,,
posedge or negedge in the body of the loop,"I have following verilog code. I can't find answer what is the effect of using posedge in the middle of the loop or after a &lt;= x;b&lt;=ri . I think that always begin gets executed always and after that the function will be blocked on posedge clk(after the  integer d line). When the clock will rise the next line will be executed.(namely r &lt;= 0). 

If this is true then the next posedge clk (after &lt;= x ; b &lt;= ri and c = ri) will be executed on the same clock edge or the require another clock edge and what is the reason of using posedge in the middle of code instead of in beginning?   

always
begin :two
   real c;
   integer d;
   @(posedge clk)
      r &lt;= 0;
   if (k) 
   begin
      a &lt;= x; b &lt;= ri;
      @(posedge clk);
      begin :loop
      forever
      begin
         c = ri;
         @(posedge clk);
         d = $rtoi(c*4);
         if (abs(b-c) &gt; abs(a-b)) disable loop;
         r &lt;= $rtoi(j*4);
      end
   end 
   d = 3*d; k &lt;= 1â€™b0; r &lt;= d + 1;
end
","
then the next posedge clk (after &lt;= x ; b &lt;= ri and c = ri) will be executed on the same clock edge

No, every @(posedge clk); will block execution until the rising edge is seen and it will continue after that.

what is the reason of using posedge in the middle of code instead of in beginning?

I don't know why the code was written that way, for that I would have to know (or guess) which problem the author was trying to solve.
As mentioned above: a@(posedge clk); will block execution until the rising edge is seen. So you should read the code as a particular sequence of events:

wait for a rising clock edge then set r to zero.

if k set a, b and again wait for a rising clock edge.

set c (For some reason this is a blocking assignment) and again wait for a rising clock edge.
etc.

",,,,,
How to make a linux driver detect and use a device after linux kernel has already loaded?,"I am using a System Monitor device at address 0x3f on i2c-0 bus. This device is configured with the pmbus driver in the device tree. 

The problem is that, this 'Sysmon' device is not powered when the linux kernel is loaded. Therefore, when I do a i2cdetect on bus 0 we see '--' at 0x3f which is expected. Now, when I power the Sysmon using my UI, the device is added by linux and we see a '3f' on running the i2cdetect.  

Now, I want the pmbus driver to detect this device and change it to 'UU' so that I can see all the pmbus attributes in sysfs. 

Can I do it from userspace and how? If no, can you suggest how can I tackle this. 

If I force power the device using hardware and then load linux, the pmbus driver detects this device and reserves it. But I'm not allowed to force power the device.

Device Tree: 

   i2c@ff020000 

   {

        compatible = ""cdns,i2c-r1p14"", ""cdns,i2c-r1p10"";
        status = ""okay"";
        interrupt-parent = &lt;0x4&gt;;
        interrupts = &lt;0x0 0x11 0x4&gt;;
        reg = &lt;0x0 0xff020000 0x0 0x1000&gt;;
        #address-cells = &lt;0x1&gt;;
        #size-cells = &lt;0x0&gt;;
        power-domains = &lt;0x15&gt;;
        clocks = &lt;0x3 0x3d&gt;;
        clock-frequency = &lt;0x186a0&gt;;
        pinctrl-names = ""default"", ""gpio"";
        pinctrl-0 = &lt;0x16&gt;;
        pinctrl-1 = &lt;0x17&gt;;
        scl-gpios = &lt;0x18 0x4a 0x0&gt;;
        sda-gpios = &lt;0x18 0x4b 0x0&gt;;

        fpga1sysmon0@3f {
            compatible = ""general,pmbus"";
            reg = &lt;0x3f&gt;;
        };


PS: I'm a beginner and this is my 1st question on Stack Overflow. Please bear with me for any mistakes I've made.","what about enabling the sysmon in /etc/init.d/rcS (assuming you are using busybox init) or in systemd /etc/rc.local.

the following will load the driver for an LTC2978 at address 0x60
on I2C bus #1:

$ modprobe pmbus
$ echo ltc2978 0x60 &gt; /sys/bus/i2c/devices/i2c-1/new_device


you can put that in 

/etc/init.d/rcS or /etc/rc.local

see also
https://www.kernel.org/doc/Documentation/hwmon/pmbus",,,,,
Is there a way to fix the warning related to the support of string-based lookup for the factory?,"I often get this warning message:

UVM_WARNING @ 0: reporter [TPRGED] Type name 'packet2mem_comp_Str' already registered with factory. No string-based lookup support for multiple types with the same type name.


I did not register any class with the same name, unless the parent one which, I suppose, does not present any problem.

My class is an inherited parametrized class declared as follows:

class packet2mem_comp #(string S = ""MEM"") extends mem_comp;
  typedef packet2mem_comp #(S) packet2mem_comp_Str;
  `uvm_object_utils(packet2mem_comp_Str)

  function new (string name = ""packet2mem_comp"");
    super.new(name);
  endfunction : new


... //rest of my code


endclass: packet2mem_comp


Does anyone know how to fix this warning?","There are special versions of the macros for parameterised classes. Instead of 

`uvm_object_utils(packet2mem_comp_Str)


try

`uvm_object_param_utils(packet2mem_comp_Str)


or perhaps

`uvm_object_param_utils(packet2mem_comp #(S))


You have not posted an MCVE, so I have not tested this.",,,,,
How to use System-Verilog Assertions on modules within top level DUT,"I'm trying to write a memory scheduling testbench and to verify that I am accessing the correct addresses and writing the correct values at the right time I want to compare what is going on with the signals inside my top module with my schedule that I developed.

I've tried looking up ""dot notation"" and using my simulator (ModelSim) to access the signal (which I can do on the waveform fine) but I want to be able to use SVAs to check I have the correct values.

module top(input d, output q)

    //wires
    wire sub1_output

    // Instantiate submodule
    sub_module1 sub1(.sub1_output(sub1_output));

    always begin
        // logic
    end
endmodule


module tb_top();

    reg d;
    wire q;

    DUT top(.*);

    initial begin
        // This is where I want to access something within my DUT
        assert(DUT.sub1_output == 1'b1)
    end
endmodule


When I try this my code compiles and runs, but if I write the assertion such that it should fail and stop my code, nothing happens.","DUT.sub1_output

Is the correct format to use assertions on signals within top level instantiations.",,,,,
how to randomize the elements of a array in vhdl code?,"I have a table with a known number of elements. I would like to randomize its elements so that each time I display it, its elements are displayed in random order. in vhdl using Fpga stratix3","There is no easy VHDL langage solution to generate random numbers on hardware.
To generate a pseudo random number, you can use a LFSR. See for example:
Pseudo Random Number Generator using LFSR in VHDL

To generate a true random number, you must create a ring oscillator random number generator.
See for example:
https://security.stackexchange.com/questions/81843/ring-oscillator-true-random-number-generator-trng-vs-physically-unclonable-fu

For simulation there is built-in support for random numbers in VHDL. See for example:
Generating random integer in vhdl

You can then use the generated random numbers to randomize your array.",,,,,
Type erasure in SystemVerilog / DPI,"Is it possible to cast SystemVerilog struct to some type-erased pointer, like void *?

I need to pass objects of different struct types from SV to C. And I want to have a single DPI function to handle any kind of supported struct.

On SystemVerilog side I have many types:

typedef struct { ... } stype1;
typedef struct { ... } stype2;
typedef struct { ... } stype3;
typedef struct { ... } stype4;

stype1 var1;
stype2 var2;
stype3 var3;
stype4 var4;


On C side I have a single function that accepts any type:

void send_sv_data(const char* type_name, void *ptr);


I've hoped to use it like this on SV side:

send_sv_data(""stype1"", var1);
send_sv_data(""stype2"", var2);


And it works in general, with only problem that SystemVerilog does not supports overloading. So I can only declare it for one type:

import ""DPI"" function void  send_sv_data(string port_name, stype1 data);


I've tried to have chandle as argument:

 import ""DPI"" function void  send_sv_data(string port_name, chandle data);


But I have not found a way how I cast a variable of struct type to chandle.","There are no pointers, and no casting of pointers in SystemVerilog. The easiest thing to do is pack your SystemVerilog structs into an array of bytes, and unpack them to your C structs.",,,,,
Do I need to avoid OOMR (Out of Module reference) code in UVM?,"I'm setting up a new UVM code, and want to make OOMR code in my uvm code, Do I need to avoid OOMR (Out Of Module Reference) code concept in UVM?
If don't need it, What should I have to check before OOMR code and after?

Example

tb.top.env.dut.a = 1;
a = tb.top.env.dut.b    


If you see the link there some error message after run.

    a=u_sub.b; 
            |
ncvlog: *E,ILLHIN (add.sv,6|12): illegal location for a hierarchical name (in a package).


To prevent this problem, I think I have to avoid like this code style. But I'm not sure what am I understanding this problem well.

Not sure but as I know some EDA tools support that issue. For example, cadence($xm_mirror), Mentor, VCS... 

So I want to know Do I need to avoid these OOMR code style? or Should I have to use just EDA tool's helps. 
How to resolve this problem when I got similar error in huge complex uvm codes?","It is illegal to use Verilog Hierarchical References or OOMRs in a SystemVerilog package. This is because SystemVerilog packages are compiled first, in a different way to the rest of the SystemVerilog code.

Generally, you will be putting your classes in a package. Therefore, you would avoid using Verilog Hierarchical References or OOMRs in classes. 

Obviously, you will want to connect the code in a class to the DUT ports (eg the drivers and monitors) and you may want to probe DUT internal signals, too. The solution to these is different for each case.

For connecting to DUT ports, most people would use a SystemVerilog interface . You instantiate the interface at the same level of hierarchy as the DUT and connect the interface members to the DUT somehow eg using Verilog Hierarchical References or OOMRs), eg:

interface TB_hook (input bit clk);
  logic Stim, Resp;
  ...
endinterface

module harness;
  bit clk;
  TB_hook DUT_intf (.clk);
  Sys_Top DUT (
    .clk  (clk), 
    .Stim (DUT_intf.Stim),
    .Resp (DUT_intf.Resp), 
    ...


Then in some class (a driver, monitor or agent) you can use a SystemVerilog virtual interface to connect to the interface instance. A virtual interface is a special kind of SystemVerilog variable that can store a Verilog Hierarchical Reference or OOMR to an interface instance or a modport. Because you have to assign that value at runtime, a virtual interface can be compiled in a package (but the code that assigns the value cannot be in a package), eg:

class driver;
  virtual TB_hook V;
  task drive (input bit data);
    V.Stim &lt;= data;


Then, in some Verilog module (probably the top-level module), you would assign a value to the virtual interface variable. You could do this directly, eg:

module TB_top;
  top_env env;
  ...
  initial begin
    ...
    env.agent.driver.V = harness.DUT_intf;


but most people would use the UVM config database:

module TB_top;
  top_env env;
  ...
  initial begin
    ...
    uvm_config_db #(virtual TB_hook)::set(null, ""*"", ""DUT_intf"", harness.DUT_intf);

class driver;
  virtual TB_hook V;
  ...
  function void connect_phase(uvm_phase phase);
    ...
    ok = uvm_config_db#(virtual TB_hook)::get(this, """", ""DUT_intf"", V);


You can enhance this technique using modports and/or clocking blocks.

For probing internal DUT signals, there are facilities provided by the UVM Register Layer. There are a set of functions/tasks for this:


uvm_hdl_check_path â€?checks if HDL path exists
uvm_hdl_deposit â€?deposits a value into the RTL
uvm_hdl_force â€?forces a value into the RTL
uvm_hdl_force_time â€?forces a value for a specified duration
uvm_hdl_release â€?releases a forced value 
uvm_hdl_release_and_read â€?releases a forced value and reads the new value
uvm_hdl_readâ€?reads an RTL value
",,,,,
register initial values at testbench,"want to send an initial value to reg div_num_tb (it's a 8 bit register)
and i get this error:


  Error (10137): Verilog HDL Procedural Assignment error at top_tb.v(23): object ""div_num_tb"" on left-hand side of assignment must have a variable data type


other single bit registers doesn't do issues

module top_tb();
  reg clock_tb, reset_tb, enable_tb; 
  reg [7:0]Div_num_tb;
  wire Out_signal_tb; 
  wire [7:0]count_tb;`

Top U0(
  .clock (clock_tb),
  .reset (reset_tb),
  .enable (enable_tb),
  .Div_num (div_num_tb),
  .Div_num (Div_num_tb),
  .Out_signal (Out_signal_tb),
  .count (count_tb)
);

initial
begin   
  clock_tb = 0;
  reset_tb = 1;
  enable_tb = 0;
  div_num_tb = 8'b00000000;
end
endmodule



  Error (10137): Verilog HDL Procedural Assignment error at top_tb.v(23): object ""div_num_tb"" on left-hand side of assignment must have a variable data type
","Div_num_tb has been defined as a reg.

reg [7:0]Div_num_tb;

but not div_num_tb, which as a result, is being inferred as a wire.  Verilog is case-sensitive.",,,,,
Verilog always block execution during startup,"I have an always block in verilog as shown below. All the input signals inside always block are not stable until startup time say 50ns. I don't want to execute the always block until start up time is reached. What is the best to achieve this functionality? Thanks.

always begin
 //functional code
 #10
end
","Use an initial block

initial #50ns forever begin /* functional code */ #10; end


or for combinational logic, use

initial #50ns forever @* begin /* functional code */ end
",,,,,
First assign and then reassign in if block as alternative to if-(else if)-else in Verilog,"Is it better to first assign a value to a variable and then reassign in if block instead of using if-(else if)-else blocks where the assignment in if and else blocks are the same and the assignment in the else if block is a different assignment.

always @(*) begin
    if condition1 begin
        var = val1;
    end
    else if condition2 begin
        var = val2;
    end
    else begin
        var = val1;
    end
end


vs

always @(*) begin
    var = val1;
    if condition2 begin
        var = val2;
    end
end


Given condition1 and condition2 are mutually exclusive, I am thinking that both of these blocks should synthesize the same logic and the choice of one over the other is purely aesthetic. Am I correct in thinking this or will one implementation synthesize differently from the other? If my thinking is correct, which method is preferred in the community?

Edit: Added mutually exclusive criteria after racraman's comment.","As for the general principle you're asking about: it doesn't matter which route you go. The synthesiser will be smart enough to work it out anyway. For simulation, it's possible that the option which carries out a default assignment first might execute more slowly (particularly if the assignment is a non-blocking one), but I wouldn't worry about it.

Personally, I prefer the second, because it's more obvious to the causual reader that you have covered your bases in terms of generating unwanted latches (in other words, you are always assigning to var).

Having said all that, your example is (in principle) very simple, and in this particular case it's obvious that a mux is required, and you probably don't need an always block at all, and should just use an assign with a ternary operator.

I say 'in principle' because you logic doesn't really make sense. You say your conditions are mutually exclusive, but what happens if neither condition is active? Do you actually need a latch to preserve the previous output? If not, why do you have two conditions at all?",,,,,
Verilog or Vivado HLS or Vivado SDSoC,"I want to convert my lane detection code written by C++ (OpenCV) to FPGA. Vivado HLS or Vivado SDSoC can help to embed the C ++ code into the FPGA. Or I can rewrite the lane detection code with verilog. The question is, what are the advantages and disadvantages of these three ways? 
I want to use one of the cheap Zynq-7000 FPGAs. ","Verilog is considered low-level these days.  Compare it with assembly for software implementation.  People use it only to get performance that they cannot attain with high-level languages such as C or Java in the software domain.

In the hardware domain, C (for Vivado HLS) or OpenCL are considered high-level languages.  OpenCL was developed with portability to other architectures like GPUs and CPUs in mind.  It has a lot more overhead in terms of communicating with the FPGA than Vivado HLS however.

Vivado HLS by itself produces just hardware modules in VHDL or Verilog, which you still have to connect to FPGA pins, ARM processors, etc.  It does not take care of the communication to your module.  You will still have to integrate your module in a Vivado block design or top-level VHDL or Verilog implementation yourself.

SDSoC, not ""Vivado SDSoC"" by the way, also lets you to write your entire implementation (hardware and software) in C.  Under the hood, it will invoke Vivado HLS to implement the hardware module.  Afterwards, the tool will take care of implementing an interface between your hardware and the on-board ARM processors that will run the software.

In summary, I recommend SDSoC unless you have a good reason not to use it.  I do want to warn, however, that analyzing the synthesis results of Vivado HLS is a lot harder than analyzing Vivado output for Verilog or VHDL.  Therefore, I always recommend to make sure that your code works as a software implementation first.  With minimal effort, you should be able to compile any code in gcc or another compiler too.  Don't use the synthesis results to debug your code, but just to analyze the performance.",,,,,
Concatenating elements of unpacked array together,"I am using the following function in my System Verilog code. I wondered if there was an idiomatic way of achieving the same effect that perhaps would not require the width to be hardwired. I tried streaming operators, but could not quite get them to work. I need to use unpacked arrays. Many thanks.

function bit [64:0] cat8 (bit [7:0] a[8]);
   return { a[7], a[6], a[5], a[4], a[3], a[2], a[1], a[0] };
endfunction;
","since you reversing the array in concat, there is no good way to express it.
you have:

bit [7:0] a[8];


which is equivalent to 

bit [7:0] a[0:7];


in your concat you start with a[7] in the most significant bits whether 7 is the least significant index in the array.

This is the reason why the streaming operators did not work in your case.

So, if you really need to reverse the array, than you have what you have, otherwise you can find that these 2 things are equivalent:

{ a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7] }


and

{ &gt;&gt; {a}}


of course you can declare your array as bit [7:0] a[7:0] and keep index ordering in concat as you have. But it will not reverse the array again, as in the above case. ",,,,,
Turning an ALU 1-bit into ALU 8-bit in Verilog,"Below is my 1-bit ALU which is proven to work. Now I would like to use this 1-bit aLU into an 8-bit alu and it needs to pass a test bench. So far I compiled an 8-bit ALU code but it doesn't seem to work. Any help?

module ALUSlice(A,B,CI,M,S,F,CO); //Code for 1-bit
input A,B,CI,M,S;
output F,CO;
wire [3:0] TF;
wire [3:0] TC;

FullAdder F1(TF[3],TC[3],A,B,CI);
assign TF[0] = A &amp; B;
assign TF[1] = A | B;
assign TF[2] = ~A;

assign TC[2:0] = 0;
Dual4to1Mux Mux1(F,CO,{M,S},TF,TC);
endmodule




module ALU8Bit(S1,S0, A, B, CarryIn, CarryOut, F);//What I have so far
input [7:0] A,B;
input S1,S0,CarryIn;
output [7:0] F;
output CarryOut;

wire [7:0] C;

ALUSlice A0(F[0],C[0],A[0],B[0],CarryIn,S0,S1);
ALUSlice A1(F[1],C[1],A[1],B[1],C[0],S0,S1);
ALUSlice A2(F[2],C[2],A[2],B[2],C[1],S0,S1);
ALUSlice A3(F[3],C[3],A[3],B[3],C[2],S0,S1);
ALUSlice A4(F[4],C[4],A[4],B[4],C[3],S0,S1);
ALUSlice A5(F[5],C[5],A[5],B[5],C[4],S0,S1);
ALUSlice A6(F[6],C[6],A[6],B[6],C[5],S0,S1);
ALUSlice A7(F[7],CarryOut,A[7],B[7],C[6],S0,S1);

endmodule
","Without a more complete picture of everything, its not easy to tell if this is your only issue. But one reason this might be failing is it seems you did not hook up your ALUSlice modules correctly in your ALUBit. The port (io) order of the ALUSlice module should be inputs followed by outputs, but you have outputs followed by inputs in your instantiations. The best way to void these kinds of bugs is to explicitly connect ports to their respective lines rather than relying on order, like so:

ALUSlice A0(.A(A[0]), .B(B[0]), .CI(CarryIn), .M(S1), .S(S0), .F(F[0]), .CO(C[0]));


This way, everything is connected exactly as you intend (ie, A[0] is connected to the A input, B[0] to B, CarryIn to CI, etc) without making mistakes with the order, or when you add new ports or take any away, everything is still hooked up as expected.",,,,,
SystemVerilog TypeDef Can;t index object with zero packed or unpacked array dimensions,"I am currently attempting to use TypeDef in SystemVerilog in order to define a new data structure object containing a 8 bit unsigned register and an 32-bit signed integer but I keep getting the error:

Error (10053): Verilog HDL error at UART.v(35): can't index object ""data"" with zero packed or unpacked array dimensions

I have recreated a simple implementation below where the topLevelModule instances a lowLevelModule which determines the values of both the integer and 8-bit unsigned register in which the structure is made up of and outputs them to the topLevelModule. 

Using a separate UART module I am attempting to send this structure/object (which is 40bits long) to  a host computer- to simplify the code below I have omitted this module and left out the majority of the non-associated code. 

typedef struct {
            reg[7:0] identifier;
            integer currentSynapticWeight;
        } dataPacket;

module topLevel(clk, reset, UART_TXD);

    input clk; // Clock Signal
    input reset; // Reset Signal
    output UART_TXD; // Output Signal

    dataPacket data; // Instance the dataPacket Object

    lowLevelModule LLM1(clk, reset, data);

    // CODE TO DRIVE THE UART CONNECTION OMMITED

endmodule

module lowLevelModule(clk, reset, data);

    input clk; // Clock Signal
    input reset; // Reset Signal
    output dataPacket data; // Instance the dataPacket Object

    reg[7:0] someUnsigned8BitUnsignedReg = 8'b10001000;
    integer someIntegerValue = 25;

    always @(*)
        begin
            data[39:32] = someUnsigned8BitUnsignedReg;
            data[31:0]  = someIntegerValue;
        end

endmodule


Any help would be greatly appreciated, I am not sure if I have used TypeDef in the correct manor. ","You declared data as an unpacked structure - you cannot access it as an integral packed array. Either change your assignments to unpacked members of the struct:

data.identifier = someUnsigned8BitUnsignedReg;
data.currentSynapticWeight  = someIntegerValue;


Or change your typedef to define a packed struct 

typedef struct packed {
            reg[7:0] identifier;
            integer currentSynapticWeight;
        } dataPacket;
",,,,,
"in vim, how to keep search pattern (second to last search pattern, not last search) in a buffer and use it in a new search?","suppose I have 3 idential files xfile1.txt, yfile2.txt and zfile3.txt with following contents.  

mane
hind-leg
shell


and I also have a file test.txt like below.  

xfile1.txt
{
lion mane
}

yfile2.txt
{
rabbit hind-leg   // line 8
}

zfile3.txt
{
turtle shell
}


I want to make a macro by defining q, my-macro-key, my-wanted-key-sequences, q and using it with @, my-macro-key for the following operation.  What I want to do is, when my cursor is placed for example, in the middle of hind-leg in line 8 of test.txt file, when I press a macro key like @, z, to make it open yfile2.txt and place my cursor at the beginning of hind-leg in the new open file.
So for recording the macro, I placed my cursor at the middle of hind-leg in file test.txt and pressed q,z,b,*,ctrl-o,?,^,{,enter,k,g,f,* (start macro recording for charter z, goto beginning of the word, search forward, come back, reverse search for ^{, go up a line, enter the file(yfile2.txt), search for the pattern again. for those who don't know what the previous sequence is..). but the last '* searches for '^{' because that is the last search patter that I used until that point. I want to use the search pattern hind-leg in the new opened file.
How can I use the old search pattern hind-leg in this case?","Recalling previous searches

You can recall previous search patterns in the command-line by pressing &uarr;.

Alternatively, if you want a list of previous search patterns to select from, you can enter the command-line window via q/. This is a full Vim buffer, so you can navigate with j / k, even search with /, and edit previous patterns in the usual way. Press &lt;Enter&gt; to select the current line's pattern.

Storing search patterns elsewhere

You can paste the current search pattern in a (scratch) buffer via ""/p ("": select register, /: search pattern register, paste). Unfortunately, you cannot simply yank back to the search register, but this will do:

:let @/ = getline('.')


Alternatively, you can also use other registers to store the pattern. For example:

:let @a = @/
"" Recall later
:let @/ = @a


And there's the histget('/') function to access previous search patterns.",,,,,
"Priority 8-to-3 encoder in Verilog (case, casex)","I'm trying to describe a SN54LS348 element (8-line to 3-line priority encoder).
The truth table is:

          INPUTS            OUTPUTS   
E | 0 1 2 3 4 5 6 7 ** A2 A1 A0 | GS EO
///////////////////////////////////////
H | X X X X X X X X ** Z  Z  Z  | H  H
L | H H H H H H H H ** Z  Z  Z  | H  L
L | X X X X X X X L ** L  L  L  | L  H
L | X X X X X X L H ** L  L  H  | L  H
L | X X X X X L H H ** L  H  L  | L  H
L | X X X X L H H H ** L  H  H  | L  H
L | X X X L H H H H ** H  L  L  | L  H
L | X X L H H H H H ** H  L  H  | L  H
L | X L H H H H H H ** H  H  L  | L  H
L | L H H H H H H H ** H  H  H  | L  H


Here's my implementation: 

module L348 (E, D0, D1, D2, D3, D4, D5, D6, D7, A0, A1, A2, GS, EO);

input E, D0, D1, D2, D3, D4, D5, D6, D7;
output A0, A1, A2, GS, EO;

assign D = {D0, D1, D2, D3, D4, D5, D6, D7};

parameter HIGH_IMPEDANCE = 3'bz;

reg [7:0] MASK_1 = 8'b0000_0001;
reg [7:0] MASK_2 = 8'b0000_0011;
reg [7:0] MASK_3 = 8'b0000_0111;
reg [7:0] MASK_4 = 8'b0000_1111;
reg [7:0] MASK_5 = 8'b0001_1111;
reg [7:0] MASK_6 = 8'b0011_1111;
reg [7:0] MASK_7 = 8'b0111_1111;
reg [7:0] MASK_8 = 8'b1111_1111;

reg [2:0] A;
reg [1:0] GS_EO;
reg [7:0] temp;

reg [7:0] mem [7:0];

initial
begin
mem[0] = MASK_1;
mem[1] = MASK_2;
mem[2] = MASK_3;
mem[3] = MASK_4;
mem[4] = MASK_5;
mem[5] = MASK_6;
mem[6] = MASK_7;
mem[7] = MASK_8;
temp = 8'bxxxx_xxxx;
end

assign {A2, A1, A0} = A;
assign {GS, EO} = GS_EO;

integer i;

always @(*)
begin
for (i = 7; i &gt; 0; i = i - 1)
    if (mem[i] &amp; D == mem[i])
        begin
        temp = mem[i];
        i = -1;
        end
if (E)
    begin
    A = HIGH_IMPEDANCE;
    GS_EO = 2'b11;
    end
else
    begin
        if (temp == 8'b1111_1111)
            begin
            A = HIGH_IMPEDANCE;
            GS_EO = 2'b10;
            end
        else
            begin

            GS_EO = 2'b01;
            case (temp)
                8'b0000_0001: A = 3'b001;
                8'b0000_0011: A = 3'b010;
                8'b0000_0111: A = 3'b011;
                8'b0000_1111: A = 3'b100;
                8'b0001_1111: A = 3'b101;
                8'b0011_1111: A = 3'b110;
                8'b0111_1111: A = 3'b111;
            endcase

            end
    end
end
endmodule 


It fails to achieve the switching of signals A2-A0 which are always in a X-state (except when E = H). I've tried many solutions, but it feels like simulator can't manage 'case' block ( I tried also 'casex' block). There is a bug somewhere, but I can't figure it out. Does anyone have ideas?","You've got quite a few things going on here but your most immediate problem is probably.

assign D = {D0, D1, D2, D3, D4, D5, D6, D7};


This implicitly defined wire is only going to be 1 bit wide and so the high 7b are going to be dropped.  Isn't Verilog fun?

There are other logical problems but the easiest way of doing a priority encoder with a case statement is as follows:

casez (in)
  4'b???1 : out = 0;
  4'b??10 : out = 1;
  4'b?100 : out = 2;
  4'b1000 : out = 3;
  default : out = 0; //no match
endcase


The casez allow you to put in ? for don't care conditions similar to your truth table.  The first matching entry is taken which give you the priority behavior. 
 Adapt as needed for your case for width, direction of priority, width of IO, etc...

Finally as a stylistic concern your early loop termination should use break rather than directly modifying the loop variable.",,,,,
Non-blocking assignment to ref parameter,"I would like to understand how tasks in System Verilog work. I thought that a task was just a way of naming and parametrising a bit of code that could otherwise appear enclosed between a begin and an end. However, the way that the parameters work is non-obvious. 

Say I want to factor out instances of non-blocking assignments from a module. I might do something like the following, thus reaching the point where there are two instances of the same task that differ just in the parameters (ff_0 and ff_1).

module test_inlined;

bit clk;
int count = 0;   
logic [7:0] x, y, z;

task automatic ff_0;
   @(posedge clk);
   y &lt;= x;
endtask

task automatic ff_1; // really same task as ff_0 to within variable renaming
   @(posedge clk);
   z &lt;= y;
endtask   

always
  ff_0;

always
  ff_1;

always @(posedge clk)
  $strobe(""%d: x=%d, y=%d, z=%d"", count, x, y, z);

always
  #5 clk = !clk;

always @(posedge clk)
  begin
    x &lt;= count;
    count ++;
    if (count &gt; 20) $finish;    
  end   

endmodule


It would be trivial to instead place the factored out assignments (aka flip-flops) into two instantiations of the same module, so it would make sense for it to be also possible to express the same functionality in terms of two instances of the same task. 

The following does not work because out is supposedly automatic, or that is what Modelsim claims. I do not see why it would be since it is fairly obviously a reference to a static member of a module? 

task automatic ff (ref logic [7:0] out, ref logic [7:0] inp, ref bit clk);
 @(posedge clk);
 out &lt;= inp;
endtask   

module test_broken;

  bit clk;
  int count = 0;   
  logic [7:0] x, y, z;

  always
    ff(y, x, clk);

  always
    ff(z, y, clk);

  // .... same as before

endmodule


It does make sense that the tasks need to be automatic to use ref parameters because then there is no need to worry about their lifetime. It is less clear why only blocking assignments to an automatic variable would be allowed. It is not like there is any obvious need for auto variables to go away while there are pending non-blocking assignments?

How do I factor out non-blocking assignments into a task, please? Many thanks in advance.","The problem is that task cannot assume anything about the storage classification of the variable passed to it. The code generated for the task has to work for any kind of storage, so passing by ref has to take on the pessimistic set of restrictions. ",,,,,
Can I use Modelsim license for Student Edition 10.6 for Altera Modelsim 16.0 edition?,I have the license for Modelsim 10.6 SE. Can I use the same license for Altera-Modelsim 16.0 (latest version)?,"If think that the answer for your question is buried here:

The ModelSim - Intel FPGA Edition software requires a valid license. This license expires 15 months after the date of purchase. Every 15 months you must regenerate your license file in the Self-Service Licensing Center to renew your license for the specific ModelSim-Intel FPGA Edition software version that you purchased. The ModelSim - Intel FPGA Edition software does not require a separate license file. If you purchase this software, your Quartus Prime license file includes a FEATURE line to enable it. You must, however, specify the location of license file for the ModelSim Intel FPGA Edition software using an environment variable before you can use it. Refer to the topic about specifying a ModelSim license file for more information.

Source: IntelÂ® FPGA Software Installation and Licensing

Q: Is the ModelSim-Intel FPGA Edition software the same as the ModelSim PE/DE software?
A: No. ModelSim-Intel FPGA Edition software only supports our gate-level libraries. The ModelSim-Intel FPGA Edition software includes the base features of ModelSim PE, including behavioral simulation, HDL testbenches, and Tcl scripting. However, ModelSim PE optional features are not supported in the ModelSim-Intel FPGA Edition software and the simulation performance of the ModelSim-Intel FPGA Edition software is slower than that of the ModelSim PE/DE software.

Source: https://www.altera.com/products/design-software/model---simulation/modelsim-altera-software.html#note2
But the easiest way to verify that would be to install ModelSim-Intel and test it.",,,,,
How to synchronize two unrelated UVM sequence items from different UVM agents?,"

This is my scenario for verifying a Parity Encoder-Decoder DUT. Decoder Input agent here is the re-active agent and injects error into the data stream captured from Passive monitor in Encoder Output agent. 

Now I have sequence and sequence items separately for both encoder and decoder input agents. But how do I synchronize both the agents such that decoder re-active agent adds error and creates a new packet for every data in order.

e.g suppose encoder sends data in the order - 1000, 1010, 0100, 1011 and decoder re-active agent creates error packets in the order (one hot bit) - 0010, 1000, 0001, 0100. Now both create data packets unrelated to each other. However the re-active agent should xor 1st data with its 1st packet like 1000 ^ 0010 even if it receives two data i.e 1000 and 1010 together from the passive agent monitor.
Also since both agents are generating items, decoder should not send an item before it receives data from encoder agent (via passive encoder agent monitor).","I think, you want to use the lockign mechanism between different objects.

You can use the IPC (Interprocess Communication) methods to control that, like events, mailboxes, semaphores.

In UVM, the advanced methods are available, like uvm_event, TLM FIFOs, which can be used in your purpose.",,,,,
What is the purpose of register model in UVM?,"In UVM, the testbench does not have any visibility into the internal registers of the DUT. Then why is there mirroring and creation of Register models in the UVM testbench architecture? What purpose does it serve?

The testbench would not come to know if any status bit etc is ever updated or not inside DUT since it only has access to its input output ports.","The DUT may not have direct access internal registers via ports, but some registers are accessible via an interface protocol. The register model is primarily intended for these registers. But you can access any register in the design via the backdoor (but not always desirable as it requires more work to setup and maintain).

The mirror stores the value of what the test-bench thinks are the register values of the DUT. When you do a .mirror(), the register model compares the register value (actual) verses the mirror (expected).

Status bits are often complicated to predict. To simplify things you can turn off the compare of the field (or register) with .set_compare(UVM_NO_CHECK). If you disable the check at the field level, other fields in the same register will still be compared. 

If your ambiances and want to do more complex predictions/mirror-compare on status bits, then you do have the options, such as register callbacks or of extending the uvm_reg and uvm_reg_field classes to overwrite the .predict and .mirror methods.",,,,,
How to make $display messages show up in SimVision console,"I have to use the Cadence program suite to complete a Verilog class assignment and I'd like to know why $display statements in the very simple mock-testbench I have created do not produce output in the SimVision console window.

My workflow goes like this:
I have created a cell with the following functional view:

module tesbench ( );
  initial begin
    $display(""RUNNING TESTBENCH"");
    $finish;
  end
endmodule


I have then invoked NC-Verilog, initialized and netlisted and simulated the
cell which opens the SimVision console window. Running the simulation then produces the following output:

ncsim&gt; run
Simulation complete via $finish(1) at time 0 FS + 0
/home/path/to/verilog/file.v:4      $finish;
ncsim&gt; 


So $display output is not shown. This seems like a very simple problem but I cannot for the life of me figure out what I'm doing wrong.","Okay, so I have just been able to speak with an instructor and he told me that
this is a known problem with the installation and that there is currently no work-around (the programs are running on a server administrated by the university).",,,,,
SystemVerilog register design race avoidance,"While doing digital design in systemverilog, I ran into an issue regarding racing conditions.

The test-bench (which I cannot modify) that drives my design, drives the inputs in such a way that certain registers in the design do not function properly due to a race condition.

Here is an eda-playground example which illustrates what is happening (input changes ""before"" the clock does, at time 15ns):

http://www.edaplayground.com/x/rWJ

Is there a way to make the design (a simple register in this case) resistant to this particular problem? What I need is a statement like ""out_data &lt;= preponed(in_data);"" or something similar which will make the order of input signal changes irrelevant.

I have read about #1step in the SystemVerilog LRM but I am unsure how to use it, nor if it can help me with this particular problem at all.","Your test bench is essentially creating stimulus that is in a setup violation to your register. You have two options: 


Convince the testbench writer of their erroneous ways and get them to fix it. 
Insert a layer of hierarchy around the design that delays the clock to eliminate the race.
",,,,,
Overflow in SystemVerilog constraints,"Integer types in SystemVerilog, as in most languages, wrap around on overflow.  I was wondering if this is also true in constraints.  For example:

class Test;
  rand bit [3:0] a;
  rand bit [3:0] b;

  constraint c { a + b &lt;= 4'h6; }
endclass;


When randomizing an object of this class, is it possible to get a solution where a == 7 and b == 12, which would satisfy the constraint since 7 + 12 = 19 which wraps around to 3, and 3 is less than 6?

If so, would it help to formulate the constraint as

constraint c { a + b &lt;= 6; }


where 6 is a 32-bit signed int and the sum is forced to be calculated with 32-bit precision?  (This of course is not a solution if the random variables are of type int)","You are correct. Expression evaluation is identical whether you are inside a constraint or not. In addition to overflow, you also need to be concerned about truncation and sign conversion. Integral expressions are weakly typed in SystemVerilog. ",,,,,
Prepone Region in SystemVerilog,"In SystemVerilog simulation, the prepone region is one of the several regions in a given time slot. What is the actual purpose of this region? Can anyone explain this with a valid example?","The preponed region is a conceptual name for the state of all signals at the begining of the current time slot. The state of signals in the preponed region is by definition identical to the state of the postponed region of the previous time slot. 

This preponed state is used as the sampled value for any signal used in an assertion except the clock. Using these sampling semantics eliminates the possibility of race conditions between the clock and the Boolean expression that is part of an assertion statement.",,,,,
Error in reading value from SV in C++ function using DPI,"I am trying to pass a string from SV to C++ function but the value is not getting passed properly to C++ function

Code in SV side:

    import ""DPI"" function string mainsha(string str);
    class scoreboard ;
     string text_i_cplus;
     string text_o_cplus; 
    text_i_cplus=""abc"";
    text_o_cplus=mainsha(text_i_cplus);


That's how I am sending value to C++ . At the C++ side I am taking value as:

    extern ""C"" string mainsha(string input)
 {

    string output1 = sha256(input);

    cout &lt;&lt; ""sha256('""&lt;&lt; input &lt;&lt; ""'):"" &lt;&lt; output1 &lt;&lt; endl;
   return output1;
 }


I am getting correct output when I running the C++ prog alone. But at the console I am getting the following output:


  sha256(''):e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855


Can someone please suggest where I am going wrong or am I missing something?","The DPI in current SystemVerilog standard only supports the C language, not C++. In fact you should be using import ""DPI-C"". in C++, string is a class and C only has arrays of char

  extern ""C"" const char * mainsha(const char * input)
 {

    string output1 = sha256(input); // not sure if you need a cast here

    cout &lt;&lt; ""sha256('""&lt;&lt; input &lt;&lt; ""'):"" &lt;&lt; output1 &lt;&lt; endl;
   return output1.c_str();
 }


If you are using Modelsim/Questa, there is a -dpiheader switch that you can use that automatically generates the DPI prototypes for you and you can include that file when you compile your C++ code. That way you will get a compiler error if there is a mismatch and not have to debug run-time behaviors. ",,,,,
Static integer in a class method shows unexpected behaviour,"Consider the following code:

class my_class;

  // *** constructor
  function new(string name = """");
    super.new(name);
  endfunction

  // ** my_function
  function void my_function();
    static int my_static_int = 0;
    my_static_int++;
    $display(""my_static_int = %0d"", my_static_int);
  endfunction

endclass


In my code, Assume I have a sequence with body -

// ** body
task body();

  my_class my_class_A = new;
  my_class_A.my_function();

endtask


My issue is that if I were to call body twice from my test, the second time, my_static_int has the value 2 instead of what I expected which is 1. 

Since my_class_A is destroyed each time body is run (I verify this using %p), shouldn't the subsequent run on a completely different object of my_class print a value of 1 again

Maybe my understanding is lacking here.. Any help is appreciated","A static variable means there is only one copy of the variable and one initialization of that variable before time 0. Without the static keyword, it would have been an automatic variable that gets allocated and initialized each time your function gets called. 

If you want a variable that gets initialized each time the object gets constructed, simply declare it as a class member variable.",,,,,
Verilog null/invalid slice ranges in unreachable evaluations,"Sometimes a situation comes up in parameterized code where I want to check against an array slice iff the width of that slice is non zero. I might write something like this:

parameter SLICE_WIDTH;
parameter SLICE_BASE;
logic [my_array_size : 0] my_array;
//...
always_ff @ (posedge clk) begin
   if (SLICE_WIDTH==0 || my_array[SLICE_BASE+:SLICE_WIDTH]==0) begin
   //alternately ""if (SLICE_WIDTH==0 || my_array[SLICE_WIDTH+SLICE_BASE-1:SLICE_BASE]==0) begin""
      //do something
   end
   else begin
      //do something else
   end
end


This was the way I handled these situations when writing VHDL; relying on short circuiting in the constant evaluations to prevent the invalid array range from ever being evaluated. In system verilog as written, this throws up ""range of part select is reversed"" errors and ""range width cannot be zero"" errors in QuestaSim.

Is there a way to cleanly deal with null ranges that most tools accept without duplicating the contents of //do something into several if-generate constructs?","What you can do is create a masking parameter

parameter SLICE_WIDTH;
parameter SLICE_BASE;
localparam logic [my_array_size : 0] MASK) = 2**SLICE_WIDTH - 1 &lt;&lt; SLICE_BASE;
logic [my_array_size : 0] my_array;
//...
always_ff @ (posedge clk)
   if (my_array&amp;MASK) begin
      //do something
   end
   else begin
      //do something else
   end


Synthesis tools will optimize logic away when MASK is 0.

Didn't test this, so you might have to play with my equation. ",,,,,
verilog if-statement using register,"Is there a difference between the following IF-statements?

reg SRR_read;


1:

if (SRR_read == 1'b1) begin
....
end


2:

if (SRR_read) begin
....
end
","No, both constructs are equivalent.

The same way:

if (!inword)
  ...


is equivalent to:

if (inword == 0)
  ...


In some cases, the first construct makes more sense to someone reading the code than the second one. (1800-2012 - IEEE Standard for SystemVerilog, ch. 11.4.7)",,,,,
i don't understand the utility of default values in state machine,"I am trying to understand state machine in VHDL for detecting the edge on a signal in VHDL. in next state I dont understand why we put the:
""next_etat&lt;= reg_etat"" because I think it could work without any problem even without it .
I'd would what are the default value of reg_etat and next_etat when we have just run the program because their is no real default value like in c for example int var=0; 

entity machine_etat is
    Port ( clk : in STD_LOGIC;
        rst : in STD_LOGIC;
        entree : in STD_LOGIC;
        tc : out STD_LOGIC);
end machine_etat;

architecture architecture_machine_etat of machine_etat is
type T_etat is (idle,edge,one);
signal next_etat, reg_etat : T_etat;
begin

registre_etat: process(clk)
begin
    if rising_edge(clk) then
        if rst = â€?â€?then
            reg_etat &lt;= idle;
        else
            reg_etat &lt;= next_etat;
        end if;
    end if;
end process registre_etat;

tc &lt;= â€?â€?when reg_etat = edge else â€?â€?

etat_suivant: process(reg_etat,entree)
begin
next_etat &lt;= reg_etat;-- defaults values here i dont see their purpose
case reg_etat is
    when idle =&gt;
        if entree =â€?â€?then
            next_etat &lt;= edge;
        end if;
    when edge =&gt;
        next_etat &lt;= one;
    when one =&gt;
        if entree =â€?â€?then
            next_etat &lt;= idle;
        end if;
    end case;
end process etat_suivant;
end architecture_machine_etat;
","If you don't assign next_etat (pardon my French) in all situations, logical synthesis will infer a latch to remember it's state. A latch is something you don't want, as it is very sensitive to digital logic latencies and might become metastable: also something you don't want.

HDL programming significantly differs from CPU programming.",,,,,
System Verilog Testbench waveforms no data,"I'm trying to develop a code which acts like a logical calculator; I've managed to compile both the code and the testbench without any errors. Here is the code:

   module AriLogCal(
                    input logic [3:0] OpA, OpB, //Operands A and B. The two numbers we will operate on.
                    input logic [2:0] DoOpt,        //Operator. Determines the operation we will do.
                    input logic EqualTo, AC,        //Interrupts. AC resets, EqualTo transfers data to display.
                    output logic [6:0] S2, S1, S0   //Seven-Segement LEDS. Shows each digit separately.
                 );

logic [7:0] result;                                     //Result. 
Mathematical operation result data is stored here.
logic [3:0] D2, D1, D0;                                 //Digits. Determines 
the number/symbol/deactivation for each respective SevenSeg.

always begin
if(AC)begin //Makes all the numbers display 0 if AC returns TRUE
result=8'b00000000;
S0=7'b1111110;
S1=7'b1111110;
S2=7'b1111110;        
end
else if(EqualTo)begin //Does this stuff if EqualTo returns TRUE

//Part 1: Operation. Decides the relationship between Operand A and B and stores data under ""result""
case(DoOpt) 
3'b000:result=OpA+OpB; //Addition
3'b001:begin              //Subtraction
    if(OpB&gt;OpA)
        result=OpB-OpA;
    else
        result=OpA-OpB;
end 
3'b010:result=OpA*OpB; //Multiplication
3'b011:begin                //Division
    if(OpB)
        result=OpA/OpB;
    else
        result=0;
end
3'b100:begin
    if(OpA&amp;&amp;OpB)              //Logical AND
        result=8'b00000001;
    else
        result=8'b00000000;
end
3'b101:begin
    if(OpA||OpB)              //Logical OR
        result=8'b00000001;
    else result=8'b00000000;
end
endcase

//Part 2: Digits. Dissects the value of ""result"" into its decimal digits and stores them in logic ""D""
if(!OpB&amp;&amp;DoOpt==3'b011)      //This will show ""Err"" on LED displays
D0=4'b1010;
else if(result&lt;10)begin //Single Digit. S1 and S2 is temporarily set to zero
D0=result;
D1=4'b0000;
D2=4'b0000;
end
else if(result&lt;100)begin //Double digit. S2 is temporarily set to zero
D0=result%10;
D1=result/10;
D2=4'b0000;
end
else begin                   //Triple digit. 
D2=result/100;
result=result%100;
D1=result/10;
D0=result%10;
end


//Part 3: Blanks. Adds blanks and negative sign depending on operation type, according to requirements
case(DoOpt)
3'b000:D2=4'b1011;       //Addition deactivates S2
3'b001:begin             
if(OpB&gt;OpA)                 //Subtraction deactivates or shows negative sign 
for S2
    D2=4'b1100;
else
    D2=4'b1011;
end
3'b011:begin                 //Multiplcation is skipped. 
if(!OpB)begin               //Division has two options:
    D0=4'b1010;             //If divider is 0, this will show ""Err"" on LED 
displays
    D1=4'b1010;
    D2=4'b1010;
end else                        //Otherwise, S2 is deactivated
D2=4'b0000;
end
3'b100:begin                //Logical AND deactivates S2 and S1
    D2=4'b1011;
    D1=4'b1011;
end
3'b101:begin                //Logical OR deactivates S2 and S1
    D2=4'b1011;
    D1=4'b1011;
end
endcase

//Part 4: Display. Prints the digits from ""D"" onto its respective Seven Segment LED S
case(D0)
 4'b1010: S0&lt;=7'b0000101; //D0=10 means S0 displays R
 4'b1001: S0&lt;=7'b1110011; //9
 4'b1000: S0&lt;=7'b1111111; //8
 4'b0111: S0&lt;=7'b1110000; //7
 4'b0110: S0&lt;=7'b1011111; //6
 4'b0101: S0&lt;=7'b1011011; //5
 4'b0100: S0&lt;=7'b0110011; //4
 4'b0011: S0&lt;=7'b1111001; //3
 4'b0010: S0&lt;=7'b1101101; //2
 4'b0001: S0&lt;=7'b0110000; //1
 4'b0000: S0&lt;=7'b1111110; //0
 endcase
 case(D1)
 4'b1011: S1&lt;=7'b0000000; //D1=11 means S1 deactivates
 4'b1010: S1&lt;=7'b0000101; //D1=10 means S1 displays R
 4'b1001: S1&lt;=7'b1110011; //9
 4'b1000: S1&lt;=7'b1111111; //8
 4'b0111: S1&lt;=7'b1110000; //7
 4'b0110: S1&lt;=7'b1011111; //6
 4'b0101: S1&lt;=7'b1011011; //5
 4'b0100: S1&lt;=7'b0110011; //4
 4'b0011: S1&lt;=7'b1111001; //3
 4'b0010: S1&lt;=7'b1101101; //2
 4'b0001: S1&lt;=7'b0110000; //1
 4'b0000: S1&lt;=7'b1111110; //0
 endcase
 case(D2)
 4'b1100: S2&lt;=7'b0000001; //D2=12 means S2 shows negative sign
 4'b1011: S2&lt;=7'b0000000; //D2=11 means S2 deactivates
 4'b1010: S2&lt;=7'b1001111; //D2=10 means S2 displays E
 4'b1001: S2&lt;=7'b1110011; //9
 4'b1000: S2&lt;=7'b1111111; //8
 4'b0111: S2&lt;=7'b1110000; //7
 4'b0110: S2&lt;=7'b1011111; //6
 4'b0101: S2&lt;=7'b1011011; //5
 4'b0100: S2&lt;=7'b0110011; //4
 4'b0011: S2&lt;=7'b1111001; //3
 4'b0010: S2&lt;=7'b1101101; //2
 4'b0001: S2&lt;=7'b0110000; //1
 4'b0000: S2&lt;=7'b1111110; //0
 endcase
 end
 end
 endmodule


and here is the current testbench (this is a shorter version; I'm still trying to find the problem behind this)

`timescale 1ns/1ps
module AriLogCal_tb;
logic [3:0] in_OpA;
logic [3:0] in_OpB;
logic [2:0] in_DoOpt;
logic in_EqualTo;
logic in_AC;
logic [6:0] out_S2, out_S1, out_S0;

AriLogCal AriLogCal_inst0(.OpA(in_OpA), .OpB(in_OpB), .DoOpt(in_DoOpt), 
.EqualTo(in_EqualTo), .AC(in_AC), .S2(out_S2), .S1(out_S1), .S0(out_S0));

initial begin
in_EqualTo=1'b0;
in_AC=1'b0;


in_OpA = 4'b0111; in_OpB = 4'b0010; in_DoOpt = 3'b000; 
in_EqualTo = 1'b0;#100;

$finish;

end
endmodule


Both of these files are able to individually compile successfully, with no errors. However, when I try to compile them in the RTL Simulator, I get these results:

https://drive.google.com/file/d/0By4LCb9TUml0WWVsZEYtcG03LVk/view?usp=sharing

Why do I still get ""No Data"" in my results, despite successful compilation? Immediate help will be appreciated. Thanks in advance.","There isn't any event/time blockers in AriLogCal's always block.always begin is an infinite loop. It will continuously re-evaluate and prevent the simulator from moving to the next time step.

It should be changed always_comb begin, which has an inherited time blocking and will only trigger the at time 0 and when an stimulus signal changes. Alternative you could use the Verilog auto-sensitivity @* (or the synonymous @(*)) and change the statement to always @* begin. always_comb is superior to always @* because it with through compiling errors if basic synthesis requirements are not stratified (ex: register is assigned in only one always block and no blocking @ or # statements in the  always block).

FYI: You should not be using non-blocking (&lt;=) assignments in combinational logic; blocking (=) assignments are preferred. Non-blocking assignments should be used in always_ff and the occasional always_latch.",,,,,
Shift Register or FIFO in block RAM (Xilinx),"I have to buffer some data in a quite big buffer. It is not a usual shift register or a FIFO, because I will have to be able to read data also from the middle of the buffer.
I managed to implement that in a way so I can use it as I need it. The problem is, that it does make use of LUTs for that, which takes a lot of space in my design. I would like to change my design so, that the buffer gets inferred as Block RAM. Using ram_style ""block"" didn't help. Any ideas or suggestions how I could achieve that?
Update: buf_size is declared in a package:
    constant buf_size : natural := 5;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity deriv_buffer is
  generic(
    NSAMPLES : natural := 16
  );
  port(   
    clk : in std_logic;
    rst : in std_logic;
    deriv_s : in t_deriv_array( NSAMPLES - 1 downto 0 );
    deriv_buf : out t_deriv_array( buf_size * NSAMPLES - 1 downto 0 )
  );
end deriv_buffer;

architecture Behavioral of deriv_buffer is

  signal deriv_buf_s : t_deriv_array( (buf_size-1) * NSAMPLES - 1 downto 0 );
  attribute ram_style : string;
  attribute ram_style of deriv_buf_s : signal is ""block"";

begin

  deriv_buf( buf_size * NSAMPLES - 1 downto (buf_size - 1) * NSAMPLES ) &lt;= deriv_s;

  buffer_p : process( rst, clk )
  begin
    if rst = '1' then
      deriv_buf_s &lt;= ( others =&gt; ( others =&gt; '0' ) );
    elsif rising_edge( clk ) then
      deriv_buf_s( (buf_size - 1) * NSAMPLES - 1 downto (buf_size - 2) * NSAMPLES ) &lt;= deriv_s;
      deriv_buf_s( (buf_size - 2) * NSAMPLES - 1 downto (buf_size - 3) * NSAMPLES ) &lt;= deriv_buf_s( (buf_size - 1) * NSAMPLES - 1 downto (buf_size - 2) * NSAMPLES );
      deriv_buf_s( (buf_size - 3) * NSAMPLES - 1 downto (buf_size - 4) * NSAMPLES ) &lt;= deriv_buf_s( (buf_size - 2) * NSAMPLES - 1 downto (buf_size - 3) * NSAMPLES );
      deriv_buf_s( (buf_size - 4) * NSAMPLES - 1 downto (buf_size - 5) * NSAMPLES ) &lt;= deriv_buf_s( (buf_size - 3) * NSAMPLES - 1 downto (buf_size - 4) * NSAMPLES );
    end if;
  end process buffer_p;

  deriv_buf( (buf_size-1)*NSAMPLES - 1 downto 0 ) &lt;= deriv_buf_s;

end Behavioral;
","If you want you use a block RAM, you need to consider that a block RAM only has 2 ports. You cannot look freely into the data in the RAM: you need to access it through either port.

Furthermore, reading and/or writing takes a clock cycle to process.

So if we look at your code, it already starts out problematically:

entity deriv_buffer is
    [...]
    port(
        [...]
        deriv_buf : out t_deriv_array( buf_size * NSAMPLES - 1 downto 0 )


You have your whole RAM connected to an output port! I don't know what you are doing with the contents in the entity using this component, but as I said: you don't have free access to the contents of a block RAM. You need to follow proper block RAM design guidelines.

Refer to the Xilinx Synthesis User Guide for instance for proper block RAM instantiation. (Chapter 4 HDL Coding Techniques, section RAM HDL Coding Techniques)



Next problem: reset

if rst = '1' then
    deriv_buf_s &lt;= ( others =&gt; ( others =&gt; '0' ) );


Resetting a RAM is not possible. If you really want to clear the RAM, you need to write a (others=&gt;'0') to each separate address location. Thus you need control logic to do so. But now, using this reset code will not allow a block RAM to be instantiated.



Then in your code you have the part

deriv_buf_s( (buf_size - 1) * NSAMPLES - 1 downto (buf_size - 2) * NSAMPLES ) &lt;= deriv_s;
deriv_buf_s( (buf_size - 2) * NSAMPLES - 1 downto (buf_size - 3) * NSAMPLES ) &lt;= deriv_buf_s( (buf_size - 1) * NSAMPLES - 1 downto (buf_size - 2) * NSAMPLES );
deriv_buf_s( (buf_size - 3) * NSAMPLES - 1 downto (buf_size - 4) * NSAMPLES ) &lt;= deriv_buf_s( (buf_size - 2) * NSAMPLES - 1 downto (buf_size - 3) * NSAMPLES );
deriv_buf_s( (buf_size - 4) * NSAMPLES - 1 downto (buf_size - 5) * NSAMPLES ) &lt;= deriv_buf_s( (buf_size - 3) * NSAMPLES - 1 downto (buf_size - 4) * NSAMPLES );


This code has two big issues:


You try to read and write within one clock cycle. But like I said, it takes one clock cycle to read the block RAM and a second clock cycle to write.
This code instantiates 4 write ports and 3 read ports. Like I said: a block RAM only has 2 ports.


You could implement the code to use 4 block RAM instances. But then still all the ports of these block RAMs would be occupied. So no port would be left to provide random access to all the data in the RAM, like you wish.



Conclusively: I think you should reconsider your requirement. What you want is not possible in block-RAM. If you want to use block RAM, you should change your algorithm.",,,,,
simulation errors in implementing xilinx fifo core,"I have generated a core IP from Xilinx core generator for FIFO. I get some errors while simulating the design. 

In stimulus my clock switches on every #1 and write flag is also set at #1 followed by din and again write flag unset at #1. Followed by same thing with read flag

The problems are:
1. Full flag is set earlier than the data is filled with FIFO.
2. The read won't start from first pointer, instead starts with 4th read pointer.

Any suggestions?

initial begin

    clk = 0;
    rst = 0;
    rst = 1;
    #1 rst = 0;
    wr_en = 0;
    rd_en = 0;

    for (i=0; i&lt;1024; i=i+1) begin : wr_loop
        #1 wr_en = 1;
        din &lt;= i;//$urandom_range(5,14);
        #1 wr_en = 0;
    end

    for (j=0; j&lt;1024; j=j+1) begin : rd_loop
            #1 rd_en = 1'b1;
            #1 rd_en = 1'b0;
    end

    #900000 $finish;
end

    always #1 clk = ~clk;


simulation image link: (the full flag should raise after 1024 entries)","I think you have a timing issue. If this is a FIFO synchronous to the rising clk edge, it may not correctly latch your wr_en or rd_en pulses.

For starters, I would try to keep wr_en simply high for the number of clk cycles you want to execute writes. Also, to avoid race conditions between your initial and always blocks, make clk generation part of the initial block and make sure the wr_en and rd_en signals change on the inactive (usually falling) edge of clk.",,,,,
VHDL package and std_logic_vector,"I'm trying do declare a type to use in the port but i'm with a problem
if I do the following I get an error that STD_LOGIC_VECTOR isn't declared 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.all;
-- Custom types --
package Common  is
    type Mem_in is array (2**6 to 0) of STD_LOGIC_VECTOR (11 downto 0); 
    type DinDout is range 11 downto 0;
end package Common ;
-- Use Custom Type
use work.Common.all;

entity MUX is

    Port (
        D       :   in Mem_in;
        Q       : Â  out DinDout;
        SEL     : Â  inÂ  STD_LOGIC_VECTOR (11 downto 0)
        );
end MUX;


Why can't I use STD_LOGIC_VECTOR? If I change it to DinDout I get another problem down the line in the architecture: to_integer is not declared; indexed name is not a dindout.

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.all;
-- Custom types --
package Common  is
    type Mem_in is array (2**6 to 0) of STD_LOGIC_VECTOR (11 downto 0); 
    type DinDout is range 11 downto 0;
end package Common ;


And the entity using package Common:

-- Use Custom Type
use work.Common.all;

entity MUX is

    Port (
        D       :   in Mem_in;
        Q       : Â  out DinDout;
        SEL     : Â  inÂ  DinDout
        );
end MUX;

architecture Arc of MUX is
begin
    Q &lt;= D(to_integer(unsigned(SEL)));
end Arc; 


how can I add STD_logic_vector to my package OR solve these two errors: to_integer is not declared; indexed name is not a dindout?

thanks","You have two library units in one file (if it is a single file you have quoted). While I am not sure what happens, I guess it restarts the context with every unit.

That would mean you have to repeat

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.all;

before use work.Common.all;.

Also 2**6 to 0 is a null range, that should be 0 to 2**6 or 2**6 downto 0.",,,,,
how to update the output on the rising edge of the clock in structural VHDL code?,"I have this very simple 16-bit and gate written in structural form in VHDL:
The files are uploaded here.

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity and_16bit is
  Port (
        A   : in std_logic_vector(15 downto 0);
        B   : in std_logic_vector(15 downto 0);
        Clk : in   STD_LOGIC;
        --Rst : in   STD_LOGIC;
        C   : out std_logic_vector(15 downto 0) );
end and_16bit;

architecture Behavioral of and_16bit is
component and_1bit is
  Port (
        A   : in std_logic;
        B   : in std_logic;
        C   : out std_logic );
end component;

signal s : std_logic_vector(15 downto 0);

begin
            ands: for i in 15 downto 0 generate
            and_1bit_x: and_1bit port map (A =&gt; A(i), B =&gt; B(i), C =&gt; s(i));
            end generate;
process(Clk)
    begin
        if rising_edge(Clk) then
             C &lt;= s;                     
        end if;
        end process;
end Behavioral;


In order to update the output in the rising edge of the clock, I have defined this ""s"" signal. I wonder if this is the correct way to update the output in structural VHDL codes? what should I do to scape the unknown output for the first output? 

Any comments will be a great help.","It's better to put the sequential process into a submodule and instantiate it in the top-level (and_16bit). Then your top-level will be more structural.

You can have one instance for each bit as you did for and_1bit.

For example, this module is a 1-bit register.

entity dff_1bit is
    Port (
        D   : in  std_logic;
        Clk : in  std_logic;
        Q   : out std_logic );
end dff_1bit;

architecture Behavioral of dff_1bit is
begin

process(Clk)
    begin
        if rising_edge(Clk) then
             Q &lt;= D;                     
        end if;
end process;

end Behavioral;


Then you can instantiate it in and_16bit, inside the same generate block.

dff_1bit_x: dff_1bit port map (D =&gt; s(i), Clk =&gt; Clk, Q =&gt; C(i));
",,,,,
latch warning due to case statement with codeword from ps2 keyboard verilog,"Im working with ps2 keyboard and a basys2 to simulate the behavior 
of two elevator in a building of 4 floors (sub, 1, 2 and 3)

This code saves the internal requirements of each elevator, cw is the codeword from the ps2 keyboard

The paremeters defined are the codewords for the keys (ps2 keyboard keys) used in the simulation 
ps2 keyboard codes

module reg_in2(
    input [7:0] cw,
    output reg[3:0] reqin_a1,
    output reg[3:0] reqin_a2
    );
parameter a1_sub =  8'h6b;
parameter a1_1 = 8'h6c;
parameter a1_2  = 8'h75;
parameter a1_3 = 8'h7d;
parameter a2_sub = 8'h70 ;
parameter a2_1 = 8'h69 ;
parameter a2_2 = 8'h72 ;
parameter a2_3 = 8'h7A ;

initial
begin
reqin_a1 = 4'b0;
reqin_a2 = 4'b0;
end

always@(cw)
begin
    case(cw)
    a1_sub: reqin_a1[0] = 1;
    a1_1: reqin_a1[1] = 1;
    a1_2: reqin_a1[2] = 1;
    a1_3: reqin_a1[3] = 1;
    a2_sub: reqin_a2[0] = 1; 
    a2_1: reqin_a2[1] = 1;
    a2_2: reqin_a2[2] = 1;
    a2_3: reqin_a2[3] = 1;
    default: begin
                reqin_a1 = reqin_a1;
                reqin_a2 = reqin_a2;
                end
    endcase
end

endmodule


The only warnings i get are  (for every bit of reqin_a1 and reqin_a2)

Found 1-bit latch for signal &lt;reqin_a1_0&gt;. Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.

The value init of the FF/Latch 0 hinder the constant cleaning in the block reqin_a1_3.
   You should achieve better results by setting this init to 1.

Gated clock. Clock net
   req_in1/reqin_a2_1_cmp_eq0000 is sourced by a combinatorial pin. This is not
   good design practice. Use the CE pin to control the loading of data into the
   flip-flop.


My problem is not an error but an unexpected behavior of Basys2, i'm using the LED's to check reqin_a1 and reqin_a2 values.
When i press some of the designed keys in the ps2 keyboard, more than one led lights on. 
Example: I press 2 in ps2 keyboard (parameter a2_2) and reqin_a2[0] and reqin_a2[2] are changed to 1
I've really tried a lot of things, so i would really appreciate some help","Level-sensitive latches occur when a reg is defined in no-sequential always block and is not assigned to a determinate value for all possible branches. For example always @* if (en) q = d; is an latch because q is not assigned a value when en is low. Adding else q = q; will still infer a latch.

The reason multiple lights turn on on a button press is the enable logic is not clean. The bits of cw maybe arriving a few nanoseconds/ picoseconds apart. There is also the prorogation delay matching cw to each state. In both case are likely culprits for a glitch.

The easiest solution is to make the design synchronous by adding a clock.

always @(posedge clock)
begin
    case(cw)
    a1_sub: reqin_a1[0] &lt;= 1;
    a1_1: reqin_a1[1] &lt;= 1;
    // ...
    a2_2: reqin_a2[2] &lt;= 1;
    a2_3: reqin_a2[3] &lt;= 1;
    // Note default is not required
    endcase
end


When intentionally creating a latch, keep the enabling logic clean. Preferably from a clock source. And use non-blocking assignment &lt;=. Try to keep the latching logic as simple as possible. I recommended having a separate always block for each latch-enable signal. Latch are often unintentional. Make it easy for anyone reading your code and the synthesizer to identify intentional latch. Use comments (human only), pragmas (tool specific), or enable SystemVerilog and use always_latch (universal).",,,,,
How to derive a Fixed Length Output signal from a variable length Input signal in verilog,"I have an HDL Block in which the output follows the input in such a way that when input signal is binary 0, output remains 0 but when input turns 1, output turns 1 for a preset number of clock cycles (signal_length). i.e. input may remain high for suppose 65 or 66 clock cycles but output should remain high for preset number of clock cycles. I tried to accomplish the task with Verilog. But I am having an error and I donâ€™t know how to rectify. Hope someone can help.

module last_ind
#(
parameter MAX_LENGTH = 262144,
parameter signal_length
)
(
   input           clk,      
   input [17:0] pkt_length,
   input           tdata,
   output          tlast
);
reg [17:0] cnt = 0;

always @ (posedge clk)
begin
if ((tdata==1) &amp;&amp; (cnt&lt;signal_length)) 
        tlast &lt;= 1;
 else
        cnt &lt;= 0;
 end
 assign   cnt &lt;= cnt + 1'b1;
 endmodule
","maybe something like this will do. It should keep the signal up for the signal_length cycles and will reset when tdata gets '0'. You decide on the correct protocol though.

 reg [17:0]      cnt = signal_length;

 always @ (posedge clk) begin
    if (cnt &lt; signal_lenth)
      cnt &lt;= cnt + 1;
    else if (cnt == signal_length + 1 &amp;&amp; tdata == 1 &amp;&amp; tlast == 0) begin
      cnt &lt;= 0;
      tlast &lt;= 1;
    end
    else if (tdata == 0) begin 
       cnt &lt;= sighal_length + 1;
       tlast &lt;= 0;
    end
    else
       tlast &lt;= 0;
end
",,,,,
VHDL 2008 calculate length of vector without leading zeros,"i'm writing a small vhdl module, but i'm quite new to this language.
The length of the output vector of my entity is variable, depending on the msb of my polynom. For example if i have a polynom like 100111, len should be 4. So the output vector has 5 bits. 
One less than the input vector.

For clarification:
If the inputvector looks like ""000100111"", the output vector should also be (4 downto 0). That's why i just can't use 'length.

entity CRC_n_par is
generic(
    polynom     : std_logic_vector
    );
port(
    clk     : in    std_logic;
    input   : in    std_logic;
    reset   : in    std_logic;
    output  : out   std_logic_vector(integer(ceil(log2(real(to_integer(unsigned(polynom))))))-2 downto 0) );
end entity;
architecture Behavioral of CRC_n_par is

    constant len : integer := integer(ceil(log2(real(to_integer(unsigned(polynom))))))-2;


Is there any way, to do this more elegant. Here's a similar question, but i cannot use a function in the port declaration. After the port declaration, i use the constant len again. 
Is there a way to use a c-like macro in vhdl? 
I'm using vhdl 2008, that's why the conversion is so complicated, because i can only convert between closely related types.","The length is also needed were crc_n_par is instantiated:

library ieee;
use ieee.std_logic_1164.all;

entity crc_n_par is
    generic (
        len:           natural
    );
    port (
        clk:      in    std_logic;
        input:    in    std_logic;
        reset:    in    std_logic;
        output:   out   std_logic_vector (len - 1 downto 0) 
    );
end entity;
architecture Behavioral of crc_n_par is
begin
MONITOR:
    process
    begin
        report ""crc_n_par output len = "" &amp; integer'image(len);
        wait;
    end process;
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

entity some_top_level is
end entity;

architecture foo of some_top_level is
    -- For -2002 and earlier, present in -2008:
    function to_string (inp: std_logic_vector) return string is
        variable image_str: string (1 to inp'length);
        alias input_str:  std_logic_vector (1 to inp'length) is inp;
    begin
        for i in input_str'range loop
            image_str(i) := character'VALUE(std_ulogic'IMAGE(input_str(i)));
        end loop;
        return image_str;
    end function;
    constant polynom: std_logic_vector := ""000100111"";
    constant crc_inst_len : natural := 
        integer(ceil(log2(real(to_integer(unsigned(polynom))))))-1;
    signal clk:     std_logic;
    signal input:   std_logic;
    signal reset:   std_logic;
    signal output:  std_logic_vector (crc_inst_len - 1 downto 0);
begin
MONITOR:
    process
    begin
        report LF &amp; ""polynom len = "" &amp; integer'image(polynom'length) &amp;
               "" crc_inst_len = "" &amp; integer'image(crc_inst_len) &amp; LF &amp;
               "" output length = "" &amp; integer'image(output'length) &amp; 
               "" polynom = "" &amp; to_string(polynom);
        wait;
    end process;
CRC_INSTANCE:
    entity work.crc_n_par 
        generic map (
            len =&gt; crc_inst_len
        )
        port map (
            clk =&gt; clk,
            input =&gt; input,
            reset =&gt; reset,
            output =&gt; output
        );

end architecture;


This moves the length calculation to a higher point in the design hierarchy allowing the actual used for the port output to be declared with the proper length as well.

When analyzed, elaborated and simulated it produces:


ghdl -a some_top_level.vhdl
ghdl -e some_top_level
ghdl -r some_top_level
some_top_level.vhdl:20:9:@0ms:(report note): crc_n_par output len = 5
some_top_level.vhdl:55:9:@0ms:(report note):
polynom len = 9 crc_inst_len = 5
 output length = 5 polynom = 000100111



You can independently calculate the length two places:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

entity crc_n_par is
    generic (
        polynom:       std_logic_vector;
        len:           natural :=  -- requires -2008 to access polynom
            integer(ceil(log2(real(to_integer(unsigned(polynom)))))) - 1
        );
    port (
        clk:      in    std_logic;
        input:    in    std_logic;
        reset:    in    std_logic;
        output:   out   std_logic_vector (len - 1 downto 0) 
    );
end entity;
architecture Behavioral of crc_n_par is
begin
MONITOR:
    process
    begin
        report ""len = "" &amp; integer'image(len);
        wait;
    end process;
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

entity some_top_level is
end entity;

architecture foo of some_top_level is
    constant polynom: std_logic_vector := ""000100111"";
    constant crc_inst_len : natural := 
        integer(ceil(log2(real(to_integer(unsigned(polynom))))))-1;
    signal clk:     std_logic;
    signal input:   std_logic;
    signal reset:   std_logic;
    signal output:  std_logic_vector (crc_inst_len - 1 downto 0);
begin
MONITOR:
    process
    begin
        report LF &amp; ""polynom len = "" &amp; integer'image(polynom'length) &amp;
               "" crc_inst_len = "" &amp; integer'image(crc_inst_len) &amp; LF &amp;
               "" output length = "" &amp; integer'image(output'length) &amp; 
               "" polynom = "" &amp; to_string(polynom);
        wait;
    end process;
CRC_INSTANCE:
    entity work.crc_n_par 
        generic map (
            polynom =&gt; polynom
            -- don't pass len
        )
        port map (
            clk =&gt; clk,
            input =&gt; input,
            reset =&gt; reset,
            output =&gt; output
        );
end architecture;


But you can see that's unnecessary duplication and requires -2008 to analyze and elaborate:


ghdl -a --std=08 crc_n_par.vhdl
ghdl -e --std=08 crc_n_par
ghdl -r --std=08 some_top_level
some_top_level.vhdl:20:9:@0ms:(report note): crc_n_par output len = 5
some_top_level.vhdl:55:9:@0ms:(report note):
polynom len = 9 crc_inst_len = 5
 output length = 5 polynom = 000100111



Note the - 1 in calculating polynom length matches your question title:

VHDL 2008 calculate length of vector without leading zeros 

And this is the purpose of using conversion of the array value to an integer and determining it's log2 ceiling and subtracting one.",,,,,
Verilog: proper way of connecting ports,"Assume there are two different modules (first_module, second_module). Both of the modules are synchronized with clock signal. first_module has the following structure:

module first_module(
input clk,
input reset_n,
input in1,
output reg out1,
output reg out2
);

//******** some verilog codes *********

endmodule


And second_module has similar structure:

module second_module(
input clk,
input reset_n,
input in1,
input in2,
output reg out1
);

//******** some verilog codes *********

endmodule


And then there is a module called top_module which uses instances of both modules:

module top_module(
input clk,
input reset_n,
input insignal1,
input insignal2,
output outsignal1,
output outsignal2
);

first_module fm1(
  .clk(clk),
  .reset_n(reset_n),
  .in1(insignal1),
  .out1(outsignal1),
  .out2(&lt;connection1&gt;) // to be connected to the connection2 
);

second_module sm1(
  .clk(clk),
  .reset_n(reset_n),
  .in1(insignal2),
  .in2(&lt;connection2&gt;), // to be connected to the connection1
  .out1(outsignal2)
);    

endmodule


The aim is to connect connection1 to connection2. According to my knowledge (if it is correct), we can either declare a single wire (let its name be connection) and replace both &lt;connection1&gt; and &lt;connection2&gt; with it, or we can declare two distinct wires connection1 and connection2, then:

assign connection2 = connection1;


And connect them accordingly. 


Are those two methods synthesized differently? If the answer is yes, I would be glad if you could explain how they are synthesized.
If the answer is no, can one of the methods be better than the other in different conditions? Not in terms of lines of code or simplicity, but in terms of synthesis.
","Yes there is a difference. But not in your specific case.

Using a connection directly makes that is can be uni-directional or bi-directional depending on what the underlying ports in the module are. 

But assign connection2 = connection1; is only uni-directional. 

Thus between bi-directional ports should use direct connections or you should only use bi-directional Verilog constructs between them. The assign ... is not one of them.

But in you case the signal is uni-directional so it does not matter. 

Note that modern FPGAs no longer have on-chip bi-directional buses. (At least I don't know one that has). Also in chip design on-chip buses are strongly discourage or outright forbidden by the manufacturers.
Therefore bi-directional signals are normally only present in the test-bench. As that does not get synthesized your question does not apply there. 

Last but not least:
In HDL design I would strongly discourage from changing the name of a signal for no apparent reason. Having the same name throughout the design makes it easier to debug and trace your signals post-synthesis. ",,,,,
How to set base test environment in order to use with inherit classes?,"I have wrote axi4_stream test environment. It's work good, but now I need to test design with seq_item which inherit previous item. Theese item overrides convert2string and do_compare functions.

I thought to parameterized all the axi4_stream classes by seq_items, but in hour of trying to do this I concluded that it's just a pain, and I need to dig in different direction.

here prototypes of my classes
original:  

class axi4_s_seq_item extends uvm_sequence_item;
class axi4_s_sequence extends uvm_sequence#(axi4_s_seq_item);
class axi4_s_sequencer extends uvm_sequencer#(axi4_s_seq_item);
class axi4_s_master extends uvm_driver#(axi4_s_seq_item);
class axi4_s_slave extends uvm_driver();
class axi4_s_monitor extends uvm_monitor;
class axi4_s_scoreboard extends uvm_scoreboard;
class axi4_s_agent extends uvm_agent;
...


how I thought to change:   

class new_axi4_s_seq_item extends axi4_s_seq_item;

class axi4_s_seq_item extends uvm_sequence_item;
class axi4_s_sequence#(type seq_item = axi4_s_seq_item) extends uvm_sequence#(seq_item);
class axi4_s_sequencer#(type seq_item = axi4_s_seq_item) extends uvm_sequencer#(seq_item);
class axi4_s_master#(type seq_item = axi4_s_seq_item) extends uvm_driver#(seq_item);
class axi4_s_slave extends uvm_driver();
class axi4_s_monitor#(type seq_item = axi4_s_seq_item) extends uvm_monitor;
class axi4_s_scoreboard#(type seq_item = axi4_s_seq_item) extends uvm_scoreboard;
class axi4_s_agent#(type seq_item = axi4_s_seq_item) extends uvm_agent;
...


I guess I can use defines to change class names, but still I think there is OOP solution.","Use the UVM factory to set your overrides; don't try do everything with parameter overrides. This DVCon paper is pre-UVM, but still relevant for UVM for explaining the differences between parameterization and inheritance. ",,,,,
Passing in modules as types,"I have a bunch of 'unique' modules that share some common fields. I'd like to create a module that can reference this, say, by upward name referencing. Is it possible to pass in a module type as a parameter that can be used inside? I tried this:

  3 module A;
  4   int flag = 0;
  5 endmodule
  6
  7 module B;
  8   int flag = 1;
  9 endmodule
 10
 11 module C;
 12   int flag = 2;
 13 endmodule
 14
 15 module Bind #(parameter type T=A);
 16   initial begin
 17     $display(""flat = %0d"",t.flag);
 18   end
 19 endmodule
 20
 21 module tb;
 22   bind A Bind#(A) u_bound;
 23 endmodule


But I got the following compile errors:

-- Compiling module B
-- Compiling module C
-- Compiling module Bind
** Error: test.sv(15): (qverilog-2730) Undefined variable: 'A'.
** Error (suppressible): test.sv(15): (qverilog-2987) Illegal expression as initializer for type parameter 'T'.
-- Compiling module tb
** Error: (qverilog-13069) test.sv(22): near "";"": syntax error, unexpected ';', expecting '('.
","Only datatypes can be parameterized as types. 

You could use this little known feature of Verilog that all function call names search upwards

 module A;
    int flag = 0;
    function int get_flag(); return flag; endfunction
 endmodule

  module B;
    int flag = 1;
    function int get_flag(); return flag; endfunction
  endmodule

  module C;
    int flag = 2;
    function int get_flag(); return flag; endfunction
  endmodule

  module Bind #(parameter type T=A);
    initial begin
      $display(""flag = %0d"",get_flag);
    end
  endmodule

  module tb;
    A aa();
    bind A Bind# u_bound();
  endmodule
",,,,,
"I am executing several fork-joins concurrently,I want one statement skipped in a fork join block if it got executed in any of the other fork joins","lets say I have a code like this:

for (int i=o;i&lt;5;i++) begin
automatic int j=i;
fork
thread(i);
join_none
end 


suppose thread is like this:
thread()
    begin
    statement 1;
    statement 2;
    statement 3;
end

My issue is suppose if statement 2 got executed in the first fork join block then it has to be skipped in the remaining 4 fork join blocks.
Would you be able to tell me a solution on how to implement statement 2.
Thank you.","You should pass j to your thread instead of i.

for (int I=0;i&lt;5;i++) begin
   automatic int j=i;
   fork
     thread(j);
   join_none
  end 
task thread (int n);
    statement 1;
    if (n==0) statement 2;
    statement 3;
endtask


This does exactly what you asked in the body of your question, but does not match the title. In that case, you would need a semaphore

   semaphore flag;
   flag.new(1);
   for (int i=0;i&lt;5;i++) begin
       automatic int j=i;
       fork
         thread(j);
       join_none
      end
      ...
      task thread (int n);
       static bit flag;
            statement 1;
            if (flag.try_get()) statement 2;
            statement 3;
        endtask
",,,,,
What environment architecture to choose to verify multi-interface module,"I'm going to test complex module which have axi4-stream and apb interfaces as inputs and axi4 interface as output.
As I understand, I should build this kind of environment:

                                      |-----------------------------------------------
                                      |                                              |
                             _________|_________           _______________     ______v______
                            |                   |         |               |    |            |
                            |   APB-monitor     |         | AXI4-monitor  |---&gt;|            |
                            |___________________|         |_______________|    |            |
                                       |                          |            |            |
 ____________        ______________    |     _________            |            |            |
|            |      |              |   |    |         |           |            |            |
| APB-seqr   |-----&gt;| APB-master   |---*---&gt;|         |           |            |            |
|____________|      |______________|        |         |           |            |            |
                                            |   DUT   |           |            |            |
 ____________        ______________         |         |-----------*-----------&gt;| Scoreboard |
|            |      |              |        |         |                        |            |
|AXI4-S-seqr |-----&gt;|AXI4-S-master |---*---&gt;|         |                        |            |
|____________|      |______________|   |    |_________|                        |            |
                                       |                                       |            |
                                       |                                       |            |
                             --------------------                              |            |
                            |                    |                             |            |
                            |   AXI4-S-monitor   |----------------------------&gt;|            |
                            |____________________|                             |____________|


Is it correct? If so, how should I send transactions from monitors to scoreboard? I guess I should use analysis_port/imp pair but I can't overload write method in scoreboard class, so as I understand, I can't use three analysis ports in one class.
Can anyone point me to uvm example of such a complex design?
Currently I have this type of error when try to use analysis ports:

#    Time: 0 ps  Iteration: 0  Region: /uvm_pkg::uvm_analysis_imp #(axi4_s_pkg::axi4_s_seq_item, ecaa_pkg::ecaa_scoreboard) File: D:/questasim64_10.4c/win64/../verilog_src/uvm-1.1d/src/uvm_pkg.sv
# ** Error: (vsim-8754) D:/questasim64_10.4c/win64/../verilog_src/uvm-1.1d/src/tlm1/uvm_analysis_port.svh(114): Actual input arg. of type 'class work.axi4_s_pkg::axi4_s_seq_item' for formal 'trans' of 'write' is not compatible with the formal's type 'class work.apb_pkg::apb_seq_item #(3, 2, 32, 32, 4)'.```
","Here are two ways of solving your problem.

1. The Easy Way (Using `uvm_analysis_imp_decl Macros)

Simply invoke the macro outside of the component class for each input. The macro declares a special flavour of analysis imp. The argument passed to the macro is used as a suffix within the type name of the imp and the name of the write method. You then instantiate one imp per input and define one method per input. eg:

`uvm_analysis_imp_decl(_AXI4_S)
`uvm_analysis_imp_decl(_AXI4)
`uvm_analysis_imp_decl(_APB)

class scoreboard extends uvm_scoreboard;

  uvm_analysis_imp_AXI4_S #(AXI4_S_xact, scoreboard) AXI4_S_export;
  uvm_analysis_imp_AXI4   #(AXI4_xact,   scoreboard) AXI4_S_export;
  uvm_analysis_imp_APB    #(APB_xact,    scoreboard) APB_export;
  ...
  function void build_phase(uvm_phase phase);
    AXI4_S_export = new(""AXI4_S_export"", this);
    AXI4_export   = new(""AXI4_export"",   this);
    APB_export    = new(""APB_export"",    this);
  endfunction
  ...
  function void write_AXI4_S(AXI4_S_xact t);
    ...
  endfunction

  function void write_AXI4(AXI4_xact t);
    ...
  endfunction

  function void write_APB(APB_xact t);
    ...
  endfunction
  ...


2. The Hard Way (Embedded Subscribers) 

Instantiate three subscribers inside your scoreboard. Each is a separate scope, so each can have its own write method.",,,,,
How to specify height of waveform in Modelsim/Questasim?,"I'm using QuestaSim 70.7b;
And I can not change the height of waveform signal.. 
I've tried many options, like this:

add wave -radix hex -format analog-step -scale 100 -height 100 -color gold /bin_top_tb/clk 


But nothing happen, just height of the name signal is changed, like shown below



*thanks to dave_59, to change the height you should go to Tools -> Edit Preferences and change WaveFont and then footerFont exactly at such sequence, then click apply and ok. ","There's no way to change the height of individual digital signal. You use the main preferences to select a larger Wave Window text font, and the size of the waveform gets scaled to match the wave label. ",,,,,
How to compare two circuits based on their utilization,"I have some hardware IPs that I need to synthesize. And the IP contains several generic parameters I can play with. Each combination of parameters gives me a different utilization report after synthesis and implementation.

So for example for two different configurations Design_1 and Design_2, I get the following in Vivado 2018.1. The 3rd line is the ratio of the values of Design_2 devided by values of Design_1.

So as you can see in this simple example, Design_2 has less Slice LUTs but slightly more F7 Muxes.

My question is how to conclude about the cost of each one? Should I privilege Slice LUTs or Registers ...etc?

+----------+-------------------+-----------------+------------------+----------+-------------------+-------------------+---------------+---------------------+----------------+------+------------+--------------+-------------+------------+----------+---------+------------+---------+---------------------------+-------------------------+-----------------------------+--------+--------+----------+---------+------------+-----------+---------+--------+---------+---------+-----------+----------+-----------+-------------+---------+----------+-----------+---------+
|   Name   |    Slice LUTs     | Slice Registers |     F7 Muxes     | F8 Muxes |       Slice       |   LUT as Logic    | LUT as Memory | LUT Flip Flop Pairs | Block RAM Tile | DSPs | Bonded IOB | Bonded IPADs | PHY_CONTROL | PHASER_REF | OUT_FIFO | IN_FIFO | IDELAYCTRL | IBUFDS  | PHASER_OUT/PHASER_OUT_PHY | PHASER_IN/PHASER_IN_PHY | IDELAYE2/IDELAYE2_FINEDELAY | ILOGIC | OLOGIC | BUFGCTRL |  BUFIO  | MMCME2_ADV | PLLE2_ADV | BUFMRCE | BUFHCE |  BUFR   | BSCANE2 | CAPTUREE2 | DNA_PORT | EFUSE_USR | FRAME_ECCE2 | ICAPE2  | PCIE_2_1 | STARTUPE2 |  XADC   |
+----------+-------------------+-----------------+------------------+----------+-------------------+-------------------+---------------+---------------------+----------------+------+------------+--------------+-------------+------------+----------+---------+------------+---------+---------------------------+-------------------------+-----------------------------+--------+--------+----------+---------+------------+-----------+---------+--------+---------+---------+-----------+----------+-----------+-------------+---------+----------+-----------+---------+
| Design_1 |             34124 |           16913 |             1453 |       91 |             10272 |             31538 |          2586 |                9020 |             37 |   11 |        125 | 0            |           1 |          1 |        4 |       2 |          1 | 0       |                         4 |                       2 |                          16 |     16 |     46 |       10 | 0       |          2 |         2 | 0       |      2 | 0       |       4 | 0         | 0        | 0         | 0           | 0       | 0        | 0         | 0       |
| Design_2 |             34097 |           16913 |             1550 |       91 |             10189 |             31511 |          2586 |                9021 |             37 |   11 |        125 | 0            |           1 |          1 |        4 |       2 |          1 | 0       |                         4 |                       2 |                          16 |     16 |     46 |       10 | 0       |          2 |         2 | 0       |      2 | 0       |       4 | 0         | 0        | 0         | 0           | 0       | 0        | 0         | 0       |
| -------- |                   |                 |                  |          |                   |                   |               |                     |                |      |            |              |             |            |          |         |            |         |                           |                         |                             |        |        |          |         |            |           |         |        |         |         |           |          |           |             |         |          |           |         |
| (2)/(1)  | 0.999208768022506 |               1 | 1.06675843083276 |        1 | 0.991919781931464 | 0.999143889910584 |             1 |    1.00011086474501 |              1 |    1 |          1 | #DIV/0!      |           1 |          1 |        1 |       1 |          1 | #DIV/0! |                         1 |                       1 |                           1 |      1 |      1 |        1 | #DIV/0! |          1 |         1 | #DIV/0! |      1 | #DIV/0! |       1 | #DIV/0!   | #DIV/0!  | #DIV/0!   | #DIV/0!     | #DIV/0! | #DIV/0!  | #DIV/0!   | #DIV/0! |
+----------+-------------------+-----------------+------------------+----------+-------------------+-------------------+---------------+---------------------+----------------+------+------------+--------------+-------------+------------+----------+---------+------------+---------+---------------------------+-------------------------+-----------------------------+--------+--------+----------+---------+------------+-----------+---------+--------+---------+---------+-----------+----------+-----------+-------------+---------+----------+-----------+---------+
","It's depending on your needs, LUTs and F7 Muxes are differents physical cells in your FPGA. So even if you don't use its, its will be there.

If you have one ressource more critical than the other, you should try to minimize the utilisation of the critical ressource to simplify the place and route.

If you have nothing critical, I think the better is to use F7 Muxes first because Slice LUTs are more flexible for the rest of your design.",,,,,
Pausing/restarting a sequence,"I have a design that requires a pause in data traffic to enter a low power mode. Is there a way to pause the traffic generation sequence or driver to allow this happen? And then resume the sequence at a later time?

I currently have a flag in the sequence that I set to tell it to break the forever loop. However, that is not ideal, because the sequence finishes and then I have to restart it.","You could lock (or grab the sequencer) from a virtual sequence, eg: 

class virtual_seq extends uvm_sequence;

  `uvm_object_utils(virtual_zero_seq)
  `uvm_declare_p_sequencer(virtual_sequencer)

  function new(string name = """");
    super.new(name);
  endfunction: new

  task body;
    // start the normal traffic sequence
    normal_traffic_seq seq;
    seq = serial_fixed_seq::type_id::create(""seq"");
    if (! seq.randomize() ...
    seq.set_starting_phase(get_starting_phase());
    seq.start(p_sequencer.seqr, this);

    // when you're ready, lock the sequencer
    #12345;
    this.lock(p_sequencer.seqr);   // or grab

    // wait till you're ready to resume
    #12345; 
    // you could start another sequence on the same sequencer if you need to
    // if you do, you must input the reference to this virtual sequence in 
    // the sequence's start method, otherwise that sequence will be locked too
    // eg
    // power_down_seq.start(p_sequencer.seqr, this);
    //                                        ^^^^

    // when you're ready, start normal traffic again
    this.unlock(p_sequencer.seqr);   // or ungrab
  endtask : body

endclass : virtual_zero_seq


A grab is a higher priority lock. If multiple virtual sequences try to lock a sequencer, then they will gain access in the order they request it. If multiple virtual sequences try to grab a sequencer, if it is already locked (or grabbed), those virtual sequences will gain access to it on a last come first served basis.",,,,,
Why does Quartus throw an error at my if-statement?,"I'm learning VHDL at the moment.
This may be a dumb question, but what is the problem with this process?

&quot;Error (10500): VHDL syntax error at invent_a_chip.vhdl(132) near text &quot;'&quot;;  &gt;expecting &quot;(&quot;, or an identifier, or  unary operator&quot;
Error (10500): VHDL syntax error at invent_a_chip.vhdl(134) near text &quot;'&quot;;  &gt;expecting &quot;(&quot;, or an identifier, or  unary operator

signal count  , count_nxt   : unsigned(29 downto 0);

...

process(switch, count)
    begin
    if switch(17) = '1' then
        count &lt;= '1000000000';
    else
        count &lt;= '100000';
    end if;
end process;

Edit: Lines 132 and 134 are the lines with count &lt;= '1000000000'; and count &lt;= '100000';.","count must get a value in double quotes (not single), and exactly with 30 bits (numbers), not less!",,,,,
Can a sequential always block be triggered by a short pulse from a combi block,"Could a sequential always block be triggered by a short lived pulse coming from a combi block ?

I have tried to trigger the always block, by assigning a value and set the value back to 0 in an attempt to trigger the sequential always block but to no avail, below is the pseudo code


always_comb begin
 ...some code...
pulse_trigger = 1;
load_var= driver_var // assigning some values
pulse_trigger = 0;
 ...some code...
end

always @(pulse_trigger)begin
 ...some code part 2...
end



I expect by assigning 1 to pulse_trigger the ""always@(pulse_trigger)"" block to get activated, but in my VCS simulation this does not seem to be the case. 

Maybe this is because the pulse trigger is assigned 1 and unassigned 1 in the same combi block, which takes 0 simulation time, so pulse_trigger might not appear to have changed values. Or this method should've triggered ""always@(pulse_trigger)"" and executed ""...some code part 2.."", because I am looking at the wrong values ?","In verilog simulation only a single always block can be evaluated at a time. So, until your always_comb finishes, no other always block can be evaluated. Therefore, no pulse_trigger change will be detected by simulation (because all changes happen inside  a single always block. 

You can do something like that by adding delays (assuming this is not a synthesizable code):

always @* begin
  pulse_trigger = 1;
  load_var= driver_var // assigning some values
  #1 // &lt;&lt; this will stop execution of the block for 1 time unit and allow others.
  pulse_trigger = 0;
end


However, the above code is not synthesizable but it can be a part of a test bench. 
Also, it is not allowed within always_comb.",,,,,
How do I write this For loop in Verilog,"So, I have this error while writing a Verilog file and since I haven't used FOR loops so far I don't really know how to solve this.

Here is the portion of the code:

for(counter=0;counter=counter+25000000;counter=counter+1)
begin
    out_leds&lt;=3'b111;
end


Here are the errors:


  Error (10170): Verilog HDL syntax error at LEDS.v(20) near text ""=""
  
  Error (10170): Verilog HDL syntax error at LEDS.v(20) near text "")"";
  expecting "";""
","Your for condition has not a comparator. You must write for(counter=0; counter == counter+.... 

counter = counter + 25000000 is an assignment of the new value to counter.

counter == counter + 25000000 is a statement that checks, if counter is the same as counter+25000000`

But also this is a infinite loop, as counter is never equal to counter+25000000.

You can create a variable x = counter + 25000000 and then use this variable in your loop: for(counter=0; counter==x; counter=counter+1)

See e.g. here",,,,,
Why xilinx use a pointer to store data as array?,"I take a look at the AXI-DMA example from xilinx and I get stuck at this point in XAxiDma_SimplePollExample

for(Index = 0; Index &lt; MAX_PKT_LEN; Index ++) {
        TxBufferPtr[Index] = Value;

        Value = (Value + 1) &amp; 0xFF;
}


The variable TxBufferPtr is a pointer, pointing on the memory address TX_BUFFER_BASE

u8 *TxBufferPtr;
TxBufferPtr = (u8 *)TX_BUFFER_BASE ;


Why do they use a pointer to store data with a loop? I have learned, that I should use an array to initialize the memory and use the start address of this array. So my example will look like this

u8 TxBufferPtr[MAX_PKT_LEN];
for(Index = 0; Index &lt; MAX_PKT_LEN; Index ++) {
        TxBufferPtr[Index] = Value;

        Value = (Value + 1) &amp; 0xFF;


How do xilinx avoid that other data may be placed in range of the pointer address + the loop range, so that the loop will overwrite this data?
Is there any trick when I use this or is it just ""bad"" code and use of pointer?","There is a huge difference between the two code examples.

Your code, i.e. 

u8 TxBufferPtr[MAX_PKT_LEN];


will allocate memory for the array. This will be MAX_PKT_LEN u8 typically reserved on a stack.

This code:

u8 *TxBufferPtr;
TxBufferPtr = (u8 *)TX_BUFFER_BASE ;


does not allocate memory for the array. The code assumes that TX_BUFFER_BASE is the address of some memory that has already been allocated/reserved for the program. 

If you are on some embedded system without MMU it can be a direct memory mapped region to some HW component inside the FPGA. In small simple embedded systems it's normal to map HW components using pointers to fixed addresses. The FPGA designer will give you the value of TX_BUFFER_BASE as it is the FPGA designer that decides how the memory space will be used.",,,,,
How to split the 8 bit input into two 4 bit data,"I'm writing a code for QPSK modulation in VHDL. I need to split the 8 bit input  data into odd and even bits and each bit is replicated How can i do it. 

for example if my input is 11001001 then  odd and even bits are odd= 1010  even =1001 my output should be like odd= 11001100 and even is 11000011","Use the concatenation operator '&amp;':

dbl_odds  &lt;=  v(7) &amp; v(7) &amp; v(5) &amp; v(5) &amp; v(3) &amp; v(3) &amp; v(1) &amp; v(1);
dbl_evens &lt;=  v(6) &amp; v(6) &amp; v(4) &amp; v(4) &amp; v(2) &amp; v(2) &amp; v(0) &amp; v(0);
",,,,,
How to fix infinite run time when VVP start simulation?,"this verilog code for Multiplier 4x4 have a serious problem when simulation starts using vvp.i am totally confused and can not understand where should i put an end statement that finish the simulation?

`timescale 1ns / 1ps
 module mult_4x4(
     input reset,start, 
     input[3:0] A,B, 
     output [7:0] O, output Finish
         );
reg [7:0] O;
wire Finish;  
wire Phi0,Phi1;// 2 phase clocking
wire m1,m2,m3,m4;
// state machine
reg[3:0] State;
// Accumulator
reg [8:0] ACC; // Accumulator
// logic to create 2 phase clocking when starting
nand u0(m1,start,m2);
buf #20 u1(m2,m1);
buf #10 u2(Phi0,m1);// First phase clocking
not #2 u5(m4,Phi0);
assign m3=~m1; 
and #2 u4(Phi1,m3,m4);// Second phase clocking
assign Finish = (State==9)? 1'b1:1'b0; // Finish Flag
// FSM
always @(posedge Phi0 or posedge Phi1 or posedge reset)
begin
if(reset) begin
State &lt;= 0; 
ACC &lt;= 0; 
O &lt;= 0; 
end
 else if((Phi0==1'b1) || (Phi1==1'b1)) begin // 2 phase clocking
 if(State==0)
 begin
 ACC[8:4] &lt;= 5'b00000; // begin cycle
 ACC[3:0] &lt;= A; // Load A
 State &lt;= 1;
 end
 else if(State==1 || State == 3 || State ==5 || State ==7) 
                // add/shift State
 begin
 if(ACC[0] == 1'b1) begin // add multiplicand
 ACC[8:4] &lt;= {1'b0,ACC[7:4]} + B; 
 State &lt;= State + 1;
 end
 else
 begin
 ACC &lt;= {1'b0,ACC[8:1]};// shift right
 State &lt;= State + 2;
 end
 end
 else if(State==2 || State == 4 || State ==6 || State ==8) 
                // shift State
 begin
 ACC &lt;= {1'b0,ACC[8:1]}; // shift right
 State &lt;= State + 1;
 end 
 else if(State == 9) begin
  State &lt;= 0;
 O &lt;= ACC[7:0]; 
 end
 end
 end 

endmodule

// TestBench
module test();
// signals
 reg start,reset;
 reg[3:0] A,B;
 // Outputs
 wire [7:0] O;
 wire Finish;
// device under test
mult_4x4 dut(reset,start, A,B,O,Finish);
initial begin
reset=1; // reset
#40 start = 0;A =14; B= 11;
#400 reset = 0; 
#40 start = 1; // start

end 

endmodule


after running this code,simulating never stop and when you press control+c (in cmd) it shows this message:
** VVP Stop(0) **
** Flushing output streams.
** Current simulation time is 56484472000 ticks.","i forgot to add :

@(posedge finish);
$finish;

in the end of my code...",,,,,
Generate clocks with ratio for testbench,"I want to generate a test stimulus for my I2S demux module. The stimulus contains values from an ADC measurement. The I2S standard provides two clocks: LRCLOCK and BITCLOCK. In my case LRCLOCK has a frequency of 48kHz (which is also the sample rate) and BITCLOCK is 64*LRCLOCK which results in a clock of 3.072MHz.

When creating the clocks in the testbench, there is always a offset between the LRCLOCK and the BITLCOCK. And I can't explain where this offset is coming from.

I tried to create a clock generation procedure according to this post: VHDL - How should I create a clock in a testbench?

Both suggested solutions show the same behaviour.
I work with VIVADO 2016.4, the simulator has a resolution of 1ps

Procedure:

procedure clk_gen(signal clk : out std_logic; constant FREQ : real) is
    constant PERIOD    : time := 1 sec / FREQ;        -- Full period
    constant HIGH_TIME : time := PERIOD / 2;          -- High time
    constant LOW_TIME  : time := PERIOD - HIGH_TIME;  -- Low time; always &gt;= HIGH_TIME
  begin
    -- Check the arguments
    assert (HIGH_TIME /= 0 fs) report ""clk_plain: High time is zero; time resolution to large for frequency"" severity FAILURE;
    -- Generate a clock cycle
    loop
      clk &lt;= '1';
      wait for HIGH_TIME;
      clk &lt;= '0';
      wait for LOW_TIME;
    end loop;
  end procedure;


Clock assignment:

process
    begin
        i2s_lrclock &lt;= '1';
        wait until reset /= '1';
        clk_gen(i2s_lrclock,48.0e3);
   end process;

 process
   begin
       i2s_bitclock &lt;= '1';
       wait until reset /= '1';
       clk_gen(i2s_bitclock,48.0e3*64);
  end process;


I expect the edges of both clocks to be synchronous but there is an offset of 26ps from the i2s_bitclock to i2s_lrclock.","A 3.072MHz clock has a period of 325.5208333... ns, the simulator has to trunk the period somewhere, and it's probably not on the same digit for your other clock.

Try something like that :

signal i2s_lrclock   : std_logic := '0';
signal i2s_bitclock  : std_logic := '0';

begin

  i2s_lrclock   &lt;= not(i2s_lrclock) after 10416640 ps;  -- 64 * 325.520 ns / 2
  i2s_bitclock  &lt;= not(i2s_bitclock) after 162760 ps ;  -- 325.520 ns / 2


Real value of clocks in simulation is not very important. Ratio between them is.",,,,,
"I'd like to display the segment according to differnet clocks, but I can't","stick shape is fixed to the left of the segment and dot segment want to be displayed separately according to the clock. But at the same time, it's displayed
this is an example pic https://imgur.com/LXGVUJO

++)) i want like this pic https://imgur.com/mco1q7P

    library ieee;
  use ieee.std_logic_1164.all;

 entity adventure is
port(clk : in std_logic;
     dot_seg : out std_logic;
     select_seg : out std_logic_vector(7 downto 0);
     player_in : in std_logic_vector(1 downto 0);
     seg : out std_logic_vector(6 downto 0));

  end adventure;

  architecture behavior of adventure is
    signal dot_clk : std_logic;
    signal player_clk : std_logic;
  begin
    process(clk)                
     variable dot_cnt : integer := 0;
     variable player_cnt : integer := 0;
   begin
    if rising_edge(clk) then        
        if dot_cnt &gt;= 5000000 then  -- dot_seg clk
            dot_cnt := 0;
            dot_clk &lt;= not dot_clk;
        else
            dot_cnt := dot_cnt + 1;
        end if;

        if player_cnt &gt;= 50005 then -- player_seg clk
            player_cnt := 0;
            player_clk &lt;= not player_clk;
        else
            player_cnt := player_cnt + 1;
        end if;

    end process;

process(clk, dot_clk, player_clk)       
begin

    if player_clk = '1' then        -- player 
        case player_in is                       
            when ""00"" =&gt; seg &lt;= ""1000110"";
            when ""01"" =&gt; seg &lt;= ""1000011"";
            when ""10"" =&gt; seg &lt;= ""0010101"";
            when ""11"" =&gt; seg &lt;= ""1000110"";
        end case;
        select_seg &lt;= ""01111111"";
    end if;

    if dot_clk = '1' then       -- dot(road) segment
        dot_seg &lt;= '1';                ---- put in seg &lt;= ""0000000""; ???
        select_seg &lt;= ""01011111"";
    else
        dot_seg &lt;='1';                 ---- put in seg &lt;= ""0000000""; ???
        select_seg &lt;= ""10101111"";
    end if;


end process;
 end behavior;
","Try something like that for your second process

signal digit_display : std_logic := '0';

process(clk)       
begin

    if rising_edge(clk) then

      digit_display &lt;= not(digit_display);

      if digit_display = '1' then

        dot_seg &lt;= '0';

        if player_clk = '1' then        -- player 
          case player_in is                       
            when ""00"" =&gt; seg &lt;= ""1000110"";
            when ""01"" =&gt; seg &lt;= ""1000011"";
            when ""10"" =&gt; seg &lt;= ""0010101"";
            when ""11"" =&gt; seg &lt;= ""1000110"";
            select_seg &lt;= ""01111111"";
          end case;
        end if;

      else

        seg &lt;= ""0000000""; -- Full off, I don't know polarity

        if dot_clk = '1' then       -- dot(road) segment
          dot_seg &lt;= '1';
          select_seg &lt;= ""01011111"";
        else
          dot_seg &lt;='1';
          select_seg &lt;= ""10101111"";
        end if;

      end if;

    end if;

end process;


If clk is too fast to blink digit_display, you can put a counter like that :

signal digit_display_count : unsigned(15 downto 0) := (others =&gt; '0');

if digit_display_count = 100 then -- Choose an appropriate value
  digit_display       &lt;= not(digit_display);
  digit_display_count &lt;= (others =&gt; '0')
else
  digit_display_count &lt;= digit_display_count + 1;
end if;
",,,,,
Is there a way to monitor the state of an internal signal with a University Program VWF in Quartus 13.1?,"I have a VHDL finite statemachine. I created a internal TYPE akin to TYPE t_SM_Main IS (s_Idle, s_Start, s_TX1, s_TX0, s_Cleanup); I have also created a University Program VWF inside Quartus for the simulated response of my VHDL code. 

Is it possible to have a signal that is defined inside the ARCHITECTURE be visible to the simulator without it being exported using the ENTITY PORT map? (which would also pose a problem because the TYPE definition needs to precede the PORT definition.)

Another way of phrasing it is that I'm wondering if there is a way to see the ENTITY not as a black box but as a white box.

I'm using Quartus II 64-bit 13.1 without any newer revisions of VHDL enabled.

update
Seeing as variable is a better option as per the ""â€™two-processâ€?design method"". Is it possible to get the state of a variable inside a University Program VWF?","In a Simulation Waveform Editor select:


Edit > Insert Node or Bus





Node Finder...





in a new window that popÄ™d up, change Filter to Design Entry (all names) (default: Pins: all)





list signals and choose those that you want to analyze.


Pictures taken from Quartus II Tutorial",,,,,
VHDL Pre-loading RAM Memory with MIF File,"I am trying to implement memory in VHDL and when testing it on the DE2 board I want to preload the memory with generated values. I first tried doing this by reading from a text file, but that did not work because one cannot load a text file onto the FPGA board. So I turned to mif files. However, I do not know how to get vhdl/quartus ii to associate the MIF file I generated with the RAM I created. 

I also tried using a 1-port RAM LPM, but because it clocks the reading as well as the writing and this causes it to not provide the data fast enough to be useful. 

Below is the code for the RAM I created:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.textio.all;

entity instruction_memory is
    port (
        input_address : in std_logic_vector(31 downto 0);
        opcode : out std_logic_vector(31 downto 0)
    );
end instruction_memory;

architecture archInstruction_Memory of instruction_memory is
    subtype word_t  is std_logic_vector(31 downto 0);
    type    ram_t   is array(0 to 4095) of Reichman_word_t;

    impure function ReadMemFile(FileName : STRING) return ram_t is
        file FileHandle       : TEXT open READ_MODE is FileName;
        variable CurrentLine  : LINE;
        variable TempWord     : bit_vector(31 downto 0);
        variable Result       : ram_t    := (others =&gt; (others =&gt; '0'));

        begin
           for i in 0 to 4095 loop
                exit when endfile(FileHandle);
                readline(FileHandle, CurrentLine);
                read(CurrentLine, TempWord);
                Result(i) := to_stdlogicvector(TempWord);
            end loop;

            return Result;
        end function;

        signal ram    : ram_t    := ReadMemFile(""instructions_memory.txt"");
        attribute ram_init_file : string;
        attribute ram_init_file of ram : signal is ""instructions_memory.mif"";


begin 
    opcode &lt;= ram(to_integer(unsigned(input_address(31 downto 0))));
end archInstruction_Memory;


How can I get it preload the data in the .mif file so when I test it on the DE2 board it shows that it uses those values?","I'm using a tcl script to translate binary data (code) into a VHDL constant that can be used to generate a ROM: 

package require cmdline

post_message ""embed_m68k.tcl""

exec /bin/bash -c ""(cd m68k; make)""
set binfile m68k/simple.bin
set fp [open $binfile r]
fconfigure $fp -translation binary
set bindata [read $fp]
close $fp

set filename simple.vhd

set date [clock format [clock seconds] -format { %a, %Y-%m-%d, %H:%M }]
set file [open $filename w]
set script [info script]

puts $file ""library ieee;""
puts $file ""use ieee.std_logic_1164.all;""
puts $file """"
puts $file ""    -- VHDL representation of $binfile""
puts $file ""    -- generated by $script on $date""
puts $file ""    -- m68k executable as preloaded RAM contents""
puts $file """"
puts $file ""package m68k_binary is""
puts $file ""    subtype ubyte is std_logic_vector(7 downto 0);""
puts $file ""    type ubyte_array is array (natural range &lt;&gt;) of ubyte;""
puts $file """"
puts $file ""    constant m68k_binary    : ubyte_array :=""
puts $file ""    (""
puts -nonewline $file ""        ""
set len [string length $bindata]
for {set i 0} {$i &lt; $len} {incr i} {
    set char [string index $bindata $i]
    binary scan $char H2 byte
    puts -nonewline $file ""x\""""
    puts -nonewline $file $byte
    puts -nonewline $file ""\""""
    if { ! ([expr $i + 1] == $len) } {
        puts -nonewline $file "", ""
    }
    if { [expr ($i + 1) % 8] == 0 } {
        puts $file """"
        puts -nonewline $file ""        ""
    }
}
puts $file """"
puts $file ""    );""
puts $file ""end package m68k_binary;""
close $file


You can easily include the script into your Quartus workflow using the PRE_FLOW_SCRIPT_FILE variable in your .qsf:

set_global_assignment -name PRE_FLOW_SCRIPT_FILE ""quartus_sh:precmd.tcl""


The PRE_FLOW_SCRIPT_FILE will then automatically be executed at the beginning of the synthesis process. Just include the generated .vhd file into your project.",,,,,
Connection from many port(in different agents) to one export (in scoreboard),I have a many(port) to one(export) situation with my agents and the scoreboard. My doubt is how will I make sure that only one out of the many ports can write into the export at an instant of time so that I don't get any complications or lost transactions. any help/advice is appreciated. Thank you,"As you mentioned, the ports are called 'serially' so you shouldn't have any lost transactions. Whenever the monitor in the agent is ready to broadcast, it'll call the port write function to which the scoreboard is a subscriber.

However, I don't think there's any guarantee in which order the port write functions are called, so you may still have complications depending on what you're trying to achieve.",,,,,
How to fix long compilation for Verilog HDL in quartus,"I've been trying to create a counting sort algorithm using Verilog HDL, but when I tried to compile this iteration of it, Quartus started to compile it for a really long time. I can't figure out what is the issue.

module sort(reset, clk, data_in0,data_in1,data_in2,data_in3,data_in4,data_in5,data_in6,data_in7,data_in8,data_in9, data_out0, data_out1, data_out2, data_out3, data_out4, data_out5, data_out6, data_out7, data_out8, data_out9);

input wire reset, clk;

input wire [1:0] data_in0;

input wire [1:0] data_in1;

input wire [1:0] data_in2;

input wire [1:0] data_in3;

input wire [1:0] data_in4;

input wire [1:0] data_in5;

input wire [1:0] data_in6;

input wire [1:0] data_in7;

input wire [1:0] data_in8;

input wire [1:0] data_in9;

output reg [1:0] data_out0;

output reg [1:0] data_out1;

output reg [1:0] data_out2;

output reg [1:0] data_out3;

output reg [1:0] data_out4;

output reg [1:0] data_out5;

output reg [1:0] data_out6;

output reg [1:0] data_out7;

output reg [1:0] data_out8;

output reg [1:0] data_out9;

reg [1:0] mem [9:0];


reg[9:0] buff [3:0];
integer i,k,j,f,s;

always@ (posedge clk)

begin

    for(i=0; i&lt;4; i=i+1)
    buff[i]&lt;=0;
    if (reset == 1) begin

    for (i = 0; i &lt; 10; i = i + 1) mem[i]&lt;=0;
    s=0;
    f=0;


end

else begin
if (f==0)begin
mem [0] &lt;= data_in0;
mem[1]&lt;=data_in1;

mem[2]&lt;=data_in2;

mem[3]&lt;=data_in3;

mem[4]&lt;=data_in4;

mem[5]&lt;=data_in5;

mem[6]&lt;=data_in6;

mem[7]&lt;=data_in7;

mem[8]&lt;=data_in8;

mem[9]&lt;=data_in9;
f=1;
end
 for( i = 0; i &lt;10 ; i=i+1)
begin
    buff[mem[i]]&lt;=buff[mem[i]]+1;
end
if(s==0) begin
k&lt;=0;
    for( i = 0; i &lt;4 ; i=i+1)
    begin
        for( j = 0; j &lt; 10 ; j = j +1)
        begin
            if(j&lt;buff[i])
            begin
                mem[k]&lt;=i;
                k&lt;=k+1;
            end
        end
    end

end     s=1;    

data_out0 = mem[0];

data_out1 = mem[1];

data_out2 = mem[2];

data_out3 = mem[3];

data_out4 = mem[4];

data_out5 = mem[5];

data_out6 = mem[6];

data_out7 = mem[7];

data_out8 = mem[8];

data_out9 = mem[9];

end

end

endmodule


It takes a really long time to pass the Analysis and Synthesis section. I assume it is due to mistakes in this code or the wrong use of operators, but I can't understand where it is exactly.","This is an example of how a FSM-based solution for your problem would be. It can be vastly improved, though, but it's just a starting (and hopefully working) point.

For start, I've changed your module interface. Discrete inputs can be used, but as the algorithm uses indexes to run over the entire input domain, I've assume two external memories: one with the input data and another one which will hold the output data. The module drives the corresponding address bus for both memories, as well as the write enable signal, and data buses. There is also a busy signal so the rest of the system knows that the module has not yet finished sorting data. Finally, I've sorted 16 numbers instead of 10.

Internally, I've used a memory element, count, as the vector that holds the histogram of the input data. As this memory is tiny, I've used as four independent registers. This allows me to use more than one element of ""count"" in the same clock cycle, as in count[3] &lt;= count[3] + count[2] + count[1] + count[0];

The version of the algorithm I've used is from Wikipedia:
https://en.wikipedia.org/wiki/Counting_sort

function countingSort(array, k) is
  count â†?new array of k zeros
  for i = 1 to length(array) do
    count[array[i]] â†?count[array[i]] + 1
  for i = 2 to k do
    count[i] â†?count[i] + count[i - 1]
  for i = length(array) downto 1 do
    output[count[array[i]]] â†?array[i]
    count[array[i]] â†?count[array[i]] - 1
  return output


And this is the Verilog module:

module sort (
  input wire clk,
  input wire reset,
  output reg [3:0] addr_data_in,
  input wire [1:0] data_in,
  output reg [3:0] addr_data_out,
  output reg [1:0] data_out,
  output reg write_data_out_strobe,
  output reg busy
);

/*
function countingSort(array, k) is
  count â†?new array of k zeros
  for i = 1 to length(array) do
    count[array[i]] â†?count[array[i]] + 1
  for i = 2 to k do
    count[i] â†?count[i] + count[i - 1]
  for i = length(array) downto 1 do
    output[count[array[i]]] â†?array[i]
    count[array[i]] â†?count[array[i]] - 1
  return output
*/
  localparam
    ZERO         = 3'd0,
    MAKEHIST1    = 3'd1,
    MAKEHIST2    = 3'd2,
    PREFIXSUM    = 3'd3,
    PLACEOUTPUT1 = 3'd4,
    PLACEOUTPUT2 = 3'd5,
    IDLE         = 3'd7
    ;

  reg [4:0] count[0:3];
  reg [2:0] state = IDLE;
  reg [1:0] data;

  always @(posedge clk) begin
    if (reset == 1'b1) begin
      state &lt;= ZERO;
      write_data_out_strobe &lt;= 1'b0;
      busy &lt;= 1'b1;
    end
    else begin
      case (state)
        ZERO:
        //count â†?new array of k zeros
          begin
            count[0] &lt;= 4'd0;
            count[1] &lt;= 4'd0;
            count[2] &lt;= 4'd0;
            count[3] &lt;= 4'd0;
            addr_data_in &lt;= 4'd0;
            state &lt;= MAKEHIST1;
          end
        MAKEHIST1:
        //for i = 1 to length(array) do
        //  count[array[i]] â†?count[array[i]] + 1
          begin
            data &lt;= data_in;
            addr_data_in &lt;= addr_data_in + 4'd1;
            state &lt;= MAKEHIST2;
          end
        MAKEHIST2:
          begin
            count[data] &lt;= count[data] + 4'd1;
            if (addr_data_in == 4'd0)
              state &lt;= PREFIXSUM;
            else
              state &lt;= MAKEHIST1;
          end
        PREFIXSUM:
        //for i = 2 to k do
        //  count[i] â†?count[i] + count[i - 1]
          begin
            count[1] &lt;= count[1] + count[0];
            count[2] &lt;= count[2] + count[1] + count[0];
            count[3] &lt;= count[3] + count[2] + count[1] + count[0];
            addr_data_in &lt;= 4'd15;
            state &lt;= PLACEOUTPUT1;
          end
        PLACEOUTPUT1:
        //for i = length(array) downto 1 do
        //  output[count[array[i]]] â†?array[i]
        //  count[array[i]] â†?count[array[i]] - 1
          begin
            data &lt;= data_in;
            addr_data_in &lt;= addr_data_in - 4'd1;
            write_data_out_strobe &lt;= 1'b0;
            state &lt;= PLACEOUTPUT2;
          end
        PLACEOUTPUT2:
          begin
            addr_data_out &lt;= count[data] - 5'd1;
            data_out &lt;= data;
            count[data] &lt;= count[data] - 4'd1;
            write_data_out_strobe &lt;= 1'b1;
            if (addr_data_in == 4'd15)
              state &lt;= IDLE;
            else
              state &lt;= PLACEOUTPUT1;
          end
        IDLE:
          begin
            write_data_out_strobe &lt;= 1'b0;
            busy &lt;= 1'b0;
          end
      endcase
    end  // of else
  end  // of always
endmodule


You can see that because of the way I'm using count, this will surely generate lots of muxes and decoders, just because I'm using a register value as the address for count[] in some places. However, I think this will synthesize much faster. Yosis can make it in a couple of seconds, FYI.

Besides, here you have a test bench for the above module:

module tb_counting_sort;
  reg clk, reset;
  wire [3:0] addr_data_in, addr_data_out;
  wire [1:0] data_in,data_out;
  wire write_data_out_strobe, busy;

  sort uut (
    .clk(clk),
    .reset(reset),
    .addr_data_in(addr_data_in),
    .data_in(data_in),
    .addr_data_out(addr_data_out),
    .data_out(data_out),
    .write_data_out_strobe(write_data_out_strobe),
    .busy(busy)
  );

  reg [1:0] vector_in[0:15];
  reg [1:0] vector_out[0:15];
  assign data_in = vector_in[addr_data_in];
  always @(posedge clk)
    if (write_data_out_strobe == 1'b1)
      vector_out[addr_data_out] &lt;= data_out;

  integer i;
  initial begin
    vector_in[0]  = 2'd2;
    vector_in[1]  = 2'd1;
    vector_in[2]  = 2'd0;
    vector_in[3]  = 2'd0;
    vector_in[4]  = 2'd3;
    vector_in[5]  = 2'd1;
    vector_in[6]  = 2'd0;
    vector_in[7]  = 2'd2;
    vector_in[8]  = 2'd1;
    vector_in[9]  = 2'd1;
    vector_in[10] = 2'd3;
    vector_in[11] = 2'd3;
    vector_in[12] = 2'd3;
    vector_in[13] = 2'd2;
    vector_in[14] = 2'd1;
    vector_in[15] = 2'd0;

    reset = 1'b1;
    clk = 1'b0;
    repeat (2) 
      @(posedge clk);
    reset = 1'b0;

    @(negedge busy);
    for (i=0;i&lt;16;i=i+1)
      $write (""%1d "", vector_out[i]);
    $display("""");
    $finish;
  end

  always begin
    clk = #5 ~clk;
  end
endmodule


Both modules can be viewed, simulated or synthesized at EDAPlayground, here:
https://www.edaplayground.com/x/6GLj",,,,,
"In VHDL, Can I use signal'event if signal is not a clock?","I am trying to clean up my VHDL code. I have a signal that is NOT a clk.

Can I write an event change monitor like the following and how do I get it to compile so it can be synthesized? (see code) I have tried several permutations but I cannot get it to compile. Will signal'event compile if signal is not a CLK and if so, how is it done? I see on the web and other literature that it can be done but all examples I see show CLK'event. 

signal cntr: unsigned(15 downto 0) := (others =&gt; '0');

...
process(CLK):
begin

IF rising_edge(CLK) THEN
    if (cntr'event) then
        do something;
    end if;
or...
    if(cntr(0)'event) then
        do something;
    end if;
END IF;
end process;


I get the following and others
: can't synthesize condition that contains an isolated 'EVENT predefined attribute","rising_edge(CLK) is already an event, making your design synchronous, which is good. As said in comments, only clock signals should use that.
Looking at another even at that time doesn't make sense in synchronous designs, as the 2 signals won't change exactly at the same time, creating a race condition. Or actually a clock within a clock, and the synthesis error...
It may work in simulation, but don't rely on that fact.
The normal way to program in HDL languages is to save the previous value of the signal, on the same clock (for example cntr_d &lt;= cntr) and to compare with that previous value. That allows to find if the signal went up (previously at 0, currently at 1), went down, changed (is different)...
And that method is perfectly fine for synthesis!",,,,,
Use dma transfert with Cyclone V Avalon-MM for PCIe,"Is it possible to do DMA transferts with the IP core Â«Cyclone V Avalon-MM for PCIeÂ» provided by altera in Qsys (quartus 14.0) ?

Altera provide an ip-core named Â«Cyclone V Avalon-MM DMA for PCIeÂ» to do dma transfert. But this ip-core does not support PCIe Gen1 with 1x lane.

The demo (ep_g1x1) design for Â«Cyclone V Avalon-MM for PCIeÂ» include a DMA block that is connected on Avalon-mm TX bus of PCIe ip-core.

Then I'm wondering if it's possible to write data from this DMA block to the root-complex (host) ? Because I can't find how to do that.","I finally managed to make DMA request with the Â«Cyclone V Avalon-MM for PCIeÂ» altera core-ip. Then yes it's possible.

On my Linux system, rootcomplex (RC)Â is included under i.MX6 with Linux operating system. Then most of the tricks are on the Linux side in fact.

Under the Linux driver a PAGE must be requested with dma_alloc_coherent() call and the address of this page must be written on the CRA register named ADDR_MAP_LO0Â and ADDR_MAP_HI0.

On my system, memory pages are 4k sized, then I had to configure the Â«address translation settingsÂ» of the PCIe hard ip with pages of 4k to be coherent.

Once that done, I simply connected the DMA controller provided by Qsys on the TX avalon-MM slave port of PCIe IP.
Telling the DMA to write data on this port will automatically generate TLPs from the FPGA to write on i.MX6 ram.",,,,,
Verilog FSM and module instantiation,"This finite state machine is to act as a controller for a datapath that contains the operators necessary to calculate the GCD of two 4 bit numbers. I am fairly new to this language and I am aware the issue is a probably a missing semi colon or maybe something with my declarations but I can't figure out what the problem is. I keep getting the errors:

ERROR:HDLCompiler:806 - ""D:/Xilinx Stuff/GCD/GCD FSM.v"" Line 44: Syntax error near ""if"".
ERROR:HDLCompiler:806 - ""D:/Xilinx Stuff/GCD/GCD FSM.v"" Line 60: Syntax error near ""="".
ERROR:HDLCompiler:806 - ""D:/Xilinx Stuff/GCD/GCD FSM.v"" Line 64: Syntax error near ""="".
ERROR:HDLCompiler:806 - ""D:/Xilinx Stuff/GCD/GCD FSM.v"" Line 68: Syntax error near "";"".

I'm also open to any tips regarding the logic in general,the code for the FSM is shown below:

module GCD_FSM(clk,data_in,reset,data_out,x_in,y_in,gcd_out,xgty,xlty,xequaly,go_in,xnew,ynew);

    input   clk, data_in, reset,go_in;
    input reg[3:0] x_in,y_in,gcd_out;
    output reg [1:0] data_out;
    reg [3:0] x,y;
    output reg[3:0] xnew,ynew;
    output reg xgty,xlty,xequaly,cleango;

    // Declare state register
    reg [1:0]state;

    // Declare states
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 =4;

    /* Output depends only on the state
    always @ (state) begin
        case (state)
            S0:
                data_out = 2'b01;
            S1:
                data_out = 2'b10;
            S2:
                data_out = 2'b11;
            S3:
                data_out = 2'b00;
            default:
                data_out = 2'b00;
        endcase
    end
    */


    // Determine the next state
    always @ (posedge clk or posedge reset) begin
        if (reset)
            state &lt;= S0;
        else
            case (state)
                S0:
                    debounce start(.clock(clk),.noisy(go_in),.clean(cleango));
                    if (cleango)
                        state &lt;= S1;
                    else
                        state &lt;= S0;
                S1:
                    state &lt;= S2;
                S2:

                    if (xlty)
                        state &lt;= S3;
                    else if(xgty)
                        state &lt;= S4;
                    else if(xequaly)
                        state &lt;= S5;
                S3:
                    ripple_carry_adder_subtractor ysubx(.S(ynew),.C(carry),.V(overflow),.A(y),.B(x),.Op(1));
                    y = ynew;
                    state &lt;= S2;
                S4:
                    ripple_carry_adder_subtractor xsuby(.S(xnew),.C(carry),.V(overflow),.A(x),.B(y),.Op(1));
                    x = xnew;
                    state &lt;= S2;
                S5:
                    gcd_out = x;
                    state &lt;= S0;

            endcase
    end

endmodule
","A few errors that I noticed:


Line 3, you are missing a ; at the end: output reg[3:0] gcd_out
Variables go_in and cleango are not defined.
Module debounce is not defined
",,,,,
Converting 64 word (clk/8) to 8x8 word (clk) (Digital Design - Verilog),"I need to make some sort of interface between my PS and PL on Zynq chip. I need block which will accept 64bit long word (at every clk/8) and send 8 by 8bit word at the output (on every clk). So basically I need to divide 64 bit word into 8 x 8bits word. If you have advice's how to do it please share. 

Thank you in advance,",Register the 64 bits data at the clock when it is ready. Then do the left/right shift 8 bits (depends on your endian requirement) for the following 7 cycles. Your 8 MSBs/LSBs will be your output data respectively. ,,,,,
Generate Statement in verilog for multiple Blocks,"In the code you can see that, I want to instantiate LSFR_counter for 8 times using generate statement. It simulated well, but I want to synthesize for FPGA. 

I have problems which are: 

1)   I found an error when synthesized it. 

Line 31: Signal Reg[4] in unit Main is connected to following multiple drivers:


2) Can I use random parameter for #(.n(random))?

module Main( output Reg , input clk , input reset );     

 parameter N =5 ;
 wire  [N-1:0] Reg ; 
 generate    
   genvar i =0 ;
   for (i ; i&lt;8 ; i=i+1 )
   begin 
   LSFR_counter   #(.n(5)) F1  ( .Reg (Reg )  , .clk (clk ), .reset(reset) );  
   end 
 endgenerate 
endmodule


and 

    module LSFR_counter  #(parameter n=6)( output Reg, input clk, input reset);
    //parameter n=6; // Change more than n to change LFSR length.

    reg [n:1]Reg; //All procedure outputs must be registered

    always @(posedge clk or posedge reset)
        if
        (reset) Reg &lt;=1;
        else
        Reg &lt;= {Reg[n-1:2], Reg[n]^Reg[1], Reg[n]};
    endmodule 
","Multiple divers means that you have multiple modules trying to set the value of Reg. As a side note I really would advise to use some thing else other than Reg as a signal name, not least because at the top level it is a wire.

Thinking about your generate around the LFSR it would unroll to something like:

LSFR_counter   #(.n(5)) F1_1  ( .Reg (Reg )  , .clk (clk ), .reset(reset) );
LSFR_counter   #(.n(5)) F1_2  ( .Reg (Reg )  , .clk (clk ), .reset(reset) );
LSFR_counter   #(.n(5)) F1_3  ( .Reg (Reg )  , .clk (clk ), .reset(reset) );


clk and reset are inputs and they can drive multiple modules, but reg is an output which all of them are trying to drive.

In simulation you may not see an issue as you have multiple modules all driving the exact same value. 

You likely wanted some thing along the lines of:

wire  [N-1:0] Reg [0:7]; //&lt;-- memory
genvar i =0 ;   
generate    
  for (i ; i&lt;8 ; i=i+1 ) begin 
    LSFR_counter #(
     .n(5)
    ) F1  ( 
     .Reg  (Reg[i]  ), //&lt;-- write to part of memory
     .clk  (clk  ),
     .reset(reset) 
    );  
  end 
endgenerate 
",,,,,
Can I make a bus of buses in Xilinx ISE?,"I know how to add a bus to wires in xilinx.
Furthermore, I made a bus to another buses. Now I'm stuck with adding a bus tap correctly. How can I do it?
Is this even possible?","Finally I heard that with Xilinx, it's impossible.",,,,,
wait must contain condition clause with until keyword,"The following VHDL is to be used to test bench a booth multiplier. I keep getting an error on the first wait statement during analysis and elaboration : ""wait statement must contain condition clause with until keyword""
I have several working test benches written this way (i.e. signal assignment, wait for x ns, other assignment, wait for x ns ...). I can't seem to find what the error might be.

LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY BoothMultiplier_32_test IS
END BoothMultiplier_32_test;

ARCHITECTURE test_arch OF BoothMultiplier_32 IS

SIGNAL A_test           :   STD_LOGIC_VECTOR (31 downto 0);
SIGNAL B_test           :   STD_LOGIC_VECTOR (31 downto 0);
SIGNAL result_test  :   STD_LOGIC_VECTOR (63 downto 0);

COMPONENT BoothMultiplier_32
    PORT (
        dataA, dataB    :   IN STD_LOGIC_VECTOR (31 downto 0);
        result          :   OUT STD_LOGIC_VECTOR (63 downto 0)
    );
END COMPONENT;

BEGIN
    DUT1: BoothMultiplier_32 
    PORT MAP(
        dataA=&gt;A_test,
        dataB=&gt;B_test,
        result=&gt;result_test
    );

    testing : PROCESS
    BEGIN
        wait for 10 ns;
        A_test&lt;=x""0000000A"";
        B_test&lt;=x""0000000A"";
        --wait for 10 ns;
        --A_test&lt;=x""10000000"";
        --B_test&lt;=x""00000010"";
        --wait for 10 ns;
        --A_test&lt;=x""FFFFFFFF"";
        --B_test&lt;=x""FFFFFFFF"";
        wait;
    END PROCESS testing;

END ARCHITECTURE test_arch;
","The only observable error in your code is:

ARCHITECTURE test_arch OF BoothMultiplier_32 IS


Should be:

ARCHITECTURE test_arch OF BoothMultiplier_32_test IS


Preceding your entity and architecture pair with a dummy BoothMultiplier_32 and using the above correction:

library ieee;
use ieee.std_logic_1164.all;

entity boothmultiplier_32 is
    port (
        dataa, datab    :   in std_logic_vector (31 downto 0);
        result          :   out std_logic_vector (63 downto 0)
    );
end entity;

architecture foo of boothmultiplier_32 is
begin
end architecture;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY BoothMultiplier_32_test IS
END BoothMultiplier_32_test;

ARCHITECTURE test_arch OF BoothMultiplier_32_test IS

SIGNAL A_test           :   STD_LOGIC_VECTOR (31 downto 0);
SIGNAL B_test           :   STD_LOGIC_VECTOR (31 downto 0);
SIGNAL result_test  :   STD_LOGIC_VECTOR (63 downto 0);

COMPONENT BoothMultiplier_32
    PORT (
        dataA, dataB    :   IN STD_LOGIC_VECTOR (31 downto 0);
        result          :   OUT STD_LOGIC_VECTOR (63 downto 0)
    );
END COMPONENT;

BEGIN
    DUT1: BoothMultiplier_32 
    PORT MAP(
        dataA=&gt;A_test,
        dataB=&gt;B_test,
        result=&gt;result_test
    );

    testing : PROCESS
    BEGIN
        wait for 10 ns;
        A_test&lt;=x""0000000A"";
        B_test&lt;=x""0000000A"";
        --wait for 10 ns;
        --A_test&lt;=x""10000000"";
        --B_test&lt;=x""00000010"";
        --wait for 10 ns;
        --A_test&lt;=x""FFFFFFFF"";
        --B_test&lt;=x""FFFFFFFF"";
        wait;
    END PROCESS testing;

END ARCHITECTURE test_arch;


And the code then analyzes, elaborates and runs using the  elaboration and run target boothMultiplier_32_test (while doing nothing interesting but none the less showing proper connectivity).

Perhaps you could tell us what tool you're having trouble with?",,,,,
How do I concatenate parameters and integers in verilog,"My code for an Altera FPGA has 8 memories, that I need to initialise using memory initialization files (mifs). To enable me to instantiate memories with different mifs, I make the following changes to the memory definition file.

original code

module my_memory (
input clk,addr,din,wen,ren;
output dout);
...
...
defparam
altsyncram_component.init_file = ""memory_init.mif"";
...
endmodule


modified code

module my_memory (
input clk,addr,din,wen,ren;
output dout
);


parameter MIFNAME = ""memory_init.mif"";

...
...
...
defparam
altsyncram_component.init_file = MIFNAME,
...
endmodule


This now allows me to instantiate multiple memory blocks and pass the initialisation file as a parameter.

My memory instantiation now looks like this

my_memory #(.MIFNAME(""mem_0_init.mif"") u_mem0 (...);
my_memory #(.MIFNAME(""mem_1_init.mif"") u_mem1 (...);
my_memory #(.MIFNAME(""mem_2_init.mif"") u_mem2 (...);
my_memory #(.MIFNAME(""mem_3_init.mif"") u_mem3 (...);
my_memory #(.MIFNAME(""mem_4_init.mif"") u_mem4 (...); 


I then decide to use a generate to instantiate my memories

generate
genvar i;
for (i=0; i&lt;=4; i=i+1)
begin : MEM_INST
  mem_memory #(.MIFNAME({""mem_"",i,""_init.mif""}) u_mem (...);
end
endgenerate


However this does not work. The memory initialisation file parameter passed to each of the instantiation is incorrect. 

What do I do?","If you can use SystemVerilog, then this is what you can write 

  mem_memory #(.MIFNAME($sformatf(""mem_%0d_init.mif"",i)) u_mem (...);


Otherwise you will need to get creative with parameters

genvar i;
for (i=0; i&lt;=4; i=i+1)
begin : MEM_INST
  localparam [7:0] index = ""0""+i;
  mem_memory #(.MIFNAME({""mem_"",index,""_init.mif""}) u_mem (...);
end
endgenerate
",,,,,
"Recieving the following error: ""line 36 expecting 'endmodule', found 'if'","On the line with if(lr == 0) I am recieving the following error ""expecting 'endmodule', found 'if'.  The Verilog code is of a 8-bit shift register that functions as a left and right shifter and can choose between arithmetic and logical shifting.   I can't see why I am receiving the error.  It may be a some type of syntax error since I am new to Verilog.  Thanks for any help in advance.

module shifter(
input [7:0] shift_in,
input [2:0] shift_by,

 // 0 for left, 1 for right
input lr,

 //0 for logical, 1 for arithmetic
input arith,
output reg signed [7:0] shift_out
);

//left shift
if(lr == 0) 
begin
    assign shift_out = shift_in &lt;&lt; shift_by;
    assign shift_out[0] = 1'b0;
end
//right shift
else begin
    //logical shift
    if (arith == 0) begin
        assign shift_out = shift_in &lt;&lt; shift_by;
        assign shift_out[7] = 1'b0;
    //arithmetic shift
    end else begin
        assign shift_out[7] = shift_in[7];
        assign shift_out = shift_in &lt;&lt; shift_by;
    end
end

endmodule
","You can not use if statments like that with assign. Place in an always block and remove the assign.

always @* begin
//left shift
if(lr == 1'b0) 
begin
    shift_out = shift_in &lt;&lt; shift_by;
    shift_out[0] = 1'b0;
end
//right shift
else begin
    //logical shift
    if (arith == 0) begin
        shift_out = shift_in &lt;&lt; shift_by;
        shift_out[7] = 1'b0;
    //arithmetic shift
    end else begin
        shift_out[7] = shift_in[7];
        shift_out = shift_in &lt;&lt; shift_by;
    end
end
end
",,,,,
FPGA verilog code upload speed and size limit,"I have two question about FPGA
1.  I would like to know how large FPGA chip size would be if I create a full CPU with pipeline.
Any calculation method or paper that describes how I can calculate the chip size?
2. If I upload fairly reasonable functions (or modules) to FPGA after compilation, How long would it actually take to write the logic on FPGA? that is, excluding the compilation time and including just uploading time.","This would depend on the particular CPU, but to give you an idea a Xilinx MicroBlaze Soft Processor Core takes up around 1000 logic cells, maybe up to around 6000 logic cells with peripherals. A high end FPGA like the Xilinx Zynq-7100 has 444K logic cells.

Configuring an FPGA is very quick; the Z-7100 takes about 1-2 minutes to program. ",,,,,
How can I design VHDL modal in the following details?,"Design VHDL model of a functional unit called sign-extender unit used in some processors. Input of this unit is 4-bit signed binary number and output is 8 bit signed binary number. The unit preserves magnitude and sign of the number.

Here is my code and it doesn't work. I'm beginner. Please help and explain. Many thanks.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity sign_extender is
    port
    (   
        a: in std_logic_vector (3 downto 0);
        q: out std_logic_vector (7 downto 0);
    );
end sign_extender;

architecture sign_extender_arch of sign_extender is
begin -- architecture
    q &lt;= a;
end sign_extender_arch;
","q &lt;= std_logic_vector(resize(signed(a), q'length));


The std_logic_vector doesn't represent an integer value, only an array of std_logic, so first you make it signed using signed from  ieee.numeric_std.signed.  

A resize function is also defined in ieee.numeric_std for signed and unsigned, and it is applied to the signed value, with the desired length given by q'length, and it returns a signed for signed argument, etc.  

Finally the signed value is converted back to std_logic_vector, as required for the output port.",,,,,
verilog code containing adders,"i write the verilog code which contain only adders. In this g,h are 10 bits and r5(main output) is of 11 bits. When i take r5 as 11 bits then i am not getting correct output but when i take r5 as 10 bits then i am getting correct. but (r5=g+h) so its bit should be one more than bits of g,h.
i took input as clk = 1;

    s189 = 10'd200;
    s375 = 10'd75;
    s050 = 10'd300;
    s218 = 10'd54;


and output should be r5= -16 but it gives output as (01111110000) instead of (11111110000)

module out(clk,s189,s375,s050,s218,r5,g,h);
input clk;
input [9:0] s189,s375,s050,s218;
output reg[10:0] r5;
output reg [9:0] g,h;
reg [3:0] countr=4'b0000;
always@(posedge clk)
begin
if (countr==4'b1000)
begin
 g&lt;= s218-s189;
 h&lt;= s375+s050;
 r5&lt;=g+h;
 end
end

always@(posedge clk)
begin
 if (countr==4'b1001)
 countr&lt;=4'b0000;
 else 
 countr&lt;= countr+1;
end

endmodule
","You are performing unsigned arithmetic, as noted the MSB is 0 not 1 (negative) as expected. You need to declare the inputs, outputs and variables used as signed, for automatic sign extension.

module out(
  input clk, 
  input signed [9:0] s189,
  input signed [9:0] s375,
  input signed [9:0] s050,
  input signed [9:0] s218,
  output reg signed [10:0] r5,
  output reg signed [9:0] g,
  output reg signed [9:0] h
);
",,,,,
The Identifier must be declared with a port mode : (for all 3 outputs) (Verilog),"I am getting three errors saying that the identifier must be declared with a port mode for my three output.  I cannot figure out why this is happening.  Some help would be great.

module Testbench (A2, B2, Zero, One, Two);
input [3:0] A2, B2;
output Zero1, One1, Two1;
wire e0, e1, e2, e3, A10, A11, A12, A13, B10, B11, B12, B13;
Compare  cp0(A2[0], B2[0], e0, A10, B0);
Compare  cp1(A2[1], B2[1], e1, A11, B1);
Compare  cp2(A2[2], B2[2], e2, A12, B12);
Compare  cp3(A2[3], B2[3], e3, A13, B13);
assign Zero = (e0 &amp; e1 &amp; e2 &amp; e3);
assign One = (A13 | (A12 &amp; e3) | (A11 &amp; e3 &amp; e2) | (A10 &amp; e3 &amp; e2 &amp; e1));
assign Two = (~One &amp; ~Zero);
endmodule 
","In your port list, you have:

module Testbench (A2, B2, Zero, One, Two);


But you call out the outputs with different names:

output Zero1, One1, Two1;
",,,,,
VHDL Accumulator - Infix errors,"I'm trying to create an accumulator to use in an NCO, but getting some strange errors. I'm fairly new to VHDL so any help is appreciated, here's my code:

library IEEE;
use IEEE.STD_LOGIC_1164.all;    -- for std_logic and std_logic_vector
use IEEE.NUMERIC_STD.all;       -- for unsigned type

---------------------------------------------------------------------
-- accumulator entity declaration
---------------------------------------------------------------------       

entity accumulator is

    port(CLK, Reset : in std_logic;
         S  : in std_logic_vector(11 downto 0);
           N : out std_logic_vector(7 downto 0));
end accumulator;

---------------------------------------------------------------------
-- accumulator architecture                                        
---------------------------------------------------------------------   

architecture accumulator_arch of accumulator is

begin   

process (CLK)
      variable ACC : unsigned(11 downto 0) := ""000000000000"";
      variable STEP : unsigned(11 downto 0) := ""000000000000"";
    begin
        -- use an ""if"" statement to synchronise to rising clock edge
        STEP := unsigned(S);
        if (Reset = '1') then
          ACC := ""000000000000"";

        elsif   rising_edge(clk) then

            ACC := ACC + S;
            --add step size to ACC
        end if;

        N &lt;= std_logic_vector(ACC(11 downto 4));

end process;

end accumulator_arch;


The errors i'm getting are:

** Error: C:/Modeltech_pe_edu_10.4/Projects/NCO.vhd(34): No feasible entries for infix operator ""+"".
** Error: C:/Modeltech_pe_edu_10.4/Projects/NCO.vhd(34): Bad right hand side (infix expression) in variable assignment.
** Error: C:/Modeltech_pe_edu_10.4/Projects/NCO.vhd(42): VHDL Compiler exiting


I can't see why I'm getting errors, as its two unsigned variables I'm adding.

Thanks","You are adding ACC (unsigned) with S (std_logic_vector). You probably meant to use STEP (unsigned) instead.

Also, since you used an asynchronous reset, you have to add Reset to the process sensitivity list or the simulation won't match the implementation. 

I think you would want a synchronous reset in that case, since I expect reset to be driven by a top module instead of a global reset. You make the reset synchronous by moving it inside the rising_edge block:

if rising_edge(clk) then
    if (Reset = '1') then
        ACC := (others =&gt; '0');
    else
        ACC := ACC + STEP;
    end if;
end if;
",,,,,
Output is always zeros (quotient and remainder) in divider code VHDL,"Output is always zeros (quotient and remainder) in the code shown below. 
Even if I assign value of b to remainder,it is giving 0. I have checked for many times but I am not able to understand what the issue is. While compiling, it is showing 2 warnings: 

- Initial value of ""b"" depends on value of signal ""divisor"".


What is the problem?

-- DIVIDER

library ieee;  
use ieee.numeric_bit.all;  

entity unsigned_divider is  
port(
-- the two inputs  
dividend: in bit_vector(15 downto 0);  
divisor : in bit_vector(15 downto 0);  
-- the two outputs  
quotient : out bit_vector(15 downto 0);  
remainder : out bit_vector(15 downto 0)  
);  
end entity unsigned_divider;  

architecture behave of unsigned_divider is  

begin  
process  

variable a : bit_vector(15 downto 0):=dividend;  
variable b : bit_vector(15 downto 0):=divisor;  

variable p : bit_vector(15 downto 0):= (others =&gt; '0');  
variable i : integer:=0;  
begin  

for i in 0 to 15 loop  
p(15 downto 1) := p(14 downto 0);  
p(0) := a(15);  
a(15 downto 1) := a(14 downto 0);  
p := bit_vector(unsigned(p) -  unsigned(b));  

if(p(15) ='1') then  
a(0) :='0';  
p := bit_vector(unsigned(p) +  unsigned(b));  
else  
a(0) :='1';  
end if;  
wait for 1 ns;  

end loop;

quotient &lt;= a after 1 ns;  
remainder &lt;= p  after 1 ns;  

end process;
end behave;
","You should have explicit assignments to the variables a and b inside the process statement part (as sequential signal assignments). The declarations:

        variable a : bit_vector(15 downto 0):=dividend;  
        variable b : bit_vector(15 downto 0):=divisor;  


Should be:

        variable a : bit_vector(15 downto 0);  
        variable b : bit_vector(15 downto 0);  


And in the process statement part (following the begin in the process):

        a := dividend;
        b := divisor;


These overcome the issue natipar mentions, that the values are only assigned to a and b during initialization.

Further should you desire to have a 1 ns delay you should have an explicit wait statement as the last sequential statement of the process statement process statement part:

wait on dividend, divisor;


These make your process statement look something like this (with indentation added):

    process  

        variable a : bit_vector(15 downto 0); -- := dividend;  
        variable b : bit_vector(15 downto 0); -- := divisor;  

        variable p : bit_vector(15 downto 0) :=  (others =&gt; '0');  
        variable i : integer := 0;  
    begin  

        a := dividend;
        b := divisor;

        for i in 0 to 15 loop  
            p(15 downto 1) := p(14 downto 0);  
            p(0) := a(15);  
            a(15 downto 1) := a(14 downto 0);  
            p := bit_vector(unsigned(p) -  unsigned(b));  

            if  p(15)  = '1'  then  
                a(0) :='0';  
                p := bit_vector(unsigned(p) +  unsigned(b));  
            else  
                a(0) := '1';
            end if;  
            wait for 1 ns;  

        end loop;

        quotient &lt;= a after 1 ns;  
        remainder &lt;= p  after 1 ns;  

        wait on dividend, divisor;

    end process;


(Note the space between the numeric literal and the units, required by IEEE Std 1076-2008, 15.3 Lexical elements, separators and delimiters paragraph 4, the last sentence ""At least one separator is required between an identifier or an abstract literal and an adjacent identifier or abstract literal."", despite Modelsim not requiring it).

Writing a simple testbench we find at least one error in your restoring division algorithm:

entity unsigned_divider_tb is
end entity;

architecture foo of unsigned_divider_tb is
    signal dividend, divisor: bit_vector (15 downto 0) := (others =&gt; '0');
    signal quotient, remainder: bit_vector (15 downto 0);

    function to_string(inp: bit_vector) return string is
        variable image_str: string (1 to inp'length);
        alias input_str:  bit_vector (1 to inp'length) is inp;
    begin
        for i in input_str'range loop
            image_str(i) := character'VALUE(BIT'IMAGE(input_str(i)));
        end loop;
        return image_str;
    end;

begin
DUT:
    entity work.unsigned_divider
        port map (
            dividend,
            divisor,
            quotient,
            remainder
        );
MONITOR:
    process (quotient, remainder)
    begin
        report ""quotient = "" &amp; to_string (quotient) severity NOTE;
        report ""remainder = "" &amp; to_string (remainder) severity NOTE;
    end process;

end architecture;



  ghdl -a unsigned_divider.vhdl
  ghdl -e unsigned_divider_tb
  ghdl -r unsigned_divider_tb
  unsigned_divider.vhdl:83:9:@0ms:(report note): quotient = 0000000000000000
  unsigned_divider.vhdl:84:9:@0ms:(report note): remainder = 0000000000000000
  unsigned_divider.vhdl:83:9:@17ns:(report note): quotient = 1111111111111111
  unsigned_divider.vhdl:84:9:@17ns:(report note): remainder = 0000000000000000  


(And a note on interpretation, the transactions reported at time 0 ms are the default assignments performed as a result of elaboration).

Your algorithm gives a wrong answer for division by 0.

Adding a stimulus process to the testbench:

STIMULUS:
    process
    begin
        wait for 20 ns;
        dividend &lt;= x""ffff"";
        divisor &lt;= x""000f"";
    end process;


Shows it can get the right answer too:


  unsigned_divider.vhdl:83:9:@37ns:(report note): quotient = 0001000100010001
  unsigned_divider.vhdl:84:9:@37ns:(report note): remainder = 0000000000000000  


And with the testbench and added wait statements and assignments in the stimulus process you can explore further.

I've always been a fan of non-restoring division myself, because the adds or subtracts take a clock in a clocked divider.",,,,,
Function to calculate a value inside a Verilog generate loop,"I am trying to create a parametrized circuit for the multiplication stage of a BCD Wallace Tree Multiplier, which I implemented in Orcad. The trouble I'm having is that I need to calculate the bit positions that each two digits that result from BCD multiplication will inhabit.
Here is my code:

module bcd_mult_1_n #(parameter N = 8)
  (input [N * 4 - 1:0] num1, num2, output reg [2 * 4 * N * N - 1:0] partProds);

  genvar i, j;

  generate
    for(i = 0; i &lt; N; i = i + 1) begin : dig1
      for(j = 0; j &lt; N; j = j + 1) begin : dig2
        localparam lsd = posLSD(i, j);
        localparam msd = posMSD(i, j);
        bcd_mult_1 bcd_mult(num1[i * 4 + 3:i * 4], num2[j * 4 + 3:j * 4],
                            partProds[msd * 4 + 3:msd * 4], partProds[lsd * 4 + 3: lsd * 4]);
      end
    end
  endgenerate


In the above code, numPrev(i + j) needs to return a value calculated something like this

int numPrev(int x) {
  int acc = 0;
  for(int i = x; i &gt; 0; i++) acc = acc + 2 * i;
  return acc;
}




Thanks to help from @Morgan I have created the following function; the logic is meant to count up and down a sort of triangle of values which rise from 1 to N and back down to 1.

  function integer posLSD;
    input integer x, y;
    integer weight;
    integer acc;
    integer num;
    integer i;
    weight = x + y;
    acc = 0;
    if(weight &gt;= N) num = N - 1;
    else num = weight;
    for(i = num; i &gt; 0; i = i - 1)
      acc = acc + 2 * i;
    if(weight &gt;= N) begin
      for(i = 2 * N - weight; i &lt;= N; i = i + 1) begin
        acc = acc + 2 * i;
      end
      acc = acc + N - weight + y - 1;
    end
    else
      acc = acc + y;
    posLSD = acc;
  endfunction

  function integer posMSD;
    input integer x, y;
    integer acc;
    integer weight;
    acc = posLSD(x, y);
    weight = x + y;
    if(weight &lt; N) acc = acc + weight + 1;
    else acc = acc + 2 * N - weight - 1;
    posMSD = acc;
  endfunction


How could I achieve this functionality? If needed, I could use SystemVerilog constructs.","When I change to use a function I get the error Packed dimension must specify a range. I think you need to think about your partProds width and connections.

Using a function:

module bcd_mult_1_n #(
  parameter N = 8
)  (
  input [N * 4 - 1:0] num1, 
  input [N * 4 - 1:0] num2, 
  output reg [2 * 4 * N * N] partProds
);

  integer prev = 1;
  genvar i, j;
  generate
    for(i = 0; i &lt; N; i = i + 1) begin : dig1
      for(j = 0; j &lt; N; j = j + 1) begin : dig2
        bcd_mult_1 
          bcd_mult(
            num1[i * 4 + 3:i * 4],
            num2[j * 4 + 3:j * 4], 
            partProds[numPrev(i+j) + 2*j + i + 1], 
            partProds[numPrev(i+j) + j]
          );
      end
    end
  endgenerate

  function numPrev;
    input integer x ;
    integer acc;
    begin
      acc = 0;
      for(int ij = x; ij &gt; 0; ij++) begin
        acc = acc + 2 * ij;
      end
      numPrev = acc;
    end
  endfunction

endmodule

module bcd_mult_1(
  input [3:0]a,
  input [3:0]b,
  input c,
  input d
);

endmodule


Example on EDA Playground.",,,,,
Basics about process statement in VHDL,"In test bench in xilinx, I recognized that a statement like

 clk_process :process
   begin
        clk &lt;= '0';
        wait for clk_period/2;
        clk &lt;= '1';
        wait for clk_period/2;
   end process;


According to my knowledge, process is implemented when the argument is changed. However, in here, we do not declare any argument. Why does this code works? In what conditions? And, why do we have to use tag like ""clk_process:"" or in port mapping. I am sorry this is a very basic question:( Even brief explanation suffices","IEEE Std 1076-2008, 10.2 Wait statement:


  The wait statement causes the suspension of a process statement or a procedure.  


11.3 Process statement:


  A process statement defines an independent sequential process representing the behavior of some portion of the design.  


Para 12:


  The execution of a process statement consists of the repetitive execution of its sequence of statements. After the last statement in the sequence of statements of a process statement is executed, execution will immediately continue with the first statement in the sequence of statements.  


Back to 10.2, para 8:


  The execution of a wait statement causes the time expression to be evaluated to determine the timeout interval. It also causes the execution of the corresponding process statement to be suspended, where the corresponding process statement is the one that either contains the wait statement or is the parent (see 4.3) of the procedure that contains the wait statement. The suspended process will resume, at the latest, immediately after the timeout interval has expired.  


And back to 11.3, para 4:


  If a process sensitivity list appears following the reserved word process, then the process statement is assumed to contain an implicit wait statement as the last statement of the process statement part; this implicit wait statement is of the form  
  
  wait on sensitivity_list ;  


(Which covers the case of a process sensitivity list).

What you refer to as a tag is a label.  Labels are optional by and large (particularly here although there are places where labels can be required).

The last paragraph of 10.1 (10. Sequential statements):


  All sequential statements may be labeled. Such labels are implicitly declared at the beginning of the declarative part of the innermost enclosing process statement or subprogram body.  


The last paragraph of 11.1 (11. Concurrent statements):


  All concurrent statements may be labeled. Such labels are implicitly declared at the beginning of the declarative part of the innermost enclosing entity declaration, architecture body, block statement, or generate statement.  


(And a process statement is a concurrent statement, see 11.1 paragraph 2).

11.3, paragraph 2:


process_statement ::= 
    [ process_label : ]
        [ postponed ] process [ ( process_sensitivity_list ) ] [ is ] 
              process_declarative_part
        begin
            process_statement_part
        end [ postponed ] process [ process_label ] ;


Where the square brackets enclose an optional item. (See 1.3.2 Syntactic description).",,,,,
Error in testbench as Inout port 'A' of 'DIGITADD' must be a net,"module DIGITADD(
    input [3:0] A,
    input [3:0] B,
    input CIN,
    output COUT,
    output [3:0] SUM
    );

  reg [4:0] s2;
assign SUM = s2[3:0];
assign COUT = s2[4];

//BCD ADDER PART 
always @ ( * )
begin
    s2 = A + B + CIN;
    if (s2 &gt; 9)
    begin
        s2 = s2 + 6;
    end
end
endmodule 


TEST BENCH

module DIGITADD_tb(
  reg [3:0] A,
  reg [3:0] B,
  reg CIN,
  wire COUT,
  wire [3:0] SUM);

  DIGITADD uut(
    .A(A),
    .B(B),
    .CIN(CIN),
    .COUT(COUT),
    .SUM(SUM));

  initial begin
    $dumpfile(""dump.vcd"");
    $dumpvars(1,DIGITADD_tb);
    #10;
     #10 A=4'b0000;B=4'b0011;CIN=1'b0;
    #10 A=4'b0111;B=4'b1000;CIN=1'b1;
    $finish;
  end
endmodule
","You have added local variables in your testbench in the style of a port list:

module DIGITADD_tb(
  reg [3:0] A,
  reg [3:0] B,
  reg CIN,
  wire COUT,
  wire [3:0] SUM);


Should be:

module DIGITADD_tb(); //&lt;-- no ports 
  reg [3:0] A; //&lt;-- semicolon
  reg [3:0] B;
  reg   CIN;
  wire COUT;
  wire [3:0] SUM;
",,,,,
selective data transfer in verilog,"How to transfer particular bits of data from input to output.

The code is as follows:

module (a ,b, ...);
 input [31:0] a;
output [15:0] b;
endmodule


My questions is how I can transfer only first sixteen bits of ""input a"" to the ""output b""?","Use a part-select:

assign b = a[15:0];
",,,,,
How to update regmodel with writes going from RTL blocks,"I understand that regmodel values are updated as soon as transaction initiates from test environment on any of the connected interfaces.

However consider a scenario:


RTL registers being updated from ROM on boot-up (different value than default)
Processor in RTL writing to register as compared to test environment.


In these 2 cases regmodel doesn't get updated/mirrored with correct RTL value. I would like to know what is correct procedure to get regmodel updated, if there is none at the moment what other approach can be taken to keep these 2 in sync?","For the first case you have to pre-load your memory model with your ROM contents at the start of the simulation. There isn't any infrastructure to do this in uvm_memory (unfortunately), so you'll have to implement it yourself.

For the second case, you have to use a more grey-box approach to verification. You have to monitor the bus accesses that the processor does to the peripherals and update the register values based on those transactions. This should be OK to do from a maintainability point of view, because the architecture of your SoC should be pretty stable in that sense (you've already decided to use a processor so that will always be there, but you might not know which peripherals will make it to the end).",,,,,
Can I access delayed value in SystemVerilog assertion,"I want to use an old value of a signal in a SystemVerilog assertion.

This is what I am currently doing

logic [ADDRESS_WIDTH-1:0] old_address [1:0];

always_ff@(posedge rdclock) begin
   old_address[0] &lt;= rdaddress;
   old_address[1] &lt;= old_address[0];
end

property FooBar;
   @(posedge rdclock) rden |-&gt; ##2 q == mem[old_address[1]];
endproperty

Baz: assert property (FooBar);


Is this how is should be done, or can I somehow use an old version of rdaddress directly in the assertion?","You can use the $past(...) system task. Using $past(rdaddress) will return the value of rdaddress that was sampled in the previous cycle. You can specify how many cycle in the past to go with the second argument. In your case, calling $past(rdaddress, 2) will return the value of rdaddress 2 cycles before.",,,,,
Verilog assignments in a sequential always,"I know that I should be using a non-blocking assignments in sequential always assignments. However, I accidentally happen to use a blocking assignment in part of my code, here it is:

reg tb_strobe = 0;
reg [9:0] tb_strobe_cnt = 0;
reg tb_sync = 0;

always@(posedge tb_clkh)
begin
    if (~tb_resetl) begin
        tb_strobe     &lt;= 0;
        tb_strobe_cnt &lt;= 0;
        tb_sync     &lt;= 0;
    end
    else begin

        if (tb_strobe_cnt == 1022) begin
            tb_strobe &lt;= 1;
            tb_strobe_cnt &lt;= tb_strobe_cnt + 1;
        end else if (tb_strobe_cnt == 1023) begin
            tb_strobe &lt;= 0;
            tb_strobe_cnt &lt;= 0;
        end else begin
            tb_strobe &lt;= 0;
            tb_strobe_cnt &lt;= tb_strobe_cnt + 1;
        end

        if (tb_strobe == 1) begin
            tb_sync = 1;             //  &lt;-- this is the mistakenly used blocking assignment
        end else begin
        end

    end
end


And then my simulator behaves unpredictably, and once I fixed that assignment to be a non-blocking one, it started working fine !!!!

I am curious as to what was wrong with the above (in my specific code)?
In the way that I used it, since I am only calling tb_sync once in my code, I wasn't expecting any unpredictable behavior... 
And tb_sync is not being assigned anywhere else in the code. Any idea what is wrong?","Non-blocking assignments are used to prevent race conditions between multiple processes that write and read the same variable on the same clock edge. It just takes one process that writes, and another process that reads the same variable on the same clock edge to create that race. Your example does not show the process that reads tb_sync, but I'm assuming that's where the race is.",,,,,
FPGA reached the limit of USB WireIns,"I'm programming a Xilinx Spartan-6 on an OpalKelly implementation for my master thesis at university.
To by precise, this is the FPGA I'm working on (XEM6010-LX45): https://www.opalkelly.com/products/xem6010/

It is mounted on a board that has to acquire multiple signals (8+), process them and generate multiple ones (16+) to close some feedback loops based on the settings. 

It is controlled by a User Interface built in C# that I'm also programming myself and that must be able to change the feedback logic used when needed without restarting the experiment. This means that the USB interface continuosly sends data to update the settings.

I've just encountered the classic (I suppose) problem where I've just run out of WireIns, that are the Opal Kelly implementation for the USB transmission of data from the C# program to the FPGA.

They are limited to 16bits data with addresses from 0x00 - 0x1F (so 32 WireIns). More details here page 41 http://assets00.opalkelly.com/library/FrontPanel-UM.pdf



Here is the question: how can I increase the data I can send to the FPGA?

The first idea that comes in mind is a big multiplexer in the FPGA that just uses two WireIns, one for the data, the other as a selector. Then a trigger activates the FPGA, storing the data into the right addressed register.

Is this really viable or it's incredibly inefficient? Should I use the WireORs (see the FrontPanel manual I linked)? Should I use a PipeIn and in some way manage the required multiplexer?

How FPGA designers overcome this USB communication limit?

Thanks in advance!","If you have lots of data that you can stream, use a Pipe.

If you want to access the data randomly, you'll have to use a multiplexer, controlled by a WireIn.

Regarding efficiency, you'll have to specify what dimension of efficiency you are interested in, and what value is acceptable.  For example, bandwidth, latency, LUTs used.

--- Update with some code

If you have an array of vectors to update called regs and 2 wirein signals called address and data then you just need to do:

regs(to_integer(unsigned(address))) &lt;= data when rising_edge(clk);


That will be pretty efficient anyway.  If you need to be more careful about glitches on the registers, you might want to use a TriggerIn also, so you can set up the address and data and then trigger the transfer.

regs(to_integer(unsigned(address))) &lt;= data when rising_edge(clk) and trigger_signal = '1';


If your synthesiser won't accept the code above, you'll have to log a bug and convert it into a clocked process with an if statement inside the clocked part.",,,,,
VHDL Type of xxx is incompatible with type of xxx,"Ich have two different types:

type signal_4bit_t is
record
   signals_v      : STD_ULOGIC_VECTOR (3 downto 0);
end record;

 type signal_8bit_t is
record
   signals_v      : STD_ULOGIC_VECTOR (7 downto 0);
end record;


and I create two Arrays:

 type Array_signal_4bit_t   is array (0 to 2) of signal_4bit_t;
 type Array_signal_8bit_t   is array (0 to 2) of signal_8bit_t;


and one entity uses the 4bit Array as Input:

entity test_input is
    Port ( 
           hx_i      : in  Array_signal_4bit_t;
           lx_i      : in  Array_signal_4bit_t;
          );
end test;


and another uses the 8bit Array as Output:

entity test_ouput is
    Port ( 
           out_o      : out Array_signal_8bit_t
          );
end test;


For the Conncetion between the two components I use the signal:

signal tets_out_to_test_in   : Array_signal_8bit_t;


The Instantation looks like this:

in: test_input 
    Port Map ( 
           hx_i  =&gt;    tets_out_to_test_in(7 downto 4),
           lx_i  =&gt;    tets_out_to_test_in(3 downto 0)
          );

out: test_out 
    Port Map ( 
           out_o  =&gt;    tets_out_to_test_in
          );


Now I get the error ""Type of hx_i is incompatible with type of tets_out_to_test_in. I see that Array_signal_4bit_t is different to Array_signal_8bit_t, but is there a ""easy"" way to fix this problem without chanching my entites? Or any idea how I can solve this problem?","Creating a Minimum, Verifiable and Complete example:

library ieee;
use ieee.std_logic_1164.all;

package somepack is
    type signal_4bit_t is
    record
       signals_v      : std_ulogic_vector (3 downto 0);
    end record;

     type signal_8bit_t is
    record
       signals_v      : std_ulogic_vector (7 downto 0);
    end record;
    type array_signal_4bit_t   is array (0 to 2) of signal_4bit_t;
    type array_signal_8bit_t   is array (0 to 2) of signal_8bit_t;
end package;

use work.somepack.all;
entity test_input is
    port ( 
           hx_i      : in  array_signal_4bit_t;
           lx_i      : in  array_signal_4bit_t
         );
end test_input;

architecture foo of test_input is
begin
end architecture;

use work.somepack.all;
entity test_output is
    port ( 
           out_o      : out array_signal_8bit_t
         );
end test_output;

architecture foo of test_output is
begin
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use work.somepack.all;

entity sometestbench is
end entity;

architecture foo of sometestbench is
    signal tets_out_to_test_in: array_signal_8bit_t;
    component test_input is
        port (
            hx_i: in  array_signal_4bit_t;
            lx_i: in  array_signal_4bit_t
        );
    end component;
    component test_output is
        port (
           out_o      : out array_signal_8bit_t        
        );
    end component;    

    signal hx_i_high: array_signal_4bit_t;
    signal lx_i_low:  array_signal_4bit_t;

begin

    hx_i_high(0).signals_v &lt;= tets_out_to_test_in(0).signals_v(7 downto 4);
    hx_i_high(1).signals_v &lt;= tets_out_to_test_in(1).signals_v(7 downto 4);
    hx_i_high(2).signals_v &lt;= tets_out_to_test_in(2).signals_v(7 downto 4);
    lx_i_low(0).signals_v  &lt;= tets_out_to_test_in(0).signals_v(3 downto 0);
    lx_i_low(1).signals_v  &lt;= tets_out_to_test_in(1).signals_v(3 downto 0);
    lx_i_low(2).signals_v  &lt;= tets_out_to_test_in(2).signals_v(3 downto 0);                

label_in: test_input 
    port map ( 
          --  hx_i  =&gt;    tets_out_to_test_in(7 downto 4),
          hx_i =&gt; hx_i_high,
          --lx_i  =&gt;    tets_out_to_test_in(3 downto 0)
          lx_i =&gt; lx_i_low
    );


label_out: test_output 
    port map ( 
           out_o  =&gt;    tets_out_to_test_in
          );    
end architecture;


There were various punctuation issues and spelling mismatches, in and out can't be used as identifiers (labels) they're reserved words.  The component test_out should be test_output,...

There's also a bit more direct, constructing an array_signal_4bit_t type from elements extracted from the array_signal_8bit_t type:

    hx_i_high &lt;= array_signal_4bit_t'(
               0 =&gt; (signals_v =&gt; tets_out_to_test_in(0).signals_v(7 downto 4)),
               1 =&gt; (signals_v =&gt; tets_out_to_test_in(1).signals_v(7 downto 4)),
               2 =&gt; (signals_v =&gt; tets_out_to_test_in(2).signals_v(7 downto 4))
               );

    lx_i_low &lt;= array_signal_4bit_t'(
               0 =&gt; (signals_v =&gt; tets_out_to_test_in(0).signals_v(3 downto 0)),
               1 =&gt; (signals_v =&gt; tets_out_to_test_in(1).signals_v(3 downto 0)),
               2 =&gt; (signals_v =&gt; tets_out_to_test_in(2).signals_v(3 downto 0))
               );


You can't do this in the actual in the association list because the expression operand of the qualified expressions must be globally static (historically (-1993) and likely for synthesis still). (In IEEE Std 1076-2008, 6.5.6.3 Port clauses, para 6):


  If the actual part of a given association element for a formal port of a block is the reserved word inertial followed by an expression, or is an expression that is not globally static, then the given association element is equivalent to association of the port with an anonymous signal implicitly declared in the declarative region that immediately encloses the block. The signal has the same subtype as the formal port and is the target of an implicit concurrent signal assignment statement of the form  


anonymous &lt;= E;  



  where E is the expression in the actual part of the given association element. The concurrent signal
  assignment statement occurs in the same statement part as the block. 


The above examples also make the point you don't have to have a loop.

This MVCe analyzes, elaborates and simulates (while doing nothing particularly interesting).  

A slightly different architecture uses a procedure:

architecture fie of sometestbench is
    signal tets_out_to_test_in: array_signal_8bit_t;
    component test_input is
        port (
            hx_i: in  array_signal_4bit_t;
            lx_i: in  array_signal_4bit_t
        );
    end component;
    component test_output is
        port (
           out_o      : out array_signal_8bit_t        
        );
    end component;    

    signal hx_i_high: array_signal_4bit_t;
    signal lx_i_low:  array_signal_4bit_t;

    procedure slice_array_signal_8bit (
            signal input:   in  array_signal_8bit_t; 
            signal low:     out array_signal_4bit_t;
            signal high:    out array_signal_4bit_t
    ) is
    begin
        for i in array_signal_4bit_t'range loop
            high(i).signals_v &lt;= input(i).signals_v(7 downto 4);
            low(i).signals_v  &lt;= input(i).signals_v(3 downto 0);
        end loop;
    end procedure;

begin

BREAKOUT: 
slice_array_signal_8bit ( tets_out_to_test_in, hx_i_high, lx_i_low);             

label_in: test_input 
    port map ( 
          hx_i =&gt; hx_i_high,
          lx_i =&gt; lx_i_low
    );


label_out: test_output 
    port map ( 
           out_o  =&gt;    tets_out_to_test_in
          );    
end architecture;


Which also tells us how to use a process statement:

architecture foe of sometestbench is
    signal tets_out_to_test_in: array_signal_8bit_t;
    component test_input is
        port (
            hx_i: in  array_signal_4bit_t;
            lx_i: in  array_signal_4bit_t
        );
    end component;
    component test_output is
        port (
           out_o      : out array_signal_8bit_t        
        );
    end component;    

    signal hx_i_high: array_signal_4bit_t;
    signal lx_i_low:  array_signal_4bit_t;

begin

BREAKOUT: 
    process (tets_out_to_test_in)
    begin
        for i in array_signal_4bit_t'range loop
            hx_i_high(i).signals_v &lt;= tets_out_to_test_in(i).signals_v(7 downto 4);
            lx_i_low(i).signals_v  &lt;= tets_out_to_test_in(i).signals_v(3 downto 0);
        end loop;
    end process;          

label_in: test_input 
    port map ( 
          hx_i =&gt; hx_i_high,
          lx_i =&gt; lx_i_low
    );


label_out: test_output 
    port map ( 
           out_o  =&gt;    tets_out_to_test_in
          );    
end architecture;


And finally, the simplest way:

architecture fum of sometestbench is
    signal tets_out_to_test_in: array_signal_8bit_t;
    component test_input is
        port (
            hx_i: in  array_signal_4bit_t;
            lx_i: in  array_signal_4bit_t
        );
    end component;
    component test_output is
        port (
           out_o      : out array_signal_8bit_t
        );
    end component;
begin

label_in: test_input
    port map (
          hx_i(0).signals_v =&gt; tets_out_to_test_in(0).signals_v(7 downto 4),
          hx_i(1).signals_v =&gt; tets_out_to_test_in(1).signals_v(7 downto 4),
          hx_i(2).signals_v =&gt; tets_out_to_test_in(2).signals_v(7 downto 4),
          lx_i(0).signals_v =&gt; tets_out_to_test_in(0).signals_v(3 downto 0),
          lx_i(1).signals_v =&gt; tets_out_to_test_in(1).signals_v(3 downto 0),
          lx_i(2).signals_v =&gt; tets_out_to_test_in(2).signals_v(3 downto 0)
    );

label_out: test_output
    port map (
           out_o  =&gt;    tets_out_to_test_in
          );
end architecture;


We get to map elements of formal's composite type to actual elements individually in a port association list. And this form should be synthesis eligible.",,,,,
"Dynamic signal creation in VHDL and solution of VHDL error: Syntax error near ""process""","I'm new to the world of VHDL and I'm getting this error saying Syntax error near process. I checked for the solutions and found that there may be a missing end if statement but in my code I'm not having that problem.

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_unsigned.ALL;
USE ieee.std_logic_arith.ALL;
use STD.textio.all;

entity Main_Architecture is
port(
    SEN: out std_logic;
    reset: in std_logic;
    clk: in std_logic
    );
end Main_Architecture;

architecture Behavioral of Main_Architecture is
signal main_counter : std_logic_vector(7 downto 0)  := ""00000000"";
signal mux: std_logic_vector(1 downto 0) := ""00"";
signal output  : std_logic_vector(7 downto 0);
signal main_counter_int : integer range 0 to 127:=0;
signal main_generator : std_logic_vector(7 downto 0);


begin
process(main_counter,reset,clk)
    variable x: std_logic;
    variable y: std_logic;
    variable z: integer;
begin
    if(reset = '1') then
        main_counter &lt;= (others =&gt; '0');
    end if;

    if(clk'event and clk='1') then

        if(mux=""00"") then                               --load main counter
            y:= main_counter(0);
            x:= (main_counter(0)XOR main_counter(6) XOR main_counter(7));
            main_counter(7 downto 1) &lt;= main_counter(6 downto 0);
            main_counter(0)&lt;=x;
            main_counter &lt;= main_counter+'1';
            output(0)&lt;=y;
            output(1)&lt;=main_counter(0);
            output(2)&lt;=main_counter(1);
            output(3)&lt;=main_counter(2);
            output(4)&lt;=main_counter(3);
            output(5)&lt;=main_counter(4);
            output(6)&lt;=main_counter(5);
            main_counter_int&lt;=conv_integer(output);
            if(main_counter &gt;= ""11111111"") then
                mux &lt;= ""01"";
            end if;
        end if;

        if(mux=""01"") then
            if(main_counter_int &lt; 2) then
                z:=1;
            else if(main_counter_int &lt; 4) then
                z:=2;
            else if(main_counter_int &lt; 8) then
                z:=3;
            else if(main_counter_int &lt; 16) then
                z:=4;
            else if(main_counter_int &lt; 32) then
                z:=5;
            else if(main_counter_int &lt; 64) then
                z:=6;
            else if(main_counter_int &lt; 128) then
                z:=7;
            end if;


        end if;

    end if;

end process;    -------- LINE 104  -------

end Behavioral;


Also I want to create a std_logic_vector which has a size from value z to 0. i.e. A vector of size z+1. How can i make it?","Question part 1

Without looking into any other issues in your code, I think the problem is this section, which I have re-formatted to show how many 'end if' statements you are missing:

    if(mux=""01"") then
        if(main_counter_int &lt; 2) then
            z:=1;
        else
            if(main_counter_int &lt; 4) then
                z:=2;
            else
                if(main_counter_int &lt; 8) then
                    z:=3;
                else
                    if(main_counter_int &lt; 16) then
                        z:=4;
                    else
                        if(main_counter_int &lt; 32) then
                            z:=5;
                        else
                            if(main_counter_int &lt; 64) then
                                z:=6;
                            else
                                if(main_counter_int &lt; 128) then
                                    z:=7;
                                end if;


    end if;


I think you probably wanted to use elsif instead of else if.

Question part 2

For the second part of your question, assuming you want to produce code that can be realised in hardware, there is no such thing as a run-time sized std_logic_vector. The best you can do is to make your vector have the maximum size that it could need, then only assign or use parts of it, based on the value of 'z'.

A couple of other points:

USE ieee.std_logic_arith.ALL;


This is not a 'true' standard library, and there are many other answers where people recommend against using this library. If you need to perform math functions (e.g. +), USE ieee.numeric_std.all;, then create signals of type signed or unsigned. In your example, main_counter would be declared signal main_counter : unsigned(7 downto 0)  := ""00000000"";. Operations like + can then be performed on this signal, with no ambiguity as to whether it is supposed to be signed or not.

Lastly, the section:

        output(0)&lt;=y;
        output(1)&lt;=main_counter(0);
        output(2)&lt;=main_counter(1);
        output(3)&lt;=main_counter(2);
        output(4)&lt;=main_counter(3);
        output(5)&lt;=main_counter(4);
        output(6)&lt;=main_counter(5);


could more compactly be written using the concatenation operator &amp; as

        output(6 downto 0) &lt;= main_counter(5 downto 0) &amp; y;


Side note: output(7) doesn't seem to ever be assigned.",,,,,
How to overloading an operator in SystemVerilog,"Does anyone have a working example for overloading an operator in SystemVerilog? I read the spec and tried ""bind"" with Questasim 10.3. But there's no luck.",I don't think any tool supports this construct.,,,,,
Event on logic value change,"I usually use the @ operator to wait for any logical value change of a particular signal. For example to wait on any change in signal a, I usually do

wire a;
//...
@(a); // wait any value change 0-&gt;1 or 1-&gt;0, or x-&gt;1 etc


But now I realized that the above codes will not always work as expected especially when we introduce signal strength, as illustrated in following code:

module test;
  wire a;
  logic sweak1 = 0;
  logic spull1 = 0;

  assign (weak0,weak1) a = sweak1 ? 1'b1 : 1'bz;
  assign (pull0,pull1) a = spull1 ? 1'b1 : 1'bz;

  task wait_a_change();
    @(a);
  endtask

  initial forever begin
    $display(""Value: a = %b %v @%0t"", a, a, $time);
    wait_a_change();
    end
  initial begin
    sweak1 = 1;
    #10; spull1 = 1;
    #10; spull1 = 0;
    #10; spull1 = 1;
    #10;
   end 
endmodule


The event @(a) will trigger even if the logical value of a doesn't change.
So my first solution to overcome this is by doing:

task wait_a_change();
  if (a) @(negedge a);
  else   @(posedge a);
endtask


That solution requires additional check (and line too). 
Is there any better solution?","Try @(!a). By putting it through a Boolean expression, it loses its strength. The only thing you loose is x->z transitions. (your solution would not catch that either). If you need that, you had better explain better what you are trying to accomplish, where might be an entirely different approach to take.  ",,,,,
VHDL: Why is output delayed so much?,"I'm learning VHDL in order to describe and demonstrate the work of a superscalar-ish pipelined CPU with hazard detection and branch prediction, etc.

I'm starting small, so for practice I tried making a really simple ""calculator"" design, like this:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_signed.all;

entity calculator is
    port(
        in_A  : in  std_logic_vector(3 downto 0);
        in_B  : in  std_logic_vector(3 downto 0);
        add : in std_logic;
        sub : in std_logic;
        out_C : out std_logic_vector(3 downto 0)
    );
end entity calculator;

architecture RTL of calculator is
    signal next_output : std_logic_vector(3 downto 0);
begin
    process(in_A, in_B, add, sub)
        variable temp_x, temp_y, temp_z : integer;
    begin

        temp_x := conv_integer(in_A);
        temp_y := conv_integer(in_B);

        if(add = '1') and (sub = '0') then
            temp_z := temp_x + temp_y;
            next_output &lt;= std_logic_vector(to_unsigned(temp_z, 4));
        elsif(add = '0') and (sub = '1') then
            temp_z := temp_x - temp_y;
            next_output &lt;= std_logic_vector(to_unsigned(temp_z,4));
        else
            temp_z := 0;
            next_output &lt;= std_logic_vector(to_unsigned(temp_z,4));
        end if;

        out_C &lt;= next_output;
    end process;
end architecture RTL;


However, I can't figure out why the output is set only after the input is changed, as is demonstrated here (the test bench code I guess is irrelevant):



I would like to know what I should do in order to make the output correct and available without delay. If add is 1, then the output should be set according to the input, without delay (well, I want it to be, the way I wrote it, its not :) )

Also, can someone explain to me when the output will be remembered in flip-flops, and if it being remembered in flip-flops the way I wrote my description.

I would also really appreciate all advice, criticism and guidance to help me out. This is only a simple ADD/SUB calculator, and I gotta describe a whole processor with an instruction set in about two months! Maybe you can point me to good learning tutorials, because the classes I had were useless :( 

Thanks in advance! :) ","The easiest thing to do would be to move the assignment

out_C &lt;= next_output;


outside the process (make it a concurrent signal assignment). 

You could also make next_output a variable declared in the process and leave the signal assignment where it is.

The delay happens because signal assignments don't take effect in the simulation cycle they occur in.  Without a process sensitive to next_output it's new value will be seen the next time the process otherwise executes.

A concurrent signal assignment statement has an equivalent process where signals on the right hand side are in the sensitivity list.

Making next_output a variable makes it's value immediately available.

You could also re-write your process:

    process(in_A, in_B, add, sub)
        variable temp_x, temp_y, temp_z : integer;
    begin

        temp_x := conv_integer(in_A);
        temp_y := conv_integer(in_B);

        if(add = '1') and (sub = '0') then
            temp_z := temp_x + temp_y;
        elsif(add = '0') and (sub = '1') then
            temp_z := temp_x - temp_y;
        else
            temp_z := 0;
        end if;

        out_C &lt;= std_logic_vector(to_unsigned(temp_z,4));
    end process;


And eliminate next_output.",,,,,
Verilog - multiple edges in one block like in VHDL?,"I'm using Quartus II, version 11.0 and I'm trying to port my VHDL code to Verilog (just for practice).

I need to check - how long 'a' line is low. There are working VHDL code:

process (clock, a)
begin
    -- on each rising edge of clock...
    if (rising_edge(clock))
    then -- count how long 'a' is low
        if (a = '0' and a_low_time &lt; 3)
        then
            a_low_time &lt;= a_low_time + 1;
        end if;
    end if;
    -- reset counter if 'a' is not low
    if a = '1' then
        a_low_time &lt;= 0;
    end if;
end process;


Very simple, it's working perfectly. But how can I do it using Verilog?
This code:

// on each rising edge of clock...
always @ (posedge clock)
begin
    // count how long 'a' is low
    if (!a &amp;&amp; a_low_time &lt; 3)
        a_low_time &lt;= a_low_time + 1;
end

// reset counter if 'a' is high
always @ (*)
begin
    if (a)
        a_low_time &lt;= 0;
end


Throws ""Ñan't resolve multiple constant drivers"" error. And this:

always @ (posedge clock, posedge a)
begin
    if (!a &amp;&amp; a_low_time &lt; 3)
        a_low_time &lt;= a_low_time + 1;
    else if (a)
        a_low_time &lt;= 0;
end


Throws ""cannot match operand(s) in the condition to the corresponding edges in the enclosing event control of the always construct"" error.

This code is working:

always @ (posedge clock)
begin
    if (!a &amp;&amp; a_low_time &lt; 3)
        a_low_time &lt;= a_low_time + 1;
    else if (a)
        a_low_time &lt;= 0;
end


But I need to reset a_low_time immediately after 'a' goes high but not on rising edge of clock.

How can I do it? Can't believe that I can't do so simple task.","Why do you need to reset a_low_time asynchronously?  In any case, maybe you can use a as your reset line:

always @(posedge clock or posedge a)
begin
    if (a)
        a_low_time &lt;= 0;
    else if (!a &amp;&amp; a_low_time &lt; 3)
        a_low_time &lt;= a_low_time + 1;


Actually, since a is your reset, you shouldn't need to check it to increment:

always @(posedge clock or posedge a)
begin
    if (a)
        a_low_time &lt;= 0;
    else if (a_low_time &lt; 3)
        a_low_time &lt;= a_low_time + 1;
",,,,,
Inbuilt Adders used in FPGA,When we write code for adder C=A+B then which adders are used by IST for implementation in FPGA . Can we build adders faster than that so that our delay gets reduced by compromising the Area.,For most cases you can't beat the dedicated adder resources found in FPGAs. They have enhanced carry logic that is significantly faster than what you can create in the configurable fabric. In certain cases you may be able to do better than the hardware adder support if you switch to an architecture that is less sensitive to carry delays such as using the signed digit number system to add multiple values together. The overhead of doing that with only two terms will still be slower though.,,,,,
Verilog asynch mem in Xilinx,"I am trying to create a memory shift operation in verilog and was wondering the best way to do it. An example code is: 

reg [MSB:0] a [0:NO_OF_LOCATIONS];
// after some processing
for(i =0; i &lt;= NO_OF_LOCATIONS; i= i+1)
  a[i] = a[i+1]


If I use a ROM in Xilinx it can only do synchronize writes and I need to do all the shifts within one clock cycle. If I do use a memory as above I am not sure if on board implementation will result in metastability or don't care propagation. 

Also what would be the best way to do it instead of a for loop?","I am assuming this is part of a clocked synchronous block, i.e. something like the following (it would not make much sense otherwise and you wrote ""I need to do all the shifts within one clock cycle"", which implies that this is part of a synchronous design):

reg [MSB:0] a [0:NO_OF_LOCATIONS];

always @(posedge clk)
  if (...) begin
    for(i =0; i &lt; NO_OF_LOCATIONS; i= i+1)
      a[i] &lt;= a[i+1];
    a[NO_OF_LOCATIONS] &lt;= ...;
  end

// also use a[] somewhere
assign a0 = a[0];


Btw: a[] has NO_OF_LOCATIONS+1 locations in it. I'm not sure if this is intended but I just left it that way. Usually the range of a[] would be written as [0:NO_OF_LOCATIONS-1] for NO_OF_LOCATIONS memory locations.

Notice that I have changed the assignment = to &lt;=. When assigning something in a clocked always-block and the thing you assign to is read anywhere outside that always-block then you must assign non-blocking (i.e. with &lt;=) in order to avoid race conditions in simulation that can lead to simulation-synthesis mismatches.

Also notice that I have factored out the assignment to a[NO_OF_LOCATIONS], as it would have got its value from a[NO_OF_LOCATIONS+1], which is out-of-bounds and thus would always be undef. Without that change the synthesis tool would be right to assume that all elements of a[] are constant undef and would simply replace all reads on that array with constant 'bx.

This is perfectly fine code. I'm not sure why you brought up metastability but as long as the ... expressions are synchronous to clk there is no metastability in this circuit. But it does not really model a memory. Well, it does, but one with NO_OF_LOCATIONS write ports and NO_OF_LOCATIONS read ports (only counting the read ports inferred by that for-loop). Even if you had such a memory: it would be very inefficient to use it like that because the expensive thing about a memory port is its capability to address any memory location, but all the ports in this example have a constant memory address (i is constant after unrolling the for-loop). So this huge number of read and write ports will force the synthesis tool to implement that memory as a pile of individual registers. However, if your target architecture has dedicated shift register resources (such as many fpgas do), then this might be transformed to a shift register.

For large values of NO_OF_LOCATIONS you might consider implementing a fifo using cursor(s) into the memory instead of shifting the content of the entire memory from one element to the next. This would only infer one write port and no read port from inside the for-loop. For example:

reg [MSB:0] a [0:NO_OF_LOCATIONS];

parameter CURSOR_WIDTH = $clog2(NO_OF_LOCATIONS+1);
reg [CURSOR_WIDTH-1:0] cursor = 0;

always @(posedge clk)
  if (...) begin
    a[cursor] &lt;= ...;
    cursor &lt;= cursor == NO_OF_LOCATIONS ? 0 : cursor+1;
  end

assign a0 = a[cursor];
",,,,,
pass a dimentional array(2D) to a function VHDL,"I declared a matrix and a signal in my TOP file like this: 

type scanImage is array (0 to 7,0 to 7) of std_logic_vector(2 downto 0);
signal image_matrix : scanImage;




Now, I want to send the above signal to a function which calculates number of cells in the matrix which are not ""000"".

My package looks like this: 



library IEEE;
use IEEE.std_logic_1164.all;
 use IEEE.std_logic_unsigned.all;
 use IEEE.std_logic_arith.all;
use IEEE.NUMERIC_STD.ALL;
 USE IEEE.NUMERIC_BIT.ALL;


PACKAGE my_pack IS

type double_array is array (0 to 7,0 to 7) of std_logic_vector(2 downto 0);

--------------------square calculation declaration--------------------------
 function square_calculation(matrix : double_array) return integer;


 ---------------------------------------------------------------------
 function square_calculation(matrix : double_array) return integer IS
 variable tmp: integer range 0 to 64;
 begin
  tmp:=0;
  for i in 0 to 7 loop

            for j in 0 to 7 loop
                if matrix(i,j)/=""000"" then
                    tmp:=tmp+1;
                end if;
            end loop;

end loop;
return tmp;

end function square_calculation;


 END my_pack;




After compilizing I get this error: 
Error (10476): VHDL error at vision_ctrl.vhd(112): type of identifier ""image_matrix"" does not agree with its usage as ""double_array"" type

Thanks for helping me.","The two arrays scanImage and double_array are not the same type; just happens to be declared the same way.

So declare image_matrix with the type double_array, instead of making a new type scanImage:

signal image_matrix : my_pack.double_array;


Then you can use my_pack.square_calculation with the image_matrix argument.",,,,,
How to make connection between wire signal of top module and inout signal of other module,"The code is as follows:

module abc(a,b,c...);
  inout [15:0] a;
endmodule

module top;
   wire [15:0] data_a;
endmodule


How to make connection between wire signal data_a of top module and inout signal a of other module so that any change in data_a is reflected in inout port?","There is quite a detailed answer on how to instantiate module, which shows how to make connections between modules. 

Inouts are no different, instantiate the module and connect the wire inside top.

module abc(a,b,c...);
  inout [15:0] a;
endmodule

module top;
   wire [15:0] data_a;
   abc u_abs(            //module instance
     .a( data_a )        //port connections
   );
endmodule
",,,,,
'run' phase is ready to proceed to the 'extract' phase,"I am trying to run a couple of test cases using script.But I am getting an error message after running the first test case.This stops the simulation.I am attaching the LOG with this mail.I don't understand why this is happening.

I checked previous posts and added +UVM_OBJECTION_TRACE in the vsim command.But I am not able to find out the cause of the error.Can anybody help me??

# UVM_INFO @ 0: run [OBJTN_TRC] Object uvm_test_top raised 1 objection(s): count=1  total=1
# UVM_INFO @ 0: run [OBJTN_TRC] Object uvm_top added 1 objection(s) to its total (raised from source object uvm_test_top): count=0  total=1
# AT TIME=0,APB MASTER IN RESET MODE
# AT TIME=1200000,APB MASTER IN ACTIVE MODE
# AT TIME=45400000,*************************** EXPECTED_DATA=1792474624,RECEIVED DATA=1792474624
# AT TIME=186600000,*************************** EXPECTED_DATA=222,RECEIVED DATA=222
# AT TIME=231800000,*************************** EXPECTED_DATA=1504340502,RECEIVED DATA=1504340502
# AT TIME=349000000,*************************** EXPECTED_DATA=2367782205,RECEIVED DATA=2367782205
# UVM_INFO Test_Cases/my_test.sv(40) @ 349000000: uvm_test_top [root objections] 
# The total objection count is 1
# ---------------------------------------------------------
# Source  Total   
# Count   Count   Object
# ---------------------------------------------------------
# 0       1       uvm_top
# 1       1         uvm_test_top
# ---------------------------------------------------------
# 
# UVM_INFO Test_Cases/my_test.sv(43) @ 349000000: uvm_test_top [my_component objections] 
# The total objection count is 1
# ---------------------------------------------------------
# Source  Total   
# Count   Count   Object
# ---------------------------------------------------------
# 1       1         uvm_test_top
# ---------------------------------------------------------
# 
# UVM_INFO @ 349000000: run [OBJTN_TRC] Object uvm_test_top dropped 1 objection(s): count=0  total=0
# UVM_INFO @ 349000000: run [OBJTN_TRC] Object uvm_test_top all_dropped 1 objection(s): count=0  total=0
# UVM_INFO @ 349000000: run [OBJTN_TRC] Object uvm_top subtracted 1 objection(s) from its total (dropped from source object uvm_test_top): count=0  total=0
# UVM_INFO @ 349000000: run [OBJTN_TRC] Object uvm_top subtracted 1 objection(s) from its total (all_dropped from source object uvm_test_top): count=0  total=0
# UVM_INFO verilog_src/uvm-1.1d/src/base/uvm_objection.svh(1268) @ 349000000: reporter [TEST_DONE] 'run' phase is ready to proceed to the 'extract' phase
# 
# --- UVM Report Summary ---
# 
# ** Report counts by severity
# UVM_INFO :   12
# UVM_WARNING :    0
# UVM_ERROR :    0
# UVM_FATAL :    0
# ** Report counts by id
# [OBJTN_TRC]     6
# [Questa UVM]     2
# [RNTST]     1
# [TEST_DONE]     1
# [my_component objections]     1
# [root objections]     1
# ** Note: $finish    : C:/questasim_10.2c/win32/../verilog_src/uvm-1.1d/src/base/uvm_root.svh(430)
#    Time: 349 us  Iteration: 68  Instance: /my_top
# 1
# Break in Task uvm_pkg/uvm_root::run_test at C:/questasim_10.2c/win32/../verilog_src/uvm-1.1d/src/base/uvm_root.svh line 430
# Simulation Breakpoint: 1
# Break in Task uvm_pkg/uvm_root::run_test at C:/questasim_10.2c/win32/../verilog_src/uvm-1.1d/src/base/uvm_root.svh line 430
# MACRO ./run_do PAUSED at line 18


Comment on this question",I am not sure about what script your are talking about. But it looks like you do not quit vsim. Try quit in your do file.,,,,,
What is multiple constant driver error in VHDL,"I am developing a VHDL program for flash interface. While compiling my program I got this error. 


(clickable)

As you can see in the picture, two signals (right hand side) are ""xnor"" ed and result is assigned to output (flash_oe). 

Can anyone describe what is this error message?","Are you doing something like this?

ENTITY test IS
  PORT ( sig1, sig3 : IN BIT;
         sig2 : OUT BIT);
END test;
---------------------------
ARCHITECTURE test_arch of test is
BEGIN
  PROCESS(sig1)
  BEGIN
    sig2 &lt;= '0';
  END process;

  PROCESS(sig3)
  BEGIN
    sig2 &lt;= '1';
  END process;
END test_arch;


Let us test this code:

ghdl -a test.vhd
ghdl -e test
ghdl -r test


we get this error:

sig2
./test:error: several sources for unresolved signal
for signal: .test(test_arch).ghdl: compilation error


This is similar to the one you have posted above and it's come up because my code assigns a value to sig2 in two different processes. How could this be implemented into a circuit?

Maybe there is a workaround, I have not provided a solution to your problem since I don't know how your code looks like.",,,,,
Apply same operation to every byte in array,"I have a large array of 2 bits elements. I access these elements one after another at every clock cycle changing the value of the 2 bits depending on the inputs of my design.
Now, after having accessed them all, I would like to set at a certain value (let's say, 11) all the cells that currently contain a specific value (like 10). I need to do it in one clock cycle.

My first idea was to design a single register with a multiplexer at its input, so I can decide which value give to the register, but it does not seems the smartest idea to me (because I need to instantiate N times this new component, and I do not know if it will be easy to access sequentially all these components).

Is there a smart and simple way to do that? I guess that maybe the solution could be using the keyword OTHERS, but I found no clues about how to use that, even in the  VHDL reference manual.

EDIT: this was the component I had in mind.

library IEEE;
use IEEE.STD_LOGIC_1164.all;

entity cell is
  port (
    reset, clk, set, calc: in std_logic;
    data: out std_logic_vector
  );
end entity;

architecture arch of cell is

signal my_reg: std_logic_vector(1 downto 0);

begin

    data &lt;= my_reg;

    main : process(clk, reset)
    begin
        if(reset = '0') then
            my_reg &lt;= ""00"";
        elsif(clk'event and clk = '0') then
            if(set = '1') then
                my_reg &lt;= ""01"";
            elsif(calc = '1' and my_reg = ""01"") then
                my_reg &lt;= ""11"";
            else
                my_reg &lt;= ""00"";
            end if;
        end if;
    end process;

end architecture;


Even instantiating it many times, I do not know how to access in sequence every 'set' signal and globally all the 'calc' signals. ","Because you weren't forthcoming with some parameters of how you were connecting these cells I made the assumption that each of the cells had it's own set and calc bits:

library ieee;
use ieee.std_logic_1164.all;

entity cell is
    port (
        reset_n:    in  std_logic;
        clk_n:      in  std_logic;
        set:        in  std_logic;
        calc:       in  std_logic;
        data:       out std_logic_vector(1 downto 0)
    );
end entity;

architecture arch of cell is
    signal my_reg: std_logic_vector(1 downto 0);
begin
    data &lt;= my_reg;
main: 
    process (clk_n, reset_n)
    begin
        if reset_n = '0' then
            my_reg &lt;= ""00"";
        elsif clk_n'event and clk_n = '0' then -- falling_edge(clk_n)
            if set = '1' then
                my_reg &lt;= ""01"";
            elsif calc = '1' and my_reg = ""01"" then
                my_reg &lt;= ""11"";
            else
                my_reg &lt;= ""00"";
            end if;
        end if;
    end process;
end architecture;

library ieee;
use ieee.std_logic_1164.all;

entity bunch is 
generic ( NUMBER_CELLS:     natural := 8);
    port (
    reset_n:    in  std_logic;
    clk_n:      in  std_logic;
    set:        in  std_logic_vector (NUMBER_CELLS - 1 downto 0);
    calc:       in  std_logic_vector (NUMBER_CELLS - 1 downto 0);
    data:       out std_logic_vector (NUMBER_CELLS * 2 - 1 downto 0)
    );
end entity;

architecture foo of bunch is 
    component cell is
        port (
            reset_n:    in  std_logic;
            clk_n:      in  std_logic;
            set:        in  std_logic;
            calc:       in  std_logic;
            data:       out std_logic_vector (1 downto 0)
        );
    end component;   
begin

GEN:
    for i in set'range generate
    CELLX:
        cell
            port map (
                reset_n =&gt; reset_n,
                clk_n =&gt; clk_n,
                set =&gt; set(i),
                calc =&gt; calc(i),
                data =&gt; data (i * 2 + 1 downto i * 2)
            );
    end generate;
end architecture;

library ieee;
use ieee.std_logic_1164.all;

entity bunch_tb is 
    constant NUMBER_CELLS:  natural := 8;
end entity;

architecture test of bunch_tb is
    constant CLK_PERIOD:    Time := 40 ns;
    signal reset_n:     std_logic := '1';
    signal clk_n:       std_logic := '1';
    signal set:         std_logic_vector(NUMBER_CELLS - 1 downto 0) 
                            := (others =&gt; '0');
    signal calc:        std_logic_vector(NUMBER_CELLS - 1 downto 0) 
                            := (others =&gt; '0');
    signal data:        std_logic_vector (NUMBER_CELLS * 2 - 1 downto 0);

begin
NOTCLK:
    process
    begin
        wait for CLK_PERIOD/2;
        clk_n &lt;= not clk_n;
        if Now &gt; 1400 ns then
            wait;
        end if;
    end process;

DUT:
    entity work.bunch 
        generic map (NUMBER_CELLS)
        port map (
            reset_n =&gt; reset_n,
            clk_n =&gt; clk_n,
            set =&gt; set,
            calc =&gt; calc,
            data =&gt; data
        );
STIMULUS:
    process
        variable bit: std_logic := '1';
    begin
        if Now = 0 ns then
            reset_n &lt;= '0';
            wait for CLK_PERIOD;
        end if;
        if Now &gt; 700 ns then
            bit := '0';
        end if;
        reset_n &lt;= '1';
        set &lt;= bit &amp; set (NUMBER_CELLS - 1 downto 1); -- shift in '1','0'
        wait for CLK_PERIOD;
        calc &lt;= bit &amp; calc (NUMBER_CELLS -1 downto 1); -- shift in '1', '0'
        wait for CLK_PERIOD;
        if Now &gt; 1440 ns then
            wait;
        end if;
    end process;    
end architecture;


As you might notice is changed the name of clk and reset to indicate the polarity, taken from your incomplete cell definition.

And this gives:


(clickable)

If you had been a bit more specific I could have tailored the interfaces to match your expectations.

What this shows is how to hook up the different bus sizes for set, calc and data in a for generate loop.

This was done with ghdl-0.31 on OS X 10.9.5 with gtkwave 3.3.64.


  ghdl -a cell.vhdl
  ghdl -e bunch_tb
  ghdl -r bunch_tb --wave=bunch_tb.ghw  


(And setting up the signals display in gtkwave).

Notice the tests for simulation time (Now) for stopping input stimulus in the testbench.",,,,,
VHDL: Trouble combining entities (components),"Me again!

I wrote something SUPER simple in order to demonstrate how entities come together. However, I'm having trouble figuring out why the output of the combined entities never assumes any value (other than U). Here's the code (its super simple, I promise!) 

library ieee;
use ieee.std_logic_1164.all;

entity OR_LOGIC is
    port(
        in_a  : in  std_logic;
        in_b  : in  std_logic;
        out_c : out std_logic
    );
end entity;

architecture OR_LOGIC_ARCH of OR_LOGIC is
begin
    out_c &lt;= in_a or in_b;
end OR_LOGIC_ARCH;


library ieee;
use ieee.std_logic_1164.all;

entity AND_LOGIC is
    port(
        in_a  : in  std_logic;
        in_b  : in  std_logic;
        out_c : out std_logic
    );
end entity;

architecture AND_LOGIC_ARCH of AND_LOGIC is
begin
    out_c &lt;= in_a and in_b;
end AND_LOGIC_ARCH;


library ieee;
use ieee.std_logic_1164.all;

entity COMBO is
    port(
        in_a  : in  std_logic;
        in_b  : in  std_logic;
        in_c  : in  std_logic;
        out_d : out std_logic
    );
end entity;

architecture COMBO_ARCH of COMBO is
    signal wire1 : std_logic;
    signal wire2 : std_logic;
    component OR_LOGIC
        port(
            in_a  : in  std_logic;
            in_b  : in  std_logic;
            out_c : out std_logic
        );
    end component;
    component AND_LOGIC
        port(
            in_a  : in  std_logic;
            in_b  : in  std_logic;
            out_c : out std_logic
        );
    end component;
begin

    or1 : OR_LOGIC port map (in_a, in_b, wire1);
    and1 : AND_LOGIC port map(in_c, wire1, wire2);
end COMBO_ARCH;


and then:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity TEST_ENTITY is
end entity TEST_ENTITY;

architecture TEST_ENTITY_ARCH of TEST_ENTITY is    
    component ANDandOR
        port(
            in_a  : in  std_logic;
            in_b  : in  std_logic;
            in_c  : in  std_logic;
            out_d : out std_logic
        );
    end component; 
    signal in_a, in_b, in_c, out_d : std_logic;

begin

    combination : ANDandOR port map (in_a, in_b, in_c, out_d);

    process
    begin
        in_a &lt;= '0';
        in_b &lt;= '0';
        in_c &lt;= '0';
        wait for 5ns;

        in_a &lt;= '1';
        in_b &lt;= '0';
        in_c &lt;= '1';
        wait for 5ns;

        in_a &lt;= '0';
        in_b &lt;= '1';
        in_c &lt;= '0';
        wait for 5ns;
    end process;

end architecture TEST_ENTITY_ARCH;
","First, you have assigned the output of your AND gate to wire2, but wire2 is floating. You should either assign it to your ouput like this

out_d &lt;= wire2;


OR remove wire2 from your internal signals and assign your output directly.

and1 : AND_LOGIC port map(in_c, wire1, out_d);


Second, your test bench needs to have the proper name of the component COMBO in order to map it properly. Quartus can generate a test bench template for you, that you can then add test code to it.

Processing --> Start --> Start Test Bench Template Writer

It comes very handy :)",,,,,
VHDL-Switches Proper Code,"Hello I want to get this done


(clickable)

And i have written this code,is it correct?
Because my compiler on MAX+PLUS II dont show any mistake...

LIBRARY IEEE;
USE IEE.STD_LOGIC_1164.ALL;

ENTITY alarm IS PORT
(ON/OFF,MOTION_SENSOR,.LIGHT_SENSOR,.SOUND_SENSOR,.CAMERA_SENSOR,.IP_SENSOR,.TEMPERATURE_SENSOR: IN STD_LOGIC;
SENSOR_SIRINE,SENSOR_LIGHT:OUT STD_LOGIC);
END alarm;

ARCHITECTURE LEITOURGEIA OF alarm IS
BEGIN
if (ON/OFF='1' AND (MOTION_SENSOR='1' OR LIGHT_SENSOR='1' OR SOUND_SENSOR='1' OR CAMERA_SENSOR='1' OR IP_SENSOR='1' OR TEMPERATURE_SENSOR='1')) then
SENSOR_LIGHT&lt;='1';
SENSOR_SIRINE&lt;='1';

ELSE IF (ON/OFF='0' AND (MOTION_SENSOR='1' OR LIGHT_SENSOR='1' OR SOUND_SENSOR='1' OR CAMERA_SENSOR='1' OR IP_SENSOR='1' OR TEMPERATURE_SENSOR='1')) then
SENSOR_LIGHT&lt;='1';
SENSOR_SIRINE&lt;='0';

ELSE
SENSOR_LIGHT&lt;='0';
SENSOR_SIRINE&lt;='0';

END IF

END LEITOURGEIA;
","This is an approximation of what your code would look like as valid VHDL:

library ieee;
use ieee.std_logic_1164.all;

entity alarm is 
    port (
        on_off, motion_sensor, light_sensor,
        sound_sensor, camera_sensor, ip_sensor, 
        temperature_sensor:           in  std_logic;
        sensor_sirine, sensor_light:  out std_logic
    );
end alarm;

architecture leitourgeia of alarm is
begin
unlabelled:
    process (on_off, motion_sensor, light_sensor, sound_sensor, 
             camera_sensor, ip_sensor, temperature_sensor)
    begin
        if on_off = '1' and 
            (motion_sensor = '1' or light_sensor = '1' or sound_sensor = '1' or
             camera_sensor = '1' or ip_sensor = '1' or temperature_sensor='1') then
            sensor_light &lt;= '1';
            sensor_sirine &lt;= '1';
        elsif on_off = '0' and 
            (motion_sensor = '1' or light_sensor = '1' or sound_sensor = '1' or 
            camera_sensor = '1' or ip_sensor = '1' or temperature_sensor = '1') then
            sensor_light &lt;= '1';
            sensor_sirine &lt;= '0';
        else
            sensor_light &lt;= '0';
            sensor_sirine &lt;= '0';
        end if;
    end process;
end leitourgeia;


I indented it, fixed some spelling errors, made things valid identifiers, put the if statement in a process and made the else if an elsif, plus getting rid of two sets of superfluous parentheses.

It now analyzes, elaborates and simulates.

And so does this architecture:

architecture foo of alarm is
    signal alarm_light: std_logic; 
begin
    alarm_light &lt;= motion_sensor or sound_sensor or light_sensor or 
                   camera_sensor or ip_sensor or temperature_sensor;

    sensor_light &lt;= alarm_light;

    sensor_sirine &lt;= '1' when alarm_light = '1'  and on_off = '1' else
                     '0'; 
end architecture foo;


Which more closely resembles the referenced schematic image.

And this one even more closely resembles the referenced schematic:

architecture fum of alarm is
    signal alarm_light: std_logic;
begin
    alarm_light &lt;= motion_sensor or sound_sensor or light_sensor or 
                   camera_sensor or ip_sensor or temperature_sensor;

    sensor_light &lt;= alarm_light;

    sensor_sirine &lt;= on_off and alarm_light;
end architecture fum;
",,,,,
left-justified text for pli call,"I'm trying to make my test-bench more scalable and with a set of PLI functions that require a path name to an instance. I'm trying to avoid having to hardcore that paths. I can construct the path with the $sformat/$sformatf system tasks/functions. I tried defining the path as a SystemVerilog string type, but the PLI rejects it and I cannot change the PLI. The PLI does accept a reg array.

The challenge is the PLI requires left-justify text, but $sformat, $sformatf and %s are all right-justified.

 left-justified : ""tb.vdut[10].inst9.sample_func       "" // Desired
right-justified : ""       tb.vdut[10].inst9.sample_func"" // Actual


Example Function:

function void call(
    integer dut_id, inst_id,
    reg [CHAR_NUM-1:0] func_name,
    integer arg0, arg1, argN );

  reg [CHAR_NUM-1:0] path;
  $sformat(path,""tb.vdut[%0d].inst%0d.%0s"", dut_id, inst_id, func_name );

  // Make path left-justified
  /* missing convert code here */

  $display(""path:'%s', arg0:%0d, arg1:%0d, argN:%0d"", path, arg0, arg1, argN );
  //$my_pli( path, arg0, arg1, argN );
endfunction : call


I have a self answer, but I'm looking for a cleaner solution. The while-loop can suck up a lot of CPU time if CHANR_NUM is big and the function call is executed often times.","Find another solution. First create a parameter for the format string. Use a parameter to the format evaluational only happens at compile/elaboration time, it will be static during simulation.

parameter FORMAT_LJUSTIFY = $sformatf(""%%-%0ds"",CHAR_NUM/8);


So if CHAR_NUM is 640, then FORMAT_LJUSTIFY will be ""%-80s"", meaning the last 80 characters will be be left-justified. 

Then use $sformat(path, FORMAT_LJUSTIFY, path);. It is recommended to use $sformat over $sformatf with reg arrays. Some simulators $sformatf as right justified, others wouldn't compile unless I did type casting. Type casting worked, but it is an extra.

Constraint: If the width of path must be CHAR_NUM else there will be leading and trailing white-space or chomped characters.

function void call(
    integer dut_id, inst_id,
    reg [CHAR_NUM-1:0] func_name,
    integer arg0, arg1, argN );

  reg [CHAR_NUM-1:0] path;
  $sformat(path,""tb.vdut[%0d].inst%0d.%0s"", dut_id, inst_id, func_name );

  // Make path left-justified
  $sformat(path, FORMAT_LJUSTIFY, path);

  $display(""path:'%s', arg0:%0d, arg1:%0d, argN:%0d"", path, arg0, arg1, argN );
  //$my_pli( path, arg0, arg1, argN );
endfunction : call
",,,,,
What is the improve way to multiplying by 15?,"I'm trying to implement as follows to multiplying by 15.
module mul15( 
output [10:0] result, 
input [3:0] a
 ); 
assign result =   a*15;
 endmodule

But is there any improve way to multiplying to a by 15?
I think there are 2 ways like this
1.result = a&lt;&lt;4 -1;
2.result = {a,3'b1111_1111};
Ans I think the best way is 2.
but I'm not sure also with aspect to synthesis.
update:
What if I am multiplying 0 at {a,3'b1111_1111}? This is 255 not 0.
Does anyone know the best way?
Update
How about this way?
Case1
result = {a,8'b0}+  {a,7'b0}+  {a,6'b0}+  {a,5'b0}+  {a,4'b0}+  {a,7'b0}+  {a,3'b0}+  {a,2'b0}+  {a,1'b0}+  a;
But it looks 8 adder used.
Case2
result = a&lt;&lt;8 -1
I'm not sure what is the best way else.","The cleanest RTL version is as you have stated in the question:

module mul15( 
  input      [3:0] a
  output reg [7:0] result, 
); 
  always @* begin
    result = a * 4'd15;
  end
endmodule


The Multiplicand 15 in binary is 4'b1111; That is 8 + 4 + 2 + 1.

Instead of a multiplier it could be broken down into the sum of these powers of 2. Powers of 2 are just barrel shifts. This is how a shift and add multiplier would work.

module mul15( 
  input      [3:0] a
  output reg [7:0] result, 
); 
  always @* begin
    //        8        4        2       1 =&gt;15
    result = (a&lt;&lt;3) + (a&lt;&lt;2) + (a&lt;&lt;1) + a;
  end
endmodule


To minimise the number of adders required a CSD could be used. making 15 out of 16-1:

module mul15( 
  input      [3:0] a
  output reg [7:0] result, 
); 
  always @* begin
    //        16    - 1 =&gt;15
    result = (a&lt;&lt;4) - a;
  end
endmodule


With a modern synthesis tool these should all result in same the thing. Therefore having more readable code which gives a clear instruction to the tool as to what you intended gives it the free rein to optimise as required. ",,,,,
Can I make 4x4 multiplier only using 2x2 multiplier?,"I want to implement to 4x4 bits multiplier using only 2x2 bits multiplier.

for example,
a=1110
b=1011
The 2x2 result is should be 10011010. 

I think that I can split like this.

#case 1
a=10
b=11
2x2 multiplier's result = 0110

#case 2
a=11
b=10
2x2 multiplier's result = 0110


I can get the 2 result by using 2x2 multiplier.
but how can I make to 4x4 multiplier only using 2x2 multiplier?

But I can't approch to any hint. So how can I make 4x4 multiplier. Does anyone know how to do this? Please help.

In brief, How many 4x4 multiplier would you need to perform an 8x8 multiply.
how an 8x8 multiplier would be created using only 4x4 multipliers?

Update :

Is this working?
 http://blog.pioneermathematics.com/2011/04/26/vedic-trick-on-multiplication/ How ?","See lvds answer on how to cascade multipliers.

Some other points on Multipliers

Bare in mind as the input bit width grows to a multiplier, the multiplier size grows exponentially, therefore this is not a linear problem.

Multipliers can be considered to be a sum of shifts, if each shift is controlled by the position and value of the multiplicand we can build a multiplier out of shifts and some AND gates.

reg [3:0] a;
reg [3:0] b;
reg [7:0] mul;

always @* begin
  // mul = a * b;
  mul = ((a &lt;&lt; 3) &amp; {4{b[3]}} )
      + ((a &lt;&lt; 2) &amp; {4{b[2]}} )
      + ((a &lt;&lt; 1) &amp; {4{b[1]}} )
      + ((a     ) &amp; {4{b[0]}} );
end
",,,,,
Convert VHDL code to Verilog,"I have to translate the following vhdl program to verilog:

ENTITY ascounter IS
  PORT (CLK :IN STD_LOGIC;
      QoutA, QoutB, QoutC, QoutD :OUT STD_LOGIC);
END ascounter;
ARCHITECTURE circuit OF ascounter IS
   SIGNAL CLKnot, QBnot, QCnot, QDnot, QA, QB, QC, QD, HIGH :STD_LOGIC;
   BEGIN
      HIGH&lt;='1';
      CLKnot&lt;=NOT CLK;
      QDnot&lt;=NOT QD; 
      QCnot&lt;=NOT QC;
      QBnot&lt;=NOT QB;
      FFD: JKFF PORT MAP (J=&gt;HIGH, K=&gt;HIGH, CLK=&gt;CLKnot, CLRN=&gt;HIGH, PRN=&gt;HIGH, Q=&gt;QD);
      FFC: JKFF PORT MAP (J=&gt;HIGH, K=&gt;HIGH, CLK=&gt;QDnot, CLRN=&gt;HIGH, PRN=&gt;HIGH, Q=&gt;QC);
      FFB: JKFF PORT MAP (J=&gt;HIGH, K=&gt;HIGH, CLK=&gt;QCnot, CLRN=&gt;HIGH, PRN=&gt;HIGH, Q=&gt;QB);
      FFA: JKFF PORT MAP (J=&gt;HIGH, K=&gt;HIGH, CLK=&gt;QBnot, CLRN=&gt;HIGH, PRN=&gt;HIGH, Q=&gt;QA);
      QoutA&lt;=QA;
      QoutB&lt;=QB;
      QoutC&lt;=QC;
      QoutD&lt;=QD;
END circuit;


and I have done it:

  ...
  assign HIGH = 1'b1;
  assign CLKnot = (~CLK);
  assign QDnot = (~QD);
  assign QCnot = (~QC);
  assign QBnot = (~QB);

 flipflop_jk FFD(.J(HIGH), .K(HIGH), .CK(CLKnot), .CLN(HIGH), .PRN(HIGH), .Q(QD));

 flipflop_jk FFC(.J(HIGH), .K(HIGH), .CK(QDnot), .CLN(HIGH), .PRN(HIGH), .Q(QC));

 flipflop_jk FFB(.J(HIGH), .K(HIGH), .CK(QCnot), .CLN(HIGH), .PRN(HIGH), .Q(QB));

 flipflop_jk FFA(.J(HIGH), .K(HIGH), .CK(QBnot), .CLN(HIGH), .PRN(HIGH), .Q(QA));

 assign QoutA = QA;
 assign QoutB = QB;
 assign QoutC = QC;
 assign QoutD = QD;


I have used a jk flipflop:

always @(CK or PRN or CLN)
 begin
  if (PRN == 1'b0)
  begin
     Q &lt;= 1'b1 ; 
  end
  else if (CLN == 1'b0)
  begin
     Q &lt;= 1'b0 ; 
  end
  else if (CK == 1'b0)  
  begin
     if (J == 1'b1 &amp; K == 1'b1)
     begin
        Q &lt;= ~Q ; 
     end
     else if (J == 1'b1 &amp; K == 1'b0)
     begin
        Q &lt;= 1'b1 ; 
     end
     else if (J == 1'b0 &amp; K == 1'b1)
     begin
        Q &lt;= 1'b0 ; 
     end 
  end 
 end 


When I try to run the simulation, I get something like this which is wrong, but I cannot understand where the mistake is.     

    

Does anyone have any idea?
Thank you very much!  ","It would be more appropriate to use edge sensitivity in the flipflop_jk definition, Also you have included an asynchronous clear signal, with a different value to your reset signal. My example shows this with a synchronous clear.

Your signal capture does not show your reset signal. I assume this is initially low then you take it high after time 0. To set Q to a known value.

module flipflop_jk(
  input      CK,
  input      PRN,
  input      CLN,
  input      J,
  input      K,
  output reg Q
);

always @(posedge CK or negedge PRN) begin
  if (PRN == 1'b0) begin
     Q &lt;= 1'b1 ; 
  end
  else begin
    if (CLN == 1'b0) begin
      Q &lt;= 1'b0 ; 
    end
    else if (J == 1'b1 &amp; K == 1'b1) begin
      Q &lt;= ~Q ; 
    end
    else if (J == 1'b1 &amp; K == 1'b0) begin
      Q &lt;= 1'b1 ; 
    end
    else if (J == 1'b0 &amp; K == 1'b1) begin
      Q &lt;= 1'b0 ; 
    end 
  end
end
endmodule
",,,,,
Signals and Variables in VHDL,"I want to ask about the signals and variables in VHDL, I know the difference between them, but I want to see the difference at simulation.

I used this simple program in Quartus Tool to see the difference between them:

ENTITY test IS PORT (
  a : IN bit;
  y : OUT bit);
END test;

ARCHITECTURE beh OF test IS
SIGNAL x : BIT;
BEGIN
  PROCESS (a)
  BEGIN
    x &lt;= '1';
    IF x = '1' THEN y &lt;= '0' AFTER 8 ns;
    ELSE y &lt;= '1' AFTER 5 ns;
    END IF;
  END PROCESS;
END BEH;


for signals and this for variables:

entity test1 is port (
  a : IN bit;
  y : OUT bit);
end test1;

architecture beh of test1 is
begin
  process (a)
  variable x : bit;
  begin
    x := '1';
    if x = '1' then y &lt;= '0' after 8 ns;
    else y &lt;= '1' after 5 ns;
    end if;
  end process;
end beh;


the i created waveform to see the difference in the first program (y)value should be set to 1 at 5ns,but it doesn't change..Why?

Thank you in advance.","You don't see the difference in waveforms, as the waveform viewer only shows the values of variables at the end of a delta cycle (ie when some real time passes).  If you single-step the code, or add report statements mid process, you can see intermediate values on a variable:

signal s:integer := 0;
process
   variable v:integer := 0;
begin
   report ""Signal=""&amp;integer'image(s)&amp;"" variable=""&amp;integer'image(v);
   s &lt;= 1; v := 1;
   report ""Signal=""&amp;integer'image(s)&amp;"" variable=""&amp;integer'image(v);
   wait for 0 ps; -- end the delta cycle, even 0ps counts as ""time passing""
   report ""Signal=""&amp;integer'image(s)&amp;"" variable=""&amp;integer'image(v);
   wait;
end process;
",,,,,
Verilog: I2C read operation,"In a verilog simulation, I will have to communicate with the 64K I2C EEPROM from Microchip. Every time for getting an ack from slave, I am driving my SDA to high impedance for a given clock period. Now, in order to get data from slave, should I have to follow the same for SDA? Simply, should the SDA ports have to be driven to high impedance state ?","In a physical I2C circuit, there are pull-up resistors that make SCL and SDA go high when their outputs are in their high impedance states.  The Verilog equivalent to the pullup resistor is the TRI1.  This will make the lines defined rather than floating when the signals are in their high impedance state.",,,,,
Arithmetic Right Shift in Verilog,"As part of a processor design, I am implementing a simple behavioral right shifter using Verilog.

The shifter inputs a 32 bit variable and outputs either a right logical shift or a right arithmetic shift based on a variable (input) choice. 

Following is the code:

 module ShiftRight(
  input signed[31:0] inp,
  input [31:0] shamt,
  output [31:0] out,
  input choice
  );

  assign out = (choice)? (inp&gt;&gt;&gt;shamt):(inp&gt;&gt;shamt);


 endmodule


This results in a correct behavioral implementation but gives the following warning during synthesis:

Unit ShiftRight : the following signal(s) form a combinatorial loop: out_shift0000&lt;31&gt;.


(the coeff in brackets is basically the most significant bit of inp, 31 in my case). So I was wondering whether this had anything to do with inp bein signed. ","I'll guess your synthesizer is just exploding at the thought of having to arithmetic shift a vector by 2^32 bits (4,294,967,296), and in it's internal RTL to gates synthesis it's ending up in a circular loop.

Since I'm guessing you don't need to shift by 4 billion bits, maybe you could use a reasonable number for your shift amount?",,,,,
"Verilog Error: Can't elaborate user hierarchy ""counter:counter""","I'm tring to write snake from LED on a Quartus Board. It's kind of like KITT-Leds, but when I try to run my program, I get an error.

module ukol3(KEY,LEDR);
input[1:0]KEY;
output[14:0] LEDR;

counter counter(KEY[0], KEY[1], LEDR[14:0]);

endmodule

module counter(C,CLR,Q);
input C, CLR;
output [14:0] Q;
reg [14:0] tmp;
integer i;

always @(posedge C or posedge CLR)      
    begin

        if (CLR)
            tmp = 15'b000000000000000;

        if (tmp == 15'b111111111111111)
            i = 0;

        if (tmp == 15'b000000000000000)
            i = 1;

        if (i == 1)
            tmp = tmp + 1'b1;

        if (i == 0)
            tmp = tmp - 1'b1;
        end 
    assign Q = tmp;


endmodule


This gives me an error:


  Error: Can't elaborate user hierarchy ""counter:counter""


I really don't know what's going on.","This question is about Verilog, not vhdl. I want to ask a couple of questions: Is your code synthesizable? and what do you get after a synthesis module counter?

For your question, I think you should compile counter first, then compile ukol3. The EDA tool will not find counter when you didn't did it first. You should split it into two separable files and do the counter first.

P.S.: You should use a better mapping port method such as counter counter (.C(KEY[0]),.CLR (KEY[1]),.Q (LEDR[14:0])); for clearer code.",,,,,
VHDL state machine is not looping,"Fellow SO users,

I'm programming my ADC (ADC0804 which is mounted on a breadboard connected to a Spartan-3 FPGA board). Now, I'm using this ADC to provide digital output for my humidity sensor. The ADC outputs an 8-bit value which I'm displaying on the LEDs on the FPGA board. 

Now, I'm writing the state machine in such a way that the ADC would always continue to keep outputting values even when I vary the humidity level. But as for the current implementation I have, eventhough I'm looping back to the first state, I'm not getting a continuous stream of values. I'm only getting one 8-bit value at a time (I.E.; I have to keep pressing the reset button to update the value displayed on the LEDs). The following is my code. 

FSM_NEXT_STATE_INIT :   PROCESS (CLK, RST)
                        BEGIN
                        IF (RST = '1') THEN
                           CURR_STATE &lt;= STARTUP;
                        ELSIF (CLK'EVENT AND CLK = '1') THEN
                            CURR_STATE &lt;= NEXT_STATE;
                        END IF;
                       END PROCESS;

START_FSM   :   PROCESS (CURR_STATE, INTR)
                BEGIN

                CASE CURR_STATE IS

                        WHEN STARTUP =&gt;
                            NEXT_STATE &lt;= CONVERT;
                            WR &lt;= '0';
                            READ_DATA &lt;= '0';


                        WHEN CONVERT =&gt;
                            IF (INTR = '0') THEN
                                NEXT_STATE &lt;= READ1;
                            ELSE
                                NEXT_STATE &lt;= CONVERT;
                            END IF;
                            WR &lt;= '1';
                            READ_DATA &lt;= '0';


                        WHEN READ1 =&gt;
                            NEXT_STATE &lt;= READ2;
                            WR &lt;= '1';
                            READ_DATA &lt;= '1';

                        WHEN READ2 =&gt;
                            NEXT_STATE &lt;= STARTUP;
                            WR &lt;= '1';
                            READ_DATA &lt;= '0';

                        WHEN OTHERS =&gt;
                            NEXT_STATE &lt;= STARTUP;
                END CASE;
                END PROCESS;

                PROCESS (CLK, RST)
                BEGIN
                    IF (RST = '1') THEN
                        Y &lt;= (OTHERS =&gt; '0');
                    ELSIF (CLK'EVENT AND CLK = '1') THEN
                        IF (READ_DATA = '1') THEN
                            Y &lt;= D7&amp;D6&amp;D5&amp;D4&amp;D3&amp;D2&amp;D1&amp;D0; --Concatenate the 8-bit ADC output
                        END IF;
                    END IF;
                END PROCESS;


You'll notice that in state 'READ2', I'm looping back to the beginning (so that I can keep reading values continuously as the states transition) but somehow I don't think this is working. Could anyone please provide some assistance on how to go about solving this?","After a look on the data sheet for the ADC0804 I found following which could be the/a possible reason:

Note: Read strobe must occur 8 clock periods (8/fCLK) after assertion of interrupt to guarantee reset of INTR.

Inserting a WAIT state between CONVERT and READ1 might fix the problem.",,,,,
VHDL - setting sampling rate for a sensor,"Fellow SO users,

I'm trying to sample my resistive humidity sensor at a frequency of 5Hz (5 samples a second). I'm using an ADC to read the output. Now, I've been told that you can run the ADC at any frequency but you need to use a 5hz clock to initiate the conversion and read values from the ADC.

The way I'm doing this is by having a process that initiates the conversion by running at 5hz and having a flag, say ""start_convert"" to '1' on the rising edge of the clock.

PROCESS (CLK_5HZ)       
BEGIN
    IF (CLK_5HZ'EVENT AND CLK_5HZ = '1') THEN
        START_CONVERT &lt;= '1';
    END IF;
END PROCESS;


And then I have a state machine for the ADC;

PROCESS (CURR_STATE, INTR)
                BEGIN

                CASE CURR_STATE IS

                        WHEN STARTUP =&gt;
                            WR &lt;= '0';
                            READ_DATA &lt;= '0';
                            IF (START_CONVERT = '1') THEN
                                NEXT_STATE &lt;= CONVERT;
                            ELSE
                                NEXT_STATE &lt;= STARTUP;
                            END IF;

                        WHEN CONVERT =&gt;
                            IF (INTR = '0' AND STREAM = '1') THEN
                                NEXT_STATE &lt;= WAIT500;
                            ELSIF (INTR = '0' AND STREAM = '0') THEN
                                NEXT_STATE &lt;= READ1;
                            ELSE
                                NEXT_STATE &lt;= CONVERT;
                            END IF;
                            WR &lt;= '1';
                            READ_DATA &lt;= '0';

                        WHEN WAIT10 =&gt;
                            IF (COUNTER_WAIT = 10) THEN
                                NEXT_STATE &lt;= READ1;
                            ELSE
                                NEXT_STATE &lt;= WAIT10;
                            END IF;
                            COUNTER_WAIT &lt;= COUNTER_WAIT + 1;

                        WHEN READ1 =&gt;
                            NEXT_STATE &lt;= CONVERT;
                            WR &lt;= '1';
                            READ_DATA &lt;= '1';

                        WHEN OTHERS =&gt;
                            NEXT_STATE &lt;= STARTUP;
                END CASE;
                END PROCESS;


And then I'm using another process at 5hz to detect whenever READ_DATA is 1 so that I read the values from the ADC.

PROCESS (CLK_5HZ, RST)
    BEGIN
    IF (RST = '1') THEN
    Y &lt;= (OTHERS =&gt; '0');
    ELSIF (CLK_5HZ'EVENT AND CLK_5HZ = '1') THEN
        IF (READ_DATA = '1') THEN
        Y &lt;= DATA_IN (0) &amp; DATA_IN (1) &amp;
         DATA_IN (2) &amp; DATA_IN (3) &amp;
         DATA_IN (4) &amp; DATA_IN (5) &amp;
         DATA_IN (6) &amp; DATA_IN (7);
    END IF;
   END IF;
END PROCESS;


Could anyone please advice me whether this is the right approach or not?

EDIT: I'm interfacing the ADC (ADC0804) using a Spartan-3 board.","It's a bit hard to give specific advice, when not knowing the specifics of the device you are trying to interface to.

However, a couple of general comments regarding your code:


Your asynchronous process (the PROCESS (CURR_STATE, INTR)) will generate quite a few latches when synthesizing it, since you are not setting all your signals in all cases. WR and READ_DATA are for instance not being set in your WAIT10 state. This will most probably lead to severe timing issues, so correcting this is something you'd absolutely want to do.
The WAIT10 state in the same process will give you a combinatorial loop, as it runs whenever COUNTER_WAIT is updated. As that state also updates COUNTER_WAIT, it will in theory just keep running, but in practice most synthesizers will just give you an error (I think). You'll need to move the incrementing to a synchronous/clocked process instead, which will also give you control over how long each cycle takes.
Your 5 Hz processes seem to run on a separate clock (CLK_5HZ). I presume that the rest of your system is running at a faster clock? This essentially gives you two (or more) clock domains, that will need special interface logic for interfacing them with each other. A much, much better solution is to run everything on the same (fast) clock, and control slower processes using clock enables. Everything is thus inherently synchronized, and shouldn't give you any nasty timing surprises.
",,,,,
Is it possible to write verification procedures on simulations in ModelSim?,"I am using ModelSim in order to design and simulate CPU architectures. For those like me who know about this, you are also probably aware that it is really difficult to verify simulation data when trying to handle all those signals in front of you.

Is there a way to automatically run a simulations and perform some verification procedure in order to see if data I get are correct? 

For example, I have a certain component that when stimulated by a signal, in the next clock, will return the negated signal. I want to verify this. How? (of course without manually checking signals on the screen).

Thankyou","Yes, this is known as self-checking test benches. The idea is to write a new VHDL file where you instantiate the component you want to test, apply stimuli to the component and verify the output using assertions. The basic way to do that is with the assert statement, like this:

assert my_signal = x""3456"" report ""my_signal has the wrong value!"" severity ERROR;


Also try looking into PSL, which is another language for verifying behavior of VHDL code. Modelsim has support for both VHDL assertions and PSL.",,,,,
zero flag in verilog problems,"I am attempting to build a 32 bit ALU in verilog and I've only done a small bit of behavioral verilog before, so I'm having some difficulty with this code: 

module ZERO_FLAG(flag, control, inputA, inputB);
  input [2:0] control;
  input [31:0] inputA, inputB;
  output flag;

  reg flag;

  always @(control or inputA or inputB) begin
    case (control)
      1: flag &lt;= (|(inputA ~&amp; inputB));
      3'bxxx, 3'bxx0, 3'bxx1, 3'bx0x,
      3'bx00, 3'bx01, 3'bx1x, 3'bx10,
      3'bx11, 3'b0xx, 3'b0x0, 3'b0x1,
      3'b00x, 3'b000, 3'b01x, 3'b010,
      3'b011, 3'b1xx, 3'b1x0, 3'b1x1,
      3'b10x, 3'b100, 3'b101, 3'b11x,
      3'b110, 3'b111: flag &lt;= 0;
    endcase
  end
endmodule


For some reason Modelsim is simply unhappy with the NAND between inputA and inputB in the case of 1. The basic idea is that I only want to throw a zero flag when subtraction is happening, and then I want the result to be an OR reduced bitwise NAND of the two inputs. Thoughts? ","I would try rewriting the line as:

1: flag &lt;= |(~(inputA &amp; inputB));
",,,,,
Implementing delay in VHDL state machine,"I'm writing a state machine which controls data flow from a chip by setting and reading read/write enables. My clock is running at 27 MHz giving a period of 37 ns. However the specification for the chip I'm communicating with requires I hold my 'read request' signal for at least 50 ns. Of course this isn't possible to do in one cycle since my period is 37 ns.

I have considered I could create an additional state which does nothing but flag the next state to be the one I actually complete the read on, hence adding another period delay (meaning I hold 'read request' for 74 ns), but this doesn't sound like good practice.

The other option is perhaps to use a counter, but I wonder if there's perhaps yet another option I haven't visited yet?

How should one implement delay in a state machine when a state should last longer than one clock period?

Thanks!


(T1 must be greater than 50 ns)
Please see here for the full datasheet.","Delays are only reliably doable using the clock - adding an extra ""tick"" either via an extra state or using a counter in the existing state is perfectly acceptable to my mind.  The counter has the possibility of being more flexible if you re-use the same state machine with a slower external chip (or if you use a different clock frequency to feed the FPGA) - you can just change the maximum count, instead of adding multiple ""wait"" states to the state machine.",,,,,
VHDL change CLK speed,"From this code I create a block, then add CLK, KEY[0] and LEDR[0:15]

   library ieee;
use ieee.std_logic_1164.all;

--library work;
--use work.car_pkg.all;


entity knight_rider2 is
    port (  clk, resetn, clock_button : in std_logic;
        led1, led2, led3, led4, led5, led6, led7, led8, 
        led9, led10, led11, led12, led13, led14, led15 : out std_logic);
end entity knight_rider2;



architecture fsm of knight_rider2 is
    type state_types is (start, forward1, forward2, forward3, 
    forward4, forward5, forward6, forward7, forward8, forward9, 
    forward10,forward11,forward12, forward13, forward14);


    signal state: state_types;
    signal led_states : std_logic_vector(14 downto 0);

begin

             count : process(clk, resetn, clock_button)
begin
  if clock_button = '0' then
    counter   &lt;= 0;
    fsm_pulse &lt;= '0';
  else
    if rising_edge(clk) then
      counter     &lt;= counter + 1;
      fsm_pulse   &lt;= '0';
      if counter = divider then
        fsm_pulse &lt;= '1';
        counter   &lt;= 0;
      end if;
    end if;
  end if;
end process;


    combined_next_current: process (clk, resetn, clock_button)
    begin
        if (resetn = '0') then
            state &lt;= start;
        elsif rising_edge(clk) then
            if fsm_pulse = '1' then
            case state is

                when start =&gt; 
                    state &lt;= forward1;

                when forward1 =&gt;                
                    state &lt;= forward2;              


                when forward2 =&gt;                    
                        state &lt;= forward3;              

                when forward3 =&gt;            
                        state &lt;= forward4;              

                when forward4 =&gt;                    
                        state &lt;= forward5;                  


                when forward5 =&gt;                
                        state &lt;= forward6;                  


                when forward6 =&gt;                    
                        state &lt;= forward7;                  


                when forward7 =&gt;                
                            state &lt;= forward8;              

                when forward8 =&gt;                    
                            state &lt;= forward9;      


                when forward9 =&gt;                    
                            state &lt;= forward10;                     

                when forward10 =&gt;                       
                            state &lt;= forward11;


                when forward11 =&gt;                   
                            state &lt;= forward12;                 


                when forward12 =&gt;                       
                            state &lt;= forward13;


                when forward13 =&gt;                       
                            state &lt;= forward14;



                when forward14 =&gt; state &lt;=start;

                when others =&gt;
                state &lt;= forward1;

            end case;
        end if;
    end process;


    --combinational output logic

    --internal signal to control state machine transistions


    led_select : process(state)
begin
  case state is
    when forward1 =&gt;
     led_states &lt;= ""000000000000011"";
     when forward2 =&gt;
     led_states &lt;= ""000000000000110"";
    when forward3 =&gt;
     led_states &lt;= ""000000000001100"";
    when forward4 =&gt;
     led_states &lt;= ""000000000011000"";
     when forward5 =&gt;
     led_states &lt;= ""000000000110000"";
     when forward6 =&gt;
     led_states &lt;= ""000000001100000"";
     when forward7 =&gt;
     led_states &lt;= ""000000011000000"";
     when forward8 =&gt;
     led_states &lt;= ""000000110000000"";
     when forward9 =&gt;
     led_states &lt;= ""000001100000000"";
     when forward10 =&gt;
     led_states &lt;= ""000011000000000"";
     when forward11=&gt;
     led_states &lt;= ""000110000000000"";
     when forward12=&gt;
     led_states &lt;= ""001100000000000"";
     when forward13=&gt;
     led_states &lt;= ""011000000000000"";
     when forward14=&gt;
     led_states &lt;= ""110000000000000"";
     when others =&gt;
     led_states &lt;= ""100000000000001"";

  end case;
end process;

led1 &lt;= led_states(0);
led2 &lt;= led_states(1);
led3 &lt;= led_states(2);
led4 &lt;= led_states(3);
led5 &lt;= led_states(4);

led6 &lt;= led_states(5);
led7 &lt;= led_states(6);
led8 &lt;= led_states(7);
led9 &lt;= led_states(8);
led10 &lt;= led_states(9);

led11 &lt;= led_states(10);
led12 &lt;= led_states(11);
led13 &lt;= led_states(12);
led14 &lt;= led_states(13);
led15 &lt;= led_states(14);





end;


But now I want add KEY[1] button to change speed, for example:

1st press : 2*f

2 press: 4*f 

3 press: 8*f

4 press: f

5 press: 2*f etc

So, how can I change this code to do what I want?","You can change the rate that your state machine operates at by employing a counter, for example:

-- Generate a counter at your main clock frequency
-- counter is declared as an integer.
count : process(clock, resetn)
begin
  if resetn = '0' then
    counter   &lt;= 0;
    fsm_pulse &lt;= '0';
  else
    if rising_edge(clock) then
      counter     &lt;= counter + 1;
      fsm_pulse   &lt;= '0';
      if counter = divider then
        fsm_pulse &lt;= '1';
        counter   &lt;= 0;
      end if;
    end if;
  end if;
end process;


The new signals are declared as follows:

signal fsm_pulse : std_logic;
signal counter   : integer;
signal divider   : integer;


Then, in your FSM process you can trigger state transitions using the fsm_pulse you generated:

combined_next_current: process (clk, resetn)
begin
    if (resetn = '0') then
        state &lt;= start;
    elsif rising_edge(clk) then
      if fsm_pulse = '1' then
        case state is
            when start =&gt; 
                state &lt;= forward1;
            when forward1 =&gt;                
                state &lt;= forward2; 

        ...

        etc (your remaining states)
      end if;


The fsm_pulse will be set to '1' for a single clock cycle whenever the counter reaches the divider value you have chosen. The divider value represents the number of clock cycles you desire each FSM transition to occur after, for example a divider of zero will make the FSM transition at the main clock frequency and a divider of 1 will make the FSM transition at halve the main clock frequency.",,,,,
Copy filename (with wildcard) in tcl,"I'm trying to copy a file using a wildcard and it isn't being interpreted correctly. 

set projName [lindex $argv 0]
puts ""$projName chosen""

set sysdefPath ""$projName/$projName.runs/impl_1/*.sysdef""
file copy -force $sysdefPath ./src/generatedFiles/$projName.hdf


I've tried a couple of variations of this but none have worked {*}, (*), [*], {.*}. The result of this places the wildcard (*) in the search path instead of trying to pattern match it. 

What is the correct way to perform this?

Output,

$ test.tcl -tclargs proj
# set projName [lindex $argv 0]
# puts ""$projName chosen""
proj chosen
# set sysdefPath ""$projName/$projName.runs/impl_1/*.sysdef""
# file copy -force $sysdefPath ./src/generatedFiles/$projName.hdf
error copying ""proj/proj.runs/impl_1/*.sysdef"": no such file or directory
    while executing
""file copy -force $sysdefPath ./src/generatedFiles/$projName.hdf""
    (file ""./src/projTcls/build_bitstream.tcl"" line 5)
","Your shell will expand file patterns wherever it finds them. Tcl is not like that: you have to explicitly ask for the list of files matching a pattern using the glob command: untested

set pattern $projName/$projName.runs/impl_1/*.sysdef
set sysdefPaths [glob -nocomplain -- $pattern]
switch -exact [llength $sysdefPaths] {
    0 {error ""No files match $pattern""}
    1 {file copy -force [lindex $sysdefPaths 0] ./src/generatedFiles/$projName.hdf}
    default {error ""Multiple files match $pattern: [list $sysdefPaths]""}
}
",,,,,
Max Number of Iterations/Clock Cycle,"How to calculate maximum number of iterations executed in one Clock Cycle of a given frequency in System Verilog. 

For example: Clock = 50MHz. How many iterations of a for loop can I execute in one cycle? ","It depends on what kind of logic the for loop represents. As an example, consider a loop that counts the number bits set in a bus. That would get unrolled into a chain of adders. So you would need to look at the delay across each adder. ",,,,,
Using integers from a large single line text file for testbench,"I have a file with a large number of integers, it looks like:

123 254 360 700 800 900 1000 354 778 897 663 554 888 776 654 655 231 900 777 666 667 776 887 991 555 888 778 666 111 2232 444 545 667 ...  


I have written a VHDL code (algorithm) to analyze this file which stores the several characteristics of this file. I want to write a test bench for this algorithm which takes a value (integer) at a time gives it to my algorithm as an input and moves on to next value.

At the end of the file, this test bench should take the output stored in the algorithm write the result in a separate text file.

The caveat here is that its a large single line file separated by spaces. I tried solutions like Read textfile in VHDL testbench but they are not suitable for single line file.","If you are not memory-limited you can just read the whole line at once and then parse it one integer at a time until the last integer. Example:

use std.textio.all;

entity foo is
end entity foo;

architecture arc of foo is
begin
  process
    variable l: line;
    file f: text is ""foo.txt"";
    variable i: integer;
    variable good: boolean;
  begin
    readline(f, l); 
    loop
      read(l, i, good);
      exit when not good;
      report integer'image(i);
    end loop;
    wait;
  end process;
end architecture arc;


If your file is larger than what your available memory can afford, you'll have to split the readline in smaller chunks but here std.textio will not help and you will have to use lower level read procedures and custom file type of characters. But, personally, I would probably use some shell utilities to split the super-long line is shorter ones. Programming in VHDL is funny but when the problem to solve is too far from hardware, the fun is getting less significant.",,,,,
How to generate different types of component,"I have 3 different types of component. For example type0, type1 and type2. They all have the same ports but functions. I want to use a constant like 0, 1 and 3 to put the corresponding component in my top design.  I want to know the way to do this. 

Best regards","You could use a generate statement, eg:

G0 : if SOME_CONSTANT = 0 generate
  I0 : type0 ( ...
end generate;
G1 : if SOME_CONSTANT = 1 generate
  I1 : type1 ( ...
end generate;
G2 : if SOME_CONSTANT = 2 generate
  I2 : type2 ( ...
end generate;
-- etc


If you use VHDL-2008, there is a case-generate statement:

G : case SOME_CONSTANT generate
  when 0 =&gt;
    I0 : type0 ( ...
  when 1 =&gt;
    I1 : type1 ( ...
  when 2 =&gt; 2 
    I2 : type2 ( ...
  -- etc
end generate;
",,,,,
SystemVerilog: Automatic variables cannot have non-blocking assignments appearing for static reg,"I start getting this error after I actually make a register static.

This complies fine in Quartus:

task InitAutoRefresh;

       reg [$clog2(AUTOREFRESH_CLOCKS):0] AutoRefreshCounter = 0;

       AutoRefreshCounter &lt;= AutoRefreshCounter + 1;
       InitState &lt;= (AutoRefreshCounter &lt; AUTOREFRESH_CLOCKS) ? InitState : InitState + 1;       

       InitCmd &lt;= (AutoRefreshCounter == 0) ? CMD_AR : CMD_NOP;

endtask


But Modelsim gives me this error:

# ** Error (suppressible): C:/projects/Camera-RAM-VGA/Ram.sv(137): (vlog-2244) Variable 'AutoRefreshCounter' is implicitly static. You must either explicitly declare it as static or automatic
# or remove the initialization in the declaration of variable.


Now when I add static in front of reg [$clog2(AUTOREFRESH_CLOCKS):0] AutoRefreshCounter = 0; Quartus gives me this error (which looks to be the opposite of my change):

Error (10959): SystemVerilog error at Ram.sv(139): illegal assignment - automatic variables can't have non-blocking assignments


And this points to the register that I've just added the static keyword for!

The only possible explanation I can think of is that when I add static to this single reg it starts treating other regs as automatic, but then the line number in the error message is wrong.","I would simply move the declaration of AutoRefreshCounter outside of the task. Then it is clear that the variable is to be initialized only once at time 0. (That is the reason for the ""Implicitly static"" error  message in the first place).",,,,,
MIG MCB Unexpected Write Behavior,"So I recently inhereted a project that has a generated MCB implemented in the design. I have never debugged IP cores before so you'll have to forgive me is the solution to my problem is obvious. I've been working on this problem for a day or two and can't seem to figure it out.

First off, I have read the documentation UG388, UG406, UG416 a few times through and done a bit of research with no luck.

As I understand the parameters, the MCB is setup in configuration-1 is what I get from: 

    localparam C3_PORT_ENABLE             = 6'b111111;
    localparam C3_PORT_CONFIG             =  ""B32_B32_R32_R32_R32_R32"";
    localparam C3_P0_PORT_MODE             =  ""BI_MODE"";
    localparam C3_P1_PORT_MODE             =  ""BI_MODE"";
    localparam C3_P2_PORT_MODE             =  ""RD_MODE"";
    localparam C3_P3_PORT_MODE             =  ""RD_MODE"";
    localparam C3_P4_PORT_MODE             =  ""RD_MODE"";
    localparam C3_P5_PORT_MODE             =  ""RD_MODE"";


And is set to interface with DDR2 memory. I'm not sure what other information would be important for this problem, but I can post more if you need it.
Here is some additional parameters that I think will be helpful:

localparam C3_NUM_DQ_PINS          = 16;
localparam C3_MEM_ADDR_WIDTH       = 13;
localparam C3_MEM_BANKADDR_WIDTH   = 3;
localparam C3_MEM_ADDR_ORDER       = ""ROW_BANK_COLUMN"";
localparam C3_P0_MASK_SIZE          = 4;
localparam C3_P0_DATA_PORT_SIZE     = 32;


Also, I should mention that the design only uses a single port (p0). 
Onto the behavior, the generated MCB comes with an Example_design that includes a TB and I have ran than to my success with no errors.

Now I'm trying to setup my own tb that performs a simple write and read.
I'm able to write 32 bits in and read the same the 32 bits out, but the problem is that the Memory unit reads in sequence of 4 - 16 bit values everytime. This means half the data it writes is ""XXXX"" and can't figure out how to fill that space with meaningful data. Here is my output (Last few lines show the problem, the first part is just inititailization stuff that might be helpful):

ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 438401.0 ps WARNING: 200 us is required before CKE goes active.
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 460801.0 ps INFO: Precharge All
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 486401.0 ps INFO: Load Mode 2
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 486401.0 ps INFO: Load Mode 2 High Temperature Self Refresh rate = 1X (0C-85C)
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 499201.0 ps INFO: Load Mode 3
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 512001.0 ps INFO: Load Mode 1
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 512001.0 ps INFO: Load Mode 1 DLL Enable = Enabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 512001.0 ps INFO: Load Mode 1 Output Drive Strength = Full
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 512001.0 ps INFO: Load Mode 1 ODT Rtt = 50 Ohm
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 512001.0 ps INFO: Load Mode 1 Additive Latency =           0
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 512001.0 ps INFO: Load Mode 1 OCD Program = OCD Exit
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 512001.0 ps INFO: Load Mode 1 DQS_N Enable = Enabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 512001.0 ps INFO: Load Mode 1 RDQS Enable = Disabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 512001.0 ps INFO: Load Mode 1 Output Enable = Enabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 524801.0 ps INFO: Load Mode 0
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 524801.0 ps INFO: Load Mode 0 Burst Length =  4
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 524801.0 ps INFO: Load Mode 0 Burst Order = Sequential
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 524801.0 ps INFO: Load Mode 0 CAS Latency =           5
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 524801.0 ps INFO: Load Mode 0 Test Mode = Normal
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 524801.0 ps INFO: Load Mode 0 DLL Reset = Reset DLL
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 524801.0 ps INFO: Load Mode 0 Write Recovery =           5
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 524801.0 ps INFO: Load Mode 0 Power Down Mode = Fast Exit
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 537601.0 ps INFO: Precharge All
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 563201.0 ps INFO: Refresh  
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 691201.0 ps INFO: Refresh  
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 819201.0 ps INFO: Load Mode 0
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 819201.0 ps INFO: Load Mode 0 Burst Length =  4
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 819201.0 ps INFO: Load Mode 0 Burst Order = Sequential
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 819201.0 ps INFO: Load Mode 0 CAS Latency =           5
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 819201.0 ps INFO: Load Mode 0 Test Mode = Normal
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 819201.0 ps INFO: Load Mode 0 DLL Reset = Normal
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 819201.0 ps INFO: Load Mode 0 Write Recovery =           5
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 819201.0 ps INFO: Load Mode 0 Power Down Mode = Fast Exit
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 832001.0 ps INFO: Load Mode 1
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 832001.0 ps INFO: Load Mode 1 DLL Enable = Enabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 832001.0 ps INFO: Load Mode 1 Output Drive Strength = Full
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 832001.0 ps INFO: Load Mode 1 ODT Rtt = 50 Ohm
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 832001.0 ps INFO: Load Mode 1 Additive Latency =           0
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 832001.0 ps INFO: Load Mode 1 OCD Program = OCD Default
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 832001.0 ps INFO: Load Mode 1 DQS_N Enable = Enabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 832001.0 ps INFO: Load Mode 1 RDQS Enable = Disabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 832001.0 ps INFO: Load Mode 1 Output Enable = Enabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 844801.0 ps INFO: Load Mode 1
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 844801.0 ps INFO: Load Mode 1 DLL Enable = Enabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 844801.0 ps INFO: Load Mode 1 Output Drive Strength = Full
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 844801.0 ps INFO: Load Mode 1 ODT Rtt = 50 Ohm
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 844801.0 ps INFO: Load Mode 1 Additive Latency =           0
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 844801.0 ps INFO: Load Mode 1 OCD Program = OCD Exit
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 844801.0 ps INFO: Load Mode 1 DQS_N Enable = Enabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 844801.0 ps INFO: Load Mode 1 RDQS Enable = Disabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 844801.0 ps INFO: Load Mode 1 Output Enable = Enabled
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 844801.0 ps INFO: Initialization Sequence is complete
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 864001.0 ps INFO: Precharge All
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 1382401.0 ps INFO: Activate  bank 0 row 0000
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .cmd_task: at time 1395201.0 ps INFO: Write     bank 0 col 080, auto precharge 0
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .main: at time 1401601.0 ps INFO: Sync On Die Termination = 1
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .data_task: at time 1409601.0 ps INFO: WRITE @ DQS= bank = 0 row = 0000 col = 00000080 data = 5678
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .data_task: at time 1411201.0 ps INFO: WRITE @ DQS= bank = 0 row = 0000 col = 00000081 data = 1234
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .data_task: at time 1412801.0 ps INFO: WRITE @ DQS= bank = 0 row = 0000 col = 00000082 data = xxxx
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .data_task: at time 1414401.0 ps INFO: WRITE @ DQS= bank = 0 row = 0000 col = 00000083 data = xxxx
ReadWrite_MIG_tb.\MEM_INST3.u_mem_c3 .main: at time 1422401.0 ps INFO: Sync On Die Termination = 0


At the time the p0_cmd is put into the cmd FIFO, the p0_wr_count is 3 (I filled it with a few extra in case that was the problem). The example_design tb also performs 4 consecutive writes, but their isn't ""XXXX"".

I've been comparing my waveform to the tb and to UG388 and it really seems like I'm replicating it correctly, but not sure what's causing this behavior. How can I fill the ""XXXX"" with data or stop it from writing the extra values?

Any help would be greatly appreciated!","It would seem that after a few days and restarting my computer, the issue seems to have resolved itself. I can't recall making any significant changes and am now unable to replicate the behavior that I previously described.

For now, I can consider this issue resolved, but I will update this if I discover anything new. I thought it would be something trivial, but this is just unexplainable.",,,,,
Modifying queue of class in systemverilog function,"I met a problem when I trying to modify a queue of class in systemverilog function.

Here are the codes:

module my_module;

class dscr;
   logic mode;

   function void print_dscr;
        $display(""mode = %d"", this.mode);
   endfunction
endclass

dscr a_dscr_q[$];
dscr b_dscr_q[$];

initial begin 
    descriptor_decode(0, a_dscr_q);
    for (int I=0; I&lt;a_dscr_q.size(); i++)
       a_dscr_q[i].print_dscr();

    descriptor_decode(1, b_dscr_q);
    for (int I=0; I&lt;a_dscr_q.size(); i++)
       a_dscr_q[i].print_dscr();
    for (int I=0; I&lt;b_dscr_q.size(); i++)
       b_dscr_q[i].print_dscr();
end


function void descriptor_decode(logic mode, ref dscr dscr_q[$]);
    dscr dscr_dec = new;
    dscr_dec.mode = mode;

    dscr_q.pushback(dscr_dec);
endfunction

endmodule


I am trying to create different class queue in function ""descriptor_decoder"", with different value of input mode. In function, I firstly create a new dscr class and then push it to a class queue. However the simulation result are:

mode = 0
mode = 1
mode = 1


The first time I call the function, it did push back the correct class into a_dscr_q. But the second function call, it seems the class is push back into both a_dscr_q and b_dscr_q. I am quite confused, What happened in here?","Your code was made illegal syntax in the IEEE 1800-2009 LRM because of the very problem you are experiencing. Most tools now report this as an error.

Your descriptor_decode is function with a static lifetime, and the dscr_dec variable declared inside it has a static lifetime as well. 

You are not allowed to have an initialization on a variable whose lifetime is implicitly static and has the option to be declared automatic. This is because unlike most programming languages, the default lifetime of variables in a SystemVerilog function is static, and initialization of static variables happens once before time 0, not each occurrence of calling the function. In your example, you are expecting dscr_dec to behave as an automatic. 
So you need to make one of the following code changes:


explicitly declare dscr_dec automatic 
declare the function automatic, which makes variables declared inside it implicitly automatic 
declare the module automatic, which makes functions declared inside it implicitly automatic 
split the declaration and initialization do that the initialization happens when the function gets called.
",,,,,
FSM state machine in Verilog,"If there is no reset in the input, how do you set the initial state to state_0 ? 

reg[2:0]    state;


localparam  s0 = 3'b000, s1 = 3'b001, s2 = 3'b010, s3 = 3'b011, s4 = 
3'b100, s5 = 3'b101;    
assign  state = s0; /* NOT SURE IF THIS IS RIGHT!*/


localparam  i=0, j=64, k=0, h=0; 


always @ ( posedge clk ) begin

case( state )

        s0: ........
","No that will not work, because an assign statement will force state = s0 all the time. The compiler will also complain about multiple drivers setting state. If there is no reset signal, one option is:

initial begin
  // set any initial values
  state = s0;
end


This would go in place of where you have the assign statement. This works well in simulation, but an even better practice would be to modify your state logic:

localparam  s0 = 3'b000, s1 = 3'b001, s2 = 3'b010, s3 = 3'b011, s4 = 3'b100, s5 = 3'b101;
reg [2:0] state, next_state;

always @(posedge clk) begin
  state &lt;= next_state;
end

always @(state) begin
  case (state)
  // modify this state logic to reflect your FSM
  s0: next_state &lt;= s1;
  s1: next_state &lt;= s2;
  s2: next_state &lt;= s3;
  s3: next_state &lt;= s4;
  s4: next_state &lt;= s5;
  s5: next_state &lt;= s0;
  // this controls the behavior at bringup w/o a reset
  // you should include a default case even with a reset
  default: next_state &lt;= s0;
  endcase
end

always @(state) begin
  case (state)
  // modify this output logic to reflect your FSM
  s0: // set your output signals accordingly
  s1: // set your output signals accordingly
  s2: // set your output signals accordingly
  s3: // set your output signals accordingly
  s4: // set your output signals accordingly
  s5: // set your output signals accordingly
  // this controls the behavior at bringup w/o a reset
  // you should include a default case even with a reset
  default: // set all outputs to 0
  endcase
end


The separation of the logic into the clocked always block and the combinational state transition logic above helps to create a latch-free design. I know it's more than what you asked, but this coding style helps create good synthesized designs.",,,,,
Error: Iteration limit 5000 reached at time xxx ns,"I was reading the book ""Verilog Hdl"" by Samir Palnitkar. At the end of chapter 6 there is this exercise: design a synchronous counter using master-slave JK flip-flops. However I am struggling with the JK flip-flop part.
Here's the JK flip-flop circuit provided in the book:


And here's my Verilog code for the above circuit (I have checked it multiple times, hopefully there's no stupid mistake):

module test(in1, in2, clk, out, clr);
    input in1, in2, clk, clr;
    output out;

    mJKff wtf(
        .Q(out),
        .J(in1),
        .K(in2),
        .clk(clk),
        .clr(clr));

endmodule

module mJKff(Q, J, K, clk, clr);
    output Q;
    input J, K, clk, clr;

    wire
        a, b, c, d, y, ybar, cbar, qbar;

    assign
        a    = ~(qbar &amp; J &amp; clk &amp; clr),
        b     = ~(clk &amp; K &amp; Q),
        y     = ~(a &amp; ybar),
        ybar = ~(y &amp; clr &amp; b),
        c    = ~(y &amp; cbar),
        d    = ~(ybar &amp; cbar),
        cbar = ~clk;

    assign
        qbar = ~(Q &amp; clr &amp; d),
        Q    = ~(c &amp; qbar);

endmodule


The code compiled successfully, I use Quartus Prime v18.0 for simulation and get this error:


  
    Error (suppressible): (vsim-3601) Iteration limit 5000 reached at time xxx ns.
  


""xxx"" is exactly at the moment when 'clk' is rising and J = 1; K = 0; clr = 1
What's wrong?","You need to add delays in your circuit; without them the loops in your logic run infinitely in simulation; example:

assign #1 qbar = ~(Q &amp; clr &amp; d);
",,,,,
array bit parameter range in verilog - underflow or -1,"What should be index ranges of parameter init in this case:

parameter zero = 0;

parameter bit[31:0] size = 32'b01;

parameter bit[((zero * size) - 1):0] init = 2'b11;


It should be [-1:0] or [4294967295:0] and why? Is such behavior standardized or it depends on tool?","According to the LRM, the range in an array declarations are signed integer expressions. It should cast the 32-bit unsigned expression to a signed integer. So the result is -1. You can test this by displaying the result of $left(init)

Whether all tool developers have read the LRM is another question.",,,,,
Using DCM Locked output in Spartan 3 FPGA,"I'm using the DCM on the Spartan-3 FPGA which has a LOCKED output signal. I need my clock distributed when it is ready, otherwise it should be zero. Is there any problem with defininga signal which is ""CLKOUT and LOCKED"" which is used by further entities or do I run into trouble with routing that clock through an and gate?","You're looking for a BUFGCE

Usually, I use the LOCKED port of a pll to generate the synchronous deassertion reset (RST_N) for my CLK and not for enabling the CLK. It depends on your design which I don't know...

process (CLK,LOCKED)
begin
  if (LOCKED = '0') then
    rst_n_in &lt;= '0';
    RST_N    &lt;= '0';
  elsif (rising_edge(CLK)) then
    rst_n_in &lt;= '1';
    RST_N    &lt;= rst_n_in ;
  end if;
end process;
",,,,,
Verilog assign part of array memory,"I've trying to define some part of a memory array in Verilog such as this one

module test (
  input clk,
  input [7:0]  in1,
  input [23:0] in2
);

wire [7:0] array_in2 [2:0];
reg  [7:0] buffer    [5:0];

genvar i;

generate
  for (i = 0; i &lt; 3; i = i + 1) begin: fillmsg
    assign array_in2[i] = in2[i*8 +:8];
  end
endgenerate

always @(posedge clk) begin
  //buffer &lt;= {8'd0, in1, 8'd1, array_in2}; // does not work
  buffer[0] &lt;= 8'd0;
  buffer[1] &lt;= in1;
  buffer[2] &lt;= 8'd1;
  buffer[5:3] &lt;= array_in2; // &lt;--- does not work either
end

endmodule


but I haven't been successful. Does anyone have an idea how this assignment could be done? 

EDIT:

As dave_59 suggested one way to do the assignment would be one array element  at a time

integer j;
always @(posedge clk) begin
  for (j=0; j&lt;3; j=j+1) begin
    buffer[i+3] &lt;= array_in2[i];
  end
end
",Verilog does not allow operations on more than one array element at a time. You need to move to SystemVerilog for your code to work. Just changing the file extension to *.sv is usually all you need to do. Then both your assignments should work. ,,,,,
"In which phase ""Initial"" blocks are executed?","I have an interface signal, that I initialize in an initial block in my top module.
In a test, I want to randomize its value by the mean of randomize(). But the problem I don't know in which phase I should call the randomization function.
Would calling randomize() at build() phase be correct ?

Thank you,","Assuming you call uvm_pkg::run_test() from an initial block in a module, run_test() will start all the UVM phases after a delta delay. That means all other initial block have a chance to execute before any UVM phase begin.  

The UVM recommends that you not drive any signals until the start_of_simulation() phase or later.",,,,,
Synthesizable arithmetic shift in Verilog,"I recently came across this answer on stackoverflow. 


  With Verilog, once you take a part-select, the result is unsigned. Use the $signed system task on the part select to make it signed.


Is this method synthesizable (ie the system task $signed) 

If it is not synthesizable, is there a different way to perform arithmetic shift on variables like a &lt;= a&gt;&gt;&gt;2 (this should give the quotient when a is divided by 4).","It certainly is synthesizable. Whether your particular tool supports it is another question.

You can also use a cast in SystemVerilog. 

res = signed'(registers[0][0]) &gt;&gt;&gt; 2;
",,,,,
"When do we use ""typedef class xxxxx"" in uvm?","I'm not familiar with uvm, but trying to understand and studying.

I found the below code when I leaning the UVM.

typedef class driver; 
typedef class monitor; Â  

class env; driver d0; 
monitor mon0; Â  
function init_drvr (); 
d0 = new (); // initialize endfunction Â  
function init_mon (); 
mon0 = new (); // initialize endfunction endclass
endfunction
endclass


Especially 

typedef class driver; 
typedef class monitor; Â  


Probably it seems like declare something, but why those typedef is in there?

Would you please let me know why do we use 

typedef class driver; 

typedef class monitor; Â  


and how to understand this grammar?","It is rare that you would need typedef class name in SystemVerilog. Most programming languages require that identifiers used as type names be declared before they can be referenced syntactically. One place that occurs is if you have cyclical class references

class X;
  Y has_a_Y;
endclass
class Y;
  X has_a_X;
endclass


In order to compile the code for class X, class Y must be declared. If you change the compile order of the classes, then X becomes unknown. So we use what is called a forward typedef

typedef class Y;
class X;
  Y has_a_Y;
endclass


Now class X compiles as long as class Y gets defined before closing the current scope.

However, the UVM strongly discourages this kind of coding as these dependencies make the code less reusable. 

Sometimes people use a forward typedef even when there are no cyclical dependencies because they are too lazy to compile their code in the correct dependency order. ",,,,,
SystemVerilog changing port type from wire to logic gives error when usingn default_nettype none,"I am converting my design from Verilog to SystemVerilog and by default I have 'default_nettype none directive. Here is my design:

`default_nettype none

module my_design 
#(
parameter INPUT_WIDTH  = 16,
parameter OUTPUT_WIDTH = 2*INPUT_WIDTH
)
(
    input  wire signed [INPUT_WIDTH-1 : 0 ]  x_in,
    input  wire signed [INPUT_WIDTH-1 : 0 ]  y_in,
    output wire signed [OUTPUT_WIDTH-1 : 0]  z_out
);


Which compiles whithout any issue. However, when I change wire to logic as follow:

module my_design 
#(
parameter INPUT_WIDTH  = 16,
parameter OUTPUT_WIDTH = 2*INPUT_WIDTH
)
(
    input  logic signed [INPUT_WIDTH-1 : 0 ]  x_in,
    input  logic signed [INPUT_WIDTH-1 : 0 ]  y_in,
    output logic signed [OUTPUT_WIDTH-1 : 0]  z_out
);


I am getting the following error for all my port signals:

ERROR: [VRFC 10-1103] net type must be explicitly specified for 'x_in' 
when default_nettype is none


Which is very strange to me since I have explicitly decalred all the ports. I am using Vivado Simulator 2018.2. I am using the following command to compile the above codes:

xvlog --sv -f files.f


And files.f contains my design and test file only.","Input ports are implicitly wire net types with an implicit logic data type. SystemVerilog chose these defaults to be backward compatible with Verilog. 

So your original Verilog input declaration was an explicit wire with an implicit logic data type. You changed it to an implicit wire nettype with an explicit logic data type.  But the result is functionally the same. You need to add back the wire keyword. 

The following are all functionally equivalent:

 input signed [INPUT_WIDTH-1 : 0 ]  x_in, // implicit wire logic
 input logic signed [INPUT_WIDTH-1 : 0 ]  x_in, // implicit wire
 input wire signed [INPUT_WIDTH-1 : 0 ]  x_in, // implicit logic
 input wire logic signed [INPUT_WIDTH-1 : 0 ]  x_in, // explicit
",,,,,
Configure GCC target CPU,"I have a Zynq 7000 target hardware. I consists of a dual core ARM Cortex A-9 with NEON and VFP co-processor. The co-processor must be enabled with an write access to the FPEXC register.

The Enabling NEON and FPU for bare-metal shows corresponding code. The problem is that GCC (GNU assembler) doesn't accept the code. The error is:


  Error: selected processor does not support requested special purpose register -- `msr fpexc,r0'


The complete minimal source code example is here:

  .text

  .global enableNeon
 enableNeon:
    mrc p15,0,r0,c1,c0,2    // Read CP Access register
    orr r0,#0x00f00000      // Enable full access to NEON/VFP (Coprocessors 10 and 11)
    mcr p15,0,r0,c1,c0,2    // Write CP Access register
    isb
    mov r0,#0x40000000      // Switch on the VFP and NEON hardware
    msr fpexc,r0            // Set EN bit in FPEXC
    bx lr

  .end


The GCC compiler of the Xilinx-SDK is started with these options:

arm-none-eabi-gcc -c -o ""monitor.o"" -mcpu=cortex-a9 -mfpu=neon-vfpv4  monitor.s


It looks like the GCC did not recognize that the CPU has the FPEXC register.
How can I configure the GCC to enable code generation for that CPU, coprocessor, and the special purpose register FPXEC?","The GNU assembler wants to see a VMSR instruction for this register:

 vmsr fpexc,r0            // Set EN bit in FPEXC
",,,,,
VHDL equivalent of Verilog localparam,"I found the following statement in a verilog modul:

localparam str2=""  Display Demo  "", str2len=16;


Seems to me that str2 is a string value but I wonder how this is processed in the following code snippet. 

always@(write_base_addr)
    case (write_base_addr[8:7])//select string as [y]
    0: write_ascii_data &lt;= 8'hff &amp; (str1 &gt;&gt; ({3'b0, (str1len - 1 - write_base_addr[6:3])} &lt;&lt; 3));//index string parameters as str[x]
    1: write_ascii_data &lt;= 8'hff &amp; (str2 &gt;&gt; ({3'b0, (str2len - 1 - write_base_addr[6:3])} &lt;&lt; 3));
    2: write_ascii_data &lt;= 8'hff &amp; (str3 &gt;&gt; ({3'b0, (str3len - 1 - write_base_addr[6:3])} &lt;&lt; 3));
    3: write_ascii_data &lt;= 8'hff &amp; (str4 &gt;&gt; ({3'b0, (str4len - 1 - write_base_addr[6:3])} &lt;&lt; 3));
    endcase


Will the string value be convertet into a bit value first? Write_ascii_data is only 8 bits long, seems to me that it is too short for fully storing the end result of the case process. Is there any vhdl equivalent of localparam string ?","Verilog has no string types. A string literal gets converted to the equivalent ASCII bit vector, 8 bits per character. So str2 is a 128 bit vector parameter. The RHS expressions are shifting str2 to the left by some multiple of 8 bits, selecting one ASCII character.",,,,,
Verilog - Nonblocking statement confusion,"I always thought that with non-blocking statements, that they all occur in parallel at the end of the always block.

But consider this example I found:

https://www.nandland.com/articles/blocking-nonblocking-verilog.html

always @(posedge i_clock)
begin
  r_Test_1 &lt;= 1'b1;
  r_Test_2 &lt;= r_Test_1;
  r_Test_3 &lt;= r_Test_2;
end


It says that ""The always block in the Verilog code above uses the Nonblocking Assignment, which means that it will take 3 clock cycles for the value 1 to propagate from r_Test_1 to r_Test_3.""

That doesn't make any sense. If it takes 3 clock cycles for the value to propagate then surely it's happening in series too and not in parallel?","Nonblocking statements do run in parallel every time the always block is run. However, each assignment uses the previous value of the right hand side when assigning. If we simulate the design, we can see this behavior:



Initially, all of the signals have a value of 0, however on the first rising edge r_Test_1 takes on a value of 1, while the other two registers stay 0. This is because r_Test_2 is assigned the value of r_Test_1 just before the clock edge, and r_Test_1 is 0 just before the rising edge. 

A similar behavior happens on the second rising edge, this time with r_Test_2 and r_Test_3. r_Test_2 becomes 1 on the second rising edge because this time r_Test_1 had a value of 1 just before the clock edge, but because r_Test_2 was still 0 just before this edge, r_Test_3 remains 0.

Let's contrast this with the behavior of this code:

always @(posedge i_clock)
begin
    r_Test_1 = 1'b1;
    r_Test_2 = r_Test_1;
    r_Test_3 = r_Test_2;
end




Because I've used blocking assignments here, each register is assigned the value immediately instead of the assignment being deferred until the end of the always block. Because of this, when r_Test_2 is being assigned, r_Test_1 already has a value of 1, and likewise with r_Test_3 and r_Test_2, so all 3 signals take a value of 1 on the first cycle. 

Now that I am using blocking assignments, order has become important. So if I rearrange the code to look like this: 

always @(posedge i_clock)
begin
    r_Test_1 = 1'b1;
    r_Test_3 = r_Test_2;
    r_Test_2 = r_Test_1;
end


I then get a different result from the second simulation: 


Challenge: why is this so?

Full test bench:

`timescale 1ns/1ps
module test;
    reg i_clock = 0;

    reg r_Test_1 = 0;
    reg r_Test_2 = 0;
    reg r_Test_3 = 0;

    initial begin
        $dumpfile(""dump.vcd"");
        $dumpvars;
        #100 $finish;
    end

    always #5 i_clock &lt;= ~i_clock;

    always @(posedge i_clock)
    begin
        r_Test_1 &lt;= 1'b1;
        r_Test_2 &lt;= r_Test_1;
        r_Test_3 &lt;= r_Test_2;
    end
endmodule
",,,,,
"Combinatorial assignment to ""composite"" wire in always block","This is not a blocker that I'm dealing with, just looking for possibly a more elegant way of doing it.

module Ram(RamClk, CKE, CAS, RAS, WE, DQM, BA, A, DQ,
           OpEnable, Addr, RdData, WrData, Ready);   
    input RamClk;
    output CKE;
    output logic CAS, RAS, WE;
    output [1:0] DQM;
    output logic [1:0] BA;
    output logic [11:0] A;
    inout [15:0] DQ;

    input OpEnable;
    output [23:0] Addr; //24 bits = 16 Mb
    output [15:0] RdData;
    input [15:0] WrData;
    output Ready;

    // code omitted here

    wire CMD = {CAS,RAS,WE};

    // code omitted here

    //multiplexers
    always @*
    begin
      if    (InitDone == 0)
        begin
           CMD = InitCmd;
           A = InitA;
           BA = InitBA;
        end
        else
        begin
           //todo: assign the output of the main CMD, A and BA multiplexers
           CMD = CMD_NOP;
           A = 0;
           BA = 0;
        end     
    end

    //rest of the module


I have 3 outputs of the module RAS, CAS, WE that I'm combining into a single wire for convenience so that I can assign command values to them as a whole.

Now I need to connect a multiplexer to CMD and I'm doing it in an always block for convenience.

I could do it in separate assign statements in this case of only 2 inputs to the multiplexer using the ternary expression, but let's imagine the multiplexer has more inputs, for more inputs it looks more convenient to use multiple if/else or a case statement which I cannot use with assign as far as I understand.

Now I have an issue that I have to have a reg on the LHS in the always block although it is combinatorial logic in this case and it will not infer a register in this case.

But if I change CMD to reg then I cannot use the {} notation to combine CAS, RAS and WE.

I could replace the CMD with a task or combine/split CAS, RAS and WE outside the module and have them as a single CMD module parameter.

Any more elegant way of expressing this?","When you have have multiple variables that you would like to assign at once, you can use the concatenation operator on the LHS of an expression:

output logic CAS, RAS, WE;
...
logic [2:0] CMD;

assign {CAS, RAS, WE} = CMD;
...
CMD = 3'b011; // Will assign CAS = 0, RAS = 1, WE = 1
...


You can also just not use CMD at all and just use {CAS, RAS, WE} in its place; depending on your style and what makes sense for your project. A side note, ideally, you should be using always_comb over always @(*) and logic over wire and reg (mostly) if you are in a SystemVerilog environment as you seem to be.",,,,,
Using $ceil to define a parameter in SystemVerilog in Quartus Prime,"Trying to do this

parameter integer PRECHARGE_CLOCKS = $ceil(PRECHARGE_NS / CLOCK_PERIOD_NS);


And then use the value in a comparion

if(InitPrechargeCounter &lt; PRECHARGE_CLOCKS - 1)


But getting this error 

Error (10174): Verilog HDL Unsupported Feature error at Ram.sv(23): system function ""$ceil"" is not supported for synthesis


Is there a way around this so that I get the value calculated at compile time?
Using some different language construct instead of parameter?","I ended up working around this with the following macro, this creates 2 extra parameters for the sake of rounding up, but this is the best solution I've found so far.
This is not limited to integer arguments and works with real numbers.
I've tested this with Quartus and Modelsim

`define Ceil(ParamName, Expression) \
 parameter ParamName``_F = Expression;\
 parameter integer ParamName``_R = ParamName``_F;\
 parameter integer ParamName = (ParamName``_R == ParamName``_F || ParamName``_R &gt; ParamName``_F) ? ParamName``_R : (ParamName``_R + 1);


And then instead of

 parameter integer AUTOREFRESH_CLOCKS = $ceil(UTOREFRESH_NS/CLOCK_PERIOD_NS);


You would invoke the macro

`Ceil(AUTOREFRESH_CLOCKS, UTOREFRESH_NS/CLOCK_PERIOD_NS)


And this is not both synthesizable in Quartus and works in Modelsim",,,,,
"What are the difference in delay times of the basic AND, OR, NOT, NAND, NOR, XOR, XNOR gates?","1-1 What are the difference in delay times of the basic logic gates? 

I found that NAND and NOR gates are preferred in digital circuit design for shorter delay time and that AND and OR gates might even be implemented with NOT and NAND/NOR gates. 

1-2 Are there set or known difference in delay time between AND, OR, NOT gates?","If you look at how these different gates are constructed you can see some of the reasons for differences. An inverter consists of one pull-up transistor and one pull down transistor. This is the simplest gate and is therefore potentially the fastest. A NAND has two pull-down devices in series and two pull-up transistors in parallel. The NOR is basically the opposite of the NAND. And yes: AND is usually just NAND + inverter.

The on resistance of a path will be higher with two transistors in series (making it slower), and the number of transistors connected to a single node will increase the captive load (making it slower). You can make things faster by using larger transistors (with lower on resistance) but that increases the load of whatever cell is driving it, which slows that cell down. 

It is a big optimization problem which you probably shouldn't try to solve yourself. That is what the EDA tools are for.",,,,,
Procedure in VHDL never returns the value,"I have a procedure which is never return the value. 

procedure gen_start_impulse (
    signal rising_signal        : out std_logic;                             
    signal carier_clk           : in std_logic;
    constant duration           : in integer)    is                         
variable clk_counter    : integer := 0;
begin 
    if (rising_edge(carier_clk)) then
        if (clk_counter = duration) then
            rising_signal &lt;= '0';
            clk_counter := 0;
        else
            rising_signal &lt;= '1';
            clk_counter := clk_counter + 1;
        end if;
    end if;
end gen_start_impulse;


I am call it here 

process (start)
begin
    if (start = '1') then
        gen_start_impulse(start_impulse, clk, 1);           
    end if;
end process;


In testbench start_impulse is uninitialized.

Result of testbench 

I don`t understand why in the waveform start_impulse is uninitialized.","Welcome on Stackoverflow. Your question is interesting but it does not really contain enough information to receive a complete answer (a quick look at the help center and especially at the How to create a Minimal, Complete, and Verifiable example section could probably be help you improving it, if you wish).

Anyway, let's try to guess. Your process resumes each time start changes and, thanks to your if statement, it calls your gen_start_impulse procedure only if the new value of start is '1'. So, just to clarify things, we could probably flatten your model and rewrite your process like this:

process (start)
    variable clk_counter: integer := 0;
    constant duration: integer := 1;
begin
    if (start = '1') then
        if (rising_edge(clk)) then
            if (clk_counter = duration) then
                start_impulse &lt;= '0';
                clk_counter := 0;
            else
                start_impulse &lt;= '1';
                clk_counter := clk_counter + 1;
            end if;
        end if;
    end if;
end process;


Important note: this is not strictly equivalent to your initial code because in your code the clk_counter variable is re-initialized each time your gen_start_impulse procedure is called while here it keeps its previous value.

Now, what do you think will happen if start is synchronous? That is, if it changes always just after a rising edge of clk? Simple: the condition of the:

if (rising_edge(clk)) then


statement is always false and your signal assignments to start_impulse are never executed. This is because start and clk never change simultaneously. There is always at least one simulation step (a ""delta-cycle"") between them.

If you design a synchronous system wait or check for rising edges of your clock and then test the other signals, not the opposite. Example:

procedure gen_start_impulse (
    signal rising_signal        : out std_logic;                             
    signal starter              : in std_logic;
    constant duration           : in integer)    is                         
    variable clk_counter    : integer := 0;
begin 
    if (starter = '1') then
        if (clk_counter = duration) then
            rising_signal &lt;= '0';
            clk_counter := 0;
        else
            rising_signal &lt;= '1';
            clk_counter := clk_counter + 1;
        end if;
    end if;
end gen_start_impulse;
...
process (clk)
begin
    if (rising_edge(clk)) then
        gen_start_impulse(start_impulse, start, 1);           
    end if;
end process;


Important note: because of the clk_counter variable is re-initialized each time gen_start_impulse procedure is called (see previous note), this will not work as you expect. If you want this to work you will need to rework it a bit, either by completely removing the procedure (why do you need it, by the way?) and using only one synchronous process, or by adding a fourth inout parameter to your procedure for the clk_counter variable ans declaring it as a process variable.",,,,,
SPI interface with FPGA running LINUX,"I have a DE1-SoC FPGA running Ubuntu 16.04 via the microSD card. I'm somewhat new to the device-tree, but have managed to figure out somewhat how to enable the various peripherals on the board by decompiling the .dtb file into a .dts file using dtc. I did that and edited the .dts file in nano to change the SPI ports from ""disabled"" to ""okay"". I then recompiled the .dtb file from the modified .dts file (I also erased the .dts file and re-decompiled a second .dts file to see if the changed took affect, and they did). 

At this point, I reboot the system, and go to cd/dev/ but there is not spidev or spi* or spidev* listed. When I go to cd/proc/device-tree, I have the following listed:

ubuntu@DE1_SoC:/proc/device-tree$ dir
3-3-v-regulator      chosen          leds               name
#address-cells       compatible      __local_fixups__   #size-cells
aliases              cpus            memory             soc
bridge@0xff200000    intc@fffed000   model              __symbols__


And when I navigate to the /soc/ folder, I have the following, which is consistent with the .dts file I have:

ubuntu@DE1_SoC:/proc/device-tree/soc$ dir
#address-cells        gpio@ff70a000       #size-cells
amba                  i2c@ffc04000        snoop-control-unit@fffec000
base-fpga-region      i2c@ffc05000        spi@ff705000
can@ffc00000          i2c@ffc06000        spi@fff00000
can@ffc01000          i2c@ffc07000        spi@fff01000
clkmgr@ffd04000       interrupt-parent    sram@ffff0000
compatible            l2-cache@fffef000   sysmgr@ffd08000
device_type           l2edac@xffd08140    timer0@ffc08000
dwmmc0@ff704000       l3regs@0xff800000   timer1@ffc09000
ethernet@ff700000     name                timer2@ffd00000
ethernet@ff702000     nand@ff900000       timer3@ffd01000
fpga2sdram-bridge     ocramedac@ffd08144  timer@fffec600
fpga-bridge@ff400000  ranges              usb@ffb00000
fpga-bridge@ff500000  rstmgr@ffd05000     usb@ffb40000
fpga-bridge@ff600000  sdramedac           usbphy@0
fpga-mgr@ff706000     sdr@ffc25000        watchdog@ffd02000
gpio@ff708000         serial0@ffc02000    watchdog@ffd03000
gpio@ff709000         serial1@ffc03000


So, I'm not sure what I'm doing wrong that my serial peripheral interfaces are not working. The end goal: the SPI on the FPGA connects to an onboard ADC (AD7928), which I would like to access via Linux using a program written in C. The i2C work fine, but for some reason the SPI is not responding.

I think I might be missing a step, but at this point I am kinda lost so any help would be great. 

EDIT: Forgot to add the .dts entry for the SPI:

spi@fff00000 {
    compatible = ""snps,dw-apb-ssi"";
    #address-cells = &lt;0x1&gt;;
    #size-cells = &lt;0x0&gt;;
    reg = &lt;0xfff00000 0x1000&gt;;
    interrupts = &lt;0x0 0x9a 0x4&gt;;
    num-cs = &lt;0x4&gt;;
    tx-dma-channel = &lt;0x2c 0x10&gt;;
    rx-dma-channel = &lt;0x2c 0x11&gt;;
    clocks = &lt;0x11&gt;;
    status = ""okay"";
    linux,phandle = &lt;0x59&gt;;
    phandle = &lt;0x59&gt;;
};

spi@fff01000 {
    compatible = ""snps,dw-apb-ssi"";
    #address-cells = &lt;0x1&gt;;
    #size-cells = &lt;0x0&gt;;
    reg = &lt;0xfff01000 0x1000&gt;;
    interrupts = &lt;0x0 0x9b 0x4&gt;;
    num-cs = &lt;0x4&gt;;
    tx-dma-channel = &lt;0x2c 0x14&gt;;
    rx-dma-channel = &lt;0x2c 0x15&gt;;
    clocks = &lt;0x11&gt;;
    status = ""okay"";
    linux,phandle = &lt;0x5a&gt;;
    phandle = &lt;0x5a&gt;;
};


And the addresses are consistent with the board's datasheet for the SPIM. 

Made a little leeway by adding editing the .dts some more:

spi@fff00000 {
    compatible = ""snps,dw-apb-ssi"";
    #address-cells = &lt;0x1&gt;;
    #size-cells = &lt;0x0&gt;;
    reg = &lt;0xfff00000 0x1000&gt;;
    interrupts = &lt;0x0 0x9a 0x4&gt;;
    num-cs = &lt;0x4&gt;;
    tx-dma-channel = &lt;0x2c 0x10&gt;;
    rx-dma-channel = &lt;0x2c 0x11&gt;;
    clocks = &lt;0x11&gt;;
    status = ""okay"";
    linux,phandle = &lt;0x59&gt;;
    phandle = &lt;0x59&gt;;

    spidev@0 {
        compatible = ""spidev"";
        reg = &lt;0x0&gt;;
        spi-max-frequency = &lt;0xb71b00&gt;;
        enable-dma = &lt;0x0&gt;;
    }


Now spidev32766.0 is showing up in my /dev/ folder. ","spidev32766.0 is device node you got after you added device tree nodespidev@0 
for SPI device on first SPI bus (controller) spi@fff00000 with chip select 0.

Frequency property spi-max-frequency = &lt;0xb71b00&gt; by convention should be put in decimal format 12000000, instead of hex, and in new versions of spidev.c, driver will complain about compatible = ""spidev"" property, as this property should describe real HW not some SW abstraction.

This 32766 bus(controller) number is dynamically allocated by the Kernel and is completely legal.
In older Kernels, before device tree files, bus number had to be defined in board file platform data e.g.: .bus_num    = 0,

As previously said there are no SPI bus(controller) device nodes spiX under/dev filesystem, only clients(chip) device nodes spidevX.Y.

spidev.c  is a special kind of driver which is registered for generic SPI client(chip) devices, and it's main goal is to export Kernel low level SPI API to userspace, by creating character device nodes under /dev interface.

But if your goal is SPI driver for ADC, maybe it is better to use a existing Linux SPI driver for that chip, like e.g. for AD7791, or to write your own.
Linux provides support for Industrial I/O Subsystem (iio) devices like analog to digital converters.

Linux Kernel Configuration
Device Drivers  ---&gt;
    ...
    &lt;*&gt;     Industrial I/O support ---&gt;
        --- Industrial I/O support
        ...
        Analog to digital converters  ---&gt; 
            ...
            &lt;*&gt;  Analog Devices ADXYZ* ADC driver


In that case Linux will export your ADC device  functionality to userspace in /sys filesystem:

/sys/bus/iio/devices/iio:deviceX


with device attributes accessible as files:

-r--r--r--    1 root     root          4096 Jan  1 04:18 name
drwxr-xr-x    2 root     root             0 Jan  1 04:18 power
-rw-r--r--    1 root     root          4096 Jan  1 04:18 sampling_frequency
-r--r--r--    1 root     root          4096 Jan  1 04:18 sampling_frequency_available
",,,,,
Can I optimize my verilog code using Synopsys DC and bring it back to Xilinx,I would like to know if it is possible to optimize existing verilog code in Synopsys DC and use the optimized gate level code in Xilinx to use in my FPGA?,"Yes, assuming you have the right Xilinx gate-level library for DC.",,,,,
Compiling Verilog HDL in Quartus,"I'm using Quartus to run simulations and analyze Verilog code. I've searched the Internet and Stack Overflow but haven't seem to come up with answers for my question.

I want to run the RTL Viewer with Verilog code I open in Quartus, but when I open the Verilog code itself, the compile and other options are inactive. I noticed though that when I open a QPF file that it seems to work.

Do I need to create a QPF file in order to use the RTL Viewer? And if so, how could I do that with existing Verilog code I have?","To be able to use RTL Viewer, you need to run at least Analysis &amp; Elaboration task in Quartus software. This task generates Pre-Synthesis Netlist based on your logic (i.e. code) (compare: IntelÂ® QuartusÂ® Prime Standard Edition Handbook, pp. 791)), which is used by RTL Viewer. You won't be able to run this task, unless you created Quartus Project.

QPF file is just Quartus Project File. You can create new project and simply add the code you have created earlier. Just press Project &gt; Add/Remove Files in Project.",,,,,
SystemVerilog: $urandom call inside conditional expression,"So I wanted to set some bits in a vector with some hard-wired probability when an event was triggered, so I did this:  

always @(some_event) begin
  err_byte[0] = ($urandom()&amp;65535 &lt; 85) ? 1'b1 : 1'b0;  
  err_byte[1] = ($urandom()&amp;65535 &lt; 85) ? 1'b1 : 1'b0;  
  //....etc


and my err_byte had always the value of 8'h00, even if this code was triggered several thousands of times (which should've been enough to set at least one bit to 1). When I declared an integer rndv and did this:  

rndv = $urandom()&amp;65535;
err_byte[0] = (rndv &lt; 85) ? 1'b1 : 1'b0;
rndv = $urandom()&amp;65535;
err_byte[1] = (rndv &lt; 85) ? 1'b1 : 1'b0;
//etc...


then it suddenly works. Now the question: what the hell is happening here? Am I not allowed to call system tasks inside conditional expressions?","Operator precedence.  &lt; is ahead of &amp; so your first example could be written like this.

err_byte[0] = ($urandom() &amp; (65535 &lt; 85)) ? 1'b1 : 1'b0;


See the problem now?",,,,,
Exporting task of an instantiated module,"I am trying to export several tasks to a C program via DPI-C. The tasks are defined in the module ""my_subm"" as:

module my_subm;
    task mytask1(...);
    ...
    endtask
    task mytask2(...);
    ...
    endtask
endmodule


And in my main module ""main_mod"", where ""my_subm"" is instantiated:

module main_mod;
    my_subm my_subm_i ();
    `include ""dpic_exports.svh""

    initial begin
        ...
    end
endmodule


Where ""dpic_exports.svh"" is:

`ifndef DPIC_EXPORTS
`define DPIC_EXPORTS

export ""DPI-C"" task my_subm_i.mytask1;
export ""DPI-C"" task my_subm_i.mytask2;

`endif


When trying to compile it I get an error saying that in ""dpic_exports.svh"" my_subm_i is an illegal location for a hierarchical name.

What am I doing wrong?

What I need is these tasks to be available from the scope of ""main_mod"", as the C tasks that will access them are called from that module.","The export statement has to be in the same location as the task/function being exported. Two suggestions: You can create wrapper tasks in your main_mod and export those

task mytask1;
  my_subm_i.mytask1;
endtask
task mytask2;
  my_subm_i.mytask2;
endtask
export ""DPI-C"" task mytask1;
export ""DPI-C"" task mytask2;


The other option is to put the export statements inside my_subn_i and use svSetScope(svGetScopeFromName(""main_mod.my_subm_i""); in your C code.",,,,,
mtd-utils error during yocto build,"I'm trying to build Petalinux with meta-swupdate from https://github.com/Xilinx/yocto-manifests and https://github.com/sbabic/meta-swupdate. I followed the directions for Peatlinux manifest. The command to build it was

TEMPLATECONF=/home/someuser/projects/petalinux-build-system/sources/meta-petalinux/conf sources/core/oe-init-env-build petalinux-build-env
bitbake petalinux-image-full


Everything worked. Then I added a meta-swupdate layer to the bblayers.conf and rebuilt (bitbake petalinux-image-full). This is where the I'm having issues. 

During the build I'm getting a following error:

| mkdir -p /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/image//usr/share/man/man1
| install -m 0644 mkfs.jffs2.1 /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/image//usr/share/man/man1/
| gzip -9f /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/image//usr/share/man/man1/*.1
| install: cannot stat '/home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git//include/libubi.h': No such file or directory
| WARNING: exit code 1 from a shell command.
| ERROR: Function failed: do_install (log file is located at /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/temp/log.do_install.385)
ERROR: Task (/home/someuser/projects/petalinux-build-system/sources/core/meta/recipes-devtools/mtd/mtd-utils_git.bb:do_install) failed with exit code '1'
NOTE: Tasks Summary: Attempted 5877 tasks of which 5875 didn't need to be rerun and 1 failed.


I'm somewhat new to Yocto and not sure how to fix the problem. Would anyone care to help? The full log is attached

DEBUG: Executing shell function do_install
NOTE: make CC=arm-xilinx-linux-gnueabi-gcc  -march=armv7-a -marm -mfpu=neon  -mfloat-abi=hard -mcpu=cortex-a9 --sysroot=/home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/sysroots/zynq-generic RANLIB=arm-xilinx-linux-gnueabi-ranlib AR=arm-xilinx-linux-gnueabi-ar CFLAGS= -O2 -pipe -g -feliminate-unused-debug-types -fdebug-prefix-map=/home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0=/usr/src/debug/mtd-utils/1.5.2-r0 -fdebug-prefix-map=/home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/sysroots/x86_64-linux= -fdebug-prefix-map=/home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/sysroots/zynq-generic=   -I/home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git//include BUILDDIR=/home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ install DESTDIR=/home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/image SBINDIR=/usr/sbin MANDIR=/usr/share/man INCLUDEDIR=/usr/include  
mkdir -p /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/image//usr/sbin
install -m 0755 /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ftl_format /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/flash_erase /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/nanddump /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/doc_loadbios /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ftl_check /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/mkfs.jffs2 /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/flash_lock /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/flash_unlock /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/flash_otp_info /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/flash_otp_dump /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/flash_otp_lock /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/flash_otp_write /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/mtd_debug /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/flashcp /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/nandwrite /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/nandtest /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/mtdpart /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/jffs2dump /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/nftldump /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/nftl_format /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/docfdisk /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/rfddump /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/rfdformat /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/serve_image /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/recv_image /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/sumtool /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/jffs2reader /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/mkfs.ubifs/mkfs.ubifs /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubiupdatevol /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubimkvol /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubirmvol /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubicrc32 /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubinfo /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubiattach /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubidetach /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubinize /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubiformat /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubirename /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/mtdinfo /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubirsvol /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git/ubi-utils/ubiblock flash_eraseall /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/image//usr/sbin/
mkdir -p /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/image//usr/share/man/man1
install -m 0644 mkfs.jffs2.1 /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/image//usr/share/man/man1/
gzip -9f /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/image//usr/share/man/man1/*.1
install: cannot stat '/home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/git//include/libubi.h': No such file or directory
WARNING: exit code 1 from a shell command.
ERROR: Function failed: do_install (log file is located at /home/someuser/projects/petalinux-build-system/petalinux-build-env/tmp/work/cortexa9hf-neon-xilinx-linux-gnueabi/mtd-utils/1.5.2-r0/temp/log.do_install.385) 
",This project appears to be using the Yocto 2.2 release code named morty. Use the morty branch of meta-swupdate.,,,,,
I want to update inputs in verilog,"I want to implement the following algorithm in verilog. Is there a way to update input in verilog just like c/c++(eg, a=a+i;)

aâ†a + b + 2 Â· lsw(a) Â· lsw(b)
dâ†?d âŠ?a) &gt;&gt;&gt; 32
câ†c + d + 2 Â· lsw(c) Â· lsw(d)
bâ†?b âŠ?c) &gt;&gt;&gt; 24
aâ†a + b + 2 Â· lsw(a) Â· lsw(b)
dâ†?d âŠ?a) &gt;&gt;&gt; 16
câ†c + d + 2 Â· lsw(c) Â· lsw(d)
dâ†?b âŠ?c) &gt;&gt;&gt; 63


here a,b,c,d are 64 bit ASCII inputs. And lsw(x) is the least significant word of 32 bit.""âŠ? denotes bit wise XOR and """"+"""" denotes wordwise addition."," and >>> denotes right shift operation.""",,,,,
,,,,,,,
,,,,,,,
,,,,,,,
0,0,220,,,,,
 because of the feedback nature of your signals.,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
 on every positive edge of clock.,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
,,,,,,,
assimilating values to registers in GCD FSM in verilog,"I'm trying to create a state machine for the GCD algorithm(subtraction method), and I need to put the values(wires) of my numbers to a register to work with the algorithm, but I don't want for each value change to assimilate into the registers.
in other words:

module GCD_R (u,v,out,nrst,act,clk);
input [31:0] A,B;
input clk,act,rst;
output reg [31:0] out;
reg[4:0] state,next_state;
reg[31:0] A_reg,B_reg,Aint_reg,Bint_reg;
parameter IDLE = 4'b0001;
parameter ABIG = 4'b0010;
parameter BBIG = 4'b0100;

always @(A,B)
    begin
        A_reg&lt;=A
        B_reg&lt;=B
    end
always @*   
    case (state)
        IDLE: begin


but this definition is problematic since if someone changes the values of A or B, it will move them to the registers every time and I don't want that, basically I need some condition that will move the values to the registers only on initialization, how do I do that?","Usually for such issues clocks are used. You even have it in parameters. So, use it:

always @(posedge clk) begin
    A_reg&lt;=A
    B_reg&lt;=B
end
",,,,,
Simple oscillator in VHDL,"I've just started with VHDL, and I have a problem understanding how exactly process operates. Here is an example of a simple oscillator:

timer_1Hz: process(clk) is
    variable timer : integer := 0;
    constant period : integer := 50E6;
begin
--if rising_edge(clk) then
    timer := (timer+1) rem period;
    if (timer=0) then
        led &lt;= not led;
    end if;
--end if;
end process timer_1Hz;


clk is an input (clock) signal with 50 MHz frequency, and 50% duty cycle.

Now, as I understand it, the process timer_1Hz will be triggered on any change in the clk signal, whether that be a transition from 0 to 1, or from 1 to 0.

I expected from the above example to flash LEDs with a frequency of 0.5 Hz, since the rising_edge test was commented out. In other words, I expected that the body will be triggered two times in a single clock period, on a rising and a falling edge. However, that doesn't seem to work, i.e., LEDs are never turned on.

If I include the rising_edge test, LEDs blink with a 1 Hz frequency, just as I expected.

Can someone please explain what am I missing in the unexpected case.","The code will not work without the rising edge part you removed. It might work in simulation, but not in a real fpga board. Why? Because sensitivity list is (mostly) important for simulation and not(so much) for synthesis.

For synthesis purpose, you have to always think about the hardware you would be implementing. In a practical sense, a process is NOT ""run"" when certain events occur. 

If you really want 0.5 Hz output, just use 25E6 instead of 50E6 with the original code.. ",,,,,
ISim shows U for all flip flops outputs,"When I try to simulate my VHDL code with ISIM it shows onlys U for all outputs. 

That just made up of three cascaded D-type flip flops.

And here is my VHDL code:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity az_4_2 is
    Port ( clk: in std_logic;
            X : in  STD_LOGIC;
              Ain : in  STD_LOGIC;
           Bin : in  STD_LOGIC;
              Cin : in  STD_LOGIC;
           Aout : out  STD_LOGIC;
           Bout : out  STD_LOGIC;
              Cout : out  STD_LOGIC;
           Y : out  STD_LOGIC;
              reset : in std_logic);
end az_4_2;

architecture Behavioral of az_4_2 is
begin


process(clk, reset, Ain, Bin, Cin, X)
begin

if (reset = '1') then
Y &lt;= '0';

elsif (Ain = '0') and (Bin = '0') and (Cin = '0') then
Y &lt;= '0';

elsif (Ain = '0') and (Bin = '0') and (Cin = '1') then
Y &lt;= '0';

elsif (Ain = '0') and (Bin = '1') and (Cin = '0') then
Y &lt;= '0';

elsif (Ain = '0') and (Bin = '1') and (Cin = '1') then
if (x = '0') then
Y &lt;= '0';
else
Y &lt;= '1';
end if;

elsif (Ain = '1') and (Bin = '0') and (Cin = '0') then
if (x = '0') then
Y &lt;= '0';
else
Y &lt;= '1';
end if;

end if;


if(rising_edge(clk)) then


if (reset = '1') then
Aout &lt;= '0';
Bout &lt;= '0';
Cout &lt;= '0';

elsif (Ain = '0') and (Bin = '0') and (Cin = '0') then
if (x = '0') then
Aout &lt;= '0';
Bout &lt;= '0';
Cout &lt;= '0';
else
Aout &lt;= '1';
Bout &lt;= '0';
Cout &lt;= '0';
end if;

elsif (Ain = '0') and (Bin = '0') and (Cin = '1') then
if (x = '0') then
Aout &lt;= '0';
Bout &lt;= '1';
Cout &lt;= '0';
else
Aout &lt;= '0';
Bout &lt;= '1';
Cout &lt;= '1';
end if;

elsif (Ain = '0') and (Bin = '1') and (Cin = '0') then
if (x = '0') then
Aout &lt;= '0';
Bout &lt;= '0';
Cout &lt;= '0';
else
Aout &lt;= '0';
Bout &lt;= '1';
Cout &lt;= '1';
end if;

elsif (Ain = '0') and (Bin = '1') and (Cin = '1') then
if (x = '0') then
Aout &lt;= '1';
Bout &lt;= '0';
Cout &lt;= '0';
else
Aout &lt;= '0';
Bout &lt;= '1';
Cout &lt;= '1';
end if;

elsif (Ain = '1') and (Bin = '0') and (Cin = '0') then
if (x = '0') then
Aout &lt;= '0';
Bout &lt;= '0';
Cout &lt;= '0';
else
Aout &lt;= '0';
Bout &lt;= '1';
Cout &lt;= '1';

end if;
end if;
end if;
end process;
end Behavioral;


And here is my TEST_BENCH:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

ENTITY tb_az_4 IS
END tb_az_4;

ARCHITECTURE behavior OF tb_az_4 IS 

COMPONENT az_4
    Port ( clk: in std_logic;
            reset: in std_logic;
            X : in  STD_LOGIC;
              Ain : in  STD_LOGIC;
           Bin : in  STD_LOGIC;
              Cin : in  STD_LOGIC;
           Aout : out  STD_LOGIC;
           Bout : out  STD_LOGIC;
              Cout : out  STD_LOGIC;
           Y : out  STD_LOGIC);
END COMPONENT;

   --Inputs
   signal clk, reset : std_logic := '0';

    --BiDirs
   signal X, Ain, Bin, Cin, Aout, Bout, Cout, Y : std_logic;

begin
   uut: az_4 PORT MAP (
          clk =&gt; clk,
             reset =&gt; reset,
          X =&gt; X,
          Ain =&gt; Ain,
             Aout =&gt; Aout,
             Bin =&gt; Bin,
          Bout =&gt; Bout,
             Cin =&gt; Cin,
             Cout =&gt; Cout,
          Y =&gt; Y
        );

   -- Clock process definitions
clock_process :process
begin
     clk &lt;= '0';
     wait for 5 ns;
     clk &lt;= '1';
     wait for 5 ns;
end process;


-- Stimulus process
stim_proc: process
begin        
   -- hold reset state for 100 ns.
   reset &lt;= '1';    
    wait for 10 ns;
    reset &lt;= '0';   
   Ain &lt;= '0';
   Bin &lt;= '0';
    Cin &lt;= '0';
    x &lt;= '0'; 

   wait;
end process;

END behavior;


So why this is happened? How can I solve this issue?","During elaboration a component instantiation of component declaration is associated with a particular design entity. This can either be done explicitly - by a configuration specification in the enclosing block declarative region or a configuration declaration providing a binding indication, or implicitly by default binding.

Lacking both a configuration specification and a configuration declaration in your example a default binding indication is attempted during elaboration. The component name in the component instantiation statement is searched for (az_4). 

The search finds the first of:


An entity declaration that has the same simple name and is directly visible (through a use clause of the form L.all; where L is a reference library).  
An entity as above that would be directly visible barring a visible component declaration with the same simple name hiding the entity.
An entity declaration denoted by L.C where L is the target library logical name where the component C is declared.


In your case the search did not find az_4, noting you do provide an az_4_2.

Your uut in the testbench architecture body is unbound in a default binding indication without an entity named az_4 being directly visible.

There are three ways to cure this.


You can make the four names match (the entity name in the entity az_4_2, it's matching architecture body, the component declaration and component instantiation statement in the testbench architecture body) and count on default binding.
You can provide a binding indication as configuration specification as a testbench architecture declarative item:

 for uut: az_4                    -- ADDED configuration  specification
     use entity work.az_4_2;
begin
   uut: az_4 port map (

Or you can provide a binding indication in a configuration declaration, which hardly seems worthwhile for a single component instantiation.


I've checked to see your code will analyze, elaborate and simulate with the first two methods, noting your testbench won't stop simulation until simulation time reaches TIME'HIGH without implementation intervention (such as running the simulation for a set time interval). The clock runs continuously.

Providing the configuration specification shown above produces:



Which shows the binding indication worked and that your testbench stim_proc process isn't fully developed as yet.",,,,,
Maximum path delay in a simple combinational circuit,"I want to calculate the maximum path delay for a combinational circuit in Xilinx ISE. I'm familiar with the sequential circuits and I know how to work with timing constraints and the timing reports generated after P&amp;R. But with no clock in the design, I do not know what should I do? 
Is it necessary to add clock in every combinational design so that it can be figured that how much the maximum path delay is?
For example, for the following VHDL code of a full adder, how can I measure the maximum path delay?

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity full_adder_vhdl_code is
Port ( A : in STD_LOGIC;
B : in STD_LOGIC;
Cin : in STD_LOGIC;
S : out STD_LOGIC;
Cout : out STD_LOGIC);
end full_adder_vhdl_code;

architecture gate_level of full_adder_vhdl_code is

begin

S &lt;= A XOR B XOR Cin ;
Cout &lt;= (A AND B) OR (Cin AND A) OR (Cin AND B) ;

end gate_level;
","This can be easily done in Xilinx ISE. You don't have to add any clock.

Just synthesis the code as it is. And then watch the console tab. The synthesis status will be displayed there. The delay you require is shown at the end of this report. 

When I synthesised your code in ISE 14.6, I got this:


  Minimum period: No path found
  Minimum input arrival time before
  clock: No path found
  Maximum output required time after clock: No
  path found
  Maximum combinational path delay: 0.776ns
  
  ========================================================================
  
  Process ""Synthesize - XST"" completed successfully
",,,,,
"Net, which fans out, cannot be assigned more than one value","I am trying to design an 8-bit multiplier based on 4-bit multiplier. so this is my code:
module _8bit_multiply(a, b, q);

input [7:0] a;
input [7:0] b;

output [15:0] q;

wire [7:0] q0;
wire [7:0] q1;
wire [11:0] q2;
wire [11:0] q3;
wire [7:0] x0;
wire [11:0] x1;
wire [7:0] sum0;
wire [12:0] sum1;
wire [12:0] sum2;
wire co0;
wire co1;
wire temp;

_4bit_multiply m1(a[3:0], b[3:0], q0);

assign q[3:0] = q0[3:0];
assign x0[3:0] = q0[7:4];

_4bit_multiply m2(a[7:4], b[3:0], q1);

nbit_adder s1(x0, q1, 0, sum0, co0);

_4bit_multiply m3(a[3:0], b[7:4], q2);
_4bit_multiply m4(a[7:4], b[7:4], x1);

assign q3[11:4] = x1[7:0];

nbit_adder s2(q2, q3, 0, sum1, co1);

nbit_adder s3(sum0, sum1, co0, sum2, temp);
nbit_adder s4(sum2, 0, co1, sum2, temp);

assign q[15:4] = sum2[12:0];

endmodule

then I get this error:

Error (12014): Net &quot;sum2[11]&quot;, which fans out to &quot;q[15]&quot;, cannot be
assigned more than one value
Error (12015): Net is fed by &quot;nbit_adder:s3|s[11]&quot;  Error (12015):
Net is fed by &quot;nbit_adder:s4|s[11]&quot;

And more than like this. what should I do ?","The same variable is the output of multiple modules in your code. Basically you're doing this:

assign sum2 = 1;
assign sum2 = 0;


So Quartus doesn't know what to do. ",,,,,
is nested @ supported?,"I am trying to create an implicit FSM using the following syntasix:

always @(posedge clock) begin
   @(posedge clock)begin
       statement
   end
   @(posedge clock)begin
       statement
   end


It works fine in simulation but when I try to synthesize, an error displays:
""syntax unexpected @""

is this sintax not supported by yosys?

THX",A high-level synthesis tool can support this and build a state machine from multiple clock edges in a single always block.  But I don't think yosys can handle it. ,,,,,
vhdl function is not being called,"I have written a vhdl code something like this

entity myentity is
 port( number : in integer range 0 to 15; result : out integer);
 function myfunction(num: integer range 0 to 15) return integer is
 variable i: integer :=1;
 variable error1, error2, error, temp, concat: integer;
 variable res: integer;
 begin
  if (num&lt;=1)then
   res := num;
  else 
   while (2**i &lt; num) loop
    i:=i+1;
   end loop;
   error2 := num-(2**i); 
   error1 := num-(2**(i-1));
   if abs(error1)&lt;error2 then
    error := error1;
   else error := error2;
   end if;
   if error=0 then
   res := to_integer(to_unsigned(num,8) sll i);
   else 
   temp := num-error;
   concat := myfunction(temp);
   res :=to_integer(to_unsigned(temp,4) &amp; to_unsigned(concat,i-1));
   end if;
  end if;
 return res;
end myfunction;
end myentity;

architecture Behavioral of myentity is
begin
 result&lt;=myfunction(number);
end Behavioral;


Function is recursive. The problem is, the architecture body is not calling the function. i.e., function lines are not being executed. When I compile the program, it shows no error. Any help? 
I changed the example to the original code. ","With your new question code formatted for readability, report statements added for debugging and an added testbench to drive all possible integer values of number (0 to 15), creating a Minimal, Complete and Verifiable example:

library ieee;             -- CONTEXT CLAUSE ADDED
use ieee.numeric_std.all; -- unsigned, to_unsigned, to_integer, sll
 -- superfluous parentheses removed, indentation added  for clarity:
entity myentity is
    port (
        number:  in  integer range 0 to 15; 
        result:  out integer
    );

    function myfunction (num: integer range 0 to 15) return integer is
        variable i: integer := 1;
        variable error1, error2, error, temp, concat: integer;
        variable res: integer;
    begin
        if num &lt;= 1 then  -- CONDITION COULD BE num = 0
            res := num;
            report ""num = "" &amp; integer'image(num);        -- ADDED REPORT
        else
            while 2 ** i &lt; num loop
                i := i + 1;
            end loop;
            report ""i = "" &amp; integer'image(i);            -- ADDED REPORT
            error2 := num - 2 ** i; 
            report ""error2 = "" &amp; integer'image(error2);  -- ADDED REPORT
            error1 := num - 2 ** (i - 1);
            report ""error1 = "" &amp; integer'image(error1);  -- ADDED REPORT
            if abs error1 &lt; error2 then
                error := error1;
            else
                error := error2;
            end if;
            report ""error = "" &amp; integer'image(error);    -- ADDED REPORT
            if error = 0 then
                res := to_integer(to_unsigned(num, 8) sll i);
                report ""res = "" &amp; integer'image(res);    -- ADDED REPORT
            else
                temp := num - error;
                report ""temp = "" &amp; integer'image(temp);  -- ADDED REPORT
                concat := myfunction(temp);
                report ""concat = "" &amp; integer'image(concat); -- ADDED REPORT
                res := to_integer(to_unsigned(temp, 4) &amp; 
                       to_unsigned(concat, i - 1) );
                report ""res = "" &amp; integer'image(res);    -- ADDED REPORT
            end if;
        end if;
        return res;
    end myfunction;
end entity myentity;

architecture behavioral of myentity is
begin
    result &lt;= myfunction(number);
end architecture behavioral;

entity myentity_tb is
end entity;

architecture foo of myentity_tb is
    signal result: integer;
    signal number: integer range 0 to 15;
begin

DUT:
    entity work.myentity 
        port map (
            number =&gt; number,
            result =&gt; result
        );
STIMULI:
    process
    begin
        for i in 0 to 15 loop
            number &lt;= i;
            report ""number = "" &amp; integer'image(i);
            wait for 10 ns;
        end loop;
        wait;
    end process;
end architecture;


Analyzing the code, elaborating and running the testbench produces with a VHDL implementation dependent report statement format:


myentity.vhdl:17:13:@0ms:(report note): num = 0
myentity.vhdl:74:13:@0ms:(report note): number = 0
myentity.vhdl:74:13:@10ns:(report note): number = 1
myentity.vhdl:17:13:@10ns:(report note): num = 1
myentity.vhdl:74:13:@20ns:(report note): number = 2
myentity.vhdl:22:13:@20ns:(report note): i = 1
myentity.vhdl:24:13:@20ns:(report note): error2 = 0
myentity.vhdl:26:13:@20ns:(report note): error1 = 1
myentity.vhdl:32:13:@20ns:(report note): error = 0
myentity.vhdl:35:17:@20ns:(report note): res = 4
myentity.vhdl:74:13:@30ns:(report note): number = 3
myentity.vhdl:22:13:@30ns:(report note): i = 2
myentity.vhdl:24:13:@30ns:(report note): error2 = -1
myentity.vhdl:26:13:@30ns:(report note): error1 = 1
myentity.vhdl:32:13:@30ns:(report note): error = -1
myentity.vhdl:38:17:@30ns:(report note): temp = 4
myentity.vhdl:22:13:@30ns:(report note): i = 2
myentity.vhdl:24:13:@30ns:(report note): error2 = 0
myentity.vhdl:26:13:@30ns:(report note): error1 = 2
myentity.vhdl:32:13:@30ns:(report note): error = 0
myentity.vhdl:35:17:@30ns:(report note): res = 16
myentity.vhdl:40:17:@30ns:(report note): concat = 16
../../src/ieee/numeric_std-body.v93:2151:7:@30ns:(assertion warning): NUMERIC_STD.TO_UNSIGNED: vector truncated
myentity.vhdl:43:17:@30ns:(report note): res = 8
myentity.vhdl:74:13:@40ns:(report note): number = 4
myentity.vhdl:22:13:@40ns:(report note): i = 2
myentity.vhdl:24:13:@40ns:(report note): error2 = 0
myentity.vhdl:26:13:@40ns:(report note): error1 = 2
myentity.vhdl:32:13:@40ns:(report note): error = 0
myentity.vhdl:35:17:@40ns:(report note): res = 16
myentity.vhdl:74:13:@50ns:(report note): number = 5
myentity.vhdl:22:13:@50ns:(report note): i = 3
myentity.vhdl:24:13:@50ns:(report note): error2 = -3
myentity.vhdl:26:13:@50ns:(report note): error1 = 1
myentity.vhdl:32:13:@50ns:(report note): error = -3
myentity.vhdl:38:17:@50ns:(report note): temp = 8
myentity.vhdl:22:13:@50ns:(report note): i = 3
myentity.vhdl:24:13:@50ns:(report note): error2 = 0
myentity.vhdl:26:13:@50ns:(report note): error1 = 4
myentity.vhdl:32:13:@50ns:(report note): error = 0
myentity.vhdl:35:17:@50ns:(report note): res = 64
myentity.vhdl:40:17:@50ns:(report note): concat = 64
../../src/ieee/numeric_std-body.v93:2151:7:@50ns:(assertion warning): NUMERIC_STD.TO_UNSIGNED: vector truncated
myentity.vhdl:43:17:@50ns:(report note): res = 32
myentity.vhdl:74:13:@60ns:(report note): number = 6
myentity.vhdl:22:13:@60ns:(report note): i = 3
myentity.vhdl:24:13:@60ns:(report note): error2 = -2
myentity.vhdl:26:13:@60ns:(report note): error1 = 2
myentity.vhdl:32:13:@60ns:(report note): error = -2
myentity.vhdl:38:17:@60ns:(report note): temp = 8
myentity.vhdl:22:13:@60ns:(report note): i = 3
myentity.vhdl:24:13:@60ns:(report note): error2 = 0
myentity.vhdl:26:13:@60ns:(report note): error1 = 4
myentity.vhdl:32:13:@60ns:(report note): error = 0
myentity.vhdl:35:17:@60ns:(report note): res = 64
myentity.vhdl:40:17:@60ns:(report note): concat = 64
../../src/ieee/numeric_std-body.v93:2151:7:@60ns:(assertion warning): NUMERIC_STD.TO_UNSIGNED: vector truncated
myentity.vhdl:43:17:@60ns:(report note): res = 32
myentity.vhdl:74:13:@70ns:(report note): number = 7
myentity.vhdl:22:13:@70ns:(report note): i = 3
myentity.vhdl:24:13:@70ns:(report note): error2 = -1
myentity.vhdl:26:13:@70ns:(report note): error1 = 3
myentity.vhdl:32:13:@70ns:(report note): error = -1
myentity.vhdl:38:17:@70ns:(report note): temp = 8
myentity.vhdl:22:13:@70ns:(report note): i = 3
myentity.vhdl:24:13:@70ns:(report note): error2 = 0
myentity.vhdl:26:13:@70ns:(report note): error1 = 4
myentity.vhdl:32:13:@70ns:(report note): error = 0
myentity.vhdl:35:17:@70ns:(report note): res = 64
myentity.vhdl:40:17:@70ns:(report note): concat = 64
../../src/ieee/numeric_std-body.v93:2151:7:@70ns:(assertion warning): NUMERIC_STD.TO_UNSIGNED: vector truncated
myentity.vhdl:43:17:@70ns:(report note): res = 32
myentity.vhdl:74:13:@80ns:(report note): number = 8
myentity.vhdl:22:13:@80ns:(report note): i = 3
myentity.vhdl:24:13:@80ns:(report note): error2 = 0
myentity.vhdl:26:13:@80ns:(report note): error1 = 4
myentity.vhdl:32:13:@80ns:(report note): error = 0
myentity.vhdl:35:17:@80ns:(report note): res = 64
myentity.vhdl:74:13:@90ns:(report note): number = 9
myentity.vhdl:22:13:@90ns:(report note): i = 4
myentity.vhdl:24:13:@90ns:(report note): error2 = -7
myentity.vhdl:26:13:@90ns:(report note): error1 = 1
myentity.vhdl:32:13:@90ns:(report note): error = -7
myentity.vhdl:38:17:@90ns:(report note): temp = 16
./myentity_tb:error: bound check failure at myentity.vhdl:39
./myentity_tb:error: simulation failed



Where we can see for a number value of 0 the function returns 0 which is assigned to result.  That explains why without driving different values (1 through 15) on number through stimuli (here a testbench, a higher level in the design hierarchy) why result is 0 and produces no error. (Note without an assignment to result it's value would have been INTEGER'LOW the minimum value for that type, result has no subtype constraint and inherits it's subtype from the type mark in the port declaration for result).

There are two classes of messages causing concern in the output for number values 1 through 15.

The first is the report message from package numeric_std telling you you clipped left elements from the binary number eventually converted to integer and assigned to res. This represents inaccuracy in your algorithm that needs to be addressed. You can note that res (assigned to result in the concurrent signal assignment statement) is 64 when that occurs.

The second is the error message when number was assigned a value of 9 and the value passed to the recursive call to myfunction was outside it's parameter num's range (0 to 15, the value 16 for variable temp). A bounds violation error is sufficient to cause simulation to cease, the integrity of the simulation is compromised. (And this is what strong typing does for you, the subtype of parameter num should have been chosen for a purpose in implementing myfunction).

You can easily remove every report statement added for debugging when your algorithm functions satisfactorily after which you can test again.

Note the values of number can be distinguished by what time they occur at during simulation.

This answer shows why your code reports no error as well as showing how to tell what it's doing to allow debugging for other values of number.

As we can see my the presence of the very first report statement the function myfunction is getting called. Also if result were not assigned it's default value would be a negative number.",,,,,
Verilog: How to assign the an inout to another inout?,"I'm trying to assign the input from an inout port to another inout port used as output. As common practice, I have to set the input port to High-Z:

inout pin5;
inout pin20;
assign pin20 = 1'bz;
assign pin5 = pin20;


This caused both pin5 and pin20 to be routed to high-Z. I know why it's logically happening, but how can I go around it, besides turning pin20 into an input?

Here's the schematics output from my mapper.

","There is no buffer in your code. But the picture that you show looks like the following to me. The 'test' module gets 2 pins and assigns 'z's. If you leave them hanging, there will stay at this value. In the example below the 'top' module emulates the activity on the pin and assigns 'val' to it. Now the 'pin2' will follow the pattern of 'val' (if enabled) or stay at 'z'. The val actually is the buffer you'd been talking about.  

module top();
   reg val, en;
   wire pin1, pin2;
   // do something with val and en 

   test t(pin1, pin2);
   assign pin2 = en ? 1'bz : val;
endmodule // top

module test(inout pin1, pin2);
   assign pin1 = 1'bz;
   assign pin2 = pin1;
endmodule // test
",,,,,
Incompatibile Slices in VHDL,"I am learning VHDL and for first project I picked up simple Brainfuck processor. When I try to compile it, I get error about incompatibile slices. I am using EdWinXP. How do I fix my code? Are there many mistakes in my code? Is there alternative of VHDL that would be simpler for C programmer?

use ieee.std_logic_1164.all;

entity BFCPU is
 port ( 
        I0 : in std_logic; --INPUT
        I1 : in std_logic; --PROGRAM
        I2 : in std_logic; --PROGRAM READY
        O1 : out std_logic; --PROGRAM NEEDED
        O2 : out std_logic; --OUTPUT
        O3 : out std_logic; --OUTPUT WRITTEN
        O4 : out std_logic); --INPUT NEEDED
        --O5 : out std_logic); --INPUT POOLING CLOCK
end BFCPU;

architecture work of BFCPU is
  type t_Memory is array (0 to 127) of std_logic_vector(7 downto 0); 
  signal rammem : t_Memory; 
  signal pointer : std_logic;
 begin
 pointer &lt;= 0;
 workflow: process (I2) is
 begin
  if I1=1 then
    rammem(pointer) &lt;= std_logic_vector(unsigned(rammem(pointer)) + 1);
  elsif I1=2 then
    rammem(pointer) &lt;= std_logic_vector(unsigned(rammem(pointer)) - 1);
  elsif I1=3 then
    pointer &lt;= pointer - 1;
  elsif I1=4 then
    pointer &lt;= pointer + 1;
  elsif I1=5 then
    O2 &lt;= rammem(pointer);
  elsif I1=6 then
    O4 &lt;= not O4;
    inwait: while( I0 = 0 ) loop
        if not (I0 = 0) then
            rammem(pointer) &lt;= I0;
        end if;
    end loop inwait;
    O4 &lt;= not O4;
  end if;
 end process workflow;
end work;
","What you're writing below the begin statement and outside a process is always true, so this isn't sequential in any form. Imagine like an FPGA pin, which is soldered to ground. 

You try to manipulate the pointer signal from within a process, but you can't because your pointer is fixed to '0'. 
If you want the pointer initializing to '0', as it looks like, you have to put this line within the process. However, i see you try to call arithmetic operations with the pointer signal, but you are defining the signal as std_logic. std_logic can represent '0', '1' and several other states, like High-Z, but not a number. You should take an integer or natural for calculations.",,,,,
Optimization of continuous assignment by mixing combinational and behavioral logics?,"I am trying to wrap my head around a mix of combinational and behavioral logic. I've got small FPGA with 4 LEDs and a 66 MHz clock input. The idea was to make two of them glowing (one rising, one falling) and another two blinking. So I came up with the following code:

module ledflash(input wire CLK,
        input wire USER_RESET,
        output wire LED[3:0]);

   reg [26:0]           cnt;
   reg [4:0]            pwm;

   wire             led_enable = ~USER_RESET;

   always @(posedge CLK)
     begin
    if (led_enable)
      begin
         cnt &lt;= cnt + 1;
         pwm &lt;= pwm[3:0] + (cnt[26] ? cnt[25:22] : ~cnt[25:22]);
      end
    else
      begin
         cnt &lt;= 0;
         pwm &lt;= 0;
      end
   end

   assign LED[0] = led_enable ? (cnt[26] ? pwm[4] : ~pwm[4]) : 0;
   assign LED[1] = led_enable ? (cnt[26] ? ~pwm[4] : pwm[4]) : 0;

   assign LED[2] = led_enable ? cnt[25] : 0;
   assign LED[3] = led_enable ? ~cnt[25] : 0;

endmodule


I did not want to use a vendor specific DCM, and so simple bit adders with 66MHz clock works out the magic. Perhaps the whole design is wrong in a first place (for instance, I could have used two clock dividers and simply flip a bit of two registers to achieve (almost) the same thing), but I ran into this situation which made me wondering...

From a regular software developer's point of view, there are some parts in continuous assignments that seem redundant. For example, an extra register can be used and so it would seem that less work is performed. For instance:

module ledglow(input wire CLK,
        input wire USER_RESET,
        output wire LED[3:0]);

   reg [26:0]           cnt;
   reg [4:0]            pwm;
   reg              led_pair1;
   reg              led_pair2;

   wire             led_enable = ~USER_RESET;

   always @(posedge CLK)
     begin
    if (led_enable)
      begin
         cnt &lt;= cnt + 1;
         pwm &lt;= pwm[3:0] + (cnt[26] ? cnt[25:22] : ~cnt[25:22]);
      end
    else
      begin
         cnt &lt;= 0;
         pwm &lt;= 0;
      end
    led_pair1 &lt;= cnt[26] ? pwm[4] : ~pwm[4];
    led_pair2 &lt;= cnt[25];
     end

   assign LED[0] = led_enable ? led_pair1 : 0;
   assign LED[1] = led_enable ? ~led_pair1 : 0;

   assign LED[2] = led_enable ? led_pair2 : 0;
   assign LED[3] = led_enable ? ~led_pair2: 0;

endmodule


I was trying to dig into synthesizer report differences for two approaches above and look at HDL schematics, but it way too complex for such an inexperienced guy like me.

No doubt synthesis tool optimizes the combinational logic very well, but assuming the the right hand side expressions are very complicated to be one-liners etc, is there a way to say something like this?

   if (some_reg_var) begin
       assign net0 = 1;
       assign net1 = 0;
    end
   else
    begin
       assign net0 = 0;
       assign net1 = 1;
    end


Or does it even make sense to do so? If not, does it make sense to introduce registers in such cases to simplify the behavioral part? I am sure there are some rules or thumb at least. Any help is appreciated.","Your question is a bit verbose, but I think I understand what you're getting at (correct me if I'm wrong). 

You wish to know if there is a way to break up long assign statements to use if/else logic, similar to regs in an always block?

Verilog always seemed slightly funny to me in this way, but just because you declare something a 'reg' datatype does not mean that it gets synthesized to a register. It only actually creates a register if there is some state to store. Having said that, the following two statements should synthesize to exactly the same thing:

Case 1: 

wire a;
wire b;
assign a = b ? 0 : 1; 


Case 2: 

reg a;
wire b;

always @(b)
   if(b)
       a &lt;= 0;
   else
       a &lt;= 1;


Both of these should create the exact same logic (simply, an inverter with a = !b). Even in the second case where you have declared a reg, it doesn't actually instance a register, because there's nothing to remember (all of the inputs are in the sensitivity list). 

Because of this, you are free to write complex if/else logic to simplify your code, and this doesn't mean you're paying a penalty of synthesizing extra registers. So feel free to write it which ever way is most comfortable for you. (If you do use an always block, make sure to have an assignment for all possible cases, or you will infer a latch which you probably don't want). ",,,,,
How to disable XST FF/Latch trimming or hide warnings about it,"Can anyone explain to me how can I disable XST FF/Latch trimming ? 
In this particular example, I know why trimmings are occurring (I don't want to go into details), but they are occurring on very large std_logic_vector (two vectors with 128 bits). 

That said, I get many warnings and can't see if anything else is wrong (that I would care about). So I would like to hide warnings or disable FF/Latch trimming. Is that possible ?

Thanks !","In ISE you can hide particular warnings from the message window IIRC.  I think right-clicking the message might be the way.

Personally, I tend to use a pure command-line flow - including a script which ""edits out"" the messages I have defined as being ""uninteresting"" or ""supposed to happen"" via a set of regexps in a side-file.  Of course, then I have to validate the regexps :)",,,,,
VDHL - initial value of signal?,"I have simple VHDL modul that outputs PWM signal. PWM modul has signal that holds current PWM percentage. When I synthesize and implement it, that signal is reset by default to 0. Is there any way to configure it that after implementation PWM percentage is 20 or something else ?

Thanks !","You should be able to set the power-up default value.  It has to agree with the reset value (if there is one) because the synthesizer will use NOT-gate-pushback to implement it.

Try

SIGNAL dutycycle : INTEGER := 20;   -- powerup value

PROCESS (n_reset, clk)
BEGIN
   IF TO_X01(n_reset) = '0' THEN
       dutycycle &lt;= 20;             -- asynchronous reset value
   ELSIF RISING_EDGE(clk) THEN
       dutycycle &lt;= load_dutycycle; -- synchronous load
   END IF;
END PROCESS;
",,,,,
Can't infer register because its behavior doesn't match any supported model in Quartus II,"The code: 

        library IEEE;
        use IEEE.std_logic_1164.all;
        use ieee.numeric_std.all;
        use ieee.std_logic_unsigned.all;
        entity decoder10 is 
        port( in_data:  in STD_LOGIC_VECTOR (7 downto 0);
                clk : in STD_LOGIC;
                out_data:  out STD_LOGIC_VECTOR (7 downto 0));
        end decoder10;

        architecture behavioral of decoder10 is
        signal int_bus1 : STD_LOGIC_VECTOR (63 downto 0);
        signal int_bus2 : STD_LOGIC_VECTOR (63 downto 0);
        signal int_bus3 : STD_LOGIC_VECTOR (31 downto 0);
        signal lower : STD_LOGIC_VECTOR (31 downto 0);
        signal higher : STD_LOGIC_VECTOR (31 downto 0);
        signal intermid : STD_LOGIC_VECTOR (31 downto 0);
        signal curr_key : STD_LOGIC_VECTOR (31 downto 0);
        signal got_data: std_logic;      --data written in    
        signal variable_test: std_logic:= '0';      
        signal n_ready: std_logic; --code assembled
        signal k_ready: std_logic; --key selected
        signal k_added: std_logic; --key added
        signal sub_ready: std_logic; --blocks substituted
        signal sh_ready: std_logic; --shift done
        signal xor_ready: std_logic; --xor done
        signal out_ready: std_logic; --ready for output
        signal sent_data: std_logic; --data written out  
        signal start_again: std_logic; --start the main step again
        type arr is array (0 to 15) of std_logic_vector(31 downto 0);
        type key is array (0 to 7) of std_logic_vector(31 downto 0);
        type key_num is array (0 to 31) of integer;
        signal key_it : key_num := (0,1,2,3,4,5,6,7,
                                             7,6,5,4,3,2,1,0,
                                             7,6,5,4,3,2,1,0,
                                             7,6,5,4,3,2,1,0);

        signal tab : arr := (X""00000001"",
                                    X""00000002"",
                                    X""00000003"",
                                    X""00000004"",
                                    X""00000005"",
                                    X""00000006"",
                                    X""00000007"",
                                    X""00000008"",
                                    X""00000009"",
                                    X""0000000a"",
                                    X""0000000b"",
                                    X""0000000c"",
                                    X""0000000d"",
                                    X""0000000e"",
                                    X""0000000f"",
                                    X""00000000"");  

        signal tab_key : key := (X""00000007"",
                                         X""00000006"",
                                         X""00000005"",
                                         X""00000004"",
                                         X""00000003"",
                                         X""00000002"",
                                         X""00000001"",
                                         X""00000000"");

        component adder is 
        port(   dataa       : IN STD_LOGIC_VECTOR (31 DOWNTO 0);
                datab       : IN STD_LOGIC_VECTOR (31 DOWNTO 0);
                result      : OUT STD_LOGIC_VECTOR (31 DOWNTO 0));
        END component;

        begin

        add1: adder
            port map (lower, curr_key, int_bus3);

        process (clk, in_data)
        variable i: INTEGER := 0;
        variable j: INTEGER := 0;
        variable k: INTEGER := 0;


        begin
          -- assembling input code into one piece
          if (rising_edge(clk)) then
              if (i&lt;8) then
                 int_bus1(63 downto 56)&lt;=in_data;
                got_data &lt;= '1';
                n_ready &lt;= '0';
                 if (got_data = '1') then 
                     --shift right 8 bits 
                     int_bus1(55 downto 0) &lt;= int_bus1(63 downto 8);
                     i := i + 1;
                     got_data &lt;= '0';
                 end if;
              end if;

                 if (i = 8 and n_ready = '0' and out_ready = '0') then
                     lower&lt;=int_bus1(31 downto 0);
                     higher&lt;=int_bus1(63 downto 32);
                     n_ready &lt;= '1';
                     start_again &lt;= '1';
                 end if;
          end if; 



          if (n_ready ='1') then
          -- base encryption step
             if (rising_edge(clk)) then
             if (j &lt;32 and start_again = '1') then
             -- key/step dependence
                 curr_key &lt;= tab_key(key_it(j));
                k_ready &lt;= '1';
                start_again &lt;= '0';
             end if;   

             if (k_ready = '1') then 
                    lower &lt;= curr_key + lower;
                    k_added &lt;= '1';
                    k_ready &lt;='0';
             end if;

             if (k_added = '1') then
                    --block substitution
                    lower(3 downto 0) &lt;= tab(CONV_INTEGER(lower(3 downto 0)))(3 downto 0);
                    lower(7 downto 4) &lt;= tab(CONV_INTEGER(lower(7 downto 4)))(7 downto 4);
                    lower(11 downto 8) &lt;= tab(CONV_INTEGER(lower(11 downto 8)))(11 downto 8);
                    lower(15 downto 12) &lt;= tab(CONV_INTEGER(lower(15 downto 12)))(15 downto 12);
                    lower(19 downto 16) &lt;= tab(CONV_INTEGER(lower(19 downto 16)))(19 downto 16);
                    lower(23 downto 20) &lt;= tab(CONV_INTEGER(lower(23 downto 20)))(23 downto 20);
                    lower(27 downto 24) &lt;= tab(CONV_INTEGER(lower(27 downto 24)))(27 downto 24);
                    lower(31 downto 28) &lt;= tab(CONV_INTEGER(lower(31 downto 28)))(31 downto 28);
                    sub_ready &lt;= '1';
                    k_added &lt;= '0';
             end if;    

             if (sub_ready = '1') then
                  --shift 11 bits right cyclically
                    lower(31 downto 21) &lt;= lower(10 downto 0);
                    lower(20 downto 0) &lt;= lower(31 downto 11);
                    sh_ready&lt;= '1';
                    sub_ready &lt;= '0';
             end if;

             if (sh_ready = '1') then
                    higher &lt;= lower xor higher;
                    lower &lt;= higher;
                    sh_ready&lt;= '0';
                    j:=j+1;
                    start_again &lt;= '1';
                    out_ready &lt;= '0'; 
              end if;
              end if; 
             end if;     

         if (rising_edge(clk)) then
              if (j = 32 and out_ready = '0') then
                j:=j+1;
                variable_test &lt;= '1'; --artifact of testing the behavior of variables
              end if;   


         end if;
          -- assembling output code into one piece
          if (rising_edge(clk)) then  
            if (out_ready = '0' and variable_test = '1') then
                 int_bus2 (63 downto 32) &lt;= higher;
                 int_bus2 (31 downto 0) &lt;= lower;
                 out_ready &lt;= '1';
                 n_ready &lt;= '0';
            end if;

             if (out_ready = '1' and k&lt;8) then
                 out_data&lt;=int_bus2(7 downto 0);
                 sent_data &lt;= '1';
                 if (sent_data ='1') then 
                    --shift right 8 bits 
                     int_bus2(55 downto 0) &lt;= int_bus2(63 downto 8);
                     k := k + 1;
                     sent_data &lt;= '0';
                 end if;
            end if;
         end if;
        end process; 
        end behavioral;


And I'm getting the following errors: 


  Error (10821): HDL error at decoder10.vhd(106): can't infer register for start_again because its behavior does not match any supported register model
  Info (10041): Inferred latch for start_again at decoder10.vhd(75)
  Error (10821): HDL error at decoder10.vhd(106): can't infer register for higher[0] because its behavior does not match any supported register model
  Info (10041): Inferred latch for higher[0] at decoder10.vhd(75)
  (this continues for the first 18 bits of ""higher"")


Why won't it synthesize? And why can't only first 18 bits of higher be inferred?","It's most probably because your clock enable has higher priority than your clock, and that no FPGA hardware exists that allows this. Whenever you write code for synthesis you need to think about if this can actually map to the underlying hardware.
So instead of 

if (n_ready ='1') then
  -- base encryption step
  if (rising_edge(clk)) then
    (...)


Try:

if(rising_edge(clk)) then
  if(n_ready = '1') then
    (...)


And have a look at Get your priorities right - it's written for Xilinx FPGAs, but I'd guess that something similar applies to other makes also.",,,,,
VHDL login terminal,"i am beginner in VHDL and i need do login terminal. For example i have fixed password 7010. I need implement only funcionality of automat. I want to have defined one signal, that will hold count of keys presses and will be incremented each time. 

But i dont know how to initialize signal and incerement it, because when i initialize signal in one process, i cant increment its value in other process. If i dont intialize that signal, then my code not work and i dont know why. For example doSomething will not be runned if i dont that signal to ""0000"". But i need incerement its value in doSomething... Sry for my bad english. 

if(mySignal = ""0000"")
    doSomething
","What you are trying to do sounds like a class assignment.

Break the problem down. 

Draw a block diagram of what you want

In synthisisable VHDL you are correct in saying, unless the signal can be high Z, multiple drivers are not allowed.  But there is nothing to stop you taking a copy of the signal and using that in another process.  

Make use of unsigned types for counters or any signal that has magnitude, it makes life much easier

doSomething:process(clk,mySignal
begin
    if rising_Edge(clk) then
        if mySignal = ""0000"" then
            count&lt;=count+1;
        end if;
    end if;
end process;
",,,,,
Splitting a bit array into smaller arrays in Verilog,"This is probably easy, but sadly I can't really find the answer.
Let's say I have...

input [31:0] controls;


How would I declare a bit array I can return that equals a segment of those bits, such as 6-0 or 31-25?","I'm not sure I totally understand the question (it's a little vague to me), but are you just looking for this?

wire [6:0] controls_part;
assign controls_part = controls[31:25]; 


Or can you elaborate a little more?",,,,,
Verilog: Pass a vector as a port to a module,"I have two modules


counter: Output is a vector called error_count.
lcd: Module to display the code on an LCD. Input includes clock and error_count.


Following snippet of the code is most relevant and attached below:


Top level module:

counter counter1 (..., error_count);
lcd lcd1 (..., error_count);
counter module:


module counter (..., error_count);
...
output reg [31:0] error_count = 0;
... //Update counter every clock cycle
endmodule

lcd module:


module lcd (..., error_count);
...
input [31:0] error_count;
... //error_count used to display on LCD
endmodule



What is wrong with this code? The display just prints 0 as the output. Is there anything wrong with the way I am passing the the vector?

Additional Info:
I am using the Xilinx Spartan 3E starter kit for testing this code. The LCD code is fine and I have tested it with local counter (which was reg[31:0]).","You need to declare 32-bit wire within the top-level module to connect the two ports.

wire [31:0] error_count;

If you leave this out, an implicit net is declared which is only a 1-bit wire and will not connect the vectors properly.

This mistake is a classic Verilog gotcha. The presentation here has a good explanation of this one and others:

http://www.sutherland-hdl.com/papers/2006-SNUG-Boston_standard_gotchas_presentation.pdf",,,,,
"Warning ""has no load"", but I can't see why","I got these warnings from Lattice Diamond for each instance of any uart (currently 11)

WARNING - ngdbuild: logical net 'UartGenerator_0_Uart_i/Uart/rxCounter_cry_14' has no load
WARNING - ngdbuild: logical net 'UartGenerator_0_Uart_i/Uart/rxCounter_cry_0_COUT1_9_14' has no load
WARNING - ngdbuild: logical net 'UartGenerator_0_Uart_i/Uart/rxCounter_cry_12' has no load
WARNING - ngdbuild: logical net 'UartGenerator_0_Uart_i/Uart/rxCounter_cry_10' has no load
WARNING - ngdbuild: logical net 'UartGenerator_0_Uart_i/Uart/rxCounter_cry_8' has no load
WARNING - ngdbuild: logical net 'UartGenerator_0_Uart_i/Uart/rxCounter_cry_6' has no load
WARNING - ngdbuild: logical net 'UartGenerator_0_Uart_i/Uart/rxCounter_cry_4' has no load
WARNING - ngdbuild: logical net 'UartGenerator_0_Uart_i/Uart/rxCounter_cry_2' has no load
WARNING - ngdbuild: logical net 'UartGenerator_0_Uart_i/Uart/rxCounter_cry_0' has no load


The VHDL-code is

entity UART is 
    generic (
        dividerCounterBits: integer := 16
    );
    port (
        Clk         : in  std_logic;                        -- Clock signal
        Reset       : in  std_logic;                        -- Reset input
        ClockDivider: in  std_logic_vector(15 downto 0);

        ParityMode  : in std_logic_vector(1 downto 0);      -- b00=No, b01=Even, b10=Odd, b11=UserBit
    [...]


architecture Behaviour of UART is
    constant oversampleExponent : integer := 4;

    subtype TxCounterType is integer range 0 to (2**(dividerCounterBits+oversampleExponent))-1;
    subtype RxCounterType is integer range 0 to (2**dividerCounterBits)-1;
    signal rxCounter: RxCounterType;
    signal txCounter: TxCounterType;
    signal rxClockEn: std_logic; -- clock enable signal for receiver
    signal txClockEn: std_logic; -- clock enable signal for transmitter
begin
    rxClockdivider:process (Clk, Reset)
    begin
        if Reset='1' then
        rxCounter &lt;= 0;
        rxClockEn &lt;= '0';
    elsif Rising_Edge(Clk) then
        -- RX counter (oversampled)
        if rxCounter = 0 then
            rxClockEn &lt;= '1';
            rxCounter &lt;= to_integer(unsigned(ClockDivider));
        else
            rxClockEn &lt;= '0';
            rxCounter &lt;= rxCounter - 1;
        end if;
    end if;
    end process;

    txClockDivider: process (Clk, Reset)
    [...]

    rx: entity work.RxUnit
    generic map (oversampleFactor=&gt;2**oversampleExponent)
    port map (Clk=&gt;Clk, Reset=&gt;Reset, ClockEnable=&gt;rxClockEn, ParityMode=&gt;ParityMode,
            ReadA=&gt;ReadA, DataO=&gt;DataO, RxD=&gt;RxD, RxAv=&gt;RxAv, ParityBit=&gt;ParityBit,
            debugout=&gt;debugout
             );

end Behaviour;


This is a single Uart, to create them all (currently 11 uarts) I use this

-- UARTs

    UartGenerator: For i IN 0 to uarts-1 generate
    begin
        Uart_i : entity work.UartBusInterface 
            port map (Clk=&gt;r_qclk, Reset=&gt;r_reset, 
                cs=&gt;uartChipSelect(i), nWriteStrobe=&gt;wr_strobe, nReadStrobe=&gt;rd_strobe,
                address=&gt;AdrBus(1 downto 0), Databus=&gt;DataBus,
                TxD=&gt;TxD_PAD_O(i), RxD=&gt;RxD_PAD_I(i),
                txInterrupt=&gt;TxIRQ(i), rxInterrupt=&gt;RxIRQ(i), debugout=&gt;rxdebug(i));

        uartChipSelect(i) &lt;= '1' when to_integer(unsigned(adrbus(5 downto 2)))=i+4 and r_cs0='0' else '0';
    end generate;


I can syntesis it and the uarts work, but why I got the warning?  

IMHO the rxCounter should use each single possible value, but why each second bit creates the warning ""has no load""?  

I read somewhere that this mean that these net's aren't used and will be removed.
But to count from 0 to 2^n-1, I need no less than n-bits.","This warning means that nobody is ""listening"" to those nets. 

It is OK to have signals that will be removed in synthesis. Warnings are not Errors! You just need to be aware of them.

We cannot assess what is happening from your partial code. 


Is there a signal named rxCounter_cry?
What is the datatype of ClockDivider? 
What is the value of dividerCounterBits?
What happens in the other process? If it is irrelevant, please try to run your synthesis without that process. If it is relevant, we need to see it.
",,,,,
Can't compile a self programmed function on ModelSim,"I got a problem with compiling a VHDL code, I get a error when at :

use bin2bcd.all;

by the way the code works on ISE by not on ModelSIm any Idea ???!! !
thanks in advance. 

library ieee; 
use ieee.std_logic_1164.all; 
use ieee.std_logic_arith.all; 
use ieee.std_logic_unsigned.all; 
library bin2bcd; 
use bin2bcd.all; 


and bin2bcd is : 

library IEEE; 
use IEEE.STD_LOGIC_1164.all; 
use IEEE.STD_LOGIC_UNSIGNED.all; 
package bin2bcd is 
function to_bcd ( bin : std_logic_vector(11 downto 0) ) return std_logic_vector; 
end bin2bcd;
","When you compile bin2bcd, it goes into the work library (unless youv'e made the compiler do something else).

This means you need to do:

use work.bin2bcd.all

Looking at this:

library bin2bcd; 
use bin2bcd.all; 


you may actually have compiled a package called bin2bcd into a library called bin2bcd.

in which case you need to do this

library bin2bcd; 
use bin2bcd.bin2bcd.all; 
",,,,,
VHDL Functions requiring additional LEs?,"I am creating a package that has multiple definitions similar to the following

    -- Control Register Address Type Declaration
    SUBTYPE ctrl_reg_addr_type IS std_logic_vector( ADDR_BITS-1 DOWNTO 0 );
    -- Control Register Data Type Declaration
    SUBTYPE ctrl_reg_data_type IS std_logic_vector( DATA_BITS-1 DOWNTO 0 );
    -- Control Register Type Declaration
    SUBTYPE ctrl_reg_word_type IS std_logic_vector( CTRL_BITS-1 DOWNTO 0 );

    -- Left/Right Line-In Control Type Declarations
    CONSTANT LINE_IN_VOL_BITS : integer := 5;

    SUBTYPE line_in_volume_type IS natural
    RANGE 0 TO ( 2**LINE_IN_VOL_BITS )-1;

    TYPE line_in_ctrl_type IS RECORD

        -- Left/Right Channel Line Input Volume (4:0)
        -- Registers: LINVOL/RINVOL
        -- 0x1F = +12.0dB
        -- ...  =   1.5dB steps
        -- 0x00 = -34.5dB
        -- 0x17 - 0dB (Default)
        volume : std_logic_vector( LINE_IN_VOL_BITS-1 DOWNTO 0 );
        -- Left/Right Channel Line Input Mute to ADC (7)
        -- Registers: LINMUTE/RINMUTE
        -- 0x1 = Enable Mute
        -- 0x0 = Disable Mute
        mute   : std_logic;
        -- Left/Right Channel Line Input Volume and Mute Load (8)
        -- Registers: LRINBOTH/RLINBOTH
        -- 0x1 = Enable Simultaneous Load of LINVOL/LINMUTE &lt;-&gt; RINVOL/RINMUTE
        -- 0x0 = Disable Simultaneous Load
        both   : std_logic;

    END RECORD line_in_ctrl_type;


I would like to use functions similar to the following to modify the fields within the record types.

    -- Left/Right Line-In Increase Volume Function Body
    FUNCTION increase_volume( ctrl : line_in_ctrl_type )
    RETURN line_in_ctrl_type IS

        VARIABLE volume : line_in_volume_type := 0;
        VARIABLE tmp    : line_in_ctrl_type;

    BEGIN

        tmp    := ctrl;
        volume := natural( to_integer( unsigned( ctrl.volume ) ) );

        IF ( volume &lt; line_in_volume_type'HIGH ) THEN

            volume     := volume + 1;

            tmp.volume := std_logic_vector(
                              to_unsigned( volume, LINE_IN_VOL_BITS ) );

        END IF;

        RETURN ( tmp );

    END FUNCTION increase_volume;

    -- Left/Right Line-In Increase Volume Function Body
    FUNCTION increase_volume( ctrl : line_in_ctrl_type;
                              step : natural )
    RETURN line_in_ctrl_type IS

        VARIABLE volume : line_in_volume_type := 0;
        VARIABLE tmp    : line_in_ctrl_type;

    BEGIN

        tmp    := ctrl;
        volume := natural( to_integer( unsigned( ctrl.volume ) ) );

        IF ( volume &lt; ( line_in_volume_type'HIGH - step ) ) THEN

            volume     := volume + step;

            tmp.volume := std_logic_vector(
                              to_unsigned( volume, LINE_IN_VOL_BITS ) );

        ELSE

            tmp := increase_volume( tmp );

        END IF;

        RETURN ( tmp );

    END FUNCTION increase_volume;


My questions is, will using functions similar to the examples shown, use more LEs than explicitly modifying record values.","Using functions in VHDL is very abstract (as VHDL should be).  It can be about as far from RTL as you can get. This means asking what will be inteferred in LE's at is really difficult to determine.  It mostly depends on the synthesis tools and how they pick out logical constructs.

A function is synthesised more like a macro.  Each time you call it, you may end up instantiating another instance of the same logical block.  How often are you calling it?

For efficient LE usage you need to write code that re-uses functional blocks.  e.g. Write a generic structure read/write engine and use it once, but route the inputs and outputs from/to various places.

If you are worried about LE usage, and still want to use functions, I suggest considering if you have a big enough FPGA.",,,,,
Incompatible modes for port vhdl,"I am getting the following error with my code: ** Failure: (vsim-3808) Incompatible modes for port ""d_out"".

I specified a new component, defined its entity, connected its ports, everything seemd ok and even compiled but when I ran a tb it wrote an error that appears in the headline

this is part of the code:

signal jal_nor_out: std_logic;
 jal_unit: jal_nor
port map(
data_in(5 downto 0) =&gt; instruction(31 downto 26),
d_out =&gt; jal_nor_out
);
jal_writedata_mux : Mux_2to1_xN
port map(
    sel =&gt; jal_nor_out,
    d_in1 =&gt; WriteData,
    d_in2 =&gt; pc_inc,
    d_out =&gt; data_mux_out
    );


and on another file I have:

    entity jal_nor is
    port(
    data_in : in std_logic_vector(5 downto 0);
    d_out : out std_logic
    );
end jal_nor;
architecture bhv of jal_nor is
    begin
        process (data_in) 
          begin
            if data_in=""000011"" then
                d_out &lt;= '1';
            else
                d_out &lt;= '0';
            end if;
        end process;
    end bhv;


this is the Mux code

    entity Mux_2to1_xN is
  generic(
           WIDTH :     integer := 32);
  port(
        sel   : in  std_logic;
        d_in1 : in  std_logic_vector((WIDTH - 1) downto 0);
        d_in2 : in  std_logic_vector((WIDTH - 1) downto 0);
        d_out : out std_logic_vector((WIDTH - 1) downto 0));
end Mux_2to1_xN;


any help?","Sounds like the compiler thinks you have told it two different things about the ports.  Have you used any component declarations?

debugging advice:

Make a smaller testcase - keep chopping code out until you have the tiniest subset of the code which causes the error.  Take out ports which don't matter, signals that are unused, everything else.  In the process of doing this you'll find a very small code subset is causing the problem, and probably be able to fix it yourself.  If not, you have a small self-contained piece of code you can post here for us to look at.  Just the tiniest code, not with lots of lines commented out.  And make sure what you post compiles to the same error...",,,,,
@() inside an always block,"Whether using @() inside an always block is a bad practice or in other words it is wrong? The example code is given below:

always@(negedge clk)begin

        @(valueI)begin
            deterministicEnable=0;
            iterate=iterate+1;
            deterministicEnable=1;
            j=0;
            $display(""%h  %d   %d"",valueI,$time,j);
        end

end
",It's wrong for synthesisable code. It's not wrong for your testbench.,,,,,
How to unpack LUTs into logic cells in verilog,"I have a structural verilog containing LUTS all over him.

I want this verilog to be unpacked so that I'll have the same functional but instead LUTS - I'll have logic cell (Like Or/And/Xor etc...).

How can I do it ? 

Does Yosys has something built in ?
Is there something else out there over the internet who already implement that kind of thing ?
Because I searched for this and I could not find. ","You could do something like the following

read_verilog struct.v lut.v
hierarchy -top top
flatten
synth -noabc


in Yosys, where lut.v contains a Verilog model of the LUT primitive. This would convert LUTs to non-optimised logic. You could also use abc (remove -noabc, or add abc at the end of the script) to optimise the logic.",,,,,
"VHDL with-select error expecting ""("", or an identifier or unary operator","I am writing a 2bit 4 input multiplexer in VHDL based solely on a truth table. I am using the with-select statement Code . However I get the following error messages: Error messages on the last 4 lines. I cannot find any syntax errors and looking at other examples of with-select look exactly like mine. 
I am thinking I might have made a mistake with assigning vector values but I can't find the error. 
The software is Quartus Prime Lite. 

Code: 

LIBRARY ieee;
use ieee.std_logic_1164.all; 
    entity tut43mux IS 
        PORT(
        --sw: in Std_Logic_Vector(9 downto 0);
        --LEDR: out Std_Logic_Vector(9 downto 0));
        sw: in Std_Logic_Vector(0 to 9);
        LEDR: out Std_Logic_Vector(0 to 9));
        end tut43mux;

    architecture behavior of tut43mux is
        --signal s,u,v,w,x,t,y,m: Std_Logic_Vector(1 downto 0);
        signal s,u,v,w,x,m: Std_Logic_Vector(0 to 1);
        begin
            LEDR(0)&lt;=m(0);LEDR(1)&lt;=m(1);

            LEDR(2)&lt;=sw(2);LEDR(3)&lt;=sw(3);
            LEDR(4)&lt;=sw(4);LEDR(5)&lt;=sw(5);
            LEDR(6)&lt;=sw(6);LEDR(7)&lt;=sw(7);
            LEDR(8)&lt;=sw(8);LEDR(9)&lt;=sw(9);

            s(0)&lt;=sw(0);s(1)&lt;=sw(1);
            u(0)&lt;=sw(2);u(1)&lt;=sw(3);
            v(0)&lt;=sw(4);v(1)&lt;=sw(5);
            w(0)&lt;=sw(6);w(1)&lt;=sw(7);
            x(0)&lt;=sw(8);x(1)&lt;=sw(9);

            with s select m     
                    &lt;= u when ""00"",
                    &lt;= v when ""01"",
                    &lt;= w when ""10"",
                    &lt;= x when ""11"",
                    &lt;= ""00"" when others;

        end architecture behavior;
","you only need &lt;= for the first assignement in the with.. select statement. The rest do not need it. 

with s select
  m &lt;= u when ""00"",
       v when ""01"",
       w when ""10"",
       x when ""11"",
    ""00"" when others;
",,,,,
"What is the difference between simple assignments with ""initial"" block and without it?","For Example, what is the difference between these two implementations?

with initial statment:

module with_initial();
reg clk,reset,enable,data;

initial begin
  clk=0;
  reset=0;
  enable=0;
  data=0;
end

always @(â€?
..
end

endmodule


and here without using an initial statement:

module without_initial();
reg clk,reset,enable,data;

clk=0;
reset=0;
enable=0;
data=0;

always @(â€?
..
end

endmodule
","The code in without_initial is not legal syntax, and it should produce compile errors for you, as it does for the simulators on edaplayground.

Procedural assignments must be inside an initial or always block.  Refer to IEEE Std 1800-2017, section 10.4 Procedural assignments.

Also, a reg can be declared with an initial value outside of an initial block:

module without_initial;

reg clk=0;
reg reset=0;
reg enable=0;
reg data=0;

endmodule


Refer to IEEE Std 1800-2017, section 6.8 Variable declarations.",,,,,
Is it possible to define looping functions in a test bench,"I am doing a past paper in preparation for an exam and one of the questions shows this waveform:

Now I know of course that you could just write the code out line by line like so:

sig1 &lt;= '1'; sig2 &lt;= '1'; y &lt;= '1'; wait for 20 ns;
y &lt;= '0'; wait for 5 ns;
-- etc.


or by utilising arrays. I was wondering if it was possible to streamline the process by setting up looping functions that can be called and run simultaneously.

-- Some pseudocode
function sig1 is
    sig1 &lt;= '1'; wait for 25 ns;
    sig1 &lt;= '0'; wait for 50 ns;
end sig1;

-- Definition for the other waves goes here

function waveform is
    while n=1 loop
        sig1, sig2, y run;
    end loop;
end waveform;


I've already had a poke around the documentation for VHDL and here on Stack Overflow but I must apologise in advance, I haven't a clue as to what you would call something like this so my searches haven't yielded any results close to what I am thinking. This is just a curiosity of course, I already expect that because of the nature of the hardware and language in question it just might not be possible.

Thank you though in advance for any help!","VHDL for test bench can be more software like, since it does not need to be synthesizable.

The Â´yÂ´ part can be written with loop as shown below, and the other parts can be made in a similar fashion.

library ieee;
use ieee.std_logic_1164.all;

entity tb is
end entity;


architecture sim of tb is
  signal y : std_logic;
begin
  process is
    constant period : time := 80 ns;
    constant steps  : natural := 8;
  begin
    for i in 0 to steps - 1 loop
      case i is
        when 0 | 1 | 3 =&gt; y &lt;= '1';
        when others =&gt; y &lt;= '0';
      end case;
      wait for period / steps;
    end loop;
  end process;
end architecture;


The above makes use of the VHDL feature, that a process without sensitivity list will restart when the end is reached.

Waveform will be:

",,,,,
How to prevent new threads of SVA,"Lets assume, I have a button in my design. I want to increment counter between next two clock when button has been pressed three times and I want to check this behaviour with SVA.
I have wrote this one:

`timescale 1ns / 1ps
module tb();

parameter NUMBER_OF_PRESSES = 10;
parameter CLK_SEMI_PERIOD = 5;

bit clk;
always #CLK_SEMI_PERIOD clk = ~clk;

bit button_n;
bit reset_n;
logic [7:0] counter;

property p;
  logic[7:0] val;
  disable iff(!reset_n) @(posedge clk) (($fell(button_n)[=3]),val=counter) |=&gt; ##[0:2] (counter== val+1);
endproperty
assert property(p);



initial begin
    automatic bit key_d;
    automatic byte key_lat;
    automatic byte key_press_count;
    reset_n = 1;
    button_n = 1;
    counter = 0;
    fork
        begin
            repeat(NUMBER_OF_PRESSES) begin
                repeat(5)begin
                    @(negedge clk);
                end
                button_n = 0;
                key_lat = $urandom_range(1,4);
                repeat(key_lat) begin
                    @(negedge clk);
                end
                button_n = 1;
            end
        end
        begin
            forever begin
                @(posedge clk);
                if(!button_n &amp;&amp; key_d) begin
                    key_press_count++;
                end
                if(key_press_count == 3) begin
                    counter++;
                    key_press_count = 0;
                end
                key_d = button_n;
            end
        end
    join_any
end

endmodule


This works good at first three press, but then it will always throw assertion error, because it has been started new thread of assertion at each button press. So, I need to prevent testbench from doing this. When repetitition has been started I don't need to start new threads.
How can I do this?","I am not confident I fully understand your question. Let me first state my understanding and where I think your problem is. Apologise if I am mistaken. 

You intend to detect negedges on button_n (""presses""), and on the third one, you increment ""counter"".

The problem here is that your stated objective (which actually matches the SVA) and your design do different things.

Your SVA will check that the counter has the expected value 1-3 cycles after every third negedge. This holds for press 0, 1 and 2. But it must also hold for press 1, 2 and 3. And press 2, 3 and 4 etc. I suspect the assertion passes on press 2 and then fails on press 3. I.e. you check that you increment your counter on every press after the third.

Your design, on the other hand does something different. It counts 3 negedges, increments counter, and it then starts counting from scratch.

I would advise against the use of local variables in assertions unless you are certain that it is what you need - I don't think this is the case here. You can have your SVA trigger on key_press_count == 3 (assuming you ofc define key_press_count appropriately and not as an automatic var).

If you insist on using your local SVA variable you can slightly modify your trigger condition to include counter. For example something along the lines of (though may be slightly wrong, have not tested):
(counter == 0 || $changed(counter)) ##1 ($fell(button_n)[=3], val = counter)

IMO that's a bad idea and having supporting RTL is the better way to go here to document your intention as well as check exactly the behaviour you are after. 

Hope this helps",,,,,
Testbench is returning undefinded values in Modelsim,"I am coding a pattern generator in VHDL.
I finished it recently but now I have a problem with the test-bench. 

My Code:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.std_logic_unsigned.all;

entity pattern_gen is
    Port ( 
    clk_i : in STD_LOGIC;-- 100Mhz clock on Basys 3 FPGA board

    x : in INTEGER;
    y: in INTEGER;
    modus : in STD_LOGIC;
    enable : in STD_LOGIC;

    red : out STD_LOGIC_VECTOR(3 downto 0);
    green : out STD_LOGIC_VECTOR(3 downto 0);
    blue : out STD_LOGIC_VECTOR(3 downto 0)
    );
end pattern_gen;

architecture Behavioral of pattern_gen is
    signal segment_x : integer := 0;
    signal segment_y : integer := 0;

begin
    stripes : PROCESS(modus, segment_x, x, clk_i)
    BEGIN
        IF( clk_i'EVENT and clk_i = '1') then
            IF(modus = '0' AND enable = '1' ) THEN        --Mod 0 -&gt; Stripes enabled
                    IF(x &lt; (40+ (160*(segment_x-1)))) THEN
                        red &lt;= (OTHERS =&gt; '1');
                        green  &lt;= (OTHERS =&gt; '0');
                        blue &lt;= (OTHERS =&gt; '0');
                    ELSE IF(x &lt; (80+ (160*(segment_x-1)))) THEN
                        red &lt;= (OTHERS =&gt; '0');
                        green  &lt;= (OTHERS =&gt; '1');
                        blue &lt;= (OTHERS =&gt; '0');
                        ELSE IF(x &lt; (120+ (160*(segment_x-1)))) THEN
                            red &lt;= (OTHERS =&gt; '0');
                            green  &lt;= (OTHERS =&gt; '0');
                            blue &lt;= (OTHERS =&gt; '1');
                            ELSE IF(x &lt; (160+ (160*(segment_x-1)))) THEN
                                red &lt;= (OTHERS =&gt; '0');
                                green  &lt;= (OTHERS =&gt; '0');
                                blue &lt;= (OTHERS =&gt; '0');
                            END IF;
                        END IF;
                    END IF;
                END IF;
            END IF;
        end if;
    END PROCESS;

    panels: PROCESS(modus, segment_x, segment_y, clk_i)
    variable i: integer range -10 to 100;
    BEGIN
        IF(clk_i'EVENT and clk_i = '1') then 
            IF(modus = '1' AND enable = '1' ) THEN        --Mod 1 -&gt; Panels enabled
                    i := segment_x*segment_y;

                    while (i&gt;0) loop
                        IF (i = 1) then
                            red &lt;= (OTHERS =&gt; '1');
                            green  &lt;= (OTHERS =&gt; '0');
                            blue &lt;= (OTHERS =&gt; '0');
                        else if(i = 2) then
                            red &lt;= (OTHERS =&gt; '0');
                            green  &lt;= (OTHERS =&gt; '1');
                            blue &lt;= (OTHERS =&gt; '0');
                            else if(i=3) then
                                red &lt;= (OTHERS =&gt; '0');
                                green  &lt;= (OTHERS =&gt; '0');
                                blue &lt;= (OTHERS =&gt; '1');
                                end if;
                            end if;
                        end if;

                        i := i - 3;

                    end loop;
            END IF;
        END IF;
    END PROCESS;

    segment: PROCESS(x, y, modus, clk_i)
    variable i: integer range 0 to 10;
    BEGIN
        if(clk_i'EVENT and clk_i = '1') then
            IF(modus = '0' AND enable = '1') THEN
                i := 1;
                while i&lt;=4 loop
                    IF(x &lt; (i * 160))then
                        segment_x &lt;= i;
                        exit;
                    END IF;
                    i := i +1;
                END loop;
            ELSIF (modus = '1' AND enable = '1') THEN --Mod 1 -&gt; Panels enabled
                i:=1; --reset i for horizintal segment 
                while i&lt;=10 loop
                    IF(x &lt; (i * 64))then
                        segment_x &lt;= i;
                        exit;
                    END IF;
                    i := i +1;
                end loop;
                i:=1; --reset i for vertical segment
                while i&lt;=10 loop
                    IF(y &lt; (i * 48)) then
                        segment_y &lt;= i;
                        exit;
                    end if;
                    i := i +1;
                end loop;   
            END IF;
        end if; 
     END PROCESS;
end Behavioral;


The testbench is very short, I just want to test a few cases.

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.std_logic_unsigned.all;
entity pattern_gen_tb is

end entity;

architecture sim of pattern_gen_tb is
component pattern_gen
   Port ( 
    clk_i : in STD_LOGIC;

    x : in INTEGER;
    y: in INTEGER;
    modus : in STD_LOGIC;
    enable : in STD_LOGIC;

    red : out STD_LOGIC_VECTOR(3 downto 0);
    green : out STD_LOGIC_VECTOR(3 downto 0);
    blue : out STD_LOGIC_VECTOR(3 downto 0)
    );
end component;

signal clk_s : STD_LOGIC := '0';

signal x_s : INTEGER;
signal y_s : INTEGER;
signal modus_s : std_logic;
signal enable_s : std_logic;

signal red_s : STD_LOGIC_VECTOR(3 downto 0);
signal green_s :STD_LOGIC_VECTOR(3 downto 0);
signal blue_s : STD_LOGIC_VECTOR(3 downto 0);

begin
    uut : pattern_gen
    port map(
        clk_i =&gt; clk_s,

        x =&gt; x_s,
        y =&gt; y_s,
        modus =&gt; modus_s,
        enable =&gt; enable_s,

        red =&gt; red_s,
        green =&gt; green_s,
        blue =&gt; blue_s
        );
    clk_s  &lt;= not clk_s after 10 ns;

 p_test : process
 begin
    x_s &lt;= 44; 
    y_s&lt;= 300;
    modus_s &lt;= '0';
    enable_s &lt;= '1'; -- result should be green(1,1,1,1)

    wait; 

end process;

end sim;


The Result of the Simulation is undefined even though Segment is calculated correctly and the second If Statement should trigger because 
44 &lt; (80 + 160 * (1-1)) therefore  the Output should be 

Segment 1 and Stripe 2 -> green (1,1,1,1) red and blue(0,0,0,0)



What am I missing? I've been trying to get it working for hours now.","You drive red, green, and blue from multiple processes.

Having searched the to date 152 posts on multiple drivers there's not a single posted question with an upvoted answer that adequately explains why or how you return 'U's (or in some cases 'X's).

IEEE Std 1076-2008
14.7 Execution of a model
14.7.2 Drivers


  Every signal assignment statement in a process statement defines a set of drivers for certain scalar signals. There is a single driver for a given scalar signal S in a process statement, provided that there is at least one signal assignment statement in that process statement and that the longest static prefix of the target signal of that signal assignment statement denotes S or denotes a composite signal of which S is a subelement. Each such signal assignment statement is said to be associated with that driver. Execution of a signal assignment statement affects only the associated driver(s).


14.7.3.2 Driving values  

>
The driving value of any signal S is determined by the following steps:  


  
    ...
    e) If S is a basic signal:  
    
    
      ...
      â€?If S is a resolved signal and has one or more sources, then the driving values of the sources of S are examined. ... the driving value of S is obtained by executing the resolution function associated with S, where that function is called with an input parameter consisting of the concatenation of the driving values of the sources of S, with the exception of the value of any source of S whose current value is determined by the null transaction.
    
  


How that resolution function is operated is described in 14.7.3.2 Driving values.

The type or subtype std_logic_vector (-2008) is resolved composite type or sutype with a resolved element type (-2008) that uses a resolution function for it's elements provided in IEEE package std_logic_1164, the package body:

  -------------------------------------------------------------------
  -- resolution function
  -------------------------------------------------------------------
  constant resolution_table : stdlogic_table := (
    --      ---------------------------------------------------------
    --      |  U    X    0    1    Z    W    L    H    -        |   |
    --      ---------------------------------------------------------
             ('U', 'U', 'U', 'U', 'U', 'U', 'U', 'U', 'U'),  -- | U |
             ('U', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X'),  -- | X |
             ('U', 'X', '0', 'X', '0', '0', '0', '0', 'X'),  -- | 0 |
             ('U', 'X', 'X', '1', '1', '1', '1', '1', 'X'),  -- | 1 |
             ('U', 'X', '0', '1', 'Z', 'W', 'L', 'H', 'X'),  -- | Z |
             ('U', 'X', '0', '1', 'W', 'W', 'W', 'W', 'X'),  -- | W |
             ('U', 'X', '0', '1', 'L', 'W', 'L', 'W', 'X'),  -- | L |
             ('U', 'X', '0', '1', 'H', 'W', 'W', 'H', 'X'),  -- | H |
             ('U', 'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X')   -- | - |
             );

  function resolved (s : STD_ULOGIC_VECTOR) return STD_ULOGIC is
    variable result : STD_ULOGIC := 'Z';  -- weakest state default
  begin
    -- the test for a single driver is essential otherwise the
    -- loop would return 'X' for a single driver of '-' and that
    -- would conflict with the value of a single driver unresolved
    -- signal.
    if (s'length = 1) then return s(s'low);
    else
      for i in s'range loop
        result := resolution_table(result, s(i));
      end loop;
    end if;
    return result;
  end function resolved;


One by one each driver value is compared against a resolved value of previous drivers to determine the resolved value including each new driver. 

Signal update is done by element due to a characteristic known as longest static prefix (8. Names), where using indexed names (8.4) or slice names (8.5) force the granularity of drivers for array composites to elements (which also meets the definition of subelements). (Assignments to elements of records have drivers for all the elements of a record composite and any subelements. See 8.3 selected names. Records don't have subsets of elements.)

The resolution of multiple drivers emulates what happens when two outputs are tied together. Tying multiple outputs together can be a violation of design constraints in FPGA synthesis tools for internal nets for example.

In your design you have assignments to drivers in multiple processes (and concurrent statements also provide process statements).

Two of the processes don't effect any assignment to red, green or blue contingent on the value of modus which is not updated. Resolution of a 'U' with any other value of std_ulogic results in a 'U'.

If your testbench had caused assignment to red or green or blue in more than one process a '0' for one scalar element driver in one process would be resolved with a '1' from the other driver to an 'X'.

A lot of target device families don't allow internal signals to have multiple sources (drivers). This is quite common in FPGAs for instance (while Xilinx supports automatic conversion of mutually exclusively driven multiple sources to be converted to multiplexer selected sources through a software patented process for some device families).

One solution to the synthesis limitation on multiple drivers might be to combine the first two processes into one, assignments separated by conditional choice of modus values. 

Another solution might be to assign unique signals in each process and assign red, green and blue to these values in another process steered by the value of modus (emulating the software patent manually, which should also provide cause to question it's validity).

While loops are not historically synthesis eligible, while for loops with fixed range loop parameters have always been supported. Today some synthesis tools support while loops where the exit condition can be determined by a relatively few loop iterations. (Loops are unrolled in synthesis.) At least one of your while loops will likely require the algorithm being implemented be rewritten.",,,,,
Error when trying to synthesize Verilog code for DE1SoC?,"I am trying to instantiate a VHDL component in a Verilog design as a part of testing a divide function in another complex design. Getting syntax error:


  Error (10170): Verilog HDL syntax error at deldel.v(29) near text:
  ""["";  expecting "")"".......


My VHDL file:

    library IEEE;
    use IEEE.STD_LOGIC_1164.ALL;
    use IEEE.STD_LOGIC_UNSIGNED.ALL;
    use IEEE.NUMERIC_STD.ALL;

entity divide_test is
    port(
            odabir      : in std_logic_vector(9 downto 0);
            rezultat    : out std_logic_vector(9 downto 0)
            );
end divide_test;

architecture behavioral of divide_test is

    constant deljenik0  : unsigned(23 downto 0) := x""000999""; --2457
    constant deljenik1  : unsigned(23 downto 0) := x""000FA7""; --4007
    constant deljenik2  : unsigned(23 downto 0) := x""000288""; --648
    constant delilac        : unsigned(23 downto 0) := x""000015""; --21

    signal rez_temp : unsigned(23 downto 0);
    signal od_temp  : integer range 0 to 3;

begin
    od_temp &lt;= to_integer(unsigned(odabir));
    rezultat &lt;= std_logic_vector(rez_temp(9 downto 0));
    deljenje: process(od_temp)
    begin
        case  od_temp is
            when 0 =&gt; rez_temp &lt;= x""000000"";
            when 1 =&gt; rez_temp &lt;= deljenik0/delilac; --150
            when 2 =&gt; rez_temp &lt;= deljenik1/delilac; --200
            when 3 =&gt; rez_temp &lt;= deljenik2/delilac; --32
        end case;
    end process;

end behavioral;


My Verilog file:

//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module deldel(

    //////////// LED //////////
    output           [9:0]      LEDR,

    //////////// SW //////////
    input            [9:0]      SW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================




//=======================================================
//  Structural coding
//=======================================================

divide_test u0(
    .odabir[1] (SW[0]),
    .odabir[0] (SW[1]),
    .rezultat[0] (LEDR[0]),
    .rezultat[1] (LEDR[1]),
    .rezultat[2] (LEDR[2]),
    .rezultat[3] (LEDR[3]),
    .rezultat[4] (LEDR[4]),
    .rezultat[5] (LEDR[5]),
    .rezultat[6] (LEDR[6]),
    .rezultat[7] (LEDR[7]),
);

endmodule


Verilog file is generic, created from ""DE1SoC_SystemBuilder"". I am trying to connect SW0 and SW1 from DE1Soc board to select one from three operation and show the result with eight LEDs on DE1Soc board!

What am I missing?","The error message indicates that you should not use square brackets for the instance port names (odabir and rezultat) in the Verilog module.  You should not split out the bits of the signals in the instance port names.  Refer to the IEEE Std 1800-2017, section 23.3.2.2 Connecting module instance ports by name, which states:


  The port_name shall be the name specified in the module declaration.
  The port name cannot be a bit-select, a part-select, or a
  concatenation of ports.


You could use square brackets for the connecting signals (SW and LEDR).  However, since the signals are all 10 bits wide, it is simpler to just use the signal name:

divide_test u0 (
    .odabir   (SW),
    .rezultat (LEDR)
);


Note that you can use a range specifier for the connecting signals (SW, for example):

divide_test u0 (
    .odabir   (SW[9:0]),
    .rezultat (LEDR[9:0])
);


You can have any valid expression for the connecting signals (inside the parentheses).",,,,,
Xilinx Zynq peripheral drivers,"I have started to develop software for the ZYNQ 7020 SoC from Xilinx. I have finished several tutorials and I have found that whenever I use some predefined block in the PL (for example GPIO controller) then associated software driver for that peripheral is automatically generated. Does anybody know whether this is true only for the predefined blocks or also for user developed blocks? Thanks.

I have found in my opinion useful document regarding the process of custom IP block drivers development. ","The tools can't automatically write your driver, but if you package your IP block and driver in the right format you can do the same type of thing. Look here for some more info on how to do that: Is there a way to pass a design parameter from a custom IP to software",,,,,
MATLAB script use in System verilog using SNPS VCS tool,"I have coded an algorithm using MATLAB R2019 script and i want it  to be called in an System verilog file i.e The output generated by the  matlab script is actually to be fed into the testbench written using SV. I dont want to use HDL coder tool as the algorithm is quite complex and re-coding it  in SV/ C is quite difficult. I use synopsys VCS tool for compilation and elaboration.
My question is :
1. Is it possible that a MATLAB script to be called in testbench written in SV ? I've heard about DPI, but not much idea on it, or worked on it.
2. Can the output of the MATLAB script stored in a separate file, let's say for example a text file and i can call that file in my SV test bench.? ","To answer your questions in order, it is indeed possible. 

You need to do the following: 


In SV, import a C function (extern DPI-C) that you will call as required. Say we call this callMatlabFn
In C, define an extern function called callMatlabFn. This will then actually call your matlab fn. Have a look here for calling matlab in C : https://www.mathworks.com/help/matlab/matlab_external/call-matlab-functions-from-c-1.html
Note, you could return data via DPI but that may have a different meaning. It may be best to return any data in SV via reference in an output arg to the imported fn.  


Finally, text File I/O in SV is implemented via the following system tasks:

$fopen (file_name) ;   
$fclose (file_name) ;   
$fdisplay (arguments) ;
$fwrite (arguments) ;    
$fstrobe (arguments) ;    
$fmonitor (arguments) ;    
$readmemb (""file"", memory_identifier [,begin_address[,end_address]]) ;    
$readmemh (""file"", memory_identifier [,begin_address[,end_address]]) ;
",,,,,
Binding internal DUT signal to interface and using it in monitor,"I have some internal DUT signals which I need to use in my Monitor. I tried to bind the interface and then use the virtual interface in monitor but the DUT values doesn't reflect on my interface. 

testbench_top-

bind fifo1 : i_dut.fifo_inst.fifo1_inst exp_interface m1 (.fifo_out(out_dut1));
exp_interface exp_intf();

initial
     begin 
       uvm_config_db#(virtual exp_interface)::set(null, ""*"", ""exp_intf"", exp_intf);
end


interface file- 

 interface exp_interface (
        output fifo_in,
        input fifo_out
    );
    endinterface


In monitor I am trying to access using-

if(exp_intf.fifo_out==1)
          $display(""hello0---------------------"");


but I don't see the dut value of out_dut1 (which is tied to 1) reflected on the interface. ","The bind statement just instantiates your interface of type exp_interface inside the instance you provided i_dut.fifo_inst.fifo1_inst with the instance name m1. 

As a result, the path to your interface is i_dut.fifo_inst.fifo1_inst.m1. This is the one which you need to register.

In your case you instantiated yet another interface in the current scope which is not bound to any real signal. It is not needed.",,,,,
Clock divider in vhdl from 100MHz to 1Hz code,"I wrote this code for dividing the clock an a nexys4 fpga that has its integrated clock at 100Mhz frequency by default , and i need to divide it to 1hz. Can someone tell me if its correct or if not what needs to be changed ?

LIBRARY IEEE;
USE IEEE.STD_LOGIC_1164.ALL;


entity digi_clk is
port (clk1 : in std_logic;
       clk : out std_logic
     );
end digi_clk;

architecture Behavioral of digi_clk is

signal count : integer :=0;
signal b : std_logic :='0';
begin

 --clk generation.For 100 MHz clock this generates 1 Hz clock.
process(clk1) 
begin
if(rising_edge(clk1)) then
count &lt;=count+1;
if(count = 50000000) then
b &lt;= not b;
count &lt;=0;

end if;
end if;
clk&lt;=b;
end process;
end;
","The code looks OK.  However the existing code will produce an output frequency that is just below 1 Hz.  To get a precise 100000000:1 ratio, you will want to change the conditional statement from:

    if(count = 50000000) then


... to:

    if(count = 50000000-1) then
",,,,,
"Unexpected waveform is coming out, designing CPU","

I'm trying to design cycles of Read and Write between CPU and SRAM.
    Initial memory values are mem(0) = 000f, mem(1) = 000e.
    I want to design by 5cycles
    Cycle 1 : Assigning addr = 0
    Cycle 2 : Read value from SRAM, mem(0) -> IR
    Cycle 3 : Assigning addr = 1
    Cycle 4 : Write value in SRAM, IR -> mem(1)
    Cycle 5 : Read value from SRAM, mem(1) -> DR

        module sram(addr,clk,din,dout,we); //sram.v

        parameter addr_width = 12, word_depth = 4096, word_width = 16;

        input clk,we;
        input [addr_width-1:0] addr; 
        input [word_width-1:0] din; 
        output [word_width-1:0] dout; 

        reg [word_width-1:0]mem[0:word_depth-1]; 
        reg [word_width-1:0]dout;

        always @ (posedge clk) begin
            if(!we)
                mem[addr] &lt;= din[word_width-1:0]; 
            end
        always @ (posedge clk) begin
            if(we)
                dout[word_width-1:0] &lt;= mem[addr];
            end

        endmodule


        module cpu(clk,reset,select); //cpu.v

        input clk,reset;
        input [2:0]select;

        reg[15:0] ir,dr,ac;
        reg[11:0] ar,pc;

        reg [11:0]addr;
        reg[15:0] din;
        reg we;
        wire[15:0] dout;

        sram sram(addr,clk,din,dout,we);

        always @ (posedge clk or negedge reset) begin
            if(!reset) begin
                ar &lt;= 12'b0;  ir &lt;= 16'b0;  pc &lt;= 12'b0;  dr &lt;= 16'b0;  ac &lt;= 16'b0;
            end

            if(select==3'b001)  //cycle1, address assign
                 addr &lt;= 12'b0; 
            if(select==3'b010) //cycle2, read
                 we &lt;= 1;ir[15:0] &lt;= dout[15:0]; 
            if(select==3'b011) //cycle1, address assign
                 addr &lt;= 12'b1;    
            if(select==3'b100) //cycle4, write
                 we &lt;= 0; din[15:0] &lt;= ir[15:0]; 
            if(select==3'b101) //cycle5, read
                 we &lt;= 1; dr[15:0] &lt;= dout[15:0];
            end

        endmodule

        module tb_cpu(); //tb_cpu.v
        parameter addr_width = 12, word_depth = 4096, word_width = 16;

        reg clk,reset;
        reg [2:0] select;
        integer sram_pointer;
        integer reg_pointer;

        cpu cpu(clk,reset,select);

        always #5 clk = ~clk;

        initial begin
            clk = 0; reset = 1;

            $readmemb(""sram.dat"", tb_cpu.cpu.sram.mem);

            sram_pointer = $fopen(""sram_aftercycle.dat"");
            reg_pointer = $fopen(""reg.dat"");
            #1 reset = 0;
            #1 reset = 1;
            #3 select = 3'b001; //cycle 1
            #20 select = 3'b010; //cycle 2
            #20 select = 3'b011; //cycle 3
            #20 select = 3'b100; //cycle 4
            #20 select = 3'b101; //cycle 5

            #10
            $fdisplay(reg_pointer, ""AR = %b"", tb_cpu.cpu.ar);
            $fdisplay(reg_pointer, ""IR = %b"", tb_cpu.cpu.ir);
            $fdisplay(reg_pointer, ""PC = %b"", tb_cpu.cpu.pc);
            $fdisplay(reg_pointer, ""DR = %b"", tb_cpu.cpu.dr);
            $fdisplay(reg_pointer, ""AC = %b"", tb_cpu.cpu.ac);

            $fdisplay(sram_pointer, ""mem[0000 0000 0000] = %b"",tb_cpu.cpu.sram.mem[0]);
            $fdisplay(sram_pointer, ""mem[0000 0000 0001] = %b"",tb_cpu.cpu.sram.mem[1]);
            $fdisplay(sram_pointer, ""mem[0000 0000 0010] = %b"",tb_cpu.cpu.sram.mem[2]);
            $fdisplay(sram_pointer, ""mem[0000 0000 0011] = %b"",tb_cpu.cpu.sram.mem[3]);

             $fclose(sram_pointer);
             $fclose(reg_pointer);

             #5 $finish;
         end

        endmodule


This is my simulation. Select value can mean cycle number. As I expected, When cycle 2 is started, mem(0) value 000f assign to dout, so dout becomes 000f, and IR should get this value at next rising edge, but DR value is unexpectedly change simultaneously with IR. Where is the problem?","At the bottom of the always block, you have an if without begin/end:

if(select==3'b101) //cycle5, read
   we &lt;= 1; dr[15:0] &lt;= dout[15:0];


This means that the assignment to dr will always happen; only we &lt;= 1 is covered by the condition.",,,,,
System Verilog Variable Module Name,"Is it possible to have variable module name which could then be picked by some parameter? I am looking for the syntax for if...else inside a macro definition.

module test;

  `define NAME(x) if (x == 0) mod_e else mod_w
  generate
    for (genvar i = 0; i &lt; 2; i++) begin
      `NAME(i) inst_name (.a(a),.b(b),...);
    end
  endgenerate

endmodule


One way is to do it like below, but it requires connecting all ports 2 times, which is inconvenient for modules with hundreds of IOs and prone to errors.

module test;

  generate
    if (SOME_PARAM == 0) begin
      mod_e inst_name (.a(a),.b(b),...);
    end else begin
      mod_w inst_name (.a(a),.b(b),...);
    end
  endgenerate

endmodule
","As a possible solution to your hundreds of ports issues, assuming that all instances have the same set of ports, you can approach this problem differently, by defining an instance macro:

`define INST(mod_name) mod_name inst_name(.a(a), .b(b), ...);

if(SOME_PARAM == 0)
   `INST(mod_e)
else
   `INST(mod_w)

",,,,,
Variable use in VHDL,"I was reading some codes in VHDL and saw this example:

  signal     count : integer range 0 to width;
begin
  process(clk, rst)
    variable temp  : integer range 0 to width;
begin
          temp := count + 1;
          count &lt;= temp;
end process;


what's the purpose of count signal here? Why can't we just use the variable?","Variables are local to the process, and signals are used to communicate between processes.

So you would rather do without the variable, and in the process just have:

count &lt;= count + 1;
",,,,,
What is the point of a subtype when a type can be constrained?,"With the VHDL subtype defined from here 

signal ShortInt: integer range 0 to 255;

subtype SHORT integer range 0 to 255;


Would I use short like this:

signal ShortInt: SHORT;


Why wouldn't I just put the range on the signal and leave out the subtype completely?

signal ShortInt: integer range 0 to 255;


I've seen questions answered here about subtypes and what they do but I have not found anyone as simple minded as I am to ask, why use subtypes at all?","Subtypes are mostly there for clarity and ease of later modification. But in addition to Jim's answer, with VHDL 2008 you can also create partially constrained subtypes, which can be of use when you have complicated records. Take this:

type reg_if_t is record
  valid : std_logic;
  addr  : std_logic_vector;
  data  : std_logic_vector;
end record;


It can be a bit of a faff constraining it on every port.

entity ent1 is
  port (
    reg_if0 : in reg_if_t( addr( 7 downto 0), data(31 downto 0) );
    reg_if1 : in reg_if_t( addr(15 downto 0), data(15 downto 0) )
  )
end entity;


why not declare the commonly used subtypes in a package:

subtype reg_if_a8_t is reg_if_t( addr(7 downto 0), data(open) );  -- data length unconstrained
subtype reg_if_a8_d32_t is reg_if_t( addr(15 downto 0), data(31 downto 0) );
subtype reg_if_a16_d16_t is reg_if_t( addr(15 downto 0), data(15 downto 0) );
subtype reg_if_d32_t is reg_if_t( addr(open), data(31 downto 0) );


Now, with a decent naming convention, its clear to the user the intention from the type:

entity ent1 is
  port (
    reg_if0 : in reg_if_a8_d32_t;
    reg_if1 : in reg_if_a16_d16_t 
  )
end entity;


And because they are the same base type, they can all have the same functions used on them. Scale this up to a big bus like an AXI4 interface, and you'll have plenty subtypes declared!",,,,,
How to generate 400MHz & 500MHz clocks from 100MHz clock using Verilog?,"For 400 MHz:

realtime delay =1.25;
always begin
#delay clk=0;
#delay clk=1;


This isn't working.","Here is one way to generate the 3 clocks, where the 100MHz clock is synchronous to the other two:

`timescale 1ns/10ps

module tb;

reg clk1, clk2, clk3;

initial begin : clk_100MHz
    clk1 = 0;
    forever #5 clk1 &lt;= ~clk1;
end

initial begin : clk_500MHz
    clk2 = 0;
    forever #1 clk2 &lt;= ~clk2;
end

initial begin : clk_400MHz
    clk3 = 0;
    forever #1.25 clk3 &lt;= ~clk3;
end

endmodule




You didn't show your complete code.  Two reasons I can think of why your code did not work:


You declared clk as 4-state signal, like reg, but did not initialize it to 0 or 1, and it remained x in your simulation.
You did not set your timescale appropriately to generate the desired frequency.
",,,,,
"Two ways to write pipeline in verilog, which one is better?","I learned two ways of writing pipeline(unblocking and blocking), I wonder which is better?

My personal opinion is that the second one is tedious and I don't understand why so many wire are needed.

Also, is there any standard style(template) of writing pipeline like FSM in verilog?
Thanks in advance.

module simplePipeline
#(
    parameter WIDTH = 100
)
(
    input clk,
    input [WIDTH - 1 : 0] datain,
    output [WIDTH - 1: 0] dataout
);

    reg [WIDTH - 1 : 0] piprData1;
    reg [WIDTH - 1 : 0] piprData2;
    reg [WIDTH - 1 : 0] piprData3;

    always @(posedge clk) begin
        piprData1 &lt;= datain;
    end

    always @(posedge clk) begin
        piprData2 &lt;= piprData1;
    end

    always @(posedge clk) begin
        piprData3 &lt;= piprData2;
    end

    assign dataout = piprData3;

endmodule



module blockingPipeline#2
(
    parameter WIDTH = 100
)
(
    input                   clk,
    input                   rst,
    input                   validIn,
    input [WIDTH - 1 : 0]   dataIn,
    input                   outAllow,
    output wire                 validOut,
    output wire [WIDTH - 1 : 0]   dataOut
);

    reg                 pipe1Valid;
    reg [WIDTH - 1 : 0] pipe1Data;
    reg                 pipe2Valid;
    reg [WIDTH - 1 : 0] pipe2Data;
    reg                 pipe3Valid;
    reg [WIDTH - 1 : 0] pipe3Data;


    /*------------------------PIPE1 LOGIC------------------------*/
    wire                pipe1AllowIn;
    wire                pipe1ReadyGo;
    wire                pipe1ToPipe2Valid;

    assign pipe1ReadyGo = 1'b1

    assign pipe1AllowIn = ! pipe1Valid || pipe1ReadyGo &amp;&amp; pipe2AllowIn;

    assign pipe1ToPipe2Valid = pipe1Valid &amp;&amp; pipe1ReadyGo

    always @(posedge clk)begin

        if( rst ) begin
            pipe1Vali &lt;= 1'b0;
        end

        else if(pipe1AllowIn)begin
            pipe1Valid &lt;= validIn;
        end

        ifvalidIn &amp;&amp; pipe1AllowIn)begin
           pipe1Data &lt;= dataIn;
        end

    end

    /*------------------------PIPE2 LOGIC------------------------*/
    wire                pipe2AllowIn;
    wire                pipe2ReadyGo;
    wire                pipe2ToPipe3Valid;

    assign pipe2ReadyGo = 1'b1;
    assign pipe2AllowIn = ! pipe2Valid || pipe2ReadyGo &amp;&amp; pipe3AllowIn;
    assign pipe2ToPipe3Valid = pipe2Valid &amp;&amp; pipe3ReadyGo;

    always @(posedge clk)begin
        if( rst ) begin
            pipe2Valid &lt;= 1'b0;
        end
        else if(pipe2AllowIn)begin
            pipe2Valid &lt;= pipe1ToPipe2Valid;
        end
        if(pipe1ToPipe2Valid &amp;&amp; pipe2AllowIn)begin
            pipe2Data &lt;= pipe1Data;
        end
    end


    /*------------------------PIPE3 LOGIC------------------------*/
    wire                pipe3AllowIn;
    wire                pipe3ReadyGo;

    assign pipe3ReadyGo = 1'b1;
    assign pipe3AllowIn = ! pipe3Valid || pipe3ReadyGo &amp;&amp; outAllow;

    always @(posedge clk)begin
        if( rst ) begin
            pipe3Valid &lt;= 1'b0;
        end
        else if(pipe3AllowIn)begin
            pipe3Valid &lt;= pipe2ToPipe3Valid;
        end
        if(pipe2ToPipe3Valid &amp;&amp; pipe3AllowIn)begin
            pipe3Data &lt;= pipe2Data;
        end
    end

    assign validOut = pipe3Valid &amp;&amp; pipe3ReadyGo;
    assign dataOut = pipe3Data;

endmodule
","As good practice, the second one seems ""better"" in the sense that when you design a hardware circuit part you might want offer great control possibilities. Generally speaking, since your code will be implemented in the silicon forever (or in your FPGA with painful reconfiguration) that would be a real problem to not have enough controls capacities, because you can't really add some afterward.

As an example you already mentioned in the comments that you'll have to stall the pipeline, so of course you need more wires to do it. You will also need to reset the pipeline sometimes, this is the purpose of the rst signal.

However, more signals means more silicon surface (or more FPGA resources using) which generally come with a greater price. One can argue that only one or two wires will not makes such great difference for a chip, which is true, but if you re-use your pipeline thousand times on the circuit it will be much more significant.

For me the first implementation can be relevant only with really strong optimization requirements at circuit level like for an ASIC, where you exactly know the overall wanted behavior.",,,,,
"What does the phrase ""Varies most rapidly"" in a list of dimension mean?","For example:

bit [1:10] v1 [1:5];     //1 to 10 varies most rapidly; compatible with memory arrays
bit v2 [1:5][1:10];      //1 to 10 varies most rapidly, compatible with C;
","If you line up all the elements by their order in memory(or as a bit-stream), the dimension whose index whose index that would change between each element is the one that varies most rapidly. The memory layout does not matter so much since SystemVerilog has no pointers. But is does matter when you try to select parts of an array, the index selecting goes from least to most varying.

v1[2][3] is 2 of 5 followed by 3 of 10.",,,,,
SystemVerilog Concurrent Assertion Sequence Dynamic Length,"I have an array of length x. A signals output for a given testbench will be each value in the array in its respective order from 0:x-1.

In my problem in particular, the array is filter coefficients and the testbench is the impulse response.
The test needs to be self-checking, which will require a sequence with dynamic length, as the coefficients will change from test to test.

The sequence I would like should look something like this: 

always @(posedge clk) begin
  assert_sequence : assert property (    
        (data_out == array_1[0])
    |=&gt; (data_out == array_1[1])
    |=&gt; (data_out == array_1[2]) 
    |=&gt; (data_out == array_1[3]) 
    |=&gt; (data_out == array_1[4]) 
    |=&gt; (data_out == 0) ) 
      $info(""Seen the sequence"");
    else
      $error(""Sequence was incorrect"");  
  end


Can this be possible to do dynamically? I've tried a genvar for loop but it throws errors. I've searched the forums and can't find anything that meets my requirement like so. 

Possibly something like this could give the right answer?

    always @(posedge clk) begin
  assert_sequence : assert property (    
        (data_out == array1[0][0])

  for(genvar i = 1; i &lt; 5, i++) begin
    |=&gt; (data_out == array1[i])
  end

    |=&gt; (data_out == 0) ) 
      $info(""Seen the sequence"");
    else
      $error(""Sequence was incorrect"");  
  end
","Comments are very useful and had notes of the direction I have taken to resolve this. Just revisited the problem and came up with this un-elegant solution.

for(genvar i = 1; i &lt; 5; i++) begin
  always @(posedge clk) begin
    assert_sequence : assert property (
                                       (data_out == array1[0])
                               |-&gt; ##i (data_out == array1[i])
                               |-&gt; ##(5-i) (data_out == 0) //This line prevents error 
                                                                  //as my coefficients are symmetric
                                    )
      $info(""Impulse response Coefficient %0d seen"", i);
  else
      $error(""Impulse response Coefficient %0d not seen"", i);
  end
end


This code creates multiple assertions, and describes that when I see the first coefficient, in i clock cycles I expect to see the (i+1) coefficient, and due to my problems symmetry, in (5-i) clock cycles I will see a 0.",,,,,
"""?"" don't care value in case statement","I am trying to use the ""?"" don't care specifier in my case statement. I have tried using 6'b0001xx and 6'b0001zz as well. I am confused as i have referenced Pong Chu's FPGA prototyping by Verilog examples and it seems he does this the exact same way. When I run the  simulation, when ""state"" is 0 and ""in"" is 4 (3'b100) the case statement goes to default instead of the expected first case (6'b0001??). If anybody can explain or point me in the right direction it would be much appreciated.

always @(*)
begin
    case({state, in})
        //state0, start is high &gt;&gt; loadA = 1 (s1)
        6'b0001??: {nstate, nout} = {3'b001, {1'b0, 1'b1, 1'b0, pass}};
        //state1, start is high &gt;&gt; loadD = 1 (s2)
        6'b0011??: {nstate, nout} = {3'b010, {1'b0, 1'b0, 1'b1, pass}};
        //state2, start is high &gt;&gt; we = 1 (s3)
        6'b0101??: {nstate, nout} = {3'b011, {1'b1, 1'b0, 1'b0, pass}};
        //state3, done is high &gt;&gt; loadA = 1 (s4), done is low &gt;&gt; loadA = 1 (s1)
        6'b01111?: {nstate, nout} = {3'b100, {1'b0, 1'b1, 1'b0, pass}};
        6'b0111??: {nstate, nout} = {3'b001, {1'b0, 1'b1, 1'b0, pass}};
        //state4, start is high &gt;&gt; loadD = 1 (s5)
        6'b1001??: {nstate, nout} = {3'b101, {1'b0, 1'b0, 1'b1, pass}};
        //state5, start is high &gt;&gt; (s6)
        6'b1011??: nstate = 3'b110;
        //state6, done is low &gt;&gt; loadA = 1 (s4), done is high &gt;&gt; (s7)
        6'b1101??: {nstate, nout} = {3'b100, {1'b0, 1'b1, 1'b0, pass}};
        6'b11011?: nstate = 3'b111;
        //state7, finish is low &gt;&gt; increment pass, loadA = 1 (s1), finsih is high &gt;&gt; pass = 0 loadA = 1 (s1)
        6'b1111??: {nstate, nout} = {3'b001, {1'b0, 1'b0, 1'b0, (pass+1)}};
        6'b1111?1: {nstate, nout} = {3'b001, {1'b0, 1'b0, 1'b0, 3'b0}};
        default:
            {nstate, nout} = {3'b0, 6'b0};
    endcase
","there are 3 different case statements in verilog: case, casex, and casez. They differ in the way they treat don't cares.

In general, case should not have don't care and its behavior is not synthesizable in case of don't cares. The reason is that it does implement the === operator to compare conditions. So, it matches x to x and z to z exactly.

With don't care you should either use casex and casez. Both do symmetrical compare, meaning that ? is matched to anything, but anything is also matched to '?'. So, there can be false-positives if state or in in your case contain x or z. 

casez has a smaller pool of false positives since it only matches 'z', whether casex matches both, 'x' and 'z'. I suggest that you use casez for that reason.",,,,,
Data types in VHDL,"I am trying to implement a filter in VHDL. All input vectors and output vectors are in signed 16 bits (1.15 format, the first bit is a sign bit). I plan to declare all signals / variables as STD_LOGIC / STD_LOGIC_VECTOR type(s). All the calculations will be based on 2's complement. 

There are packages (in IEEE) such as std_logic_1164 (std_logic types &amp; related functions), std_logic_arith (arithmetic fuctions), std_logic_signed (signed arithmetic functions), and std_logic_unsigned (unsigned arithmetic functions). 

In order to achieve all the 2's complement operations in this filter implementation based on types of STD_LOGIC / STD_LOGIC_VECTOR, which library should I use? Should I use both std_logic_signed.ALL and std_logic_1164.ALL?","std_logic_(un)signed and std_logic_arith are NOT standard VHDL packages. They were written by synopsys nearly 30 years ago and never part of the VHDL standard. 

The VHDL standard packages appropriate here would be numeric_std from VHDL 93 (for unsigned and signed types) or numeric_std_unsigned for arithmetic with std_logic_vector (from VHDL 2008). Also available in VHDL2008 is the fixed_pkg, that allows the user to define and do arithmetic with fixed point packages. eg:

signal a,b : sfixed(0 downto -15); -- 1.15 signed fixed 
signal c   : sfixed(1 downto -15);

....

a &lt;= to_sfixed(0.12345, a);
b &lt;= to_sfixed(-0.54321, b);

c &lt;= a + b;


This is fixed point, 2s compliment, integer arithmatic.",,,,,
how to design a flip flop that samples the input after 2 clock cycles using system verilog?,"the data is input in the first posedge clock but the output should present after 2 clock cycles.

i've tried using #delay but not quite getting it.

clk=0;
forever #10 clk = ~clk;
always @ (posedge clk) begin //synchronous rst
#60 q&lt;=d;
end
","One way to solve your problem would be to have 2 flip-flops.

reg q1, q2;
always @(posedge clk) begin
   q1 &lt;= d;
   q2 &lt;= q1;
end


Now, q2 will follow the input with a 2 clock-cycle latency, which is what you wanted.",,,,,
verilog: can not save multiple values in register,"I am trying to save into the register the numbers from 0 to 127. This way only the number 127 exists in the register after the execution of this code.

module TOP();

  reg [63:0] inputdata1;


  //pass the numbers
      integer count;

      initial
      begin
        count = 0;
        while (count &lt; 128) // Execute loop till count is 127. exit at count 128
          begin
          // every timh that the integer variable count takes must be also passed into reg inputdata1 
          inputdata1 = count;
          count = count + 1;
        end
      end

endmodule


Do you know how can I fix it? ","count can hold a single 32-bit signed value.  inputdata1 can hold a single 64-bit value; it can not hold multiple values at any one time.

If you add a $display to your code, you will see that inputdata1 is taking on the values you expect:

    while (count &lt; 128) // Execute loop till count is 127. exit at count 128
      begin
      // every timh that the integer variable count takes must be also passed into reg inputdata1 
      inputdata1 = count;
      count = count + 1;
      $display(""inputdata1=%0d"", inputdata1);
    end


Outputs:

inputdata1=0
inputdata1=1
inputdata1=2
inputdata1=3
inputdata1=4
etc.


After the while exits, you are left with only the last value (127).

Perhaps you want to store multiple values in an array (like a memory):

  reg [63:0] inputdata1 [0:127];

  // ...

    while (count &lt; 128) begin
        inputdata1[count] = count;
        count = count + 1;
    end
",,,,,
Are multiple non-nested if statements inside a VHDL process a bad practice?,"I use VHDL for a few months and I sometimes build that kind of process with non-nested if statements when I want some conditions to be evaluated sequentially : 

    process(clk)
    begin
        if rising_edge(clk) then
            if CONDITION1 then
                (some instructions)
            end if;

            if CONDITION2 then
                (some instructions)
            end if;
        end if;
    end process;


It seems to work well in both simulation and synthesis, but I hardly ever see that kind of structure when looking for examples on the web.
I had doubts about the sequential execution of those statements but the IEEE Standard VHDL Language Reference Manual Std 1076-2008 states :


  Sequential statements are used to define algorithms for the execution
  of a subprogram or process; they execute in the order in which they
  appear.


And the if statement is in the list of sequential statements.

Why can't I find more examples of this? Is this a bad practice?","Yes, it is legal, and yes, assignments are sequiential. Remember that signal assignemnts are given the last value given to them, so the final if ""wins"". So the following two codes are functionally identical.

process(clk)
begin
  if rising_edge(clk) then
    if cond1 then
      --do something 
    end if;

    if cond2 then
      -- do something else
    end if;
  end if;
end process;

-- same as this:

process(clk)
begin
  if rising_edge(clk) then
    if cond2 then 
      -- do soemthing else
    elsif cond1 then
      -- do something
    end if;
  end if;
end process;


There is a practical use for this. The traditional process template has a reset as an if..else setup:

-- sync process
if srst then
  a &lt;= '0';
  b &lt;= '0';
else
  --do something with a and b
end if;


This is fine, but you are forcing a and b to always have a link to srst. If you forget to put b in the srst branch, you'll connect srst to the enable pin of b, because you're saying in the code that the b register cannot be latched when srst is active. This forces you to put all register in the reset branch, which you may not want. So, to allow reset and non-reset signals in the same process without creating the enable link, you can use the double if:

--sync process
--do some logic with A and B here

if srst then  -- reset wins
  a &lt;= '0'; 
  -- B has no link to reset 
end if;


This is not a style you find commonly on the internet (probably because of old tutorials always teaching the if..else style). But it is very common to find accidental timing links between srst and enable pins in development code using the ""traditional"" approach.",,,,,
Diference in bit selection in Verilog,"I have a code similar to the following

module testModule(
    input        Clk,
    input  [2:0] Counter,
    output [1:0] OutVar1,
    output [1:0] OutVar2
);

    localparam logic [7:0] mask = 8'h50;

    // CODE 1
    always_ff @(posedge Clk) begin
        case (mask[{Counter[1:0], 1'b0} +: 2])
            2'h0 : OutVar1 &lt;= 2'h0;
            2'h1 : OutVar1 &lt;= 2'h1;
            2'h2 : OutVar1 &lt;= 2'h2;
            2'h3 : OutVar1 &lt;= 2'h3;
            default: OutVar1 &lt;= 2'hX;
        endcase
    end

    // CODE 2
    always_ff @(posedge Clk) begin
        case (mask[(Counter[1:0]&lt;&lt;1) +: 2])
            2'h0 : OutVar2 &lt;= 2'h0;
            2'h1 : OutVar2 &lt;= 2'h1;
            2'h2 : OutVar2 &lt;= 2'h2;
            2'h3 : OutVar2 &lt;= 2'h3;
            default: OutVar2 &lt;= 2'hX;
        endcase
    end

endmodule


Counter is a input that goes 0, 2, 4, 6, 0, 2, 4, etc.
And I expected CODE 1 and CODE 2 to behave the same but when counter is 2 and 6 (counter[1:0] is 2) I hit the case 2'h1 in CODE 1 (correct) and 2'h0 in CODE 2 (wrong).

I have not checked yet what is the behaviour if counter goes 0, 1, ..., 7, 0, 1, etc.

I do not have a testbed because this code is part of a large project. I saw the problem after simulation and seeing the waves.

What am I missing?","I suspect you're missing that only 2 bits are used to calculate the answer in ""CODE 2"", because it is a so-called self-determined expression. So, Verilog takes the expression:

counter[1:0]&lt;&lt;1


and needs to decide how many bits to use for the answer. This is what it does: it looks at how many bits there are on the left hand side of the shift operator (2) and uses that to put the result in. How could it do anything else? The number of bits on the right hand side (32) is basically irrelevant (unless you think Verilog should use 2^31-1 bits for the result!). So, you get an overflow - the left hand side of the result of the shift is truncated.

See this answer here.",,,,,
Interface Modport Connection to Testbench Environment in SystemVerilog,"I have a simple arbiter design that grants one of the two requests with priority to the first one. I want to connect it to the test bench designed in SystemVerilog. I want to connect my environment to my DUT through an interface on two positions: 1) To a monitor that monitors the bus 2). To a driver, to drive relevant test cases.

For the two connections, I have defined two modports. I have instantiated my DUT and interface in a top module and have tried to pass the reference to these two modports using virtual interfaces. However, I'm getting a compile time error as below:


  ** Error: Environment.sv(8): Illegal assignment to type 'virtual interface arbi_if' from type 'virtual interface arb_if': Virtual interface type 'arbi_if' cannot be assigned type 'arb_if'.


Different codes are as below:

arb_if.sv

interface   arb_if(
    input   clk
);

logic   [1:0]   request;
logic   [1:0]   grant;
logic           rst;

clocking cb @(posedge clk);
    input   grant;
    output  request;
endclocking

modport TEST(clocking cb, output rst);    
modport ARBI(input clk, grant, output rst, request);    
modport MONT(input clk, grant, rst, request);

endinterface


Environment.sv

class Environment;
    virtual arbi_if af;

    virtual arbi_if.TEST aft;
    virtual arbi_if.TEST afm;

    function new(virtual arb_if af);
        this.af = af;
        this.aft = af.TEST;
        this.afm = af.MONT;
    endfunction

endclass


test.sv

`include ""Environment.sv""

class test;
    Environment env;
    virtual arb_if af;

    function new(virtual arb_if afi);
        this.af = afi; // Compiler complains for this line.
    endfunction

    ...
endclass


tb_top.sv

module tb_top;

reg clk;

initial
begin
    clk = 0;
    forever #5 clk = ~clk;
end

arb_if arbif(clk);
arb a(arbif);
test ta(arbif);

endmodule


In summary, I want to know how reference to modports are passed to different classes from a top module? 
The above code has been trimmed to make a minimum working example.","Modports are just restricted access rights when declaring interface ports or virtual interface variables, or making assignments to them. This is explained in section 25.9 Virtual interfaces and 25.10 Access to interface objects of the IEEE 1800-2017 LRM.

Essentially you can always make interface type assignments from an unrestricted interface instance to a modport restricted port or variable, but you can never make the assignment in the reverse direction (restricted to unrestricted), or from one modport type to another modport type. ",,,,,
How to have a fixed simulation time in uvm,"is it possible to have a fixed simulation time in the uvm-framwork? Normally i start the simulation and run it for a fixed time in a *.tcl file (e.g. run 1ms).

P.S: i am new in uvm","The UVM has an objection mechanism used to end tests. Components raise objections and then lower objections to ending current run_phase. All you have to do is in the run_phase of your test, or some other component. 

phase.raise_objection(this);
#1ms;
phase.drop_objection(this);


This assumes there are no other objections in your testbench. You might want to read http://www.sunburst-design.com/papers/CummingsDVCon2011_UVM_TerminationTechniques.pdf

Also, more info on the UVM framework can be found here.",,,,,
Implementing a reversing counter in VHDL,"I am new to VHDL and I am trying to implement a counter that counts up from 0 to its maximum value, then automatically starts counting down once it reached the max value. This is my entity and architecture:



entity Rev_Counter is   -- self-reverting counter
    generic (
    counter_steps: integer:=256;                -- number of steps of the counter
    counter_output_size: integer:=8     -- smallest nr of bits to represent the biggest value of the counter
    );
    port (
    clock: in std_logic;                -- input clock signal
    output: out std_logic_vector (counter_output_size-1 downto 0)
    );
end Rev_Counter; 






architecture Arh_Rev_Counter of Rev_Counter is
   signal count_sig: std_logic_vector (counter_output_size-1 downto 0) := (others =&gt; '0');
   signal count_dir: std_logic := '0';      -- 0 = count up, 1 = count down  
begin

Count: process (clock)
begin

    if (clock'event and clock = '1') then
        if (count_sig = counter_steps-1) then   -- revert the counting direction
            count_dir &lt;= '1';       -- reached highest value, count down 
            count_sig &lt;= count_sig - 1;
        elsif (count_sig = 0) then  -- revert the counting direction
            count_dir &lt;= '0';       -- reached lowest value, count up  
            count_sig &lt;= count_sig + 1;
        end if;

        if (count_dir = '0') then   -- perform count up
            count_sig &lt;= count_sig + 1;
        elsif (count_dir = '1') then    -- preform count down
            count_sig &lt;= count_sig - 1;
        end if;
    end if;
end process;
output &lt;= count_sig;

end architecture; 




My problem is: when simulating this code, my counter counts up to FF normally, then it starts acting strange. After counting up to FF, it goes straight to 00, then FF, then 00 and so on, without the numbers in between. I would appreciate some help figuring out why it acts this way.

I found an alternative way to do it. I edited the Count process to look like this. However, I don't exactly understand what was wrong in the first place, therefore I'd still appreciate some insight.

    Count: process (clock)
    begin

        if (clock'event and clock = '1') then  
            if (count_dir = '0') then   
                count_sig &lt;= count_sig + 1;
                if (count_sig = counter_steps - 1) then
                    count_sig &lt;= count_sig - 1;
                    count_dir &lt;= '1';
                end if;
            elsif (count_dir = '1') then
                count_sig &lt;= count_sig - 1;
                if (count_sig = 0) then
                    count_dir &lt;= '0';
                end if;
            end if;
        end if;
    end process;
","You are changing count_dir one tick too late at either end.

Since it is a registered value, the effects of changing it have a 1 clock period delay. As a result, on reaching 0xFF count_sig will increment one more time (0x00) before reversing the direction. It will then count 'down' to 0xFF, reversing the direction again, resulting in the value constantly flicking between 0x00 and 0xFF.

Altering your conditions to change direction to count_sig = counter_steps - 2 and count_sig = 1 respectively gives you the behaviour you want.",,,,,
"Are these two verilog sentences equivalent, do they take the same cycles?","I want to know if these two codes would be doing the same? And what is the practical difference between them? If they are doing the same operation, is the second case faster than the first case?

In the first case, because I have to wait until it comes out to the ""cycle statement"" to recognize the rising of the flag ""modi_varx_f"" and ""modi_vary_f"" in order to ""activate"" in the next cycle and operate the increase of the variable, then it's slower than to do it at once as in the second case that seems to ""activate"" and run the operation within the same cycle.


First case:


always@(posedge clk or negedge rst) begin
    if (~rst) begin
        modi_varx_f = 0;
        modi_vary_f = 0;
    end
    else if (cond1) begin
        modi_varx_f = 1; // increase variable x on 1.
        modi_vary_f = 1; // add 3'd6 to variable.
    end
end

always@(posedge clk or negedge rst)
    if (~rst) 
        varx  = 0;
    else if (modi_varx_f)
        varx = varx + 1;
end  

always@(posedge clk or negedge rst)
    if (~rst) 
        vary  = 0;
    else if (modi_vary_f)
        vary = vary + 3'd6;
end



Second case:


always@(posedge clk or negedge rst) begin
    if (~rst) begin
        varx = 0;
        vary = 0;
    end
    else if (cond1) begin;
        varx = vary + 1; 
        vary = vary + 3'd6;
    end
end
","just to summarize the comment stream. In general, you can collapse multiple sequential always blocks into one without loosing functionality. I guess that you made a mistake in the second example and used varx = vary + 1; while in the first case you used varx = varx + 1;. This makes the difference. 

However, if the second example uses varx, than both are equivalent.

Since you used sequential elements (flops with asynchronous reset) in your examples, you should have used non-blocking assignments there, according to industry-wide practices. And the right answer for collapsing should look like this:

always@(posedge clk or negedge rst) begin
    if (~rst) begin
        varx &lt;= 0;
        vary &lt;= 0;
    end
    else if (cond1) begin;
        varx &lt;= varx + 1; // &lt;&lt; varx
        vary &lt;= vary + 3'd6;
    end
end
",,,,,
picorv32 risc-v implementation in vivado 2018.2,"This is the core: 
https://github.com/cliffordwolf/picorv32

I'm having a problem implementing the core in vivado.
I have installed the riscv gnu toolchain and I am sure that it works ok, I modified the Makefile ($TOOLCHAINPREFIX).

I ran the makfile's make firmware.hex (from the scripts/vivado folder) and then I ran the make synth_system command to run synth_system.tcl in vivado and generate the bitstream for my fpga.

My fpga is an arty a7-35t development board and I have modified the synth_system.xdc constraints file to match the arty a7 pins and not the basys 3 (like it is by default). I also changed the name of the board in the .tcl script.
I also modified the firmware.c to only output zeros and ones on the adress 0x10000000 and with a small delay in between to blink the board's LED's.

However, de LED's don't blink, and the only efect is that the trap signal is on when I press the reset button (I put the reset on button0 of the FPGA and the trap signal on the green led 0).

So, whatever I do, the only result is the fact that I get a green LED light up when I press reset and that's all.

I may be missing something...

Please help me, I do not know what to do to fix this !

Thank you in advance !

P.S. I'm attaching the modified files from the scripts/vivado folder.

////////////////////////
firmware.c
///////////////////
void putc(int c)
{
(volatile int)0x10000000 = c;
}

void puts(const char *s)
{
while (*s) putc(*s++);
}

void *memcpy(void dest, const void src, int n)
{
while (n) {
n--;
((char)dest)[n] = ((char)src)[n];
}
return dest;
}

int message1=0xFFFFFFFF;
int message2=0x00000000;
int flag=1;

void main()
{

while(1)
{ 
    if(flag)
    {
        //putc(message2);
        *(volatile int*)0x10000000 = message2;
        flag=0;
    }
    else
    {   
        *(volatile int*)0x10000000 = message1;
        //putc(message1);
        flag=1;

    }

    for (long int i = 0; i=500000; i++);

}
}


////////////////////////////////////
synth_system.tcl
///////////////////////////////////

read_verilog system.v
read_verilog ../../picorv32.v
read_xdc synth_system.xdc

synth_design -part xc7a35ti-csg324-1L -top system
opt_design
place_design
route_design

report_utilization
report_timing

write_verilog -force synth_system.v
write_bitstream -force synth_system.bit


//////////////////////////////////////////////
synth_system.xdc
/////////////////////////////////////

XDC File for Arty A7 Board
###########################

set_property PACKAGE_PIN E3 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports clk]
create_clock -period 10.00 [get_ports clk]

Blue from RGB LEDS and also regular LEDS from Arty A7
set_property PACKAGE_PIN E1 [get_ports {out_byte[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {out_byte[0]}]
set_property PACKAGE_PIN G4 [get_ports {out_byte[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {out_byte[1]}]
set_property PACKAGE_PIN H4 [get_ports {out_byte[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {out_byte[2]}]
set_property PACKAGE_PIN K2 [get_ports {out_byte[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {out_byte[3]}]
set_property PACKAGE_PIN H5 [get_ports {out_byte[4]}]
set_property IOSTANDARD LVCMOS33 [get_ports {out_byte[4]}]
set_property PACKAGE_PIN J5 [get_ports {out_byte[5]}]
set_property IOSTANDARD LVCMOS33 [get_ports {out_byte[5]}]
set_property PACKAGE_PIN T9 [get_ports {out_byte[6]}]
set_property IOSTANDARD LVCMOS33 [get_ports {out_byte[6]}]
set_property PACKAGE_PIN T10 [get_ports {out_byte[7]}]
set_property IOSTANDARD LVCMOS33 [get_ports {out_byte[7]}]

first is buton 0 trap and out_byte_en is on green LEDS from the RGB leds
set_property PACKAGE_PIN D9 [get_ports {resetn}]
set_property IOSTANDARD LVCMOS33 [get_ports {resetn}]
set_property PACKAGE_PIN F6 [get_ports {trap}]
set_property IOSTANDARD LVCMOS33 [get_ports {trap}]
set_property PACKAGE_PIN J4 [get_ports {out_byte_en}]
set_property IOSTANDARD LVCMOS33 [get_ports {out_byte_en}]

set_property CONFIG_VOLTAGE 3.3 [current_design]
#where value2 is the voltage provided to configuration bank 0

set_property CFGBVS VCCO [current_design]
#where value1 is either VCCO or GND

//////////////////////////////////////////////////////////////////



I also modified the code for system.v to see if the project works at all.
end else begin
//////////////////
last part of system.v
//////////////////////
always @(posedge clk) begin
m_read_en &lt;= 0;
mem_ready &lt;= mem_valid &amp;&amp; !mem_ready &amp;&amp; m_read_en;

        m_read_data &lt;= memory[mem_addr &gt;&gt; 2];
        mem_rdata &lt;= m_read_data;

        out_byte_en &lt;= 0;
                    out_byte&lt;=8'h0F;  ////MODIFIED PART
        (* parallel_case *)
        case (1)
            mem_valid &amp;&amp; !mem_ready &amp;&amp; !mem_wstrb &amp;&amp; (mem_addr &gt;&gt; 2) &lt; MEM_SIZE: begin
                m_read_en &lt;= 1;
            end
            mem_valid &amp;&amp; !mem_ready &amp;&amp; |mem_wstrb &amp;&amp; (mem_addr &gt;&gt; 2) &lt; MEM_SIZE: begin
                if (mem_wstrb[0]) memory[mem_addr &gt;&gt; 2][ 7: 0] &lt;= mem_wdata[ 7: 0];
                if (mem_wstrb[1]) memory[mem_addr &gt;&gt; 2][15: 8] &lt;= mem_wdata[15: 8];
                if (mem_wstrb[2]) memory[mem_addr &gt;&gt; 2][23:16] &lt;= mem_wdata[23:16];
                if (mem_wstrb[3]) memory[mem_addr &gt;&gt; 2][31:24] &lt;= mem_wdata[31:24];
                mem_ready &lt;= 1;
            end
            mem_valid &amp;&amp; !mem_ready &amp;&amp; |mem_wstrb &amp;&amp; mem_addr == 32'h1000_0000: begin
                out_byte_en &lt;= 1;
                out_byte &lt;= 8'h01;  ///////////MODIFIED PART
                mem_ready &lt;= 1;
            end
        endcase
    end
end endgenerate
endmodule



I also tried to only lit the LEDs by while(1) writing 0xFF on them but that did not work either:

void putc(int c)
{
    *(volatile int*)0x10000000 = c;
}

void puts(const char *s)
{
    while (*s) putc(*s++);
}

void *memcpy(void *dest, const void *src, int n)
{
    while (n) {
        n--;
        ((char*)dest)[n] = ((char*)src)[n];
    }
    return dest;
}

int message1=0xFFFFFFFF;
int message2=0x00000000;
int flag=1;

void main()
{
    while(1)
    {
    *(volatile int*)0x10000000 = message1;
    }

}


Conclusion: even though the .C program writes at adress 0x1000_0000, the blue leds for the out byte only lit up in the pattern 0x0F (00001111 in binary, so only the latter 8 lit up)
Something must be wrong, I don't seem to find out what.","If you are trying to build code for a 32-bit RISC-V rv32i core using a 64-bit compiler (as most distributions provide) then you need to add -mabi=ilp32 -march=rv32i to put it into rv32i mode.

If you are using a ""linux"" variant compiler to create a bare metal binary, you need to remove the build ID (which breaks the flat binary output) by using ,--build-id=none after -Wl.",,,,,
How should I implement the cascade of classifiers in Viola-Jones algorithm on FPGA?,I am trying to implement the Viola-Jones algorithm on FPGA. I am not sure what I should do about the cascade of classifiers. How should I implement it on the FPGA?,"Check out this paper, seems exactly what you're looking for. You'll need a handle on VHDL or some hardware-description-language as well as some sort of breakout board like the Altera they are using.

Project Files and Source Code",,,,,
Why is computing two's compliment in a single Verilog statement (i.e. ~x + 1'b1) producing the wrong answer?,"I realized that doing the 2's compliment in a single verilog statement (as seen for the '' below) is giving the wrong answer. But I don't understand why. Can someone help explain this? Operator precedence doesn't seem to explain the issue.

module test();
  logic [7:0] x;
  logic [7:0] x_1s;
  logic [3:0] x_2_0_2s_compl_type1;
  logic [3:0] x_2_0_2s_compl_type2;

  assign x = '0;

  assign x_2_0_2s_compl_type1 = ~x[2:0] + 1'b1; // gives the wrong answer

  assign x_1s = ~x;
  assign x_2_0_2s_compl_type2 = x_1s[2:0] +1'b1; // gives correct answer

  always @* begin
    $display(""x = %b"",x);
    $display(""x_2_0_2s_compl_type1 = %b"",x_2_0_2s_compl_type1);
    $display(""x_1s = %b"",x_1s);
    $display(""x_2_0_2s_compl_type2 = %b"",x_2_0_2s_compl_type2);
  end

endmodule


Simulation results:

x = 00000000
x_2_0_2s_compl_type1 = 0000
x_1s = 11111111
x_2_0_2s_compl_type2 = 1000
","Section 11.8.2 Steps for evaluating an expression in the 1800-2017 LRM explains this. Basically, the operands in a context-determined expression get extended to match the size of the target assignment before applying any operators. So ~x[2:0] becomes ~(4'b000)

To do what you want in one expression you can write

assign x_2_0_2s_compl_type1 = {~x}[2:0] + 1'b1;


or 

assign x_2_0_2s_compl_type1 = 3'(~x) + 1'b1;
",,,,,
Input Port Declaration with two sizes,"I'm new to SystemVerilog and in the project I'm working on, I stumbled over the following port declaration. From VHDL I know the port declaration with one size (e.g. a 8-bit vector). But I don't understand why there are two sizes specified. Can someone explain it to me?

Thanks in advance!

module foobar
    #(parameter PORTS = 1)
     (input [PORTS-1:0][15:0] id_map);
endmodule
","SystemVerilog has array datatypes with multiple dimensions (actually arrays of arrays) and allows ports to have array data types. 

An array is a fundamental data type in SystemVerilog and I suggest reading a number of tutorials on it. Here is one good explanation. ",,,,,
"Verilog - take in input from multiple ""sensors"", increment ""count""","I'm doing an introductory Verilog project for a class.  In my code I'm using several sensors (Sensor_1, Sensor_2...).  All sensors begin in an idle state; Sensor_x == 0. If the sensor senses a moving object it changes to Sensor_x == 1.  Is there a way to code a ""count"" that will keep track of multiple sensors changing to 1 so that I can branch to different code depending on what the count is?  I realize I could use nested 'if' statements in conjunction with OR (||) and AND (&amp;&amp;) but, if I have four or five sensors, this gets a bit redundant.  Maybe I'm thinking about this the wrong way but keeping track of multiple asserted sensors in one variable seems more efficient than many 'if, 'else if' statements.  Please correct me if I'm wrong.   This may be very simple to many but coding in Verilog is new to me so I'm a bit stumped.","
  ... so that I can branch to different code


No! Verilog is not a programming language where you can somehow re-direct a program counter to do something different. 

All code is present at the same time and is executed in parallel.
All you can do is ""enable"" or ""disable"" parts of the code by using structures like if, case etc. 


  Is there a way to code a ""count"" that will keep track of multiple sensors changing to 1...


You can keep a count for all sensors but what do you do if two sensors change at the same time?
It is not like a C-program where you can do:

   for (s=0; s&lt;NUM_SENSORS; s++)
     if (sensor[s])
        count++;


For a beginners course I would use a counter per sensor and add them up.

Last but not least: if this is to really work in hardware, you may need to synchronize the sensors to the local clock before you can use them. Ask your class instructor if the sensor input is arriving synchronous or asynchronous. Beware: you risk that he may suspect that you have been asking for help if you ask that question!",,,,,
Making submodule in topmodule results in verilator error,"I just started learning Verilog and decided to make a 4 bit adder. To create this 4 bit adder, I first built a half_adder module, then a full_adder module which uses the half_adder module. In the 4 bit adder I use 4 full_adder modules.
Up to this point everything compiles and simulates with Verilator. I wrote some tests and checked that all outputs were correct.

After being done with the 4 bit adder, I thought of creating a small ALU which uses the 4 bit adder for additions. Now when I create a submodule of the 4 bit adder in the ALU module, I get verilator errors.

The 4 bit adder looks like:

`default_nettype none
module adder_4_bit(
    i_a,
    i_b,
    o_sum,
    o_carry
);

    input   [3:0]   i_a;
    input   [3:0]   i_b;
    output  [3:0]   o_sum;
    output  wire    o_carry;

    wire    internal_carry1;
    wire    internal_carry2;
    wire    internal_carry3;

    full_adder full_adder1(
        .i_a        ( i_a[0] ),
        .i_b        ( i_b[0] ),
        .i_carry    ( 1'b0 ),
        .o_sum      ( o_sum[0] ),
        .o_carry    ( internal_carry1 )
    );

    full_adder full_adder2(
        .i_a        ( i_a[1] ),
        .i_b        ( i_b[1] ),
        .i_carry    ( internal_carry1 ),
        .o_sum      ( o_sum[1] ),
        .o_carry    ( internal_carry2 )
    );

    full_adder full_adder3(
        .i_a        ( i_a[2] ),
        .i_b        ( i_b[2] ),
        .i_carry    ( internal_carry2 ),
        .o_sum      ( o_sum[2] ),
        .o_carry    ( internal_carry3 )
    );

    full_adder full_adder4(
        .i_a        ( i_a[3] ),
        .i_b        ( i_b[3] ),
        .i_carry    ( internal_carry3 ),
        .o_sum      ( o_sum[3] ),
        .o_carry    ( o_carry )
    );
endmodule


The ALU (for now) looks like this. I still need to implement the optcode select etc, but even creating the 4 bit adder submodule already resulted in errors...:

`default_nettype none
module alu_4_bit(
    i_a,
    i_b,
    i_opt,
    o_result,
    o_status
);

    input [3:0] i_a;
    input [3:0] i_b;
    input [3:0] i_opt;
    output [3:0] o_result;
    output [4:0] o_status;

    adder_4_bit adder_4_bit_inst(
        .i_a(i_a),
        .i_b(i_b),
        .o_sum(o_result),
        .o_carry(o_status[0])
    );
endmodule


When running the command
verilator -Wall -cc alu_4_bit.v

I get the following errors:

verilator -Wall -cc alu_4_bit.v 
%Error: adder_4_bit:5: Unterminated string
%Error: adder_4_bit:11: Unterminated string
%Error: adder_4_bit:27: Unterminated string
%Error: adder_4_bit:28: Unterminated string
%Error: adder_4_bit:31: Unterminated string
%Error: adder_4_bit:40: Unterminated string
%Error: adder_4_bit:44: Unterminated string
%Error: adder_4_bit:58: Unterminated string
%Error: adder_4_bit:60: Unterminated string
%Error: adder_4_bit:66: Unterminated string
%Error: adder_4_bit:70: Unterminated string
%Error: adder_4_bit:72: Unterminated string
%Error: adder_4_bit:78: Unterminated string
%Error: adder_4_bit:79: Unterminated string
%Error: adder_4_bit:81: Unterminated string
%Error: adder_4_bit:86: Unterminated string
%Error: adder_4_bit:93: Unterminated string
%Error: adder_4_bit:119: Unterminated string
%Error: adder_4_bit:121: Unterminated string
%Error: adder_4_bit:124: Unterminated string
%Error: adder_4_bit:131: Unterminated string
%Error: adder_4_bit:132: Unterminated string
%Error: adder_4_bit:133: Unterminated string
%Error: adder_4_bit:134: Unterminated string
%Error: adder_4_bit:135: Unterminated string
%Error: adder_4_bit:139: Unterminated string
%Error: adder_4_bit:141: Unterminated string
%Error: adder_4_bit:143: Unterminated string
%Error: adder_4_bit:144: Unterminated string
%Error: adder_4_bit:146: Unterminated string
%Error: adder_4_bit:148: Unterminated string
%Error: adder_4_bit:150: Unterminated string
%Error: adder_4_bit:157: Unterminated string
%Error: adder_4_bit:160: Unterminated string
%Error: adder_4_bit:162: Unterminated string
%Error: adder_4_bit:164: Unterminated string
%Error: adder_4_bit:165: Unterminated string
%Error: adder_4_bit:1: syntax error, unexpected $undefined
%Error: Exiting due to 38 error(s)
%Error: Command Failed /usr/local/bin/verilator_bin -Wall -cc alu_4_bit.v


The strange thing is that these errors seem to come from the adder_4_bit.v while I already compiled and simulated it with verilator. I even made sure it worked correctly.

What could be the issue here?","I did not get such warnings when I tried to compile it with verilator, however I got some other warnings:

alu_4_bit.v:12: Signal is not used: i_opt


I commented out input[3:0] i_opt and i_opt's definition in module I/O and then I got this warning.

%Error: alu_4_bit.v:20: Illegal bit or array select; type does not have a bit range, or bad dimension: type is logic


I replaced output[3:0] o_status with output o_status and removed the bit select from .o_carry(o_status[0]) so that it is .o_carry(o_status) now.

After these, the design compiled with my version (4.004) of verilator. I hope these help you as well.",,,,,
16-bit CPU design: Issues with implementing fetch-execute cycle,"I am doing a computer architecture course on Coursera called
NandtoTetris and have been struggling with my 16-bit CPU design. The
course uses a language called HDL, which is a very simple Verilog like
language.

I have spent so many hours trying to iterate on my CPU design based on
the diagram below and I don't understand what I am doing wrong. I
tried my best to represent the fetch and execute mechanics. Does
anyone have any advice on how to solve this?    

Here are the design and control syntax diagram links:

CPU IO high-level diagram:


Gate level CPU diagram:


Control instruction syntax:


Here is my code below:

    // Put your code here:

    // Instruction decoding:from i of â€œixxaccccccdddjjjâ€?
    // Ainstruction: Instruction is 16-bit value of the constant that should be loaded into the A register
    // C-instruction: The a- and c-bits code comp part, d- and j-bits code dest and jump(x-bits are ignored). 
    Mux16(a=outM, b=instruction, sel=instruction[15], out=aMUX); // 0 for A-instruction or 1 for a C-instruction  
    Not(in=instruction[15], out=aInst); // assert A instruction with op-code as true 
    And(a=instruction[15], b=instruction[5], out=cInst); // assert wite-to-A-C-instruction with op code AND d1-bit
    Or(a=aInst, b=cInst, out=aMuxload); // assert Ainstruction or wite-to-A-C-instruction is true
    ARegister(in=aMUX, load=cInst, out=addressM); // load Ainstruction or wite-to-A-C-instruction 


    //  For C-instruction, a-bit determines if ALU will operate on A register input (0) vs M input (1)
    And(a=instruction[15], b=instruction[12], out=Aselector); // assert that c instruction AND a-bit 
    Mux16(a=addressM, b=inM, sel=Aselector, out=aluMUX); // select A=0 or A=1           
    ALU(x=DregisterOut, y=aluMUX, zx=instruction[11], nx=instruction[10], zy=instruction[9], ny=instruction[8], f=instruction[7], no=instruction[6], zr=zr, ng=ng,out=outM); 

    // The 3 d-bits of â€œixxaccccccdddjjjâ€?ALUout determine registers are destinations for for ALUout
    // Whenever there is a C-Instruction and d2 (bit 4) is a 1 the D register is loaded
    And(a=instruction[15], b=instruction[4], out=writeD); // assert that c instruction AND d2-bit
    DRegister(in=outM, load=writeD, out=DregisterOut); // d2 of d-bits for D register destination 

    // Whenever there is a C-Instruction and d3 (bit 3) is a 1 then writeM (aka RAM[A]) is true
    And(a=instruction[15], b=instruction[3], out=writeM); // assert that c instruction AND d3-bit  

    // Programe counter to fetch next instruction
    // PC logic: if (reset==1), then PC = 0
    //           else:
    //                load  = comparison(instruction jump bits, ALU output zr &amp; ng)
    //                if load == 1, PC = A
    //                else: PC ++   
    And(a=instruction[2], b=ng, out=JLT); // J2 test against ng: out &lt; 0
    And(a=instruction[1], b=zr, out=JEQ); // J1 test against zr: out = 0
    Or(a=ng, b=zr, out=JGToutMnot)); // J0 test if ng and zr are both zero
    Not(in=JGToutMnot, out=JGToutM; // J0 test if ng and zr are both zero
    And(a=instruction[0], b=JGToutM, out=JGT);
    Or(a=JLT, b=JEQ, out=JLE); // out &lt;= 0  
    Or(a=JGT, b=JLE, out=JMP); // final jump assertion
    And(a=instruction[15], b=JMP, out=PCload); // C instruction AND JMP assert to get the PC load bit
    // load in all values into the programme counter if load and reset, otherwise continue increasing
    PC(in=addressM, load=PCload, inc=true, reset=reset, out=pc);     
","It is tricky to answer these kinds of questions without doing the work for you, which isn't helpful to you in the long run.

Some general thoughts.


Consider each element in isolation (including the circles where signals come together).
Label each line between elements with a name. These will become internal control lines. It helps reduce the chances of confusion.
Be very careful about junk outputs. If you're not supposed to be putting valid data on outM, use a Mux to output false.


Potential gotcha: I seem to remember that it's a bad idea to use a design output (like outM) as an input to something else. Outputs should only be outputs. Right now you are sending the output of the ALU to outM and using outM as an input to other elements. I suggest you try outputting the ALU to a new signal ""ALUout"", and using that as the input for the other elements and (through a mux with false controlled by writeM) outM. But remember, writeM is an output! So the block that generates writeM needs to generate a copy of itself to use as the control to the mux. FORTUNATELY, a block can have multiple out statements!

For example, right now you're generating outM like this (I won't comment on whether it is wrong, I am just using it as an illustration):

And(a=instruction[15], b=instruction[3], out=writeM); 


You can create a second output like this:

And(a=instruction[15], b=instruction[3], out=writeM, out=writeM2)


and then ""clean"" your outM like this:

Mux16(a=false,b=ALUout,sel=writeM2,out=outM);


Good luck!",,,,,
Atlas-SoC board preloader troubleshooting,"I just bought a new Cyclone V board from Terasic ( Atlas-SoC ) and planned to build a bare metal application. At first, I used the GSRD provided by Terasic. The example project is from version 14.0 and my 17.1 Quartus asked me to launch an update to those 14.0 IP, but I saw that they already compile everything and I had a handoff file folder. All I needed to do was just make a preloader and uboot. Then I followed these steps (from rocketboard and many places else):


Generate .rbf file.
I made a preloader using the bsp-editor tool from EDS-SoC.
Compile successfully the preloader and obtain
preloader-mkpimage.bin.
Generate uboot and also uboot script file.
Load preloader into SD card using alt-boot-disk-util.
Copy all the rbf file, uboot and uboot script to an SD card. At this moment I did not make any application because I wanted to check if the preloader loaded or not.  
Plug SD card into the board and then power up 8. In Putty, I saw the U-boot spl and Uboot worked fine.


With the first success, I tried to make my own HPS-FPGA design. I based on HPS configuration to make my own HPS ( initialize I2C, UART, no sdram, etc. ). For the FPGA part, I put some LEDs PIO, JTAG UART, System ID peripheral, etc. 

After finish my Platform designer ( Qsys), I made a VHDL top file and connect all the nodes ( just like GSRD design). At this point, I did not add any IP such as HPS reset, debounce, etc. because I just wanted to see if the preloader worked or not.

Then I followed exactly those steps as I did with GSRD design, however this time on Putty I received nothing. U-Boot SPL did not even appear. Feeling weird, I came back to GSRD to check. I copied the whole folder of GSRD design and made it my own new project. Then I launched an update for those IP and compiled the whole thing again. After that, preloader and uboot were made in the same steps and the result amazed me: On Putty terminal, I only had this single line

U-Boot SPL 2013.01.01 (Mar 08 2019 - 10:28:04)


and nothing else happened. I think that something wrong with the preloader, it has something mismatched with my Quartus design or I have made mistakes during building the preloader.

I have searched in a lot of places, came up with many hypotheses, and tried to fix this. I even contacted Terasic and visited the Intel community forum, but I still haven't got an answer.","If U-boot is not showing up, then the preloader is not doing its job. There are some settings that you need to check when building the preloader for baremetal designs (Watchdog timer must be disabled for instance).

If U-boot starts and you can enter commands in it it means your preloader works fine. You could enter commands manually on u-boot at first to configure the FPGA (enable bridges, load rbf and go to the software application start address) If by following this method you get the application and FPGA running, it means all your files are correctly generated but you need to script the necessary u-boot commands and run the script to automatically configure the FPGA and run the application from u-boot.

Here is a link to a github repository for DE1-SoC where you can find a full tutorial on how to boot HPS-FPGA system in baremetal : https://github.com/sahandKashani/SoC-FPGA-Design-Guide/blob/master/DE1_SoC/SoC-FPGA%20Design%20Guide/SoC-FPGA%20Design%20Guide%20%5BDE1-SoC%20Edition%5D.pdf

I hope it helps!",,,,,
"I have written code for my project in VHDL, but im getting an error while using signal","library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity keygeneration is
    Port ( key : in  STD_LOGIC_VECTOR (127 downto 0);
           rc : in  STD_LOGIC_VECTOR (3 downto 0);
           keyout : out  STD_LOGIC_VECTOR (127 downto 0));
end keygeneration;

architecture Behavioral of keygeneration is

component sbox is
     port(a: in std_logic_vector(7 downto 0);
          y: out std_logic_vector(7 downto 0));
end component;
component RCON is
 Port ( rc : in  STD_LOGIC_VECTOR (3 downto 0);
            rout : out  STD_LOGIC_VECTOR (31 downto 0));
end component;
signal w0,w1,w2,w3,tem: STD_LOGIC_VECTOR (31 downto 0);
signal rout1: STD_LOGIC_VECTOR (31 downto 0);

begin
-- 52nd line below
w0&lt;=key[127 downto 96];
w1&lt;=key[95 downto 64];
w2&lt;=key[63 downto 32];
w3&lt;=key[31 downto 0];

t1: sbox port map(w3[23 downto 16],tem[31 downto 0]);
t2: sbox port map(w3[15 downto 8],tem[23 downto 16]);
t3: sbox port map(w3[7 downto 0],tem[15 downto 8]);
t4: sbox port map(w3[31 downto 24],tem[7 downto 0]);

r1: RCON port map(rc[3 downto 0],rout1[31 downto 0]);

keyout[127 downto 96]&lt;=w0^tem^rout1;
keyout[95 downto 64]&lt;=w0^tem^rout1^w1;
keyout[63 downto 32]&lt;=w0^tem^rout1^w1^w2;
keyout[31 downto 0]&lt;=w0^tem^rout1^w1^w2^w3;

end Behavioral;


Error found is 


  ERROR:HDLParsers:164 - ""D:/Files/newpro/keygeneration.vhd"" Line 52.
  parse  error, unexpected INTEGER_LITERAL, expecting RETURN or
  IDENTIFIER or  RSQBRACK.


I have shown the 52nd line in the code. I have got the same error for all the assignment statements from line 52. Please help. Thanks in advance","2 errors:

VHDL does not use [] for indexing arrays (though they are used for signatures). Use () for indexing arrays instead.

There is no ^ operator in VHDL. Use xor instead.",,,,,
Inferring Latch in a nested If-Else statement (VHDL),"I have a problem with an inferred latch with my code. I know a latch is usually caused by not having all situations for an output accounted for, but in this situation, I haven't seen any online examples that cover this. I have a nested if-else statement in a process statement as shown below. Just to quickly explain what I'm doing, after a reset is initiated, reset_cnt will go high and initiate a counting process for sck up to 24 cycles and repeat itself and output will increment. 

clock_counter: process(reset, sck, counter, output, reset_cnt, reset_done)
begin
  if (reset = '1') then
    counter &lt;= 0;
    output &lt;= 1;
    reset_cnt &lt;= 1;
    reset_done &lt;= '1';
  else
    reset_done &lt;= '1';   -- added to fix
    reset_cnt &lt;= 1;      -- added to fix
    output &lt;= output;          -- added to fix (didn't work)
    if (reset_cnt AND counter = 24) then
      counter &lt;= 0;
      output &lt;= output + 1;
    elsif (rising_edge(sck)) then
      counter &lt;= counter + 1;
    end if;
  end if;
end process;


Originally I had a problem with 3 latches: reset_done, reset_cnt, and output. I added in some lines of code (the ones with the comments next to it) and I was able to remove latches for reset_done and reset_cnt. It looks like I still get an inferred latch for out because I use it in the nested If statement. I thought:

output &lt;= output;


might work, but I guess not. Does anyone know how to fix this kind of latch? I should mention, I've tried splitting this up into 2 process statements, and making it into a case statement, but that didn't work either. Any help or advice is much appreciated!","This code is totally wrong. It's hard to fix because it combines multiple mistakes in one process.

I'll try to enumerate some of your mistakes:


The sensitivity list should not use output and reset_done.
output &lt;= output + 1; cannot be synthesized or will create an endless loop in simulation
you need to distinguish combinational and sequential logic into two processes
reset_done and reset_cnt are useless, because they are always '1'
reset_cnt is an integer, this cannot be ANDed with a boolean from expression counter = 24
never write output &lt;= output;


I suggest to study about combinational and sequential processes as well as coding patterns for VHDL.",,,,,
Verilog HDL error: Illegal left-hand side assignment,"I am learning CPU Design and basic Verilog HDL. I have a processor running in tkgate on Fedora 29 and I have designed a hardware RAM disk. I can't test the RAM but have decided to replace it with an HDL RAM disk. Whenever I try to simulate the circuit, I get the error:
RAM_HDL, line 17: Illegal use of 'w7' in left-hand-side assignment.
Here is my code for the RAM:  

module RAM_HDL(RAM, Data_In, Data_Out, Address, RW);  
    reg [15:0] RAM [127:0];  
    wire [15:0] Data_In;  
    wire [15:0] Data_Out;  
    wire [7:0] Address;  
    wire RW;  

    initial  
        $readmemb(""RAM_DATA.BIN"", RAM);  

    always @(*)  
        begin  
            if (RW)  
                RAM[Address] &lt;= Data_In;  
            Data_Out &lt;= Address;  
        end  

   endmodule  


The error is on line 17:  

Data_Out &lt;= Address;  
","The following code compiles at least:  

module RAM_HDL(Data_In, Data_Out, Address, RW);

reg [15:0] RAM [127:0];    
input [15:0] Data_In;  
output [15:0] Data_Out;  
input [7:0] Address;  
input RW;  

initial  
  $readmemb(""RAM_DATA.BIN"", RAM);  

always @(*)  
  begin  
    if (RW)  
      RAM[Address] &lt;= Data_In;  
  end  
assign Data_Out = RAM[Address];  

endmodule
",,,,,
Why is my System Verilog Dynamic Array sum constraint is not working? (Run on EDA Playground (Aldec Tool Riviera Pro 2017),"Why is my System Verilog Dynamic Array sum constraint is not working? (Run on EDA Playground (Aldec Tool Riviera Pro 2017)
/////////////////////////////////////

/////========================

class c ;

string name;

rand logic [4:0] len;

rand logic [4:0] duty_cycles[];

constraint c1 { duty_cycles.size()==len; len inside {[2:5]}; solve len before duty_cycles;};

constraint c2 { duty_cycles.sum() with (int'(item)) == 20;};

function new(string name=""randcreaterâ€?

this.name=name;

endfunction

function void post_randomize ();

$display (""New rand of len %d, sum=%d"",duty_cycles.size, duty_cycles.sum());

foreach(duty_cycles[i])begin $display(""%d"",duty_cycles[i]); end

endfunction

endclass

/////=====================

module testbench ();

c obj;

initial begin

obj = new;

repeat (10) begin

obj.randomize();

 #10;

end

end
endmodule


/////////////////////////////////////


Result :

KERNEL: New rand of len 2, sum= 6

KERNEL: 6

KERNEL: 0

KERNEL: New rand of len 2, sum= 4

KERNEL: 2

KERNEL: 2","The reason for this is your tool has a bug. The software versions on EDAPlayground are old. Try a different simulator. 

Also, there is no need for the solve len before duty_cycles; because the size of an array always picks a value before any constraints on its elements. ",,,,,
SystemVerilog conditional statement syntax error,"Im trying to practice SystemVerilog and attempting to implement an ALU(Arithmetic  Logic Unit) based  on this diagram:



I simulating SystemVerilog code on EDA playground online(https://www.edaplayground.com/x/mYi):

ALU:

module alu(
  input  [31:0] a,
  input  [31:0] b,
  input  [2:0] f,
  output [31:0] result,

);

  /*000*/
  if (f[0]==0 &amp;&amp; f[1]==0 &amp;&amp; f[2]===0)
    begin
    assign result = a &amp; b;
    end
  /*001*/
  else (f[0]==0 &amp;&amp; f[1]==0 &amp;&amp; f[2]==1)
    begin
    assign result = a | b;
    end
  /*010*/
  else (f[0]==0 &amp;&amp; f[1]==1 &amp;&amp; f[2]==0)
    begin
    assign result = a + b;
    end
  /*011 not used*/ 
  else (f[0]==0 &amp;&amp; f[1]==1 &amp;&amp; f[2]==1)
    begin
    assign result = -1;
    end
  /*100*/
  else (f[0]==1 &amp;&amp; f[1]==0 &amp;&amp; f[2]==0)
    begin
    assign result = a &amp; ~b;
    end 
  /*101*/  
  else (f[0]==1 &amp;&amp; f[1]==0 &amp;&amp; f[2]==1)  
    begin
    assign result = a | ~b;
    end
  /*110*/
  else (f[0]==1 &amp;&amp; f[1]==1 &amp;&amp; f[2]==0) 
    begin
    assign result = a - b;
    end
  /*111 slt*/
  else
    begin
    assign result = -1; 
    end

endmodule


Partial Test Bench:

module testharness();
  reg  [31:0] a;
  reg  [31:0] b;
  reg  [2:0] f;
  reg  [31:0] result;


//DUT (Device Under Test)
alu alu_0 (
  .a   (a),
  .b   (b),
  .f    (f),
  .result (result)
);

// Test program
initial begin
     /*000*/
  f[0]=0; 
  f[1]=1;
  f[2]=0;
  /*0+0*/
  a[0]=0;
  b[0]=0;

  $display( ""a (%d) + b (%d) = %d%d%d%d"", a[0], b[0], result[0], result[1]);
   /*000*/
  f[0]=0;
  f[1]=1;
  f[2]=0;
  /*0+1*/
  a[0]=0;
  b[0]=1;

 $display( ""a (%d) + b (%d) = %d%d"", a[0], b[0], result[0], result[1]);

     /*000*/
  f[0]=0;
  f[1]=1;
  f[2]=0;
  /*1+1*/
  a[0]=1; 
  b[0]=1; 

  $display( ""a (%d) + b (%d) = %d%d"", a[0], b[0], result[0], result[1]);

  $finish;
end

endmodule


I keep getting  this error:

ERROR VCP2000 ""Syntax error. Unexpected token: (. Expected tokens: '???' , ';' , 'always' , 'and' , 'assign' ... ."" ""design.sv"" 15  9

This is line: 

else (f[0]==0 &amp;&amp; f[1]==0 &amp;&amp; f[2]==1)
    begin
    assign result = a | b;
    end


I dont  see anything obvious.

Thanks","I think you are mixing up combinational logic using the alwaysstatement and continuous assignments. As mentioned earlier by other users, I also think it would be good if you would take a look at some basic Verilog tutorials. Asic-world.com has some great tutorials to get started with, for example, Verilog in One Day by Deepak Kumar Tala.

However, let me try to explain this to you. What you are using in your example is the continuous assignment statement. You can find more about this in section 10.3.2 in the IEEE Std 1800-2012. The manual says:


  Assignments on nets or variables shall be continuous and automatic. In
  other words, whenever an operand in the right-hand expression changes
  value, the whole right-hand side shall be evaluated.


This is not the case here since the right-hand side operands of all your assignment statements are the same. It is not automatic, because it depends on your if statements. Take a look at this really simple example below. If you always want result to be a &amp; b, you can use the code below. However, as you can imagine, for more complex logic this becomes rather lengthy.

module alu(
  input  [31:0] a,
  input  [31:0] b,
  output [31:0] result,

);

    assign result = (a &amp; b);

endmodule


That's why SystemVerilog offers procedural blocks like always, always_comb, always_latch, and always_ff (section 9 in the IEEE Std 1800-2012). For your example, you should use always_comb. To quote section 9.2.2.2 of the manual:


  SystemVerilog provides a special always_comb procedure for modeling
  combinational logic behavior.


With this, we could rewrite your code to

module alu(
  input  [31:0] a,
  input  [31:0] b,
  input  [2:0] f,
  output [31:0] result,

);

  reg [31:0] result_;   

  always_comb 
  begin
    /*000*/
    if (f[0]==0 &amp;&amp; f[1]==0 &amp;&amp; f[2]===0)
    begin
      result_ = a &amp; b;
    end
    /*001*/
    else if (f[0]==0 &amp;&amp; f[1]==0 &amp;&amp; f[2]==1)
    begin
      result_ = a | b;
    end
    /*010*/
    else if (f[0]==0 &amp;&amp; f[1]==1 &amp;&amp; f[2]==0)
    begin
      result_ = a + b;
    end
    /*011 not used*/ 
    else if(f[0]==0 &amp;&amp; f[1]==1 &amp;&amp; f[2]==1)
    begin
      result_ = -1;
    end
    /*100*/
    else if (f[0]==1 &amp;&amp; f[1]==0 &amp;&amp; f[2]==0)
    begin
      assign result = a &amp; ~b;
    end 
    /*101*/  
    else if (f[0]==1 &amp;&amp; f[1]==0 &amp;&amp; f[2]==1)  
    begin
      result_ = a | ~b;
    end
    /*110*/
    else if (f[0]==1 &amp;&amp; f[1]==1 &amp;&amp; f[2]==0) 
    begin
      result_ = a - b;
    end
    /*111 slt*/
    else
    begin
      result_ = -1; 
    end
  end // End of always_comb

  assign result = result_;

endmodule


Please mind that you can continously assign a wire, but you need to declare a variable as a reg to use it in an always block. That's the reason I am using result_, instead of directly assigning result. At the end of the code block, I continuously assign result_ to result. Asic-world.com also has a tutorial on the difference between regs and wires.

If you don't want to think about whether to use reg or wire, you could also use th new keyword logic.

Edit: As Oldfart pointed out, I orgininally forgot to fix your if...else statements. In your code, you always use else instead of else if. This is probably also the direct cause of the error the compiler is throwing at you.",,,,,
Parametrized uvm sequence item to adjust size,"I have an issue and I am out of ideas on how to resolve it. I have a class that contains an array called data. This dynamic array can be of parametrized packed width - either 8, 16, or 32 bits for example.

class MyItem#(int WIDTH=8) extends uvm_sequence_item;

  bit[WIDTH-1:0] data[];

endclass


The problem is, when I want to instantiate an object of MyItem, I need to provide it with the parameter. The WIDTH parameter however, depends on some other settings and for the puspose of the example lets assume can be randomly generated between 8,16, and 32.

class MySequence extends uvm_sequence;

  rand int width;
  constraint c_width {width inside {8, 16, 32}; }

  task body();
    MyItem#(width) req = MyItem#(width)::type_id::create(""item""); // &lt;--- THIS IS NOT ALLOWED
  endtask

endclass


So I had to come up with a way to work around this. The one way is to have a handle inside MyItem to all the different widths and then use the one I need. Something to the effect of:

class MyItem extends uvm_sequence_item;
  bit[ 7:0] data_08[];
  bit[15:0] data_16[];
  bit[23:0] data_24[];
endclass


This would allow me to use the handle depending on the packed size. But this is a bit hacky and I would prefer avoiding this as I have to keep checking the WIDTH parameter and access data_08, data_16 or data_24 seperately which bloats the code.

The other option is to just use a MAX_WIDTH parameter, and pad the bits.

class MyItem extends uvm_sequence_item;
  bit[MAX_WIDTH:0] data[];
endclass


But for very large arrays, this is a waste of memory and not efficient.

The final solution I came up with, but doesn't work is to create a base class called MyItemBase, and then Item extends from this. So now I can (or rather, should be able to) access data as just obj_handle.data

class MyItemBase extends uvm_sequence_item;
  bit data[];
endclass

class MyItem#(WIDTH) extends MyItemBase;
  bit[WIDTH-1:0] data[];
endclass


What this allows me to do is use the below code in my sequence:

  rand int width;
  constraint c_width {width inside {8, 16, 32}; }

  task body();
    MyItemBase req
    case(width)
      8:  req = MyItem#(8)::type_id::create(""item"");
      16: req = MyItem#(8)::type_id::create(""item"");
      32: req = MyItem#(8)::type_id::create(""item"");
      default: //
    endcase

    // Now I should be able to use req.data
    req.data = new[32];
    foreach(req.data[i]) req.data[i] = $urandom();
    foreach(req.data[i]) $display(""data[%0d] = %0x"",  i, data[i]);
  endtask

endclass


As you might have guessed, this didn't work. My data array is just one bit wide and I guess it is getting it from the base class, so polymorphism doesn't work for variables the way it does for functions (unless I am missing something key here).

Now having the single bit version of data in the MyItemBase class causes compilation errors unless I cast to the derived type. This causes some additional complexity and I feel I am getting way in over my head on a simple problem.

Can anyone give me any suggestions on how to structure this?
Thanks","What I suggest is creating a 2-dimensional dynamic array. Since you seem to be working with bytes widths, you could do:

bit[7:0] data[][];


Then the second dimension can be constructed with

   foreach(data[I]) data[I]= new[width/8];


If you need to work with a packed array, you could declare a local variable with a max width, and stream the data bytes from/to the local variable;

bit [MAX_WIDTH-1:0] temp;
...
temp = {&lt;&lt;{data[I]}};
",,,,,
I cannot assign output to value in Verilog,"I am trying to assign ADDR to pcOut but ADDR is showing up as xxxxxxxx in GTKWave.

Here is my code:

module processor (
    input CLK,

    // Memory
    input [31:0] DATAOUT, // Memory data out
    output [31:0] DATAIN, // Memory data in
    output [31:0] ADDR, // Memory address
    output WE // Memory write enable
);
    wire [3:0] aluSel;
    wire [4:0] regSel1, regSel2, regDataSel;
    wire regLoad, aluEnable, pcLoad, pcNext;
    wire [31:0] regDataIn, regDataOut1, regDataOut2, aluOut, pcOut, pcIn, aluA, aluB;

    assign ADDR = pcOut;

    controlUnit controlUnit (
        .CLK(CLK), // Clock

        // Outputs
        .memDataOut(DATAOUT),
        .regDataOut1(regDataOut1),
        .regDataOut2(regDataOut2),
        .aluOut(aluOut),
        .pcOut(pcOut),

        // Load and enable
        .pcLoad(pcLoad),
        .regLoad(regLoad),
        .aluEnable(aluEnable),

        .pcNext(pcNext),

        // Selects
        .aluSel(aluSel),
        .regSel1(regSel1),
        .regSel2(regSel2),
        .regDataSel(regDataSel),

        // Inputs
        .pcIn(pcIn),
        .regDataIn(regDataIn),
        .aluA(aluA),
        .aluB(aluB),
        .memDataIn(DATAIN),
        .memAddr(ADDR)
    );

    datapath datapath (
        .pcNext(pcNext),

        // Load and enable
        .pcLoad(pcLoad),
        .regLoad(regLoad),
        .aluEnable(aluEnable),

        // Selects
        .aluSel(aluSel),
        .regSel1(regSel1),
        .regSel2(regSel2),
        .regDataSel(regDataSel),

        // Inputs
        .regDataIn(regDataIn),
        .pcIn(pcIn),
        .aluA(aluA),
        .aluB(aluB),

        // Outputs
        .regDataOut1(regDataOut1),
        .regDataOut2(regDataOut2),
        .aluOut(aluOut),
        .pcOut(pcOut)
    );
endmodule


Can anyone help?
Thanks in advance.

Edit:
pcOut is outputting the correct value but ADDR is not being set that same value.

Edit 2:
Here is the code for the controlUnit module:

module controlUnit (
    input CLK,
    input [31:0] memDataOut, regDataOut1, regDataOut2, aluOut, pcOut,
    output reg [0:0] pcLoad, regLoad, aluEnable, pcNext,
    output reg [3:0] aluSel,
    output reg [4:0] regSel1, regSel2, regDataSel,
    output reg [31:0] pcIn, regDataIn, aluA, aluB, memDataIn, memAddr
);
    reg cycle = 0;
    wire [10:0] opcode;
    wire [4:0] rs1, rs2, rd;

    decoder decoder (
        .cycle(cycle),
        .instruction(memDataOut),

        .rs1(rs1),
        .rs2(rs2),
        .rd(rd),
        .opcode(opcode)
    );

    always @(posedge CLK) begin
        case (cycle)
            1'b0: begin
                regLoad &lt;= 0;
                aluEnable &lt;= 0;
                pcNext &lt;= 0;
            end
            1'b1: begin
                pcNext &lt;= 1;
                case (opcode)
                    11'b00000110011: begin // Add
                        regSel1 &lt;= rs1;
                        regSel2 &lt;= rs2;
                        regDataSel &lt;= rd;
                        aluSel &lt;= 0;
                        aluEnable &lt;= 1;
                        regDataIn &lt;= aluOut;
                        regLoad &lt;= 1;
                    end
                    11'b10000110011: begin // Sub
                    end
                endcase
            end
        endcase

        cycle &lt;= !cycle;
    end
endmodule
","Your controlUnit doesn't seem to have any logic attached to memAddr, but memAddr is still an output of controlUnit. At the top level, you port map ADDR to .memAddr, and you also assign ADDR = pcOut. You're trying to drive ADDR in two different locations.",,,,,
Proper way to change state on a state machine in VHDL,"I'm working on a FPGA project where I need to read data from an image sensor. This sensor has different image modes (like test pattern, frame, binning, etc.) and in order to change image mode I need to look for specific signals before writing into the registers.

I have inherited some code that I need to fix since the image sensor sometimes gets stuck when we change image mode.

Concerning the change of image mode, a state machine is used.

The following piece of code shows how the registers for changing mode are currently written.
Essentially, when we want to change mode, we need to wait that the signal MODE_SIG_HIGH becomes high before writing into the registers. Then, when this condition happens, we check what mode we want to set. For example, to set set test pattern, we check if bit S2 is set. Then we performs all the operations to actually change mode (line 10).

01. ...
02. WHEN MODE_SIG_HIGH =&gt;
03.   NEXT_ST &lt;= MODE_SIG_HIGH;
04.   ...
05.   IF S2 = '1' THEN 
06.     -- configure the sensor to            
07.     NEXT_ST &lt;= CONFIGURE_TEST_PATTERN;
08.   END IF; 
09.   ...
10.   WHEN CONFIGURE_TEST_PATTERN =&gt;
11.   ...


I'm having a debate with a friend of mine concerning what is the best way to change state when a new event happens. The above solution doesn't seem right to me.
As far as I understood, when we enter a sate, all the instructions contained in that state are performed in parallel. Therefore, concerning the above piece of code, when we enter the state MODE_SIG_HIGH the instruction at line 03 is executed in parallel to the IF condition. My point is that if the bit S2 is set to 1, the IF condition is true and we end up assigning the value CONFIGURE_TEST_PATTERN to the NEXT_ST. An this ends up in assigning two different values to the same variable (in parallel), in line 03 and in line 07. Am I right or am I missing some basic behavior? The reason for having the instruction at line 3 is because after we enter MODE_SIG_HIGH, it could take some clock cycles before we see on of the mode bits set.","
  As far as I understood, when we enter a sate, all the instructions
  contained in that state are performed in parallel.


Not quite. The only things in VHDL which are concurrent ('performed in parallel') are:


processes
concurrent signal assignments
component instantiations
concurrent procedure calls 
concurrent assertions (inc.PSL)
generates
blocks


The code inside a process or subprogram (function/prodedure) executes sequentially. This is where you do your conventional programming, using sequential statements (ie. nothing in the list above). These are your standard control constructs (if, case, loop, etc), sequential signal assignments, and so on. If you carry out signal (or variable) assignments in a sequential region, the last one wins, just like a conventional programming language. There are scheduling rules that make this happen, but you don't need to know about those (yet!)",,,,,
Problem with Verilog Dataflow testbench causing different errors on different sites,"This program is in Dataflow Verilog.  What I'm trying to do is make an adder and subtractor dependent on a selector.  I am currently getting some errors that are either ""syntax error in continuous assignment"" for line 10, (the assign {cout...},) or ""Error launching EPWave: [Could not parse file: $timescale not found in the header.]. Could not load './dataflow_hw_1.vcd'"".  

I have looked all over the internet in search of how to solve this problem, but I keep attempting the recommended solutions to no avail.  I don't know what's wrong when trying to testbench it.

Here is the code:

module dataflow_1 (a[7:0],b[7:0],out[7:0],cout);

  input a,b;
  output out,cout;
  //if a have odd number of 1s, output = a + b
  //else if even positions have even number of 1s in total, output = a-b

  assign selectorOdd = (a[1]^ a[3]^ a[5] ^ a[7]);
  assign selectorEven = (~selectorOdd &amp; ~(a[0] ^ a[2] ^ a[4] ^ a[6])); 
  assign {cout,out[7:0]} = (selectorOdd &amp; ({a[7:0] + b[7:0}) | (selectorEven &amp; ({a[7:0] - b[7:0]}));


endmodule


Here is the testbench code:

// Code your testbench here
module dataflow_1();

  reg [7:0] a;
  reg [7:0] b;
  wire [7:0] out;


   dataflow_1  test(
     .a(a),
     .b(b),
     .out(out)
  );

  initial begin
    $dumpfile(""dump.vcd"");
    $dumpvars(0, out);

    a = 8'b01010101;
    b = 8'b00000001;
  #100;

  end



endmodule
","The problem is on this line:

assign {cout,out[7:0]} = (selectorOdd &amp; ({a[7:0] + b[7:0}) | (selectorEven &amp; ({a[7:0] - b[7:0]}));


you used wrong {} and [], {} used to concatenate the bits. It should be fixed like this:

assign {cout,out} = selectorOdd ? (a + b) : (selectorEven ? (a - b) : {9{1'b0}});


Your code should have more the case for else all. In this code if selectorOdd and selectorEven are 0, I assign {cout,out}={9{1'b0}}.",,,,,
Read and write from txt in Verilog,"First of all I want to say that I'm running the simulation in ADS (Advanced Design System 2017) through a Verilog model compiled in ModelSim.

My objective is loading data from a .txt file into the testbench as input in order to run the simulation, and afterwards save the results of this simulation in another .txt file.

Here is the content for the input test .txt file called ""param.txt"":

1
2
3
4
5


And here is my Verilog testbench code:

`include ""disciplines.vams""


module resistor(p,n);
electrical p,n;
parameter real R=50.0;
integer file;
integer out;
real pwm_A[0:10];
integer i;
integer count;


analog begin

    @(initial_step) // Initial Conditions
    begin


////////////// Read

file=$fopen(""param.txt"",""r"");

    if (file)  $display(""File was opened successfully : %0d"", file);
    else       $display(""File was NOT opened successfully : %0d"", file);

    for (i=1; i&lt;=5; i=i+1) begin  
         count = $fscanf(file,""%d"",pwm_A[i]);
    end



////////////// Write


out=$fopen(""out.txt"",""w"");

    for (i=1; i&lt;=5; i=i+1) begin  
        $fwrite(out,""%d\n"",pwm_A[i]);
    end


$fclose(file);
$fclose(out);


end

// Simulation (doesnt matter)
V(p,n) &lt;+ R * I(p,n);


end
endmodule


The simulation throws this error:

Error: Incorrect target supplied to integer-valued $fscanf field.


May anyone spot the problem?

Thanks in advance.","You have declared pwm as an array of reals whilst using the %d format specifier to both read and write the file. You need to either

i) change pwm to be an array of integers or

ii) change the %d format specifier to %f in the $fscanf and $fwrite system function calls.

The %d format specifier is expecting to read and will write a decimal integer.",,,,,
Verilog questions on 2's complement and left roate,"I am trying to write a 16 bits ALU with verilog.
My inputs are 16 bits Ain,Bin and 16 bits output out.

I am required to do a 2's complement addition and subtraction of both inputs. As such I am wondering if I can just use the '+' and '-' operator. Ain+Bin, Ain-Bin

Also, I am required to do a left rotate of the bits in A by a certain value N. I came out with the following where I replicate A to form 32 bits and shift it to the left by N bits. But now the problem is I am required to reduce it to 16 bits again but how can I do that?

out &lt;=({A,A}&lt;&lt;N);","Yes, you can just use +- operators if you want to add or subtract two numbers.

If you want to truncate the result back to 16 bits, just assign the result to a 16 bit wire/register, and it will automatically drop the upper bits and just assign the lower 16 bits to out. In some cases this may create a lint warning, so you may want to assign the result to an intermediate variable first, and then do an explicit part select.

wire [15:0] out;
wire [15:0] A;
wire [31:0] A_rotate;

A_rotate = {A,A} &lt;&lt; N;
out = A_rotate[15:0];
",,,,,
"What can I use for developing on FPGA (Virtex): C, C++, OpenCL, MPI?","What can I use for developing on FPGA Virtex-5 or Virtex-7: C, C++, C++11, OpenCL, MPI?
And what is mostly usually uses for this?

There are:


SystemC is a set of C++ classes and macros which provide an event-driven simulation interface in C++
AutoESL
Vivado HLS - (High-level synthesis)
VHDL (VHSIC(very-high-speed integrated circuits) Hardware Description Language
Software-based system realization with C/C++ and Future plans for OpenCL support
","A FPGA is just a big configurable circuit, and developing for it is creating a program that is ""compiled"" into a gigantic map of how the transistors and other low-level components are configured. It is fundamentally different from a normal CPU, or even a GPU : it is massively parallel at a very low level.

Programming such board requires another way of thinking. There are two main strategies:


Develop with System Verilog, or another HDL (Hardware Description Language),
Use SystemC, or other wrapper that allows you to use C/C++ for FPGA (it will be less optimized)


Normally, the board should come with a manual indicating what to use to program it.

On a personal side, I never used OpenCL with a FPGA (but I used CUDA for GPGPU), so I don't know how it works (but I think you have some overhead, as you have to emulate some small computing units).",,,,,
Verilog simulator for windows,"I'm looking for a verilog simulator for windows. All I see is the source code for veriwell, with makefiles for Linux. Anybody have any suggestion on where I can find the binaries for veriwell or other Verilog simulator.","Veriwell is an excellent simulator, but unfortunately only supports vlog-95, which makes it unusable for realistic designs. Icarus is the way to go - I'm pretty sure you can download Windows binaries, very reliable and stable, active support, good language compliance, very low level of bugs (much better than at least one widely-used commercial simulator, for example).",,,,,
VHDL code in NCLaunch giving errors not given in Xilinx,"I am trying to make a dataflow design for a comparator in VHDL. It compiles and simulates fine in Xilinx, but I have to use Cadence/NCLaunch. When I copied the same code to gedit and ran it, it gives an error about a semicolon.

my code is :

library ieee;
use ieee.std_logic_1164.all;
-----------------------------------------------------
entity Comparator is
port(   A:    in std_logic_vector (3 downto 0);
        B:    in std_logic_vector (3 downto 0);
        AeqB:  out std_logic;
    AltB:  out std_logic;
    AgtB:  out std_logic);
end Comparator;


architecture dataflow of Comparator is

signal AeB : std_logic;
signal AlB : std_logic;
signal AgB : std_logic;
signal i : std_logic_vector (3 downto 0);
signal j : std_logic_vector (3 downto 0);

begin
    B1: BLOCK BEGIN   
        AeB &lt;= i(3) AND i(2) AND i(1) and i(0);
        AgB &lt;= j(3) or j(2) or j(1) or j(0);
        AlB &lt;= AeB nor AgB;
    END BLOCK B1;


    B2: BLOCK BEGIN
            i &lt;= a xnor b;
    END BLOCK B2;


    B3: BLOCK BEGIN
        j(3) &lt;= (not b(3)) and a(3);
        j(2) &lt;= i(3) and not b(2) and a(2);
        j(1) &lt;= i(3) and i(2) and not b(1) and a(1);
        j(0) &lt;= i(3) and i(2) and i(1) and not b(0) and a(0);       
    END BLOCK B3;


    B4: BLOCK BEGIN
        AeqB &lt;= AeB;
        AltB &lt;= AlB;
        AgTB &lt;= AgB;
    END BLOCK B4;


end dataflow;


...and the error I get is:

i &lt;= a xnor b;
       |
ncvhdl_p: *E,EXPSMI (/ugrad/syedhuq/ECE425/Lab2/Comparator.vhd,29|11): expecting a semicolon (';') [9.5.1].


As far as I can tell, I have a semicolon there...also if I replace the statement with four individual statements like 

i(n) &lt;= a(n) xnor b(n); //[n = 1, 2, 3, 4], 


i get the same error 4 times. Can anyone help me out with this??

Also, it compiles fine in Synopsys (VCSMX) and so does the testbench file, but during the linking process it tells me :

Design unit 'COMPARATOR(BEHAVE)' from library '.' cannot be opened for 
  reading.
  Possible causes:
  [1] Incorrect logical to physical mapping in synopsys_sim.setup file. 
  [2] Intermediate file generation was prematurely terminated during analysis.
  Reanalyze the design unit and resolve any errors that occur during analysis.


the relevant line from the testbench code is:

for x1: Comparator use entity work.Comparator(Behave);
","I'm not familiar with Cadence/NCLaunch, but knowing your code analyzes correctly in an IEEE 1076-1993 compliant tool, and noting where error is (you indicated character position 11 in line 29, noting it appears to be character position 17), I'd say off hand it either doesn't have ""xnor"" un-commented in package std_logic_1164 (both the specification and the body), or it's a VHDL87 compliant tool, or there's some missing tool set or command line argument to use use the proper std_logic_1164 package.

In the distributed source for std_logic_1164, available from 
http://standards.ieee.org/downloads/1076/1076.2-1996/

-- --------------------------------------------------------------------
--  version | mod. date:| 
--   v4.200 | 01/02/92  | 
-- --------------------------------------------------------------------


You'll find that xnor is commented out by default, when after VHDL92 (-1993, don't ask) was approved it was supposed to be un-commented.

--  -----------------------------------------------------------------------
--  Note : The declaration and implementation of the ""xnor"" function is
--  specifically commented until at which time the VHDL language has been
--  officially adopted as containing such a function. At such a point, 
--  the following comments may be removed along with this notice without
--  further ""official"" ballotting of this std_logic_1164 package. It is
--  the intent of this effort to provide such a function once it becomes
--  available in the VHDL standard.
--  -----------------------------------------------------------------------
--  function ""xnor"" ( l, r : std_logic_vector  ) return std_logic_vector;
--  function ""xnor"" ( l, r : std_ulogic_vector ) return std_ulogic_vector;


9.5.1 refers to Conditional signal assigns in IEEE=1076-1993.

The analyzer is acting like it doesn't recognize xnor as a operator and if you look in -1993 7.2.1 Logical operators:


  The logical operators and, or, nand, nor,xor, xnor, and not are
  defined for predefined types BIT and BOOLEAN. They are also defined
  for any one-dimensional array type whose element type is BIT or
  BOOLEAN.


Which tells us in an IEEE 1076-1993 compliant tool the declarations for xnor would come from the std_logic_1164 package.

I had a quick gander through some NCSIM, etc. online user guides and tutorials and didn't see anything relating to the problem.  It's likely the std_logic_1164 package hadn't had xnor un-commented in both the declaration and body.

The issue may be the the providence (age) or the particular tool copy you are using and may require sysadmin help to correct. In the mean time you can either write your own xnor function (shown), if running into any difficulties try and use not( a xor b) instead.

architecture dataflow of Comparator is


function ""xnor""  ( l : std_logic; r : std_logic ) return ux01 is
begin
    return not (l xor r);
end ""xnor"";

signal AeB : std_logic;
signal AlB : std_logic;
signal AgB : std_logic;
signal i : std_logic_vector (3 downto 0);
signal j : std_logic_vector (3 downto 0);

begin


Also see Weird XNOR behaviour in VHDL",,,,,
vhdl :: creating a type with a size parameter,"I was wondering is there was a way to defined a type with a size parameter in VHDL. e.g.

type count_vector(size: Natural) is unsigned (size-1 downto 0);


and then later on do something like

variable int : count_vector(32) := (others =&gt; '0');
variable nibble : count_vector(4) := (others =&gt; '0');


Essentially, is there a way to defined an ""array-like"" type, or is that not allowed by syntax?

I am currently trying to use generics for re-usability, but I would like to be able to take maximal advantage of generic typing (ie: Is it possible to write type-generic entities in VHDL? ).

Thanks in advance!","library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity foo is
     generic (
        constant INT_LEFT:    natural := 32;
        constant NIB_LEFT:    natural := 4
     );
     -- note entity declarative items are forward looking only
     -- a port declaration requires a type or subtype declared in a package
     -- you can also use a package for any constants

     -- a type or subtype can be declared as an entity declarative item here:
--     subtype int_size is unsigned(INT_LEFT downto 0);
--     subtype nib_size is unsigned(NIB_LEFT downto 0);
end entity;

architecture fum of foo is
    -- or as an architecture declarative item here:
    subtype int_size is unsigned(INT_LEFT downto 0);
    subtype nib_size is unsigned(NIB_LEFT downto 0);   

begin
USAGE:
    process 
        variable int:  int_size := (others =&gt; '0');
        variable nibble: nib_size := (others =&gt;'0');
    begin
        int := int + 3;
        -- the function ""+"" is L: UNSIGNED, R: NATURAL
        --  int_size and nibble_size are subtypes of UNSIGNED
        Report integer'IMAGE(TO_INTEGER(int));
        -- ditto for TO_INTEGER
        nibble := nibble + 2;
        -- if int_size or nibble_size were types it would require
        -- operator functions for those types.
        Report integer'IMAGE(TO_INTEGER(nibble));
        wait;
    end process;

end architecture fum;




Added:

This is in response to BennyBarns assertion in a comment on the question: ""I would like to add that while you can use n-dimensional arrays in VHDL, only the first one may be unconstrained"".

Contrary to the assertion:

entity t1 is
end entity;

architecture foo of t1 is

    type typeI is array ( natural range &lt;&gt;, natural range &lt;&gt;) of integer;

begin
    process is
        variable sigI : typeI(0 to 1, 0 to 1);  -- 2D integer array
    begin
        sigI(0,0) := 1;
        sigI(0,1) := 2;
        sigI(1,0) := 3;
        sigI(1,1) := 4; 
        report ""Initialized indiviually"";
        report ""sigI(0,0) = "" &amp; integer'IMAGE(sigI(0,0));
        report ""sigI(0,1) = "" &amp; integer'IMAGE(sigI(0,1));
        report ""sigI(1,0) = "" &amp; integer'IMAGE(sigI(1,0));
        report ""sigI(1,1) = "" &amp; integer'IMAGE(sigI(1,1));
        sigI := ((11,12),(13,14));
        report ""Initialized as an aggregate"";
        report ""sigI(0,0) = "" &amp; integer'IMAGE(sigI(0,0));
        report ""sigI(0,1) = "" &amp; integer'IMAGE(sigI(0,1));
        report ""sigI(1,0) = "" &amp; integer'IMAGE(sigI(1,0));
        report ""sigI(1,1) = "" &amp; integer'IMAGE(sigI(1,1));
        wait;
    end process;
end architecture;


The statement is imprecise and relates in the example subtype declaration to the deferred range constraint in the type declaration of UNSIGNED in package numeric_std.  The subtype indication requires a constraint either supplied by the type mark or explicitly.  It's only valid for a subtype indication type mark that is an unconstrained type.  

A subtype declaration of an unconstrained type must provide a constraint just as if you had added 

signal A: unsigned;


as an architecture declarative item to fum of entity foo:

ghdl -a foo.vhdl
foo.vhdl:24:12: declaration of signal ""a"" with unconstrained array type ""unsigned"" is not allowed


And just to make things interesting things interface lists can be special:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity fie is
    port (
        a:  in  unsigned
    );
end entity;

architecture fee of fie is

begin

EVAL:
    process (a)
    begin
        report ""Fie:a range is "" &amp; integer'IMAGE(a'LEFT) &amp; "" to "" &amp; 
                                  integer'IMAGE(a'RIGHT) ;
    end process;

end architecture fee;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity fie_tb is
end entity;

architecture fum of fie_tb is
    component fie is
        port (a: in unsigned);
    end component;

    signal aa:  unsigned (3 to 7);
begin

EUT: fie port map (a =&gt; aa);

end architecture;


The 'rules' can be found in the LRM section on Index constraints and discrete ranges, IEEE Std 1076-2008 5.3.2.2, -2002/-1993 3.2.1.1.",,,,,
Why unresolved inclusion?,"I wonder why I get the error msg ""unresolved inclusion"" for stddef.h



The background is this question:
https://stackoverflow.com/questions/18754434/altera-de2-hardware-timer-usage
where I try to solve the entire hw interrupt mechanism that I now divide into smaller problems to pinpoint what it is that makes the program not tick forward the time when I switch from polling to hardware timer. 

What do you think is the matter? Does this problem have anything to do with that time is not ticking forward? When I did it with polling it worked:

https://codereview.stackexchange.com/questions/30870/please-review-polling-for-nios-2

Now I want to do it with hw interrupts and I followed the manual but still have some issues that I hope you can help me with?","Search for stdio.h in your compiler's path. It could possibly be in some kind of include or inc folder. Then try to see if there is a stddef.h at the same place.

Try to remove the line including stddef.h and see if the compiler complains about stdio.h.

If you find both files, then you probably need to setup your build commands to add the path to the std*.h files (possibly with the -I flag).",,,,,
compiling Verilog code in Quartus,"I'm new to verilog HDL and my first project is to implement a simple stopwatch counter using a  set of registers. I'm using Altera Quartus. 

When I tried compiling the code below, I keep getting an error for each and everyone of the registers. one of the error messages looks like this:

Error (10028): Can't resolve multiple constant drivers for net ""sec0[3]"" at test_interface.v(127)

Anyone can help? The code simulates fine in Modelsim.

Here's the fragment of code that's causing problems:

always @ (posedge clk)

  if (qsoutput == 1)
      sec0 = sec0 + 1;
  else if (sec0 == 4'b1010) begin
      sec1 = sec1 + 1;
      sec0 = 4'b0000;
  end else if (sec1 == 4'b0110) begin
      min0 = min0 + 1;
      sec1 = 4'b0000;
  end else if (min0 == 4'b1010) begin
      min1 = min1 + 1;
      min0 = 4'b0000;     
  end else if (min1 == 4'b0110) begin
      sec0 = 4'b0000;
      sec1 = 4'b0000;
      min0 = 4'b0000;
      min1 = 4'b0000;
  end
","Based on your code in Dropbox, you are assigning registers in multiple always blocks. This is illegal for synthesis and cosponsors to the Altera Quartus error message is referring to. A reg type should only be assigned with in one always block.

As an example, sec0 is defined in always @(posedge reset_reg) and the code provided in your question. The code in Dropbox is even worse because you split the counter logic into 4 separate always blocks that assign sec0.

I suggest you put all sec* and min* resisters one clock synchronous always block with an asynchronous:

always(@posedge clk or posedge reset_reg)
begin
  if(reset_reg)
  begin
    // ... asynchronous reset code ...
  end
  else
  begin
    // ... synchronous counter code ...
  end
end


This paper goes into detail about good verilog coding practices for synthesis: 
http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA.pdf



Other issues you will have:


Use non-blocking (&lt;=) when assigning registers. This is discussed in Cliff's paper mentioned earlier.
Get rid of the initial block. I understand some FPGA synthesizers allow it and some ignore it. It is a better practice to have an asynchronous to put everything into a known and predictable value.
The block starting with always @ (clk or start_reg or lap_reg or reset_reg) has a bizarre sensitivity list and will likely give you problems. you wither want @(*) if you want combination logic or @(posedge clk or posedge reset_reg) for synchronous flops.
Very rarely dual edge flops are used. The line always @ (posedge clk or negedge clk) should be always @ (posedge clk) for synchronous or always @(*) for combination logic.
",,,,,
How to develop this algorithm?,"pollkey() should be called every millisecond and tick(&amp;timeloc) should be called every second and I don't have a thread library. The obvious way would be to do it with threads but now it seems that I need advice how to perform both the updates. The code I'm trying is

int main() {
    while (TRUE) {
        pollkey();
        puttime(&amp;timeloc);
        delay(1);
        IOWR_ALTERA_AVALON_PIO_DATA(DE2_PIO_REDLED18_BASE, timeloc);
        if (RUN == 1) {
            tick(&amp;timeloc);
            puthex(timeloc);
        }

    }
    return 0;
}


But I don't think that the above is 100 % correct. The entire program is

#include &lt;stdio.h&gt;
#include ""system.h""
#include ""altera_avalon_pio_regs.h""
extern void puttime(int* timeloc);
extern void puthex(int time);
extern void tick(int* timeloc);
extern void delay(int millisec);
extern int hexasc(int invalue);

#define TRUE 1
#define KEYS4 ( (unsigned int *) 0x840 )

int timeloc = 0x5957; /* startvalue given in hexadecimal/BCD-code */
int RUN = 0;

void pollkey() {

    int action = IORD_ALTERA_AVALON_PIO_DATA(DE2_PIO_KEYS4_BASE);
    putchar(action);
    if (action == 7) {
        timeloc = 0x0;
    } else if (action == 13) {
        RUN = 0;
    } else if (action == 14) {
        RUN = 1;
    } else if (action == 11) {
        tick(&amp;timeloc);
    }
}

int main() {
    while (TRUE) {
        pollkey();
        puttime(&amp;timeloc);
        delay(1);
        IOWR_ALTERA_AVALON_PIO_DATA(DE2_PIO_REDLED18_BASE, timeloc);
        if (RUN == 1) {
            tick(&amp;timeloc);
            puthex(timeloc);
        }

    }
    return 0;
}

int hex7seg(int digit) {
    int trantab[] = { 0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00,
            0x10, 0x08, 0x03, 0x46, 0x21, 0x06, 0x0e };
    register int tmp = digit &amp; 0xf;
    return (trantab[tmp]);
}

void puthex(int inval) {
    unsigned int hexresult;
    hexresult = hex7seg(inval);
    hexresult = hexresult | (hex7seg(inval &gt;&gt; 4) &lt;&lt; 7);
    hexresult = hexresult | (hex7seg(inval &gt;&gt; 8) &lt;&lt; 14);
    hexresult = hexresult | (hex7seg(inval &gt;&gt; 12) &lt;&lt; 21);
    IOWR_ALTERA_AVALON_PIO_DATA(DE2_PIO_HEX_LOW28_BASE, hexresult);
}

int hex7seg2(int digit) {
    int trantab[] = { 0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00,
            0x10, 0x08, 0x03, 0x46, 0x21, 0x06, 0x0e };
    register int tmp = digit &amp; 0xf0;
    return (trantab[tmp]);
}


I created subroutine for the delay, I think I might not change this:

        .equ    delaycount,     16911 #set right delay value here!
        .text                   # Instructions follow
        .global delay           # Makes ""main"" globally known

delay:  beq     r4,r0,fin       # exit outer loop

        movi    r8,delaycount   # delay estimation for 1ms

inner:  beq     r8,r0,outer     # exit from inner loop

        subi    r8,r8,1         # decrement inner counter

        br      inner

outer:  subi    r4,r4,1         # decrement outer counter
        br      delay


fin:    ret


The tick file is

extern void delay(int millisec);

/*
 * tick - update the time by adding one second
 * 
 * Parameter (only one): the address of the time variable.
 */
void tick( int * timeloc )
{
  /* Read time variable. */
  int tmp = * timeloc;

  tmp = tmp + 1; /* try a tick */

  /* if we ticked from 9 seconds to 10, adjust time properly */
  if( (tmp &amp; 0x000f) == 0x000a ) tmp = tmp - 0x000a + 0x0010;

  /* if we ticked from 59 seconds to 60, adjust time properly */
  if( (tmp &amp; 0x00f0) == 0x0060 ) tmp = tmp - 0x0060 + 0x0100;

  /* if we ticked from 9 minutes to 10, adjust time properly */
  if( (tmp &amp; 0x0f00) == 0x0a00 ) tmp = tmp - 0x0a00 + 0x1000;

  /* if we ticked from 59 minutes to 60, adjust time properly */
  if( (tmp &amp; 0xf000) == 0x6000 ) tmp = 0x0000;

  *timeloc = tmp;      /* update memory with new time value */
  delay(1000);
}


And it's in the tick file where the 1 second delay is. Can you think of a more correct way to achieve the result?","The standard approach to this is to track when was the last time a function was called and rerun it when enough time has passed.

#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;

#define SLEEP_INTERVAL 200

struct timeval last_pollkey_call, last_tick_call, now, diff;
memset(&amp;last_pollkey_call, 0, sizeof(last_pollkey_call));
memset(&amp;last_tick_call, 0, sizeof(last_pollkey_call));

while(1) {
    gettimeofday(&amp;now, NULL);

    timersub(&amp;now, &amp;last_pollkey_call, &amp;diff);
    if (diff.tv_sec &gt;= 1 || diff.tv_usec &gt;= 1000) {
        pollkey();
        last_pollkey_call = now;
    }

    timersub(&amp;now, &amp;last_tick_call, &amp;diff);
    if (diff.tv_sec &gt;= 1) {
        tick();
        last_tick_call = now;
    }

    usleep(SLEEP_INTERVAL);
}


You can have as many events with as many different intervals as you like.",,,,,
"Modelsim Warning: ""does not denote a port""","I am simulation the LEON3 with modelsim. After a make vsim I get a do-file I use for calling modelsim.
It gives me a warning message and I don't know if this message now is relevant. Actually I don't know what it means.

# ** Warning: [6] /path/to/lib/tech/ec/orca/orca.vhd(14744): (vcom-1288) VITAL timing generic ""tpd_a1_s2"" port specification ""s2"" does not denote a port.


The indicated code:

ENTITY fadsu2 IS
   GENERIC(
      TimingChecksOn : boolean := TRUE;
      XOn            : boolean := FALSE;
      MsgOn          : boolean := TRUE;
      InstancePath   : string := ""fadsu2"";
      tpd_a0_bco     : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_a1_bco     : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_b0_bco     : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_b1_bco     : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_bci_bco    : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_con_bco    : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_a0_s0      : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_a0_s1      : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_a1_s0      : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_a1_s1      : VitalDelayType01 := (0.001 ns, 0.001 ns);
     tpd_a1_s2      : VitalDelayType01 := (0.001 ns, 0.001 ns); -- &lt;--- here
      tpd_b0_s0      : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_b0_s1      : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_b1_s0      : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_b1_s1      : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_bci_s0     : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_bci_s1     : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_con_s0     : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tpd_con_s1     : VitalDelayType01 := (0.001 ns, 0.001 ns);
      tipd_a0        : VitalDelayType01 := (0.0 ns, 0.0 ns);
      tipd_a1        : VitalDelayType01 := (0.0 ns, 0.0 ns);
      tipd_b0        : VitalDelayType01 := (0.0 ns, 0.0 ns);
      tipd_b1        : VitalDelayType01 := (0.0 ns, 0.0 ns);
      tipd_bci       : VitalDelayType01 := (0.0 ns, 0.0 ns);
      tipd_con       : VitalDelayType01 := (0.0 ns, 0.0 ns));

   PORT(
      a0             :  IN    std_logic;
      a1             :  IN    std_logic;
      b0             :  IN    std_logic;
      b1             :  IN    std_logic;
      bci            :  IN    std_logic;
      con            :  IN    std_logic;
      bco            :  OUT   std_logic;
      s0             :  OUT   std_logic;
      s1             :  OUT   std_logic);

   ATTRIBUTE Vital_Level0 OF fadsu2 : ENTITY IS TRUE;

END fadsu2;


any sugestions?","I happened to have a copy of that source laying around.  Comment out the offending line mentioning tpd_a1_s2 and it will compile.

Without modification:

david_koontz@Macbook: ghdl -a fadsu2.vhdl  
fadsu2.vhdl:23:7:warning: 's2' is not a port name (in VITAL generic name)


Commenting out the offending generic:

david_koontz@Macbook: ghdl -a fadsu2.vhdl  
david_koontz@Macbook:


And it analyzes.  (I extracted the entity and architecture pair for fadsu2 from orca.vhd)

The issue is that you have a tpd value (time propagation delay) specified between input a1 and output s2 (tpd_a1_s2), where output port s2 is non-existent.  ",,,,,
Polling with C and assembly for Nios 2,"I want to call the pollkey function once per millisecond and increment the time variable (timeloc) once per second. I think that it should work if I add a call pollkey to the delay subroutine so why is it not working?

        .equ    delaycount,     16911 #set right delay value here!
        .text                   # Instructions follow
        .global delay           # Makes ""main"" globally known

delay:  beq     r4,r0,fin       # exit outer loop
        movi    r8,delaycount   # delay estimation for 1ms

inner:  beq     r8,r0,outer     # exit from inner loop
        subi    r8,r8,1         # decrement inner counter
        br      inner

outer:  subi    r4,r4,1         # decrement outer counter
        call    pollkey
        br      delay


fin:    ret


The above I ran with C that is

#include &lt;stdio.h&gt;
#include ""system.h""
#include ""altera_avalon_pio_regs.h""
extern void puttime(int* timeloc);
extern void puthex(int time);
extern void tick(int* timeloc);
extern void delay(int millisec);
extern int hexasc(int invalue);

#define TRUE 1
#define KEYS4 ( (unsigned int *) 0x840 )

int timeloc = 0x5957; /* startvalue given in hexadecimal/BCD-code */
int RUN = 1;

void pollkey() {
    int action = IORD_ALTERA_AVALON_PIO_DATA(DE2_PIO_KEYS4_BASE);
    if (action == 7) {
        timeloc = 0x0;
    } else if (action == 13) {
        RUN = 0;
    } else if (action == 14) {
        RUN = 1;
    } else if (action == 11) {
        tick(&amp;timeloc);
    }
}

int main() {
    while (TRUE) {
        puttime(&amp;timeloc);
        delay(1);
        IOWR_ALTERA_AVALON_PIO_DATA(DE2_PIO_REDLED18_BASE, timeloc);
        if (RUN == 1) {
            tick(&amp;timeloc);
            puthex(timeloc);
        }

    }
    return 0;
}

int hex7seg(int digit) {
    int trantab[] = { 0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00,
            0x10, 0x08, 0x03, 0x46, 0x21, 0x06, 0x0e };
    register int tmp = digit &amp; 0xf;
    return (trantab[tmp]);
}

void puthex(int inval) {
    unsigned int hexresult;
    hexresult = hex7seg(inval);
    hexresult = hexresult | (hex7seg(inval &gt;&gt; 4) &lt;&lt; 7);
    hexresult = hexresult | (hex7seg(inval &gt;&gt; 8) &lt;&lt; 14);
    hexresult = hexresult | (hex7seg(inval &gt;&gt; 12) &lt;&lt; 21);
    IOWR_ALTERA_AVALON_PIO_DATA(DE2_PIO_HEX_LOW28_BASE, hexresult);
}

int hex7seg2(int digit) {
    int trantab[] = { 0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00,
            0x10, 0x08, 0x03, 0x46, 0x21, 0x06, 0x0e };
    register int tmp = digit &amp; 0xf0;
    return (trantab[tmp]);
}


The polling works if it polls every second but I want to poll every millisecond and the only way I think I can do it is the call the pollkey from the dely subroutine but if I do that it's like nothing happens. Can you help me? I asked how to do it before and got an answer in C only while I think that the answer should be to change the assembly. 

How to develop this algorithm?

Update

I'm getting much better results using br instead of call so I must check the difference. This is what I'm using that works better:

        .equ    delaycount,     16911 #set right delay value here!
        .text                   # Instructions follow
        .global delay           # Makes ""delay"" globally known

delay:  beq     r4,r0,fin       # exit outer loop
        movi    r8,delaycount   # delay estimation for 1ms

inner:  beq     r8,r0,outer     # exit from inner loop
        subi    r8,r8,1         # decrement inner counter
        br      inner

outer:  subi    r4,r4,1         # decrement outer counter
        br      pollkey
        br      delay


fin:    ret


Now only problem is that the clock is ticking too fast.

Update

I think I solved it by introducing a counter that breaks modulo 1000 for seconds:

#include &lt;stdio.h&gt;
#include ""system.h""
#include ""altera_avalon_pio_regs.h""
extern void puttime(int* timeloc);
extern void puthex(int time);
extern void tick(int* timeloc);
extern void delay(int millisec);
extern int hexasc(int invalue);

#define TRUE 1
#define KEYS4 ( (unsigned int *) 0x840 )

int timeloc = 0x5957; /* startvalue given in hexadecimal/BCD-code */
int RUN = 0;

void pollkey() {
    int action = IORD_ALTERA_AVALON_PIO_DATA(DE2_PIO_KEYS4_BASE);
    if (action == 7) {
        timeloc = 0x0;
        puttime(&amp;timeloc);
        puthex(timeloc);
    } else if (action == 13) {
        RUN = 0;
    } else if (action == 14) {
        RUN = 1;
    } else if (action == 11) {
        tick(&amp;timeloc);
        puttime(&amp;timeloc);
        puthex(timeloc);
        delay(1000);
    }
}

int main() {
    int counter = 0;
    while (TRUE) {
        pollkey();
        delay(1);
        ++counter;
        if (counter % 1000 == 0) {
            IOWR_ALTERA_AVALON_PIO_DATA(DE2_PIO_REDLED18_BASE, timeloc);
            if (RUN == 1) {
                tick(&amp;timeloc);
                puttime(&amp;timeloc);
                puthex(timeloc);
            }
        }

    }
    return 0;
}

int hex7seg(int digit) {
    int trantab[] = { 0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00,
            0x10, 0x08, 0x03, 0x46, 0x21, 0x06, 0x0e };
    register int tmp = digit &amp; 0xf;
    return (trantab[tmp]);
}

void puthex(int inval) {
    unsigned int hexresult;
    hexresult = hex7seg(inval);
    hexresult = hexresult | (hex7seg(inval &gt;&gt; 4) &lt;&lt; 7);
    hexresult = hexresult | (hex7seg(inval &gt;&gt; 8) &lt;&lt; 14);
    hexresult = hexresult | (hex7seg(inval &gt;&gt; 12) &lt;&lt; 21);
    IOWR_ALTERA_AVALON_PIO_DATA(DE2_PIO_HEX_LOW28_BASE, hexresult);
}

int hex7seg2(int digit) {
    int trantab[] = { 0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78, 0x00,
            0x10, 0x08, 0x03, 0x46, 0x21, 0x06, 0x0e };
    register int tmp = digit &amp; 0xf0;
    return (trantab[tmp]);
}


        .equ    delaycount,     16911 #set right delay value here!
        .text                   # Instructions follow
        .global delay           # Makes ""delay"" globally known

delay:  beq     r4,r0,fin       # exit outer loop
        movi    r8,delaycount   # delay estimation for 1ms

inner:  beq     r8,r0,outer     # exit from inner loop
        subi    r8,r8,1         # decrement inner counter
        br      inner

outer:  subi    r4,r4,1         # decrement outer counter
        br      delay


fin:    ret
","The right way  to run routines in an embedded system on particular timescales is to use a hardware timer and put the action (assuming it is relatively small!) into the interrupt service routine for that timer, or use that function to tell longer routines to run in the background loop.

Bodging the delay() function is going to result in


variable delays - the delay function is already an approximation using instruction cycles, and if you run off to call another function in the middle sometimes it'll only get worse
inaccurate 1ms polling - the level of inaccuracy may or may not be good enough for your purposes.


Once you have a 1ms timer, you can run the pollkey function from it and also schedule longer events accurately too.

Of course at that point you've started to build an RTOS, so you might want to use one anyway :)",,,,,
How to enable the instantiated modules in sequence in verilog,"I have different modules instantiated in one single module. I want to execute them in sequence, I have enable and acknowledgement signals of all modules how can I do this?

Following is the code:

module memorycontroller(
    input  [7:0] A,
    input  [7:0] B,
    input  [1:0] adrress,
    input        clk,
    output [7:0] A_mem,
    output [7:0] B_mem
);
    reg          LMwrEnable, localmemEnable;
    integer      LMwrack,    localmemack;
    reg    [7:0] A1, B1;

    initial
    begin
      LMwrEnable     = 1;
      localmemEnable = 0;
    end

    memorywrite LMwr (
      .clk     ( clk        ), 
      .A       ( A          ), 
      .B       ( B          ), 
      .adr     ( adrress    ),
      .enable  ( LMwrEnable ),
      .ack     ( LMwrack    )
    );

    bram_tdp localmem (
      .a_clk   ( clk            ), 
      .a_wr    ( 1'b0           ), 
      .a_addr  ( adrress        ), 
      .a_din   ( A1             ), 
      .a_dout  ( A_mem          ), 
      .b_clk   ( clk            ), 
      .b_wr    ( 1'b0           ), 
      .b_addr  ( adrress+1'b1   ), 
      .b_din   ( B1             ), 
      .b_dout  ( B_mem          ),
      .enable  ( localmemEnable ),
      .ack     ( localmemack    )
    );

     always@(posedge clk)
     begin
       if(LMwrack)
         localmemEnable = 1;
     end


endmodule


In initial statement I've enabled only LMwr module in initial block and on its ack signal I have enabled localmem module in always block but this is giving me wrong result. Can you tell me how to execute different modules in sequence?

Following is the memorywrite module

module memorywrite(
    input clk,
    input [7:0] A,
    input [7:0] B,
    input [1:0] adr,
     input enable,
     output ack
    );
     wire [7:0] C,C1;

 bram_tdp localmem (
    .a_clk(clk), 
    .a_wr(1'b1), 
    .a_addr(adr), 
    .a_din(A), 
    .a_dout(C), 
    .b_clk(clk), 
    .b_wr(1'b1), 
    .b_addr(adr+1'b1), 
    .b_din(B), 
    .b_dout(C1),
     .enable(enable),
     .ack(ack)
    );

endmodule


This above code writes to the memory.

Following is the actual memory module which is being written by 2nd code stated above and read by 1st code stated above

module bram_tdp #(
    parameter DATA = 8,
    parameter ADDR = 2
) (
     input enable,
     output ack,
    // Port A
    input   wire                a_clk,
    input   wire                a_wr,
    input   wire    [ADDR-1:0]  a_addr,
    input   wire    [DATA-1:0]  a_din,
    output  reg     [DATA-1:0]  a_dout,

    // Port B
    input   wire                b_clk,
    input   wire                b_wr,
    input   wire    [ADDR-1:0]  b_addr,
    input   wire    [DATA-1:0]  b_din,
    output  reg     [DATA-1:0]  b_dout
);

// Shared memory
reg [DATA-1:0] mem [(2**ADDR)-1:0];

// Port A
always @(posedge a_clk) begin
if(enable) begin
    a_dout      &lt;= mem[a_addr];
    if(a_wr) begin
        a_dout      &lt;= a_din;
        mem[a_addr] &lt;= a_din;
    end
    end
end

// Port B
always @(posedge b_clk) begin
if(enable) begin
    b_dout      &lt;= mem[b_addr];
    if(b_wr) begin
        b_dout      &lt;= b_din;
        mem[b_addr] &lt;= b_din;
    end

    end
end
assign ack=1;
endmodule


Here is testbench:

module mmTesting;

    // Inputs
    reg [7:0] A;
    reg [7:0] B;
    reg [1:0] adrress;
    reg clk;

    // Outputs
    wire [7:0] A_mem;
    wire [7:0] B_mem;

    // Instantiate the Unit Under Test (UUT)
    memorycontroller uut (
        .A(A), 
        .B(B), 
        .adrress(adrress), 
        .clk(clk), 
        .A_mem(A_mem), 
        .B_mem(B_mem)
    );

    initial begin
        // Initialize Inputs
        A = 0;
        B = 0;
        adrress = 0;
        clk = 0;

        // Wait 100 ns for global reset to finish
        #100;
      A = 5;
        B = 5;
        adrress = 0;

      #100 A = 6;
        B = 2;
        adrress = 1;


        // Add stimulus here

    end
     always #5 clk=!clk; 
endmodule


Result should be same as what I am writing to the memory.","Just to clarify that Verilog is a hardware description and that both instantiations (not modules, as an uninstantiated module does not exist) can be executed and exist in parallel, unlike the C equivalent which would execute one then the other.

If you have instance A and B, you just need a FSM (Finite State Machine) to enable A wait for its completion signal, then disabling A enable B, waiting for B to complete and repeat. 

NB: if the commented out code is not relevant to the question can it be removed, it is good practise to reduce your question to the minimum amount of code required to reproduce the problem.",,,,,
Shifting a Concatenate Register,"Ive been doing verilog HDL in quartus II for 2 month now and have not synthesized any of my codes yet. I am struggling to code a fractional division circuit. Of course theres a lot of problems...

I would like to know how do I concatenate two registers to form a larger register that I can shift to the right where the shifting of the data would occur at every positive edge of the clock pulse... The data in the newly created register has 3 zeros (MSB) followed by 4 data bits from another register called divider.
For example B=[0 0 0]:[1 0 1 0]

I have tried the following

module FRACDIV (divider,clk,B,START,CLR);

input       [3:0]  divider;
input           START, CLR, clk;
output      [6:0] B;

    reg [6:0]       B;


always @ (posedge clk)
    begin
        B = {3'd0, divider};
            if (START == 1'b1)
        begin
        B=B+B&lt;&lt;1;
        end
    end

endmodule


Any help would be deeply appreciated as I've been trying to figure this out for 5 hours now...



Mr. Morgan,

Thank you for the tips. The non-blocking statement did help. However the code would not shift perhaps because B is always reinitialized at every clock pulse as it is outside the if statement.

With a fresh new day and a fresh mind and owing to your suggestion using the non-blocking statement I tried this...

module FRACDIV(divider,clk,B,START,CLR);
input       [3:0] divider;
input           START, CLR, clk;
output      [6:0] B;

    reg [6:0] B;

    always @ (posedge clk) 
    begin
      if (START) begin
        B &lt;= {3'b0, divider};
      end
      else begin
         B &lt;= B &lt;&lt;1;
      end
    end
endmodule


The if statement loads data into B whenever START is HIGH. When START is LOW, the data shifts at every positive edge of the clock. Is there anyway to make the data in B to start shifting right after loading it with the concatenated data without the if statement? 

Just curious and I still do not feel this code is the most efficient.","When implying flip-flops it is recommended to use &lt;= non-blocking assignments.

When declaring outputs you should also be able to delcare it as a reg, unless you are stuck using a strict verilog-95 syntax.

module FRACDIV (
  input       [3:0] divider,
  input             START, CLR, clk,
  output reg  [6:0] B
);

always @ (posedge clk) begin 
  B &lt;= {3'd0, divider};
  if (START == 1'b1) begin 
    B&lt;=B+B&lt;&lt;1;  //This will overide the previous statement when using `&lt;=`
  end 
end
endmodule


This will simulate in the same way that your synthesised code will perform on the FPGA.",,,,,
writing a ripple carry adder in verilog,"I'm attempting to write a ripple carry adder in verilog.

module half_adder(a,b,sum,carry);
   input a,b;
   output sum,carry;
   assign sum=a^b;
   assign carry=a&amp;b;
endmodule


module full_adder(a,b,cin,sum,cout);
   input a,b,cin;
   output sum,cout;
   wire   t1,t2;
   half_adder h(a,b,t1,t2);
   assign cout=t1&amp;cin;
   assign sum=t1^cin;
   assign cout=t2|cout;
endmodule // full_adder

module ripple_carry_adder(input1,input2,answer);
   input [31:0] input1,input2;
   output [31:0] answer;
   integer       carry,t;
   genvar        i;
   initial begin
     assign carry=1'b0;
   end

   for(i=0;i&lt;=31;i=i+1)
     begin
        full_adder f(input1[i],input2[i],carry,answer[i],t);
        assign carry=t;
     end
endmodule


however when i compile using the iverilog simulator, the following error log shows up(repetitive errors removed) :

   ripple_carry_adder.v:28: warning: Couldn't build unique name for unnamed generate block - using internal name $gen1
    ripple_carry_adder.v:30: warning: Port 3 (cin) of full_adder expects 1 bits, got 32.
    ripple_carry_adder.v:30:        : Pruning (signed) 31 high bits of the expression.
    ripple_carry_adder.v:30: error: reg t; cannot be driven by primitives or continuous assignment.
    ripple_carry_adder.v:30: error: Output port expression must support continuous assignment.
    ripple_carry_adder.v:30:      : Port cout of full_adder is connected to t
    ripple_carry_adder.v:31: error: reg carry; cannot be driven by primitives or continuous assignment.
    ripple_carry_adder.v:28: warning: Couldn't build unique name for unnamed generate block - using internal name $gen1
    ripple_carry_adder.v:30: warning: Port 3 (cin) of full_adder expects 1 bits, got 32.
    ripple_carry_adder.v:30:        : Pruning (signed) 31 high bits of the expression.
    ripple_carry_adder.v:30: error: reg t; cannot be driven by primitives or continuous assignment.
    ripple_carry_adder.v:30: error: Output port expression must support continuous assignment.
    ripple_carry_adder.v:30:      : Port cout of full_adder is connected to t
    ripple_carry_adder.v:31: error: reg carry; cannot be driven by primitives or continuous assignment.


Where am I going wrong?

EDIT: Using the generate statement now.Still have doubt about the type of carry. 

module ripple_carry_adder(input1,input2,answer);
   input [31:0] input1,input2;
   output [31:0] answer;
   wire          carry;
   wire          t;

   initial begin
     carry=1'b0;
   end
   genvar        i;
   generate for(i=0;i&lt;=31;i=i+1)
     begin
        full_adder f(input1[i],input2[i],carry,answer[i],t);
        carry=t;
     end endgenerate
endmodule
","You should get rid of the initial block. You can drop t. Then using an generate block:

   wire [31:0] carry;
   genvar i;
   full_adder f(input1[0],input2[0],1'b0,answer[0],carry[0]);
   generate // optional in IEEE std 1364-2005 and IEEE std 1800
   for(i=1;i&lt;=31;i=i+1)
     begin
        full_adder f(input1[i],input2[i],carry[i-1],answer[i],carry[i]);
        //assign carry=t;
     end
   endgenerate
endmodule


Alternatively, something that worked with the old 1364-1995 style:

full_adder f[31:0](input1[31:0],input2[31:0],{carry[30:0],1'b0},answer[31:0],carry[31:0]);
",,,,,
Can't compile my system in Qsys,"When trying to assemble the system according to the instructions in this document
http://www.cs.columbia.edu/~sedwards/classes/2013/4840/lab3.pdf
I get this error message:

Error: System.nios2_qsys_0: Reset slave sram_0.avalon_slave_0 not connected to instruction_master.
Error: System.nios2_qsys_0: Exception slave sram_0.avalon_slave_0 not connected to instruction_master.
Error: System.sram.avalon_slave_0: Interface must have an associated clock
Error: System.sram.avalon_slave_0: Interface must have an associated reset
Error: System.leds.avalon_slave_0: Interface must have an associated reset
Error: System.nios2_qsys_0.data_master: leds.avalon_slave_0 (0x0..0x3f) overlaps jtag_uart_0.avalon_jtag_slave (0x0..0x7)
Error: System.nios2_qsys_0.instruction_master: leds.avalon_slave_0 (0x0..0x3f) overlaps jtag_uart_0.avalon_jtag_slave (0x0..0x7)
Error: System.sram.avalon_slave_0: sram.avalon_slave_0 must declare an associated reset
Error: System.leds.avalon_slave_0: leds.avalon_slave_0 must declare an associated reset
Warning: System.leds.reset: Interface has no signals
Warning: System.sram: sram.conduit_end must be exported, or connected to a matching conduit.
Warning: System.leds: leds.conduit_end must be exported, or connected to a matching conduit.
Warning: System.jtag_uart_0: Interrupt sender jtag_uart_0.irq is not connected to an interrupt receiver


Can you tell me what is wrong? 

","Since the document uses SOPC Builder, you would need to make certain changes so that it works with QSys without errors.

I have listed the fixes for the errors in your question below:


Error: System.nios2_qsys_0: Reset slave sram_0.avalon_slave_0 not connected to instruction_master.

Error: System.nios2_qsys_0: Exception slave sram_0.avalon_slave_0
not connected to instruction_master.

Fix: Connect avalon_slave_0 of the sram to the instruction_master of the nios2_qsys processor.
Error: System.sram.avalon_slave_0: Interface must have an associated clock

Error: System.sram.avalon_slave_0: Interface must have an associated reset

Fix: Edit the de2_sram_controller.vhd file and add the following lines to the signal declarations:

signal clk: in std_logic;

signal reset_n: in std_logic;

Then, edit the sram component you created in QSys and add the clk and reset_n signals.
Error: System.nios2_qsys_0.data_master: leds.avalon_slave_0 (0x0..0x3f) overlaps jtag_uart_0.avalon_jtag_slave (0x0..0x7)

Error: System.nios2_qsys_0.instruction_master: leds.avalon_slave_0 (0x0..0x3f) overlaps jtag_uart_0.avalon_jtag_slave (0x0..0x7) 

Fix: In the QSys window, go to System --> Assign Base Addresses.
Error: System.leds.avalon_slave_0: Interface must have an associated reset 

Error: System.sram.avalon_slave_0: sram.avalon_slave_0 must declare an associated reset 

Error: System.leds.avalon_slave_0: leds.avalon_slave_0 must
declare an associated reset

Fix: Edit the sram and led components. Under the Interfaces tab make sure Associated Reset has a reset signal (shown in the image below).





Warning: System.leds.reset: Interface has no signals

Fix: Edit the led component. Under the Interfaces tab, towards the bottom, click Remove Interfaces With No Signals.
Warning: System.sram: sram.conduit_end must be exported, or connected to a matching conduit.

Warning: System.leds: leds.conduit_end must be exported, or connected to a matching conduit.

Fix: In the QSys window, for both the sram and led components, under the Export column, ensure you Double-click to export.
Warning: System.jtag_uart_0: Interrupt sender jtag_uart_0.irq is not connected to an interrupt receiver

Fix: Ensure that the avalon_jtag_slave of the jtag_uart_0 is connected to IRQ 31. Refer to the image below and double-click the white circle connecting the jtag_uart_0 to IRQ 31.




I hope this helps.",,,,,
Creating a cache memory benchmark in VHDL,"I have a working VHDL design for Data&amp;Instruction Caches. I want to evaluate it (find miss rates and so) with a testbench.

So I want to know how to create random requests to the caches? and how to make them favor some type of locality or have a pattern (like sequential access but with occasional random jumps in a program for example)?

In other words, how to make a VHDL Benchmark to evaluate the cache designs in different conditions and memory access patterns?","Think about the types of cache patterns you would like to see, and you should be able to code them fairly easily in your testbench using IEEE.MATH_REAL.uniform.

To take your example of sequential access with occasional random jumps:

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;
use IEEE.MATH_REAL.all;

entity ...

architecture ...
    signal cache_read : std_logic := '0';
    signal cache_addr : unsigned(31 downto 0) := (others=&gt;'0');

    ...
begin
    sequential_and_jumps: process
            variable seed1, seed2 : positive := 42;
            variable rand         : real;
            variable loops        : integer;
            variable addr         : integer;
    begin
        cache_read &lt;= '0';
        wait until reset='0' and rising_edge(clk);

        -- Starting address.
        addr := 0;

        -- Continual repeated accesses.
        loop
            -- Randomly jump to a new address between 0x0 and 0x10000
            -- with a chance of 10%.
            uniform(seed1, seed2, rand);
            if(rand &lt; 0.1) then
                uniform(seed1, seed2, rand);
                addr := integer(trunc(rand * real(16#10000#)));
            end if;

            -- Wait 0-15 cycles prior to the cache request.
            uniform(seed1, seed2, rand);
            loops := integer(trunc(rand*16.0));
            for i in 1 to loops loop
                wait until rising_edge(clk);
            end loop;

            -- Randomly request 1-32 words.
            uniform(seed1, seed2, rand);
            loops := integer(trunc(rand*32.0)) + 1;
            for i in 1 to loops loop
                cache_addr &lt;= to_unsigned(addr, cache_addr'length);
                cache_read &lt;= '1';
                wait until rising_edge(clk);
                cache_read &lt;= '0';
                -- Assumes word addresses.
                -- For byte addresses, increment by e.g. 4 for 32-bit words.
                addr := addr + 1;
            end loop;
        end loop;
    end process;
end architecture;


Other access patterns can be achieved in a similar manner.",,,,,
how to define a multi line macro in verilog?,"I am relatively new to verilog (a VHDL user), and in order to improve my skills i built my test environment using verilog (my QC use their own env).

In my env, I emulate a master that force random stimuli on the lines (i2c master).

since i didn't really want to use a real master and wanted only a 'well behaved' master, i created the following macros to provide me with the i2c communications:   

`define writeChipId(addr)\
sda = 1\
#7500 sda = addr[3];\
#2500 sda = addr[2];\
#2500 sda = addr[1];\
#2500 sda = addr[0];\
#2500;

`define writeData(data)\
sda = data[7]\
#2500 sda = data[6];\
#2500 sda = data[5];\
#2500 sda = data[4];\
#2500 sda = data[3];\
#2500 sda = data[2];\
#2500 sda = data[1];\
#2500 sda = data[0];\
#2500 sda = 1;\
#2500; // time for the slave to answer

`define readData\
#sda = 1\
#20000 sda = 0;\
#2500; // master always answer ACK


my problem is that, when i try to use these macros i get a compilation errors (using modelsim) saying i have a syntax error and i have unexpected '[' that should be ';' for using the chipID macro and having unexpected '#' that should be ';' when using the read\ write macros.

the usages i try (and fail) are

`writeChipId(`chipID)  


and  

`writeData(rndData)   


and   

 `readData


last, but not least: if i write the same lines without the macro in my code, it compiles perfectly (only tried in one place, don't want to do it for the 12 other places i'll need these macros...)

anyone have a clue what is the problem? i've been trying to play with the macros with no luck and also verified they have no white spaces stuck in the middle.
also looked for multi-line macro examples and found similar things to what I did that didn't give an answer.  

thanks in advance to all repliers

edit
something i forgot saying: when i take the macro and remove the input and use const values instead of the input, it works fine.","ok, solution found:
the first line of each macro should also have semicolon (;), also - the use of parameter for the chipID is hard on the verilog, this was solved by putting the input into a reg and using the reg's bits.

i didn't come across this problem the previous time I used macros because of another mistake I made - I defined the macro of the constant to have semicolon (meaning `define ADD 32'h0;) and when I used it it inserted the ; to the line and seemed OK.",,,,,
Driving GPIO pins shared with SRAM in VHDL,"I've bought a Spartan 3A development board from Micronova (http://micro-nova.com/mercury) and I've got some problems interfacing with its SRAM.
This board has 30 GPIO pins that are shared with Cypress SRAM and two pins to switch between them.
Obviously, connecting two VHDL modules (one for controlling SRAM and the other to drive GPIO) to the same pin leads to &quot;Multiple driver error&quot; when synthetizing.
So, to solve the problem I've created a third module as a middle controller that connects both modules with another variable for choosing which one to operate.
This works well for output, but when it comes to read input I always get 1, independently of the real value.
I don't know which pins will be used as input and which ones are for output because I would like an independent module that I can use for other projects.
This is what I got so far:
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity DMA2 is
    Port (
        IOphys      : inout STD_LOGIC_VECTOR (29 downto 0);
        IOin1       : out STD_LOGIC_VECTOR (29 downto 0);
        IOin2       : out STD_LOGIC_VECTOR (29 downto 0);
        IOout1      : in STD_LOGIC_VECTOR (29 downto 0);
        IOout2      : in STD_LOGIC_VECTOR (29 downto 0);
        SwitchEn2   : in STD_LOGIC
    );
end DMA2;

architecture Behavioral of DMA2 is

begin

IOin2 &lt;= IOphys;
IOin1 &lt;= IOphys;
IOphys &lt;= IOout2 when SwitchEn2 = '1' else IOout1;

end Behavioral;

IOphys are the physical pins on the board, SwitchEn2 is for choosing the driving module and the others are the inputs and outputs of the modules.","You don't seem to be driving your outputs. As a starter, how about defining a tristate driver like so



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity tristate is
port (
   signal data_in         : out   std_logic;
   signal data_out        : in    std_logic;
   signal data_tristate   : inout std_logic;
   signal tristate_select : in    std_logic
);

architecture rtl of tristate is
begin

   data_in &lt;= data_tristate;
   data_tristate &lt;= 'z' when tristate_select = '1' else data_out;

end architecture;


Then selecting between its use like so

entity arbitrate_bus
port(
   -- the pins
   IOphys        : inout STD_LOGIC_VECTOR (29 downto 0);
   IOin1         : out STD_LOGIC_VECTOR (29 downto 0);
   IOout1        : in STD_LOGIC_VECTOR (29 downto 0);
   IO_direction1 : in STD_LOGIC_VECTOR (29 downto 0);
   IOin2         : out STD_LOGIC_VECTOR (29 downto 0);
   IOout2        : in STD_LOGIC_VECTOR (29 downto 0);
   IO_direction2 : in STD_LOGIC_VECTOR (29 downto 0);
   SwitchEn2     : in STD_LOGIC
);

architecture like_this of arbitrate_bus is
  signal input : STD_LOGIC_VECTOR (29 downto 0);
  signal output_selected : STD_LOGIC_VECTOR (29 downto 0);
  signal direction_selected  : STD_LOGIC_VECTOR (29 downto 0);
begin

    output_selected    &lt;= IOout1 when SwitchEn2 = '0' else IOout2;
    direction_selected &lt;= IO_direction1 when SwitchEn2 = '0' else IO_direction2;

    g_ts: for g in output_selected'range generate
    begin
       u_ts: entity tristate
       port map(
          data_in         =&gt; input(g),
          data_out        =&gt; output_selected(g),
          data_tristate   =&gt; IOphys(g),
          tristate_select =&gt; direction_selected(g)
      );
    end generate;

    IOin1 &lt;= input;
    IOin2 &lt;= input;

end architecture;
",,,,,
VHDL initialize variable to multiple values,"In VHDL is it possible to sequentially assign values to a variable of type INTEGER? For example, I have a behavior file that has a matrix that loads value from a variable called DIN of type INTEGER. In the testbench I would think I need to assign values that DIN can have in which case I would need 8x8 values. How can I do so when my only inputs are DIN, CLK, and START?","I am assuming that the question can be interpreted as: ""given a 2D array of  integers, how can I initialize it one value at a time?""

If this is the case, here's a possible solution:


you will need two internal signals of integer type to index the array elements (say current_row and current_column)
you will need a reset signal to put your registers in a known state upon initialization (current_row, current_column, and your matrix elements should be set to 0 when reset is asserted)
on every clock pulse, assign the value from d_in to an element in your matrix: matrix(current_row, current_column) &lt;= d_in
on every clock pulse, update current_row and current_column so that they cycle through the entire matrix in the correct order


The implementation details are left to the reader, but this should be enough to get you started.  ",,,,,
Is the use of records the solution to all latch problems in VHDL,"I was recently told that the solution to all (most) problems with unintended latches during VHDL synthesis is to put whatever the problematic signal is in a record.

This seems like it's a little bit too good to be true, but I'm not that experienced with VHDL so there could be something else that I'm not considering.

Should I put all my signals in records?","No, you should not put all your signals in records. This will quickly become very confusing and you will not gain anything by using the record.

One way that a record may help you avoid latches, is if you register an entire record in a clocked process, you are really registering all of the components of the record. This takes one line of code, instead of possibly tens of lines.  In the case where you have many elements which all need to be treated the same, a record can save you ""silly mistakes"", and possibly save you from creating a latch.

As stated by others, a record doesn't have any specific synthesis interpretation. It is simply a group of signals that you are grouping together for coding-convenience.",,,,,
Subtleties of Non Blocking Assignments,"Here in this example,a non-blocking assignment propagates to a continuous assignment. Can this cause any execution paradigms.Please elaborate on this piece of code- Possible errors, How can it be removed and good style of coding. 

  always @(posedge clk)
        dff1 &lt;= f(x);

    assign fsm_in = f(dff1);
    assign fsm_out = fsm_state;

    always @(fsm_in)
        fsm_state &lt;= g(fsm_in);
","Your code is fine, though I agree with Greg that it's better style to use blocking assignments in the combinatorial process.

On your comments:

In very simplified terms, the scheduler contains 5 queues (SV has 17), but
you're only interested in 2 of them: the active event queue, and the
nonblocking assignment update queue. In a given simulation cycle, the
simulator processes the active event queue, and then the nonblocking update
queue. In general, this will create more events, and the simulator cycles
around the queues in a pre-determined order until there are no more events at
this simulation time. The simulator then moves on to the next time at which an
event is scheduled (at the next clock edge, for example).

Assume that 4 things happen 'at once': there is a change in fsm_state, there
is a change in f(x), and both your NBA assignments are executed. As far as
the simulator is concerned, these 4 statements are executed in the same
simulation cycle, but in an undefined order. The definition of 'at once' is
rather complex, but assume that they all happen as a result of a clock edge,
with no ordering dependencies between the statements. The simulator is usually
single-threaded, so it will actually execute the 4 statements at different
real times, but it knows that all 4 are expected to happen at the same
simulation time.

The changes on fsm_state and f(dff1) are update events, and are added to
the scheduler's active event queue.

The RHS of the two NBAs are immediately evaluated, and the LHS updates are
added to the nonblocking assignment update queue.

The simulator now sees a queue with 4 events on it. It executes the two active
events first, in an undefined order, so fsm_in and fsm_out get their new
values. If there are no more active events, it then executes the two
non-blocking updates, in an undefined order, so dff1 and fsm_state now get
their new values.

In your case, the simulation cycle isn't finished, because the change on
fsm_in is also an update event, and this triggers the evaluation/execution
of the always block which is sensitive to fsm_in. This is an evaluation
event. The sim executes the always block, immediately reads the new value of
fsm_in, and adds the update of fsm_state to the NBA assignment update
queue. If there are no active events, the assignment is then acted on, and
fsm_state gets it's new value.

This goes on until there are no more events in this simulation cycle, and the
simulator then advances time, if something is scheduled in the future.

You could get all this from section 5 of the Verilog LRM, but it doesn't make
much sense. All the language was grafted on late in the standardisation
process and uses (VHDL) terminology that's not used elsewhere in the LRM. It
was also all added in such a way as to match the behaviour of Verilog-XL, and
specifically to document the non-determinism specific to XL, so don't expect
too much from it. NBAs weren't even added to the language till 1992, I
think. Don't bother with the SV LRM; there are many more queues, and the
common text has changed, just adding another level of confusion.

Cliff Cummings has a simplified description in one of his papers (on
non-blocking assignments), but read it with care. I'm pretty sure that the
description of the active event queue is incorrect (for RHS evaluation of
NBAs). If he was right, it would cause all sorts of problems; he presumably
got the description from an early version of the LRM.

Much the best thing to do is to look up any text on VHDL delta cycles. These
are easy to understand, and they work, and always have done, and they have
crept into Verilog over the years. The details are different, but you don't
need to know anything more than you'll find in delta cycles.",,,,,
SV assertion based on event trigger,"Assume SV interface contains a concurrent assertion property. 
Is it possible to enable this assertion only when an event is triggered? I tried writing property inside a task in interface file, but I ended up with error: near ""property"": syntax error, unexpected property. 

Interface intf;

   task e1();
        -&gt; e1; 
   endtask

   wait(e1.triggered); // something like this, where property waits for trigger 
   property prop1;
     @(posedge clk) a ##1 b;
   endproperty

endinterface


Thank you.","I think you need to consider that properties are best written synchronously and are evaluated on every clock cycle. You property says that one cycle after every clock cycle where a occurs b occurs. I guess what you're after is something like:


  if e1 occurs, then a should be true (on the next rising edge of
  clk?) and then b should be true on the rising edge of clk after
  that


So, one way of doing that would be to create an always block that generates a pulse one clock wide should e1 occur, eg:

always begin
  @(e1);
  @(posedge clk) e = 1'b1;
  @(posedge clk) e = 1'b0;
end

property prop1;
 @(posedge clk) e |-&gt; a ##1 b;
endproperty


or some variation of that. I feel like I should be worried about races, however.",,,,,
Verilog: Implementation Using Primitive Modules vs. Bit-wise Operators,"The textbook I'm reading implements 1-bit adders using built-in primitive modules:

module yAdder1(z, cout, a, b, cin);
     output[0:0] z, cout;
     input[0:0] a, b, cin;
     wire[0:0] tmp, outL, outR;

     xor left_xor(tmp, a, b);
     xor right_xor(z, cin, tmp);
     and left_and(outL, a, b);
     and right_and(outR, tmp, cin);
     or my_or(cout, outR, outL);
endmodule


But why not use bit-wise operators? Seems simpler.

module yAdder1(z, cout, a, b, cin);
     output[0:0] z, cout;
     input[0:0] a, b, cin;

     assign z = (a ^ b) ^ cin;
     assign cout = (a &amp; b) | ((a ^ b) &amp; cin);
endmodule


Unless bit-wise operators implicitly use  primitive modules?","builtin primitives are a convenient way to express gates in gate-level models. Usually they are generated by other tools. Other than that there is no much reason for using them in the regular verilog.

There are probably few of them which you can run across, mostly a variety of tristate buffers which could be used for driving buses. But all others are not that used as much.

And no they are not use implicitly in simulation. ",,,,,
What is the purpose of this module?,"module InoutConnect(
                .X1(internal), 
                .X2(internal)
                );


   parameter width = 1;

   inout [ width - 1 : 0 ] internal;
endmodule // InoutConnect


In the above code what is the format used,
I know that while instantiating the module .x1 is use to match the variable name but what about module definition.
What does it mean here?","it is called explicit port declaration, meaning that the external world will know this port by its explicit names, X1 and X2 in your case, though internally the same port will be known as internal in your case.

So, in your example you connect both ports to the same internal variable (looks bad to me :)) Though, this is one of the possible uses, in particular if you need to identical output ports. The other example is remapping internal structs or arrays to multiple potrts:

module m(
   output .arr1(array[2:0]),
   output .arr2(array[7:3]),
   input logic [7:0] input_array
)
   logic [7:0] array;
   ...
   always_ff @(posedge clk)
       array &lt;= input_array;
   ...
endmodule


So, above you can use your array as the whole internally, but it will have a different representation in the external world.

See 23.2.2.2 ANSI style list of port declarations for more info.",,,,,
SystemVerilog - With an enum can you have a range?,"With a typedef enum can you have a range for un-assigned values? For example:

typedef bit [3:0] enum {BLUE = 4'h0, RED = 4'h1, OTHERS = 4'h2 to 4'hF};


Or something similar? What will happen if a user chooses a value that is unassigned also?","Enums in System-Verilog can have out of range values. This is particularly useful when describing FSMs using enums if you choose a four-state type as the base type, eg:

//           a four-state base type (with default value 3'bxxx)
//               |
//               |      the base value of IDLE will be 3'b000
//               |        |
//               V        V
typedef enum logic[2:0] {IDLE, GO1, GO2} state_type;
state_type state;


The default type of logic is x, so by default the variable state above will have the value 3'bxxx. Therefore, by using a four-state base type, we can model an uninitialised state, which checks that the FSM has been reset properly.

So, you ask ""What will happen if an user choose a value that is unassigned also?"" The variable will have that value and, as in Serge's case example, in will not be equal to any of the defined enumeration values.",,,,,
Alternate signals for test bench without manually typing out all times in iverilog,"I am writing a test bench that I want to be able to have signals go high and low in a certain pattern (something like this):
Currently I manually type out what I want each time to be like this:

module TestExample;
reg a, b, c;

initial begin
    $dumpfile(""test.vcd"");
    $dumpvars(0, TestExample);

    # 0 a=0; b=0; c=0;
    # 10 a=1; b=0; c=0;
    # 20 a=0; b=1; c=0;
    # 30 a=1; b=1; c=0;
    # 40 a=0; b=0; c=1;
    # 50 a=1; b=0; c=1;
    # 60 a=0; b=1; c=1;
    # 70 a=1; b=1; c=1;
    # 80 a=0; b=0; c=0;

    # 90 $stop;
end
endmodule


The problem with this is when I get more signals (lets say a-z instead of a-b) it will take a really long time to manually type out each time and the associated value.  Because of this I am wondering if there is a way I can automate the signals.  For example if I could say switch your state every 10 u-seconds for a, every 20 u-seconds for b, and every 30 u-seconds for c?","As Greg says...

module TestExample;
wire a, b, c, d ...
integer i;

initial begin
    $dumpfile(""test.vcd"");
    $dumpvars(0, TestExample);
    for (i = 0; i &lt; 1&lt;&lt;26; i=i+1)
        #10;
    $stop;
end

assign a = i[0], b = i[1], c = i[2], d = i[3] ... 

endmodule
",,,,,
How to create VHDL package with component and no package body?,"In Quartus 16.0, I have a foo.vhd and bar.vhd files, each containing a valid/working entity and corresponding architecture. I am trying to create a package with foo and bar in it. I have something like this:

library ieee;
use ieee.std_logic_1164.all;

package my_package is

    component foo
            port(
                a, b : in  std_logic;
                out : out std_logic);
    end component;

    component bar
            port(
                a, b : in  std_logic;
                out : out std_logic);
    end component;

end package my_package;


Trying to compile it, I receive the error: Error (12007): Top-level design entity ""my_package"" is undefined. I am not sure where the problem is and as a beginner don't yet know how to go about debugging it.","You are actually using a package as the top level of your design. Those two things are different. A package stores useful constants, functions, etc... whereas the top level (which is an entity) instantiates and map components between each other. Take a look at this link to see how to implement a top level entity : 

https://www.altera.com/support/support-resources/design-examples/design-software/vhdl/v_hier.html

In VHDL you don't need to add your entity (or component) in a package. You just need to compile them in the same library - usually WORK.

When compiling your top level entity, which instantiate all the components your design need, Quartus looks for the vhdl file containing the entity called by the instantiation. ",,,,,
VHDL ERROR : Can't resolve multiple constant drivers for net... : for loop,"I have a little problem with this vhdl code, it says that: 


  Error (10028): Can't resolve multiple constant drivers for net
  ""leds[25]"" at pong_game.vhd(1049) ... 


Here is a part of my code : 

architecture led_matrix of pong_game is 

...

type etat is 
(led1,led2,led3,led4,led5,led6_1,led7_1_g,led7_1_d,led8_1_g,led8_1_d,led9_1_g 
...)

signal etat_present, etat_futur : etat;

...

affichage_sequence : process(etat_present)
begin
case etat_present is
when led1 =&gt;
    for i in 1 to 30 loop
        if i = 1 then
            leds(i)&lt;='1';
        else
            leds(i)&lt;='0';
        end if;
    end loop;
when led2 =&gt;
    for i in 1 to 30 loop
        if i = 2 then
            leds(i)&lt;='1';
        else
            leds(i)&lt;='0';
        end if;
    end loop;
when led3
...

end case ;

end process affichage_sequence ;

end architecture led_matrix;


Is there a better way to perform these operations? ","Maybe it could be really simple, but what is happening with your states?

[...]led5,led6_1,led7_1_g,led7_1_d[...]


All kind of weird names. What are you trying to achieve?

As for the process:

begin
    case etat_present is
        when led1 =&gt;
            leds &lt;= (1 &lt;= '1', others =&gt; '0');
        when led2 =&gt;
            leds &lt;= (2 &lt;= '1', others =&gt; '0');
    [...]


or

begin
    case etat_present is
        when led1 =&gt;
            leds &lt;= (others =&gt; '0'); leds(1) &lt;= '1';
        when led2 =&gt;
            leds &lt;= (others =&gt; '0'); leds(2) &lt;= '1';
    [...]


or

begin
    leds &lt;= (others =&gt; '0');
    case etat_present is
        when led1 =&gt;
            leds(1) &lt;= '1';
        when led2 =&gt;
            leds(2) &lt;= '1';
    [...]


Depending on your requirements and the support of the synthesis tool.

But we're missing the code to see why leds(25) has multiple drivers. So can't help you there.

What did simulation say? I hope you simulated this. Straight to FPGA is usually a bad idea.

Change the leds signal type to std_ulogic_vector and test in simulation, which will give an earlier error.",,,,,
Modelsim - Object not logged & no signal data while simulating verilog clock divider code,"What I'm trying to do: I wish to count numbers from 0 to hexadecimal F and display these on my FPGA board at different frequencies - my board's clock (CLOCK_50) is at 50 MHz and I wish to alter the frequency/speed of the counting based on two input switches on my board (SW[1:0]). 

Verilog Code for top-module &amp; clock divider module:

//top level module 

module rate_divider (input CLOCK_50, input [1:0] SW, input [1:0] KEY,output [6:0] HEX0);

//Declare parameters that define the # of clock cycles needed to generate an enable pulse
according to the desired frequency.

    parameter FREQ_5MHz = 4'd9; //To divide to 5 MHz we need (10-1) cycles, 
                                //since the pulse needs to start at the 9th cycle.
    parameter FULL50_MHz = (4'd1);  //The CLOCK_50's Frequency.

//Select the desired parameter based on the input switches

    reg [3:0] cycles_countdown;  
    wire enable_display_count;
    wire [3:0] selected_freq;

    always @(*)
            case (SW)           
                2'b00: cycles_countdown = FULL50_MHz;
                2'b01: cycles_countdown = FREQ_5MHz; 
                default : cycles_countdown = FULL50_MHz;
            endcase

    assign selected_freq = cycles_countdown;        

//wire that is the output of the display_counter and input to the 7 segment

    wire [3:0] hex_value;

// instantiate my other modules

    clock_divider_enable freq_divider (.d(selected_freq), .clk(CLOCK_50), .reset(KEY[0]), 
                                                    .enable(enable_display_count));

    display_counter count_hex (.enable(enable_display_count), .clk(CLOCK_50), .hex_out(hex_value), .reset(KEY[1]));

    hex_decoder HX0 (.hex_digit(hex_value), .segments(HEX0[6:0]));

endmodule

//the clock_divider sub-circuit.

module clock_divider_enable (input [3:0] d, input clk, reset, 
                                        output enable);

    reg [3:0] q;

    always @(posedge clk)
        begin
            if (!reset || !q)
                q &lt;= d;
            else
                q &lt;= q - 4'd1;
        end

    assign enable = (q == 4'h0) ? 1'b1 : 1'b0;  

endmodule


ModelSim Code:

vlib work
vlog rate_divider.v
vsim rate_divider
log {/*}
add wave {/*}

#initial reset - using KEY[1:0]. Note: active low synchronous reset.

force {CLOCK_50} 1
force {KEY[0]} 0
force {KEY[1]} 0
run 10ns

#choose 5 MHz as the desired frequency - turn SW[0] high. 

force {CLOCK_50} 0 0ns, 1 {10ns} -r 20ns
force {KEY[0]} 1
force {KEY[1]} 1
force {SW[0]} 1
force {SW[1]} 0
run 600ns


Problems I am facing:

Here's the thing - when I don't use the always block to select a parameter, and pass a desired parameter to the wire selected_freq, my simulation works fine - I can see the expected enable pulse.

HOWEVER, if I use the always block, the reg cycles_countdown does get the correct value assigned, BUT for some reason the enable signal is just a red line. When I select my clock_divider_enable module and add it's 'q' signal onto my waveform, it is red too and shows no data, and the object q is ""not logged"". As such, I'm unable to debug and figure out what exactly the problem with my code is.

It'd be great if someone could help with how to fix the simulation issue rather than just point out the issue with my Verilog code since I want to learn how to use ModelSim efficiently so that in the future debugging will be easier for me.

Equipment Used:

FPGA: Altera De-1-SoC, Cyclone V chip

CAD/Simulation Tools: Altera Quartus II Lite 17.0 + ModelSim Starter Edition","SW wasn't given an initial value, therefore it is high-Z (X if connected to a reg). 

I'm guessing when you used the parameter approach you were parameterizing cycles_countdown. Some simulators do not trigger @* at time-0. So if there isn't a change on the senctivity list, then the block may not execute; leaving cycles_countdown as its initial value (4'hX). 



Instead of driving your test with TCL commands, you can use create a testbench in with verilog. This testbench should only be used in simulation, not synthesis.

module rate_devider_tb;
  reg CLOCK_50;
  reg [1:0] SW;
  reg [1:0] KEY;
  wire [6:0] HEX0;

  rate_divider dut( .CLOCK_50(CLOCK_50), .SW(SW), .KEY(KEY), .HEX0(HEX0));

  always begin
    CLOCK_50 = 1'b1;
    #10;
    CLOCK_50 = 1'b0;
    #10;
  end
  initial begin
    // init input signals
    SW &lt;= 2'b01;
    KEY &lt;= 2'b00;

    // Log file reporting
    $monitor(""SW:%b KEY:%b HEX0:%h  @ %t"", SW, KEY, HEX0, $time);
    // waveform dumping
    $dumpfile(""test.vcd"");
    $dumpvars(0, rate_devider_tb);

    wait(CLOCK_50 === 1'b0); // initialization x-&gt;1 will trigger an posedge
    @(posedge CLOCK_50);
    KEY &lt;= 2'b01; // remove reset after SW was sampled
    #600; // 600ns assuming timescale is in 1ns steps
    $finish();
  end
",,,,,
Convert my pyverilog AST to input for Z3 solver,"I have converted my verilog file to AST(abstrct syntax tree) but along with external constraints like the output for the circuit and the AST is to be given to Z3/SMT solver which should give us the inputs for the circuit, but I have no idea how can I give AST as the inputs for Z3/SMT solver. 

Thanks in advance.","Such a task typically amounts to walking over your AST and symbolically executing it, and generating a trace for the SMT solver. This is easier said then done, unfortunately: there are many facets of doing this translation and even when done fully, it is far from easy for a solver to verify the corresponding properties. For full Verilog, you'd have to essentially implement a Verilog simulator that can deal with symbolic values. While this can be a very large task, perhaps you can get away with a much smaller set of features, if your inputs are ""simple"" enough. Without knowing anything about how your Verilog is structured, it's really hard to say anything. 

This paper, penned by the two main authors of Z3 (Nikolaj and Leonardo) provides a good survey of the approach. It's an excellent read with many useful references. Starting with that can at least give you an idea of what's involved. 

I should add that verification of Verilog designs is a topic that has industrial applications, and there are vendor supported tools (not cheap!) to do verification at the Verilog level. The Jasper Gold tool from Cadence is one such example. Synopsys also has a similar tool.

It seems you are interested in test-case generation. That would correspond to writing a typical ""cover"" property, and reading off of the values to primary inputs that lead to the cover scenario in such a setting. Such properties are typically written in the SVA format, which is understood by such tools.",,,,,
Creating device context in OpenCL for embedded profile,"I am able to create context and devices in OpenCL by doing

     using namespace cl;
     std::vector&lt;Platform&gt; platforms;
     Platform::get(&amp;platforms);
     cl_context_properties properties[] = 
                        {CL_PLATFORM_NAME,
                      (cl_context_properties) (platforms.at(0))(),0};
            context = Context(CL_DEVICE_TYPE_ALL, properties);
            devices = context.getInfo&lt;CL_CONTEXT_DEVICES&gt;();


It is working well with CPU and GPU devices. If I try the same for FPGA devices I get error in method clCreateContextFromType(). The context constructor is wrapping this method.

How should I create context and devices for OpenCL devices such as  FPGA with embedded profile.","FPGA devices usually require to link additional vendor specific OpenCL driver libraries. What are the libraries to link with is usually specified in the vendor documentation and/or examples.

For Altera that can be found in their documentation: 1.7.6 Managing Host Application

For Xilinx in their examples (by OP): github.com/Xilinx/SDAccel_Examples",,,,,
"SystemVerilog & RegEx: ""\d"" is not recognized as a character class","I'm trying to use regular expressions in SystemVerilog. The character class ""\d"" (a digit) seems not to work, while other character classes like ""\w"", ""\s""  work fine. I tried with SVLIB and UVM, same behavior.

To reproduce I wrote the code below. The code does nothing but test ""1"" against regex ""\d"" and ""\w"" using UVM and SVLIB.

module SandBox;

import svlib_pkg::*;
import uvm_pkg::*;

initial
begin

Str myString;
Regex regex;

string testString;
string reString;

testString = ""1"";
reString = ""\\d"";

myString = Str::create(testString);
regex = Regex::create();
regex.setRE(reString);

$display(""-------------------------------------"");
$display(""test string: %s"", testString);
$display(""regex: %s"", reString);

if (regex.test(myString)) begin

    $display(""SVLIB Test passed!"");

end

if (!uvm_re_match(reString, testString)) begin

    $display(""UVM Test passed!"");   

end

testString = ""1"";
reString = ""\\w"";

myString = Str::create(testString);
regex = Regex::create();
regex.setRE(reString);

$display(""-------------------------------------"");
$display(""test string: %s"", testString);
$display(""regex: %s"", reString);

if (regex.test(myString)) begin

    $display(""SVLIB Test passed!"");

end

if (!uvm_re_match(reString, testString)) begin

    $display(""UVM Test passed!"");   

end

end

endmodule


I have the following output:

-------------------------------------
test string: 1
regex: \d
-------------------------------------
test string: 1
regex: \w
SVLIB Test passed!
UVM Test passed!


What is the reason for this behavior? The underlying system? Something in SV syntax?","According to the svlib User Guide and Programmer's Reference:


  svlib uses the ""extended
  regular expression"" dialect of the C library's POSIX-compliant regular expression subsystem,
  and you can find full details of how to write regular expressions in this dialect by consulting
  the man-page man 7 regex or any of the numerous online regular expression tutorials. The
  regex dialect of svlib is in almost all respects the same as that used by the Unix/Linux
  command egrep.


The POSIX regular expressions standard (man 7 regexp), in turn, defines the available character classes as follows:


  Within a bracket expression, the name of a character class enclosed in ""[:"" and "":]"" stands for the list of all characters belonging to that class.  Standard character class names are:

alnum   digit   punct
alpha   graph   space
blank   lower   upper
cntrl   print   xdigit



So, the digits characters class has to be specified as: 

[[:digit:]]


using the canonical syntax.

The \d, \w or \s are a so called Shorthand Character Classes, which are not defined by the POSIX standard, so their availability depends on the Regexp 
engine implementation you are using.

Some regexp engines choose to implement all of them, others (e.g. sed or grep, only implement a subset, not including \d.

The svlib implementation is claimed to be egrep compatible, and egrep does not support \d.",,,,,
Conversion of scientific notation into real in systemverilog,"I have a string which has the following form

str = ""1e-06""


The content of the string is a number which is expressed in scientific notation. I would like obtain the content of the string in real format to use in next blocks of my systemverilog code. Can anybody help me to find the solution?

Example:

string str = ""1e-06"";
real number;
number = str.atoreal();
$display(""%f"", number);


At the output of this snippet, I was expecting 1e-06 but I am obtaining 1","Use %e instead of %f. This is why it's very important to show a complete example.

Here's an example of a complete example

module top;
string str = ""1e-06"";
real number;
initial begin 
  number = str.atoreal();
  $display(""%e"", number); // %f displays a fixed point number, you want %e or %g
  end
endmodule
",,,,,
Using Subtraction in a Conditional Statement in Verilog,"I'm relatively new to Verilog and I've been working on a project in which I would, in an ideal world, like to have an assignment statement like:

assign isinbufferzone = a &gt; (packetlength-16384) ? 1:0;


The file with this type of line in it will compile, but isinbufferzone doesn't go high when it should. I'm assuming it's not happy with having subtraction in the conditional. I'm able to make the module work by moving stuff around, but the result is more complicated than I think it should need to be and the latency really starts to add up. Does anyone have any thoughts on what the most concise way to do this is? Thank you in advance for your help. ","You probably expect isinbufferzone to go high if packetlength is 16384 or less regardless of a, however this is not what happens.

If packetlength is less than 16384, the value packetlength - 16384 is not a negative number &minus;X, but some very large positive number (maybe 232 &minus; X, or 217 &minus; X, I'm not quite sure which, but it doesn't matter), because Verilog does unsigned arithmetic by default. This is called integer overflow.

You could maybe try to solve this by declaring some signals as signed, but in my opinion the safest way is to explicitly handle the overflow case and making sure the subtraction result is only evaluated for packetlength values of 16384 or greater:

assign isinbufferzone = (packetlength &lt; 16384) ? 1 : (a &gt; packetlength - 16384);
",,,,,
c++ write on specific bits in matrix,"I got a quite simple problem today. I have a matrix float gradient[COLS][ROWS]. As you probably know the float type includes 32 bits. 
In my code I do 4 different checks on another table. For each of them I want to write in gradient[][] the results. 

What I would like to do is write these results on 8 bits in gradient[][].
So the LSB would contain the result of the first Check, the 8 following bits the results of the second Check, and so on.

As for the reason I want to do this, it is because I'm trying to synthetize this code using HLS and make it run on a Xilinx ZedBoard. There is however not much memory available on the FPGA, so instead of storing the results of my 4 functions into 4 different matrix I woul like to store them in the same matrix using bit operations.

I know I can use masks with an AND operator like gradient[][]&amp;0xFF. What I'm not sure however is when and how do I apply this mask ?

As an example here is the code for one of the Checks (sry for the spanish names i didn't write this) : 

void FullCheck(float brightness_tab[COLS][ROWS]){
    for(int i=0;i&lt;ROWS;i++){
        int previous_point = (int)(brightness_tab[0][i]);
        for(int j=1;j&lt;COLS-1;j++){
            float brightness=brightness_tab[i][j];
            int brightnessi=(int)(brightness);
            gradient[i][j]=brightnessi- previous_point;
            if(!(gradient[i][j]&gt;VALOR_PENDIENTE || gradient[i][j]&lt;-VALOR_PENDIENTE)){
                if(!(gradient[i][j] + gradient[i][j-1] &gt;VALOR_PENDIENTE_TRUNCAR || gradient[i][j] + gradient[i][j+1]&lt;-VALOR_PENDIENTE_TRUNCAR)){
                    gradient[i][j]=0;
                }
            }
            if(j&lt;2 || i&lt;2 || COLS-1 ==i){gradient[i][j]=0;}
            previous_point=brightnessi;
        }
    }
}


Thank you in advance for your answers !","Deducing from your comments, I'll assume that gradient will be declared as an int array.

In your sample code, there are 2 cases for writing something to the matrix. In the first case, you want to write some value, such as this line:

gradient[i][j] = brightnessi - previous_point;


If you want to write some data to a specific byte, the data you want to write should be a 1-byte data itself.

gradient[i][j] = 0;          // initialize to all zero bits
int data1 = 0x12;            // 1-byte value
gradient[i][j] |= data1;     // writing to the 1st byte (LSB)
int data2 = 0x34;
gradient[i][j] |= data2 &lt;&lt; 8;   // writing to the 2nd byte
int data3 = 0x56;
gradient[i][j] |= data3 &lt;&lt; 16;  // writing to the 3rd byte
int data4 = 0x78;
gradient[i][j] |= data4 &lt;&lt; 24;  // writing to the 4th byte


After executing above code, the value of gradient[i][j] will be 0x78563412.

The second case is clearing what you have written before by writing 0, such as this line:

gradient[i][j] = 0;


In this case you can do

gradient[i][j] &amp;= 0xffffff00;    // clearing the 1st byte (LSB)
gradient[i][j] &amp;= 0xffff00ff;    // clearing the 2nd byte
gradient[i][j] &amp;= 0xff00ffff;    // clearing the 3rd byte
gradient[i][j] &amp;= 0x00ffffff;    // clearing the 4th byte
",,,,,
Turn 2 bit module (Multiplier) into more bits,"I have the following code for a 2 bit multiplier:

module Multiplier (a0, a1, b0, b1, c[3:0]);
output      [3:0]c; 
input       a0, a1, b0, b1;
wire        a0b1, a1b0, ha0c, a1b1;  

and (c[0], a0, b0);
and (a0b1, a0, b1);
and (a1b0, a1, b0);
HalfAdder ha0 (a1b0, a0b1, c[1], ha0c);

and (a1b1, a1, b1);
HalfAdder ha1 (ha0c, a1b1, c[2], c[3]);
endmodule


I want to be able to expand this to more than 2 bits though (32 bits).  The structure of my code poses a challenge for this though.  First off I would have to have 68 parameters for the module.  Also I would have to manually create 64 wires (duplicates of wire a0b1, a1b0, ha0c, a1b1).  Finally I would need to manually write out a bunch of logic gates and HalfAdder modules to connect all the logic.  Because of this I am wondering if there is a way that I can refactor my code to be able to instantiate a binary multiplier of n (a passed parameter) size.  ","You need to parameterize and use a generate block. (And it is much better to use a synchronous circuit then an asynchronous circuit).

Here is an incomplete example, you can fill in the necessary logic :

module Multiplier (a, b, c, clk);
parameter WIDTH = 64;
output      [2*WIDTH:0]c; 
input       [WIDTH-1:0]a; 
input       [WIDTH-1:0]b; 
input       clk;


genvar i;
generate  for (i = 0; i &lt; WIDTH; i &lt;= i + 1)
begin : shifts
    // shift a 1-bit for each i and 'logical and' it with b
    reg  [WIDTH + i :0]carry;
    wire [WIDTH + i -1:0]shifted = {a,i{0}} &amp; b[i]; 


    // sum the result of shift and 'logical and'
    always @ (posedge clk)
    begin
        carry &lt;= shifted + shifts[i-1].carry ;
    end
end

assign c = shifts[WIDTH].carry;

endgenerate

endmodule
",,,,,
VHDL program doesn' t compile,"I am trying to create a VHDL ALU with structural way that does the following operations:
1)ADDITION
2)SUBSTRACTION
3)LOGIC AND 
4)LOGIC OR

I'm running my code in Quartus II and it finds some errors at compilation.
Here is my code :

library ieee;
use ieee.std_logic_1164.all;
use work.basic_func.all;

entity askhsh1 is
port
(   a : in std_logic_vector(15 downto 0);
    b : in std_logic_vector(15 downto 0);
    coin : in std_logic;
    coout : out std_logic;
    s : in std_logic_vector(15 downto 0);
    d : in std_logic_vector(15 downto 0);
    result : out std_logic;
    operator : in std_logic;
    binvert : in std_logic;
    ainvert : in std_logic);

 end askhsh1;

 architecture structure of askhsh1 is 
    signal c : std_logic_vector(1 to 15);
    signal result : std_logic_vector(15 downto 0);
 component myAND
    port (in1, in2: in std_logic; out1: out std_logic);
end component;
component myOR
    port (in1, in2: in std_logic; out1: out std_logic);
end component;
component myXOR
    port (in1, in2: in std_logic; out1: out std_logic);
end component;
component fullader
    port (cin, x, y : in std_logic; 
            s, cout : out std_logic);
end component;
begin 
U1 : myAND port map (a, b, result) when (operator = '0') else T1 : myOR port map (a, b, result) when (operator = '1')
else (stage0 : fullader port map (coin, a(0), b(0), s(0), c(1));
       stage1 : fullader port map (c(1), a(1), b(1), s(1), c(2));
        stage2 : fullader port map (c(2), a(2), b(2), s(2), c(3));
        stage3 : fullader port map (c(3), a(3), b(3), s(3), c(4));
        stage4 : fullader port map (c(4), a(4), b(4), s(4), c(5));
        stage5 : fullader port map (c(5), a(5), b(5), s(5), c(6));
        stage6 : fullader port map (c(6), a(6), b(6), s(6), c(7));
        stage7 : fullader port map (c(7), a(7), b(7), s(7), c(8));
        stage8 : fullader port map (c(8), a(8), b(8), s(8), c(9));
        stage9 : fullader port map (c(9), a(9), b(9), s(9), c(10));
        stage10 : fullader port map (c(10), a(10), b(10), s(10), c(11));
        stage11 : fullader port map (c(11), a(11), b(11), s(11), c(12));
        stage12 : fullader port map (c(12), a(12), b(12), s(12), c(13));
        stage13 : fullader port map (c(13), a(13), b(13), s(13), c(14));
        stage14 : fullader port map (c(14), a(14), b(14), s(14), c(15));
        stage15 : fullader port map (c(15), a(15), b(15), s(15), coout);) when (operator = '2' and binvert = '0' and ainvert = '0')

else  (stage0 : fullader port map ('1', a(0), not b(0), s(0), c(1));
       stage1 : fullader port map (c(1), a(1), not b(1), s(1), c(2));
        stage2 : fullader port map (c(2), a(2), not b(2), s(2), c(3));
        stage3 : fullader port map (c(3), a(3), not b(3), s(3), c(4));
        stage4 : fullader port map (c(4), a(4), not b(4), s(4), c(5));
        stage5 : fullader port map (c(5), a(5), not b(5), s(5), c(6));
        stage6 : fullader port map (c(6), a(6), not b(6), s(6), c(7));
        stage7 : fullader port map (c(7), a(7), not b(7), s(7), c(8));
        stage8 : fullader port map (c(8), a(8), not b(8), s(8), c(9));
        stage9 : fullader port map (c(9), a(9), not b(9), s(9), c(10));
        stage10 : fullader port map (c(10), a(10), not b(10), s(10), c(11));
        stage11 : fullader port map (c(11), a(11), not b(11), s(11), c(12));
        stage12 : fullader port map (c(12), a(12), not b(12), s(12), c(13));
        stage13 : fullader port map (c(13), a(13), not b(13), s(13), c(14));
        stage14 : fullader port map (c(14), a(14), not b(14), s(14), c(15));
        stage15 : fullader port map (c(15), a(15), not b(15), s(15), coout);) when (operator = '2' and binvert = '1' and ainvert = '0')

else (stage0 : fullader port map ('1', not a(0), b(0), s(0), c(1));
       stage1 : fullader port map (c(1), not a(1), b(1), s(1), c(2));
        stage2 : fullader port map (c(2), not a(2), b(2), s(2), c(3));
        stage3 : fullader port map (c(3), not a(3), b(3), s(3), c(4));
        stage4 : fullader port map (c(4), not a(4), b(4), s(4), c(5));
        stage5 : fullader port map (c(5), not a(5), b(5), s(5), c(6));
        stage6 : fullader port map (c(6), not a(6), b(6), s(6), c(7));
        stage7 : fullader port map (c(7), not a(7), b(7), s(7), c(8));
        stage8 : fullader port map (c(8), not a(8), b(8), s(8), c(9));
        stage9 : fullader port map (c(9), not a(9), b(9), s(9), c(10));
        stage10 : fullader port map (c(10), not a(10), b(10), s(10), c(11));
        stage11 : fullader port map (c(11), not a(11), b(11), s(11), c(12));
        stage12 : fullader port map (c(12), not a(12), b(12), s(12), c(13));
        stage13 : fullader port map (c(13), not a(13), b(13), s(13), c(14));
        stage14 : fullader port map (c(14), not a(14), b(14), s(14), c(15));
        stage15 : fullader port map (c(15), not a(15), b(15), s(15),        coout);) when (operator = '2' and ainvert = '1' and binvert = '0')
else P1 : myXOR port map (a, b, result) when (operator = '3');
end structure;


The package basic_func is here:

 library ieee;
 use ieee.std_logic_1164.all;

 package basic_func is 
component myAND
    port (in1, in2: in std_logic; out1: out std_logic);
end component;
component myOR
    port (in1, in2: in std_logic; out1: out std_logic);
end component;
component myXOR
    port (in1, in2: in std_logic; out1: out std_logic);
end component;
component fullader
    port (cin, x, y : in std_logic; 
            s, cout : out std_logic);
end component;
end package basic_func;


  library ieee;
  use ieee.std_logic_1164.all;
  entity myAND is
port (in1, in2: in std_logic; out1: out std_logic);
end myAND;
  architecture modeland of myAND is
begin
    out1 &lt;= in1 and in2;
  end modeland;


  library ieee;
  use ieee.std_logic_1164.all;
  entity myOR is
  port (in1, in2: in std_logic; out1: out std_logic);
  end myOR;
  architecture modelor of myOR is
begin
    out1 &lt;= in1 or in2;
    end modelor;


   library ieee;
   use ieee.std_logic_1164.all;
   entity myXOR is
   port (in1, in2: in std_logic; out1: out std_logic);
   end myXOR;
   architecture modelxor of myXOR is
   begin
     out1 &lt;= in1 xor in2;
   end modelxor;


   library ieee;
   use ieee.std_logic_1164.all;
   entity myfullader is
   port (cin, x, y : in std_logic; 
            s, cout : out std_logic);
   end myfullader;
  architecture modelfulla of myfullader is
   begin
     s &lt;= x xor y xor cin;
     cout &lt;= (x and y) or (cin and x) or (cin and y);
   end modelfulla;


Any help is appreciated","Your approach to the problem of selecting the different outputs of the functional blocks (addition, etc) is not valid:

U1 : myAND port map (a, b, result) when (operator = '0') else T1 : myOR port map (a, b, result) when (operator = '1') -- and so on


Remember that you are describing hardware. What you have attempted to do here is to instantiate different hardware, depending on the operator, which changes during run time. What you need to do is to instantiate all the functional blocks, then use your operator to multiplex the output of one of those functional blocks to your output. It's difficult to give an example you can copy exactly, but the general way to select one of the outputs would look something like this (where operator is an integer range 0 to 2):

process (operator, adder_output, and_output, or_output) 
begin
  case (operator) is
    when 0 =&gt; result &lt;= and_output;
    when 1 =&gt; result &lt;= or_output;
    when 2 =&gt; result &lt;= adder_output;
  end case;
end process;


There are a few other points to make.


Your operator is defined as an std_logic, and you are trying to check for it being '2'. It looks like to implement the number of operators you have, you should define this input to be an integer. Having done this, you test this input against an integer literal, which would look like 2, not '2'. I would make the input operator : in integer range 0 to 2, assuming you have 3 operators.
You have result defined as an std_logic port, and an std_logic_vector signal. It is not clear what you actually wanted, but I suspect you should make your result port an std_logic_vector, and remove the signal.
You are instantiating entities using positional association. this is not generally recommended. Where you have:

stage0 : fullader port map (coin, a(0), b(0), s(0), c(1));


You would instead use named association:

stage0 : fullader port map (
  cin =&gt; coin,
  x =&gt; a(0),
  y =&gt; b(0),
  s =&gt; s(0),
  cout =&gt; c(1)
);


This prevents bugs if somebody alters the port list, and makes the code more readable.
I would suggest making the code more structured, so that you create an entity that creates an 8-bit adder using your fulladder entites, then you can much more cleanly instnatiate this one 8-bit adder in your top level. This will make it more clear in your code what is going on.
If you did have a need to conditionally instantiate an entity, you would use the generate statement:

SomeLabel : if (my_condition = true) generate
  stage0 : fullader port map (
    cin =&gt; coin,
    x =&gt; a(0),
    y =&gt; b(0),
    s =&gt; s(0),
    cout =&gt; c(1)
  );
end generate;


Again, I don't think this is what you should be using in this case, as generate is a compile-time construct, and you want the behavior to change during run-time.
",,,,,
How to implement time delay into Verilog FSM,"always @(posedge clock)
    case(state)
        `STATE0: begin
            state &lt;= `STATE1;
            // Code here
            // Wait 5ms before advancing 
        end
        `STATE1: begin 
            state &lt;= `STATE2;
            // Code here
            // Wait 5ns before advancing 
        end
        `STATE2: begin 
            state &lt;= `STATE0;
            // Code here
            // Wait 5s before advancing 
        end
        default:begin
            state &lt;= `STATE0;
            // Code here
        end
    endcase
end


Is it possible to add wait statements into the design where it must wait x amount of time units before it can proceed to the next state? 
I know it can be manually done in my testbench using # but my design requires that there needs to be a certain wait time before I can proceed. ","For short delays (a few clock cycles), it might be easiest to implement a few ""dummy"" states as intermediaries between the intended states.

For longer delays, use a counter as the enable signal to transfer between the states:

reg [31:0] count;
always@(posedge clock)
    if (SOME RESET) count &lt;=0;
    else count &lt;= count + 1;

always @(posedge clock)
//...
   STATE_N: if (count == SOME_NUMBER_OF_CYCLES) state &lt;= STATE_NPLUSONE;
            else state &lt;= STATE_N;
",,,,,
Sum of Values based on bits enabled Verilog,"I am new to Verilog, I was trying to write a simple code but I am not sure how to do it in a expert way.
I have a 12 bit register ""data"", each bit of that register have a specific value. e.g. 

Bit 0 = 12;
Bit 1 = 16;
Bit 2 = 33;
......
Bit 11 = 180;


Now if any bit of ""data"" register is 1 then the result should be the sum of all value that coresponds to that bit value. e.g.

data = 12'b100000000101
result = 225 (180+33+12)


Right now i am checking each bit of data, if it is 1 then i register that corresponding value and add it to previous registered value. This method takes number of cycles.
How can i do it in a fast way in verilog.

thank you","It depends on what you mean by ""fast"". Presumably you mean time, but remember that time=cycles/frequency - reducing the number of cycles will often reduce the maximum frequency your circuit can operate at.

For example, here's a circuit that does the entire add in one cycle:

always@(*) begin
    tempsum = 0;
    tempsum = tempsum + (data[0]? 12:0);
    tempsum = tempsum + (data[1]? 16:0);
    tempsum = tempsum + (data[2]? 33:0);
    //...
end
always@(posedge clock)
    result &lt;= tempsum;


If you synthesized this circuit, you'd see a long chain of adders. In could calculate the result in a single cycle, but would have a long critical path, and therefore have a lower fMax. Whether this would be ""faster"" is impossible to know until you synthesize it (there are too many factors to guess).

A better multi-cycle approach could be to use a tree, i.e.:

reg [31:0] sum [29:0];
always @ (posedge clock) begin
    // level 0
    sum[0] &lt;= (data[0]? 12:0) + (data[1]? 16:0);
    sum[1] &lt;= (data[2]? 33:0) + (data[3]? 40:0);
  // ...
    sum[15] &lt;=  (data[30]? 160:0) + (data[31]? 180:0);
    // level 1
    sum[16] &lt;= sum [0] + sum [1];
    sum[17] &lt;= sum [2] + sum [3];
  // ...
    sum[23] &lt;= sum [14] + sum [15];
    // level 2
    sum[24] &lt;= sum [16] + sum [17];
    sum[25] &lt;= sum [18] + sum [19];
  // ...
    // level 3
    sum[28] &lt;= sum [24] + sum [25];
    sum[29] &lt;= sum [26] + sum [27];

    result &lt;= sum [28] + sum [29];
end


All that said, ultimately the ""fastest"" approach will also depend on the other requirements of your system, what you're implementing it on, etc.",,,,,
Chisel HDL for CPLDs,"Is it possible to use the Chisel HDL  with a CPLD? If yes, have you
tried it, could you share experience please?","As Chisel generate Verilog code and the CPLD accept Verilog for synthesis, yes it's possible.
I tested it with a CoolRunnerII from Xilinx. That works well.",,,,,
How to start a counter using a one clock pulse enable,"So I'm trying to implement a counter that takes a one-clock-cycle enable and starts counting from there. It sends a one-clock-cycle expired once the counter finishes counting. The enable will never be sent again until the counter is done counting, and the value input is continuous.

I was thinking of just using a reg variable that is changed to high when enable = 1, and changed to low once the counter finishes counting. I fear this may imply latches that I don't want... is there a better way to do this?

current code:

module Timer(
input [3:0] value,
input start_timer,
input clk,
input rst,
output reg expired
);

//counter var
reg [3:0] count;

//hold variable
reg hold;

//setting hold
always @*
begin
    if (start_timer == 1'b1)
         hold &lt;= 1'b1;
end


//counter
if (hold == 1'b1)
begin
always @ (posedge(clk))
begin
    if(count == value - 1)
    begin
        expired &lt;= 1'b1;
        count &lt;= 4'b0;
        hold &lt;= 1'b0;
    end
    else
        count &lt;= count + 1'b1;
end
end

endmodule
","Well, you seem to be on the right track, but you are correct that your current design will imply latches. You can fix this by making hold its own flipflop and only counting when its set as you have done, clearing it once your counting is complete. Note this will impact the timing of your system, so you have to make sure everything happens on the correct cycle. Its hard to say from your description whether you want expired to be set on the ""value""th cycle or ""value + 1""th cycle. In order to show you a few of what youll need to do to your code to get it to compile and have the proper timing, Im going to assume a few things:


value is held at a constant number and doesnt not change while counting
expired will pulse on the valueth clock after start_timer is set
value will not be 4'h0 (though this is easy to deal with, as no counting is required based on assumption 1)


So, your module would look like this:

module Timer(
             input [3:0] value,
             input start_timer,
             input clk,
             input rst,
             output expired
            );

//counter var
reg [3:0] count;

//hold variable
reg hold;

// Note you cannot assign hold from multiple blocks, so the other one has been removed

// In order to meet the timing from assumption 2, we need to combinationally determine expired (be sure we only set it while we are counting; thus the dependence on hold)
assign expired = (count == value - 4'd1) &amp;&amp; (hold == 1'b1);

//counter
// Note, you cannot have logic outside of a procedural block!
always @(posedge clk) begin
  if ((hold == 1'b0) &amp;&amp; (start_timer == 1'b1)) begin
    hold &lt;= 1'b1; // Hold is part of the register, making it its own flipflop
    count &lt;= 4'd0;
  end
  else if (hold == 1'b1) begin
    if (count == value - 4'd1) begin
        hold &lt;= 1'b0; // Clear hold, we are done counting
        // No need to clear count, it will be cleared at the start of the timer
    end
    else begin
      count &lt;= count + 4'd1;
    end
  end
end

endmodule
",,,,,
"How to determine if all for loops have ended, VHDL, Quartus-II","I'm struggling with a VHDL conundrum. Here's some code which should explain what I'm trying to do:

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use work.all;

entity forLoopTest is
-- Number of bits known only at compilation
generic(
    bits : integer  range 1 to 1024;                := 256;
);
port(
    clk:    in  std_logic                           := '0';
    -- Single bit inputs from foo
    foo:    in  std_logic_vector(bits-1 downto 0)   := (others =&gt; '0');
    -- Output should be high when all inputs have gone to '1' at some point
    bar:    out std_logic
);
end forLoopTest;

------------------------------------------------------------------------------------------------------------

architecture implementation of forLoopTest is
    -- Create states for finite state machine, where finish implies a '1' has been received
    type FSM_states_single is (waitForHigh, finish);
    -- Make an array of the states, one for each input bit
    type FSM_states_multi is array (bits-1 downto 0) of FSM_states_single;
    -- Create signal of states initialised to the waiting condition
    signal state : FSM_states_multi                 := (others =&gt; waitForHigh);

begin

    process(clk, foo)
        -- For each input bit:
        for bitNumber in 0 to bits-1 loop
            case state(bitNumber) is
                -- Whilst waiting, poll the input bit
                when waitForHigh =&gt;
                    -- If it goes high, then switch states
                    if (foo(bitNumber) = '1') then
                        state(bitNumber) &lt;= finish;
                    end if;
                -- If input bit has gone high:
                when finish =&gt;
                    -- What is simplest method of setting ""bar""?
                        -- ""bar"" should be high if and only if all bits have equalled '1' at some point
                        -- Otherwise it should be '0'
                        -- Though of dominant setting '0', and submissive setting 'H', but multiple things setting output fails
                            -- Either explicitly, or only one of them is used, others ignored
            end case;
        end loop;

    end process;        

end implementation;


Basically, I am trying to find an optimal method of deducing when all ""threads"" of the for loop have completed. The above is a hypothetical example to illustrate the point. One method using the above code would be to simply ""AND"" all of the states. However, I'm not sure how to and an unknown number of variables (pre-compilation). Also I am curious to know what other methods of solving this problem are.

Thanks in advance!","Added the clock and a reset to your process. The reset allows you to clear state.

No bar flip flop, it'd be easy to do, move an if statement.

The case statement was removed because of how bar is derived, evaluating both states isn't necessary:

library ieee;
use ieee.std_logic_1164.all;
-- use ieee.std_logic_arith.all;  -- not used
use work.all;

entity forlooptest is
    generic (
        bits : integer  range 1 to 1024 := 256 -- removed ';' 2 places
    );
    port (
        clk:    in  std_logic;
        reset:  in  std_logic;  -- added
        foo:    in  std_logic_vector(bits-1 downto 0) := (others =&gt; '0');
        bar:    out std_logic
    );
end entity forlooptest;

architecture foo of forlooptest is

    type FSM_states_single is (waitForHigh, finish);
    type FSM_states_multi is array (bits-1 downto 0) of FSM_states_single;
    signal state : FSM_states_multi := (others =&gt; waitForHigh);

begin

FOO_BAR:
    process (clk, reset)
        variable state_v:   FSM_states_multi;  -- added
    begin -- original missing begin

        state_v := state;  -- variable can be evaluated after assignment
        if reset = '1' then
            state_v := (others =&gt; WaitForHigh);
        elsif rising_edge(clk) then 
            for bitNumber in 0 to bits-1 loop 
                if state_v(bitNumber) = waitForHigh and 
                                foo(BitNumber) = '1'     then
                    state_v(bitNumber) := finish;
                end if;
            end loop;  
            state &lt;= state_v;  
        end if;
        if state_v = (state_v'range =&gt; finish)  then 
            bar &lt;= '1';  -- bar not a FlipFlop move if statement above
        else             -- preceding end if and add to reset condition for FF
            bar &lt;= '0';  -- no latch
        end if;
    end process;    

end architecture;


Making bar a flip flop can be done by moving it's if statement above the preceding end if, removing the else and assignment to '0', and adding bar &lt;= '0' to the reset.

There's also a variable copy of state so any updated bits are available immediately for evaluation. (A signal assignment doesn't take effect immediately while a variable assignment does).

Note the heart of the matter, how to evaluate state (state_v) using an aggregate value with every position set to finish. You can't use an others here. The number of elements and their type has to be discernable from the aggregate expression as an input to the equality operator.

Adding a small testbench with a limited range of bits:

library ieee;
use ieee.std_logic_1164.all;

entity for_loop_test_tb is
end entity;

architecture fum of for_loop_test_tb is
    constant bits:  integer range 1 to 1024 := 16; 
    signal clk:    std_logic := '0';
    signal reset:  std_logic;  -- added
    signal foo:    std_logic_vector(bits-1 downto 0) := (others =&gt; '0');
    signal bar:    std_logic;
begin
DUT:
    entity work.forlooptest
        generic map (bits =&gt; bits)
        port map (
            clk =&gt; clk,
            reset =&gt; reset,
            foo =&gt; foo,
            bar =&gt; bar
        );
CLOCK:
    process
    begin
        wait for 5 ns;
        clk &lt;= not clk;
        if now &gt; 150 ns then
            wait;
        end if;
    end process;

STIMULI:
    process
    begin
        wait for 10 ns;
        reset &lt;= '1';
        wait for 10 ns;
        reset &lt;= '0';
        wait for 10 ns;
        foo &lt;= x""0FF0"";
        wait for 10 ns;
        foo &lt;= x""0001"";
        wait for 10 ns;
        foo &lt;= x""F002"";
        wait for 10 ns;
        foo &lt;= x""0F00"";
        wait for 10 ns;
        foo &lt;= x""FF00"";
        wait for 10 ns;
        foo &lt;= x""0001"";
        wait for 10 ns;
        foo &lt;= x""00F0"";
        wait for 10 ns;
        foo &lt;= x""F0F0"";
        wait for 10 ns;
        foo &lt;= x""0004"";
        wait for 10 ns;
        foo &lt;= x""CCCC"";
        wait;
    end process;

end architecture;


And that gives:



(The value for bits and the number of different input values for foo were restricted to provide a waveform easily interpreted.)",,,,,
Indexing of original vector in a function in VHDL,"I want to write a function in VHDL which is given the top few bits of a std_logic_vector and does stuff to them but it seems to be that the indexing of my function still starts counting at the bottom of the whole vector. 

I can get around this by first assigning my vector to a temporary signal and using that but I'm worried that I don't understand what's going on here.

Could someone explain why a and b don't get the same output in the below?

architecture rtl of inds is
  function top_bit (c : std_logic_vector) return std_logic is
  begin
    return c(c'length-1);
  end top_bit;
  signal temp : std_logic_vector(2 downto 0);
begin
  temp &lt;= input(3 downto 1);
  a &lt;= top_bit(temp);
  b &lt;= top_bit(input(3 downto 1));
end rtl;


If you give them the input ""0100"", you get a='0', b='1'.

If you give them the input ""1000"", you get a='1', b='0'.

So a=temp(2)=input(3) and b=input(2) which is input(""length of c"" -1).

I don't think this makes sense, can someone justify it for me.

Edit: if you replace the declaration line with:

function top_bit (c : std_logic_vector(2 downto 0)) return std_logic is


then it works as I'd expect. 
I suppose the vector c takes it's indexing from the vector it's given.

I'd like to see a function which takes an arbitrary slice of a vector and returns the top bit of that slice.","You are using the 'length attribute, where you could be using 'high. I think this would do what you're asking for.

I've got a print out on my wall of the table here http://www.csee.umbc.edu/portal/help/VHDL/attribute.html as a reference for what attributes are available.",,,,,
How can i get Audio Stream input as binary number for AES encryption in verilog?,"I am doing a project in which I have written the code for AES-128 encryption algorithm in Verilog with a fixed input (128-bit), Now I want to take audio stream as binary number and use it for input to AES encryption algorithm.
What would be the best way to do that?","As shown in figure, Connect your source of Audio to ADC, Make sampling frequency as described in below,

F_sample &gt;= 2 x Fmax_audio (According to Nyquist Criteria)

That will be fed to ADC.

Give 90 degree shifted clock to FPGA for latching that Digital data from ADC.

Now you have your data on Board, use it in AES algorithm.

You can do reverse process to speaker. 




180 degree phase shift also can be used, according to setup and hold time.


Edit:

There is one reason why 90 degree phase shifted clock to FPGA board, if we use 90 degree phase shifted clock then it is sampling the data at half of positive level, so we can avoid the mis-sample. See image, at 90 degree it is stable as well, we also can use 180 degree.

",,,,,
Distinguish and expand text macro nested in define macro,"I would like to define a parameter MYTYPE using text macro, whose value is passed over by text macro, eg 

`define MY_FEATURE(nam,def) parameter nam=def;


and then 

`MY_FEATURE(MYTYPE, 1)


But the value is mixed by those who are defined by other text macros, eg

`MY_FEATURE(NEWTYPE, 2)
`MY_FEATURE(MYTYPE, NEWTYPE)


The latter case will not work unless the def in define MY_FEATURE is added with the directive dot. 

I need to distinguish this two different cases and automatically expand the macro - only if it is defined, so I came up with this code but I got error. 

`define yea 1
`define nop 0
`define MY_FEATURE(nam,def) `ifdef def parameter nam=`def; `else parameter nam=2; `endif

module test;

  `MY_FEATURE(MYTYPE,yea)
  initial begin
    $display(""%d"",MYTYPE);
  end
endmodule


The above code works and gives a 1 as output. However if I write 

`MY_FEATURE(MYTYPE,10)


since for other cases I need to assign an actual number to the parameter, then I will get 

 `ifdef without a macro name - ignored.


My desired result is MYTYPE is assigned as 10. 
Is there any way to achieve this? Thanks. 

Code can be found here
http://www.edaplayground.com/x/6Jha","I think you are overthinking it. `define creates an directive expression. When when you pass a directive as parameter to another directive you can pass it as `yea. 

Here is an example:

`define yea 1
`define nop 0
`define MY_FEATURE(nam,def) parameter nam=def;

module test;
  `MY_FEATURE(MYTYPE,`yea)
  `MY_FEATURE(MYTYPE2,10)
  `MY_FEATURE(MYTYPE3,MYTYPE+MYTYPE2)
  initial begin
    $display(""%d %d %d"",MYTYPE, MYTYPE2, MYTYPE3); // displays: 1 10 11
  end
endmodule


http://www.edaplayground.com/x/5Pgf



Verilog-AMS (superset of Verilog-A) is a language of its own, derived from Verilog (IEEE Std 1364); according the manual. This means your MY_FEATURE never creates new directives; it creates parameters. Directives and parameters are both treated as constants in simulation but act differently in compile. The `define/parameters relation in Verilog (and Verilog derived languages) is equivalent to C's #define/const relation. Unlike C, to access the value of a `define requires a ` prefix.

Neither directives or parameters cannot start with a numeric value. The first character must be an alpha or underscore (aka [a-zA-Z_]). There for 10 can never be a directives and even trying to use it is illegal syntax. There is noway for the compile to recover from an illegal syntax directive name. This is way I suggested passing `yea instead of yea.

If someone build you a nice model, then it should come with equally nice documentation or some way of getting support.",,,,,
Using reg output as input Verilog,"So, I'm working on a simple register that takes a synchronized input and, as soon as input is asserted, holds that state until reset is enabled. 

My code should be pretty self explanatory. Is this checking-of-reg-output going to cause any problems?

    module walk_reg(
        input Walk_Sync,    //pedestrian set walk-request
        input WR_Reset,     //FSM reset, for during the walk service
        input clk,      //clock
        output reg WR   //output
        );


    always @(posedge (clk)) 
    begin
        if(WR_Reset)    //if reset enables, output goes to 0
            WR &lt;= 1'b0;
        else if (WR)    //if WR is already on, keep it on
            WR &lt;= WR;
        else 
            WR &lt;= Walk_Sync;    //if reset is not enabled and WR isn't already one, assign output to Walk_Sync
    end

    endmodule // walk_reg


EDIT Changed name of variable, forgot to change it in code","Not answer but too much for a comment.

always @(posedge (clk)) 
    begin
        if(WR_Reset)    //if reset enables, output goes to 0
            WR &lt;= 1'b0;
        else if (WR)    //if WR is already on, keep it on
            WR &lt;= WR;
        else 
            WR &lt;= Walk_Sync;    //if reset is not enabled and WR isn't already one, assign output to Walk_Sync
    end


Is the same as:

always @(posedge clk) 
begin
  if (WR_Reset)    //if reset enables, output goes to 0
    WR &lt;= 1'b0;
  else if (!WR)    
    WR &lt;= Walk_Sync;
end


Flip-flops will hold their value if no condition is met.

Even better suggestion from duskwuff:

always @(posedge clk) 
begin
  if (WR_Reset)    //if reset enables, output goes to 0
    WR &lt;= 1'b0;
  else if (Walk_Sync)    
    WR &lt;= 1'b1;
end
",,,,,
Cannot use Bool in class parametrization to reverse reset polarity,"I just started out with Chisel and wrote a simple counter to blink an led. The FPGA board (Lattice iCEstick) has an inverted reset signal, and instead of changing the polarity in the generated verilog, I want to set it in Chisel.

I found that Module has a _reset parameter of type Chisel.Bool that can be set to false which inverts the reset signal. Here is an example of where it is used by someone else. However I'm getting an error which I can't seem to fix. First, the code:

import Chisel._

class Blink( rstPol: Bool = null ) extends Module( _reset = rstPol ) {
  val io = new Bundle {
    val led = UInt( OUTPUT, 1 )
  }

  val cnt_next = UInt()
  val counter  = Reg( init = UInt( 0, 24 ), next = cnt_next )

  cnt_next := counter + UInt( 1 )

  io.led := counter( 23 )
}

object blinkmain {
  def main( args: Array[ String ] ): Unit = {
    chiselMain( Array( ""--backend"", ""v"" ),
      () =&gt; Module( new Blink( Bool( false ) ) )
    )
  }
}


And the error I get:

[error] Blink.scala:19 &lt; /*??*/ Chisel.Bool(OUTPUT, width=1, connect to 0 inputs: ()) &gt; doesn't have its component,yet. in class blinkmain$$anonfun$main$1$$anonfun$apply$1


If I don't supply the Bool( false ) parameter, then I get no errors, but my reset polarity of course remains positve.

I have tried rstPol: Bool = Bool( false ) and Module( _reset = Bool( false ) ) but I get the same error on line 3. It seems like it's trying to assign the Bool to something that doesn't have a width, but I have no idea how that's possible.

I checked which version of Chisel I'm using and it's 2.2.33. Here is my build.sbt file in case it's important:

scalaVersion := ""2.11.7""

libraryDependencies += ""edu.berkeley.cs"" %% ""chisel"" $ ""latest.version""

scalacOptions ++= Seq(""-deprecation"", ""-feature"", ""-unchecked"", ""-language:reflectiveCalls"")
","Since I'm new to Scala and Chisel, I wrongly assumed that the _reset parameter of Module was a Bool to indicate whether a positive or negative reset signal would be generated. You can connect a Bool INPUT to _reset however, contrary to a Bool OUTPUT as the error message mentions.

This is how I fixed it (I did expand it with a counter width parameter swidth, but that's irrelevant):

import Chisel._

class Blink( swidth: Int, rst: Bool = null ) extends Module( _reset = rst ) {
  val io = new Bundle {
    val led = UInt( OUTPUT, 5 )
  }

  val counter = Reg( init = UInt( 0, width = swidth ) )

  counter := counter + UInt( 1 )

  io.led := counter( swidth - 1, swidth - 5 )
}

class Top extends Module {
  val io = new Bundle {
    val led  = UInt( OUTPUT, 5 )
    val rstn = Bool( INPUT )
  }

  val rst   = Reg( next = Reg( next = !io.rstn ) )
  val blink = Module( new Blink( 27, rst ) )

  blink.io.led &lt;&gt; io.led
}

object BlinkMain {
  def main( args: Array[ String ] ): Unit = {
    chiselMain( Array( ""--backend"", ""v"", ""--targetDir"", ""verilog"" ),
      () =&gt; Module( new Top() )
    )
  }
}


So I created a Top module that instantiates the Blink, which takes the inverted reset input (rstn), inverts it, and assigns that to _reset. For good measure, I also route rstn through two flip-flops to sync it up with the input clock signal.",,,,,
Verilog shift register of parameterized length,"I am new in Verilog code. I have to do a problem in verilog code with a shift register. I searched before asking, but I didn't find something similar. Could someone please help me with some tips about creating the code in Verilog for this register?
Thank you! Have a nice day!

","Perhaps this might get you going:

module DW03_shft_reg #(
// the parameterisable length of the shift register needs to be a parameter
    parameter LENGTH = 1              
  )(
      input [LENGTH-1:0] p_in,
      input s_in, load_n, shift_n, clk, 
      // this needs to be a 'reg' so that it can be assigned to by the 'always' block
      output reg [LENGTH-1:0] p_out     
  );

    // the template for sequential code with no asynchronous reset
    always @(posedge clk)               
        begin
          // implement the behaviour from the truth table here
          // the { , } (concatenation) operator is useful for shift registers
        end

endmodule
",,,,,
For loop goes into infinite loop when I use a variable as ending condition,"I have a for loop that runs fine in Verilog.  It looks like this:

for(j=0; j&lt;=5; j=j+1)begin
    ...
end


but as soon as I change the 5 into a variable:

for(j=0; j&lt;=m; j=j+1)begin
    ...
end


I get this error: 


  Error (10119): Verilog HDL Loop Statement error at alu.v(95): loop with non-constant loop condition must terminate within 250 iterations


I have m as a reg initialized as such:

reg [3:0] m = 5;


The reason I need to use a variable is I have an another variable that I want this loop to count to. I was getting the same error so I used this test value 'm' that should always equal 5.  I'm not sure why this is happening.  I would think the loop would end after 5, but for some reason it doesn't.  Please help!","Verilog HDL is not programming language, like e.g. C or Python, but a Hardware Description Language (HDL).  So the synthesis tool will unroll the for loop to a fixed hardware circuit, and for this it needs to know the (maximum) number of iterations in the loop.  

In your case it appears that the synthesis tool (Altera Quartus II/Prime), can't figure this out when the end condition is based on m as a register, so you have to rewrite this to each loop has a constant end condition, allowing the synthesis tool to unroll this to a fixed hardware circuit.",,,,,
Verilog code for wighted average circuit,"I am trying to synthesize a weighted sum circuit which will essentially implement the following equation,

out=out+a[i]*w[i]  ,  where i=0,1..n

I have written the following code but synthesizing in design vision environment generates error as following


  ELAB-368 (error) %s Net '%s', or a directly connected net, is driven
  by more than one source, and at least one source is a constant net.


module weighted_sum #(parameter n=10)(input [7:0] a[3:0], input [7:0] w[3:0], output [7:0] out);

assign out=0;
genvar i;
generate
for (i=0;i&lt;n;i=i+1) begin:block1
out=out+a[i]*b[i];
end
endgenerate
endmodule


Any direction is appreciated.

Thanks
Farhana","You cannot use a generate loop for this. generate is for replicating hardware. You want to logic, which should use an always block:

always_comb begin // SystemVerilog use ""always_comb"", Verilog use ""always @*""
  out = 0;
  for (int i=0;i&lt;n;i=i+1) begin
    out += a[i]*b[i];
  end
end


FYI, Verilog does not support multi-dimensional arrays on the port-list (ex input [7:0] a[3:0]). Verilog only supports vector type ports (aka single dimension packed arrays). SystemVerilog does support multi-dimensional arrays on ports, but some tools may have limitations on support so refer to your manuals and experiment. 

Also, your module header does not scale. a &amp; b will always be 4 entries of 8bits, and out will likely overflow. I suggest the following module header:

module weighted_sum #(parameter N=10)(
  input [7:0] a[N], input [7:0] w[N], // scaling input depth
  output logic [14+N:0] out); // scaling for overflow protection
",,,,,
Easiest Way to Shift Down A Signed Number,"I am multiplying a 2s compliment floating point number and using it for some maths inside a DSP. I get the result and wish to shift it back down but I'm unsure of the easiest method.

For example:

constant b_const : integer := integer(real(1.0 / 3.0) / real((2.0**-10.0)));        
signal b : std_logic_vector(10 downto 0);

begin

b &lt;= std_logic_vector(to_signed(b_const, b'length)) ; 

dsp: work.entity_dsp -- p = a * b
port map(
    clk =&gt; clk,
    a =&gt; a,
    b =&gt; b,
    p =&gt; p -- also signed
);

c &lt;= p / 2**10; -- Isn't this very resource intensive ?


I had a look at the function ""resize"" but it just seems to either truncate or pad bits. I thought a golden rule of FPGAs was never to use ""/"" unless it realises a simple solution for what I'm trying to do?

Any advice?","If you want to truncate LSBs, you can use the shift_right function defined in numeric_std, followed by a resize. 


c &lt;= resize(shift_right(p, 10), c'length);


Alternatively, you can take a slice:


c &lt;= p(c'length+10 downto 10);
",,,,,
Using Verilog parameters in if else conditions,"Consider the following Verilog code.

parameter  C_SUB_WIDTH  = 2;
parameter  C_SUB_HEIGHT = 2;
parameter  BIT_DEPTH    = 12;

reg [5:0]  single_block_width;

always @ (*) begin
    if(BIT_DEPTH == 8) begin
        case({C_SUB_HEIGHT == 1, C_SUB_WIDTH == 1})
            2'b00:  single_block_width = 6'd16;
            2'b10:  single_block_width = 6'd16;
            2'b11:  single_block_width = 6'd24;
            default:single_block_width = 6'dx;
        endcase
    end
    else if(BIT_DEPTH == 10) begin
        case({C_SUB_HEIGHT == 1, C_SUB_WIDTH == 1})
            2'b00:  single_block_width = 6'd16;
            2'b10:  single_block_width = 6'd24;
            2'b11:  single_block_width = 6'd32;
            default:single_block_width = 6'dx;
        endcase
    end
    else if(BIT_DEPTH == 12) begin
        case({C_SUB_HEIGHT == 1, C_SUB_WIDTH == 1})
            2'b00:  single_block_width = 6'd24;
            2'b10:  single_block_width = 6'd24;
            2'b11:  single_block_width = 6'd40;
            default:single_block_width = 6'dx;
        endcase
    end
    else begin
        single_block_width = 6'dx;
    end
end


Since  C_SUB_WIDTH, C_SUB_HEIGHT and BIT_DEPTH are all parameters, would this make single_block_width, a parameter too?

If not, then how can I make single_block_width a parameter and set its' value based on above mentioned parameters?

I am using Xilinx Vivado to synthesize the above code. (Its has to be able to synthesize)

Thank you.","parameter [5:0] SINGLE_BLOCK_WIDTH = (BIT_DEPTH == 8) ? ((C_SUB_WIDTH == 0) ? ((C_SUB_HEIGHT == 0 ) ? 6'd16 : 6'd16) : 6'd24) 
                                 : ((BIT_DEPTH == 10) ? ((C_SUB_WIDTH == 0) ? ((C_SUB_HEIGHT == 0 ) ? 6'd16 : 6'd24) : 6'd32) 
                                   : (BIT_DEPTH == 12) ? ((C_SUB_WIDTH == 0) ? ((C_SUB_HEIGHT == 0 ) ? 6'd24 : 6'd24) : 6'd40));


Try this type of coding. It may have logical error but it is synthesise.  ",,,,,
"Gate Level Verilog: Conditional, generate gate inputs","I'm working on a binary decoder and am trying to parameterize the address size.  It is a project requirement that this be made in gate level verilog.

Is there a way to generate the i[k] statements in the second generate statement based on ADDR_SIZE?

module Decoder #(
  parameter ADDR_SIZE = 5
)(
  out,
  in
);
  input wire [ADDR_SIZE-1:0] in;
  output wire [(2**ADDR_SIZE)-1:0] out;
  wire [ADDR_SIZE-1:0] code, codeNot;

  genvar j;
  generate
    for (j = 0; j &lt; ADDR_SIZE; j = j + 1)
    begin : bufs
      buf (code[j], in[j]);
      not(codeNot[j], in[j]);
    end
  endgenerate

  genvar i;
  generate
    for (i = 0; i &lt; (2**ADDR_SIZE); i = i + 1)
    begin : selects
      and (out[i],
        i[0] ? codeNot[0] : code[0],
        i[1] ? codeNot[1] : code[1],
        i[2] ? codeNot[2] : code[2],
        i[3] ? codeNot[3] : code[3],
        i[4] ? codeNot[4] : code[4],
      );
    end
  endgenerate
endmodule


So if ADDR_SIZE = 4, the only thing that would change would be:

 and (out[i],
        i[0] ? codeNot[0] : code[0],
        i[1] ? codeNot[1] : code[1],
        i[2] ? codeNot[2] : code[2],
        i[3] ? codeNot[3] : code[3]
      );


Or if ADDR_SIZE = 6

 and (out[i],
        i[0] ? codeNot[0] : code[0],
        i[1] ? codeNot[1] : code[1],
        i[2] ? codeNot[2] : code[2],
        i[3] ? codeNot[3] : code[3],
        i[4] ? codeNot[4] : code[4],
        i[5] ? codeNot[5] : code[5]
      );


Since its a decoder, I'm accepting a binary input of 2^ADDR_SIZE (default to 5).  Depending on what the input binary value is, the corresponding output line would be driven high, so if in = 5'b00001, out = 32'b...0000001 (dots are all zeros.  only least significant bit is high).  If in = 5'b00011, out = 32'b...0000100.

That part has been done and works with a 5 bit address in the following code.  I'm now trying to make it so that if I set ADDR_SIZE = 4, my input is now 4'b and my output is now 16'b.  Most of this works, and each output line is just an AND of either in or inNot depending on the place.

After all this generated code is taken out, I'm essentially asking how I can do the following.  Again, its important this be done in Structural Verilog.

parameter ADDR_SIZE = 5

generate . . .
 and(out, a, b, c, d, e);
endgenerate

parameter ADDR_SIZE = 3

generate . . .
 and(out, a, b, c);
endgenerate

parameter ADDR_SIZE = 6

generate . . .
 and(out, a, b, c, d, e, f);
endgenerate
","If you want to only use gate level, my suggestion is to use a module that recursively invokes smaller versions of itself. For example:

module my_and #(parameter SIZE=4) (output out, input [SIZE-1:0] in);
generate
  if (SIZE&lt;2) begin
    // Intentionally cause a compile error if ever selected

    // Verilog requires you to be a bit clever with your error messages 
    // Suggest using using non-existing modules instances
    non_existing_module my_and_SIZE_is_less_than_2 ();

    // SystemVerlog allows option for more meaningful message
    //$error(""SIZE must be &gt;= 2, was %0d @ %m"", SIZE);
  end
  else begin
    case(SIZE)
      2 : and and2 (out, in[0], in[1]);
      3 : and and3 (out, in[0], in[1], in[2]);
      4 : and and4 (out, in[0], in[1], in[2], in[3]);
      default : begin : recursive
        wire half0, half1;
        my_and #(SIZE/2) half_0 (half0, in[SIZE/2-1:0]);
        my_and #(SIZE/2) half_1 (half1, in[SIZE-1-(SIZE%2):SIZE/2]);
        if (SIZE%2) begin : odd
          and and3 (out, half0, half1, in[SIZE-1]);
        end
        else begin : even
          and and2 (out, half0, half1);
        end
      end
    endcase
  end
endgenerate
endmodule


Note: my_and is not optimized. Depending on your target max size and inputs to an and, you may want to consider having the recursive method conditionally break into groups of three or four sub slices.

Then create a local vector for the select:

genvar i,k;
generate
  for (i = 0; i &lt; (2**ADDR_SIZE); i = i + 1)
  begin : selects
    wire [ADDR_SIZE-1:0] local_select; // local to scope
    for(k = 0; k &lt; ADDR_SIZE; k = k + 1)
    begin
      assign local_select[k] = i[k] ? code[k] : codeNot[k];
    end
    my_and #(ADDR_SIZE) dec(out[i], local_select);
  end
endgenerate


RTL is obviously simpler:

module Decoder #(
  parameter ADDR_SIZE = 5
)(
  output reg [(2**ADDR_SIZE)-1:0] out,
  input [ADDR_SIZE-1:0] in
);
always @* begin
  out = {(2**ADDR_SIZE){1'b0}};
  out[in] = 1'b1;
end
endmodule
",,,,,
Structural design of Shift Register in VHDL,"I've made a structural design of a shift register in vhdl . When WriteShift is 1 then I got shift and when it is 0 then shift register loads a price. Although load works perfectly when I set writeshift to 1 in testbench I get 00000 in simulation.

My code is the following:

entity ShiftRegis is
    Port ( Din : in  STD_LOGIC_VECTOR (4 downto 0);
           WriteShift : in  STD_LOGIC;
           Clock : in  STD_LOGIC;
              reset : in  STD_LOGIC;
              En : in STD_LOGIC;
           Q : out  STD_LOGIC_VECTOR (4 downto 0));
end ShiftRegis;

architecture Behavioral of ShiftRegis is

component notGate 
    Port ( in0 : in  STD_LOGIC;
           out0 : out  STD_LOGIC);
end component;

component nand4Gate 
    Port ( i0 : in  STD_LOGIC;
           i1 : in  STD_LOGIC;
           i2 : in  STD_LOGIC;
           i3 : in  STD_LOGIC;
           bitOut : out  STD_LOGIC);
end component;

component D_FlipFlop 
    Port ( Din : in  STD_LOGIC;
           En : in  STD_LOGIC;
           Q : out  STD_LOGIC;
              reset : in STD_LOGIC;
           Clk : in  STD_LOGIC);
end component;

signal q4, q3, q2, q1, in3, in2, in1, in0, notWS : std_logic;

begin

ff4 : D_FlipFlop
    port map( Din =&gt; Din(4),
             En =&gt; En,
             Q =&gt; q4,
                reset =&gt; reset,
             Clk =&gt; Clock);

ff3 : D_FlipFlop
    port map( Din =&gt; in3,
             En =&gt; En,
             Q =&gt; q3,
                reset =&gt; reset,
             Clk =&gt; Clock);

ff2 : D_FlipFlop
    port map( Din =&gt; in2,
             En =&gt; En,
             Q =&gt; q2,
                reset =&gt; reset,
             Clk =&gt; Clock);

ff1 : D_FlipFlop
    port map( Din =&gt; in1,
             En =&gt; En,
             Q =&gt; q1,
                reset =&gt; reset,
             Clk =&gt; Clock);

ff0 : D_FlipFlop
    port map( Din =&gt; in0,
             En =&gt; En,
             Q =&gt; Q(0),
                reset =&gt; reset,
             Clk =&gt; Clock);

notg4 : notGate
    port map( in0 =&gt; WriteShift,
                 out0 =&gt; notWS);

nandg3 : nand4Gate
    port map( i0 =&gt; Din(3),
             i1 =&gt; notWS,
             i2 =&gt; WriteShift,
             i3 =&gt; q4,
             bitOut =&gt; in3);

nandg2 : nand4Gate
    port map( i0 =&gt; Din(2),
             i1 =&gt; notWS,
             i2 =&gt; WriteShift,
             i3 =&gt; q3,
             bitOut =&gt; in2);

nandg1 : nand4Gate
    port map( i0 =&gt; Din(1),
             i1 =&gt; notWS,
             i2 =&gt; WriteShift,
             i3 =&gt; q2,
             bitOut =&gt; in1);

nandg0 : nand4Gate
    port map( i0 =&gt; Din(0),
             i1 =&gt; notWS,
             i2 =&gt; WriteShift,
             i3 =&gt; q1,
             bitOut =&gt; in0);

Q(4) &lt;= q4;
Q(3) &lt;= q3;
Q(2) &lt;= q2;
Q(1) &lt;= q1;

end Behavioral;
","Your load (WriteShift = '1' and en = '1') doesn't work either.

There's a design flaw where you're using 4 input NAND gates where you need a 2:1 Multiplexer for selecting between Din and q bits for the four LSBs in the shift register.

That's fixed by creating 2:1 muxes using three 2 input NOR gates: 

architecture behavioral of shiftregis is

    component notgate 
        port ( 
            in0:    in   std_logic;
            out0:   out  std_logic
        );
    end component;

    -- component nand4gate
    --     port (
    --         i0:     in  std_logic;
    --         i1:     in  std_logic;
    --         i2:     in  std_logic;
    --         i3:     in  std_logic;
    --         bitout: out  std_logic
    --     );
    -- end component;

    component nor2gate
        port (
            i0:     in  std_logic;
            i1:     in  std_logic;
            bitout: out  std_logic
        );
    end component;

    component d_flipflop 
        port ( 
            din:    in  std_logic;
            en:     in  std_logic;
            q:      out std_logic;
            reset:  in  std_logic;
            clk:    in  std_logic
        );
    end component;

    signal q4, q3, q2, q1, in3, in2, in1, in0, notws: std_logic;

    signal nor2g0a, nor2g0b: std_logic; -- ADDED
    signal nor2g1a, nor2g1b: std_logic; -- ADDED
    signal nor2g2a, nor2g2b: std_logic; -- ADDED
    signal nor2g3a, nor2g3b: std_logic; -- ADDED
begin

ff4:  
    d_flipflop
        port map (
            din =&gt; din(4),
            en =&gt; en,
            q =&gt; q4,
            reset =&gt; reset,
            clk =&gt; clock
        );

ff3:  
    d_flipflop
        port map (
            din =&gt; in3,
            en =&gt; en,
            q =&gt; q3,
            reset =&gt; reset,
            clk =&gt; clock
        );

ff2:  
    d_flipflop
        port map (
            din =&gt; in2,
            en =&gt; en,
            q =&gt; q2,
            reset =&gt; reset,
            clk =&gt; clock
        );

ff1:  
    d_flipflop
        port map (
            din =&gt; in1,
            en =&gt; en,
            q =&gt; q1,
            reset =&gt; reset,
            clk =&gt; clock
        );

ff0:  
    d_flipflop
        port map (
            din =&gt; in0,
            en =&gt; en,
            q =&gt; q(0),
            reset =&gt; reset,
            clk =&gt; clock
        );

notg4:  
    notgate
        port map (
            in0 =&gt; writeshift,
            out0 =&gt; notws
        );

-- norg3:
--     nand4gate
--         port map (
--             i0 =&gt; din(3),
--             i1 =&gt; notws,
--             i2 =&gt; writeshift,
--             i3 =&gt; q4,
--             bitout =&gt; in3
--         );

norg3a:  
    nor2gate
        port map (
            i0 =&gt; din(3),
            i1 =&gt; writeshift,
            bitout =&gt; nor2g3a
        );
norg3b:  
    nor2gate
        port map (
            i0 =&gt; notws,
            i1 =&gt; q4,
            bitout =&gt; nor2g3b
        );

nor3gc:  
    nor2gate
        port map (
            i0 =&gt; nor2g3a,
            i1 =&gt; nor2g3b,
            bitout =&gt; in3
        );

-- norg2:
--     nand4gate
--         port map (
--             i0 =&gt; din(2),
--             i1 =&gt; notws,
--             i2 =&gt; writeshift,
--             i3 =&gt; q3,
--             bitout =&gt; in2
--         );

norg2a:  
    nor2gate
        port map (
            i0 =&gt; din(2),
            i1 =&gt; writeshift,
            bitout =&gt; nor2g2a
        );
norg2b:  
    nor2gate
        port map (
            i0 =&gt; notws,
            i1 =&gt; q3,
            bitout =&gt; nor2g2b
        );

nor2gc:  
    nor2gate
        port map (
            i0 =&gt; nor2g2a,
            i1 =&gt; nor2g2b,
            bitout =&gt; in2
        );


-- norg1:
--     nand4gate
--         port map (
--             i0 =&gt; din(1),
--             i1 =&gt; notws,
--             i2 =&gt; writeshift,
--             i3 =&gt; q2,
--             bitout =&gt; in1
--         );

norg1a:  
    nor2gate
        port map (
            i0 =&gt; din(1),
            i1 =&gt; writeshift,
            bitout =&gt; nor2g1a
        );
norg1b:  
    nor2gate
        port map (
            i0 =&gt; notws,
            i1 =&gt; q2,
            bitout =&gt; nor2g1b
        );

nor1gc:  
    nor2gate
        port map (
            i0 =&gt; nor2g1a,
            i1 =&gt; nor2g1b,
            bitout =&gt; in1
        );

-- norg0:
--     nand4gate
--         port map (
--             i0 =&gt; din(0),
--             i1 =&gt; notws,
--             i2 =&gt; writeshift,
--             i3 =&gt; q1,
--             bitout =&gt; in0
--         );

norg0a:  
    nor2gate
        port map (
            i0 =&gt; din(0),
            i1 =&gt; writeshift,
            bitout =&gt; nor2g0a
        );
norg0b:  
    nor2gate
        port map (
            i0 =&gt; notws,
            i1 =&gt; q1,
            bitout =&gt; nor2g0b
        );

nor0gc:  
    nor2gate
        port map (
            i0 =&gt; nor2g0a,
            i1 =&gt; nor2g0b,
            bitout =&gt; in0
        );

    q(4) &lt;= q4;
    q(3) &lt;= q3;
    q(2) &lt;= q2;
    q(1) &lt;= q1;

end architecture behavioral;


And that gives:



Where you see on q(0) that between A and B a '0' is output, B and C a '1, C and D a '0', D and E a '1' and E and F a '1', following that the shifted in values for Din(4), because there's no mux on the din input to ff4.

You'll notice the LSB goes out first.

Repetitively instantiated components can in general be a target for the use of generate statements.

Without a Minimal, Complete, and Verifiable example I had to guess and settled on an asynchronous reset for the D_flipflop component.",,,,,
Setting variable length std_logic_vectors in VHDL,"I have a std_logic_vector, x: std_logice_vector(A+B-1 downto 0), and I want to set the top A bits to '1' and the bottom B bits to '0', is there an easy way to do this?

I would like to do something like this:

x &lt;= (A+B-1 downto B &lt;= (others =&gt; '1'),
        B-1 downto 0 &lt;= (others =&gt; '0'));


My other plans are to define the sub signals and join them:

signal top: std_logic_vector(A-1 downto 0);
signal bottom: std_logic_vector(B-1 downto 0);
...
top &lt;= (others =&gt; '0');
bottom &lt;= (others =&gt; '1');
x &lt;= top &amp; bottom;


Or I could write a function that loops over all the bits but that seems like a lot of work for something this easy.

If there isn't an easy way and since I need to do this multiple times I might define a constant and use that.","Another option is to use aliases.  For example:

architecture test of foo is
  signal x: std_logic_vector(A+B-1 downto 0);
  alias x_upper is x(A+B-1 downto B);
  alias x_lower is x(B-1 downto 0);
begin
  x_upper &lt;= (others =&gt; '1');
  x_lower &lt;= (others =&gt; '0');
end architecture test;


You can treat the aliases just like signals.  (And they are fully synthesizable).",,,,,
low power circuit design in verilog and calculate power for different input sequences,"I want to implement the following circuit in verilog. FA is the full adder circuit and trapezoidal shape is a mux. I am not sure how to add this power gating pmos in the circuit. 
And also I would like to synthesize the circuit in Synopsys Design vision and compute the difference in power when APP is 0 and 1.



Any help is appriciated.

Thanks

Farhana","Design two versions of the original circuit: one of them will assume the power switch is ON and the FA is operating. The other one will assume the power switch is OFF and then, the FA will be missing from the circuit. Leave the remaining devices (eg. muxes) on both circuits and set APP acoordingly.

Tell Synopsys to not perform any optimizations (it would remove the muxes as the select input is fixed to a certain value, but if it does so, the current compsumtion of the muxes, although neligible, wouldnÂ´t be taken into account).

Perform a power analysis on both versions and you will get the difference in power.

The result you obtain will have to assume that the leakage current through the PMOS device is 0 when OFF",,,,,
Is there a way to ignore combinational loop error in HDL code?,"I am trying to formally verify a small module in a very big Project code. I have anayzed and elaborated the design. I cannot verify the small module because the tool gives me a ""Found Combinational Loop"" error. 

I am quite sure that this small module is not affected by this Loop error. So i want to avaid getting this error. Is it even possible?

Thanks!","Not sure what tool you used, in JasperGold formal tool, you can use following command setting to break a combinational loop.

stopat u_DUT.signal_a


Just put it before prove -all in your tcl file (if you uses a tcl file to run your tool).

Have a look at stopat command in JapserGold manual for further information in your cases to see if you can easily break the comb loop.",,,,,
VHDL - How to efficiently convert integer to ascii or 8-bit slv,"I'm trying to output different (non-constant) values over serial. Serial communication is working fine but there doesn't seem to be an elegant, synthesizable way to convert any integer/natural/std_logic_vector/unsigned/signed type of any size and value to an array of 8-bit std_logic_vectors based on the ASCII table. That is super weird because what I'm trying to do is not uncommon.

One way I can do this is with big lookup tables or long, nested chains of if-elsif-else statements but that seems very inefficient and inelegant.

This doesn't sysnthesize:

eight_bit_result &lt;= std_logic_vector(to_unsigned(character'pos(some_integer), 8));


ISE 14.7 breaks with a vague error caused by some header file. Even if it did work, it wouldn't work for values outside of 0-255. What is the right way to do this?

EDIT:

I wrote a quick and dirty function to cover integer values 0-9999. It needs no clocked process, no extra entity, etc. The proposed answers so far seem overly complicated.

function get_ascii_array_from_int(i : integer range 0 to 9999) return char_array is
        variable result : char_array(0 to 3) := (x""30"", x""30"", x""30"", x""30""); -- 0000
    begin
        if i &gt;= 0 then
            if i &lt; 1000 then
                result(0) := x""30""; -- 0
                result(1 to 3) := get_ascii_array_from_int_hundreds(i);
            elsif i &lt; 2000 then
                result(0) := x""31""; -- 1
                result(1 to 3) := get_ascii_array_from_int_hundreds(i-1000);
            elsif i &lt; 3000 then
                result(0) := x""32""; -- 2
                result(1 to 3) := get_ascii_array_from_int_hundreds(i-2000);
            elsif i &lt; 4000 then
                result(0) := x""33""; -- 3
                result(1 to 3) := get_ascii_array_from_int_hundreds(i-3000);
            elsif i &lt; 5000 then
                result(0) := x""34""; -- 4
                result(1 to 3) := get_ascii_array_from_int_hundreds(i-4000);
            elsif i &lt; 6000 then
                result(0) := x""35""; -- 5
                result(1 to 3) := get_ascii_array_from_int_hundreds(i-5000);
            elsif i &lt; 7000 then
                result(0) := x""36""; -- 6
                result(1 to 3) := get_ascii_array_from_int_hundreds(i-6000);
            elsif i &lt; 8000 then
                result(0) := x""37""; -- 7
                result(1 to 3) := get_ascii_array_from_int_hundreds(i-7000);
            elsif i &lt; 9000 then
                result(0) := x""38""; -- 8
                result(1 to 3) := get_ascii_array_from_int_hundreds(i-8000);
            else
                result(0) := x""39""; -- 9
                result(1 to 3) := get_ascii_array_from_int_hundreds(i-9000);
            end if;
        else
            result := (x""6e"", x""65"", x""67"", x""23""); -- ""neg#"" 
        end if;

        return result;

    end get_ascii_array_from_int;


As you may have guessed there are three other methods: get_ascii_array_from_int_hundreds
get_ascii_array_from_int_tens
get_ascii_array_from_int_ones

Say what you will about the this function but keep in mind that it produces the correct result when I need it, not several cycles later, and is simple and straightforward. I can easily expand it to cover negative numbers and larger numbers.","Is it an absolute requirement to output in decimal?
Hexadecimal output is the way to go if you want efficiency.
To crete hexadecimal output, you just split the integer up in groups of 4 bits, and convert each group to ASCII chars 0-F.

Converting a int to decimal ASCII representation is a computationaly heavy operation, as it requires many divisions.

But if this is what you need, one of the more efficient way to do it would be to create a state-machine which calculates one digit each clock cycle. The state machine needs to perform the following operations each clock cycle:


Divide integer X by 10 and store result back in X.
Calculate remainder.
Produce ASCII digit by adding x'30' to the remainder.


The statemachine would have to run for 10 clock cycles to convert a 32bit integer to ASCII decimal.",,,,,
Whether combinational circuit will have less frequency of operation than sequential circuit?,"I have designed an algorithm-SHA3 algorithm in 2 ways - combinational
and sequential.
The sequential design that is with clock when synthesized giving design summary as 

Minimum clock period 1.275 ns and Maximum frequency 784.129 MHz.

While the combinational one which is designed without clock and has been put between input and output registers is giving synthesis report as  

Minimum clock period 1701.691 ns and Maximum frequency 0.588 MHz.

so i want to ask is it correct that combinational will have lesser frequency than sequential?

As far as theory is concerned combinational design should be faster than sequential. But the simulation results I m getting for sequential is after 30 clock cycles where as combinational there is no delay in the output as there is no clock. In this way combinational is faster as we are getting instant output but why frequency of operation of combinational one is lesser than sequential one. Why this design is slow can any one explain please?
The design has been simulated in Xilinx ISE

Now I have applied pipe-lining to the combinational logic by inserting the registers in between the 5 main blocks which are doing the computation. And these registers are controlled by clock so now this pipelined design is giving design summary as

clock period 1.575 ns and freq 634.924 MHz 

Min period 1.718 ns and freq 581.937. 

So now this 1.575 ns is the delay between any of the 2 registers , its not the propagation delay of entire algorithm so how can i calculate propagation delay of entire pipelined algorithm.","What you are seeing is pipelining and its performance benefits. The combinational circuit will cause each input to go through the propagation delays of the entire algorithm, which will take at up to 1701.691ns on the FPGA you are working with, because the slowest critical path in the combinational circuitry needed to calculate the result will take up to that long. Your simulator is not telling you everything, since a behavioral simulation will not show gate propagation delays. You'll just see the instant calculation of your combinational function in your simulation.

In the sequential design, you have multiple smaller steps, the slowest of which takes 1.275ns in the worst case. Each of those steps might be easier to place-and-route efficiently, meaning that you get overall better performance because of the improved routing of each step. However, you will need to wait 30 cycles for a result, simply because the steps are part of a synchronous pipeline. With the correct design, you could improve this and get one output per clock cycle, with a 30-cycle delay, by having a full pipeline and passing data through it at every clock cycle.",,,,,
Matlab System generator: error with black box,"I using Xilinx system generator blocks in Matlab.

I simply using only a black box with a gateway in and gateway out.

The code for the black box is very simple and work correctly with ISE design suite

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.ALL;

entity test44_vhdl is
    Port ( row : in  std_logic_vector (1 downto 0);
           slice : out  std_logic_vector (3 downto 0));
end test44_vhdl;

architecture Behavioral of test44_vhdl is

type oneD is array (1 to 3) of integer range 0 to 15;
constant table: oneD := (3, 9, 13);

begin

    slice &lt;= std_logic_vector(to_unsigned(table(to_integer(unsigned(row))), slice'length));

end Behavioral;


but unfortunately it doesn't work with the matlab system generator.

I got the following error message 

Exception: ISE Simulator Simulation failed during initialization.


can any one help me what is the wrong with this code and what change should I do so the model work correctly  ","after I checked the problem several times, I found the the error, is that, there is no value assigned to the array table when the input is ""00""

So, the only changed that should I do, is to add a value to array at 0

type oneD is array (0 to 3) of integer range 0 to 15;
constant table: oneD := (3, 9, 13, 6);


now the model work correctly.",,,,,
What does <= operator do in this code?,"module counter (clk,rst,enable,count);
input clk, rst, enable;
output [3:0] count;
reg [3:0] count;

always @ (posedge clk or posedge rst)
if (rst) begin
  count &lt;= 0;
end else begin : COUNT
  while (enable) begin
    count &lt;= count + 1;
    disable COUNT;
  end
end

endmodule


(Source: http://www.asic-world.com/verilog/verilog_one_day2.html#While)

From what I have learnt, &lt;= is a relational operator and it will return 1 if true and 0 if false, but where does it return in this code?","In the context of your code, &lt;= is not a relational operator, it is an assignment operator. There are two types of assignment in Verilog:


blocking : =
non-blocking : &lt;=


In a Verilog design, you


always use blocking assignments for combinational logic
always use non_blocking assignments for sequential logic


If you do not, you simulation will be indeterminate - it will not necessarily behave the same way every time you run it. Which, of course, is not good.

So, why is that? Well, to start you must learn that Verilog has 4 scheduling regions:

from prev time step
        |
      ACTIVE
        |
     INACTIVE
        |
       NBA
        |
    POSTPONED
        |
        V
 to next time step


Blocking assignments are executed in the ACTIVE region. However, while the right-hand side of a non-blocking assignment is evaluated in the ACTIVE region, the assignment does not occur until the NBA region. This is key to why you need to use them for sequential logic.

So, why do you need to use non-blocking assignments for sequential logic? The reason is because the delay between evaluation of the right-hand side and assignment of the left hand side enables a Verilog simulation to be determinate, ie to behave the same way every time you run it. This delay means that the behaviour of the simulation does not depend on the order in which the always blocks are executed, which it would if only blocking assignments were used. 

A simple analogy to the delay between evaluating the right-hand side of a non-blocking assignment and assigning the left-hand side is the clock-to-Q delay of a real flip-flop. In a real flip-flop, there is always a small delay (clock-to-Q delay) between the D input being sampled (by the clock) and the Q output being driven. This is vital to the correct operation of real sequential logic. For example, if there were no clock-to-Q delay in a real flip-flop instead of it taking exactly 4 clocks for the D input of the first flip-flop in a 4-stage shift register to get to the Q output of the fourth flip-flop, it could take any number of clocks between 1 and 4: its behaviour would also be indeterminate.",,,,,
How to wire up modules and pass value,"module container(x1, x2, x3, NUMBER);

input x1, x2, x3;
output NUMBER;
wire w0, w1;

dec_counter U1 (x1, x2, x3, w0, w1);
doz_counter U2 (w1, w0, NUMBER);


endmodule


module dec_counter(clk, reset, clk_enable, counter, terminal);

    input clk;
    input reset;
    input clk_enable;
    output reg [3:0] counter;
    output reg terminal;



always @(posedge clk, posedge clk_enable, posedge reset)
        if(reset)
        begin
            terminal &lt;= 1;
            counter &lt;= 0;
        end
        else if(clk &amp;&amp; clk_enable)
            if(counter &lt; 9)
            begin
                terminal &lt;= 1;
                counter &lt;= counter + 1; 
            end           
            else
            begin
                terminal &lt;= 1;
                counter &lt;= 0;
            end  
endmodule



module doz_counter(dozens, unity, number);

input dozens;
input unity;
output reg [7:0] number;

initial begin
    number = 8'd0;
end    

always @(posedge dozens)
    if(dozens)
        number &lt;= number + 1;

endmodule


Hello! I'm new to verilog, and i have my first problem. I have module dec_counter which counts from 0 to 9. When it gets to 9+1 it shows 0 and set ""output terminal"" to 1. Now i wanted to pass that value to my next module doz_counter as ""input dozens"". I've tried wiring, as you can see in module container but in my simulation dozens is always X, even when terminal is 1.

I feel like i'm making some critical design mistakes.","The code you posted works fine. Refer the following figure for port connection rules. The output port can be any of reg or wire, but input port is always a wire.



A couple of mistakes are listed as follows:

You have connected an 4-bit port, reg [3:0] counter; in dec_counter module to single bit port, w0 in container module. This shall result in port connection width mismatch.

wire [3:0] w0;
wire w1;
// ...


Similarly, single bit port NUMBER in container module is connected to 8-bit port number in doz_counter module. This shall result in port connection width mismatch.

output [7:0] NUMBER;
//...


Also, the value of terminal upon reset might be zero. The if-else conditions are driving the same value of terminal. It should have different values of terminal as terminal &lt;= 1 and terminal &lt;= 0; respectively.

Here is a testbench for your code for reference:

module top();

bit x1, x2, x3;
bit [7:0] NUMBER;

container c(x1, x2, x3, NUMBER);

always #5 x1 = ~x1;

initial
begin
#6 x2 = 1;
#6 x2 = 0; x3 = 1;
#100 $finish;
end

endmodule 
",,,,,
How to delete trailing whitespace in Verilog Mode Emacs,"I'm trying to delete trailing whitespaces in Verilog Mode. I have customized Verilog mode with the menu : ""Verilog --> Customize Verilog Mode..."".

Trailing whitespaces are not removing when editing or saving a Verilog file. I've tried somme commands 'add hook' but still no success.
What am I missing ?

That's my .emacs (Emacs 24.3.1) : 

`(custom-set-variables
;; custom-set-variables was added by Custom.
;; If you edit it by hand, you could mess it up, so be careful.
;; Your init file should contain only one such instance.
;; If there is more than one, they won't work right.
'(cua-mode t nil (cua-base))
'(global-whitespace-mode t)
'(indent-tabs-mode nil)
'(show-paren-mode t)
'(verilog-align-ifelse t)
'(verilog-auto-delete-trailing-whitespace t)
'(verilog-auto-endcomments nil)
'(verilog-auto-hook (quote (delete-trailing-whitespace)))
'(verilog-auto-indent-on-newline t)
'(verilog-auto-lineup (quote declarations))
'(verilog-auto-newline nil)
'(verilog-indent-level 2)
'(verilog-indent-level-behavioral 2)
'(verilog-indent-level-declaration 2)
'(verilog-indent-level-directive 2)
'(verilog-indent-level-module 2)
'(verilog-indent-lists nil)
'(verilog-tab-always-indent t))
(custom-set-faces
;; custom-set-faces was added by Custom.
;; If you edit it by hand, you could mess it up, so be careful.
;; Your init file should contain only one such instance.
;; If there is more than one, they won't work right.
)`
","In general, not just for Verilog, I use the below clean up before save:

;; Before save
;; (add-hook 'before-save-hook 'delete-trailing-whitespace)
(add-hook 'before-save-hook 'whitespace-cleanup)


You can try enabling 'delete-trailing-whitespace only, if the 'whitespace-cleanup does too much. ",,,,,
XOR signal in verilog,"I have a signal like this for example:
wire [18:0] A; 

I need to XOR it with itself with multiple XOR gates that have up to 4 inputs. So this signal would be broken down like this:

XOR the first 4 bits [3:0] 
XOR the next 4 bits [7:4] 
XOR the next 4 bits [11:8] 
XOR the next 4 bits [15:12] 
XOR the remaining 3 bits together [18:16]


How do I XOR a signal with itself like this? Also, what is the best way to do this?","There are a couple of ways of doing this. One way could be to build a 4-input XOR module, and then instantiate multiple copies.

module myXOR4 ( input a, input b, input c, input d, output f);
    assign f = a ^ b ^ c ^ d; // ^ is the XOR operator
endmodule
// ...

myXOR4 xor1 (A[0],A[1],A[2],A[3],out[0]);
myXOR4 xor2 (A[4],A[5],A[6],A[7],out[1]);
// etc


Another way would be to use a for-loop. This won't work with all the cases, since you don't have an evenly-divisible number of wires. 

reg [4:0] out;
integer i;
always@(*) begin
    for (i=0; i&lt;4; i=i+1) 
        out[i]=A[4*i] ^ A[4*i+1] ^ A[4*i+2] ^ A[4*i+3];
    out[4] = A[18] ^ A[17] ^ A[16];
end


There are some other tricks (like 0-padding the upper-bits of A to make it evenly divisible, which makes the loops simpler) but they'll all end up with the same result, so this should be enough to get you started.",,,,,
Can't resolve multiple constant,"I'm trying to create a FSM but I'm getting the error can't resolve multiple constant drivers

Here's my code:

 library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    library work;
    use work.all;

    entity fsm is 
        port(
            reset,clk : in std_logic;
            dataout: out std_logic_vector(7 downto 0)
        );
    end entity fsm;

    architecture bhv_fsm of fsm is
    type FSM_TYPE is (standby, ready, encryption, decryption);
    signal pre_state, next_state : FSM_TYPE;
    signal cmd, cancel, busy, acquirekey : std_logic;
    signal controller: std_logic_vector(3 downto 0);
    signal dout: std_logic_vector(7 downto 0);
    begin
    controller &lt;= cmd &amp; cancel &amp; busy &amp; acquirekey;
    P1: process(clk, reset) is

    begin 
        dataout &lt;= ""00000000""; 
        if reset='1' then
        next_state &lt;= standby;
        elsif rising_edge(clk) then
            pre_state &lt;= next_state;
        end if;
    end process P1; 

    LC1_LC2: process(pre_state, next_state) is
    variable timer: integer :=0;
    begin
    dataout &lt;= (others =&gt; '0');
    next_state &lt;= pre_state;
    case pre_state is
        when standby =&gt; 
            if (controller = ""0000"") then
            next_state &lt;= ready;
            end if;

        when ready =&gt;
            if(timer&lt;10) then
                if (controller = ""1000"") then
                next_state &lt;= encryption;
                timer:=0;
                controller &lt;= ""0010"";
                timer:=timer+1;
                elsif (controller = ""0000"") then
                next_state &lt;= decryption;
                timer:=0;
                controller &lt;= ""0010"";
                end if;
            timer:=timer+1;
            else
            next_state &lt;= standby;
            end if;

            when encryption =&gt;
                if(controller = ""1110"") then
                    next_state &lt;= ready;
                elsif(controller = ""1011"") then
                    dataout &lt;= dout;
                    next_state &lt;= ready;
                end if; 
            -- cmd cancel busy acquire

            when decryption =&gt;
                if(controller = ""0110"")then
                    next_state &lt;= ready;
                elsif(controller = ""0011"") then
                    dataout &lt;= dout;
                    next_state &lt;= ready;
                end if; 

    end case;           
    end process LC1_LC2;
    end architecture bhv_fsm;


These are the errors:


  Error (10028): Can't resolve multiple constant drivers for net
  ""next_state.standby"" at fsm.vhd(33)
  
  Error (10029): Constant driver at fsm.vhd(22)
  
  Error (10028): Can't resolve multiple constant drivers for net
  ""next_state.ready"" at fsm.vhd(33)
  
  Error (10028): Can't resolve multiple constant drivers for net
  ""next_state.encryption"" at fsm.vhd(33)
  
  Error (10028): Can't resolve multiple constant drivers for net
  ""next_state.decryption"" at fsm.vhd(33)
  
  Error (10028): Can't resolve multiple constant drivers for net
  ""controller[3]"" at fsm.vhd(21)
  
  Error (10029): Constant driver at fsm.vhd(33)
  
  Error (10028): Can't resolve multiple constant drivers for net
  ""controller[2]"" at fsm.vhd(21)
  
  Error (10028): Can't resolve multiple constant drivers for net
  ""controller[1]"" at fsm.vhd(21)
  
  Error (10028): Can't resolve multiple constant drivers for net
  ""controller[0]"" at fsm.vhd(21)
","When you synthesise VHDL, each process becomes a lump of hardware that drives any signal that is driven by that process. If you drive a signal from more than one process then you end up with more than one lump of hardware driving that signal; that signal is driven from more than one place. In other words, you have a short circuit.

This is usually not the behaviour you want and is usually not behaviour that logic synthesisers are prepared to create. This is the case with your code:

You have three concurent processes in your code. This one:

controller &lt;= cmd &amp; cancel &amp; busy &amp; acquirekey;


which drives the signal controller; this one:

P1: process(clk, reset) is


which drives the signals dataout, next_state and pre_state; and this one:

LC1_LC2: process(pre_state, next_state) is


which also drives the signals controller, next_state and data_out. 

So, the signals controller, next_state and data_out are driven from more than one process; these signals will be driven by more than one lump of hardware. You synthesiser doesn't likes this, I'm pretty sure this isn't want you want. 

You're not writing software. VHDL is a hardware description language. You need to think more hardware.

I don't know your design intent; I can only ""suspect"". But, I suspect you don't need this line at all:

    dataout &lt;= ""00000000""; 


and I suspect these lines:

    if reset='1' then
    next_state &lt;= standby;


should be:

    if reset='1' then
    pre_state &lt;= standby;


I suspect you don't need this line at all:

 controller &lt;= cmd &amp; cancel &amp; busy &amp; acquirekey;
",,,,,
Systemverilog: Is there any way to pass in a module name into a module?,"Is there any way to pass in something that can be used for a module name (for a submodule) into a module? Does verilog consider the module name to be a special entity, that cant be a type or string?","Module names are not parameterizable like data types. However, SystemVerilog has a configuration mechanism that allows you to choose which module definitions are bound to which module instantiations. See Section 33 of the 1800-2012 LRM.",,,,,
cyclic shift using d flip flop vhdl,"I am trying to design a  shiftier using d flip flop as a component.. 
The flip flop works fine.. but the shifter output remains undefined ,, how should I fix it? 
this is the shiftier code 

entity cyclicSR is -- 3-bit cyclic shift register
 port (CLK: in bit; Qout: out bit_vector(1 to 3) ) ;
 end cyclicSR;
 architecture cyclicSR3 of cyclicSR is
 component DFF
 port (D, CLK: in bit; Q: out bit);
 end component;
 signal Q1, Q2, Q3: bit;
 begin
 FF1: DFF port map (Q3, CLK, Q1);
 FF2: DFF port map (Q1, CLK, Q2);
 FF3: DFF port map (Q2, CLK, Q3);
 Qout &lt;= Q1&amp;Q2&amp;Q3;
 end cyclicSR3;


Should I assign a value to q3?? how can i do that?","While you didn't provide a Minimal, Complete, and Verifiable example the problem is visible in your code example.

You need to provide an initial value or 'set' to at least one flipflop. Otherwise it happily shifts all zeros cyclically - the default value for type BIT.

Alternatively you could jam an input into say the first flip flop when all three are 0:

architecture jam of cyclicsr is

    component dff is
        port (
             d, clk: in  bit; 
             q:      out bit
        );
    end component;

     component or2 is 
         port (
             a:     in  bit;
             b:     in  bit;
             y:     out bit
         );
     end component;

     component nor3 is
         port (
             a:     in  bit;
             b:     in  bit;
             c:     in  bit;
             y:     out bit
         );
     end component;

     signal q1, q2, q3: bit;

     signal inp:        bit;   -- added
     signal all_zero:   bit;

begin

 ff1: dff port map (inp, clk, q1);  -- was q3
 ff2: dff port map (q1, clk, q2);
 ff3: dff port map (q2, clk, q3);

     qout &lt;= q1 &amp; q2 &amp; q3;

orgate:
    or2 
        port map (
            a =&gt; all_zero,
            b =&gt; q3,
            y =&gt; inp
        );
allzero:
    nor3
        port map (
            a =&gt; q1,
            b =&gt; q2,
            c =&gt; q3,
            y =&gt; all_zero
        );

end architecture;


And that gives:



And note you can set any pattern you want with an initial value or with the a single inverter turn the shift register into a Johnson counter.",,,,,
event and transaction in vhdl(timing diagram),"I tried to solve the problem, but I got a different table than the table that xilinx shows. I attatched both my answer and real answer. Xilinx shows that ""out"" is 'U' until 36ns, after 36ns, it is '1'. Can anyone help me about why the ""out"" graphics is not assigned any value before 36ns?(I think it should be assigned first at 20 ns).
my answer
question","This turned out to be a really good question. I initially thought you had done something wrong when simulating, but then I ran my own simulation and got the same result.

It turns out that the a &lt;= b after x assignment uses something called the ""inertial time model"" by default. In this mode scheduled events will be cancelled if b changes again before x time has passed. The purpose is to filter pulses shorter than the specified delay. In your case this is what the simulator will do:


At t=0, out is scheduled to change to 1 at t=20.
At t=12, tem1 or tem2 changes to 0. The scheduled change at t=20 is cancelled and a new change to 0 is scheduled at t=32.
At t=16, tem1 or tem2 changes back to 1. Again the scheduled change is cancelled and a new change is scheduled at t=36.
After this tem1 or tem2 remains at 1, so the change at t=36 is executed and out finally changes from U.


You can change to the ""transport delay model"" using out &lt;= transport tem1 or tem2 after 20 ns; In this case your drawn waveform will match with simulation.",,,,,
"Designed memory unit doesn't work, cannot read memory 0","module InstructionMemory (input clk,
                          input[31:0] PC, 
                          output reg[31:0] Inst_out
                        );

  reg[31:0] instructions [0:2**32-1];

  initial 
    $readmemb(""InstructionMemory.txt"",instructions);

  always@(posedge clk)
  begin 
    Inst_out = instructions[PC]; 
  end

endmodule


This is my InstructionMemory.txt's text:


  00000000000000010000000011110000
","Assumed that, 
You have typo at 


  reg[31:0] instructions [0: 2**32 -1];


It should be,


  reg[31:0] instructions [0: (2*32) -1];


Because 2**32 = 4294967296, It can not be this much long.

After that I modified your InstructionMemory.txt file and run the simulation it works fine, see below code.

Verilog Code with Testbench:

module InstructionMemory (input clk,
                          input[31:0] PC, 
                          output reg[31:0] Inst_out
                        );

  reg [31:0] instructions [0 : (2*32) -1];
  initial 
  begin
    $readmemb(""InstructionMemory.txt"",instructions);
  end

  always@(posedge clk)
  begin 
    Inst_out &lt;= instructions[PC]; 
  end

endmodule

module tb;
reg clk;
reg [31:0] PC;
wire [31:0] Inst_out;
integer j;

InstructionMemory InstructionMemory_u0(clk, PC, Inst_out);

always #5 clk = ~clk;

initial
begin
  $monitor(""PC = %d and Inst_Out = %d"", PC, Inst_out);
  clk = 1'b0;
  PC = 32'b0;
  for(j=0;j&lt;64;j=j+1)
  begin
    @(posedge clk) 
    PC = j;
  end
  #100 $finish;
end


endmodule


Your memory InstructionMemory.txt

00000000000000000000000000000000
00000000000000000000000000000001
00000000000000000000000000000010
00000000000000000000000000000011
00000000000000000000000000000100
00000000000000000000000000000101
00000000000000000000000000000110
00000000000000000000000000000111
00000000000000000000000000001000
00000000000000000000000000001001
00000000000000000000000000001010
00000000000000000000000000001011
00000000000000000000000000001100
00000000000000000000000000001101
00000000000000000000000000001110
00000000000000000000000000001111
00000000000000000000000000010000
00000000000000000000000000010001
00000000000000000000000000010010
00000000000000000000000000010011
00000000000000000000000000010100
00000000000000000000000000010101
00000000000000000000000000010110
00000000000000000000000000010111
00000000000000000000000000011000
00000000000000000000000000011001
00000000000000000000000000011010
00000000000000000000000000011011
00000000000000000000000000011100
00000000000000000000000000011101
00000000000000000000000000011110
00000000000000000000000000011111
00000000000000000000000000100000
00000000000000000000000000100001
00000000000000000000000000100010
00000000000000000000000000100011
00000000000000000000000000100100
00000000000000000000000000100101
00000000000000000000000000100110
00000000000000000000000000100111
00000000000000000000000000101000
00000000000000000000000000101001
00000000000000000000000000101010
00000000000000000000000000101011
00000000000000000000000000101100
00000000000000000000000000101101
00000000000000000000000000101110
00000000000000000000000000101111
00000000000000000000000000110000
00000000000000000000000000110001
00000000000000000000000000110010
00000000000000000000000000110011
00000000000000000000000000110100
00000000000000000000000000110101
00000000000000000000000000110110
00000000000000000000000000110111
00000000000000000000000000111000
00000000000000000000000000111001
00000000000000000000000000111010
00000000000000000000000000111011
00000000000000000000000000111100
00000000000000000000000000111101
00000000000000000000000000111110
00000000000000000000000000111111


Simulation:

QuestaSim-64 qverilog 10.4 Compiler 2014.12 Dec  2 2014
Start time: 10:18:08 on May 16,2016
qverilog mem.v 
-- Compiling module InstructionMemory
-- Compiling module tb

Top level modules:
    tb
Reading pref.tcl

# 10.4

# vsim -lib work tb -c -do ""run -all; quit -f"" -appendlog -l qverilog.log -vopt 
# ** Note: (vsim-8009) Loading existing optimized design _opt1
# //  Questa Sim-64
# //  Version 10.4 linux_x86_64 Dec  2 2014
# //
# //  Copyright 1991-2014 Mentor Graphics Corporation
# //  All Rights Reserved.
# //
# //  THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY INFORMATION
# //  WHICH IS THE PROPERTY OF MENTOR GRAPHICS CORPORATION OR ITS
# //  LICENSORS AND IS SUBJECT TO LICENSE TERMS.
# //  THIS DOCUMENT CONTAINS TRADE SECRETS AND COMMERCIAL OR FINANCIAL
# //  INFORMATION THAT ARE PRIVILEGED, CONFIDENTIAL, AND EXEMPT FROM
# //  DISCLOSURE UNDER THE FREEDOM OF INFORMATION ACT, 5 U.S.C. SECTION 552.
# //  FURTHERMORE, THIS INFORMATION IS PROHIBITED FROM DISCLOSURE UNDER
# //  THE TRADE SECRETS ACT, 18 U.S.C. SECTION 1905.
# //
# Loading work.tb(fast)
# run -all
# PC =          0 and Inst_Out =          x
# PC =          0 and Inst_Out =          0
# PC =          1 and Inst_Out =          0
# PC =          2 and Inst_Out =          1
# PC =          3 and Inst_Out =          2
# PC =          4 and Inst_Out =          3
# PC =          5 and Inst_Out =          4
# PC =          6 and Inst_Out =          5
# PC =          7 and Inst_Out =          6
# PC =          8 and Inst_Out =          7
# PC =          9 and Inst_Out =          8
# PC =         10 and Inst_Out =          9
# PC =         11 and Inst_Out =         10
# PC =         12 and Inst_Out =         11
# PC =         13 and Inst_Out =         12
# PC =         14 and Inst_Out =         13
# PC =         15 and Inst_Out =         14
# PC =         16 and Inst_Out =         15
# PC =         17 and Inst_Out =         16
# PC =         18 and Inst_Out =         17
# PC =         19 and Inst_Out =         18
# PC =         20 and Inst_Out =         19
# PC =         21 and Inst_Out =         20
# PC =         22 and Inst_Out =         21
# PC =         23 and Inst_Out =         22
# PC =         24 and Inst_Out =         23
# PC =         25 and Inst_Out =         24
# PC =         26 and Inst_Out =         25
# PC =         27 and Inst_Out =         26
# PC =         28 and Inst_Out =         27
# PC =         29 and Inst_Out =         28
# PC =         30 and Inst_Out =         29
# PC =         31 and Inst_Out =         30
# PC =         32 and Inst_Out =         31
# PC =         33 and Inst_Out =         32
# PC =         34 and Inst_Out =         33
# PC =         35 and Inst_Out =         34
# PC =         36 and Inst_Out =         35
# PC =         37 and Inst_Out =         36
# PC =         38 and Inst_Out =         37
# PC =         39 and Inst_Out =         38
# PC =         40 and Inst_Out =         39
# PC =         41 and Inst_Out =         40
# PC =         42 and Inst_Out =         41
# PC =         43 and Inst_Out =         42
# PC =         44 and Inst_Out =         43
# PC =         45 and Inst_Out =         44
# PC =         46 and Inst_Out =         45
# PC =         47 and Inst_Out =         46
# PC =         48 and Inst_Out =         47
# PC =         49 and Inst_Out =         48
# PC =         50 and Inst_Out =         49
# PC =         51 and Inst_Out =         50
# PC =         52 and Inst_Out =         51
# PC =         53 and Inst_Out =         52
# PC =         54 and Inst_Out =         53
# PC =         55 and Inst_Out =         54
# PC =         56 and Inst_Out =         55
# PC =         57 and Inst_Out =         56
# PC =         58 and Inst_Out =         57
# PC =         59 and Inst_Out =         58
# PC =         60 and Inst_Out =         59
# PC =         61 and Inst_Out =         60
# PC =         62 and Inst_Out =         61
# PC =         63 and Inst_Out =         62
# PC =         63 and Inst_Out =         63
# ** Note: $finish    : mem.v(39)
#    Time: 735 ns  Iteration: 0  Instance: /tb
# End time: 10:18:09 on May 16,2016, Elapsed time: 0:00:01
# Errors: 0, Warnings: 0



  Your output is one cycle late due to flop used in Reading of Instruction.


If you really want to use 2**32 set of instruction, you have to declare memory for the same.

Edit:

Information about PC,
Let's take example of 8051, a real uController, where you find PC size 16 bits long. so it can access program addresses 0x0000 to 0xFFFF, a total of 64K bytes of code. However, not all members of the 8051 have the entire 64K bytes of on-chip ROM installed. It is for expandable memory usage.",,,,,
"Using If condition to do ""something"" once every 10 clock cycles. what if ""something"" takes more than 1 clock cycle?","I am working on some VHDL code that will be used (on an FPGA) to read in a 16 bit digital signal, do some processing, and then write out the 16 bit processed signal. Currently it is setup so it should read the input every 10 clock cycles, do some processing on the next clock cycle (it currently does nothing, just outputs the input) and then just increment the counter for the remaining 8 clock cycles. 

What happens if the processing takes longer than one clock cycle to complete (Which it will), will it continue until it finishes and stop the counter incrementing until it does? Or will the counter keep incrementing in parallel while it processes the signal? 

I will set it up such that the process completes before the 8 clock cycles are up (in time to be written to the output).

The pseudocode looks something like this:

Do (on rising clock edge):
if (n = 10) then
  n &lt;= 1;
  Output &lt;= ProcessedSignal;
  InputSignal &lt;= Input;
elsif (n = 1) then
  n &lt;= n + 1
  Output &lt;= Output;
  -- do some signal processing here (e.g. a filter)
  ProcessedSignal &lt;= InputSignal;
else
  n &lt;= n + 1;
  Output &lt;= Output;
  ProcessedSignal &lt;= ProcessedSignal;
end if;
","It all depends on how you write the code; any kind of behavior is possible. Your pseudocode is nearly valid VHDL and will do what you want if I understand you correctly. Here is a suggestion for real code: (without architecture/signal declarations, also missing reset)

process (clock)
begin
  if rising_edge(clock) then
    n &lt;= n + 1; -- default assignment

    if (n = 10) then
      n &lt;= 1; -- overrides default assignment
      Output &lt;= ProcessedSignal;
      InputSignal &lt;= Input;
    elsif (n = 1) then
      -- do some signal processing here (e.g. a filter)
      ProcessedSignal &lt;= InputSignal;
    elsif (n = 2) then
      -- do more processing
    end if;
  end if;
end process;


Note that there is no need to write a signal to itself in a clocked process, unless you want to make it explicit that the signal keeps its old value.",,,,,
how to out fixed point value in verilog?,"I'm trying to out the fixed point value in verilog.
Generally, I use like this method (I'don't know what it was called)
for example,

output = 0.248*5
output = ((0.248 &lt;&lt; 8) * 5 ) &gt;&gt; 8;


But in his case the output has only integer.

I want to get fixed point fraction part.

How to handle to out the fixed point value in verilog?","To calculate and display with 8 fractional bits:

integer out;

initial begin
  out = ((0.248 * 2**8) * 5 );
  $display(""%f"", $itor(out)*(2.0**-8.0));
end
",,,,,
Is it allowed to instantiate a module inside always_comb block in system verilog?,"Is it allowed to instantiate a module inside always_comb block in system verilog?

always_comb 
begin
   OR OR1 (.Y(A), .A(Z), 
end
","First of all, your code is incomplete. Obviously, a two-input OR gate requires three connections.

In verilog, when you are instantiating a module, that means you are adding extra hardware to the board.

This hardware must be added before simulation starts(i.e. at compile time). Here, you can not add/remove hardware at each clock pulse.

Once instantiated, the module is executed/checked for each timestamp of simulation, till the end.

So to execute any module, just instantiate it, providing the required inputs to it (and add the always block in the sub-module itself, if necessary).

// Simply instantiate module
OR OR1 (.Y(A), .A(Z), .B(M));


Either way, you can add a combinational block to the current module itself:

// Directly use ORing
always_comb begin
  A = Z | M;
end


More information on instantiation can be obtained from Verilog Module Instantiation, Instantiating Modules and Primitives, Structural Modelling links.",,,,,
Kind stuck on the output when the output overlap,"I am very new on verilog.
So this is my question:


  Implement 16 bits ALU with 16 bit register. This project should meet the following requirement.
  1.  Design a 16 bitALU :
  Design a 16 bit ALU that X as input (eg. A,B..) and produces one 16 bit result.The ALU should perform the following functions. 
  Minimum 5 operations for both ALU and LOGIC.
  2.  Design a 16x16 bit register file.
  3.  Design a control unit.


So my plan is to make a bunch of module that have operations in each module. Then i gather it at the test bench. But the problem is right now. The output seems to overlap and become red and x.

This is my Add module.

module Add(A,B,Y,S,clk,enb);
  parameter BITS=8;
  input clk,enb;
  input [BITS - 5:0] S;
  input [BITS - 1:0] A ,B;
  output [BITS - 1:0] Y;
  reg [BITS - 1:0] Y;

  always @(posedge clk)
  begin
  if
    ((enb==1) || (S == 000))
  begin
   assign Y = A + B;

  end
  end

endmodule


Tolak module (Minus module)

module Tolak(A,B,Y,S,clk,enb);
  parameter BITS=8;
  input clk,enb;
  input [BITS - 5:0] S;
  input [BITS - 1:0] A ,B;
  output [BITS - 1:0] Y;
  reg [BITS - 1:0] Y;

   always @(posedge clk)
begin
  if
    ((enb==1) || (S == 010))
  begin
  assign Y = A - B;

  end
  end
endmodule


Darab module (Multiplication module)

module Darab(A,B,Y,S,clk,enb);
  parameter BITS=8;
  input clk,enb;
  input [BITS - 5:0] S;
  input [BITS - 1:0] A ,B;
  output [BITS - 1:0] Y;
  reg [BITS - 1:0] Y;

  always @(posedge clk)
    begin
  if
    ((enb==1) || (S == 011))
begin
     assign Y = A * B;
  end
  end

endmodule


GateOr module

module GateOr(A,B,Y,S,clk,enb);
  parameter BITS=16;
  input clk,enb;
  input [BITS - 14:0] S;
  input [BITS - 1:0] A ,B;
  output [BITS - 1:0] Y;
  reg [BITS - 1:0] Y;

  always @(posedge clk)
  begin
  if
    ((enb==1) || (S == 011))
  begin
   assign Y = A | B ;

  end
  end

endmodule


GateAnd module

module GateAnd(A,B,Y,S,clk,enb);
  parameter BITS=16;
  input clk,enb;
  input [BITS - 14:0] S;
  input [BITS - 1:0] A ,B;
  output [BITS - 1:0] Y;
  reg [BITS - 1:0] Y;

  always @(posedge clk)
begin
  if
    ((enb==1) || (S == 100))
  begin
  assign Y = A &amp; B;

  end
end

endmodule


AND THIS IS MY TEST BENCH

module Maintb (); 
parameter SIZE=8;
reg clk, enb ;
reg [SIZE-6:0] S; 
reg[SIZE-1:0] A,B; 
wire[SIZE-1:0] Y; 

initial 
begin
    clk = 1'b0; enb = 1'b0;
end
// generate clock
always 
begin
    #(10) clk = !clk;
end
  always begin 
    //#(10);
    #10; enb = 1'b1; A=00000001; B=00000000; S=000; //add
    #(10); enb = 1'b0; 
    #10; enb = 1'b1; A=00000001; B=00000000; S=001; //tolak
    #(10); enb = 1'b0; 
    #10; enb = 1'b1; A=00000001; B=00000000; S=010; //darab
    #(10); enb = 1'b0; 
    #10; enb = 1'b1; A=00000001; B=00000000; S=011; //or
    #(10); enb = 1'b0; 
    #10; enb = 1'b1; A=00000001; B=00000000; S=100; //and
    //#(10);
  end

defparam dut.BITS = SIZE;
defparam dut1.BITS = SIZE;
defparam dut2.BITS = SIZE;
defparam gate.BITS = SIZE;
defparam gate1.BITS = SIZE;
Add dut (A,B,Y,S,clk,enb); //000
Tolak dut1 (A,B,Y,S,clk,enb); //001
Darab dut2 (A,B,Y,S,clk,enb); //010
GateOr gate (A,B,Y,S,clk,enb); //011
GateAnd gate1 (A,B,Y,S,clk,enb);//100
Endmodule
","Take care of following points while HDL coding:


Use &lt;= for sequential hardware and = for combinational hardware  
Never use assign inside always or visa-versa
Instantiate module in proper way, i.e


&lt;module name&gt; #(parameter &lt;paramters_list&gt;) &lt;instant_name &gt;


Specify input transition wrt to clock edges, avoid use of explicit use of # delay  


Hierarchical topology of Blocks:



You can see in Image, ALU is top level entity and contain sub-modules, which are connected to each other or shared signals in top.

Testbench is having highest level top where instance of DUT (Designed Top is to be TESTED)-Design Under Test.

Which basically stimulate signal into the DUT and get response from the same.

Make sure that you are not driving same signal from multiple modules, like in your case it is Y which is driven by add, sub, mul, AND and OR module of ALU, which needs to be separate.

Removed clk signal because combinational circuit does'not require clk at all.

See your clean code with tb, modify it as mentioned upward:

module Add #(parameter BITS=8)(A,B,Y,S,enb);
  input wire enb;
  input wire [2:0] S;
  input wire [BITS - 1:0] A ,B;
  output wire [BITS - 1:0] Y;

  assign Y = (A + B) &amp; {BITS{enb &amp; (S == 3'b000)}};

endmodule


module Tolak #(parameter BITS=8) (A,B,Y,S,enb);
  input enb;
  input [2:0] S;
  input [BITS - 1:0] A ,B;
  output wire [BITS - 1:0] Y;

  assign Y = (A - B) &amp; {BITS{enb &amp; (S == 3'b001)}};

endmodule

module Darab  #(parameter BITS=8) (A,B,Y,S,enb);
  input enb;
  input [2:0] S;
  input [BITS - 1:0] A ,B;
  output wire  [BITS - 1:0] Y;

  assign Y = (A * B) &amp; {BITS{enb &amp; (S == 3'b010)}}; // truncated to 8 bit only

endmodule

module GateOr  #(parameter BITS=8) (A,B,Y,S,enb);
  input enb;
  input [2:0] S;
  input [BITS - 1:0] A ,B;
  output wire[BITS - 1:0]  Y;

  assign Y = (A | B) &amp; {BITS{enb &amp; (S == 3'b011)}}; // truncated to 8 bit only

endmodule

module GateAnd  #(parameter BITS=8) (A,B,Y,S,enb);
  input enb;
  input [2:0] S;
  input [BITS - 1:0] A ,B;
  output wire [BITS - 1:0] Y;

  assign Y = (A &amp; B) &amp; {BITS{enb &amp; (S == 3'b100)}}; // truncated to 8 bit only

endmodule


module Maintb (); 
parameter SIZE=8;
reg clk, enb ;
reg [2:0] S; 
reg [SIZE -1:0] A,B; 
wire [SIZE -1:0] Y,Y1,Y2,Y3,Y4,Y5; 

Add #(SIZE) dut (A,B,Y1,S,enb); //000
Tolak #(SIZE) dut1 (A,B,Y2,S,enb); //001
Darab #(SIZE) dut2 (A,B,Y3,S,enb); //010
GateOr #(SIZE) gate (A,B,Y4,S,enb); //011
GateAnd #(SIZE) gate1 (A,B,Y5,S,enb);//100

assign Y = Y1 | Y2 | Y3 | Y4 | Y5;

initial 
begin
    clk = 1'b0; 
    enb = 1'b0;
    enb = 1'b0; A=8'b0000_0000; B=8'b0001_0000; S=3'b000; 
end

// generate clock
always #10 clk = ~clk;

initial
begin 
  @(posedge clk); 
  @(posedge clk); 
  @(posedge clk); 
  @(posedge clk); 
  @(posedge clk); enb = 1'b1; A=8'b0000_0001; B=8'b0000_0010; S=3'b000; //add
  @(posedge clk); enb = 1'b0; 
  @(posedge clk); enb = 1'b1; A=8'b0000_0011; B=8'b0010_0000; S=3'b001; //tolak
  @(posedge clk); enb = 1'b0; 
  @(posedge clk); enb = 1'b1; A=8'b0000_1001; B=8'b0000_0000; S=3'b010; //darab
  @(posedge clk); enb = 1'b0; 
  @(posedge clk); enb = 1'b1; A=8'b0010_0001; B=8'b0100_0000; S=3'b011; //or
  @(posedge clk); enb = 1'b0; 
  @(posedge clk); enb = 1'b1; A=8'b1000_0001; B=8'b0000_0000; S=3'b100; //and
  @(posedge clk); enb = 1'b0; 
  @(posedge clk); enb = 1'b0; A=8'b0000_0000; B=8'b0001_0000; S=3'b000; //and
  #100 $finish;
end

initial
begin
  $monitor(""clk %b  A-%b B-%b Y-%b S-%b enb-%b"",clk, A, B, Y, S, enb);
end

endmodule


Simulation:

",,,,,
"Can't infer register for ""RunStop"" because its behavior does not match any supported register model ( Quartus II )","Errors: 10821,10822...and many more..please help..(separate module)


  Error (10821): HDL error at AxisCounter.vhd(48): can't infer register for ""RunStop"" because its behavior does not match any supported register model
  Error (10821): HDL error at AxisCounter.vhd(39): can't infer register for ""RunStop"" because its behavior does not match any supported register model
  Error (10821): HDL error at AxisCounter.vhd(38): can't infer register for ""RunStop"" because its behavior does not match any supported register model
  Error (10822): HDL error at AxisCounter.vhd(35): couldn't implement registers for assignments on this clock edge
  Error (10822): HDL error at AxisCounter.vhd(38): couldn't implement registers for assignments on this clock edge
  Error (12152): Can't elaborate user hierarchy ""AxisCounter:\Check:0:AxisCounter_X""
  Error: Quartus II 64-Bit Analysis &amp; Synthesis was unsuccessful. 6 errors, 9  warnings
      Error: Peak virtual memory: 486 megabytes
      Error: Processing ended: Sun May 22 18:19:32 2016
      Error: Elapsed time: 00:00:01
      Error: Total CPU time (on all processors): 00:00:01
      Error (293001): Quartus II Full Compilation was unsuccessful. 8 errors, 9 warnings  


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;


entity AxisCounter is
    Port ( 
              BASECLK_IN      :  in   STD_LOGIC;
             START_STOP     :  in   STD_LOGIC;
             RESET_COUNT        :  in   STD_LOGIC;
              DIVISOR           :  in   Integer ;
              STEPS             :  in   Integer ;
             COUNT_STATUS   :  out  STD_LOGIC;
           AXISCLK_OUT      :  out  STD_LOGIC ;
              STEPSOVER         :  out  Integer);
end AxisCounter ;

architecture Behavioral of AxisCounter is
-- signals, variables and constants
   signal cnt_r         : Integer := 0 ;
   signal steps_r   : Integer := 0 ;
   signal blink_o   : std_logic := '0' ;
   signal RunStop   : std_logic := '1' ;
   --signal Compare1    : Integer := 75000000;  -- 1000000 ;
   --signal Steps1     : Integer := 12 ;

begin

  process(BASECLK_IN,RESET_COUNT,START_STOP) 
  begin
     if (START_STOP' event and START_STOP = '1') then
        RunStop &lt;= '1';
     end if ;
    if rising_edge(BASECLK_IN) then
        if (RESET_COUNT = '0') then
            steps_r &lt;= 0 ;
            cnt_r   &lt;= DIVISOR ;
       elsif (RunStop = '1')then -- counter enabled
           cnt_r &lt;= cnt_r - 1;
            if (cnt_r &gt; (DIVISOR/2)) then
                blink_o &lt;= '1' ;
            else
                blink_o &lt;= '0' ;
                if (cnt_r = 0) then
                    steps_r &lt;= steps_r + 1 ;
                    STEPSOVER &lt;= steps_r ;
                    if (steps_r = STEPS) then
                        RunStop &lt;= '0' ;
                    else
                        cnt_r &lt;= DIVISOR ;
                    end if ;
                end if ;
            end if ;
        else
            blink_o &lt;= '0' ;
        end if ;
    end if ;
  end process;


  AXISCLK_OUT &lt;= blink_o ;
  COUNT_STATUS &lt;= RunStop ;

end Behavioral;
","What you are asking is for a flipflop to be created for RunStop that has to be clocked by two distinct clock signals: BASECLK_IN and START_STOP

There are multiple solutions for this problem:


you can define the behaviour of RunStop in such a way that it's no longer clocked by two sources
Create two versions of RunStop, 1 for each clock and combine them (asynchronously) at a later point. 
",,,,,
VHDL Increment 10-bit Program Counter by 1,"I am trying to make a 32-bit CPU using a modified MIPS instruction set in VHDL. I am currently trying to get my Program Counter to increment by 1 for the next instruction, unless it is a jump instruction which then the Program Counter will equal the Jump value.

entity PC is
Port ( PC_IN     : in STD_LOGIC_VECTOR (9 downto 0); --New PC in value (PC+1 or jump)
       PC_OUT    : out STD_LOGIC_VECTOR (9 downto 0); --PC out to instruction memory
       Jump_Inst : in STD_LOGIC_VECTOR(9 downto 0); --Jump address
       Jump      : in STD_LOGIC; --Jump MUX
       clk       : in STD_LOGIC);
end PC;

architecture Behavioral of PC is
begin

PC_IN &lt;= (PC_IN + ""0000000001"") when (Jump = '0')
else Jump_Inst;     

process(clk)
begin
   if rising_edge(clk) then --If it is the next clock cycle (i.e time for the next instruction)
   PC_OUT &lt;= PC_IN;

end if;
end process;     
end Behavioral;


I am getting errors at this line PC_IN &lt;= (PC_IN + ""0000000001"") when (Jump = '0'). The errors consist of cannot update 'in' object pc_in and 0 definitions of operator ""+"" match here, so it doesn't like me using the + operator and maybe pc_in needs to be an output?

Does anyone know how to get my program counter to increment by 1 for the next instruction? Any help would be appreciated. Thanks. ","PC_IN is defined as a std_logic_vector.  You don't show the libraries in use, but by default there are no defined operators for + for std_logic_vector in std_logic_1164.  Note your error message:


  0 definitions of operator ""+"" match here


This is your hing that + isn't defined in this context.  In order to use the + operator, you need to include a library that has that support and use the appropriate type.

Your other error:


  cannot update 'in' object pc_in


Tells you that you cannot set an in port.  Notably, PC_IN is an input, yet you are trying to drive PC_IN.  Perhaps you mean to drive PC_OUT?

I won't mention the alternate method, but you should probably use numeric_std in this case.  For example:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

...

PC_OUT &lt;= std_logic_vector(unsigned(PC_IN) + 1) when (Jump = '0') else Jump_Inst;
",,,,,
verilog code to find a single max value for an input that has 1000 samples values,"i want to find a single max value for an input signal that has 1000 decimal values that is read from a memory once every Positive clk edge.i did the following rough code for finding max value but it didn't give me the correct max value/number please help me so i can find a single max value in these 1000 values of input signal..`thanks in advance

module(input clk, input [15:0]din, output [15:0]dout);
reg [15:0] max=0;

always @ (Posedge clk)
if(din&gt;max)
max&lt;=din;
else
max&lt;=0;

assign dout=max;
endmodule
","Assumption 1: 

If your memory read operation of 1000 valuation is out of your finding max value module then no need to track how many values are read. 

module find_max (input         clk, 
                 input  [15:0] din, 
                 output [15:0] dout
               );

reg [15:0] max=0;

always @ (posedge clk)
begin
  if(din &gt; max)
    max &lt;= din;
  else
    max &lt;= max;
end

assign dout = max;

endmodule


Your max value reflected in output after next cycle of being fed to find_max module.

Assumption 2:

If your outof find_max module not taking care of total number of valuation read then we just required one counter which track the number of cycles or valuation arrived.

module find_max (input         clk, 
                 input  [15:0] din, 
                 output [15:0] dout
               );

reg [15:0] max=0;
reg [ 9:0] cnt=0;

always @ (posedge clk)
begin
  cnt &lt;= cnt + 1'b1;
  if(din &gt; max)
    max &lt;= din;
  else
    max &lt;= max;
end

assign dout = (cnt == 10'd1000) ? max : 16'd0;

endmodule


We need not to store value of 1000 sample because we have to find only max value.",,,,,
Self implemented UART in VHDL always skips second character,"I am learning VHDL right now and I tried to implement UART (1 start bit, 8 data bits, 1 stop bit) to periodically send a hardcoded string. 

Everything works as expected - I receive string every 1 second. However, there is no second character.

No matter how long the string is, which character it is. I checked this fact on a oscilloscope and there is no waveform for this particular character. 1 start bit, 8 bits for first character, stop bit, start bit and 8 bits for third character, not the second one.

Following code is for 10 MHz clock divided to send with ~38 400 bits per second, I also tried with 9600 bits per second, both the same problem.

I'm using Altera MAX10 dev board: http://maximator-fpga.org/

Short video how it works:
https://gfycat.com/JoyousIlliterateGuillemot

UART.vhd:

LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    use ieee.numeric_std.ALL;
    use ieee.std_logic_arith.all;

entity UART is
    port (
        clk_10mhz: in STD_LOGIC;
        txPin: out STD_LOGIC
    );
end entity;

architecture Test of UART is
    signal txStart: STD_LOGIC;
    signal txIdle: STD_LOGIC;
    signal txData: STD_LOGIC_VECTOR(7 downto 0);

    component TX is
        port (
            clk_in: in STD_LOGIC;
            start: in STD_LOGIC;
            data: in STD_LOGIC_VECTOR(7 downto 0);
            tx: out STD_LOGIC;
            txIdle: out STD_LOGIC
        );
    end component TX;


begin
    process (clk_10mhz, txIdle) 
        variable clkDividerCounter : integer range 0 to 10000000;
        variable textToSend : string(1 to 31) := ""Hello darkness my old friend!"" &amp; CR &amp; LF; 
        variable currentCharacterIndex : integer range 0 to 31;
    begin       
        if (rising_edge(clk_10mhz)) then
            if (clkDividerCounter &lt; 10000000) then
                clkDividerCounter := clkDividerCounter + 1;
            else
                clkDividerCounter := 0;
                currentCharacterIndex := 1;
            end if;


            if (txIdle = '1' and currentCharacterIndex &gt; 0) then
                txData &lt;= CONV_STD_LOGIC_VECTOR(character'pos(textToSend(currentCharacterIndex)),8);
                txStart &lt;= '1';

                if (currentCharacterIndex &lt; 31) then
                    currentCharacterIndex := currentCharacterIndex + 1;
                else
                    currentCharacterIndex := 0;
                    txStart &lt;= '0';
                end if;
            end if;
        end if;
    end process;


    u1: TX port map (clk_10mhz, txStart, txData, txPin, txIdle);
end Test;


TX.vhd:

LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    use ieee.numeric_std.ALL;

entity TX is
    port (
        clk_in: in STD_LOGIC;
        start: in STD_LOGIC;
        data: in STD_LOGIC_VECTOR(7 downto 0);

        tx: out STD_LOGIC;
        txIdle: out STD_LOGIC
    );
end entity;

architecture Test of TX is
    signal idle: STD_LOGIC;
begin
    process (clk_in) 
        variable bitIndex : integer range 0 to 9;
        variable clkDividerCounter : integer range 0 to 260;

        variable dataFrame : STD_LOGIC_VECTOR(9 downto 0);
        variable dataFrameCurrentIndex : integer range 0 to 9;
    begin
        if (rising_edge(clk_in)) then
            if (start = '1' and idle = '1') then
                dataFrame(0) := '0';
                dataFrame(8 downto 1) := data;
                dataFrame(9) := '1';

                dataFrameCurrentIndex := 0;

                idle &lt;= '0';
            end if;

            if (idle = '0') then                
                if (clkDividerCounter &lt; 260) then
                    clkDividerCounter := clkDividerCounter + 1;
                else
                    if (dataFrameCurrentIndex &lt;= 9) then
                        tx &lt;= dataFrame(dataFrameCurrentIndex);
                        dataFrameCurrentIndex := dataFrameCurrentIndex + 1;
                    else
                        idle &lt;= '1';
                    end if;

                    clkDividerCounter := 0;
                end if;
            end if; 

            txIdle &lt;= idle; 
        end if;
    end process;
end Test;
","Move the line

txIdle &lt;= idle;


from TX.vhd outside the process. Signals take their new value after the process ends.

For example:

idle &lt;= '0';
txIdle &lt;= idle;


Will set txIdle to '1'Â if idle was '1' when the two statements were executed inside a process. You should notice that this means that txIdle will be '1' for two consecutive cycles and causes currentCharacterIndex to increment twice at the start.

Note that contrary to signals, variable take their new value when the assigning statement is encountered, and not at the end of the process as signals do.

While your code is not that terrible for a beginner, I recommend to use only signal when you start learning VHDL. It is much easier to make mistake with variables, or describe sub-optimal or broken implementation.

Also, as Brian mentioned, don't use std_logic_arith, especially when using numeric_std. They are conflicting with each other (some tools deal with it though) and std_logic_arith is not a IEEE standard, while numeric_std is.

Finally, simulation is a crucial part of hardware design. To avoid uninitialized pin, add a reset to your circuit, which is generally a good idea.",,,,,
"Signal x cannot be synthesized, bad synchrononous description","I'm very new to vhdl and i cannot manage to find what's causing this error. 
I'm trying to replicate the functionality of a CD54/74HC192 Circuit. 

Any help would be greatly appreciated. 

    library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity upg1 is
    Port ( clock_up : in  std_logic;
           clock_down : in  std_logic;
           reset : in  STD_LOGIC;
           asyn_load : in  STD_LOGIC;
           bcd_in : in  STD_LOGIC_VECTOR (3 downto 0);
           bcd_ut : out  STD_LOGIC_VECTOR (3 downto 0);
           term_up : out  STD_LOGIC;
           term_down : out  STD_LOGIC);
end upg1;

architecture Behavioral of upg1 is
subtype state_type is integer range 0 to 15;
signal next_state, present_state: state_type;
signal clock : std_logic;

begin

process(clock_up, clock_down)
begin
   if clock_up = '1' then
      clock &lt;= clock_down;
    else
      if clock_down = '1' then
      clock &lt;= clock_up;
   end if;
   end if;
end process;


process(present_state, asyn_load, clock) -- line 65
begin
   if reset= '1' then
      next_state &lt;= 0;
   end if;
   if (asyn_load = '1' and (rising_edge(clock))) then
         if present_state = 9 or present_state = 13 or present_state = 15 then
         present_state &lt;= 0;
         elsif
         present_state = 10 or present_state = 12 or present_state = 14 then
         present_state &lt;= 9;
         elsif
         present_state = 11 then
         present_state &lt;= 4;
         else
         present_state &lt;= present_state + 1;
         end if;

       else
         if rising_edge(clock) then 
            if present_state = 12 then
            present_state &lt;= 3;
            elsif present_state = 13 then
            present_state &lt;= 4;
            elsif present_state = 14 then
            present_state &lt;= 5;
            elsif present_state = 15 then
            present_state &lt;= 6;
            elsif present_state = 0 then
            present_state &lt;= 9;
            else
            present_state &lt;= present_state - 1;
            end if;
     else
      present_state &lt;= TO_INTEGER(UNSIGNED(bcd_in));
   end if; 
   end if;

end process;
end Behavioral;


I've tried different methods in resolving the error but unable to do so.

Error-console: 

line 65: Signal present_state cannot be synthesized, bad synchronous description. The description style you are using to describe a synchronous element (register, memory, etc.)
","First, don't use both packages numeric_std and std_logic_arith/unsigned, but use only numeric_std since this is a VHDL standard package, where std_logic_arith/unsigned are Synopsys proprietary.  So change to:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.all;


About the real issue, then create state in VHDL through flip-flops using a structure like:

process(clock, reset)
begin
  if rising_edge(clock) then
    ...
  end if;
  if reset = '1' then
    ...
  end if;
end if;


Synthesis will recognize this and infer flip-flops.  The reset and clock should not be used elsewhere inside the process.",,,,,
Expected a more extensive RTL Viewer,"I synthesized my VHDL code. When I saw the RTL viewer, I was expecting another outcome. I got a state machine build with VHDL code (see below) and got the following outcome (see picture). Some things that I don't get here:


What does 1'h0 mean?
What does state~7 mean?
Why is there only one block state? Where are the other states?


VHDL Code:

ENTITY state_machine IS
PORT (  clk: IN std_logic;
        reset: IN std_logic;
        X: IN BIT;
        Z: OUT BIT);
END state_machine;

--  Present State   Next State      Output
--                  X       !X
--                                  Z
--  S0              S0      S1      0
--  S1              S0      S11     0
--  S11             S110    S11     0
--  S110            S0      S1101   0
--  S1101           S0      S11     1

ARCHITECTURE behaviour OF state_machine IS
  TYPE states IS (S0, S1, S11, S110, S1101);    
  SIGNAL state : states;                        
BEGIN

next_state : PROCESS(reset, clk)    
BEGIN
    IF reset='0' THEN
        state &lt;= S0;
    ELSIF rising_edge(clk) THEN
        CASE state IS
            WHEN S0 =&gt; 
                IF X='0' THEN 
                    state&lt;=S1; 
                END IF;
            WHEN S1 =&gt; 
                IF X='0' THEN
                    state&lt;=S11; 
                ELSE 
                    state&lt;=S0;
                END IF;
            WHEN S11 =&gt; 
                IF X='0' THEN
                    state&lt;=S11; 
                ELSE 
                    state&lt;=S110;
                END IF;
            WHEN S110 =&gt; 
                IF X='0' THEN
                    state&lt;=S1101; 
                ELSE 
                    state&lt;=S0;
                END IF;
            WHEN S1101 =&gt; 
                IF X='0' THEN
                    state&lt;=S11; 
                ELSE 
                    state&lt;=S0;
                END IF;
        END CASE;
    END IF;
END PROCESS;

output:PROCESS(state)
BEGIN
    CASE state IS
        WHEN S0 =&gt; Z&lt;='0';
        WHEN S1 =&gt; Z&lt;='0';
        WHEN S11 =&gt; Z&lt;='0';
        WHEN S110 =&gt; Z&lt;='0';
        WHEN S1101 =&gt; Z&lt;='1';
    END CASE;
END PROCESS;
END behaviour;


RTL Schematic:

","The viewer uses Verilog notation for constants, and 1'h0 in Verilog is the same as '0' in VHDL.

The OR-gate is simply named state~7, just like the yellow box is named state.  So the OR-gate is simply an inverter so the reset to state block is not reset for the external reset input.

The rest of the design with the state machine is put in an internal block named state, so if you double click on this it will probably expand.  The S1101 output on the state block is asserted when in state S1101, since only then is the Z output '1'.",,,,,
How to write property for formal verification?,"property prop1;
@(posedge clk)
$fell(sig1) ##1 sequence1 |-&gt; sequence2;
endproperty


I want to disable the property iff sig1=1'b1 after first clock cycle.

Transition from high to low on sig1 is my triggering condition. If I do disable iff(sig1) triggering condition will not be met.

Also using throughout is not possible on both enabling and satisfying sequences in formal verifiers.

How can i do it?
Thanks!","How about writing some satellite code to derive a delayed version of sig:

  always @(posedge clk) sig1d &lt;= sig1;

  property prop1;
    @(posedge clk) disable iff(sig1d) 
    $fell(sig1) ##1 sequence1 |-&gt; sequence2;
  endproperty


http://www.edaplayground.com/x/2tbX",,,,,
Tell me what's wrong with this code,"This code describes this expression -> (a+b)(c+d). I used 2 summators, to first sum a and b, and then c and d. And then another one to multiply results. Unfortunately, I'm really bad at Verilog, so I'm unable to understand what's wrong.

  module automate(a,b,c,d,clk,start,result,ready);
  parameter n=8;
  input [7:0] a,b,c,d;
  input start,clk;
  output reg[17:0] result;
  output reg ready;
  reg[7:0] ra;
  reg[7:0] rb;
  reg[7:0] rc;
  reg[7:0] rd;
  reg[8:0] sm1;
  reg[8:0] sm2;
  reg[8:0] acc,q;

  always@(posedge start)
  begin
    ra=a;
    rb=b;
    rc=c;
    rd=d;

    sm1=ra+rb;
    sm2=rc+rd;

    q=sm2;
    acc=0;
    ready=0;

    repeat(9)
    begin
      @(posedge clk)
      if(q[0])
        acc=acc+sm1;
      else
        acc=acc;
      q=q&gt;&gt;1;
      q[8] = acc[0];
      acc=acc&gt;&gt;1;
    end

    ready=1;
    result={acc[8:0],q};
  end

endmodule


Testbench :    

module test_bench;
reg[7:0] a,b,c,d;
reg clk,start;
wire ready;
wire[17:0] result;

automate res(a,b,c,d,clk,start,result,ready);
initial begin
  start = 0;
  clk=0;

  a=8'd7;
  b=8'd5;
  c=8'd9;
  d=8'd3;

  #30 start = 1;
  wait(ready);
  #20 start = 0;

  #500 $finish;
end

always #10 clk=~clk;

endmodule  


but here's what I get:

","Your code is working fine as per @Matthew Taylor!!,

Simulation is might not be of TB, as it is top module, nothing is driven to DUT so your signals are X and Z. 

 .....
 automate res(a,b,c,d,clk,start,result,ready);
 initial begin
   $monitor (result, res.sm1, res.sm2); // added monitor system task
   start = 0;
 .....


And just run it, you will see then output as below,

#      x  x  x
#      x 12 12
#    144 12 12


Even though, I would like to say, you are writing HDL code, a real Hardware so don't use repeat, use for loop.

And if your requirement is just (A+B) / (C+D) then there is no use of clock. 

For addition,

  always@(*)
  begin
    ra = 0;
    rb = 0;
    rc = 0;
    sm1 = 0;
    sm2 = 0;
    result = 0;

    if(start) begin
      ra = a;
      rb = b;
      rc = c;
      rd = d;

      sm1 = ra + rb;
      sm2 = rc + rd;

      result = product(sm1, sm2);
    end
  end


For function product which will multiply sm1 and sm2 can be,

  function [17:0] product;
    input [8:0]  multiplier, multiplicand;

    integer i;

    begin
      product = 0;
      for(i=0; i&lt;17; i=i+1)
        if( multiplier[i] == 1'b1 )
          product = product + ( multiplicand &lt;&lt; i );
     end
   endfunction


So I think start and ready would be asserted on same cycle. No sequential logic is there in your code, as of now.

Hope this will help you.

Edit: 

for your second problem, use following transcript commands:

vsim -novopt -c -do ""add wave -r /*; run -all;"" work.test_bench

add wave -r /*

run -all
",,,,,
8 bits Array Multiplier VHDL (output wrong),"I'm trying to make a 8 bits Array Multiplier in VHDL, I am using the standard architecture of the array multiplier to do this, i have a BDF file receiving the A(multiplicand) and B(multiplier), and in this BDF file have a block named ""adder"" that makes the sums from the products of A and B. I'm having problems with the sum output, its showing a much lower number from the correct value.


The image above is my main BDF.



The image above shows de connections from and_arrays to the adder.

Adder code:

LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.std_logic_unsigned.ALL;
use IEEE.std_logic_arith.ALL;
use IEEE.numeric_std.ALL;

ENTITY adder IS
  PORT (i_IN0   : IN  STD_LOGIC_VECTOR(7 downto 0);-- data input
        i_IN1   : IN  STD_LOGIC_VECTOR(7 downto 0);-- data input
        i_IN2   : IN  STD_LOGIC_VECTOR(7 downto 0);-- data input
        i_IN3   : IN  STD_LOGIC_VECTOR(7 downto 0);-- data input
        i_IN4   : IN  STD_LOGIC_VECTOR(7 downto 0);-- data input
        i_IN5   : IN  STD_LOGIC_VECTOR(7 downto 0);-- data input
        i_IN6   : IN  STD_LOGIC_VECTOR(7 downto 0);-- data input
        i_IN7   : IN  STD_LOGIC_VECTOR(7 downto 0);-- data input
        o_Q     : OUT STD_LOGIC_VECTOR(15 DOWNTO 0);
        o_COUT  : OUT STD_LOGIC);-- data output  
END adder;

architecture arch1 of adder is 
begin 
    process(i_IN0, i_IN1, i_IN2, i_IN3, i_IN4, i_IN5, i_IN6, i_IN7)
      variable soma:std_logic_vector(14 downto 0);
      variable aux0:std_logic_vector(14 downto 0);
      variable aux1:std_logic_vector(14 downto 0);
      variable aux2:std_logic_vector(14 downto 0);
      variable aux3:std_logic_vector(14 downto 0);
      variable aux4:std_logic_vector(14 downto 0);
      variable aux5:std_logic_vector(14 downto 0);
      variable aux6:std_logic_vector(14 downto 0);
      variable aux7:std_logic_vector(14 downto 0);
      variable c:std_logic; -- carry in
      BEGIN
         aux0(7 downto 0) := i_IN0; aux0(14 downto 8) := ""0000000""; -- here i'm trying to shift the 8 nbit input value
         aux1(0) := '0'; aux1(8 downto 1) := i_IN1; aux1(14 downto 9) := ""000000""; -- to a 15 bit value to the sums
         aux2(1 downto 0) := ""00"";aux2(9 downto 2) := i_IN2; aux2(14 downto 10) := ""00000""; -- looking to the array multiplier
         aux3(2 downto 0) := ""000"";aux3(10 downto 3) := i_IN3; aux3(14 downto 11) := ""0000""; -- architecture, it seem to be
         aux4(3 downto 0) := ""0000"";aux4(11 downto 4) := i_IN4; aux4(14 downto 12) := ""000""; -- correct
         aux5(4 downto 0) := ""00000"";aux5(12 downto 5) := i_IN5; aux5(14 downto 13) := ""00"";
         aux6(5 downto 0) := ""000000""; aux6(13 downto 6) := i_IN6; aux6(14) := '0';
         aux7(6 downto 0) := ""0000000""; aux7(14 downto 7) := i_IN7;
    -- below the loop that make the sums bit-in-bit, i've addapted this code from a 8 bit adder
         c := '0';
            for i in 0 to 14 loop
                soma(i) := aux0(1) xor aux1(i) xor aux2(i) xor aux3(i) xor aux4(i) xor aux5(i) xor aux6(i) xor aux7(i) xor c;
                c := (aux0(i) and aux1(i) and aux2(i) and aux3(i) and aux4(i) and aux5(i) and aux6(i) and aux7(i)) or ((aux0(i) xor aux1(i) xor aux2(i) xor aux3(i) xor aux4(i) xor aux5(i) xor aux6(i) xor aux7(i)) and c);
            end loop;
            o_COUT &lt;= c; 
            o_Q(15) &lt;= c; -- carry out atribuition to the last bit of the vector
            o_Q(14 downto 0) &lt;= soma;
    end process;
end arch1;


AND ARRAY CODE:

LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.std_logic_unsigned.ALL;
use IEEE.std_logic_arith.ALL;

ENTITY and_array IS
  PORT (i_MULTIPLICANDO   : IN  STD_LOGIC_VECTOR(7 downto 0);-- data input
        i_MULTIPLICADOR   : IN  STD_LOGIC;-- data input
        o_Q   : OUT STD_LOGIC_VECTOR(7 DOWNTO 0));-- data output
END and_array;

ARCHITECTURE arch_1 OF and_array IS
    BEGIN
        GEN_REG: 
        FOR i IN 0 TO 7 GENERATE
            o_Q(i) &lt;= i_MULTIPLICADOR and i_MULTIPLICANDO(i); 
        END GENERATE GEN_REG;
END arch_1;


I've made simulation for this two blocks, the and array blocks works perfectly, but the error appears in the adder simulation, below the imagem from the simulation:



I'am simulating the following inputs:

        Multiplicand = 1 1 1 1 0 1 0 1 (245 dec)
        Multiplier   = 1 0 1 0 1 1 1 1 (175 dec)


The correct value for this product is 42785, in my simulation appears 24899

I am using the following logic to the sums in adder:

                   1 1 1 1 0 1 0 1
                   1 0 1 0 1 1 1 1
                   -----------------
      x x x x x x x 1 1 1 1 0 1 0 1     p1
      x x x x x x 1 1 1 1 0 1 0 1 x     p2
      x x x x x 1 1 1 1 0 1 0 1 x x     p3
      x x x x 1 1 1 1 0 1 0 1 x x x     p4 
      x x x 0 0 0 0 0 0 0 0 x x x x     p5
      x x 1 1 1 1 0 1 0 1 x x x x x     p6
      x 0 0 0 0 0 0 0 0 x x x x x x     p7
      1 0 1 0 1 1 1 1 x x x x x x x     p8
_________________________________________


In the adder block i've changed all the ""X's"" for 0 to the sum (Like a shift). In the loop of the adder block the sums of p1 to p8, is made bit-in-bit. Probably the error it's in this loop or in the carry, but i've tried to do this from many forms and always goes wrong.

Someone have any idea how to fix this?

Below it's the main circuit abstraction image:

","The solution for this problem was use half adders and full adders in the place of the adder shown above in the question.

It was used the logic below:



Totally were used:

64 AND gates;
8 Half Adders;
48 full adders.",,,,,
Led Counter Program (0 - 15) with different frequencies,"I want to make a counter with the 4 LEDs on a Zybo board that counts from 0 to 15. Also I want the 4 buttons of the board to correspond to a different frequency for the changes of the LEDs (0.5Hz, 1Hz, 2Hz, 4Hz). I have already achieved the simple counter with a fixed frequency but not the second part with the button frequency changes.

In the Block Design, I have a Zynq Processing System, an AXI GPIO which reads the button data and a custom IP that functions as the driver for the LEDs, the clock divider and the frequency changer.

Custom IP

The clock divider module code.

module Clock_Divider(
input clk,  
input rst,
input reg0,
output reg clk_out    
);

reg [31:0] count;    
reg constantNumber;   

always @ (reg0)
begin
    if(reg0 == 0000)
        constantNumber = 50000000;
    else if(reg0 == 0001)
        constantNumber = 100000000;
    else if(reg0 == 0010)
        constantNumber = 50000000;
    else if(reg0 == 0100)
        constantNumber = 25000000;
    else if(reg0 == 1000)
        constantNumber = 12500000;
    else
        constantNumber = 50000000;
end

always @ (posedge(clk), posedge(rst))
begin        
    if (rst == 1'b1)
        begin
        count &lt;= 32'b0;         
        end
    else if (count == constantNumber - 1)
        begin
        count &lt;= 32'b0;
        end
    else
        begin
        count &lt;= count + 1;
        end
end

always @ (posedge(clk), posedge(rst))
begin
    if (rst == 1'b1)
        clk_out &lt;= 1'b0;
    else if (count == constantNumber - 1)
        clk_out &lt;= ~clk_out;
    else
        clk_out &lt;= clk_out;
end   
endmodule


The register constantNumber takes the corresponding value in order to change the clock frequency.

The rest of the custom IP logic.

Clock_Divider UIP (.clk(S_AXI_ACLK), .rst(), .reg0(slv_reg0), .clk_out(clk_out));

reg [3:0] counter = 0;

always @(posedge clk_out) 
begin
    if(counter &lt; PWM_COUNTER_MAX-1)
        begin            
        counter &lt;= counter + 1;
        end
    else            
        counter &lt;= 0;
end

assign PWM0 = counter[0];
assign PWM1 = counter[1];
assign PWM2 = counter[2];
assign PWM3 = counter[3];


The button data are sent to the first register of the custom IP (slv_reg0) which in turn sends them to reg0 in the Clock_Divider module.

Main C program

#include &lt;stdio.h&gt;
#include ""platform.h""
#include &lt;xgpio.h&gt;
#include ""xparameters.h""
#include ""sleep.h""
#include ""xil_io.h""

//#define MY_PWM XPAR_MY_PWM_CORE_0_S00_AXI_BASEADDR //Because of a bug in Vivado 2015.3 and 2015.4, this value is not correct.
#define MY_PWM 0x43C00000 //This value is found in the Address editor tab in Vivado (next to Diagram tab)

int main(){
    XGpio input;
    int button_data = 0;

    XGpio_Initialize(&amp;input, XPAR_AXI_GPIO_0_DEVICE_ID);    //initialize input XGpio variable
    XGpio_SetDataDirection(&amp;input, 1, 0xF);                 //set first channel tristate buffer to input

    init_platform();

    while(1){

        button_data = XGpio_DiscreteRead(&amp;input, 1);    //get button data

        if(button_data == 0b0000){
            Xil_Out32(MY_PWM, button_data);
        }

        else if(button_data == 0b0001){
            xil_printf(""button 0 pressed\n\r"");
            Xil_Out32(MY_PWM, button_data);
        }

        else if(button_data == 0b0010){
            xil_printf(""button 1 pressed\n\r"");
            Xil_Out32((MY_PWM), button_data);
        }

        else if(button_data == 0b0100){
            xil_printf(""button 2 pressed\n\r"");
            Xil_Out32((MY_PWM), button_data);
        }

        else if(button_data == 0b1000){
            xil_printf(""button 3 pressed\n\r"");
            Xil_Out32((MY_PWM), button_data);
        }

        else{
            xil_printf(""multiple buttons pressed\n\r"");
            Xil_Out32(MY_PWM, 0b0000);
        }
    }

    cleanup_platform();
    return 0;
}


I can confirm that the button data are correctly read by the AXI GPIO because when they are pressed the correct lines are printed in the terminal. But when I press the buttons, the frequency does not change. Also it runs with a very slow frequency, much slower than the 1Hz that should be the default even if the button data did not get sent to the custom IP.

The problem has to lie somewhere either with the reg0 case logic in the custom IP or the sending of the button data from the cpu to the register of the custom IP.","I made the changes that Greg proposed plus some of my own and I got it working at last.

In the clock divider file I made the following changes.

input [3:0] reg0,

reg [31:0] constantNumber;   

always @ (reg0)
begin
    if(reg0 == 4'b0000)
        constantNumber = 50000000;
    else if(reg0 == 4'b0001)
        constantNumber = 100000000;
    else if(reg0 == 4'b0010)
        constantNumber = 50000000;
    else if(reg0 == 4'b0100)
        constantNumber = 25000000;
    else if(reg0 == 4'b1000)
        constantNumber = 12500000;
    else
        constantNumber = 50000000;
end


I made consantNumber 32 bits in order to be sure there are no overflows.

In the custom IP logic I changed the parameter for the reg0 in order to send the correct (last) bits of the slv_reg0 to it.

Clock_Divider UIP (.clk(S_AXI_ACLK), .rst(), .reg0(slv_reg0[3:0]), .clk_out(clk_out));


And last but not least the changes in the c program.

if(button_data == 0b0001){
        xil_printf(""button 0 pressed\n\r"");
        Xil_Out32(MY_PWM, 0b0001);
    }

    else if(button_data == 0b0010){
        xil_printf(""button 1 pressed\n\r"");
        Xil_Out32((MY_PWM), 0b0010);
    }

    else if(button_data == 0b0100){
        xil_printf(""button 2 pressed\n\r"");
        Xil_Out32((MY_PWM), 0b0100);
    }

    else if(button_data == 0b1000){
        xil_printf(""button 3 pressed\n\r"");
        Xil_Out32((MY_PWM), 0b1000);
    }
    else if(button_data &gt; 0b0000){
        xil_printf(""button 3 pressed\n\r"");
        Xil_Out32((MY_PWM), 0b0000);
    }


I got rid of the:

if(button_data == 0b0000){
        Xil_Out32(MY_PWM, button_data);
    }


because after a few clock ticks no button is pressed and it would send a 0000 signal to the slv_reg0.",,,,,
ascii-hex conversion in verilog,"I was looking for a Verilog function to convert my ASCII input strings to hexadecimal output. I am not sure if I can do it in C and club it with Verilog. So far, I was able to print the input ASCII strings as hex values by using:

printf(""Hexadecimal Output for &lt;CALL-ID&gt;: "");
for(c = 0; c &lt; strlen(callid); c++)
{
  printf(""TO: %x "", callid[c]);
}


Is there a way to save the output in a text/csv file and make it accessible to my verilog code snippet?  

Or please let me know if there is an easier way in Verilog itself?","To output to a text file, you could do something like this:

static int string_to_hex_file(const char *filename, const char *string)
{
    FILE            *out;
    const char      *s;

    if((out = fopen(filename, ""w"")) == NULL)
      return 0;

    fprintf(out, ""\""%s\"", "", string);
    for(s = string; *s; s++)
    {
        if(s != string)
            fprintf(out, "", "");
        fprintf(out, ""0x%02x"", (unsigned char) *s);
    }
    fprintf(out, ""\n"");

    fclose(out);
    return 1;
}


Sample output for string == ""this is a test"":

""this is a test"", 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x65, 0x73, 0x74


Error checking can of course be improved, and you will likely need to tweak the output formatting to suit your needs.",,,,,
Verilog source code for MIPS,"can anyone tell me about simple MIPS Verilog code without pipeline... its implementation on FPGA ?

regards ","There are various websites, like OpenCores which you can help you.",,,,,
How is a variable shown in a RTL viewer in Quartus?,"How is a variable depicted in a RTL viewer in Quartus. I open RTL viewer and it does not show any register for a variable.

For example:

variable op_code   : std_logic_vector(7 downto 0);


Is there a reason why RTL viewer will not show op_code in RTL viewer? I am using VHDL.

Edit:

op_code(7 downto 0) &lt;=instr_reg(31 downto 24);

if ( op_code = ADD or op_code = MYSUB) then &lt;br&gt;
    C_addr &lt;= instr_reg(14 downto 10); &lt;br&gt;
end if;             

CASE op_code(7 downto 0) IS
    --some case statments
END CASE;
","Has it been optimised away? if the elements of opcode are used for other things, they may have been subsumed into other logic and not visible in their own right anymore.

Another thought - if you haven't described the behaviour of a register (which for a variable usually comes down to reading it before writing to it in a clocked process) then no register will be created.  It'll just be combinatorial logic within the process, and very likely to be combined with other things.  Maybe you could post your whole process (or a bit more of it) - we might be able to help more that way.",,,,,
"example extending LEON SOC with custom peripheral, AMBA AHB slave",Has anyone here extended LEON3 softcore with custom hw? I'm looking for basic example how to add custom peripheral to AMBA AHB bus,"May be this document can help ?

http://people.xiph.org/~j/bzr/theora-fpga/doc/leon3_integration/

JC",,,,,
Losing link to the FPGA device,"I am trying to debug somewhat strange problem in the device driver for the PCIe FPGA device. Both the device driver and the FPGA image are developed in the house.

The target system is x86, and the OS is fedora 9. It has a PCIe card with the FPGA plugged in it's only PCIe slot. The FPGA image is loaded after the boot from the EEPROM.

The driver is written in such a way that it uses the /sys/bus/pci/devices/0000:02:00.0/ resource files (where 0000:02:00.0 is the PCI slot of the card containing the FPGA) to configure the FPGA.

When the system boots (or when it returns from the hibernation), the FPGA link seams to be lost, and the resource files are missing. When the FPGA boots properly, everything works fine (the resource files are there).
When the system enters the hibernation, the FPGA is powered off. When it returns from the hibernation, the FPGA is powered on, before starting the driver initialization.

I am suspecting at next things :


a bug in firmware - something related to PCI plug in?
a bug in kernel - least likely, because other PCI cards are recognized fine. Only
                 this PCI card makes problems


And the questions are :


Has anyone had similar problems?
What else could be wrong?
Any suggestions on how to debug this issue?


EDIT

I just found this bug, which is very similar to the problem I am seeing.","A PCIe card has to reply to a ""Is anybody there"" message within a certain time. Is is possible that your card is not responding quickly enough after hibernation / reset?

Without more details of your design, it is hard to do anything but guess.

Can you list the differences between the system working and not working, i.e. what do you do differently to get the card to work? ",,,,,
Preserving the widths of ports,"I am trying to re-use netlists in other designs without the success.

I have a component which is translated to the netlist:

  entity c is
     port (...  sel : in std_logic_vector(31 downto 0); ... );


In the design I am using just sel(4 downto 0).
The synthesis tools notices this behaviour and gives a warning:


  'WARNING:Xst:647 - Input sel&lt;31:5> is never used ..


I am generating netlist with properties:


keep hierarchy = true
add I/O buffers = off


Whenever I want to instantiate this netlist as an black-box module in other circuit I got an error:


  ERROR:NgdBuild:76 - cannot be merged into block because one or more pins on the block, including pin  ""sel&lt;31>"", were not found in the file.


How can I preserve the size of sel?
I should mention that the sel needs to be 32bits width since it's connected to the bus.",You could try driving the unused input ports to zero. ,,,,,
GHDL and VHDL - input for executable,"In windows I know that no executable is created by the command ""ghdl -e something""; in linux it is created. I have to give an input file to my executable. If I was at linux I can do that by ./something &lt; input.inp however how can I do it in windows? cause no executable is created.","Just to add, because I lost time with this:
(in Windows)

ghdl -a ""c:\superabsolutepath\test.vhdl"" worked
ghdl -r my_test  resulted in: cannot load entity my_test


however, ghdl -d  displayed everthing correctly (the vhdl file with an absolute path)

-->use no absolute paths, by default the user folder is used ""C:\Users\Lode"" , when I placed my vhdl file in that folder(and start with the command 

ghdl -a test.vhdl
ghdl -r my_test


, everything works, fjoeew ",,,,,
Unable to execute/run any vhdl code using ghdl,"I have installed ghdl in Ubuntu 10.10 (using apt-get from the repository) and used the hello_world example available in the ghdl manual. I can analyze (-a) and elaborate (-e) successfully but when I try to run/execute (-r) it, I get the following error:
/usr/lib/ghdl/bin/ghdl: compilation error

To elaborate my problem, I have mentioned the vhdl code at the end and the sequence of commands that I follow below:


  $ ghdl -a hello.vhdl
  $ ghdl -e hello_world
  $ ./hello_world
  bash: ./hello_world: Permission denied
  $ ghdl -r hello_world
  /usr/lib/ghdl/bin/ghdl: compilation error


I have tried working as root too but without success. The permissions are perfect, the execute bit is set. Everything seems to be fine, but still it doesnt work. I have even tried reinstalling the ghdl package.

Can someone please tell me what could be the source of problem?

Thanks in advance.

hello.vhdl (Vhdl code)


  -- Hello world program.
  use std.textio.all; -- Imports the standard textio package.
  -- Defines a design entity, without any ports.
  entity hello_world is
  end hello_world;
  architecture behaviour of hello_world is
  begin
      process
      variable l : line;
      begin
          write (l, String'(""Hello world!""));
          writeline (output, l);
          wait;
      end process;
  end behaviour;
",Is your filesystem mounted noexec?  What does mount say about the filesystem that your working area is one?,,,,,
"Static library, link to a shared library","I'm new to using Eclipse and developing an application that will be running on Linux (on an ARM processor). I want to use the OpenCV libraries (.so files).
My application consists of an executable that links to multiple static libraries. This linkage is configured in the IDE settings (ARM linux g++ linker settings).
I need to use openCV within one of these static libraries. The openCV libraries are included as .so files installed with the Xilinx Eclipse SDK.
Is it possible to link to these libraries from within my static library? I'm not sure how to set this up. Obviously there are no g++ linker settings in the static library project.
Thanks for any help.","On linux a static libary is really nothing more than a collection of object files smacked together, therefore you cannot link it, but you do not need to either. As the static library isn't linked at all.

The solution is to link your final executable to both libraries. You are of course able to use OpenCV functions inside your static library, it will simply wait to be resolved at a later time.",,,,,
Verilog: Common bus implementation issue,"I've been coding a 16-bit RISC microprocessor in Verilog, and I've hit yet another hurdle. After the code writing task was over, I tried to synthesize it. Found a couple of accidental mistakes and I fixed them. Then boom, massive error.

The design comprises of four 16-bit common buses. For some reason, I'm getting a multiple driver error for these buses from the synthesis tool.

The architecture of the computer is inspired by and is almost exactly the same as the Magic-1 by Bill Buzzbee, excluding the Page Table mechanism. Here's Bill's schematics PDF: Click Here. Scroll down to page 7 for the architecture.

The control matrix is responsible for handling when the buses and driven, and I am absolutely sure that there is only one driver for each bus at any given instance. I was wondering whether this could be the problem, since the synthesis tool probably doesn't know this.

Tri-state statements enable writing to a bus, for example:

assign io [width-1:0] = (re)?rd_out [width-1:0]:0; // Assign IO Port the value of memory at address add if re is true.


EDIT: I forgot to mention, the io port is bidirectional (inout) and is simply connected to the bus. This piece of code is from the RAM, single port. All other registers other than the RAM have separate input and output ports.

The control matrix updates a 30-bit state every negative edge, for example:

state [29:0] &lt;= 30'b100000000010000000000000100000; // Initiate RAM Read, Read ALU, Write PC, Update Instruction Register (ins_reg).


The control matrix is rather small, since I only coded one instruction to test out the design before I spent time on coding the rest.

Unfortunately, it's illogical to copy-paste the entire code over here.

I've been pondering over this for quite a few days now, and pointing me over to the right direction would be much appreciated.","When re is low, the assign statement should be floating (driving Zs).

//                    enable ?   driving          :  floating
assign io [width-1:0] = (re) ? rd_out [width-1:0] : {width{1'bz}};


If it is driving any other value then the synthesizer will treat is as a mux and not a tri-state. This is where the conflicting driver message come from.",,,,,
verilog asynchronous FIFO Wizard,"How do you use the read enable to properly output a signal on a pin? I am using a ZyBo board and used a the FIFO Generator Wizard. I need an asynchronous, continuous writing to a FIFO and reading from the FIFO. This is why I need a write_enable signal and read_enable signal. However, I cannot read from the FIFO. I check to make sure the FIFO isn't empty and that read_enable is asserted. I read from the FIFO by serializing a 32bit word onto a data pin. (It alternates from serializing onto pin I and pin Q). How can I make sure I am reading from the FIFO and outputting the serialized data onto a pin? The following is my code:

// Wires and registers related to data capturing 
wire        capture_clk;
reg [31:0]  capture_data;
wire        capture_en;
reg [4:0]   slowdown;
wire        capture_full;

reg            capture_open;
reg            capture_open_cross;
reg            capture_has_been_full;
reg            capture_has_been_nonfull;
reg            has_been_full_cross;
reg            has_been_full;

// Data capture section
// ====================

always @(posedge capture_clk)
  begin
if (capture_en)
  capture_data &lt;= user_w_write_32_data; // Data source being read from a file

// The slowdown register limits the data pace to 1/32 the bus_clk
// when capture_clk = bus_clk. This is necessary, because the
// core in the evaluation kit is configured for simplicity, and
// not for performance. Sustained data rates of 200 MB/sec are
// easily reached with performance-oriented setting.
// The slowdown register has no function in a real-life application.
slowdown &lt;= slowdown + 1;

// capture_has_been_full remembers that the FIFO has been full
// until the file is closed. capture_has_been_nonfull prevents
// capture_has_been_full to respond to the initial full condition
// every FIFO displays on reset.

if (!capture_full)
  capture_has_been_nonfull &lt;= 1;
else if (!capture_open)
  capture_has_been_nonfull &lt;= 0;

if (capture_full &amp;&amp; capture_has_been_nonfull)
  capture_has_been_full &lt;= 1;
else if (!capture_open)
  capture_has_been_full &lt;= 0;

  end

// The dependency on slowdown is only for bogus data
assign capture_en = capture_open &amp;&amp; !capture_full &amp;&amp; 
             !capture_has_been_full &amp;&amp;
             (slowdown == 0);

// Clock crossing logic: bus_clk -&gt; capture_clk
always @(posedge capture_clk)
  begin
capture_open_cross &lt;= user_r_read_32_open;
capture_open &lt;= capture_open_cross;
  end

// Clock crossing logic: capture_clk -&gt; bus_clk
always @(posedge bus_clk)
  begin
has_been_full_cross &lt;= capture_has_been_full;
has_been_full &lt;= has_been_full_cross;
  end

// The user_r_read_32_eof signal is required to go from '0' to '1' only on
// a clock cycle following an asserted read enable, according to Xillybus'
// core API. This is assured, since it's a logical AND between
// user_r_read_32_empty and has_been_full. has_been_full goes high when the
// FIFO is full, so it's guaranteed that user_r_read_32_empty is low when
// that happens. On the other hand, user_r_read_32_empty is a FIFO's empty
// signal, which naturally meets the requirement.

assign user_r_read_32_eof = user_r_read_32_empty &amp;&amp; has_been_full;
assign user_w_write_32_full = 0;

// The data capture clock here is bus_clk for simplicity, but clock domain
// crossing is done properly, so capture_clk can be an independent clock
// without any other changes.

assign capture_clk = bus_clk;

async_fifo_32x512 fifo_32 //FIFO created using Xilinx FIFO Generator Wizard
  (
    .rst(!user_r_read_32_open),
    .wr_clk(capture_clk),
    .rd_clk(bus_clk),
    .din(capture_data),
    .wr_en(capture_en),
    .rd_en(user_r_read_32_rden),
    .dout(user_r_read_32_data),
    .full(capture_full),
    .empty(user_r_read_32_empty)
    );

    reg Q_en = 1'b0; //starting value is 0 because first 32bit is I
    reg [31:0] data_outI = 32'd0;
    reg [31:0] data_outQ = 32'd0;
    reg I = 1'b0;
    reg Q = 1'b0;
    reg counter_32_shift = 6'b000000;
    reg temp = 1'b0;

    always @(posedge bus_clk) begin
        if(user_r_read_32_empty == 1'b0 &amp;&amp; user_r_read_32_rden == 1'b1)begin //if something in FIFO
            if(Q_en == 1'b0) begin //output onto pin I
                if(counter_32_shift == 6'b000000) begin
                    data_outI &lt;= user_r_read_32_data;
                end else if(counter_32_shift != 5'd32) begin
                    I &lt;= data_outI[0];
                    data_outI &lt;= (data_outI &gt;&gt; 1);
                    Q &lt;= data_outQ[0];
                    data_outQ &lt;= (data_outQ &gt;&gt; 1);
                    counter_32_shift &lt;= counter_32_shift + 1'b1;
                end else begin //counter_32_shift == 32
                    I &lt;= data_outI[0];
                    data_outI &lt;= (data_outI &gt;&gt; 1);
                    Q &lt;= data_outQ[0];
                    data_outQ &lt;= (data_outQ &gt;&gt; 1);
                    counter_32_shift &lt;= 6'd0;
                    Q_en &lt;= ~Q_en;
                end
            end else if(Q_en == 1'b1) begin //Output onto pin Q
                if(counter_32_shift == 6'd0) begin
                    data_outQ &lt;= user_r_read_32_data;
                end else if(counter_32_shift != 6'd32) begin
                    I &lt;= data_outI[0];
                    data_outI &lt;= (data_outI &gt;&gt; 1);
                    Q &lt;= data_outQ[0];
                    data_outQ &lt;= (data_outQ &gt;&gt; 1);
                    counter_32_shift &lt;= counter_32_shift + 1'b1;
                end else begin //counter_32_shift == 32
                    I = data_outI[0];
                    data_outI &lt;= (data_outI &gt;&gt; 1);
                    Q = data_outQ[0];
                    data_outQ &lt;= (data_outQ &gt;&gt; 1);
                    counter_32_shift &lt;= 6'd0;
                    Q_en &lt;= ~Q_en;
                end
            end// end Q_en compare
        end //end check if FIFO empty
    end //end always


Thanks in advance for all the help","You need to design a bit better the way you write your clocked logic. 

For example, in your code, you only write to I and Q if the fifo is not empty, which is not correct. 

You need a module which:


Takes in a 32-bit value from the fifo, stores it, and then serializes it out to a pin over 32 cycles. 
Once a value has been read in from the fifo, it needs to keep serializing regardless of whether or not the fifo is empty (you only care about the state of the fifo when you're pulling in a new 32-bit value).
Only accepts a new value when it is not currently doing serialization.


The design looks to be making progress since your last question, but you haven't got the logic right yet. Try using a waveform debugger to understand better why it's not working the way you expect. ",,,,,
How to right shift a bit in Verilog?,"I have a code like the one below:

module scheduler(clk, rst, busy, s);

input clk, rst;
input [3:0] busy;

output [3:0] s;

reg [3:0] s;

wire busyor;
assign busyor = busy[0] | busy[1] | busy[2] | busy[3];

always  @ (posedge clk or negedge rst)
  if       (!rst)     s  &lt;=  4'b1000;
  else if  (!busyor)  s  &lt;=  s &gt;&gt;&gt; 1;

endmodule


The point is that ""s"" starts as 1000, and then it shifts all the way until 0001, and then when it shifts again, it becomes 0000. The point is that when the bit reaches the end, meaning when it is 0001, and when it is shifted again, I want it to appear at the beginning, meaning it to rotate. So, after 0001 if shift comes, it should go to 1000. Any way to achieve it?","Yes, there is a way to achieve that. For example:

s &lt;= {s[0],s[3:1]}
",,,,,
Verilog Example Wrong? Arbiter Code MSB Finder,"In my book as an example it has: 

wire [n-1:0] c = {1'b1,(~r[n-1:1] &amp; c[n-1:1])}; 


If n=4 then c is 4 bits but the concatenation however makes 5 bits! 0.o 
)r is there something I don't understand about Verilog here, that maybe the case. ",The concatenation is infact just 4 bits. r[n-1:1] is an n-1 bit value which in this case is 3. Note that r[n-1:1] means the bits starting from 2nd bit (index = 1) to nth bit ( index = n-1). So a 3 bit value concatenated with 1b'1 gives a 4 bit value.,,,,,
Modelsim / reading a signal value,"In my simulation, I want to have RW access to signals whereever there are in the project. To get the write access, I use the ""signal_force"" procedure from the modelsim_lib library. But to get the read access I havn't find the corresponding function.

The reason why signal_force fit my needs is that I'm working with input text files, so I have the name and the value of the signal from a ""string"" or a ""line"" variable and I can directly give these variable to the fonction.
I cannot use the ""init_signal_spy"" procedure because this procedure doesn't give back a value into a string but just duplicates the behavior of a signal onto an other. As my project has to be as generic as possible, I work with variables declared into procedures and I cannot link a signal onto a variable.

Thanks for your help","If you're comfortable writing C code it should be straightforward to achieve what you want using the VHPI, although sadly despite being part of the VHDL standard Mentor are not planning to implement it. However it will also be possible using FLI although you're locked into a proprietary interface.

Something like this:

procedure get_signal_value_as_string(
    vhdl_path : IN string;
    vhdl_value: OUT string);

attribute FOREIGN of get_signal_value_as_string : procedure is â€œmy_func mylib.soâ€?

procedure get_signal_value_as_string(
    vhdl_path : IN string;
    vhdl_value: OUT string) is
begin
    report â€œERROR: foreign subprogram get_signal_value_as_string not calledâ€?
end;


Then in C:

#include &lt;stdio.h&gt;
#include ""mti.h""


/* Convert a VHDL String array into a NULL terminated string */ 
static char *get_string(mtiVariableIdT id)
{
    static char buf[1000];
    mtiTypeIdT type;
    int len;
    mti_GetArrayVarValue(id, buf);
    type = mti_GetVarType(id);
    len = mti_TickLength(type);
    buf[len] = 0;
    return buf;
}


void my_func (
    mtiVariableIdT vhdl_path /* IN string */
    mtiVariableIdT vhdl_value /* OUT string */
    )
{
    mtiSignalIdT sigID = mti_FindSignal(get_string(vhdl_path));
    mtiInt32T value = mti_GetSignalValue(sigID);

    ...
}


Plenty of example code in the FLI manual.",,,,,
multiplying two 32-bit operand in verilog,"I have written multiplier in verilog which get two 32 bit operands and return a 64 bit output. I tested this code for 5 bit it worked properly but when I run this code nothing will be happened and also I can not stop or end simulation ModelSim. Do you have any idea about this problem?

    module multiplier_always(operand1,operand2,product);
input [31:0] operand1 ,operand2;
output reg [63:0] product; 

reg [63:0] op1;
reg [31:0] op2,addres,subres;
reg [64:0] subres2,result,addres2,opp1;
reg [2:0] i=0;



always@(*)
begin
        op1 = {32'b0,operand1};
        opp1 = {op1,1'b0};

for(i=0;i&lt;32;i=i+1)
begin
case(opp1[1:0])
2'b00:begin
            opp1 = {opp1[64],opp1[64:1]};
            end

2'b01:begin
                addres = opp1[64:6]+ operand2; 
                addres2 = {addres,opp1[32:0]}; 
                opp1 = {addres2[64],addres2[64:1]}; 
            end

2'b10:begin 
                subres = opp1[64:6]+ (~operand2+1);
                subres2 = {subres,opp1[32:0]}; 
                opp1 = {subres2[64],subres2[64:1]};
            end

2'b11:begin
            opp1 = {opp1[64],opp1[64:1]};//shift
            end

endcase
end
product = opp1[64:1];

end
endmodule
",Infinite loop as reg [2:0] i will always be less less than 32; i+1 is 0 when i==7. Change to integer i or reg [5:0] i.,,,,,
Illegal assignment to class mtiUvm.uvm_pkg::uvm_component,"I get this error when trying to access the uvm_config_db to access a variable. I googled it and found the following answer on the accellera forums:

http://forums.accellera.org/topic/406-compilation-error-regarding-illegal-class-assignment/

You cannot use this as a context inside a sequence; you must rely on the full sequence name.

Can anyone explain why this is so?
Thanks","The value you pass for a context to uvm_config_db::get/set, in your case this, must refer to a UVM component. Based on the value of context the path of full hierarchical path of where the config setting applies is constructed. If this is a sequence (which does not inherit from uvm_component, then it will have not fixed hierarchy.

What I usually do in sequences is:

uvm_config_db #(some_type)::get(p_sequencer, """", ""some_field"", some_field);


p_sequencer is a UVM component and you can make config settings apply to any sequence started on that sequencer.",,,,,
Undefined global variable when using QuestaSim,"I have a variable defined in foo_const.v which is defined like this in foo_const.v:

localparam NUM_BITS = 32;


Then I have another file foo_const_slice.v which does this:

localparam SLICE_ADDR_BITS = NUM_BITS;


This compiles fine with the vcs command:

vcs -sverilog foo_const.v foo_const_slice.v

But when I try to use QuestaSim:

vlog -work work -sv foo_const.v foo_const_slice.v

I get the following error message:

** Error: foo_const_slice.v(46): (vlog-2730) Undefined variable: 'NUM_BITS'.","The problem is that by default, each file that vlog compiles goes into a separate compilation unit, just like C/C++ and many other languages. By default, vcs concatenates all files together into a single compilation unit.

Although there is a way to change the default (you can look it up in the user manual), the proper way to code this is to put your parameters in a package, and import the package where needed.

Dave",,,,,
floating point implementation warnings,"i'm trying to implement floating point multiplier module using xilinx ip cores for matrix multiplication and i get warnings for all the components output saying like that 
NgdBuild:443 - SFF primitive 'Multiplication.M44/blk00000003/blk0000057e' has unconnected output pin 
here is the code

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
USE ieee.std_logic_arith.all;
USE ieee.std_logic_unsigned.all;


entity Multiplier is
GENERIC( N : integer := 4);
PORT(
   clock,reset : IN STD_LOGIC;
   Aport: IN STD_LOGIC_VECTOR(31 downto 0);
    Bport: IN STD_LOGIC_VECTOR(31 downto 0);
    Xport:out STD_LOGIC_VECTOR(31 downto 0)
    );
end Multiplier;

architecture Behavioral of Multiplier is

type N_array is array (0 to N- 1) of STD_LOGIC_VECTOR (31 downto 0);    
type NfN is array (0 to N - 1) of N_array; 
TYPE state IS (state0, state1); 
SIGNAL pr_state, nx_state: state;
SIGNAL Ain_reg,Ain_next :NfN;
SIGNAL Bin_reg,Bin_next :N_array;
signal mul1,mul2,mul3,mul4,sum1,sum2 :N_array ;
signal prod_reg,prod_next:N_array;
Signal s_reg, s_next: INTEGER RANGE 0 TO 20;----used as counter
Signal P_reg, P_next: INTEGER RANGE 0 TO 10;----used as counter
Signal Address_reg, Address_next: INTEGER RANGE 0 TO 10;----used as counter
Signal out_reg,out_next: STD_LOGIC_VECTOR(31 downto 0);
---------------------------------------------------------------------------------------  
--Declaration of type and signal of a N element RAM  
--and a type and signal of a NXN element RAM
--with each element being 32 bit wide.
type ram_t is array (0 to N) of std_logic_vector(31 downto 0);
type ram_array is array (0 to N*n) of std_logic_vector(31 downto 0);
signal ram_B : ram_t := (others =&gt; (others =&gt; '0'));
signal ram_out : ram_t := (others =&gt; (others =&gt; '0'));
signal ram_A : ram_array := (others =&gt; (others =&gt; '0'));

 --------------------------------------------------------------------------------------
----------Components------------------------------------------------------------------
--This is the floating point 5 components adjusted to be used with virtex6
component Adder
port (
a: IN std_logic_VECTOR(31 downto 0);
b: IN std_logic_VECTOR(31 downto 0);
clk: IN std_logic;
result: OUT std_logic_VECTOR(31 downto 0));
end component;
 ------------------------------------------------------
component Multi
port (
a: IN std_logic_VECTOR(31 downto 0);
b: IN std_logic_VECTOR(31 downto 0);
clk: IN std_logic;
result: OUT std_logic_VECTOR(31 downto 0));
end component;
 --------------------------------------------------------------------------------------
BEGIN
 --------------------------------------------------------------------------------------  

Multiplication:BLOCK
Begin
M11:Multi port map (a =&gt; Ain_reg(0)(0),b =&gt; Bin_reg(0),clk =&gt; clock,result =&gt; mul1(0));
M12:Multi port map (a =&gt; Ain_reg(0)(1),b =&gt; Bin_reg(1),clk =&gt; clock,result =&gt; mul2(0));
M13:Multi port map (a =&gt; Ain_reg(0)(2),b =&gt; Bin_reg(2),clk =&gt; clock,result =&gt; mul3(0));
M14:Multi port map (a =&gt; Ain_reg(0)(3),b =&gt; Bin_reg(3),clk =&gt; clock,result =&gt; mul4(0));
S11: Adder port map (a =&gt;mul1(0),b =&gt; mul2(0),clk =&gt; clock,result =&gt; sum1(0));
S12: Adder port map (a =&gt;mul3(0),b =&gt; mul4(0),clk =&gt; clock,result =&gt; sum2(0));
PROD1: Adder port map (a =&gt; sum1(0),b =&gt;sum2(0),clk =&gt; clock,result =&gt; prod_next(0));

M21:Multi port map (a =&gt; Ain_reg(1)(0),b =&gt; Bin_reg(0),clk =&gt; clock,result =&gt; mul1(1));
M22:Multi port map (a =&gt; Ain_reg(1)(1),b =&gt; Bin_reg(1),clk =&gt; clock,result =&gt; mul2(1));
M23:Multi port map (a =&gt; Ain_reg(1)(2),b =&gt; Bin_reg(2),clk =&gt; clock,result =&gt; mul3(1));
M24:Multi port map (a =&gt; Ain_reg(1)(3),b =&gt; Bin_reg(3),clk =&gt; clock,result =&gt; mul4(1));
S21:Adder port map (a =&gt; mul1(1),b =&gt; mul2(1),clk =&gt; clock,result =&gt;  sum1(1));
S22:Adder port map (a =&gt; mul3(1),b =&gt; mul4(1),clk =&gt; clock,result =&gt;  sum2(1));
PROD2:Adder port map (a =&gt; sum1(1),b =&gt;sum2(1),clk =&gt; clock,result =&gt; prod_next(1));

M31:Multi port map (a =&gt; Ain_reg(2)(0),b =&gt; Bin_reg(0),clk =&gt; clock,result =&gt; mul1(2));
M32:Multi port map (a =&gt; Ain_reg(2)(1),b =&gt; Bin_reg(1),clk =&gt; clock,result =&gt; mul2(2));
M33:Multi port map (a =&gt; Ain_reg(2)(2),b =&gt; Bin_reg(2),clk =&gt; clock,result =&gt; mul3(2));
M34:Multi port map (a =&gt; Ain_reg(2)(3),b =&gt; Bin_reg(3),clk =&gt; clock,result =&gt; mul4(2));
S31:Adder port map (a =&gt; mul1(2),b =&gt; mul2(2),clk =&gt; clock,result =&gt;sum1(2));
S32:Adder port map (a =&gt; mul3(2),b =&gt; mul4(2),clk =&gt; clock,result =&gt;sum2(2));
PROD3:Adder port map (a =&gt; sum1(2),b =&gt;sum2(2),clk =&gt; clock,result =&gt; prod_next(2));

M41:Multi port map (a =&gt; Ain_reg(3)(0),b =&gt; Bin_reg(0),clk =&gt; clock,result =&gt; mul1(3));
M42:Multi port map (a =&gt; Ain_reg(3)(1),b =&gt; Bin_reg(1),clk =&gt; clock,result =&gt; mul2(3));
M43:Multi port map (a =&gt; Ain_reg(3)(2),b =&gt; Bin_reg(2),clk =&gt; clock,result =&gt; mul3(3));
M44:Multi port map (a =&gt; Ain_reg(3)(3),b =&gt; Bin_reg(3),clk =&gt; clock,result =&gt; mul4(3));
S41: Adder port map (a =&gt; mul1(3),b =&gt; mul2(3),clk =&gt; clock,result =&gt; sum1(3));
S42: Adder port map (a =&gt; mul3(3),b =&gt; mul4(3),clk =&gt; clock,result =&gt; sum2(3));
PROD4:Adder port map(a =&gt; sum1(3),b =&gt; sum2(3),clk =&gt; clock,result =&gt; prod_next(3));    

end BLOCK Multiplication;

 ---------- Lower section: ------------------------ 
 PROCESS (reset, clock) 
 BEGIN 
  IF (reset='1') THEN 
        pr_state &lt;= state0; 
        address_reg &lt;= 0;
        s_reg &lt;= 0;
        P_reg &lt;= 0;         
ELSIF (clock'EVENT AND clock='1') THEN 
        pr_state &lt;= nx_state; 
        s_reg &lt;= s_next;
        p_reg &lt;= p_next;
        Address_reg &lt;= Address_next;
        Ain_reg &lt;= Ain_next;
        Bin_reg &lt;= Bin_next;
     prod_reg&lt;=prod_next;
    out_reg&lt;=out_next;          
END IF;
END PROCESS; 

---------- Upper section: ------------------------ 
PROCESS (Bport,Aport,out_reg,Address_reg,pr_state,s_reg,Ain_reg,Bin_reg,prod_reg,p_reg)

BEGIN      
Address_next &lt;= Address_reg ;
s_next &lt;= s_reg;
p_next &lt;= p_reg;
Bin_next &lt;= Bin_reg ;
Ain_next &lt;= Ain_reg;
out_next &lt;= out_reg;
nx_state &lt;= pr_state ;
CASE pr_state IS                                                                        
WHEN state0 =&gt;                                                                        
        IF (s_reg &lt; N) THEN                                                           
            Bin_next(s_reg) &lt;= Bport;                                                           
            Ain_next(0)(s_reg) &lt;=  Aport;
            s_next &lt;= s_reg + 1;
        ELSif(s_reg &gt; 3 and s_reg &lt; 8) then
            Ain_next(1)(4-s_reg) &lt;=  Aport;
            s_next &lt;= s_reg + 1;
        ELSif(s_reg &gt; 7 and s_reg &lt; 12) then
            Ain_next(2)(8-s_reg) &lt;=  Aport;
            s_next &lt;= s_reg + 1;
        ELSif(s_reg &gt; 11 and s_reg &lt; 16) then
            Ain_next(3)(12-s_reg) &lt;=  Aport;
            s_next &lt;= s_reg + 1;
        ElSE
            s_next &lt;= 0;
            nx_state &lt;= state1;
        END IF; 
 WHEN state1 =&gt;  
        IF (P_reg &lt; N) THEN
            out_next&lt;= prod_reg(P_reg);  
            P_next &lt;= P_reg + 1;
         ELSE 
        --- P_next &lt;= 0;
            nx_state &lt;= state0;
         END IF;

 END CASE;

 END PROCESS;
  Xport &lt;= out_reg ;
end Behavioral;
","Probably you didn't enable some of the optional features of the IP core. The netlist however, does contain ports for these features. According to AR21718 you can safely ignore this type of warnings as the unused elements will be trimmed out during MAP phase.",,,,,
State Machine with VHDL for UA(R)T,"I am trying to create a state machine in vhdl for UA(R)T (Only the sending portion). 

I am having an issue with the flow of the program. I know the buad rate portion does not work at the moment. I am trying to get it working with just a clock at the moment, and then will implement the baud rate divider. 

When I run it through my test bench (nothing complicated, just assign a couple of initial values reset = 1 for x time, din = z, baud = y, etc), nothing happens. My output txd stays at the initial '1' value that is set in the reset stage and if I set it to '0' it will stay like that for the cycles. 

My issue that I had when designing the state machine is the it has two values that it will transition on BUT not in ever state. 

Basically, what it is supposed to do is:
reset: txd = 1, count = 1, busy = 0, we = 0
idle: when busy = 1 set shift = init values
wait: transition on next clock signal
trans: if count &lt; 9, txd = shift(0), and shift shift 
       if count = 9, busy = 0, count = 0
       and back to idle

I think my issue is somehow related to the busy signal not being properly set. 

-- Universal Asynch Receiver Transmitter
---------------------
library ieee;
use ieee.std_logic_1164.all;

entity eds_uart is
   generic (width : positive := 16);
   port ( clk,reset: in std_logic ;
     din_wen: buffer std_logic; -- state machine sets value thus buffer needed
     brd : in std_logic_vector(23 downto 0); -- buad rate dividor
     din : in std_logic_vector(7 downto 0); -- input value
     txd: out std_logic; -- sent data bit
     tx_busy : buffer std_logic -- sent data bit active
     );
end entity eds_uart;

architecture behaviour of eds_uart is
    type state_type is (idle_s, wait_s, transmit_s);  -- three possible states of uat
    signal current_s: state_type; 
    signal tick: std_logic; -- baud rate clock
    signal count: integer := 0; -- count number of characters sent
    signal shift: std_logic_vector(9 downto 0); -- intermediate vector to be shifted

begin
   -- assign tick value based on baud rate 
   -- need to implement divisor
   process(clk, brd) begin
      tick &lt;= clk;
   end process; 

   process(tick, reset, din) begin 
       if (reset = '1') then
           current_s &lt;= idle_s; -- default state
           count &lt;= 0; -- reset character counter
           txd &lt;= '1'; 
           tx_busy &lt;= '0'; 
           din_wen &lt;= '0'; -- able to start sending
       elsif (current_s = idle_s and din_wen = '1') then -- transition when write enable is high
           current_s &lt;= wait_s; -- transition
           tx_busy &lt;= '1';  
           shift &lt;= '1' &amp; din &amp; '0'; -- init shift value
       elsif (current_s = wait_s and rising_edge(tick)) then -- transition on clock signal
            current_s &lt;= transmit_s;
       elsif (current_s = transmit_s and rising_edge(tick)) then -- test transition on clock signal
            if (count &lt; 9) then
                txd &lt;= shift(0); -- output value
                shift &lt;= '0' &amp; shift(9 downto 1); -- shift to next value
                count &lt;= count + 1; -- increment counter
                current_s &lt;= transmit_s; -- dont change state
            elsif (count = 9) then 
                txd &lt;= shift(0); -- send last element
                count &lt;= 0;
                tx_busy &lt;= '0'; -- reset busy signal
                current_s &lt;= idle_s; -- start process again
           end if;
       end if;
   end process;
end architecture behaviour ;
","The comments:

-- state machine sets value thus buffer needed


and

-- transition when write enable is high


suggest that you may be expecting to have an additional external driver for din_wen. If that is the case the buffer mode is not doing you any good as it only exposes the value of the internal driver of din_wen which is only ever driving '0'. Post VHDL-2002, buffer is effectively a fancy, readable version of out without the limitations from earlier standards. It does not implement an input port. More significantly, it does not let you see the external resolved value if you have additional signal driver(s) outside this entity.

It isn't clear why you even need to drive din_wen internally since it is intended to be a control input that causes the transition into the wait_s state. Consider changing it to an in port mode and removing the reset assignment.

Style note: You are courting danger with the mixture of synchronous and asynchronous logic described here. You should stick to the pattern of having a single call to rising_edge() in a top level if block that wraps all of your synchronous logic.",,,,,
Is there a way to use one testbench for different simulators if both simulators need their own packages to be used?,"My testbench uses a function that is defined in a modelsim package (init_signal_spy). So I can't use this testbench with a different simulator than ModelSims vsim, for example Candence's ncsim. But there is an equivalent function for ncsim (nc_mirror) in the cadence packages. The solution is that I need to have two different testbenches.

But I want to use only one.
One solution could be, to define a package only if some constant is set. But I don't know if that is possible.","The general way to make proprietary functions from different vendors appear the same in a test bench, is to use a wrapper package that converts the functions to a function interface that you define.

To support both ModelSim and NCSim, you create three files:


wrap.vhd
wrap_modelsim.vhd
wrap_ncsim.vhd


The package wrap interface is defined in ""wrap.vhd"", thus with a common interface to functions, independent of the simulator.  The package body wrap is then defined in ""wrap_modelsim.vhd"" and ""wrap_ncsim.vhd"", with implementation depending on simulator.  

When compiling, only the appropriate package body file is used, depending on the simulator.  

The test bench then use work.wrap package, and can access the converted functions through wrap.{function}.",,,,,
How to update the header on the fly,"Is there a  way to change the header file on the fly?

The header file contains a lot of constants that can be used for the modules. In my application however, some of the constants must be changed often manually. Is there any way to change the values automatically?

I have tried the following approaches.
1. Use C++ to determine the constants and write them into the header file.
2. Use SV module to update the header file.
All these methods need additional steps before running the top module.
Is there any way to update the header file at the time of executing the simulator?

In the following header.v contains NUM, which is used in the module main.
The NUM is changed often.

This problem also holds for other languages, too, such as C++ or Java.

header.v:
`define NUM 256 //256 must be changed often

module top ();
    initial ...
    //instantiation
    main MAIN();

endmodule

//this module contains NUM
module main ();
    byte[0:`NUM - 1];

endmodule
","If it is different per module in the same simulation, then you should use parameter instead of &#96;define.

main #(parameter NUM) (/*portlist*/);
    // ...
    byte array [0:`NUM - 1]; // FYI 'byte' is a SystemVerilog keyword
    // ...
endmodule


Most simulations support passing a define from command line, which can work if the value is the same within a simulation, but different for each simulation. 


+define+NUM=256
-define NUM=256
-D NUM=256


To reduce redefine warnings, wrap a &#96;ifndef to the definition in header.v:

`ifndef NUM
  `define NUM 256 //256 must be changed often
`endif
",,,,,
VHDL FSM Implementation using port mapping,"I'm trying to implement VHDL code using Finite state machine and Port mapping to components 

Does any one have an idea how to do it, since it isn't allowed to include the port mapping inside the process statement?

------ and_2.vhd (component): --------- 
LIBRARY ieee; 
USE ieee.std_logic_1164.all; 
--------------------------------------- 
ENTITY and_2 IS 
PORT ( a, b: IN STD_LOGIC; 
y:OUT STD_LOGIC); 
END and_2; 
--------------------------------------- 
ARCHITECTURE and_2 OF and_2 IS 
BEGIN 
y &lt;= a AND b; 
END and_2; 
---------------------------------------
LIBRARY ieee; 
USE ieee.std_logic_1164.all; 
USE work.my_data.all;
ENTITY FSM_PORTMAPP IS
PORT(
   clk,reset : IN STD_LOGIC;
   A,b,c,d: IN STD_LOGIC;
    x: out STD_LOGIC
);
END FSM_PORTMAPP; 
ARCHITECTURE Flow OF FSM_PORTMAPP IS 
----------------------- 
COMPONENT and_2 IS 
PORT ( a, b: IN STD_LOGIC; y: OUT STD_LOGIC); 
END COMPONENT; 
-----------------------
TYPE state IS (state0, state1, state2); 
SIGNAL pr_state, nx_state: state;
signal y,z :std_logic;
BEGIN
U1:and_2 PORT MAP(a,b ,y);
U2:and_2 PORT MAP(c,d,z);
U3:and_2 PORT MAP(y,z,x);
process(clk,reset)
BEGIN 
IF (reset='1') THEN 
        pr_state &lt;= state0;
ELSIF (clk'EVENT AND clk='1') THEN 
        pr_state &lt;= nx_state; 
END IF;
end process;
process(pr_state)
BEGIN 
case pr_state IS
WHEN state0 =&gt; 
nx_state &lt;= state1;
WHEN state1=&gt; 
nx_state &lt;= state2;
WHEN state2 =&gt; 
nx_state &lt;= state0;
END CASE;
end process;
END Flow;
-------------------------------------------------


That is an example for declaration, I want to implement three states, with each state implementing one component.","First of all, think of component instantiation and port mapping as wiring circuit components, not performing operations. The mapping itself does not perform any operation - the logic in the component combined with the signals driven into the component achieve that. This is also why you can't map a component in a process - wiring is a fixed connection, not something that you can perform as a runtime operation. It's not executed code - it's concurrent logic.

In your example code, there are three instances of the component and_2, outside of any process. This mapping is basically what you need (provided you change the component and signal types to your particular function). Then, in your state machine, you can drive the inputs selectively, or read the outputs, or whatever you need. You will probably need some intermediate signals, and you would need to change your wiring around, and what you will most likely get on your first attempt is problematic code with latches where you don't want them and nice things like that. What you can do instead is just register the adder outputs:

U1 : adder_2 port map (a, b, y);
U2 : adder_2 port map (c, d, z);
U3 : adder_2 port map (y_r, z_r, x);

adder_regs : process (clk)
begin
  if rising_edge(clk) then
    y_r &lt;= y;
    z_r &lt;= z;
  end if;
end process adder_regs;


Or is there some other reason you're trying to do it the way you are?",,,,,
vhdl - incrementing a vector in the complex plane by a fractional amount,"I am working on a project that will generate and display the Mandelbrot set on a 640 x 480 vga display (other higher resolutions are planned).

Mapping the VGA x coord to the complex plane is fairly straightforward - If I take the Mandelbrot x region from -2.0 to + 2.0, and map it onto the VGA I get an x increment of .00625 ( 4/640) so that as the the vga x coord increases from 0 to 639, the complex coord needs to increment from -2.0 in steps of .00625.
I have been experimenting with fixed-point math with a format of Q4.28 (4 bits for the integer part and 28 bits for the fractional part).
Starting is easy enough - xE0000000 maps to -2.0 in the Q4.28 format.

My question is, in VHDL, and using fixed point arithmetic, how do I increment a vector by a fractional amount?

Note: my previous attempts while incorrect yielded results that ""looked"" correct as an image but were not, if one looks at the data set generated by the test bench and some c# code I wrote to compare results.
Thanks in advance.

EDIT : partial logic (from comment)

signal x_DELTA : signed(31 downto 0):= x""00199999""; 
signal cx_MIN : signed(31 downto 0):= x""E0000000""; 
signal cx : signed(31 downto 0); 

process(clk, reset, other stuff) 
begin 
   if reset = '1' then 
      cx &lt;= cx_MIN; 
   elsif rising_edge(clk) then 
      cx &lt;= cx + x_DELTA; 


Note: this code has been shortened and abbreviated to show relevant parts and to conform with comment character limits.","Fixed point addition works the same as regular integer addition. You have to ensure that the addends are both scaled (shifted) so that their binary points align. Multiply your increment by 2**28 to use it in your current format. Then you just add them together like any other integer.

If this increment will only be a constant it is better show the arithmetic to generate it in VHDL rather than manually compute a magic number by hand:

constant x_DELTA : integer := integer(4.0/640.0 * 2.0**28);
...
cx &lt;= cx + x_DELTA;


If you have to do a lot of fixed-point work you can make things easier by using the VHDL-2008 fixed_pkg package instead of manually keeping track of binary points and shifts. A VHDL-93 version was created during its initial development and should work in any current simulator and synthesizer.",,,,,
i'm generating a sine wave using the lut,"Port ( 
           data_out : out integer range -128 to 127
type ramtype is array (0 downto 29) of integer range -128 to 127;
signal ram : ramtype;
signal sine_wave : ramtype :=(0,16,31,45,58,67,74,77,77,74,67,58,45,31,16,0,
-16,-31,-45,-58,-67,-74,-77,-77,-74,-67,-58,-45,-31,-16);

signal clk :STD_LOGIC;
variable count : integer := 0;
variable inc : integer := 0; 
constant period :time := 10 ms;   -- 100 hz clk frequency 
begin
 process(clk)
 begin
    if rising_edge (clk) then


LINE:53    inc &lt;= inc + 1;        -- error
         for i in 0 to 29 loop
            data_out &lt;= sine_wave(count);
            end loop;

    end if;


end process;  

LINE 61:    process(inc)
     begin          

    clk &lt;= not clk after period/2;

 end process;


Line 53: Use := to assign to variable inc
Line 61: Sensitivity list can have only static signal name

I need a concurrent statament for line 53 bu the compiler is suggesting an other thing, and also the sensitivity list is not being accepted
Line 61: Sensitivity list can have only static signal name","
  i want to generate a sine wave where my clk frequency is 100 hz, and i
  want to sample it accordingly on every posedge of the clock


I did this earlier to find all problems with the portion of your code you did share.  It's still not clear what inc was doing in the clock process sensitivity list.

The clock process has been modified to output one complete waveform only.  Note both inc and count are declared as signals.

The range direction for ramtype has been changed from 0 downto 29 to 0 to 29.  

I set the default value for clk to '0' which allows not clock to not provide an 'U' (see the not truth table from package std_logic_1164:

-- truth table for ""not"" function
CONSTANT not_table: stdlogic_1d :=
--  -------------------------------------------------
--  |   U    X    0    1    Z    W    L    H    -   |
--  -------------------------------------------------
     ( 'U', 'X', '1', '0', 'X', 'X', '1', '0', 'X' );


clk has to have an initial value of '0' (or 'L') or '1' ( or 'H') to make the clock process work in simulation.

Your code fragment modified to analyze, elaborate, and simulate:

library ieee;
use ieee.std_logic_1164.all;

entity sinewave is
end entity;

architecture foo of sinewave is

   -- Port (
   --            data_out : out integer range -128 to 127
   signal   data_out: integer range -128 to 127;
   type ramtype is array ( integer range 0 to 29) of  -- was downto
                               integer range -128 to 127;
   -- signal ram : ramtype;
   constant sine_wave: ramtype := ( 
              0, 16, 31, 45, 58, 67, 74, 77, 77, 74, 67, 58, 45, 31, 16,
              0,-16,-31,-45,-58,-67,-74,-77,-77,-74,-67,-58,-45,-31,-16
           );

   signal clk :STD_LOGIC := '0';  --  so not clk gives '1' or '0'
   signal count : integer  range  0 to 29 :=  0;
   signal inc : integer :=  0;     
   constant period :time := 10 ms;   -- 100 hz clk frequency 
begin
    process(clk)
    begin
        if rising_edge (clk) then
LINE_53:     inc &lt;= inc + 1;        -- error

            if count = 29 then      -- count  is index pointer to sine_wave
                count &lt;= 0;
            else 
                count &lt;= count + 1;
            end if ;
            -- for i in 0 to 29 loop
            data_out &lt;= sine_wave(count);   
            report ""data_out &lt;= "" &amp; integer'IMAGE(sine_wave(count));
            --end loop;  
        end if;
     end process;  

LINE_61: process    -- modified to show every element of sine_wave once
    begin           
    wait for period/2;
    clk &lt;= not clk;  -- after period/2;
    if Now &gt; 29.5 * period  then
        wait;
    end if;
    end process;

end architecture;


Note how count is used as the index to sine_wave, so I added an increment to it.  It would seem redundant to have both inc and count.

The for loop got dropped as I explained in the comment because it doesn't do anything, simply repeating the same sine_wave assignment 30 times.  It doesn't affect simulation.

I made his into a test bench because you provided a clock process.

When run the report statements output the count indexed sine_wave value as a display for purposes of demonstration yielding:


ghdl -r sinewave
sine.vhdl:37:13:@5ms:(report note): data_out &lt;= 0
sine.vhdl:37:13:@15ms:(report note): data_out &lt;= 16
sine.vhdl:37:13:@25ms:(report note): data_out &lt;= 31
sine.vhdl:37:13:@35ms:(report note): data_out &lt;= 45
sine.vhdl:37:13:@45ms:(report note): data_out &lt;= 58
sine.vhdl:37:13:@55ms:(report note): data_out &lt;= 67
sine.vhdl:37:13:@65ms:(report note): data_out &lt;= 74
sine.vhdl:37:13:@75ms:(report note): data_out &lt;= 77
sine.vhdl:37:13:@85ms:(report note): data_out &lt;= 77
sine.vhdl:37:13:@95ms:(report note): data_out &lt;= 74
sine.vhdl:37:13:@105ms:(report note): data_out &lt;= 67
sine.vhdl:37:13:@115ms:(report note): data_out &lt;= 58
sine.vhdl:37:13:@125ms:(report note): data_out &lt;= 45
sine.vhdl:37:13:@135ms:(report note): data_out &lt;= 31
sine.vhdl:37:13:@145ms:(report note): data_out &lt;= 16
sine.vhdl:37:13:@155ms:(report note): data_out &lt;= 0
sine.vhdl:37:13:@165ms:(report note): data_out &lt;= -16
sine.vhdl:37:13:@175ms:(report note): data_out &lt;= -31
sine.vhdl:37:13:@185ms:(report note): data_out &lt;= -45
sine.vhdl:37:13:@195ms:(report note): data_out &lt;= -58
sine.vhdl:37:13:@205ms:(report note): data_out &lt;= -67
sine.vhdl:37:13:@215ms:(report note): data_out &lt;= -74
sine.vhdl:37:13:@225ms:(report note): data_out &lt;= -77
sine.vhdl:37:13:@235ms:(report note): data_out &lt;= -77
sine.vhdl:37:13:@245ms:(report note): data_out &lt;= -74
sine.vhdl:37:13:@255ms:(report note): data_out &lt;= -67
sine.vhdl:37:13:@265ms:(report note): data_out &lt;= -58
sine.vhdl:37:13:@275ms:(report note): data_out &lt;= -45
sine.vhdl:37:13:@285ms:(report note): data_out &lt;= -31
sine.vhdl:37:13:@295ms:(report note): data_out &lt;= -16


Your 10 msec clock period means the sine wave is 3.333.. Hz.",,,,,
Implementing an Accumulator in VHDL,"I am trying to implement a signed accumulator using Core Gen in Xilinx. According to my understanding an accumulator performs the function of a normal register which is just routing the input to the output, but I wanted clarification on that. 

I added the Accumulator IPcore (.xco) module to the project and I have a main file which basically contains the component declaration and the port map. I have a single step process too. Everything compiles and I can see the result on the board but don't quite understand what's going on...  

When I input 1000 the 8 bit output on the LEDs is 11111000. Another input of 1111 gives me 11110111. I am attaching the code here for the main vhd file called Accm and the .vho file.

----------------------------------------------------------------------------------

----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity Accm is
port( b: in std_logic_vector(3 downto 0);
        sclr, clk, b1, b2 : in std_logic;
        q : out std_logic_vector(7 downto 0)
);      

end Accm;

architecture Behavioral of Accm is

-- signal declaration
type tell is (rdy,pulse,not_rdy);
signal d_n_s: tell; 
signal en: std_logic;

-- component declaration
COMPONENT my_accm
  PORT (
    b : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    clk : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END COMPONENT;

-- port map
begin

A1 : my_accm
  PORT MAP (
    b =&gt; b,
    clk =&gt; en,
    sclr =&gt; sclr,
    q =&gt; q
  );

process(clk)
begin
if clk'event and clk='1' then
case d_n_s is
when rdy =&gt; en &lt;= '0';
if b1='1' then d_n_s &lt;= pulse; end if;
when pulse =&gt; en &lt;= '1';
d_n_s &lt;= not_rdy;
when not_rdy =&gt; en &lt;='0';
if b2='1' then d_n_s &lt;= rdy; end if;
end case;
end if;
end process;

-- .VHO CODE

------------- Begin Cut here for COMPONENT Declaration ------ COMP_TAG
COMPONENT my_accm
  PORT (
    b : IN STD_LOGIC_VECTOR(3 DOWNTO 0);
    clk : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END COMPONENT;
-- COMP_TAG_END ------ End COMPONENT Declaration ------------

-- The following code must appear in the VHDL architecture
-- body. Substitute your own instance name and net names.

------------- Begin Cut here for INSTANTIATION Template ----- INST_TAG
your_instance_name : my_accm
  PORT MAP (
    b =&gt; b,
    clk =&gt; clk,
    sclr =&gt; sclr,
    q =&gt; q
  );

end Behavioral;


I am also pasting an image of the accumualtor I generated in CoreGen. 

I'D appreciate it if someone could explain me what is going on in this program. Thanks!","""Accumulator"" can mean many things.  In the hardware Xilinx library, the component you instantiated is an adder in front of a register.  The adder is adding the current value of the accumulator register with the input term.  The accumulator register is wider than the input so you can accumulate (add together) many input terms without overflowing the output.

When your circuit starts, the accumulator contains zero.  You input 1000 (-8) which when added to zero becomes 11111000 (-8 sign extended) on the output.  You then add 1111 (-1), and the output becomes 11110111 (-9 sign extended).

Once you are done ""accumulating"", assert SCLR to clear the accumulator register back to zero (or use SSET or SINIT, as appropriate for your logic).

This should all be covered by the documentation for the Xilinx library (try clicking the ""datasheet"" button in the corgen dialog).",,,,,
Structural 4 bit ring counter with D flip flop. VHDL / GHDL,"I don't know how to do this with structural programming...
&quot;A binary counter (with reset signal) of 4 bits made of 4 D flip flops.&quot;
How to connect in/outs?
Here is the entity declarations. The core of the problem is at the last lines.
                    --FFD
            entity FFD is
            port( CLK, D, reset : in STD_LOGIC;
                Q : out STD_LOGIC
               );
            end FFD;
            
            architecture behaviour of FFD is
            begin
                process(CLK, reset)
                begin
                if reset='1' then Q&lt;='0';  
                elsif (clk'event and clk='1') then Q&lt;=D;
                else null;
                end if;
                end process;
            end behaviour;
        ----------------------------------------------------------  
            
        --counter

        library IEEE;
        use IEEE.std_logic_1164.all;
        use IEEE.numeric_std.all;

            entity counter is
            port(clk : in std_logic;
               reset : in std_logic;
               count : out std_logic_vector(3 downto 0));
            end entity counter;

                architecture rtl of counter is
            
            --
            component FFD 
            port (CLK, D, reset : in STD_LOGIC;
                       Q : out STD_LOGIC);
            end component;
            
            signal q0,q1,q2: std_logic:='0';
            signal q3: std_logic:='1';
            
            begin
            -- 

            ---
            inst1: FFD port map (CLK=&gt;clk, D=&gt;q3, reset=&gt;reset, Q=&gt;q0);
            inst2: FFD port map (CLK=&gt;clk, D=&gt;q0, reset=&gt;reset, Q=&gt;q1);
            inst3: FFD port map (CLK=&gt;clk, D=&gt;q1, reset=&gt;reset, Q=&gt;q2);
            inst4: FFD port map (CLK=&gt;clk, D=&gt;q2, reset=&gt;reset, Q=&gt;q3);
            inst5: count&lt;=q3&amp;q2&amp;q1&amp;q0;
            end architecture rtl;

My problem is in this last lines.","There's no issue with your connections (they correctly form a ring counter), but you're not going to see much happen.  After reset, all of your flip-flops contain zero, which will get circulated around the ring with each clock pulse but never actually cause a change in the outputs.  The assignment of a default value of '1' for q3 when you declare the signal will be overridden by the actual output of the flip-flop as soon as your circuit starts operating (or simulating), and is generally the wrong way to initialize hardware.

You need to insure that when you assert the reset signal, your hardware transitions into an appropriate state (ie: one bit set, all others clear).  One way to do this would be to use a FF with a set input for Q3.  If you don't have a flip flop that with a set (instead of a reset) signal, you can simulate one by putting inverters on the input and output, which will provide a '1' to be clocked around your ring counter when you apply reset.  You could also create some intermediate signals and craft a multiplexer for the D inputs to build a loadable counter, or any of a variety of other solutions...",,,,,
fixing bit width mismatch,"I've run this code to the lint checker (spyglass):

     1 module test(
     2         output  [7:0] O_O,
     3         input   [7:0] I_1,
     4         input   [7:0] I_2
     5 );
     6
     7         wire    [14:0] result;
     8
     9         assign result = (I_1 + I_2) &lt;&lt; 5;
    10         assign O_O = result[7:0];
    11 endmodule


I get this warning message:

    Bit-width mismatch in signal assignment (LHS: 'O_O' width 8 should match RHS: '((I_1 + I_2) &lt;&lt; 5)' width 14). [Hierarchy:test]


To avoid this warning, I changed my code like this:

     1 module test(
     2         output  [7:0] O_O,
     3         input   [7:0] I_1,
     4         input   [7:0] I_2
     5 );
     6         wire    [15:0] result;
     7
     8         assign result = (I_1 + I_2) &lt;&lt; 5;
     9         assign O_O = result[7:0];
    10 endmodule


Then got this warning message

    Port 'O_O[4:0]' is 'tied-low'


Any recommendations to fix those warnings?","Does this work?

 1 module test(
 2         output  [7:0] O_O,
 3         input   [7:0] I_1,
 4         input   [7:0] I_2
 5 );
 6
 7         wire    [14:0] result = (I_1 + I_2) &lt;&lt; 5;
 8
 9         assign O_O = result[7:0];
10 endmodule
",,,,,
VHDL MIPS 5 stage pipeline Bug,"The code for this is too long to post so Ill just describe it. I've created a 5 stage mips pipe that almost works. The catch is that EVERY lw instruction that reaches the instruction decode stage overwrites the control signal values in the execution stage. Not only that it causes the PC to skip can instruction, i.e from 300 -> 308. I just need some idea on where to look for bugs since this is a class assignment. If we take out all the LW instructions the CPU works fine.

Example: 
 The adder in the EX stage is going to  sub $4 $1 $2  which should be 1
 Once LW enters the ID stage ALUsrc is asserted AND ALUop is changed from subtract to add
 This forces the adder in the EX stage to add $4 $1 $2 resulting in 5 being stored in $4","http://en.wikipedia.org/wiki/File:MIPS_Architecture_%28Pipelined%29.svg


The MIPS 5 Stage Pipeline (annotated to show Write Reg Select and enable)

The bottom line through the pipeline stages represents the register file write (back) port address and write enable and WB is the data from memory.

http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html

Load Word Instruction
Description:
A word is loaded into a register from the specified address.

Operation: $t = MEM[$s + offset]; advance_pc (4);

Syntax: lw $t, offset($s)

Encoding:
1000 11ss ssst tttt iiii iiii iiii iiii 

Where the write register address ($t) input is read from data memory address comprised of register file register $s offset with the immediate value i which gets sign extended. Your $4 is $t above, $1 or $2 is $s while the remaining register file output lane sounds to be suborned for the sign extended immediate.

From your description it sounds like you aren't using a three port register file with one port a write only port.

With a three port register file the only time you run into conflicts is when you attempt to use the new register file value from memory before it is read from memory and written to the register file.  That can be managed by a compiler scheduling NOOPs until the outstanding register file write is retired when a following instruction is trying to use it, or stalling the IF/ID in hardware when it's output contains a reference to an outstanding register file write.  

There are three instructions that can be in flight to the right of IF/ID, each with a write to register file address and a write enable.  You'd need to compare both instruction decode register file addresses to all three of those and stall IF/ID until those clear out.  The write enable stored in each of those three pipeline stages are used to determine whether the write register address in those pipeilne stages should be compared.

Because the ID/EX, EX/MEM and MEM/WB write register file addresses are not used anywhere else the circuitry for doing the comparison can be collocated with IF/ID and the Register File, preventing unnecessary layout delays affecting the minimum clock cycle.

Using a two port register file is much simpler and infers IF/ID stalling until the write enable comes back from MEM/WB, effectively turning any memory reading instructions into 3 cycle instructions (or more, data memory can stall if it's a cache or slow).  It makes a three port register file more or less necessary for performance reasons. There's an implied multiplexer to source for at least one of the two register file port controls (write enable, write address) from the MEM/WB stage when IF/ID is stalled (for memory->regfile).  

Data memory access can stall MEM/WB, just like instruction memory access can also stall IF/ID.  A stalled IF/ID doesn't issue a write enable for the register file to ID/EX nor does a stalled MEM/WB.",,,,,
Can I split a file into four parts (across four memories) in Verilog?,"Forgive a newbie, I don't even know how to ask this question properly: 

I have a file which is currently loaded into a memory bank, and I'd like to split it across four different memory banks.   

I have some system verilog code which uses a line very like this:

$readmemh(mem_file, memories.ram);


to read in a hex file (say it's 65536 bytes long) to some memory.

Now I want to split the memory into four parts, and put the first quarter (16384 bytes) into a block, the second quarter into another, etc...

One obvious way to do this is to split the hex file using head, tail, etc, as part of the build process that makes it, and then pass in all the new filenames at simulation time, and have statements like

$readmemh(mem_file_1stbit, memories.ram1);
$readmemh(mem_file_2ndbit, memories.ram2);
$readmemh(mem_file_3rdbit, memories.ram3);
$readmemh(mem_file_4thbit, memories.ram4);


But that seems to couple the firmware build process, simulation script, and verilog design far too much for my taste.

A greatly superior solution (in my opinion), would be to modify the verilog code to say something like:

$readmemh(mem_file, memories.ram1, 0,       (1&lt;&lt;14)-1);
$readmemh(mem_file, memories.ram2, (1&lt;&lt;14), (2&lt;&lt;14)-1);
$readmemh(mem_file, memories.ram3, (2&lt;&lt;14), (3&lt;&lt;14)-1);
$readmemh(mem_file, memories.ram4, (3&lt;&lt;14), (4&lt;&lt;14)-1);


But it doesn't look like verilog will let me do this sort of thing.

Can anyone come up with a neat construction that will achieve the same result?","This little snippet seems to do the business. It does introduce an intermediate load of stuff that I rather hope won't end up getting synthesised.

I'll go with this sort of thing. If anyone who actually knows what they're doing wants to tell me why this is a bad idea, I'd be most grateful.

   reg [8:0] data [0:15];
   reg [8:0] data1 [0:7];
   reg [8:0] data2 [0:7];

   integer   i;

   initial begin
      $readmemh(""data.hex"", data);
      for(i=0; i&lt;16; i=i+1) 
        $display(""%d:%h"",i,data[i]);
      for(i=0; i&lt;8; i=i+1)
        begin
           data1[i]=data[i];
           data2[i]=data[i+8];
        end
   end
",,,,,
Grabbing the digits of a number without using division or modulus,"I am trying to implement a 7-segment counter using VHDL.

The counter starts from 0 and increments an integer value to a max of 9999.

The value is passed to a bloc that is supposed to ""split"" the number into digits so that i can display them on the 7-segment which are multiplexed...

I have already done this on a PIC using many methods such as Interrupts... but now that i am trying to do this on a FPGA (Xilinx Spartan 3E Starter Board to be exact) i noticed while implementing the code i've wrote that i can't use neither division nor modulus because they cannot be implemented...

Edit: I know i could just map the values 0..9999 each alone but that is far far fetched.

Surely there is another way, but i can't think of it.

Any hint on a workaround would be very appreciated!","Well, if your number is in decimal, just extract the bits containing each digit and send them to your display multiplexor. The LSD is num[3:0], the MSD is num[15:12], etc.",,,,,
Why is there a difference in Output when using Event Control Statement and Wait statement for the following simple D Flipflop example,"I have created a testbench for a simple positive edge trigerred d flip flop with synchronous active low reset. In the testbench, the first case gives inputs at ""@posedge clk"" and in the second case i am giving inputs based on ""wait 10ns"" statements.

In the first case the output of the flop changes after 1 clock cycle, whereas in the second case it changes immediately in the same clock cycle in the simulator. 

I am simulating in Quartus Simulator.

Why ? Thats what i wanted to know.

Code as below:
////////////////////////////

initial
begin
    //Case 1: Using Event Based statements
    n_reset = 1'b0;
    reset = 1'b1;
    d = 1'b0;
    repeat(2)@(posedge clk);
    n_reset = 1'b1;
    repeat(2)@(posedge clk);
    d = 1'b1;
    @(posedge clk);
    d = 1'b0;
    @(posedge clk);
    d = 1'b1;

    //Case 2: Using wait Statement
    #50ns;
    n_reset = 1'b0;
    reset = 1'b1;
    d = 1'b0;
    #50ns;
    n_reset = 1'b1;
    #20ns;
    d = 1'b1;
    #10ns;
    d = 1'b0;
    #10ns;
    d = 1'b1;
    #50ns;

end


Waveform of D FlipFlop with the testbench","Using wait Statement:

Delays the execution of a procedural statement by specific simulation time.

""#&lt;_time> &lt;_statement>;""

Using Event Based statements:

Delays execution of the next statement until the specified transition on a signal.

@ (&lt; posedge >|&lt; negedge > signal) &lt; statement >;

Level-Sensitive Even Controls ( Wait statements ):

Delays execution of the next statement until &lt; expression > evaluates to true

wait (&lt; expression >) &lt; statement >;

Now I think you are able to differentiate, Right?",,,,,
VHDL: Adding operations to 8-bit ALU,"I'm very new to VHDL and am required to modify this ALU with an additional eight operations, which aren't relevant themselves but from the testing in GTKwave I see that the clk(clock) and r(result) discontinue simulating after the first eight operations it seems, although the op waveform acknowledges them. Both source and test bench compile fine with no errors, resulting what seems to be incorrect waveforms.  Waveforms/Testing

I tried to fix this by going back into the test bench code and changing the â€˜exit L1 when i &gt;10;â€?loop from 10 to 20(or any other over 10) and then recompiling, but this resulted in a â€œbound check failureâ€?error which stumped me. I also tried changing modifying to make it 16-bit, but that didn't compile - definitely not the solution I imagine.

Ignore the mixed up operational comments.

Any help would be much appreciated, I'm assume it's a very novice overlook. 

Initial code derived from http://vhdlguru.blogspot.co.uk/2011/06/vhdl-code-for-simple-alu.html

SOURCE CODE

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity Ex8 is
port(   Clk : in std_logic;             --clock signal
        A,B : in signed(7 downto 0);    --input operands
        Op : in unsigned(3 downto 0);   --Operation to be performed -- 2 to 3
        R : out signed(7 downto 0)      --output of ALU
        );
end Ex8;

architecture Behavioral of Ex8 is

--temporary signal declaration.
signal Reg1,Reg2,Reg3 : signed(7 downto 0) := (others =&gt; '0');

begin

Reg1 &lt;= A;
Reg2 &lt;= B;
R &lt;= Reg3;

process(Clk)
begin

if(rising_edge(Clk)) then --Do the calculation at the positive edge of clock cycle.
    case Op is
        when ""0000"" =&gt;
            Reg3 &lt;= Reg1 + Reg2;    --addition
        when ""0001"" =&gt;
            Reg3 &lt;= Reg1 - Reg2;    --subtraction
        when ""0010"" =&gt;
            Reg3 &lt;= not Reg1;       --NOT gate
        when ""0011"" =&gt;
            Reg3 &lt;= Reg1 nand Reg2; --NAND gate
        when ""0100"" =&gt;
            Reg3 &lt;= Reg1 nor Reg2;  --NOR gate
        when ""0101"" =&gt;
            Reg3 &lt;= Reg1 and Reg2;  --AND gate
        when ""0110"" =&gt;
            Reg3 &lt;= Reg1 or Reg2;   --OR gate
        when ""0111"" =&gt;
            Reg3 &lt;= Reg1 xor Reg2;  --XOR gate
        when ""1000"" =&gt;
            Reg3 &lt;= Reg1 / Reg2;    --division
        when ""1001"" =&gt;
            Reg3 &lt;= Reg1 * Reg2;    --multiplication
        when ""1010"" =&gt;
            Reg3 &lt;= Reg1 xnor Reg2; --rotate left
        when ""1011"" =&gt;
            Reg3 &lt;= Reg1 srl 4;     --rotate right
        when ""1100"" =&gt;
            Reg3 &lt;= Reg1 &amp; Reg2;    --shift left logical
        when ""1101"" =&gt;
            Reg3 &lt;= Reg1 sll 4;     --shift right logical
        when ""1110"" =&gt;
            Reg3 &lt;= Reg1 mod Reg2;  --modulo
        when ""1111"" =&gt;
            Reg3 &lt;= Reg1 rem Reg2;  --remainder

        when others =&gt;
            NULL;

       end case;
    end if;
end process;
end Behavioral;


TEST BENCH

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY Ex8_tb IS
END Ex8_tb;

ARCHITECTURE behavior OF Ex8_tb IS

   signal Clk : std_logic := '0';
   signal A,B,R : signed(7 downto 0) := (others =&gt; '0');
   signal Op : unsigned(3 downto 0) := (others =&gt; '0');
   constant Clk_period : time := 10 ns;

BEGIN

            -- Instantiate the Unit Under Test (UUT)
   uut: entity work.Ex8 PORT MAP (
          Clk =&gt; Clk,
          A =&gt; A,
          B =&gt; B,
          Op =&gt; Op,
          R =&gt; R
        );

        -- Clock process definitions
   Clk_process :process
   variable i : POSITIVE := 1;
   begin
        L1: loop
        Clk &lt;= '0';
        wait for Clk_period/2;
        Clk &lt;= '1';
        wait for Clk_period/2;
        i:= i+1;
        exit L1 when i &gt;10;
        end loop L1;                -- changed from failure to warning
        assert false report ""NONE. End of simulation."" severity warning;  
        wait;                   -- added wait;
   end process;

-- Stimulus process
   stim_proc: process
   begin
      wait for Clk_period*1;
        A &lt;= ""00010010"";                        --18 in decimal
        B &lt;= ""00001010"";                        --10 in decimal
        Op &lt;= ""0000"";  wait for Clk_period;     --add A and B
        Op &lt;= ""0001"";  wait for Clk_period;     --subtract B from A.
        Op &lt;= ""0010"";  wait for Clk_period;     --Bitwise NOT of A
        Op &lt;= ""0011"";  wait for Clk_period;     --Bitwise NAND of A and B
        Op &lt;= ""0100"";  wait for Clk_period;     --Bitwise NOR of A and B
        Op &lt;= ""0101"";  wait for Clk_period;     --Bitwise AND of A and B  
        Op &lt;= ""0110"";  wait for Clk_period;     --Bitwise OR of A and B
        Op &lt;= ""0111"";  wait for Clk_period;     --Bitwise XOR of A and B
        Op &lt;= ""1000"";  wait for Clk_period;     --Bitwise DIV of A and B
        Op &lt;= ""1001"";  wait for Clk_period;     --Bitwise MUL of A and B
        Op &lt;= ""1010"";  wait for Clk_period;     --Bitwise ROL of A and B
        Op &lt;= ""1011"";  wait for Clk_period;     --Bitwise ROR of A and B
        Op &lt;= ""1100"";  wait for Clk_period;     --Bitwise SLL of A and B
        Op &lt;= ""1101"";  wait for Clk_period;     --Bitwise SRL of A and B
        Op &lt;= ""1110"";  wait for Clk_period;     --Bitwise MOD of A and B
        Op &lt;= ""1111"";  wait for Clk_period;     --Bitwise REM of A and B
      wait;
   end process;

END;
","You have one problem in your code that prevents it compiling; you have one that prevents it simulating (a run-time error). Both fail for the same reason: array sizes do not match.

This line might not compile:

Reg3 &lt;= Reg1 &amp; Reg2;


This is because reg1, reg2 and reg3 are all the same width. &amp; is concatenation - the joining of two arrays to make a bigger array. The width of reg3 needs to be equal to the width of reg1 plus the width of reg2. (I say ""might not"" because it gave a compile error on one simulator and a runtime error on another).

I then changed this line:

exit L1 when i &gt;10;


to this:

exit L1 when i &gt;20;


as you suggested and then got a run time error at this line:

Reg3 &lt;= Reg1 * Reg2;    --multiplication


This is again because reg1, reg2 and reg3 are all the same width. The multiplication operator defined in the numeric_std package outputs a result with width equal to the sum of the widths of the two operands, ie the width of reg1 plus the width of reg2. 

So, you need to think about the widths of your inputs and outputs or you need to do some truncation (but that would make your concatenation operation pointless).",,,,,
ModelSim SE 5.7: unexpected 'Z' and 'X',"While getting my feet wet with an old Spartan2-Board I tried to setup a 1-bit full adder with the Verilog code and accompanying testbench as below:

module full_adder(s, cout, a, b, cin);
output s, cout;
input a, b, cin;

wire t1, t2, t3;

xor (t1, a, b);
xor (s, t1, cin);
and (t2, t1, cin);
and (t3, a, b);
or  (cout, t2, t3);
endmodule


Testbench:

module tb_full_adder;

// Inputs
reg a;
reg b;
reg cin;

// Outputs
wire s;
wire cout;

// Instantiate the Unit Under Test (UUT)
full_adder uut (
    .s(s), 
    .cout(cout), 
    .a(a), 
    .b(b), 
    .cin(cin)
);

initial begin
    // Initialize Inputs
    a = 0;
    b = 0;
    cin = 0;

    // Wait 100 ns for global reset to finish
    #100;

    //125 ns
    #25;    a = 1'b1;
    //150 ns
    #25;    a = 1'b0;   b = 1'b1;
    //175 ns
    #25;    b = 1'b0;   cin = 1'b1;

end      
endmodule


I had to use ISE 10.1 and ModelSim SE 5.7 because the more recent versions of the ISE don't support any of the Spartan devices any more, IIUC (let alone Vivado). 
The issue is that the 'Wave window' of ModelSim shows all the signals as either hi-Z or don't care 'X':



If I setup the exact same project in ISE 14.7, the code also compiles and the simulation, in this case it's the more recent ISim, shows the expected traces:



What is the difference between ModelSim and ISim, besides its age ?
What am I missing ?

best,
Chris","There is nothing different between Modelsim and ISim in this respect. With Modelsim you have not simulated your testbench. I can tell that because the signal names in the waveform viewer all start /full_adder/ rather than /tb_full_adder/uut/. I manged to get a similar waveform to your ISim waveform in Modelsim by simulating the testbench, too, ie by typing vsim tb_full_adder in the transcript window.",,,,,
conditionally calling a module using case statement,"I want to implement module adder when sel=0, and module subtractor when sel=1. I learnt that generate can be used to call module within another module conditionally. 

3.         module checker(o,a,b,sel);
4.         output reg o;
5.         input a,b,sel;
6.         always@(*)
7.         begin
8.         generate
9.         case (sel)                               
10.        1'b0 : adder a1(.sum(o),.a(a),.b(b));
11.        1'b1 : subtractor s1(.diff(o),.a(a),b(b));
12.        endcase
13.        endgenerate
14.        end
15.        endmodule

        //errors shown are:

    D:/FILES/verilog files/Neha/checker.v"" Line 8: Syntax error near ""generate"".
    D:/FILES/verilog files/Neha/checker.v"" Line 11: Port connections cannot be mixed ordered and named.
    D:/FILES/verilog files/Neha/checker.v"" Line 13: Syntax error near ""endgenerate"".
    D:/FILES/verilog files/Neha/checker.v"" Line 10: Instantiation is not allowed in sequential area except checker instantiation.
    D:/FILES/verilog files/Neha/checker.v"" Line 11: Instantiation is not allowed in sequential area except checker instantiation


Thanks in advance!","We're designing hardware here, not writing software. A Verilog module is a lump of hardware. You cannot ""call"" a Verilog module any more than you can ""call"" a chip on a PCB.

Your adder and subtractor modules are lumps of hardware. You cannot ""call"" them. What you need is some hardware - probably a multiplexer - to select the two outputs and drive the o output:

module checker(o,a,b,sel);
  output /* is this really 1 bit wide?   */ o;
  input  /* are these really 1 bit wide? */ a,b;
  input sel;

  wire   /* are these really 1 bit wide? */ sum, diff;;

  adder      a1(.sum(sum),   .a(a), .b(b));
  subtractor s1(.diff(diff), .a(a), .b(b));

  assign o = sel ? diff : sum;

endmodule


By the way - surely your inputs and outputs are more than 1 bit wide?",,,,,
Write C statement in VHDL,"I am new to VHDL, but I have managed to create a processor in VHDL with some help (it has ALU, multiplier, and a bus architecture to access SRAM memory). The processor decodes 32-bit instructions (which contains the type of operations and the memory addresses).

How do I write the following C code in the processor?

int i = 0;
int c = 0;

int a[10] = ""0,1,2,3,4,5,6,7,8,9"";
int b[10] = ""1,0,-1,0,1,0,2,1,-1,1"";

for (i = 0; i &lt; 9; i++) c += (a[i]*b[i]);


I'm guessing I would write a list of instructions for this C code in the testbench:

1st instruction: multiply a[0] with b[0]
2nd instruction: add the result to c


and repeat for 9 times.

Is this the right way? Is there a better way to implement the for-loop? Is there a way to write C-code directly in my tb_top.vhd?","Of course, you can manually translate the C code to assembler code, and then assemble this to binary code. But, a better option is to use a C compiler and / or assembler for your processor. If there is no one available and you plan to use your processor for longer / many programs, you can build a new compiler on top of gcc and a new assembler on top of binutils, for example.

Then place the binary output into the instruction ROM. If you simulate the processor itself without memory and I/O devices, then emulate the instruction ROM in your testbench. An array of std_logic_vector should fit your needs:

type rom_t is array(natural range &lt;&gt;) of std_logic_vector(7 downto 0) ; 
constant rom : rom_t(0 to 63) := (
  0 =&gt; x""00"", -- insert binary code of instruction at address 0 here
  1 =&gt; x""00"", -- instruction at address 1
   -- and so on
   others =&gt; x""00"" -- fill remaining ROM with zero
 );


The example defines a ROM with 64 addresses, each storing a byte. You will have to update the ranges and the memory content to fit your needs.",,,,,
How to split the sequential and the combinational in verilog,"I am trying to make a counter in verilog and I want to know how to split the sequential part from the combinational one.

I have this module, it works fine, but I don't know how to split it?

module counter4bits(
    input clk_i,
    input rst_n_i,
    input enable_i,
    input   up_down_i,
    output reg[3:0] val_o);

    always@(posedge clk_i) begin
        if (rst_n_i == 1)
            val_o &lt;= 0;
        else if(enable_i == 1)
            val_o &lt;= val_o + 1;
        end

endmodule
","One way is to make always @(*) blocks for the combinational parts using blocking assignments (=), and make always @(posedge clk_i) blocks for the sequential parts using non-blocking assignments (&lt;=) to simple reg.

The blocking assignment (=) in combinational gives faster simulation and predictable behavior even if explicit sensitivity lists line @(rst_n_i or enable_i or ...) are used instead of @(*).  The non-blocking assignment (&lt;=) in sequential logic gives the expected flip-flop behavior where the next value depends on the previous value.

The code will then look like:

module counter4bits(
    ... input/output with no change
    reg [3:0] val_nxt;  // Not flip-flop but used in always @(*) thus reg

    always @(*) begin
        if (rst_n_i == 1)
            val_nxt = 0;
        else if(enable_i == 1)
            val_nxt = val_o + 1;
        end

    always @(posedge clk_i)
        val_o &lt;= val_nxt;

endmodule
",,,,,
"Verilog VGA signal implementation: ""stretched horizontal""","I'm implementing the XGA (1024x768) video protocol with an Altera FPGA. I have images displaying, with correct color and crisp vertical display (i.e., setting every nth vertical pixel to black results in a sharp horizontal line w/o aliasing). However, the horizontal display (vertical lines) is very skewed, with the 1-pixel-wide lines being ""smeared"" across a 3 to 4 pixel width. Additionally, the width of the display signal is too wide. Attempting to create an even height and width grid results in the cells being wider than they are tall.

I've checked all of my timings via logic analyzer against these values, and they are extremely accurate, to within hundredths precision. 

Based on this problem description, any ideas on where to look for debugging? Considering that the vertical is spot-on, I'm thinking it has something to do with my horizontal sync? VGA signal generation code:

module vga_sig_gen
(
    clk,
    reset_n,
    vga_BLANK_N,
    vga_SYNC_N,
    vga_HS,
    vga_VS,
    vga_R,
    vga_G,
    vga_B
);

// XGA signals
input clk;
input reset_n;
output reg vga_BLANK_N;
output reg vga_SYNC_N;
output reg vga_HS;
output reg vga_VS;
output reg [7:0] vga_R;
output reg [7:0] vga_G;
output reg [7:0] vga_B;

// Frame/line position
reg [11:0] hor_pos;
reg [9:0] vert_pos;

always @ (posedge clk) begin
    if(!reset_n) begin
        {vga_R, vga_G, vga_B} &lt;= 24'h000000;
        hor_pos &lt;= 12'd0;
        vert_pos &lt;= 10'd0;
    end
    else begin
        // Update RGB values
        {vga_R, vga_G, vga_B} &lt;= (hor_pos % 48 == 0) || (vert_pos % 48 == 0) ? 24'd0 : 24'hB93E06;

        // Update line/fram position
        hor_pos &lt;= (hor_pos == 12'd1343) ? 12'd0 : hor_pos + 12'd1;
        if(hor_pos == 12'd1343) begin
            if(vert_pos == 10'd805) begin
                vert_pos &lt;= 10'd0;
            end
            else begin
                vert_pos &lt;= vert_pos + 10'd1;
            end
        end
    end

    // Generate VGA signals
    vga_BLANK_N &lt;= ((hor_pos &gt; 12'd319) &amp;&amp; (vert_pos &gt; 10'd37)) ? 1'b1 : 1'b0;
    vga_HS &lt;= ((hor_pos &gt; 12'd23) &amp;&amp; (hor_pos &lt; 12'd160)) ? 1'b0 : 1'b1;
    vga_VS &lt;= ((vert_pos &gt; 10'd2) &amp;&amp; (vert_pos &lt; 10'd9)) ? 1'b0 : 1'b1;
    vga_SYNC_N &lt;= 1'b0;
end

endmodule 
","The problem was that the native aspect ratio of my LCD monitor was causing the stretching. John's answer could be the cause if the internal clock was too slow to handle it, however at 50 MHz with a 65 MHz PLL multiplier this wasn't an issue (as revealed by the oscilloscope).",,,,,
VHDL: Selection of images using switches,"I am currently working with VGA in Vivado on a Basys3 FPGA and I am having some issues. I want to generate different images (test mires). I have a separate .vhd file for each of these images, and a top level file where I would like to use a multiplexer for these images in order to assign each of them to a separate switch. My question is: How do I assign an image to a switch, if the outputs from every .vhd file are the three colour signals RGB?

What I tried is that I named these 3 output signals differently for every image, and assigned them to the final output signal when a switch is on using a case structure. I will paste part of it so you guys can get the idea:

This is the top entity

entity VGAdraw is                                                
Port ( CLK      : in STD_LOGIC;                              
       cntHor   : in integer range 0 to cstHorTotSize - 1;   
       cntVer   : in integer range 0 to cstVerTotSize - 1;   
       SW       : in STD_LOGIC_VECTOR (15 downto 0);         
       LED      : out STD_LOGIC_VECTOR (15 downto 0);        
       RED      : out STD_LOGIC_VECTOR (3 downto 0);         
       GREEN    : out STD_LOGIC_VECTOR (3 downto 0);         
       BLUE     : out STD_LOGIC_VECTOR (3 downto 0)          
     );                                                      
end VGAdraw;


This is one of the images:

signal red5, green5, blue5, red7, green7, blue7: STD_LOGIC_VECTOR (3 downto 0);

component Checkers is                                                       
Port ( CLK      : in STD_LOGIC;                                         
       cntHor   : in integer range 0 to cstHorTotSize - 1; 
       cntVer   : in integer range 0 to cstVerTotSize - 1; 
       red7      : out STD_LOGIC_VECTOR (3 downto 0);    
       green7    : out STD_LOGIC_VECTOR (3 downto 0);     
       blue7     : out STD_LOGIC_VECTOR (3 downto 0)       
     );              
end component;

component Checkers
    port map (CLK =&gt; CLK,
              cntHor =&gt; cntHor,
              cntVer =&gt; cntVer,
              red7 =&gt; RED,
              green7 =&gt; GREEN,
              blue7 =&gt; BLUE
             );


The case structure

process                                                       
begin                                                         
case SW is                                                                     
    when ""0000000000100000"" =&gt; RED &lt;= red7;        
                               GREEN &lt;= green7;           
                               BLUE &lt;= blue7;                    
    when others             =&gt; RED &lt;= red5;       
                               GREEN &lt;= green5;           
                               BLUE &lt;= blue5;             
end case;                                         
end process;


The VGADraw is the top entity, in which I have declared each image as a different component. Like the one above. How do I assign each of them to a switch on my FPGA board, so i can change to the image I want by turning on a Switch? I have also tried some  'if generate' statements, with no results. Like in this case, having 16 switches on the Basys3, by turning on sw5, I would like to get the image drawn by the Checkers component.

Thanks for any help.                           ","Just above the process starts your code should be something like this:

signal red1, blue1, green1, red7, green7, blue7 red5, green5, blue5 : STD_LOCIC_VECTOR(3 downto 0);


In general, when making a Structural design, after finishing with components you should declare the signals you need as given above.",,,,,
"Hamming (7,4) Code - Finite State Machine","So I am working on a lab assignment for a Computer Engineering class. I have a assignment due and I am trying to get all the help I can, as for the professor I have to wait until a few days before I can speak with them for help. So I am seeing if I can get help her.

My issue is that my finite state machine is not working how it should be as asked from the lab assignment. The state machine is supposed to have 3 states; idle, s1, s2. Idle is supposed to show all zeros in the waveform, State 1 will show the randomly generated 4-bit number from the LFSR, and State 2 will show the result from the 4-bit number after hamming (7,4) is done. The clock is changed to a 1HZ clock, clk division used.

Code is as follows:

CLOCK_1HZ

    module clock_1hz (clk, reset, clk2);
    input clk, reset;
    output clk2;

    reg temp;
    reg [25:0] cnt;

always @(posedge clk or posedge reset)
    begin
        if (reset)
            begin
                cnt = {25{1'b0}};
            end
        else
            begin
                if (cnt == 26'b10111110101111000001111111)
                    begin
                        cnt = {25{1'b0}};
                        temp = 1'b1;
                    end
                else if (cnt &lt; 26'b01011111010111100000111111)
                    begin
                        cnt = cnt + 1;
                        temp = 1'b1;
                    end
                else
                    begin
                        cnt = cnt + 1;
                        temp = 1'b0;
                    end
            end
    end

    assign clk2 = temp;

endmodule


LFSR

module lfsr (out, clk, rst);

    output  [4:1] out;
    input clk, rst;

    reg [4:1] w;

always @(posedge clk or posedge rst)

    begin

    if (rst)
        begin
            w = 4'b1011;
        end

    else
        w = {w[3],w[2],w[1]^w[4], w[4]};
    end

assign out=w;

endmodule 


HAMMING

module hamming(din, dout);
    output [6:0] dout;
    input [3:0] din;

    assign dout[6] = din[3];
    assign dout[5] = din[2];
    assign dout[4] = din[1];
    assign dout[3] = din[1] ^ din[2] ^ din[3];
    assign dout[2] = din[0];    
    assign dout[1] = din[0] ^ din[2] ^ din[3];
    assign dout[0] = din[0] ^ din[1] ^ din[3];

endmodule


All this code works properly and computes the correct HAMMING and the clock division works well with the LFSR and works when it is combined as hierarchy design.

When I make the FSM for this code it works upto it computing the hamming number but does not change state when indicated.


When Switch 1 set: State IDLE 
When Switch 2 set: State 1, Shows 4-bit LFSR number
When Switch 2 set: State 2, Shows 7-bit Hamming result


The following is my code for the Finite State Machine and following that is the waveform output.

module fsm ( clk , reset , sw1 , sw2 , sw3 , lights );

    input clk, reset, sw1, sw2, sw3;
    output reg [6:0] lights;

    reg[2:0] state;

    wire clkhz;
    wire [3:0] lfsr_out;
    wire [6:0] hout;

    parameter   S0 = 3'b000, S1 =3'b001, S2 = 3'b010; // states

    clock_1hz u1(.clk(clk), 
                    .reset(reset), 
                    .clk2(clkhz));
    lfsr u2(.rst(reset),
                .clk(clkhz),
                .out(lfsr_out));
    hamming u3(.din(lfsr_out),
                    .dout(hout));

always @(posedge clk or posedge reset)
    begin
        if (reset == 1)
            begin
                state &lt;= S0;
            end
        else
            case(state)
                S0: if(sw1 == 1)
                        begin
                            state &lt;= S0;
                        end
                S1: if(sw2 == 1)
                        begin
                            state &lt;= S1;
                        end
                S2: if(sw3 == 1)
                        begin
                            state &lt;= S2;
                        end
                default state &lt;= S0;
    endcase
end

always @(*)
    begin
        case(state)
                S0: lights = 7'b0000000; //led are all off
                S1: lights = lfsr_out; //4bit lfsr shown on led
                S2: lights = hout; // display hamming code result
                default lights = 7'b0000000; //led are all off
        endcase
    end
endmodule


WAVEFORM OF FINITE STATE MACHINE:

","I don't think it is a state machine that you need here. From you description of the requirements, perhaps you just need to remember the current switch pressed? If that is the case, you could do something along the lines of:

always @(posedge clk or posedge reset)
  if (reset == 1)
    state &lt;= S0;
  else
    if (sw1)
      state &lt;= S0;
    else if (sw2)
      state &lt;= S1;
    else if (sw3)
      state &lt;= S2;


Now state is remembering the current switch pressed. From your description of the requirements, doing this does not seem to depend on which switch which switch was pressed before that and so it doesn't look like you need a state machine - the behaviour does not depend on the state.

(You don't need all those begins and ends, either. You don't need them if there is only one statement in the branch.)",,,,,
How do I get simulation stats printed in SystemVerilog?,"I know there is a SystemVerilog system call that prints out the simulation stats, but I cannot remember it.  I figured it would be useful to capture the answer in StackExchange.

By simulation stats I mean how long the simulation took to run and other performance measures. 

What is the system call that prints out simulation stats?",This is going to be tool specific. Many tools have options for collecting different kinds of statistics and different ways of reporting them. Check your user manual.,,,,,
VHDL How to debounce some buttons after the process was created?,"I'm new to VHDL . I made a process for my project(a timer) that implies two buttons(M - increment minutes and S - increment seconds) . I need to debounce them . I'm familiar  debounce process  but i don't know how to implement it in my project . 
[EDIT]
My question is how to implement debouncer in my project?Do  I need just to create a new process ?

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.STD_LOGIC_unsigned.all;
use IEEE.STD_LOGIC_arith.all;

entity Timer is
    port(start_stop,M,S : in std_logic; --Start/Stop , Minutes,Seconds
    clk : in std_logic; -- clock 1MHz
    s1,s2,m1,m2 : out std_logic_vector(3 downto 0)); --BCD representation for seconds and minutes
end Timer;
--}} End of automatically maintained section

architecture Timer of Timer is

begin  
P0 : process(M,S,start_stop)
variable temp1,temp2,temp3,temp4 : std_logic_vector(3 downto 0);
variable carry_s,carry_m : std_logic;
begin
    if(M = '1' and S = '1') 
    then
    temp1 := ""0000"";
    temp2 := ""0000"";
    temp3 := ""0000"";
    temp4 := ""0000"";
    s1 &lt;= temp1;
    s2 &lt;= temp2;  
    m1 &lt;= temp3;
    m2 &lt;= temp4;
    end if;--RESET when you press M and S 

    if(M = '0' and S = '1')
        then 
        temp1 := temp1 + ""0001"";
        if(temp1 = ""1010"")
            then
            temp1 := ""0000"";
            carry_s := '1';
        else
            carry_s := '0';
        end if;
        if(carry_s = '1')
            then
            temp2 := temp2 + ""0001"";
            if(temp2 = ""0110"")
                then
                temp2 := ""0000"";
                carry_s := '0';
            end if;
        end if;
        s1 &lt;= temp1;
        s2 &lt;= temp2;
    end if;-- Increment seconds when you press S

    if(M = '1' and S = '0')
        then 
        temp3 := temp3 + ""0001"";
        if(temp3 = ""1010"")
            then
            temp3 := ""0000"";
            carry_m := '1';
        else
            carry_m := '0';
        end if;
        if(carry_m = '1')
            then
            temp4 := temp4 + ""0001"";
            if(temp4 = ""0110"")
                then
                temp4 := ""0000"";
                carry_m := '0';
            end if;
        end if;
        m1 &lt;= temp3;
        m2 &lt;= temp4;
    end if;-- Increment seconds when you press S
end process P0;
end Timer;
","All you need to do is create a Top Level module and use the Timer module and the debounce module as components. Next using port map you should connect the buttons with the debounce unit, and the output with the input of the Timer unit.Something like this

    entity TopLevel is
    Port ( M: in  STD_LOGIC;
           S: in  STD_LOGIC;
           start_stop: in  STD_LOGIC;
           Reset : in  STD_LOGIC;
           Clk : in  STD_LOGIC;
           m1, m2, s1, s2: out STD_LOGIC_VECTOR (3 downto 0));
end TopLevel;
    architecture Structural of TopLevel is
        COMPONENT Timer
            PORT(
               start_stop, M, S : IN std_logic;
               clk : IN std_logic;          
               s1,s2,m1,m2 : OUT std_logic_vector(3 downto 0)
            );
        END COMPONENT;
      COMPONENT debouncebutton
        PORT(
           clk : IN std_logic;
           rst : IN std_logic;
           input : IN std_logic;          
           output : OUT std_logic
        );
     END COMPONENT;
    signal debounceM, debounceS :std_logic;
    begin
     timerunit:Timer port map(
       start_stop =&gt; start_stop,
       M =&gt;debounceM,
       S =&gt; debounceS,
       clk =&gt; Clk,
       s1 =&gt; s1,
       s2 =&gt; s2,
       m1 =&gt; m1,
       m2 =&gt; m2 );
    debounceM: debouncebutton PORT MAP(
        clk =&gt; Clk,
        rst =&gt; Reset,
        input =&gt; M,
        output =&gt; debounceM
    );
    debounceS: debouncebutton PORT MAP(
        clk =&gt; Clk,
        rst =&gt; Reset,
        input =&gt; S,
        output =&gt; debounceS
    );
end Structural;
",,,,,
"VHDL ""For"" Loop Null Range","I've been stuck at this problem for some hours now, and it seems I can't find the solution by searching i.e. didn't find anything here or on Google.

Here's my piece of code:

LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std;
USE work.arrays.ALL;

ENTITY parallel IS  
  PORT (clk:IN std_logic; text:IN INT_ARRAY(119 DOWNTO 0); result:OUT INT_MATRIX_2D);
END parallel;

ARCHITECTURE arch OF parallel IS
  COMPONENT unit_comparator IS
    PORT (letter:IN integer; difference:OUT integer);
  END COMPONENT;
  SIGNAL temp: INT_MATRIX_2D := (others =&gt; (others =&gt; 0));
  SIGNAL temp_differences: INT_ARRAY(119 DOWNTO 0) := (others =&gt; 0);
  BEGIN
    PROCESS(clk)
    BEGIN
      IF(rising_edge(clk))THEN
        FOR index IN 119 TO 1 LOOP
          temp(temp_differences(index))(temp_differences(index - 1)) &lt;= 
          temp(temp_differences(index))(temp_differences(index - 1)) + 1;
        END LOOP;
        result &lt;= temp;
      END IF;
    END PROCESS;
  wiring_loop: FOR index IN 119 DOWNTO 0 GENERATE
    wiring_unit: unit_comparator PORT MAP (text(index), temp_differences(index));
  END GENERATE;
END arch;


You see that ""FOR index IN 119 TO 1 LOOP"" ?

The compiler gives a ""Range 119 to 0 is Null"" warning (no doubt the whole thing doesn't work as it should), which I seem to have a problem understanding. If there is an integer assigned to ""index"" at each step through the loop, how can it become null (and it says it happens at every step!). I need a firm understanding rather than a plain solution to this.
(Note: All of the modules and packages used are tested and work properly!)

Thank you!",Ranges need a direction that corresponds to their limits. You want 119 downto 1 or 1 to 119. 119 to 1 is not a range that is suitable for iterating through.,,,,,
addition not working in for-loop verilog,"I am trying to write a Verilog code that will multiply two floating point numbers.  trying to multiply to two mantissa by shifting and adding is where I am running into troubles.  The problem is that when I try and update the ""shift and add"" variable,C_m_tmp, nothing happens (C_m_tmp = C_m_tmp + tmp;).  I have omitted any blocks of code that are not relevant to my problem.  Can anyone tell me were I am going wrong?

`timescale 1ns / 1ps
module float_mult( A_m, B_m, C_m);
    input [22:0]A_m, B_m;
    output [45:0]C_m;

    reg [45:0] C_m_tmp;
    reg [22:0] A_m_tmp;
    reg [22:0] B_m_tmp;
    reg [45:0] tmp;
    reg [4:0]i;

    initial begin         
        assign C_m_tmp = 46'b0;
    end
 //need to remove the leading one from mantissas
always@ (A_m) begin
    A_m_tmp = A_m &gt;&gt; 1;
    A_m_tmp = A_m_tmp ^ 23'b10000000000000000000000;
end
always@ (B_m) begin
    B_m_tmp = B_m &gt;&gt; 1;
    B_m_tmp = B_m_tmp ^ 23'b10000000000000000000000;
 end
 always@(A_m_tmp, B_m_tmp) begin
    for (i=0; i &lt;=22; i=i+1)
        if (B_m_tmp[i] == 1)begin
            tmp =  {23'b0,A_m_tmp};
            tmp = tmp &lt;&lt;i;
            C_m_tmp = C_m_tmp + tmp;    //this line does nothing
        end
 end
    always@(C_m_tmp)begin
        if (C_m_tmp[45] == 1) begin
            C_e_tmp = C_e_tmp + 1'b1;
        end

    end


    assign C_e = C_e_tmp + 8'b01111111;
    assign C_m = C_m_tmp[45:23];
    assign C_s = C_s_tmp;        

endmodule
","initial begin         
assign C_m_tmp = 46'b0;
end


there is no need of the above code.

Instead, you can do 

always@(C_m_tmp)begin
C_m_tmp = 'b0;
        if (C_m_tmp[45] == 1) begin
            C_e_tmp = C_e_tmp + 1'b1;
        end

    end
",,,,,
Confused between latch and flip-flop,"If a latch based and gate clock gating technique is used then what would be the behaviour of latch for this below schematic. Can anybody tell the expected behaviour for the same?

As latch doesn't have clock but schematic shows here and method it self say, to give inverted clock to latch. Now If latch has clock then it is no more latch! It becomes flip-flop.


Try to elaborate word latch and actual latch in digital-logic.","Clock gating is simply control mechanism over clocking of sequential elements in the design, as your question is directly for code! It seems worthless to give it directly, instead here you can see the concept of clock gating, which is more probably useful for power-saving.

See below image,


As flow of clock stopped on control signal, clock frequency becomes 0 Hz and that will lead us to power saving.

Static power consumption:

P_static = I_static x Vdd

Dynamic power consumption:

P_dynamic = C_load x (Vdd)^2 x frequency of clock

If frequency is not there then P_dynamic should be zero ideally.

For RTL of that please refer above schematic and design accordingly. But here behaviour of latch is like flop, because it just latch EN on negedge of CLK, expected behaviour of this latch is flop.

For Digital-System both latch and flip-flop has different meaning.",,,,,
Xilinx:Reading from BRAM,"I have attemted to write a  Minimal, Complete, and Verifiable example below.

I want to write 10 values to the first 10 addresses of the BRAM (single port Block RAM) and then read the values. After inspecting the results I find that 


there are no changes in the first 10 addresses while perfoming the write operation.
While reading, the output changes after 3 clock cycles and stays constant when the 'address' signal stops changing.


Can you give an explanation to this behaviour and how to get the desired result (write 10 values in the 10 addresses). I'm more interested in solving the second problem (reading the values from the first 10 addresses).

Below is my verilog testbench and snapshot of the waveguide.

module BRAM_tb;
    // Inputs
    reg clk;
    reg [3:0] wea;                  // write enable signal
    reg [31:0] addra;               // address
    reg signed [31:0] dina;     // data in

    // Outputs
    wire [31:0] douta;          // data out

    // Instantiate the Unit Under Test (UUT)
    BLOCK_MEM uut (
        .clka(clk), 
        .wea(wea), 
        .addra(addra), 
        .dina(dina), 
        .douta(douta)
    );

    always begin
        #15 clk =~clk;
    end

    task writeStuff;    //write to address
        begin
            addra &lt;= addra + 1;
            dina &lt;= dina+1;
        end
    endtask

    task readStuff; // read the at address
        begin
            addra &lt;= addra + 1;
        end
    endtask

    reg [1:0] writing;
    integer counter;
    initial begin
        // Initialize Inputs
        clk = 0;
        addra = 0;
        dina = 16;
        counter = 0;
        writing = 2'b10; //idle state
        // Wait 100 ns for global reset to finish
        #100;
        wea &lt;= 1;
        writing &lt;=1;
    end

    always @(posedge clk)begin
        case(writing)
            1: if(counter&lt;10) begin
                    writeStuff;
                    counter &lt;=counter+1;
                end else begin
                    writing &lt;=0;    // change state to reading
                    counter &lt;=0;
                    addra &lt;= 0;
                    wea &lt;=0;    // stop writing
                end
            0:  if(counter&lt;10) begin
                    readStuff;
                    counter &lt;=counter+1;
                end else begin // change addra to zero and do nothing
                    addra &lt;= 0;
                    writing &lt;=2'b10; //goto idle state
                end
            2: if(1) begin
                    //do nothing
                end
        endcase
    end



- The gray line is where the write operation begins.
The blue line is where the read operation begins.



BLOCK_MEM is an IP-CORE that is generated by Xilinx.","I'm going to take some guesses as to how you've configured your BRAM (I'm using Vivado 2015.4 and http://www.xilinx.com/support/documentation/ip_documentation/blk_mem_gen/v8_3/pg058-blk-mem-gen.pdf as references). Looks like you've opted for the always-enable (since the ENA signal isn't present), 32-bit data, and the 32-bit address interface. Note that if you use the 32-bit address interface, WEA changes from a 1-bit signal to a 4-bit signal. This is to allow for byte-addressable writes.

Given this, we know that for a wea of 0b0001, only the least-significant byte will be written. Also, from the timing diagram on pg 46 of the above guide, we know we can expect the written data to be available after the write on douta. We can verify this on your first image - for example, at 200ns, douta = 0xfff75c13, with the 0x13 byte having come from dina on the previous clock edge (the other bytes are what was previously in the memory). So, this confirms the writes are working as expected.

As for the reads in image two, if you count again, you'll see that douta changes every 4 clock cycles. Again, remember that the memory is addressed per byte, but you're returning 4 bytes, so the lowest two bits of the address are ignored (address 0x07 == 0x06 == 0x05 == 0x04).

In short, the BRAM is working as intended, which might not be the way you expected. To move to the next 32-bit/4-byte word in memory, you need to increment the address by 4, not by 1. To write the whole word, (not just the lowest byte) set wea='b1111.",,,,,
Maximum block of bits of 1 in a 32 bits array Verilog,"I am a beginner in Verilog and I have this task.

max_pass circuit filters an array of 32 bits such that the blocks of bits 1 of maximum length remain on position and everything else becomes 0.

A block/set is consisted of minimum 2 bits of 1.

The circuit has to be combinational and the interface of the max_pass module is:

input  [31:0] din  ;
output [31:0] dout ;


The circuit has no memory. Output immediately sees any changes in input.

It is recommended to use modular and hierarchical design.

Examples

Example 1   
input:      01011100111111111111011100101010
output:     00000000111111111111000000000000
The maximum length of a block is 12.

Example 2   
input:      00100111111001001011111100101101
output:     00000111111000000011111100000000
Two blocks of maximum length of 6.

Example 3   
input:      11011011011011011011011011011011
output:     11011011011011011011011011011011
Eleven blocks of maximum length of 2.
","A bit of work in progress: to find the maxim block size present, and calculate the location vector.

block_is[i] represents when there is a block size of i or greater.

Identify max block size and OR the shifted number of location vectors together to create the output.

module tb;
  reg [15:0] seq;
  reg [15:0] loc_vector;
  reg [15:0] block_detect;



  initial begin
    #1ps seq = 16'b0101_1100_0110_1110;
    #10ns;
    $displayb(loc_vector);
    $displayb(block_detect);
    $finish();
  end

  reg [15:0] block_is = 16'b0;
  reg  [3:0] max_block;  //integer max of block_is 

  always @* begin
    block_is[0] = ~|seq; //All 0
    block_is[1] = |seq;  //Atleast 1
    block_is[2] = 
    (seq[15:14] == 2'b11) |
    (seq[14:13] == 2'b11) |
    (seq[13:12] == 2'b11) |
    (seq[12:11] == 2'b11) |
    (seq[11:10] == 2'b11) |
    (seq[10: 9] == 2'b11) |
    (seq[ 9: 8] == 2'b11) |
    (seq[ 8: 7] == 2'b11) |
    (seq[ 7: 6] == 2'b11) |
    (seq[ 6: 5] == 2'b11) |
    (seq[ 5: 4] == 2'b11) |
    (seq[ 4: 3] == 2'b11) |
    (seq[ 3: 2] == 2'b11) |
    (seq[ 2: 1] == 2'b11) |
    (seq[ 1: 0] == 2'b11) ; 

    block_is[3] =
    (seq[15:13] == 3'b111) |
    (seq[14:12] == 3'b111) |
    (seq[13:11] == 3'b111) |
    (seq[12:10] == 3'b111) |
    (seq[11: 9] == 3'b111) |
    (seq[10: 8] == 3'b111) |
    (seq[ 9: 7] == 3'b111) |
    (seq[ 8: 6] == 3'b111) |
    (seq[ 7: 5] == 3'b111) |
    (seq[ 6: 4] == 3'b111) |
    (seq[ 5: 3] == 3'b111) |
    (seq[ 4: 2] == 3'b111) |
    (seq[ 3: 1] == 3'b111) |
    (seq[ 2: 0] == 3'b111) ; 

    //etc complete for block_is 4 to 14

    block_is[15] = &amp;seq; //AND reduction all 1's

    loc_vector = seq;
    if (block_is[1]) begin
      //always do first shift if have block of 1
      loc_vector = loc_vector &amp; (seq &lt;&lt; 1);
    end
    if (block_is[2]) begin
      //do second shift if have at least a block of 2
      loc_vector = loc_vector &amp; (seq &lt;&lt; 2);
    end

    //Find max Block Size
    for (int i=0; i&lt;16; i=i+1) begin
      if (block_is[i]) begin
        max_block = i;
      end
    end

    block_detect = loc_vector;
    //Turn Location Vectors in to max_blocks
    for (int i=2; i&lt;16; i=i+1) begin
      if ( max_block &gt;=i )
        block_detect = block_detect | (loc_vector &gt;&gt; (i-1));
    end
  end

endmodule


Which outputs:

0001000000001000
0001110000001110
",,,,,
Using verilog to generate a ripple-carry-adder with all output X,"I am a beginner and I wanted to write a ripple-carry-adder using the generate block. So I write the following module:

module ripple_carry_adder(ia, ib,  ci,  so,  co);

parameter N = 32;
input[N-1:0] ia;
input[N-1:0] ib;
input ci;
output[N-1:0] so;
output co;

wire [N:0] carry;
assign carry[0] = ci;

genvar j;
generate for(j = 0; j &lt; N; j = j + 1) 
begin:r_loop
    wire t1, t2, t3;
    xor g1(t1, ia[i], ib[j]);
    xor g2(so[j], t1, carry[j]);
    and g3(t2, ia[i], ib[j]);
    and g4(t3, t1, carry[j]);
    or g5(carry[j+1], t2, t3);
end
endgenerate

assign co = carry[N];
endmodule


And the testbench module:

`include ""ripple_carry_adder.v""
`timescale 1ns/1ps
module ripple_carry_adder_tb;

parameter N = 32;

reg clk;
reg[N-1:0] a, b;
wire[N-1:0] sum;
reg cin;
wire cout;

ripple_carry_adder rca(.ia(a), .ib(b), .ci(cin), .so(sum), .co(cout));
initial begin
    #10;
    a = 0;
    b = 0;
    cin = 0;
    clk = 0;
    #10;
end

always @(posedge clk)
begin
    #50;
    #1 a &lt;= $random() % 1000000;
    #1 b &lt;= $random() % 1000000;
end

always @(a or b)
    #5 $display(""%d + %d = %d"", a, b, sum);

always #5 clk = ~clk;

endmodule


But I got the result with all bits unknown:
result

I have spent 1 hour in vain trying to find the mistake. Can you help me?","As stated in my comment, the i in ia[i] is undefined. Changing it to j should get the desired functionality.

Verilog will treat any undeclared variable as a single bit wire, it is considered normal benavior and you will rarely get warnings. Some simulators have options to flag undeclared variables. There is a univeral option as well that was added in IEEE Std 1364-2001 (aka Verilog-2001). You can override the default net type with the `define_nettype macro. By setting it to none all nets after the macro declaration must be explicitly declared. You can get more details on default_nettype by reading IEEE Std 1364-2001 &sect; 19.2 `default_nettype or IEEE Std 1800-2012 &sect; 22.8 `default_nettype",,,,,
Realizing Top Level Entity in Testbench using VHDL,"I'm a newbie in VHDL and hardware world.
I'm trying to make a Count&amp;Compare example using Top Level Hierarchy and test it with testbench and see the results on ISIM.

Here is my block diagram sketch:


So I end up these 3 vhd source files:

Counter.vhd

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity Count_src is
    Port ( CLK   : in  STD_LOGIC;
           Reset : in  STD_LOGIC;
           S     : out  STD_LOGIC_VECTOR (3 downto 0));
end Count_src;

architecture Behavioral of Count_src is
signal count : STD_LOGIC_VECTOR (3 downto 0);

begin
process (Reset, CLK)
    begin
        if Reset = '1' then                             -- Active high reset
            count &lt;= ""0000"";                            -- Clear count to 0
        elsif (rising_edge(CLK)) then                   -- Positive edge
            count &lt;= count + ""0001"";                    -- increment count
        end if;
    end process;
S &lt;= count;                                             -- Export count
end Behavioral;


Compare

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity Compare_src is
    Port ( A : in  STD_LOGIC_VECTOR (3 downto 0);
           B : in  STD_LOGIC_VECTOR (3 downto 0);
           S : out  STD_LOGIC);
end Compare_src;

architecture Behavioral of Compare_src is

begin

    S &lt;= '1' when (A = B) else          -- Test if A and B are same
         '0';                           -- Set when S is different

end Behavioral;


CountCompare (Top Level)

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity CountCompare_src is
    Port ( Clock : in  STD_LOGIC;
           Reset : in  STD_LOGIC;
           Value : in  STD_LOGIC_VECTOR (3 downto 0);
           Flag : out  STD_LOGIC);
end CountCompare_src;

architecture Behavioral of CountCompare_src is

-- COMPONENT DECLERATIONS
component counter is
    port ( CLK   : in std_logic;
           Reset : in std_logic;
           S     : out std_logic_vector(3 downto 0)
         );
end component;

component compare is
    port (A : in std_logic_vector(3 downto 0);
          B : in std_logic_vector(3 downto 0);
          S : out std_logic
         );
end component;

-- Component Spesification and Binding
for all : counter use entity work.Count_src(behavioral);
for all : compare use entity work.Compare_src(behavioral);

-- Internal Wires
signal count_out : std_logic_vector(3 downto 0);

begin

-- Component instantiation

C1: counter PORT MAP ( Reset =&gt; Reset,
                       CLK =&gt; Clock,
                       S =&gt; count_out
                     );

C2: compare PORT MAP ( A =&gt; count_out,
                       B =&gt; Value,
                       S =&gt; Flag
                     );

end Behavioral;


To test the design I wrote a testbench as follows:

TestBench

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY TopLevelTester_tb IS
END TopLevelTester_tb;

ARCHITECTURE behavior OF TopLevelTester_tb IS 

   --Input and Output definitions.
   signal Clock : std_logic := '0';
    signal Reset : std_logic := '0';
   signal Value : std_logic_vector(3 downto 0) := ""1000"";
    signal Flag  : std_logic;

   -- Clock period definitions
   constant clk_period : time := 1 ns;

BEGIN

   -- Instantiate the Unit Under Test (UUT)
   uut: entity work.CountCompare_src PORT MAP 
    (
        Clock =&gt; Clock,
        Reset =&gt; Reset,
        Value =&gt; Value
    );

   proc: process
   begin
       Clock &lt;= '0';
       wait for clk_period/2;
       Clock &lt;= '1';
       wait for clk_period/2;   
   end process;

END;


When I simulate behavioral model, the ISIM pops up, but I see no changes on the Compare Flag. Here is the ss of the ISIM:


What am I missing here? Why does'nt the Flag change?

My best regards.","You have two problems, both in your testbench.

The first is that you never reset count in the counter, it will always be 'U's or 'X's (after you increment it).

The second is that the directly entity instantiation in the testbench is missing an association for the formal flag output to the actual flag signal:

begin

uut: 
    entity work.countcompare_src 
        port map (
            clock =&gt; clock,
            reset =&gt; reset,
            value =&gt; value,
            flag =&gt; flag
        );

proc: 
    process
    begin
        clock &lt;= '0';
        wait for clk_period/2;
        clock &lt;= '1';
        wait for clk_period/2;  
        if now &gt; 20 ns then
            wait;
        end if; 
    end process;

stimulus:
    process
    begin
        wait for 1 ns;
        reset &lt;= '1';
        wait for 1 ns;
        reset &lt;= '0';
        wait;
    end process;


Fix those two things and you get:

",,,,,
3-bit finite state machine in VHDL,"entity project4 is
    Port ( clk : in  STD_LOGIC;
           reset : in  STD_LOGIC;
           x : in  STD_LOGIC_VECTOR (1 downto 0);
           myoutputs : out  STD_LOGIC_VECTOR (2 downto 0));
end project4;

architecture Behavioral of project4 is
type state_type is (s0,s1,s2,s3,s4,s5,s6,s7);
signal state: state_type;

begin
process1: process(clk,reset)
begin
     if (reset ='0') THEN state &lt;= s0;
      myoutputs &lt;= ""000"";
ELSE IF (clk'EVENT AND clk='1') THEN
    case state is
     when s0 =&gt;
               if (x=""00"") THEN
                  state &lt;= s1;
                  myoutputs &lt;= ""001"";
                  ELSE IF (x=""01"") THEN
                  state &lt;= s7;
                  myoutputs &lt;= ""111"";
                  ELSE IF (x=""10"") THEN
                  state &lt;= s2;
                  myoutputs &lt;= ""010"";
                  ELSE
                  state &lt;=s4;
                  myoutputs &lt;= ""100"";
      END IF;

      when s1 =&gt;
                if (x=""00"") THEN
                    state &lt;= s2;
                    myoutputs &lt;=""010"";
                    ELSE IF (x =""01"") THEN
                    state &lt;= s0;
                    myoutputs &lt;= ""000"";
                    ELSE IF (x =""10"") THEN
                    state &lt;=s0;
                    myoutputs &lt;= ""000"";
                    ELSE
                    state &lt;= s0;
                    myoutputs &lt;=""000"";
        END IF;

        when s2 =&gt;
                  if (x=""00"") THEN
                     state &lt;= s3;
                     myoutputs &lt;=""011"";
                     ELSE IF (x=""01"") THEN
                     state &lt;= s1;
                     myoutputs &lt;=""001"";
                     ELSE IF (x=""10"") THEN
                     state &lt;=s5;
                     myoutputs &lt;=""110"";
                     ELSE
                     state &lt;=s3;
                     myoutputs &lt;=""011"";
        END IF;

        when s3 =&gt;
                  if (x=""00"") THEN
                     state &lt;=s4;
                     myoutputs &lt;=""100"";
                     ELSE IF (x=""01"") THEN
                     state &lt;= s2;
                     myoutputs &lt;=""010"";
                     ELSE IF (x=""10"") THEN
                     state &lt;= s1;
                     myoutputs &lt;= ""001"";
                     ELSE
                     state &lt;=s1;
                     myoutputs &lt;= ""001"";
        END IF;

      when s4 =&gt;
                if (x=""00"") THEN
                state &lt;=s5;
                myoutputs &lt;=""101"";
                     ELSE IF (x=""01"") THEN
                     state &lt;= s3;
                     myoutputs &lt;=""011"";
                     ELSE IF (x=""10"") THEN
                     state &lt;= s5;
                     myoutputs &lt;=""101"";
                     ELSE
                     state &lt;= s5;
                     myoutputs &lt;=""101"";
        END IF;

        when s5 =&gt;
                  if (x=""00"") THEN
                     state &lt;= s6;
                     myoutputs &lt;=""110"";
                     ELSE IF (x=""01"") THEN
                     state &lt;= s4;
                     myoutputs &lt;= ""100"";
                     ELSE IF (x=""10"") THEN
                     state &lt;= s7;
                     myoutputs &lt;= ""111"";
                     ELSE
                     state &lt;= s7;
                     myoutputs &lt;= ""111"";
        END IF;

        when s6 =&gt;
                  if (x=""00"") THEN
                     state &lt;= s7;
                     myoutputs &lt;= ""111"";
                     ELSE IF (x=""01"") THEN
                     state &lt;= s5;
                     myoutputs &lt;=""101"";
                     ELSE IF (x=""10"") THEN
                     state &lt;= s4;
                     myoutputs &lt;=""100"";
                     ELSE
                     state &lt;= s2;
                     myoutputs &lt;=""010"";
        END IF;

        when s7 =&gt;
                  if (x=""00"") THEN
                     state &lt;= s0;
                     myoutputs &lt;=""000"";
                     ELSE IF (x=""01"") THEN
                     state &lt;= s6;
                     myoutputs &lt;=""110"";
                     ELSE IF (x=""10"") THEN
                     state &lt;= s3;
                     myoutputs &lt;=""011"";
                     ELSE
                     state &lt;= s6;
                     myoutputs &lt;= ""110"";
        END IF;
        end case;
        end process process1;

process2: process(state)
begin
      case state is
        when s0 =&gt; myoutputs &lt;= ""000"";
        when s1 =&gt; myoutputs &lt;= ""001"";
        when s2 =&gt; myoutputs &lt;= ""010"";
        when s3 =&gt; myoutputs &lt;= ""011"";
        when s4 =&gt; myoutputs &lt;= ""100"";
        when s5 =&gt; myoutputs &lt;= ""101"";
        when s6 =&gt; myoutputs &lt;= ""110"";
        when s7 =&gt; myoutputs &lt;= ""111"";
        end case;
end process process2;

end Behavioral;


Here's entire code.

Can someone tell me what causes the error? I'm just not getting it.
(Syntax error near ""when"".)","Use elsif not else if

Constructing a Minimal, Complete, and Verifiable example from your linked code by adding a context clause:

library ieee;
use ieee.std_logic_1164.all;

entity project4 is
    port ( 
        clk:        in  std_logic;
        reset:      in  std_logic;
        x:          in  std_logic_vector (1 downto 0);
        myoutputs:  out std_logic_vector (2 downto 0)
    );
end entity project4;

architecture behavioral of project4 is
    type state_type is (s0,s1,s2,s3,s4,s5,s6,s7);
    signal state: state_type;
begin
process1: 
    process (clk, reset)
    begin
    if reset ='0' then 
        state &lt;= s0;
        myoutputs &lt;= ""000"";
    else if clk'event and clk='1' then
        case state is
            when s0 =&gt;
                if x = ""00"" then
                    state &lt;= s1;
                    myoutputs &lt;= ""001"";
                else if x = ""01"" then
                    state &lt;= s7;
                    myoutputs &lt;= ""111"";
                else if  x = ""10"" then
                    state &lt;= s2;
                    myoutputs &lt;= ""010"";
                else
                    state &lt;= s4;
                    myoutputs &lt;= ""100"";
                end if;
            when s1 =&gt;
                if  x = ""00"" then
                    state &lt;= s2;
                    myoutputs &lt;= ""010"";
                else if  
                    x = ""01"" then
                    state &lt;= s0;
                    myoutputs &lt;= ""000"";
                else if  x = ""10"" then
                    state &lt;= s0;
                    myoutputs &lt;= ""000"";
                else
                    state &lt;= s0;
                    myoutputs &lt;= ""000"";
                end if;

            when s2 =&gt;
                if  x = ""00"" then
                     state &lt;= s3;
                     myoutputs &lt;= ""011"";
                else if  x = ""01"" then
                     state &lt;= s1;
                     myoutputs &lt;= ""001"";
                else if  x = ""10"" then
                     state &lt;= s5;
                     myoutputs &lt;= ""110"";
                else
                     state &lt;= s3;
                     myoutputs &lt;= ""011"";
        end if;

            when s3 =&gt;
                if  x = ""00"" then
                     state &lt;= s4;
                     myoutputs &lt;= ""100"";
                else if  x = ""01"" then
                     state &lt;= s2;
                     myoutputs &lt;= ""010"";
                else if  x = ""10"" then
                     state &lt;= s1;
                     myoutputs &lt;= ""001"";
                else
                     state &lt;= s1;
                     myoutputs &lt;= ""001"";
                 end if;

            when s4 =&gt;
                if  x = ""00"" then
                    state &lt;= s5;
                    myoutputs &lt;= ""101"";
                else if  x = ""01"" then
                     state &lt;= s3;
                     myoutputs &lt;= ""011"";
                else if  x = ""10"" then
                     state &lt;= s5;
                     myoutputs &lt;= ""101"";
                 else
                     state &lt;= s5;
                     myoutputs &lt;= ""101"";
                 end if;

            when s5 =&gt;
                if  x = ""00"" then
                    state &lt;= s6;
                    myoutputs &lt;= ""110"";
                else if  x = ""01"" then
                    state &lt;= s4;
                    myoutputs &lt;= ""100"";
                else if  x = ""10"" then
                    state &lt;= s7;
                    myoutputs &lt;= ""111"";
                else
                    state &lt;= s7;
                    myoutputs &lt;= ""111"";
                end if;

            when s6 =&gt;
                if  x = ""00"" then
                     state &lt;= s7;
                     myoutputs &lt;= ""111"";
                else if  x = ""01"" then
                    state &lt;= s5;
                    myoutputs &lt;= ""101"";
                else if  x = ""10"" then
                    state &lt;= s4;
                    myoutputs &lt;= ""100"";
                else
                    state &lt;= s2;
                    myoutputs &lt;= ""010"";
                end if;

            when s7 =&gt;
                if  x = ""00"" then
                    state &lt;= s0;
                    myoutputs &lt;= ""000"";
                else if  x = ""01"" then
                    state &lt;= s6;
                    myoutputs &lt;= ""110"";
                else if  x = ""10"" then
                    state &lt;= s3;
                    myoutputs &lt;= ""011"";
                else
                    state &lt;= s6;
                    myoutputs &lt;= ""110"";
                end if;
            end case;

    end process process1;

process2: 
    process(state)
    begin
        case state is
            when s0 =&gt; myoutputs &lt;= ""000"";
            when s1 =&gt; myoutputs &lt;= ""001"";
            when s2 =&gt; myoutputs &lt;= ""010"";
            when s3 =&gt; myoutputs &lt;= ""011"";
            when s4 =&gt; myoutputs &lt;= ""100"";
            when s5 =&gt; myoutputs &lt;= ""101"";
            when s6 =&gt; myoutputs &lt;= ""110"";
            when s7 =&gt; myoutputs &lt;= ""111"";
        end case;
    end process process2;
end behavioral;


And using a couple of different VHDL tools:


  ghdl -a project4.vhdl
  project4.vhdl:39:13: 'end' is expected instead of 'when'
  ghdl: compilation error  


and 


nvc -a project4.vhdl  
** Error: unexpected when while parsing if statement, expecting end  
  File project4.vhdl, Line 39  
                when s1 =&gt;  
                ^^^^  
** Error: unexpected when while parsing if statement, expecting end  
  File project4.vhdl, Line 55  
                when s2 =&gt;  
                ^^^^  
** Error: unexpected when while parsing if statement, expecting end  
  File project4.vhdl, Line 70  
                when s3 =&gt;  
                ^^^^  
&gt;...



explains what the problem is.  You're using else if instead of elsif which results in the wrong number of end statements (end if;).

Fixing those 17 instances of else if and we find you left out the end if for the first if statement:


  ghdl -a project4.vhdl
  project4.vhdl:146:9: 'if' is expected instead of 'process'
  ghdl: compilation error  


Adding that right before the end process:

        end if; -- added
    end process process1;


and your design analyzes. 

Whether or not your code is functional is left to you. 

(Okay, there's another problem you drive myoutputs from two processes which will cause Xs, you should remove the second process. Each process that assigns a signal has a driver for that signal, and std_logic is a resolved type, meaning the two drivers values will presented to a resolution function, which for package std_logic_1164 will result in Xs for conflicting values on the two drivers.)

So there were 18 syntax errors, plus the code isn't functional, myoutputs having driver conflicts.

I removed superfluous parentheses and added spaces and indentation for readability.

So adding a small testbench:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity project4_tb is
end entity;

architecture foo of project4_tb is
    signal clk:        std_logic := '0';
    signal reset:      std_logic;
    signal x:          std_logic_vector (1 downto 0);
    signal myoutputs:  std_logic_vector (2 downto 0);
begin
DUT: 
    entity work.project4
        port map (
            clk =&gt; clk,
            reset =&gt; reset,
            x =&gt; x,
            myoutputs =&gt; myoutputs
        );

CLOCK:
    process
    begin
        wait for 5 ns;
        clk &lt;= not clk;
        if now &gt; 360 ns then
            wait;
        end if;
    end process;

STIMULI:
    process
    begin
        wait for 6 ns;
        reset &lt;= '0';
        wait for 10 ns;
        reset &lt;= '1';
        for i in 0 to 3 loop
            x &lt;= std_logic_vector(to_unsigned(i,x'length));
            wait for 80 ns;
        end loop;
        wait;
    end process;
end architecture;


We can see what your design does in simulation:

",,,,,
Verilog module output is X even when assigned a value,"I have a simple 8 bit parity checking module to check results and set flags. 

The output of this module is always X, and I can't for the life of me figure out why. Here is the code:

module parity8 (p, low8);

   output p;
   input [7:0] low8;

   wire [3:0] pchka;
   wire [1:0] pchkb;
   wire parity_bar;

   xor2$ xora0 (pchka[0], low8[0], low8[1]),
         xora1 (pchka[1], low8[2], low8[3]),
         xora2 (pchka[2], low8[4], low8[5]),
         xora3 (pchka[3], low8[6], low8[7]),

         xorb0 (pchkb[0], pchka[0], pchka[1]),
         xorb1 (pchkb[1], pchka[2], pchka[3]), 

         xorp (parity_bar, pchkb[0], pchkb[1]);

   inv1$ pinv (p, parity_bar);

endmodule


parity_bar always has the correct value, and I tried making another wire ptest, which replaced p on the last line. Ptest had the correct value, so I tried adding:

assign p = ptest;


Yet the output of the module was still X. Even tried assigning p = 1'b1; and it didn't change. Hopefully this isn't something obvious, thanks for your help.","As Greg pointed out, the issue was that p was driving a bit in a bit vector that had been assigned all 0's. I had dismissed this because I have several modules driving bits on this same bit vector. I suppose a problem only occurs if the assignment value and the value produced by the module are not the same.",,,,,
Constructing a 20kbit bit_vector data from 16bit unsigned_vector,"I'm very new in VHDL and having a problem about assigning values I guess.

Let's say that I've a module that get an 16 bit input signal noisein_mono for every positive edge of the clock source. What I want is to construct a 20 Kbit long bit vector from this 16-bit inputs. So I'm gonna perform random number tests on it FIPS_140-2

The code I end up with is shown below:

-- Entity Decleration
entity MonoTestModule is

Port ( clk                  : in    STD_LOGIC;
       rst                  : in    STD_LOGIC;
       start                : in    STD_LOGIC;
       noisein_mono         : in    STD_LOGIC_VECTOR (15 downto 0);
       running_mono         : out   STD_LOGIC;
       tok_mono             : out   STD_LOGIC     
     );

end MonoTestModule;

architecture Behavioral of MonoTestModule is

-- Signal to communication between processes.
signal enable_20k_bit_stream : std_logic;                                                       

begin
process (rst, clk, start, noisein_mono)
    variable count : integer := 0;                                                                                      
    variable twnty_k_bit_stream : bit_vector(19999 to 0);                                   
    begin
        if(start = '1') then                                                                            
            if (rising_edge(clk)) then                                                      
                count := count + 1;                                                         
                twnty_k_bit_stream := twnty_k_bit_stream or to_bitvector(noisein_mono);
                twnty_k_bit_stream := twnty_k_bit_stream sll 16;
            end if;

            if (rst = '1') then                                                             
                count := 0;                                                                     
                enable_20k_bit_stream &lt;= '0';                                                                           
            end if;

            -- if count is reached to 1250, 20kbit is constructed.
            if(count = 1250) then                                                                   
                enable_20k_bit_stream &lt;= '1';
            else                                                                                            
                enable_20k_bit_stream &lt;= '0';
            end if; 
    end if;
end process;


I'm using Xilinx ISE 14.7. The compiler pops up error says Line 52: Unequal length arguments for operator ""or"". 
How can I solve this problem?

My best regards.","In simulation this would be two different run-time errors.

There's actually two bounds mismatch errors, one for the ""or"" on two array values:

            twnty_k_bit_stream := twnty_k_bit_stream or
                                  to_bitvector(noisein_mono);


And one for the assignment to twnty_k_bit_stream where the length doesn't match following an implicit subtype conversion.

And that's because 

  variable twnty_k_bit_stream : bit_vector(19999 to 0);


that to should be downto. When the direction is wrong you'll end up with a null range (an array with no elements).

See IEEE Std 1076-2008 9.2.2 Logical operators, para 3:


  If both operands are one-dimensional arrays, the operands shall be arrays of the same length, the operation is performed on matching elements of the arrays, and the result is an array with the same index range as the left operand. If one operand is a scalar and the other operand is a one-dimensional array, the operation is performed on the scalar operand with each element of the array operand. The result is an array with the same index range as the array operand.


So uneven length arrays don't work.

Also see 10.6.2.1 (Variable assignment), paras 5 and 7:


  For the execution of a variable assignment whose target is a variable name, the variable name and the expression are first evaluated. A check is then made that the value of the expression belongs to the subtype of the variable, except in the case of a variable that is of a composite type (in which case the assignment involves a subtype conversion). Finally, each subelement of the variable that is not forced is updated with the corresponding subelement of the expression. A design is erroneous if it depends on the order of evaluation of the target and source expressions of an assignment statement.
  
  ...
  An error occurs if the aforementioned subtype checks fail.


And that error occurs if there isn't a corresponding element in both the target and right hand side expression of the variable assignment.

5.3.2.2 Index constrains and discrete ranges, para 4:


  An array constraint of the first form is compatible with the type if, and only if, the constraint defined by each discrete range is compatible with the corresponding index subtype and the array element constraint, if present, is compatible with the element subtype of the type. If any of the discrete ranges defines a null range, any array thus constrained is a null array, having no elements. An array value satisfies an index constraint if at each index position the array value and the index constraint have the same index range. (Note, however, that assignment and certain other operations on arrays involve an implicit subtype conversion.)


Fix both those things:

begin
    process (rst, clk) -- , start, noisein_mono)  -- not needed
        variable count:  integer := 0;
        variable twnty_k_bit_stream:  bit_vector(19999 downto 0); -- was to 
    begin
        if start = '1' then
            if rising_edge(clk) then
                count := count + 1;
                -- twnty_k_bit_stream := twnty_k_bit_stream or
                --                       to_bitvector(noisein_mono);
                -- twnty_k_bit_stream := twnty_k_bit_stream sll 16;

                twnty_k_bit_stream (twnty_k_bit_stream'LEFT downto noisein_mono'LENGTH) :=
                    twnty_k_bit_stream (twnty_k_bit_stream'LEFT - noisein_mono'LENGTH downto 0);
                twnty_k_bit_stream (noisein_mono'RANGE) :=
                                    to_bitvector(noisein_mono);
            end if;


noting I also fixed the sensitivity list and we get something that doesn't have a bounds check error. Instead of using an ""or"" this shifts then writes the lower 16 bits with noisein_mono.

Adding a testbench:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity monoblahblah_tb is
end entity;

architecture foo of monoblahblah_tb is
    signal clk:           std_logic := '0';
    signal rst:           std_logic;
    signal start:         std_logic;
    signal noisein_mono:  std_logic_vector (15 downto 0);

    signal running_mono:  std_logic;
    signal tok_mono:      std_logic;
begin
DUT:
    entity work.monotestmodule
        port map (
            clk =&gt; clk,
            rst =&gt; rst,
            start =&gt; start,
            noisein_mono =&gt; noisein_mono,
            running_mono =&gt; running_mono,
            tok_mono =&gt; tok_mono
        );
CLOCK:
    process
    begin
        wait for 5 ns;
        clk &lt;= not clk;
        if now &gt; 12680 ns then
            wait;
        end if;
    end process;
STIMULI:
    process
    begin
        wait for 6 ns;
        rst &lt;= '0';
        start &lt;= '0';
        noisein_mono &lt;= (others =&gt; '0');
        wait for 10 ns;
        rst &lt;= '1';
        wait for 10 ns;
        rst &lt;= '0';
        wait for 100 ns;
        start &lt;= '1';
        for i in 0 to 1249 loop -- 20,000 / 16
            noisein_mono &lt;= 
                std_logic_vector(to_unsigned(i, noisein_mono'length)) 
                  xor
                x""dead"";
            wait for 10 ns;
        end loop;
        wait;
    end process;
end architecture;


And we get:



And if I had thought about it I would have XOR'd different values in consecutively, these values are simply unique from 0 to 1249 as binary XOR'd with x""DEAD"". (It seemed outrÃ© to write a random number generator for a simple testbench, considering the state of twnty_k_bit_stream isn't displayed. The purpose is to show there are no bounds check failures.)

So there were two semantic errors detectable at run time (or synthesis) and an incorrect sensitivity list.",,,,,
How can I use seperate digits in seven segment display in basys 3 in vhdl,"I am working on a Project about making a stop watch. In order to do that I must use seperate digits on the 7-segment display. However, when I try it, all the digits act the same. I used the following code for the constraint.

set_property PACKAGE_PIN W7 [get_ports {clk_out[6]}] 
set_property IOSTANDARD LVCMOS33 [get_ports {clk_out[6]}] 
set_property PACKAGE_PIN W6 [get_ports {clk_out[5]}]  
set_property IOSTANDARD LVCMOS33 [get_ports {clk_out[5]}] 
set_property PACKAGE_PIN U8 [get_ports {clk_out[4]}] 
set_property IOSTANDARD LVCMOS33 [get_ports {clk_out[4]}] 
set_property PACKAGE_PIN V8 [get_ports {clk_out[3]}]  
set_property IOSTANDARD LVCMOS33 [get_ports {clk_out[3]}] 
set_property PACKAGE_PIN U5 [get_ports {clk_out[2]}] 
set_property IOSTANDARD LVCMOS33 [get_ports {clk_out[2]}] 
set_property PACKAGE_PIN V5 [get_ports {clk_out[1]}] 
set_property IOSTANDARD LVCMOS33 [get_ports {clk_out[1]}]  
set_property PACKAGE_PIN U7 [get_ports {clk_out[0]}] 
set_property IOSTANDARD LVCMOS33 [get_ports {clk_out[0]}] 


How can I use seperate digits? It would be really helpful if you explain it to me by an example. Thanks in advance.","@Brian Drummond and @user1155120 have really answered your question. The display is time multiplexed. You need to repeat this sequence over and over again so fast that the human eye cannot perceive that you are only driving one digit at once:


enable U2 and drive the 7-segment outputs for the units column; 
then enable U4 and drive the 7-segment outputs for the tens column; 
then enable V4 and drive the 7-segment outputs for the hundreds column; 
then enable W4 and drive the 7-segment outputs for the thousands column.


So, you'll need some VHDL code that drives U2 then U4 then V4 then W4 then U2 etc and some other VHDL code that drives the 7-segment outputs appropriately for each digit.",,,,,
Unexplained Red X's (collisions?) with Dual-Port BRAM in Xilinx ISim,"I've read up on this quite a bit and I can't figure out why I would have Red X's (Collisions?) with a simple Dual-Port BRAM IP core.



I think there are only a few scenarios that can cause this:

Multiple sources: I checked and I don't have multiple sources diving current_row_data_out. I only read from it.

Simultaneous Read + WRite to the same address: Nope. As you can see in the image, read_addr and write_addr are always different.

What else can it be?",The issues was caused by one or two writes of uninitialized data all the way in the beginning of the simulation. It created a chain-reaction that didn't show up until later because the values read in the beginning were coincidentally correct.,,,,,
VHDL flip-flop reset different than 0,"is any possibility to reset flip-flop vector to different value than all 0?
something like:

PROCESS (clk)
    BEGIN
        IF RISING_EDGE(clk) THEN
            IF rst = '1' THEN
                ff &lt;= INPUT_VALUE;
...


This don't survive synthesis.
I want to get the value to ff only when resetting, then I'm changing it - it works as a counter with first value set from input.",How about implementing a normal reset and then use load signal to set the counter to something else? This to me would be the standard way.,,,,,
ISIM signal assignment delay,"I expected signal 'delay' to be one clock cycle late wrt to the entities' port 'input', but ISIM shows no phase shift. 
I thought there is always is a delay between signal assignment and actual value (when the process suspends), but I don't seee it here.

Why is this?



Code:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity test is
Port ( clk:   in  std_logic;
          input: in  std_logic
        );
end test;

architecture Behavioral of test is
    signal delay: std_logic:= '0';

    begin   
    proc1: process(clk)
    begin
        if(rising_edge(clk)) then
            delay &lt;= input;                -- ISIM shows no delay between them
        end if;             
    end process;

end Behavioral;


Testbench:

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;


ENTITY tb_testbench_test IS
END tb_testbench_test;

ARCHITECTURE behavior OF tb_testbench_test IS 

-- Component Declaration for the Unit Under Test (UUT) 
COMPONENT test
PORT(
          clk:   in  std_logic;
          input: in  std_logic
    );
END COMPONENT;


--Inputs
signal clk: std_logic := '0';
signal input: std_logic := '0';

-- Clock period definitions
constant clk_period : time := 10 ns;

BEGIN

-- Instantiate the Unit Under Test (UUT)
uut: test PORT MAP (
      clk =&gt; clk,
      input =&gt; input
    );

-- Clock process definitions
clk_process :process
begin
    clk &lt;= '0';
    wait for clk_period/2;
    clk &lt;= '1';
    wait for clk_period/2;
end process;


-- Stimulus process
stim_proc: process
begin       
  wait for clk_period * 9.5;    

    input &lt;= '1';
    wait for clk_period;
    input &lt;= '0';

  wait;
end process;

end;
","Your test bench describes clk and input going high at the same time. You then have a process in your entity that is looking for a rising_edge of clk. Therefore, when your process runs, and asks 'was there a rising edge of the clock?', if the answer to this is 'yes', i.e. the clock signal had just become '1', then the state of the input must also be '1', because the two signals changed at the same time. The delay signal then takes this new input, giving the result you see.

A more realistic scenario would be a change of the input being caused by a rising edge of clk. You can easily simulate this by modifying your stimulus process:

stim_proc: process
begin       
  wait for clk_period * 9.5;    
  wait until clk = '1';  -- Sit here until we have seen a rising edge of `clk`
  input &lt;= '1'; -- This assignment now happens *after* the clock edge
  wait until clk = '1';
  input &lt;= '0';

  wait;
end process;
",,,,,
Systemverilog bit-shift difference between {<<{signal}} and {signal<<1}?,"I have the following piece of code which the Vivado simulator doesn't seem to support (results in ERROR: [XSIM 43-3209] - Unsupported Construct):

assign b = {&lt;&lt;{a}};


Wondering if I can just change this code to the following:

assign b = a&lt;&lt;1;


Could someone please confirm that the 2 lines above are identical? 
Note that both a and b are 8 bit wide. Thanks!","No they are not the same. {&lt;&lt;{a}} is a bit reversal.
Assuming a was declared with the range [7:0], you would need to write

assign b = {a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7]};
",,,,,
Simple VHDL clocked counter simulation confusion,"I am currently slightly confused about my simple counter.
It is implemented as follows:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity simple_counter is
    port( 
        DOUT : out std_logic_vector(3 downto 0);
        CE : in std_logic;
        CLK : in std_logic;
        RSTN : in std_logic
    );
end simple_counter;

architecture behavioral of simple_counter is
    signal temp : unsigned(3 downto 0);

begin   

    process(CLK)
    begin
        if RSTN = '0' then
            temp &lt;= (others =&gt; '0');
        elsif(rising_edge(CLK)) then
            if CE = '1' then
                if std_logic_vector(temp) = (temp'range =&gt; '1') then
                    temp &lt;= (others =&gt; '0');
                else
                    temp &lt;= temp + 1;
                end if;
            end if;
        end if;
    end process;

    DOUT &lt;= std_logic_vector(temp);

end behavioral;


I use the following testbench for simulation:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
library std;
use std.textio.all;

use work.tools_pkg.all;

library work;

--! @class  tools_tb
--! @brief  Test bench for the tools_tb design
entity counter_tb is
  generic (
    VOID : integer := 0);
  port (
    void_i : in std_logic);
end entity counter_tb;

--! @brief
--! @details
architecture sim of counter_tb is

    -- Clock period definitions
    -- Clock, reset and baud rate definitions
    constant CLK_FREQ   : integer   := 100_000_000;
    constant clk_period : time      := (1.0 / real(CLK_FREQ)) * (1 sec);
    signal end_sim          : boolean := false;

    signal rstn             : std_logic;
    signal clk              : std_logic;
    signal s_en             : std_logic := '0';

    ------------------------------------------------------------------------------
    -- DUT signals
    ------------------------------------------------------------------------------

    signal s_dout        : std_logic_vector(3 downto 0) := (others =&gt; '0');
    signal s_ce          : std_logic := '0';

begin  -- architecture 


    fifo : entity work.simple_counter
    port map (
        DOUT =&gt; s_dout,
        CE  =&gt; s_ce,
        RSTN =&gt; rstn,
        CLK =&gt; clk
    );


    -- Clock process definitions (clock with 50% duty cycle is generated here).
    clk_process : process
    begin
        if end_sim = false then
            clk &lt;= '1';
            wait for clk_period/2;
            clk &lt;= '0';
            wait for clk_period/2;
        else
            wait;
        end if;
    end process;

    -- Stimulus process
    stim_proc: process
    begin
        -- startup and wait for some time
        rstn &lt;= '0';
        wait for clk_period;
        rstn &lt;= '1';
        wait for clk_period;
        wait for clk_period;
        wait for clk_period;

        s_ce &lt;= '1';

        wait;
    end process;

end architecture sim;


I am confused why the counter increases instantly when I set CE &lt;= '1
(see the attached simulation). 
Since the counter is implemented in a synchrous process, shouldn't it take a single clock cycle until it is increased from '0' to '1'?

Thanks a lot!","You most likely have a race condition between s_ce and clk. If you will generate the s_ce on the rising edge of clk then you should see that counter works correctly.

I don't know this simulator but to check the race you can expand deltas when counter changes 0->1",,,,,
"Parameters, localparams and left padding single bit-value ('1)","If i have understood things correctly a SystemVerilog parameter does not have an inherent type, but will take type of the value assigned to it. Similarly the '1 notation should adapt to the type of the variable. What happens when we combine the two?

That is, what result is expected from the parameter instantiations in these snippets?

localparam BAR = '1;


and

module testModule #(parameter BAR = 0, parameter [3:0] LONGBAR = 0)
(input logic a, output logic b);
  assign b = a;
endmodule

testModule #('1, '1) u_testModule0(a, b);


and

testModule #(BAR, BAR) u_testModule1(a, b);
","In the absence of any type context (self-determined), the literal '1 is equivalent to 1'b1. The assignment to the localparam BAR is self-determined, so BAR is a one bit parameter with the value 1'b1

Because your testModule defines BAR without a type, any expression used to override it will be evaluated in a self-determined context. The expression used to override LONGBAR will be evaluated in the context of a 4-bit integral type.  

testModule #('1, '1) u_testModule0(a, b);


So in the instantiation above, the first override evaluates to 1'b1 and the second override evaluates to 4'b1111. testModule's BAR type resolves to a 1-bit type and LONGBAR's type is fixed at 4-bits.

testModule #(BAR, BAR) u_testModule1(a, b);


In the second instantiation, the first override takes on the type of the localparam BAR, so testModule's BAR type resolves to a 1-bit type with the value 1'b1. But in the second override, this is an assignment in the context of a 4-bit type. Since localparam BAR has the value 1'b1, it gets padded with 0's and LONGBAR gets the value 4'b0001.",,,,,
Casting to a fixed width signed number,"I am reading back a register field from a UVM RAL model. The field itself is a 14 bit signed number, but RAL has no sense of sign so I need to grab just the relevant bits and then cast them to a signed number

uvm_reg_data_t reg_value;
int destination;

reg_value = reg_field.get();
assign destination = signed'(14'(reg_value));


Is there a way to do this with one cast? I know I could define a type and then use that, but I was wondering if there was any syntax like this that would work:

assign destination = (14's)'(reg_value);
","There is no such syntax to do this in a single cast without a typedef. You could also do

assign destination = signed'(reg_value[13:0]);


But I think creating a typedef for the field type would be best to show your intent.",,,,,
Verilog/SV conditional variable definition,"Is there a way to manipulate variable instantiation depending on a parameter?

For example, here if I were to put just bit [WIDTH-1:0] a; and set DEPTH == 1, WIDTH would be 0 and bit [-1:0] a; would not make sense.

When I code it like in the example below I get an error on the second $display: ""Undeclared identifier: a"". Is there a way to achieve this in Verilog/SV or is there an error in my code?

module test #(
  parameter DEPTH = 2,
  parameter WIDTH = $clog2(DEPTH)
)();

  generate
    if (WIDTH == 0) begin
      bit             a;
    end else begin
      bit [WIDTH-1:0] a;
    end
  endgenerate

  initial begin
    $display(""WIDTH: %d"", WIDTH);
    $display(""Bit width of a: %d"", $bits(a));
  end
endmodule: test
","All you need to do is

bit [(WIDTH&gt;0 ? WIDTH-1 : 0):0] a;
",,,,,
UVM macros- SVTEST/SVTEST_END,"I read the following blog regarding axi driver:
http://blog.verificationgentleman.com/2016/08/testing-uvm-drivers-part-2.html?showComment=1471877179631#c7809781639091671746

In this blog there are several uses in SVTEST/SVTEST_END macros. I can't find explenation regarding those macros.",I believe he is using a library called SVUNIT See http://www.agilesoc.com/open-source-projects/svunit/svunit-getting-started/,,,,,
understanding of vhdl code and flow of 4 bit ALU?,"I am making 4 bit ALU here i have declared entities

entity ALU is
      Port ( a : in  STD_LOGIC_VECTOR (3 downto 0););
       end ALU;


can you please explain that how logic vector array works there i mean syntax of 

        a : in STD_LOGIC_VECTOR (3 downto 0);


and also  

the operator => 

2- what is difference between sequential design and combinatorial design AND hierarchical design and tell me ALU CPU is coded in all of them?","
  can you please explain that how logic vector array works there i mean
  syntax of


a : in STD_LOGIC_VECTOR (3 downto 0);


this is a port declaration, consisting of


a - the name of the port
in - its direction - it supplies a signal into this entity
STD_LOGIC_VECTOR - its type (roughly, an array of bits)
(3 downto 0) its index type (4 integers in a descending range)
; - a separator before the next declaration.


It's not clear from the question, what you don't understand.


  the operator =>


Is not really an operator, you can't overload it for example - it's an association, associating (in a case statement) the case value on the left with the case action on the right.

You'll also see it associating parameter names with parameter values in argument lists, port maps, etc.


  2- what is difference between 4 bit behavioral alu and 4 bit verdict
  multiplier


One can add, the other can multiply. Though I've never heard of a ""verdict"" multiplier.",,,,,
"Viewing SV testbench tasks,signal names in Modelsim","I want to view in Modelsim SV driver signals, tasks to debug. I don't want to add display statements everywhere to know how my test is progressing.Please let me know if there is a way we can do it. I tried adding the signals from simulation but when I restart the simulation the tool hangs ","$display and (for UVM) uvm_info statements are the most common ways of debugging signals that reside inside functions and tasks.  ModelSim/Questa have the ability to add signals from inside a uvm_component to a waveform, but not transient signals that exist only inside a function or task.  One trick I do to view them inside the waveform or log is to create an observe signal outside the function/task that I assign the value that I want to observe whenever the task is called.",,,,,
"Verilog, generate/loop with parameterized array declaration","I am trying to find the max value inside a parameterized array, I was looking at this post and came across forloop-generate. The only change I want to make is change that approach of a explicit array to parameterized array, but I am running into genvar assignment problem.

   reg [$clog2(LENGTH)-1:0] arr [0:LENGTH-1];

   wire [$clog2(LENGTH)-1:0] value_l1[0:LENGTH-2];
   wire [$clog2(LENGTH)-1:0] index_l1[0:LENGTH-2];

   genvar gen_i, gen_j, gen_k;
   generate
      for(gen_i = 0; gen_i &lt; LENGTH; gen_i = gen_i + 2) begin : loop1
         Compare cmp1(.A(arr[i])
                     ,.B(arr[i+1])
                     ,.indexA(i)
                     ,.indexB(i+1)
                     ,.value(value_l1[i/2])
                     ,.index(index_l1[i/2])
                     );
      end

      gen_k = 0;
      for(gen_i = 1; gen_i &lt; $clog2(LENGTH); gen_i = gen_i + 1) begin : loop2_1
         for(gen_j = 0; gen_j &lt; LENGTH / (2*gen_i); gen_j = gen_j + 2) begin : loop2_2
            Compare cmp2(.A(value_l1[gen_k + gen_j])
                        ,.B(value_l1[gen_k + gen_j+1])
                        ,.indexA(index_l1[gen_k + gen_j])
                        ,.indexB(index_l1[gen_k + gen_j+1])
                        ,.value(value_l1[(LENGTH/(2*gen_i))+(gen_j/2)])
                        ,.index(index_l1[(LENGTH/(2*gen_i))+(gen_j/2)])
                        );
         end
         //gen_k = gen_j; // &lt;--------- problem here
      end
   endgenerate


My approach is to have a list of the compared elements, and then compare that list and write back the result to the same list. For example:

original array : 0 1 2 3 4 5 6 7


would results into

compare array : 1 3 5 7 | 3 7 | 7
                          ^     ^
                          |     |
                          |     largest element
                          |
                          gen_k + gen_j 


then output 7 as the largest element, but I cannot do gen_k = gen_j to save the index (offset to the second part of the compare array). Is it even possible to use generate with parameterized array? If so, how can I fix this problem?","You can do this with an intermediate parameter. 

  for(gen_i = 1; gen_i &lt; $clog2(LENGTH); gen_i = gen_i + 1) begin : loop2_1
         parameter param_k = LENGTH / (2*gen_i) + 1; 
         for(gen_j = 0; gen_j &lt; LENGTH / (2*gen_i); gen_j = gen_j + 2) begin : loop2_2
            Compare cmp2(.A(value_l1[param_k + gen_j])
                        ,.B(value_l1[param_k + gen_j+1])
                        ,.indexA(index_l1[param_k + gen_j])
                        ,.indexB(index_l1[param_k + gen_j+1])
                        ,.value(value_l1[(LENGTH/(2*gen_i))+(gen_j/2)])
                        ,.index(value_l1[(LENGTH/(2*gen_i))+(gen_j/2)])
                        );
         end
      end
",,,,,
How to set verbosity of a uvm_sequence from command line?,"What's the best way to set the verbosity of a uvm_sequence from command line?

I know it is possible to set the verbosity of ALL sequences on a sequencer like:

+uvm_set_verbosity=*my_sequencer,_ALL_,UVM_HIGH,run

However, the sequencer has tons of sequences that are spewing too much info. Any way to just get the one sequence I'm interested in?","If you give the messages coming from the sequences a unique ID (or one that can be match with a regular expression), then the second argument to +uvm_set_verbosity can be used to select the messages you want to silence. ",,,,,
How to convert Verilog (.v) project to EDIF(.edf) format?,"I have very poor verilog knowledge, but i need to convert Verilog project, containing some .v files and folders wth .v files to one large EDIF file for parcing.
Is there any easy way to do this?
I have found iverilog tool, but not sure how to convert all project with subfolders at once. 
Thank you!","
EDIF (Electronic Design Interchange Format) is a vendor-neutral format in which to store Electronic netlists and schematics. https://en.wikipedia.org/wiki/EDIF .
Verilog is a Hardware Description Language, which can describe hardware at a higher, behavioural level of abstraction. 


So, in general at least, the two are not compatible. So, in general, you will need to convert your Verilog to gate-level in order for it to be suitable for EDIF. The tool that converts Verilog to gate-level is a logic synthesiser and most, if not all, logic synthesisers will be able to output your netlist as an EDIF file. 

So, 


if your Verilog is not already gate-level, you will need a logic synthesiser. If you're doing an FPGA design, that will be your FPGA tool: Quartus, Vivado etc. 
if your Verilog is already gate-level, then there may be other, more basic, tools that convert from one to another; I don't know. But, if your Verilog is already gate-level, a logic synthesiser will also be able to do the conversion.
",,,,,
Registering Platform Device with info from Device Tree,"I am using Petalinux for a Xilinx Zynq application, and I am new to kernel driver development. 

I created a kernel module for a platform driver for an AXI FIFO interface. The devices seems to be recognised from the device tree using the .of_match_table, since I can see the correct memory space reserved with cat /proc/iomem .

If I search for the driver name xxx I get

./lib/modules/4.4.0-xilinx/extra/xxx.ko
./sys/bus/platform/drivers/xxx
./sys/module/xxx
./sys/module/xxx/drivers/platform:xxx


I found the device under /sys/bus/platform/devices/43c00000.axi_xxxx but still can't access it or see it under /dev/. 


How do I register device so that I can open it from my user space app?. 
Do I need to allocate memory for it and then register a new device using platform_device_register(pdev)?


Thanks","You need to register your device in a framework to get a device file created.

I would suggest registering a miscdevice in your case. It simply registers a character device.

static struct miscdevice miscdev;

static ssize_t myaxi_read(struct file *file, char __user *buf,
                 size_t sz, loff_t *ppos)
{
    // Do something

}

static ssize_t myaxi_write(struct file *file, const char __user *buf,
                  size_t sz, loff_t *ppos)
{
    // Do something
}

static const struct file_operations myaxi_fops = {
    .owner = THIS_MODULE,
    .write = myaxi_write,
    .read = myaxi_read,
};


In your probe:

miscdev.minor = MISC_DYNAMIC_MINOR;
miscdev.name = ""myaxi"";
miscdev.fops = &amp;myaxi_fops;
misc_register(&amp;miscdev);


You can read more about linux kernel driver development and the device model at http://free-electrons.com/doc/training/linux-kernel/linux-kernel-slides.pdf",,,,,
Bind assertion to a module instance using generate,"I'm trying to bind my assertions for the module instances generated using generate for statment.

Below is my bind statement in my bind assert module:

`define NUM_BLKS 4;
genvar asrt_inst;
generate
for (asrt_inst = 0;asrt_inst &lt; `NUM_BLKS;asrt_inst = asrt_inst+1) 
begin 
bind top.u_dut.u_blk_gen[asrt_inst].u_blk my_assert u_my_assert (
.*
);
end
endgenerate


Here, the RTL is under gen block of u_blk_gen[gen_var], and I'm trying to bind my assertion to each instance of the generated instance.
The path instances of the RTL, generated using the generate block are :


top.u_dut.u_blk_gen[0].u_blk 
top.u_dut.u_blk_gen1.u_blk 
top.u_dut.u_blk_gen[2].u_blk
top.u_dut.u_blk_gen[3].u_blk


And with the bind statement, I get the below compile error:

bind top.u_dut.u_blk_gen[asrt_inst].u_blk my_assert u_my_assert (
                                 |
ncvlog: *E,ILLGVR (/home/user/assertion_bind.v,165|72): This genvar cannot be used in this context [12.1.3(IEEE 2001)].


Need to get rid of this issue.

Is this valid statement?

If not, is there a work around for such scenario?

Code at EDA Playground","This is a tools' support issue.
Contacted the vendor(cadence), which stated that this feature is supported in latest versions of the tool.

And we need to pass -nncbind command line option.

And this feature is supported in version 15.1 on wards and it requires additional incubation license. 
But from 15.20.008 version on wards, it does not require additional license.",,,,,
What is difference between + operator and + function is vhdl?,there is + operator in vhdl to addition operation then why do we need to add  ieee.std_logic_unsigned and in this library there is function for + so why that function is defined if we already have + operator in vhdl?,"The + operator, like all VHDL operators, also has a functional notation. a+b and ""+""(a,b) are exactly the same. The good aspect of this is that you can overload the VHDL operators to operate on types for which they are not defined by default. Simply define a ""+"" function that takes two arguments of your own type my_type and voilÃ . You can now use a+b where a and b are of type my_type.

The + operator is not defined by default on types std_ulogic_vector or std_logic_vector. This is a fact. You can disagree with this but it is the VHDL standard. So, if you want to use it with these types you need to define it one way or another.

The ieee.std_logic_unsigned package overloads the arithmetic operators on them. It is not a standard package and has nothing to do in the standardized ieee library. Do not use it. Use the standard ieee.numeric_std, instead, that declares types unsigned and signed and overloads the arithmetic operators on them.

Note that, as mentioned by user1155120, VHDL 2008 introduced several new synthesis packages. One of them is ieee.numeric_std_unsigned and it does overload the arithmetic operators on type std_ulogic_vector considered as unsigned natural integers.",,,,,
"Verilog ""In, out, or inout does not appear in port list""","I can't understand what this error means.
I want to make a simple calculator with memory, however this error jumped out and I cant get what the 


  ** Error: C:\Users\Kainy\Desktop\LOGIC\calculator\cal.v(14): In, out, or inout does not appear in port list: f1.
  ** Error: C:\Users\Kainy\Desktop\LOGIC\calculator\cal.v(15): In, out, or inout does not appear in port list: f2.


means.
Seems my f1, f2 have some invalid things, how can  I fix it?  

module cal( a,b,c,op,clk,reset,en,r_w);     
input [3:0] a;
input [3:0] b; 
input [7:0] c; 
input [2:0] op; 
input clk;
input reset;
input en;
input r_w;



output reg [7:0] f1;
output reg [7:0] f2; 


wire [7:0] f3;




always@(a or b or op) begin
case(op)
3'b000: begin
 f1 = a;
 f3 = f1;
end

3'b001: begin
 f1 = b;
 f3 = f1;
end


3'b010: begin 
 f1 = a+b;
 f3 = f1;
end

3'b011: begin
 f1 = a - b;
 f3 = f1;
end

3'b100: begin
 f1 = a * b;
 f3 = f1;
end

3'b101: begin
 f1 = b+a;
 f3 = f1;
end

3'b110: begin
 f1 = b-a;
 f3 = f1;
end

3'b111: begin
 f1 = 0;
 f3 = 0;
end
endcase
end

mem32 mem(clk,reset,en,r_w,c,f3,f2);

endmodule
","You have specified f1 and f2 as being outputs, but have not specified them in the port list: in other words, f1 and f2 do not appear on this line: module cal( a,b,c,op,clk,reset,en,r_w);.

Incidentally, you are using a very old-fashioned style. In 2001 this style (the ""ANSI style"") was introduced:

module cal(      
  input [3:0] a,
  input [3:0] b, 
  input [7:0] c, 
  input [2:0] op, 
  input clk,
  input reset,
  input en,
  input r_w,
  output reg [7:0] f1,
  output reg [7:0] f2
); 


Had you used this ANSI style, your error would never had occurred. 

I always recommend ANSI style for all new code to the people I teach. I teach this old-fashioned style, but mention that I am only doing so so that they can understand legacy code.",,,,,
Unhandled fault when accessing AXIS FIFO registers through device driver,"I am using a Zynq SoC with Petalinux 2016.2 I originally accessed my AXIS Fifo by opening it with

open(""/dev/mem"", O_RDWR | O_SYNC)


and using mmap to access it. I could access the registers of the AXIS device and interface successfully with the device through my C application.

I then created a platform device driver, and misc device node to access the device. The device is succesfully recognized by the driver, and I then 

fd = open(""/dev/devname, O_RDWR | O_SYNC)


and then mmap the device again with:

info-&gt;mapped_base = mmap(0, AXIFIFO_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)


I can read the registers and it seems to be the correct memory region. But when I start writing to some of the registers I start getting the following error:

Unhandled fault: imprecise external abort (0x1406) at 0x36e42000
pgd = 40ab4000
[36e42000] *pgd=3bff0831, *pte=43c0075f, *ppte=43c00c7f
Bus error


At first it seemed only to be when I write to the SRR reset register, but there's still a few other places as well.

Is there something obvious I am missing? I am suspecting it's to do with specific flags relating to the way the memory is mapped and can be accessed.

I currently have my own mmap function in the device driver where I do the following operation where start and length denotes the size of the mapped region of the AXIS FIFO's registers.

vm_iomap_memory(vma, start, length)
","It seems the memory was marked as cached in the vma_area_struct:

So simply:

vma-&gt;vm_page_prot = pgprot_noncached(vma-&gt;vm_page_prot);


before 

vm_iomap_memory(vma, start, length)


did the trick.",,,,,
How does SV solver treat multiple relationship operators in the same constraint?,"I came across a constraint which was behaving weirdly (illustrated below) :

class A;
  rand bit[3:0] a,b,c,d;

  constraint c_abcd{
      2&lt;a&lt;b&lt;c&lt;d&lt;20;
  }
endclass : A


I know that this is not the right way to specify that constraint and that we need to split it up into multiple constraints. But I expected it to give an error. Instead, it runs without any error and I could see different values for a,b,c,d being generated.

These numbers initially seem to be random, but I guess the system verilog solver behaves in a predictable manner to tackle these constraints.

So can you explain how this is solved? When I randomize with the above constraint, I get the following output :

a = 1101;
b = 0101;
c = 0111;
d = 1100;


Thank You","It turns out the constraint expression you have written evaluates true for any values of a,b,c, and d. Which is equivalent to having no constraint at all.

Since your expression evaluates from left to right, it is the same as writing ((((2&lt;a)&lt;b)&lt;c)&lt;d)&lt;20. The result of the outer most set of ()'s will be either 1'b0 or 1'b1 for any combination of values, and that result is always less than 20.",,,,,
Why does this VHDL code work? 4:2 Priority encoder using Case statement,"The code is below:

entity encoder_case is
 port(
     din : in STD_LOGIC_VECTOR(3 downto 0);
     dout : out STD_LOGIC_VECTOR(1 downto 0)
     );
end encoder_case;

architecture encoder_case_arc of encoder_case is
begin
encoder : process (din) is
begin
    case din is
        when ""1000"" =&gt; dout &lt;= ""00"";
        when ""0100"" =&gt; dout &lt;= ""01"";
        when ""0010"" =&gt; dout &lt;= ""10"";
        when ""0001"" =&gt; dout &lt;= ""11"";
        when others =&gt; dout &lt;= ""ZZ"";
    end case;
end process encoder;
end encoder_case_arc;


Now you'd expect that this code does not cover cases suh as when din is ""0101"", ""1010"" etc. But for those inputs, dout produces ""10"" and ""11"" respectively. Why does this work? Does VHDL intelligently give higher priority to the higher order bits? Does it 'know' that we're trying to accomplish a priority encoder here?","All cases under ""others"" should produce ""ZZ"", except if another signal would be driving dout. We will indeed need your testbench and waveforms to clarify this.

As for your other questions: There is no such thing as priority in a case, not in terms of the order of options and certainly not in the sense of higher/lower bits.

And it certainly does not ""know"" what you want to do. What you get is what you wrote, as always ... It might just take some time to understand what you exactly wrote sometimes.",,,,,
Bitshifting std_logic_vector while keep precision and conversion to signed,"In VHDL I want to take a 14 bit input and append '00' on the end to give me a 16 bit number which is the 14 bit input multiplied by 4 and then put this into a 17 bit signed variable such that it is positive (the input is always positive). How should I go about this?

like this? shiftedInput &lt;= to_signed('0' &amp; input &amp; '00', 17);

Or maybe like this? shiftedInput &lt;= to_signed(input sll 2, 17); 

Or this? shiftedInput &lt;= to_signed(input &amp; '00', 17); 

Does it see that the std_logic_vector it's getting is 16 bit and the signed variable is 17 bit and therefore assume the most significant bit (the singing bit) is 0?

Or do I have to do this? shiftedInput &lt;= to_signed('0' &amp; input sll 2, 17);

e.g. If I read in the 14 bit number 17 as a std_logic_vector [i.e. (00 0000 0001 0001)] it should be converted to the signed number +68. [i.e. (0 0000 0000 0100 0100)]","std_logic_vector is compatible with the type signed of numeric_std. So, the type conversion function is signed (not to_signed that converts between integers and vectors):

shiftedInput &lt;= signed('0' &amp; input &amp; ""00"");


should make it. Note the ""00"" instead of your '00'. Bit strings are double-quoted while bits are single-quoted.",,,,,
"I am doing a mux 4:1 on verilog, but the output is not the expeted","I've seen some examples on internet about mux 4:1 on verilog. I've tried to do something but the output is not the expeted. This is the source :
module mux41 (a, b, c, d,select,z);

input a,b,c,d;
input [1:0]select;
output reg z;

always@(select )
begin
case (select)
    2'b00: assign z=a;
    2'b01: assign z=b;
    2'b10: assign z=c;
    2'b11: assign z=d;
endcase
end
endmodule

and this is the testbench :
module mux41_tb;

reg at,bt,ct,dt;
reg [1:0] selectt;
wire zt;

mux41   test(.a(at),.b(bt),.c(ct),.d(dt),.select(selectt),
            .z(zt));
            
initial
begin
     $monitor (&quot;a=%d&quot;,at,&quot;b=%b&quot;,bt,&quot;c=%b&quot;,ct,
                    &quot;d=%b&quot;,&quot;select=%b&quot;,selectt,&quot;z=%z&quot;,zt);
                    
    selectt =2'b00;
    #5
    selectt =2'b01;
    #5
    selectt =2'b10;
    #5
    selectt =2'b11;
    #5;
    
end

endmodule

but the output is the following :

My question is what I should chance in both codes (source and testbench).","You're getting


  a=xb=xc=x


Because you never gave a, b, or c any values. You assign z to a for example, but a has no value since at has no value, so you're just getting x. 

As for


  d = 0111...


It's because of your monitor line

$monitor (""a=%d"",at,""b=%b"",bt,""c=%b"",ct,
                ""d=%b"",""select=%b"",selectt,""z=%z"",zt);


You forgot dt

$monitor (""a=%d"",at,""b=%b"",bt,""c=%b"",ct,
                ""d=%b"",dt,""select=%b"",selectt,""z=%z"",zt);
",,,,,
Syntax Error in Verilog 4'b0000,"I seem to have run into a strange Syntax error. So far as I was concerned it shouldn't be wrong? I've tried it with multiple simulations on EDA Playground. They all return a syntax error.

Here's the code:

//varaibles to store temp reg ID's
  reg [3:0] reg_d, reg_s, reg_t;

  always @* begin
    reg_d = 4â€™b0000;
    reg_s = 4â€™b0000;
    reg_t = 4â€™b0000;


I do more things and close it off fine. Here's the error.

Error-[SE] Syntax error
  Following verilog source has syntax error :
  ""wramp.sv"", 64: token is '\037777777742'
      reg_d = 4\037777777742\037777777600\037777777631b0000;


It seems like it's the ' but yeah. I searched google all over for correct syntax, but can't find anything wrong with what I have. Does anyone know how to fix this?","The apostrophes used in the code aren't the ""proper"" apostrophes. If you look at the error message or the comment in the beginning of the code the character ' is the proper one while in the code there is a â€? These characters won't work so you have to change them to the proper versions.",,,,,
Verilog: How to declare many reg in generate statement according to genvar i,"I want to declare many reg in generate statement according to genvar i. For example, I want to declare reg_0, reg_1, reg_2 ... reg_9 if genvar i = 10 i.

How can I do this?","I think you have to declare them as arrays. My Verilog is a little rusty, but I think something like this should work:

reg [width-1:0] foo [0:i - 1];
",,,,,
Where is the latch?,"Iam making the code for a secuential tail lights for a mustang, but iam getting a latch with Llights and Rlights. According to my logic there should be no problem. 

----------------------------------------------------------------------------------
-- Company:        Pony incorporated
-- Engineer:       Pony
-- 
-- Create Date:    17:41:27 10/23/2013 
-- Design Name: 
-- Module Name:    Mustang_FSM - Behavioral 
-- Project Name: 
-- Target Devices: Spartan 6 (Nexys 3 Digilent board)
-- Tool versions:  ISE Webpack v14.6
-- Description:    Using a Moore FSM, define the sequential tail
--                 lights found on a Ford Mustang. Look at the
--                 following video:
--                 https://www.youtube.com/watch?v=KVFA-HuikfY
-- Dependencies:   None
--
-- Revision: 
-- Revision 0.01 - File Created
-- Additional Comments: The realization of the Moore FSM is based
--                      on the template described by your teacher
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity Mustang_FSM is
    Port ( Lturn     : in   STD_LOGIC;
           Rturn     : in   STD_LOGIC;
           Hazard    : in   STD_LOGIC;
           Rst       : in   STD_LOGIC;
              Break     : in   STD_LOGIC;
           Clk100MHz : in   STD_LOGIC;
           Llights   : out  STD_LOGIC_VECTOR (2 downto 0);
           Rlights   : out  STD_LOGIC_VECTOR (0 to 2));
end Mustang_FSM;

architecture Behavioral of Mustang_FSM is
  -- Definition of embedded signals and constants
  -- Constants used for frequency division
  constant Fosc    : integer := 100000000;   --Frecuencia del oscilador de tabletas NEXYS 3
  constant Fdiv    : integer := 4;           --Frecuencia deseada del divisor
  constant CtaMax  : integer := Fosc / Fdiv; --Cuenta maxima a la que hay que llegar
  -- Signal used by the frequency division process
  signal Cont      : integer range 0 to CtaMax;
  signal Clk_En    : STD_LOGIC;

  -- State definition for the FSM
  -- Binary encoding (default) will be used 
  -- Equivalent of enumeration types in programming languages  
   type state_values is (ST0,ST1,ST2,ST3,ST4,ST5,ST6,ST7, ST8);
   signal pres_state, next_state: state_values;

  -- One hot state coding
  -- ONE HOT ENCODED state machine: Sreg0
--  subtype Sreg0_type is std_logic_vector(7 downto 0);
--  constant ST0: Sreg0_type := ""00000001"";
--  constant ST1: Sreg0_type := ""00000010"";
--  constant ST2: Sreg0_type := ""00000100"";
--  constant ST3: Sreg0_type := ""00001000"";
--  constant ST4: Sreg0_type := ""00010000"";
--  constant ST5: Sreg0_type := ""00100000"";
--  constant ST6: Sreg0_type := ""01000000"";
--  constant ST7: Sreg0_type := ""10000000"";
--  signal pres_state, next_state: Sreg0_type;

  -- Used to concatenate Lturn, Rturn and Hazard for easier
  -- handling
  signal LRH       : STD_LOGIC_VECTOR (3 downto 0);

begin
  -- Frequency divider to obtain a 2Hz signal from
  -- the 100 MHz board oscillator
  FreqDiv: process (Rst, Clk100MHz)
  begin
    if Rst = '1' then
       Cont &lt;= 0;
     elsif (rising_edge(Clk100MHz)) then
       if Cont = CtaMax - 1 then
        Cont      &lt;= 0;
        Clk_En    &lt;= '1';
      else        
         Cont      &lt;= Cont + 1;
          Clk_En    &lt;= '0';
        end if;
    end if;
  end process FreqDiv;

  -- The FSM definition begins next

  -- ""Current State Register"" (StateReg) description
  StateReg: process (Clk100MHz,Clk_En,Rst)
  begin
    if (Rst = '1') then 
      pres_state &lt;= ST0;
    elsif (rising_edge(Clk100MHz) and Clk_En = '1') then
      pres_state &lt;= next_state;
    end if;
  end process StateReg;

  -- ""Next State Logic"" (FSM) description
  LRH &lt;= Break &amp; Lturn &amp; Rturn &amp; Hazard;
  FSM: process (pres_state, LRH)
  begin
    case pres_state is

      when ST0 =&gt; 
        case LRH is
          when ""0000""   =&gt; next_state &lt;= ST0; -- All off
          when ""0110""   =&gt; next_state &lt;= ST0; -- All off
          when ""0100""   =&gt; next_state &lt;= ST2; -- Left Turn
          when ""0010""   =&gt; next_state &lt;= ST5; -- Right Turn
          when ""1000""   =&gt; next_state &lt;= ST8; -- Break

          when others  =&gt; next_state &lt;= ST1; -- Hazard
        end case;

      when ST1         =&gt; next_state &lt;= ST0;
      when ST2         =&gt; next_state &lt;= ST3;
      when ST3         =&gt; next_state &lt;= ST4;
      when ST4         =&gt; next_state &lt;= ST0;
      when ST5         =&gt; next_state &lt;= ST6;
      when ST6         =&gt; next_state &lt;= ST7;    
      when ST7         =&gt; next_state &lt;= ST0;

        when ST8 =&gt;
            case LRH is 
                when ""1000"" =&gt; next_state &lt;= ST8;
                when others  =&gt; next_state &lt;= ST0;
        end case;



      -- Include when others to avoid latches  
      when others      =&gt; next_state &lt;= ST0;
    end case;
  end process FSM;

  -- ""Output Logic"" (Outputs) description
  Outputs: process (pres_state)
  begin
    case pres_state is

      when ST0 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""000"";
      when ST1 =&gt; Llights &lt;= ""111""; Rlights &lt;= ""111"";   
      when ST2 =&gt; Llights &lt;= ""001""; Rlights &lt;= ""000"";
      when ST3 =&gt; Llights &lt;= ""011""; Rlights &lt;= ""000"";
      when ST4 =&gt; Llights &lt;= ""111""; Rlights &lt;= ""000"";
      when ST5 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""001"";
      when ST6 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""011"";
      when ST7 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""111"";   
      when ST8 =&gt; Llights &lt;= ""111""; Rlights &lt;= ""111"";
      when others =&gt; null;
   end case;
  end process Outputs;

end Behavioral;


The description of the warning: 

WARNING:Xst:737 - Found 3-bit latch for signal . Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.

WARNING:Xst:737 - Found 3-bit latch for signal . Latches may be generated from incomplete case or if statements. We do not recommend the use of latches in FPGA/CPLD designs, as they may lead to timing problems.

Thanks for the help. :D","Instead of this:

  Outputs: process (pres_state)
  begin
    case pres_state is
      when ST0 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""000"";
      when ST1 =&gt; Llights &lt;= ""111""; Rlights &lt;= ""111"";   
      when ST2 =&gt; Llights &lt;= ""001""; Rlights &lt;= ""000"";
      when ST3 =&gt; Llights &lt;= ""011""; Rlights &lt;= ""000"";
      when ST4 =&gt; Llights &lt;= ""111""; Rlights &lt;= ""000"";
      when ST5 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""001"";
      when ST6 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""011"";
      when ST7 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""111"";   
      when ST8 =&gt; Llights &lt;= ""111""; Rlights &lt;= ""111"";
      when others =&gt; null;
   end case;
  end process Outputs;


Do This:

  Outputs: process (pres_state)
  begin
    case pres_state is
      when ST0 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""000"";
      when ST1 =&gt; Llights &lt;= ""111""; Rlights &lt;= ""111"";   
      when ST2 =&gt; Llights &lt;= ""001""; Rlights &lt;= ""000"";
      when ST3 =&gt; Llights &lt;= ""011""; Rlights &lt;= ""000"";
      when ST4 =&gt; Llights &lt;= ""111""; Rlights &lt;= ""000"";
      when ST5 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""001"";
      when ST6 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""011"";
      when ST7 =&gt; Llights &lt;= ""000""; Rlights &lt;= ""111"";   
      when ST8 =&gt; Llights &lt;= ""111""; Rlights &lt;= ""111"";
      when others =&gt; Llights &lt;= ""000""; Rlights &lt;= ""000"";
   end case;
  end process Outputs;


The question your compiler is asking you is: ""What is the value of Llights when pres_state is ST9?"" I'm aware that ST9 doesn't exist, but the compiler doesn't care. Which is annoying.",,,,,
VHDL - Asynchronous up/down counter,"I'm doing a college's task that asks for implementing in VHDL an up/down asynchronous counter. 

My implementation consistis of using a control variable ctrl so when it's 0, the counter counts in ascendant order, else in descendent one.

The code I've implemented (In the discipline, we use Quartus 13 and FPGA Cyclone IVE EP4CE129C7 for simulation) is followed in this link. The resulting simulation, however, exhibits only '0' for outputs q0 and q1. 

So, where can be a possible bottleneck in the code so that this is occuring?","I'm not a quartus user so have no familiarity with the limits of your waveform viewer, but this looks like it's caused from migrating from type BIT to type Std_Logic.  Where the default value (unless otherwise specified would be 'U' for Std_Logic (Std_ULogic) while it would be '0' for type BIT.

That results in you assigning NOT 'U' for the FFT q's to the input of the MUX.  The result is your flip flops never get assigned a value other than 'U'.  

From the std_logic_1164 package:

   -- truth table for ""not"" function
    CONSTANT not_table: stdlogic_1d :=
    --  -------------------------------------------------
    --  |   U    X    0    1    Z    W    L    H    -   |
    --  -------------------------------------------------
         ( 'U', 'X', '1', '0', 'X', 'X', '1', '0', 'X' );


NOT of a 'U' is a 'U'.

With a waveform viewer that shows 'U' values:



This was done with ghdl and gtkwave, and an added testbench.  The only change to architecture arc of Taraefa09 was to add sq0_n and assign it in a concurrent signal:

INV:  sq0_n &lt;= not sq0;


Along with substituting sq0_n for sq0 in the first actual of I1: Mux2x1.  ghdl doesn't support a function used with the actual of inputs.

And the solution is to a) reset the flip flops or b) use type BIT or c) provide default values for q0 in FFT.  Choice a) would be preferred unless there's something about your target device that provides known default (initial) values. 

It turns out there's something else wrong as well:

ENTITY FFT IS
    PORT(
        clk: IN STD_LOGIC;
        q: OUT STD_LOGIC
    );
END FFT;

ARCHITECTURE Arc OF FFT IS
    SIGNAL sq: STD_LOGIC := '0' ;  -- choice c) 
    BEGIN
        PROCESS(clk)
        BEGIN
            IF(clk'event AND clk='1') THEN -- clk'event: Ã© o evento de subida/descida. 
                sq &lt;= (not sq);         -- changed target from q to sq
            END IF;
        END PROCESS;

    BUF: q &lt;= sq;   -- added concurrent statement

    END Arc;


This represents choice c) a default value for the actual q in the flip flop (named sq).  The type of flip flop is known as a toggle flip flop or T flip flop.

At this point we get:

",,,,,
Output of a module used as input of another in verilog,"While inside a module A I'm trying to use the output of a module B as the input of another module C. Essentially this is a ""go"" switch that is flipped in module B after certain conditions are met and then this is supposed to be the trigger for module C to activate. Is it possible to link an output and input like this?

I've been reading around and found this image particularly helpful - however, I don't quite understand the concept of nets or if they will be helpful. Would wiring the output of module B to a reg that's used as input to module C work? Thanks.

EDIT:

I'm looking for something like this (involving 3 different modules) where I'm instantiating a module B and a module C within a module A. I want to connect B's output to C's input.","you can make those connections
For example:

module my_moduleA (inA, outA)
input inA;
output reg outA; //If you want to assign something to out inside an always block, it has to be output reg, otherwise you will have to use assign out from an always block.

//Put your logic here

endmodule

module my_moduleB (inB, outB)
input inB;
output reg outB; //If you want to assign something to out inside an always block, it has to be output reg, otherwise you will have to use assign out from an always block.

//Put your logic here

//Instantiation of module A
my_moduleA instance(  //Here is the connection made between module A and B
.inA (inB),  
.outA (outB));
endmodule


This is how the connections are made, if you want to make those connections on internal signals, then you can use wire type",,,,,
Read data from FPGA via Android USB,"IÂ´ve to develop an app in Android, that must be able to read data that comes from a FPGA board, now some questions come into my mind:

As far as IÂ´ve read about usb connectivity and usb accessory and usb host, it looks lihe I need to attack this problem with USB Host, cause im pretty sure the fpga board is not designed to work with android. But I dont know if I need ""aditional tools"" to acomplish this job. For example, I have the micro usb cable that comes with android, obviously, the idea is to connect the usb extreme to the FPGA and the microusb extreme to the phone, then send data from the fpga and read it in the phone. Is this enough or I need another type of adapter? Also, do I need to install some software in my phone to do the job? And from the programming point of view... the API of the USB Host is all that I need?

Also, my knowledge in electronics is neraly zero, I dont know if I have to ask the person who is programming the FPGA some data about that board so I can develop this.

Finally, the person who is programming the FPGA is not finished yet, and I dont see him very often. Is there a way I can test my proyect with a PC software, which can be able to send data via usb?

Tanx for your time.","It all depends on what you want to send, and how fast you want to do this.

The easiest way to do this is to have a USB to serial interface connected to your Android phone (it must have a USB OTG port). Then data transfer to/from the FPGA will go over the serial interface. You do not need to install any drivers or write special code for that, it will act like a serial port on your android (you must find a device that supports android). 

Here is a list of all the phones that have HOST/OTG support

If you want something more complicated, then you can look into parallel interfaces for FPGA or even have a USB device on the FPGA, but that it going to be both complicated and expensive.",,,,,
FSM with Structural Description,"Using FSM in VHDL you have to declare the states, that are going to be used:

 type state_values is (ST0,ST1,ST2,ST3,ST4,ST5,ST6,ST7,ST8,ST9,ST10,ST11,ST12,ST13,ST14,ST15,ST16);
   signal pres_state, next_state: state_values;


I've tried used the states as a LOGIC_VECTOR, but then the state definition wouldnÂ´t be necessary. When using a Structural implementation, is there a way to use the state definition betweeen the components? Is there a way to implement a FSM with components?","Declare your state type in a package, then you can use the package in both components and they will share the state type; you can interconnect them with signals and ports of that type, etc.

But my question is why? The single process form of state machine is generally simpler and more reliable (it has just ""state"" instead of ""present_state"" and ""next_state""). What purpose is there in splitting a SM into not just several processes, but several components?",,,,,
Instantiating a value in or out of an always block,"I have written a piece of code that will return a quotient and a reminder, based on numbers that i provide and some other data that i used to shift the numbers in place.
The problem I have now is that i cannot keep a good track of my quotient if I test more values one after another.
I need a way to initialize my cat register, so that I no longer get residual values from previous computations.  

Here is the code I was talking about:

module divide(
  input      [7:0] a, b,
  input      [3:0] counter, msb,
  output reg [7:0] q,
  output reg [7:0] r
);
always @(*) begin
  for(i = 0; i &lt; counter + 1  ; i = i+1) begin
    sum = s_a + s_b;     //previously calculated values
      if(sum[8-msb] == 1) begin
        assign s_a       = s_a; 
        assign s_b       = s_b &gt;&gt;&gt; 1;
        cat[counter - i] = 1'b0;                
      end
      else begin
        assign s_a       = sum;
        assign s_b       = s_b &gt;&gt;&gt; 1;
        cat[counter - i] = 1'b1;
      end
      assign r = s_a;
      assign q = cat;
    end
  end
endmodule 


Note: I have declared all the registers that are in this code, but for some purpose I cannot declare them here.","You do not use assign inside always or initial blocks.

The assignments to cat are combinatorial therefore it is not a flip-flop, ie has no reset. The fact that it is a reg type has nothing to do with the hardware but a simulator optimisation.

I would have written it as (no functional alterations made):

module divide#(
  parameter DATA_W = 8
)(
  input      [7:0] a, b,
  input      [3:0] counter, msb,
  output reg [7:0] q,
  output reg [7:0] r
);
//Definitions
reg [DATA_W-1:0] sum;
reg [DATA_W-1:0] s_a;
reg [DATA_W-1:0] s_b;
integer i;

always @* begin
  for(i = 0; i &lt; (counter + 1); i = i+1) begin
    sum = s_a + s_b;     //previously calculated values
      if(sum[8-msb] == 1'b1) begin
       s_a              = s_a; 
       s_b              = s_b &gt;&gt;&gt; 1;
       cat[counter - i] = 1'b0;                
      end
      else begin
        s_a              = sum;
        s_b              = s_b &gt;&gt;&gt; 1;
        cat[counter - i] = 1'b1;
      end
      r = s_a;
      q = cat;
    end
  end
endmodule


You have the following line:

sum = s_a + s_b;     //previously calculated values


You have not included any flip-flops here, unless you have implied latches which are really to be avoided, there is no memory or state involved. i.e. there are no previously calculated values.

Instead of a combinatorial block you likely want to add a flip-flop and take multiple clock cycles to calculate the result.

instead of an always @* try:

always @(posedge clk or negedge rst_n) begin
  if (~rst_n) begin
     s_a &lt;= 'b0; //Reset Value
  end
  else begin 
    s_a &lt;= next value; //Normal logic
  end
end
",,,,,
Connecting modules using conditional (?:) assign statements,"i'm trying to connect 2 modules differently depending on bit_proc_rw signal value.
Can't post pictures yet, so:

if bit_proc_rw dataflow:   bit_in --> SCR --> CRC --> bit_out

if not, it's a reciever:   bit_in --> CRC --> SCR --> bit_out

So I did this in a top module(all wire-type):

assign SCR_input = (bit_proc_rw) ?  bit_proc_in : CRC_output; 
assign SCR_input_dav = (bit_proc_rw) ? bit_proc_in_dav : CRC_output_dav;

assign SCR_output = (bit_proc_rw) ? CRC_input : bit_proc_out;
assign SCR_output_dav = (bit_proc_rw) ? CRC_input_dav : bit_proc_out_dav;

assign CRC_input = (bit_proc_rw) ?  SCR_output : bit_proc_in; 
assign CRC_input_dav = (bit_proc_rw) ? SCR_output_dav : bit_proc_in_dav;

assign CRC_output = (bit_proc_rw) ? bit_proc_out : SCR_input;
assign CRC_output_dav = (bit_proc_rw) ? bit_proc_out_dav : SCR_input_dav;


crc_gen crc_gen_u (
.clk (clk),
.crc_in (CRC_input),
.crc_in_dav (CRC_input_dav),
.crc_out (CRC_output),
.crc_out_dav (CRC_output_dav),
.bit_proc_rw (bit_proc_rw),

);

scr scr_u (
.clk (clk),
.scr_in (SCR_input),
.scr_in_dav (SCR_input_dav),
.scr_out (SCR_output),
.scr_out_dav (SCR_output_dav),
.bit_proc_rw (bit_proc_rw)
);


Testbench shows that only inputs are being driven(ex. rw=0 CRC input works but rest are of unknown value). 
Is it because i'm assigning both input to output and output to input at the same time?
Or is this correct and i should look for bugs in my code? 
If not, how to do this using only 1 instance of each module?

Hope I made everything clear and thanks for your time!","The conditional operator (?:) is 2:1 mono-directional mux. The assign statements also mono-directional. Therefore the assignments are putting additional drivers on signals matching *_output*. The multiple conflicting drivers values are the cause of the unknown values. To correct the error, remove the assignments for outputs and assign a mux to bit_proc_out* with a mux

/* Remove / comment out:
 * assign SCR_output = (bit_proc_rw) ? CRC_input : bit_proc_out;
 * assign SCR_output_dav = (bit_proc_rw) ? CRC_input_dav : bit_proc_out_dav;
 *
 * assign CRC_output = (bit_proc_rw) ? bit_proc_out : SCR_input;
 * assign CRC_output_dav = (bit_proc_rw) ? bit_proc_out_dav : SCR_input_dav;
 */

// Add
assign bit_proc_out = (bit_proc_rw) ? CRC_output : SCR_output;
assign bit_proc_out_dav = (bit_proc_rw) ? CRC_output_dav : SCR_output_dav;
",,,,,
"""Invalid Module Instantiation"" Error in Mealy sequence detector - Verilog","I have defined a module for a Mealy State Machine that detects a particular sequence. I haven't encoded states as is usually a better choice as I wanted to do it the other way(I saw a similar example in a book, but the code was in VHDL).

module seq_detector(y_out,Clk,x_in);
  output y_out;
  reg y_out;
  input x_in, Clk;
  reg Q1,Q2,Q3,Q4;
  always @(posedge Clk)
    Q1 &lt;= (Q1&amp;&amp;(!Q3))||((!Q1)&amp;&amp;Q2;&amp;&amp;(!Q3)&amp;&amp;(!Q4)&amp;&amp;(x_in));
    Q2 &lt;= ((!Q3)&amp;&amp;Q4;&amp;&amp;(!x_in))||(Q1&amp;&amp;Q2;&amp;&amp;(!Q3)&amp;&amp;(!Q4)&amp;&amp;x_in);
    Q3 &lt;= Q1&amp;&amp;Q2;&amp;&amp;(!Q3)&amp;&amp;(x_in);
    Q4 &lt;= (Q1&amp;&amp;Q2;&amp;&amp;(x_in))||(Q1&amp;&amp;(!Q4)&amp;&amp;(!x_in))||((!Q1)&amp;&amp;(!Q2)&amp;&amp;(Q4)&amp;&amp;(!x_in))||((!Q1)&amp;&amp;(!Q2)&amp;&amp;(x_in))||((!Q1)&amp;&amp;(!Q3)&amp;&amp;Q4;&amp;&amp;x_in)||(Q1&amp;&amp;Q2;&amp;&amp;(!Q4)&amp;&amp;x_in);

  always @(x_in or Q1 or Q2 or Q3 or Q4)
  y_out &lt;= Q3||(Q2&amp;&amp;(!Q4)&amp;&amp;x_in);
endmodule


On compiling the code, I get the following errors. 

mini_project.v:8: syntax error
mini_project.v:8: error: Invalid module instantiation
mini_project.v:9: error: Invalid module instantiation
mini_project.v:10: error: Invalid module instantiation


I can't make out anything of the error message. Can someone please explain the error message and suggest how to correct it ?","You are missing begin and end keywords in your always block.  The code thinks that you are trying to instantiate a module rather than do signal assignments.  Only the first line will be captured under the always block (the Q1 assignment).  The others will not.  Try this:

always @(posedge Clk)
begin
  Q1 &lt;= (Q1&amp;&amp;(!Q3))||((!Q1)&amp;&amp;Q2;&amp;&amp;(!Q3)&amp;&amp;(!Q4)&amp;&amp;(x_in));
  Q2 &lt;= ((!Q3)&amp;&amp;Q4;&amp;&amp;(!x_in))||(Q1&amp;&amp;Q2;&amp;&amp;(!Q3)&amp;&amp;(!Q4)&amp;&amp;x_in);
  Q3 &lt;= Q1&amp;&amp;Q2;&amp;&amp;(!Q3)&amp;&amp;(x_in);
  Q4 &lt;= (Q1&amp;&amp;Q2;&amp;&amp;(x_in))||(Q1&amp;&amp;(!Q4)&amp;&amp;(!x_in))||((!Q1)&amp;&amp;(!Q2)&amp;&amp;(Q4)&amp;&amp;(!x_in))||((!Q1)&amp;&amp;(!Q2)&amp;&amp;(x_in))||((!Q1)&amp;&amp;(!Q3)&amp;&amp;Q4;&amp;&amp;x_in)||(Q1&amp;&amp;Q2;&amp;&amp;(!Q4)&amp;&amp;x_in);
end


As a side note, this code is really really really ugly.  Is there a better way to do this??",,,,,
Controlling an LCD in VHDL on spartan 6,"I found this code which controls an LCD display of an FPGA but it can't seen to understand some of the code,  in particular this part

    type LCD_CMDS_T is array(integer range &lt;&gt;) of std_logic_vector(9 downto 0);
    constant LCD_CMDS : LCD_CMDS_T := ( 0 =&gt; ""00""&amp;X""3C"",            --Function Set
                        1 =&gt; ""00""&amp;X""0C"",                --Display ON, Cursor OFF, Blink OFF
                        2 =&gt; ""00""&amp;X""01"",                --Clear Display
                        3 =&gt; ""00""&amp;X""02"",            --return home

                        4 =&gt; ""10""&amp;X""48"",            --H 
                        5 =&gt; ""10""&amp;X""65"",            --e
                        6 =&gt; ""10""&amp;X""6C"",            --l
                        7 =&gt; ""10""&amp;X""6C"",            --l
                        8 =&gt; ""10""&amp;X""6F"",            --o
                        9 =&gt; ""10""&amp;X""20"",            --blank
                        10 =&gt; ""10""&amp;X""46"",           --F
                        11 =&gt; ""10""&amp;X""72"",           --r
                        12 =&gt; ""10""&amp;X""6F"",           --o
                        13 =&gt; ""10""&amp;X""6D"",           --m

                        14 =&gt; ""10""&amp;X""20"",           --blank

                        15 =&gt; ""10""&amp;X""44"",           --D
                        16 =&gt; ""10""&amp;X""69"",           --i
                        17 =&gt; ""10""&amp;X""67"",           --g
                        18 =&gt; ""10""&amp;X""69"",           --i
                        19 =&gt; ""10""&amp;X""6C"",           --l
                        20 =&gt; ""10""&amp;X""65"",           --e
                        21 =&gt; ""10""&amp;X""6E"",           --n
                        22 =&gt; ""10""&amp;X""74"",           --t
                        23 =&gt; ""00""&amp;X""18"");          --Shift left


signal lcd_cmd_ptr : integer range 0 to LCD_CMDS'HIGH + 1 := 0;


I understand that an array has been made to hold values of character to be displayed on the display. but i don't understand this line.

signal lcd_cmd_ptr : integer range 0 to LCD_CMDS'HIGH + 1 := 0;


Can anyone help me to understand whats done here","This signal is being created to index into the string that was created.  The constant LCD_CMDS is an array that needs to be indexed.  The signal lcd_cmd_ptr is indexing into that constant to drive the display.  It is an integer than can be from 0 to 23 in this case.

I bet somewhere there's a line that has:
    LCD_CMDS(lcd_cmd_ptr)",,,,,
here is a code for sequential multiplier. the issue with the code is that the output is not registered. How can i register the output,"module multiplier(//global inputs
          i_clk,i_rst,
          //outputs
          o_product,o_done,
          //input
          i_multiplicant,i_multiplier,i_start
          );

   //parameter declarations
   parameter MULTIPLICANT_WIDTH =5;       //width for multiplicant
   parameter MULTIPLIER_WIDTH =8;        //width for multiplier
   parameter TWOSCOMP=0;                  //'1'=signed multiplication and '0'=unsigned multiplication
   parameter PRODUCT_WIDTH =(MULTIPLICANT_WIDTH+MULTIPLIER_WIDTH);   //width of the product  
   parameter NPOWER = 6;                           //multiplier width&lt;=2**NPOWER
   parameter NULL_VECTOR_S = 32'h00000000;       //used to fill the upper part of product register with zero at the begining of multiplication
   parameter S0= 2'd0;
   parameter S1= 2'd1;
   parameter S2= 2'd2;  


   //global inputs
   input i_clk;
   input i_rst;

   //outputs
   output [PRODUCT_WIDTH-1:0] o_product;
   output             o_done;

   //input
   input [MULTIPLICANT_WIDTH-1:0] i_multiplicant;
   input [MULTIPLIER_WIDTH-1:0]   i_multiplier;
   input              i_start;      //indicates start of multiplication

   // reg and wire declarations
   reg                o_done; 
   //  reg   [PRODUCT_WIDTH-1:0] o_product;
   reg                sign_i;      //sign product
   reg [PRODUCT_WIDTH-1:0]    product_i; 
   reg [PRODUCT_WIDTH-1:0]    product_ii;
   reg [NPOWER-1:0]           count_i;    
   reg [MULTIPLICANT_WIDTH-1:0]   multiplicant_i;
   reg [MULTIPLIER_WIDTH-1:0]     multiplier_i;
   reg                add_i;
   reg                shr_i;
   reg [1:0]              state=2'b00;
   reg [1:0]              nextstate=2'b00;

   //correcting the bits for signed multiplication   

   generate
      if(TWOSCOMP==1) 
    always@(i_multiplier,i_multiplicant)
      begin  
             $display(""Testing signed numbers"");
             multiplicant_i=rectify_multcnd(i_multiplicant,TWOSCOMP); 
         multiplier_i=rectify_mulplr(i_multiplier,TWOSCOMP);
      end 
   endgenerate 
   generate
      if(TWOSCOMP==0)
    always@(i_multiplicant,i_multiplier)
      begin
         $display(""Testing unsigned numbers"");
         multiplicant_i&lt;=i_multiplicant;
         multiplier_i&lt;=i_multiplier;
      end  
   endgenerate

   //functionn to correct multiplicant bits   
   function [MULTIPLICANT_WIDTH-1:0]rectify_multcnd;    
      input [MULTIPLICANT_WIDTH-1:0]multiplicant;
      reg [MULTIPLICANT_WIDTH-1:0]  rec_v;
      input                 twoc;
      begin
     if((multiplicant[MULTIPLICANT_WIDTH-1] &amp; twoc)==1)
       rec_v=~(multiplicant);
     else
       rec_v=multiplicant;
     rectify_multcnd=(rec_v+(multiplicant[MULTIPLICANT_WIDTH-1] &amp; twoc));
      end
   endfunction
   //function to correct multipier bits            
   function [MULTIPLIER_WIDTH-1:0]rectify_mulplr;   
      input [MULTIPLIER_WIDTH-1:0]multiplier;
      reg [MULTIPLIER_WIDTH-1:0]  rec_v;
      input               twoc;
      begin
     if((multiplier[MULTIPLIER_WIDTH-1] &amp; twoc)==1)
       rec_v=~(multiplier);
     else
       rec_v=multiplier;
     rectify_mulplr=(rec_v+(multiplier[MULTIPLIER_WIDTH-1] &amp; twoc));
      end
   endfunction     

   //start of multiplication  
   always@(posedge i_clk or posedge i_rst) 
     begin
    if(i_rst==1)
      product_i&lt;=18'd0;
    else begin 
       if(i_start==1) begin 
          sign_i&lt;= i_multiplicant[MULTIPLICANT_WIDTH-1] ^ i_multiplier[MULTIPLIER_WIDTH-1]; 
          product_i &lt;= {NULL_VECTOR_S[MULTIPLICANT_WIDTH-1:0], multiplier_i}; 
       end  else if (add_i==1)
         product_i&lt;= {{1'b0, product_i[PRODUCT_WIDTH-1:MULTIPLIER_WIDTH]} + {1'b0,multiplicant_i}, product_i[MULTIPLIER_WIDTH-1:1]};
       else if (shr_i==1)
         product_i&lt;= {1'b0 , product_i[PRODUCT_WIDTH-1:1]};
    end 
     end // always@ (posedge i_clk or posedge i_rst or posedge i_start)

   //always block to transverse through the states   
   always@(posedge i_clk or posedge i_rst)
     begin
    if(i_rst==1)begin
       state&lt;=S0;
       count_i&lt;=0;
    end else begin
       state&lt;=nextstate;
       if(state==S1) begin
          count_i&lt;=count_i-1;   
       end 
       else if (state==S0)  begin 
          count_i&lt;=(MULTIPLIER_WIDTH-1);
       end
    end 
     end // always@ (posedge i_clk or posedge i_rst)

   always@(state,i_start,product_i,count_i)
     begin                                
        case (state) 
          S0 :begin 
             add_i &lt;= 0;
             shr_i &lt;= 0;
             o_done &lt;= 0;                                           
             if  (i_start==1) 
               nextstate &lt;= S1; 
             else 
               nextstate &lt;= S1;
      end 
          S1:begin
             o_done  &lt;= 0;                                           
             add_i &lt;= product_i[0]; 
             shr_i &lt;= ~product_i[0];
             if (count_i==NULL_VECTOR_S [(NPOWER-1):0])
               nextstate &lt;= S2 ; 
             else 
               nextstate &lt;= S1;      
          end              
          S2 :begin  
             o_done  &lt;= 1;                                           
             add_i &lt;= 0;
             shr_i &lt;= 0;
             nextstate &lt;= S0;
      end 
      default:begin
             o_done  &lt;= 0;                                           
             add_i &lt;= 0;
             shr_i &lt;= 0;                                           
             nextstate &lt;= S0;
          end
    endcase // case (state)     
     end // always@ (state,i_start,product_i,count_i) 

 /*assigning the outputs according to the sign*/  
   generate
      if(TWOSCOMP==1)
    always@(state,i_start,product_i,count_i)
      begin 
         if(sign_i ==1)
           product_ii &lt;=((~(product_i)) + 1); 
         else
           product_ii&lt;=product_i;
      end  
   endgenerate 

   generate
      if(TWOSCOMP==0)
    always@(state,i_start,product_i,count_i)
      begin 
         product_ii&lt;=product_i;
      end
   endgenerate 

   assign o_product= product_ii;          
endmodule // multiplier


This is the main module for which we get the output. Can some one tell me how to register the output.","lets assume the unregistered output is called out_unreg:

output reg out;

always @(posedge i_clk or posedge i_rst)
   if (i_rst)
      out &lt;= 0;
   else
      out &lt;= out_unreg;


out is the registered version of out_unreg. It's clocked by i_clk and reset to 0 by i_rst; both on rising edge.",,,,,
Does indentation matter in Verilog?,"Does indentation matter in Verilog HDL as it does in Python ?
Or is it more like C++ where all it matters is if you have correctly put the { and } blocks ?  

Edit: This is something written in my textbook:  

always @(A or B or select)
  if(select == 1) m_out = A;
  else m_out = B;


It seems here that the block is defined by indentation. Why is it so?","No, indentation doesn't matter in Verilog (as extra blanks, tabs and newlines). Instead of using indentation, it has begin and end keywords (and endmodule) to delimit blocks. So, all you need is to correctly put these keywords in place. For example:

always
 begin
   clk = 0;
   #1;
   clk = 1;
   #1;
 end


In your example, the if and else blocks, only have one statement each, so you don't need to use begin/end keywords (there is a similar thing in C). Also, always block only contains one if-else block, so we don't need begin/end there, either. If any of these blocks had more than 1 statement, we had to use begin/end. For example:

always @(A or B or select)
  if(select == 1) m_out = A;
  else 
    begin
        m_out = B;
        m_out_2 = A;
    end
",,,,,
Generate NGC for custom VHDL module in IPCore Xilinx,"I am trying to implement a custom IPCore for the Zedboard. In my User_Logic I am including a component (My_Module) from the VHDL module (My_Module.vhd) which I wrote as part of the ISE project. But when I come to generate the bitstream for my design in PlanAhead it asks for the My_Module.ngc as if it is treating it as a blackbox. I though the NGC was only required when using CoreGen IPCores, but it seems it also wants it for any VHDL module included as I guess this is a 'black box'. 

The issue is how do I create a NGC file from the VHDL for this module, which is part of an ISE project. As I can't find any function in ISE that allows you to just generate the netlist for one VHDL module. Or can I export this module out into a separate ISE project and then synthesise it to get the .ngc? 

Many thanks
Sam","So the answer is to generate the NGC files by making the modules you want ""the top module"" you can then run the synthesis to generate the individual NGC. Then proceed as normal when adding IP to a PCore. So adding these NGC files to the netlist folder and modifying the BBD file and all that! 

As a note for completion to get the module working you need to set the synthesis setting ""Xilinx Specefic"" -> and disable ""add io buffers"" ",,,,,
How to place component parts on RAM on chip,"I am making some kind of cache and i am using some tables (big ones) inside entity which are composed of std_logic_vectors and i am doing it in Quartus 2 web edition. 

Everything works fine in simulation, but when i try to synthesize it its being done ONLY with latches, AND and OR components. 

Is there any way to specify Quartus to use memory modules for those tables instead of these combination elements?  Or maybe something can be done from VHDL code itself. 

library ieee;
use ieee.std_logic_1164.all;

package UTIL_PACK is
    type matrix16x8 is array (0 to 15) of std_logic_vector(0 to 7);
    type matrix2p4x8 is array (0 to 2**4) of matrix16x8;
end package;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.util_pack.all;

entity  RAM16B is

    port(
        signal RD: in std_logic;
        signal WR: in std_logic;
        signal CLK: in std_logic;
        signal A: in std_logic_vector(7 downto 0);
        signal D: inout matrix16x8;
        signal FC: out std_logic 
    );

end entity ;

architecture RAM16B_IMPL of RAM16B is
    signal memory: matrix2p4x8 := ((others =&gt; (others =&gt; (others =&gt; 'Z')))); 
begin 

run:process(clk)is
    variable slot:integer range 0 to 15 :=0;
    begin
        if(clk='1') then
            slot := TO_INTEGER(unsigned(A)) rem 16;
            if(rd = '1')then
                FC&lt;='0';
                for i in 0 to 3 loop
                    D(i) &lt;= memory(i)(slot);
                end loop;
                FC&lt;='1';
            elsif(wr = '1')then
                FC&lt;='0';
                for i in 0 to 3 loop
                    memory(i)(slot) &lt;= D(i);
                end loop;
                FC&lt;='1';
            else 
                FC &lt;= 'Z';
                D &lt;= ( others =&gt; ( others =&gt; 'Z' ));
            end if;
        else
            FC &lt;= 'Z';
            D &lt;= ( others =&gt; ( others =&gt; 'Z' ));
        end if;
    end process;

end architecture RAM16B_IMPL;


RAM consists of 16 blocks of memory, each block is 16 bytes. I am trying to read more data parallely so I am reading/writing 16 bytes of data per cycle. Slot defines block in which reading/writing is being done.","If you really want to make sure you use the hard memory blocks, you should either use the mega-function wizard to craft a custom ram component, or directly instantiate an altsyncram component from the library and use the generics to configure it how you want (this can be tricky if you're not extremely familiar with the options).  This causes porting issues, but any time you infer ram you generally have porting issues anyway.  Using a custom library component just makes it very obvious and easy to identify where you might have problems if you ever do need to migrate to something else.

As for your specific implementation, there's no way you're going to get latches automatically migrated into the hard ram blocks which are edge driven devices.  Use rising_edge(clk) instead of clk='1' in your process to fix this.

Also, there is no support for tri-state operation internal to the chip, you need independent data in and data out ports.  You are getting lots of discrete logic because and &amp; or gates are being used to emulate a tri-state bus (and because of the latch issue, above).",,,,,
How to convert decimal to IEEE double precision floating point binary in Matlab?,"I am trying to generate an MIF file for FPGA synthesis and I am programming in Matlab to do it.

I want numbers ranging from -1 to 1 (-.9,-.8,-.7...1) in IEEE standard double precision floating point so that I can write it onto an MIF file an use in Verilog. Are there any Matlab functions to do this in an easy way? Thanks for any suggestion in advance. ","Try this:

oldFormat = get(0,'Format');
format('hex'); display( -1:0.1:1 );
format(oldFormat);


Only the middle line is important.  The other two just put your format back to what it was before ('short' by default).  I don't know for certain that the output conforms to IEEE, but I suspect it will.  According to the documentation this will display a ""Hexadecimal representation of a binary double-precision number.""

If you want to save them as strings you could print later use sprintf with format %bx:

x = -1:0.1:1;
for i = 1:length(x)
    vals{i,1} = x(i);
    vals{i,2} = sprintf('%bx',x(i));
    vals{i,3} = dec2bin(hex2dec(sprintf('%bx',x(i))),64);
end
display(vals(:,[1 2]));
display(vals(:,3));
",,,,,
Add a constant to an std_logic_vector,"I have an input signal which is an std_logic_vector and holds an address. I use it to read from the memory, I need to read 500 bits, but since my memory data bus is only 256 bit wide, I need to read two consecutive chunks of 256 bit. To do this I want to read the first time from the address stored in the signal, and the second time from the address 256 bits (32 Bytes) after the address stored. How do I add a constant number to an std_logic_vector:

ADRESS  : in std_logic_vector (0 to 31);

--code

--read first word:
dfmc_DDR2Interface_address &lt;= ADRESS;
dfmc_DDR2Interface_read &lt;= '1';

-- more code

--read second word (what I want to do)
dfmc_DDR2Interface_address &lt;= ADRESS+32;
dfmc_DDR2Interface_read &lt;= '1';
","The easy way out is to use the numeric_std_unsigned package:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std_unsigned.all;  -- if you add this...

entity add_integer_literal_to_slv_signal is
    port (
        address: in std_logic_vector(0 to 31);
        dfmc_DDR2Interface_address: out std_logic_vector (0 to 31);
        dfmc_DDR2Interface_read: out std_logic
    );
end;

architecture example of add_integer_literal_to_slv_signal is
begin
    --read first word:
    dfmc_DDR2Interface_address &lt;= address;
    dfmc_DDR2Interface_read &lt;= '1';

    -- more code

    --read second word (what I want to do)
    dfmc_DDR2Interface_address &lt;= address + 256; -- ...this will work out of the box!
    dfmc_DDR2Interface_read &lt;= '1';
end;


For the record, you should take a proper look into the numeric_std package. @JimLewis has a nice roundup on VHDL 2008 arithmetic:
http://www.gstitt.ece.ufl.edu/vhdl/refs/vhdl_math_tricks_mapld_2003.pdf",,,,,
ALU + Shift Reg,"I have to make a 8-bit ALU which is connected  to a shift register. I think this is the code for a ALU but what is the best way to connect it too 8-bit shift register with a reset and clock? Im not sure how to use an internal signal to connect these two components, should they both have separate 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;              -- Calling libary's to be used
use IEEE.NUMERIC_STD.ALL;

entity lu is
port(   Clk : in std_logic;                -- The clock signal
        A : in signed(7 downto 0);         -- The A Input
        B : in signed(7 downto 0);         -- The B Input
        OPCODE : in unsigned(2 downto 0);  -- Op code entered into ALU
        RES :in  std_logic;                -- The reset pin
        Q : out signed(7 downto 0)         -- The Output of LU
        );
end lu;                                    -- End Entity


architecture Behavioral of lu is

signal Reg1,Reg2,Reg3 : signed(7 downto 0) := (others =&gt; '0'); --The signal declaration 

begin

Reg1 &lt;= A;        -- Linking Reg1 Signal to Input A
Reg2 &lt;= B;        -- Linking Reg2 Signal to Input B
Q &lt;= Reg3;        -- Linking Output Q to Signal Reg3

process(Clk)

begin

    if(rising_edge(Clk)) then -- Calculate at the positive edge of clk
        case OPCODE is

            when ""000"" =&gt; 
                Reg3 &lt;= Reg1 + Reg2;    -- Output is = to addition

            when ""001"" =&gt; 
                Reg3 &lt;= Reg1 - Reg2;    -- Output is = to subtraction

            when ""010"" =&gt; 
                Reg3 &lt;= not Reg1;       -- Output is = to NOT gate

            when ""011"" =&gt; 
                Reg3 &lt;= Reg1 nand Reg2; -- Output is = to NAND gate 

            when ""100"" =&gt; 
                Reg3 &lt;= Reg1 nor Reg2;  -- Output is = to NOR gate  

            when ""101"" =&gt; 
                Reg3 &lt;= Reg1 and Reg2;  -- Output is = to AND gate

            when ""110"" =&gt; 
                Reg3 &lt;= Reg1 or Reg2;   -- Output is = to OR gate 

            when ""111"" =&gt; 
                Reg3 &lt;= Reg1 xor Reg2;  -- Output is = to XOR gate  


            when others =&gt;              -- If anyother Input Outputs nothing
                NULL;

        end case;       
    end if;

end process;    

end Behavioral;
","Assuming you mean to add logical operations to the ALU code provided, you need to make two changes:

1) In the ports list, increase the width of your opcode signal so that you can add new opcode values:

    OPCODE: in unsigned(3 downto 0); -- Operation selection for the ALU


2) In your case statement, simply add the new conditions and the code to perform the logical operations:

    case OPCODE is
        ...

        when ""1000"" =&gt;
            Reg3 &lt;= Reg1 srl to_integer(Reg2);  -- Reg3 &lt;= Reg1 shifted Reg2 bits to the right
        when ""1001"" =&gt;
            Reg3 &lt;= Reg1 sll to_integer(Reg2);  -- Reg3 &lt;= Reg1 shifted Reg2 bits to the left
        when ""1010"" =&gt;
            Reg3 &lt;= Reg1 ror to_integer(Reg2);  -- Reg3 &lt;= Reg1 rotated Reg2 bits to the right
        when ""1011"" =&gt;
            Reg3 &lt;= Reg1 rol to_integer(Reg2);  -- Reg3 &lt;= Reg1 rotated Reg2 bits to the right
        when others =&gt;
            Reg3 &lt;= (others =&gt; '0');
    end case;
",,,,,
4bit multiplier in verilog without multiplication operator,"I'm trying to write a Verilog module that multiplies two 4bit inputs, without using * operator, but I get some errors:

module multiplier(
            output[7:0] prod,
            input[3:0] a,
            input[3:0] b);

            reg [7:0] result=8'h00;

            always @(*)
            begin
                for(i=0;i&lt;4;i=i+1)
                begin
                    if((b&amp;(1&lt;&lt;&lt;i))!=0)
                    begin
                        result = result+(a&lt;&lt;&lt;i);
                    end

                end
            end
            assign prod = result;
endmodule


Errors:

[Synth 8-2715] syntax error near = 

[Synth 8-2715] syntax error near = 

[Synth 8-993] result is an unknown type 

[Common 17-69] Command failed: Vivado Synthesis failed



What am I doing wrong?



EDIT:
I modified the code, now i get:
[Synth 8-1031] i is not declared","reg [7:0] result=16'h00;


Should be 

reg [7:0] result=8'h00;
",,,,,
Inferring BRAM with unused addresses efficiently,"What is a correct way to infer a RAM with some unused higher addresses (using block RAMs)?
Using the code below (default values for generics, Xilinx synth and map) I get a RAM sized the same as if depth was set to 2**ADDRWIDTH:  

entity foo is
    generic (
        DATAWIDTH : positive := 8;
        DATADEPTH : positive := 5000;
        ADDRWIDTH : positive := 13
    );
    port (
        clk_a  : in std_logic;
        we_a   : in std_logic;
        addr_a : in std_logic_vector(ADDRWIDTH-1 downto 0);
        di_a   : in std_logic_vector(DATAWIDTH-1 downto 0);
        do_a   : out std_logic_vector(DATAWIDTH-1 downto 0)
    );
end foo;

architecture bar of foo is
    type myram_type is array (DATADEPTH-1 downto 0) of std_logic_vector(DATAWIDTH-1 downto 0); --! type for ram content
    shared variable myram : myram_type; --! ram
begin
    process (clk_a)
    begin
        if rising_edge(clk_a) then
            if we_a = '1' then
                myram(conv_integer(addr_a)) := di_a;
            end if;
            do_a &lt;= myram(conv_integer(addr_a));
        end if;
    end process;
end bar;


For example, I want a RAM with DATAWIDTH = 8 and DATADEPTH = 5000, so the address has to be ADDRWIDTH = 13 because ADDRWIDTH = 12would only allow to address 4096 RAM locations. Lets assume one block RAM ressource on my FPGA can hold 8192 bits.
If I handcoded this I required 5000*8/8192 rounded upwards = 5 block RAM ressources.
However, with the code above, synthesis and map of Xilinx results in 8 block RAM ressources being used, because thats what can be addressed by 13 bit wide addresses...
Nontheless, this is not really efficient use of ressources since 3 of the 8 block RAMs will never be used.
I tried to check if the address at the input is larger than DATADEPTH and then assign don't cares for the data, but that results in the whole ram being implemented as distributed RAM / LUTRAM.
Am I missing something important or do I have to use one big ugly generate for this?","The principle of separate address bus width (ADDRWIDTH) and number of RAM
entries (DATADEPTH) is fine, and would give the synthesis tool freedom to
implement the design without using more RAM bits than required.

The reason that you may see more RAM bits used than minimum required, is that
the synthesis tool may choose an implementation that uses more internal RAM
primitives than the absolute minimum, which will usually occur if the there are
plenty of free RAM primitives or if so required in order to close timing.

If you try to experiment with the settings of DATAWIDTH, DATADEPTH, and
ADDRWIDTH, you will see that the synthesis tool does indeed use fewer internal
RAM primitives than what a simple rounding up of DATADEPTH to new 2 ** N would
require.

Using DATAWIDTH = 72, DATADEPTH = 17 * 1024, and ADDRWIDTH = 16 requires a
minimum of 72 * 17 Kib = 1224 Kib.  In one synthesis trial, this can fit into
76 RAMB16 of a Spartan6, thus total of 76 * 18 Kib = 1368 Kib.  Figure from
synthesis is below.



If DATADEPTH was rounded to nearest 2 * boundary it would be 32 * 1024, thus 
requiring 72 * 32 Kib = 2304 Kib.  So the Xilinx synthesis tool does make an 
intelligent fit.

By the way then a signal should be used for RAM, and not a shared variable,
since I expect that a shared variable may cause problems in some synthesis
tools.

Suggestion for code, including use clauses:

library ieee;
use ieee.std_logic_1164.all;

entity foo is
  generic (
    DATAWIDTH : positive := 72;
    DATADEPTH : positive := 17 * 1024;
    ADDRWIDTH : positive := 16
    );
  port (
    clk_a  : in  std_logic;
    we_a   : in  std_logic;
    addr_a : in  std_logic_vector(ADDRWIDTH-1 downto 0);
    di_a   : in  std_logic_vector(DATAWIDTH-1 downto 0);
    do_a   : out std_logic_vector(DATAWIDTH-1 downto 0)
    );
end foo;

library ieee;
use ieee.std_logic_unsigned.all;

architecture bar of foo is
  type myram_type is array (DATADEPTH-1 downto 0) of std_logic_vector(DATAWIDTH-1 downto 0);  --! type for ram content
  signal myram : myram_type;                                                                  --! ram
begin
  process (clk_a)
  begin
    if rising_edge(clk_a) then
      if we_a = '1' then
        myram(conv_integer(addr_a)) &lt;= di_a;
      end if;
      do_a &lt;= myram(conv_integer(addr_a));
    end if;
  end process;
end bar;
",,,,,
Signal not changing state in iSim,"I'm trying to build a simple pulse generator for a CPLD in VHDL. I have a series of simple if statements that should perform certain tasks depending on the input state of a bus connected to the module.

entity pulse_gen is
Port ( CLK : in  STD_LOGIC;
       pulse_sel_in : in  STD_LOGIC_VECTOR (2 downto 0);
       pulse_r : in  STD_LOGIC;
       pulse_s : inout  STD_LOGIC);
end pulse_gen; 

architecture Behavioral of pulse_gen is

signal pulse_sel: std_logic_vector (2 downto 0);
signal pulse_count: integer;
signal pulse_length: integer range 0 to 100;
signal pulse_a: std_logic;

begin

pulse_sel &lt;= pulse_sel_in;

pulse: process(CLK) is
begin
    if(pulse_sel &gt; ""000"" and pulse_a = '0') then
        pulse_s &lt;= '1';
        pulse_a &lt;= '1';
    end if;

    if(pulse_a = '1' and pulse_count &lt; pulse_length) then
        pulse_count &lt;= pulse_count + 1;
    end if;

    if(pulse_a = '1' and pulse_count = pulse_length) then
        pulse_s &lt;= '0';
        pulse_a &lt;= '0';
        pulse_count &lt;= 0;
    end if;
end process;

set_max: process(CLK) is
begin
if (CLK'event) then
    case pulse_sel is
        when ""001"" =&gt; pulse_length &lt;= 1;
        when ""010"" =&gt; pulse_length &lt;= 10;
        when ""011"" =&gt; pulse_length &lt;= 100;
        when others =&gt; null;
    end case;
end if;
end process;

end Behavioral;


When running this module in iSim, forcing the _pulse_s_ bus to anything but 000 should trigger the first if statement in the pulse process, which it does. However, in the simulation, the _pulse_a_ signal is never set to logic high. Now I have spent hours writing this module in different ways, but I have absolutely no idea why this doesn't happen. I'm relatively new to VHDL, so I wonder if there's some kind of syntax or procedural error that I'm just completely missing. Any ideas?","@Philippe is correct.  You need to assign pulse_a to some value, 0 or 1 when you define the signal.  Add this: signal pulse_a: std_logic := '0'; and it will work.  

You said that you're forcing it low in iSim.  Well guess what?  When you force it low, it stays low!  So your code won't be able to change it!

EDIT: You should also be assigning pulse_count to some initial value.",,,,,
"How to solve a combinatorial logic with an output feeding back to the input, forming a loop?","I have this warnig in my code for a FSM:

WARNING:Xst:2170 - Unit P22_MustangSecuentialTailLight_Structural : the following signal(s) form a combinatorial loop: Lights&lt;5&gt;, U1/next_state_cmp_eq0000, next_state_int&lt;0&gt;, pres_state_int&lt;0&gt;.

WARNING:Xst:2170 - Unit P22_MustangSecuentialTailLight_Structural : the following signal(s) form a combinatorial loop: Lights&lt;4&gt;, next_state_int&lt;1&gt;, pres_state_int&lt;1&gt;.

WARNING:Xst:2170 - Unit P22_MustangSecuentialTailLight_Structural : the following signal(s) form a combinatorial loop: next_state_int&lt;2&gt;, U1/next_state_cmp_eq0003, Lights&lt;3&gt;, pres_state_int&lt;2&gt;.

WARNING:Xst:2170 - Unit P22_MustangSecuentialTailLight_Structural : the following signal(s) form a combinatorial loop: next_state_int&lt;3&gt;, pres_state_int&lt;4&gt;, U1/next_state_cmp_eq0013, pres_state_int&lt;3&gt;, Lights&lt;2&gt;, next_state_int&lt;4&gt;.


Its for a loop made in the code, the image of my diagram

But that enbedded signal(pres_state_int) is necessary for update the next state logic block. The code: 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use work.States.all;

entity P22_MustangSecuentialTailLight_Structural is
    Port  ( Lturn     : in   STD_LOGIC;
           Rturn     : in   STD_LOGIC;
           Hazard    : in   STD_LOGIC;
           Rst       : in   STD_LOGIC;
              Break     : in   STD_LOGIC;
           Clk100MHz : in   STD_LOGIC;
           Lights    : out  STD_LOGIC_VECTOR (5 downto 0));
end P22_MustangSecuentialTailLight_Structural;

architecture Behavioral of P22_MustangSecuentialTailLight_Structural is

    component NextStateLogic
        port ( 
                BLRH       : in   STD_LOGIC_VECTOR (3 downto 0); 
                pres_state : in   STD_LOGIC_VECTOR (4 downto 0);
                next_state : out  STD_LOGIC_VECTOR (4 downto 0));
        end component;

    component CurrentStateRegister
        port ( 
                pres_state_b : out   STD_LOGIC_VECTOR (4 downto 0);
                next_state_b : in  STD_LOGIC_VECTOR (4 downto 0);
                Rst          : in STD_LOGIC;
                Clk          : in STD_LOGIC );
        end component;

    component OutputLogic
        port ( 
                pres_state_c : in   STD_LOGIC_VECTOR (4 downto 0);
                Lights     : out  STD_LOGIC_VECTOR (5 downto 0));
        end component;  

    component Clk1Hz
        port (
              Rst       : in    STD_LOGIC;
           Clk_in    : in    STD_LOGIC;
           Clk_out   : out   STD_LOGIC);
    end component;

    --Embedded signal declaration
    signal LRH_int        : STD_LOGIC_VECTOR (3 downto 0);
    signal next_state_int : state_values := ST0;
    signal pres_state_int : state_values := ST0;
    signal Clk1Hz_int     : STD_LOGIC;

    begin 
    LRH_int &lt;= Break &amp; Lturn &amp; Rturn &amp; Hazard;


    U1 : NextStateLogic 
    port map(
        BLRH       =&gt; LRH_int,
        pres_state =&gt; pres_state_int,
        next_state =&gt; next_state_int
        );

    U2 : CurrentStateRegister 
    port map(
        pres_state_b =&gt; pres_state_int,
        next_state_b =&gt; next_state_int,
        Rst =&gt; Rst,
        Clk =&gt; Clk1Hz_int
        );

    U3 : OutputLogic 
    port map(
        pres_state_c =&gt; pres_state_int,
        Lights     =&gt; Lights
        );

    U4 : Clk1Hz
    port map(
              Rst      =&gt; Rst,
           Clk_in   =&gt; Clk100MHz,
           Clk_out  =&gt; Clk1Hz_int
        );      

end Behavioral;


Next is the package use for encoding the code:

library IEEE;
use IEEE.STD_LOGIC_1164.all;

package States is

      subtype state_values is std_logic_vector(4 downto 0);
  constant ST0: state_values := ""00000"";
  constant ST1: state_values := ""00001""; 
  constant ST2: state_values := ""00010"";
  constant ST3: state_values := ""00011"";
  constant ST4: state_values := ""00100"";
  constant ST5: state_values := ""00101"";
  constant ST6: state_values := ""00110"";
  constant ST7: state_values := ""00111"";
  constant ST8: state_values := ""01000"";
  constant ST9: state_values := ""01001"";
  constant ST10: state_values := ""01010"";
  constant ST11: state_values := ""01011"";
  constant ST12: state_values := ""01100"";
  constant ST13: state_values := ""01101"";
  constant ST14: state_values := ""01110"";
  constant ST15: state_values := ""01111"";
  constant ST16: state_values := ""10000"";
  signal pres_state, next_state: state_values;


end States;


NextStateLogic component code: 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use work.States.all;


entity NextStateLogic is
            Port(   BLRH       : in   STD_LOGIC_VECTOR (3 downto 0); 
                pres_state : in   STD_LOGIC_VECTOR (4 downto 0);
                next_state : out  STD_LOGIC_VECTOR (4 downto 0));
end NextStateLogic;

architecture NextStateLogicl of NextStateLogic is

begin 

FSM: process (pres_state, BLRH)
  begin
    case pres_state is

      when ""00000"" =&gt; 
        case BLRH is
          when ""0000""  =&gt; next_state &lt;= ""00000"";--ST0; -- All off
          when ""0010""  =&gt; next_state &lt;= ""00100"";--ST4; -- Right Turn
          when ""0100""  =&gt; next_state &lt;= ""00111"";--ST7; -- Left Turn
             when ""0110""  =&gt; next_state &lt;= ""00101"";--ST5; -- All off
          when others  =&gt; next_state &lt;= ""00001"";--ST1; -- Hazard
        end case;
      when ""00001""         =&gt; next_state &lt;= ""00010"";--ST2;
        when ""00010""         =&gt; next_state &lt;= ""00011"";
        when ""00011""         =&gt; 
            case BLRH is
          when ""1000""  =&gt; next_state &lt;= ""00011""; -- Break
          when ""1110""  =&gt; next_state &lt;= ""00011""; -- 
          when ""1010""  =&gt; next_state &lt;= ""01101""; -- Right Turn &amp; Break
             when ""1100""  =&gt; next_state &lt;= ""01010""; -- Left Turn &amp; Break
          when others  =&gt; next_state &lt;= ""00000""; -- Hazard
        end case;
      when ""00100""         =&gt; next_state &lt;= ""00101"";
      when ""00101""         =&gt; next_state &lt;= ""00110"";
      when ""00110""         =&gt; next_state &lt;= ""00000"";
      when ""00111""         =&gt; next_state &lt;= ""01000"";
      when ""01000""         =&gt; next_state &lt;= ""01001"";    
      when ""01001""         =&gt; next_state &lt;= ""01010"";
        when ""01010""        =&gt; next_state &lt;= ""01011"";
        when ""01011""        =&gt; next_state &lt;= ""01100"";
        when ""01100""        =&gt; 
            case BLRH is
          when ""1100""  =&gt; next_state &lt;= ""01111""; -- Right Turn &amp; Break
          when ""1010""  =&gt; next_state &lt;= ""10000""; -- Left Turn &amp; Break
          when others  =&gt; next_state &lt;= ""00000""; 
        end case;
        when ""01101""        =&gt; next_state &lt;= ""01110"";
        when ""01110""        =&gt; next_state &lt;= ""01100"";
        when ""01111""        =&gt; next_state &lt;= ""01010"";
        when ""10000""        =&gt; next_state &lt;= ""01101"";

 -- Include when others to avoid latches  
      when others      =&gt; next_state &lt;= ""00000"";
    end case;
  end process FSM;




end NextStateLogicl;


CurrentStateRegister component code:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity CurrentStateRegister is
            Port( 
                pres_state_b : out   STD_LOGIC_VECTOR (4 downto 0);
                next_state_b : in  STD_LOGIC_VECTOR (4 downto 0);
                Rst          : in STD_LOGIC;
                Clk          : in STD_LOGIC
                );
end CurrentStateRegister;

architecture CurrentStateRegister of CurrentStateRegister is

begin

StateReg: process (Clk,Rst,next_state_b)
  begin
    if (Rst = '1') then 
      pres_state_b &lt;= ""00000"";
    elsif Clk = '1' then
      pres_state_b &lt;= next_state_b;
        else
        pres_state_b&lt;= ""00000"";
    end if;
  end process StateReg;




end CurrentStateRegister;


OutputLogic component code: 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity OutputLogic is
Port( 
                pres_state_c : in   STD_LOGIC_VECTOR (4 downto 0);
                Lights     : out  STD_LOGIC_VECTOR (5 downto 0));

end OutputLogic;

architecture OutputLogic of OutputLogic is

begin 

Outputs: process (pres_state_c)
  begin
    case pres_state_c is

      when ""00000"" =&gt; Lights &lt;= ""000000"";
        ----------------------------------------------- Hazard
        when ""00001"" =&gt; Lights &lt;= ""001100"";
      when ""00010"" =&gt; Lights &lt;= ""011110"";
      when ""00011"" =&gt; Lights &lt;= ""111111"";
      -----------------------------------------------   Right Turn  
      when ""00100"" =&gt; Lights &lt;= ""000100"";
      when ""00101"" =&gt; Lights &lt;= ""000110"";
      when ""00110"" =&gt; Lights &lt;= ""000111"";
        ----------------------------------------------- Left Turn
      when ""00111"" =&gt; Lights &lt;= ""001000"";
      when ""01000"" =&gt; Lights &lt;= ""011000"";
      when ""01001"" =&gt; Lights &lt;= ""111000"";
        ----------------------------------------------- Right Turn &amp; Break
        when ""01010"" =&gt; Lights &lt;= ""001111"";
      when ""01011"" =&gt; Lights &lt;= ""011111"";
        -----------------------------------------------
      when ""01111"" =&gt; Lights &lt;= ""000111"";
        when ""01100"" =&gt; Lights &lt;= ""111111""; -- Common Case
        when ""10000"" =&gt; Lights &lt;= ""111000"";
        ----------------------------------------------- Left Turn &amp; Break
      when ""01101"" =&gt; Lights &lt;= ""111100"";
      when ""01110"" =&gt; Lights &lt;= ""111110"";

      when others =&gt; Lights &lt;= ""000000"";
   end case;
  end process Outputs;



end OutputLogic;


And finally the Clk1Hz component code: 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity Clk1Hz is

        port (
              Rst       : in    STD_LOGIC;
           Clk_in    : in    STD_LOGIC;
           Clk_out   : out   STD_LOGIC);
end Clk1Hz;

architecture Clk1Hz of Clk1Hz is
-- Definition of embedded signals and constants
  -- Constants used for frequency division
  constant Fosc    : integer := 100000000;   --Frecuencia del oscilador de tabletas NEXYS 3
  constant Fdiv    : integer := 5;           --Frecuencia deseada del divisor
  constant CtaMax  : integer := Fosc / Fdiv; --Cuenta maxima a la que hay que llegar
  -- Signal used by the frequency division process
  signal Cont      : integer range 0 to CtaMax;

begin
  -- Frequency divider to obtain a 2Hz signal from
  -- the 100 MHz board oscillator
  FreqDiv: process (Rst, Clk_in)
  begin
    if Rst = '1' then
       Cont &lt;= 0;
     elsif (rising_edge(Clk_in)) then
       if Cont = CtaMax - 1 then
        Cont      &lt;= 0;
        Clk_out    &lt;= '1';
      else        
         Cont      &lt;= Cont + 1;
          Clk_out    &lt;= '0';
        end if;
    end if;
  end process FreqDiv;




end Clk1Hz;


Iam missing something?? Is there another way to instanciate the component NextStateLogic?

Thanks:D","In CurrentStateRegister, you need to test for rising_edge(clk) instead of clk = '1'. Your current code infers a latch instead of a register, causing a loop whenever clk = '1'. Also, lose the final else in the ControlStateRegister module:

StateReg: process (Clk,Rst,next_state_b)
  begin
    if (Rst = '1') then 
      pres_state_b &lt;= ""00000"";
    elsif (rising_edge(Clk)) then
      pres_state_b &lt;= next_state_b;
    end if;
  end process StateReg;
",,,,,
VHDL Full adder test bench output U,"I'm a vhdl newbie.i wrote codings for a full adder using only AND and OR gates. I created a testbench to test my code and had it configured to stimulate all of eight logic combinations for A,B and Cin. when i run the simulation wave forms are correct for the inputs but the sum out put(H in my case) shows just ""U"".any ideas please.

library ieee;
use ieee.std_logic_1164.all;

--This program describes behaviour of a full adder constructed using
-- AND and OR gates. It employs component method which describes behaviour of
--AND,OR and NOT gates and use them to build the final object


--Entity description of the full adder
  entity full_add is
  port (a,b,c:IN BIT; h:OUT BIT);
  end entity full_add;

--Description the 3 input And Gate

  entity And2 is
  port (j,k,l:in BIT; m:out BIT);
  end entity And2;

  architecture ex1 of And2 is
  begin
  m &lt;= (j AND k AND l);
  end architecture ex1;

  --Description of the four input OR gate

   entity Or2 is
   port (d,e,f,g:IN BIT; h:OUT BIT);
   end entity Or2;

  architecture ex1 of Or2 is
  begin
  h &lt;= (d or e or f or g);
  end architecture ex1;

--Description of the NOT gate

 entity Not1 is
 port(x:in BIT; y:out BIT);
 end entity Not1;

 architecture ex1 of Not1 is
 begin
 y &lt;= not x;
 end architecture ex1;

--Components and wiring description

 architecture netlist of full_add is
 signal s,u,v,s2,u2,v2,w2:BIT;
 begin
 g1:entity WORK.Not1(ex1) port map(a,s);
 g2:entity WORK.Not1(ex1) port map(b,u);
 g3:entity WORK.Not1(ex1) port map(c,v);
 g4:entity WORK.And2(ex1) port map(s,u,c,s2);
 g5:entity WORK.And2(ex1) port map(s,b,v,u2);
 g6:entity WORK.And2(ex1) port map(a,u,v,v2);
 g7:entity WORK.And2(ex1) port map(a,b,v,w2);
 g8:entity WORK.Or2(ex1) port map (s2,u2,v2,w2,h);

end architecture netlist;
","You are going to have to debug the implementation : this will be quite a good exercise in using the simulator! 

You see that ""H"" has value 'U' but you don't yet know why. Trace all the drivers of H back : in the posted code I can only see one, which is derived from inputs S2, U2, V2, W2.

In the simulator, add these signals to the Wave window and re-run the simulation : is one of them stuck at 'U'? If so, trace that signal back to find out why. If they all have valid values, that points to something else driving 'U' onto signal H. 

Learn the ""Drivers"" command for your simulator (i.e. find and read the manual!) to identify all the signals driving H, and their values at a given time. There may be a driver in the (hidden to us) testbench. If so, change its driving value (perhaps with an H &lt;= 'Z';"" assignment) and re-run the simulation.

Essentially : learn and practice basic simulation debugging skills : one of these skills is likely to resolve the problem. And  edit the question with what you have learned from them : if the problem persists, these results will point closer to it.",,,,,
Latch duplication in technology schema (vhdl),"Please note, this is a study question.  

I have to describe a simple d-latch in vhdl, and then synthesize it. The problem is that it is a ""unary"" d-latch, and its single input is mapped directly to its outputs (Q and nQ). You can imagine it as a classical async d-latch, where clk signal is always high. This is useless element in logic, and xilinx synthesizer in most cases gives an empty technology schema. But the reason to keep this element is, for example, creating hardware ""watermarks"", which present on the schema, but don't affect its logic.
I came up with the following code:  

entity dLatch is
  port(
    d: in std_logic;
    q: out std_logic);
end dLatch;

architecture dLatch_beh of dLatch is  
  signal o: std_logic;
begin
  latch: process(d)
  begin
    if d = '1' then
      o &lt;= '1';
    elsif d = '0' then
      o &lt;= '0';
    end if;
  end process;

  q &lt;= o;
end;


This code produce the following technology schema

link

But when I try to add nQ out port, I gain duplication of latch

entity dLatch is
  port(
    d: in std_logic;
    q, nq: out std_logic);
end dLatch;

architecture dLatch_beh of dLatch is  
  signal o: std_logic;
begin
  latch: process(d)
  begin
    if d = '1' then
      o &lt;= '1';
    elsif d = '0' then
      o &lt;= '0';
    end if;
  end process;

  q &lt;= o;
  nq &lt;= not o;
end;


Technology schema: link

I don't understand, why I am getting two completely equal latches here. I expected only one additional 'not' gate.
So my question is how to avoid the duplication of latches, or maybe some other way to solve this problem.
I use Xilinx ISE Web Pack 14.6 for synthesis.

UPD The solution is to set synthesizer's flag -register_duplication to false.",The solution is to set synthesizer's flag -register_duplication to false.,,,,,
Two input signals at the same always block,"I am working with an DE2-70 board and I am trying to use some of it's buttons as inputs. The buttons are activated at 0, and I need to check if two buttons in particular are being pressend separatly, in order to increase/decrease a number. 

I tried doing the following, where iKEY are the buttons and position is the number i am trying to modify:

reg [4:0] position;
position = 5'b0;

output wire enable = !(iKEY[3] &amp;&amp; iKEY[2]);
always @(posedge enable) begin  
    if(iKEY[3] == 0)
        position = position + 5'b00001;

    if(iKEY[2] == 0)
        position = position - 5'b00001;
end


I tried several differences of this implementation, such as tring to change the ifs conditions or changing the logic function when setting the enable signal, but I always get stuck in some problem. 
I am new to hardware logic, so maybe I am thinking in it in the wrong way

Edit:
If both buttons are pressed at the same time I expect the hardware to neither increment nor decrement the number","Summary of the chat discussion:


Missing key background information:

iKEY is 4-bit active low input. Input source is from physical buttons,
A operation should happen on a one-cold (inverse of one-hot) iKEY,
There are clocks available, such as the 50MHz iCLK_50 

Solution for operations executing unexpectedly:


Move all the all the iKEY into one always block and decode the operation with a case statement. Ex:

case(iKEY[3:0]) // one-cold, full-case
  4'b1110: /* operation 0 */
  4'b1101: /* operation 1 */
  4'b1011: /* operation 2 */
  4'b0111: /* operation 3 */
  default: /* default behavior */
endcase

If using iKEY as a clocking event, then perform a bit-wise NAND operation: wire enable = ~&amp;iKEY[3:0];
If using using the iCLK_50 clock, then add a reg to watch for button release to insure one operation per button press. Ex:

if (allow_op) begin // value from past clock event
  /* case statement defined above */
end
// value for next clock event
allow_op = &amp;iKEY[4:0]; // bit-wise AND


",,,,,
VHDL file reading program shows an error,"I was writing a vhdl code to read the image file. I converted the image file into a note pad file having 65536 lines.ie,256 X 256 pixels. Now when I am running the code I am getting a error that says:

Fatal error in ForLoop loop at C:/MentorGraphics/modeltech_6.5c/win32/test.vhd line 39
# HDL call sequence:
# Stopped at C:/MentorGraphics/modeltech_6.5c/win32/test.vhd 39 ForLoop loop


why it is happening like that.. I am attaching the code below:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use std.textio.all;

entity IMAGE_READ is
Port ( CLK : in  STD_LOGIC;
IMAGE_LOAD : IN  STD_LOGIC:='1';
IMAGE_DONE : OUT  STD_LOGIC);
end entity;

architecture Behavioral of IMAGE_READ is
type image is array (1 to 256,1 to 256) of std_logic_vector(7 downto 0);
file IMAGE_FILE:text open read_mode is ""D:\Documents\ORIGINAL IMAGE.txt"";

begin
PROCESS(CLK,ROW,COLUMN,IMAGE_LOAD)
variable LINE_NUMBER:line;
variable TEMP_PIXEL_VALUE: bit_vector(7 downto 0);
variable image_matrix:IMAGE;

BEGIN
if (clk'event and clk = '1') then 

IF(IMAGE_LOAD='1') THEN
for i in 1 to 256 loop
for j in 1 to 256 loop
    readline (IMAGE_FILE, LINE_NUMBER);           
    read (LINE_NUMBER, TEMP_PIXEL_VALUE);                 
    image_matrix(i,j) := to_stdlogicvector(TEMP_PIXEL_VALUE);
        if(i=256 and j=256) then
            TEMP_image_done:='1';
            image_done&lt;='1';
        else
            TEMP_image_done:='0';
            image_done&lt;='0';
        end if;
END LOOP;
END LOOP;
END IF;

END IF;
END PROCESS;

end Behavioral;


How to correct it?","You will have to debug the program; preferably in simulation.
Look for clues as to the error : for example, what are the values of the loop counters i and j when the error occurs? 

What is the current line of the file?
What is the previous line?
What value do you get for Temp_Pixel from the faulty line? 

and so on. 

Eventually you will see something unexpected and that will lead you to the answer.",,,,,
Filling an array with integer multiples of a signal value,"I have an array called amux, and I want to save integer multiples of signal A inside the array. The pseudocode below gives an idea:

amux(0) &lt;= ""00001101"";
amux(1) &lt;= amux(0);

....

amux(n) &lt;= amux(n-1); 


My full code looks like this:

-- n is 4 and m is 3, amux is an array, mzeros is 0's
regA: process(clk)
variable r : integer := 2**m;
begin
    if rising_edge(clk) then
        if ld_a = '1' then
            amux(0) &lt;= std_logic_vector(to_unsigned((0),n*m+m));
            amux(1) &lt;= mzeros &amp; A;

            for i in 2 to r-1 loop 
              if (i mod 2) = 0 then
                   amux(i) &lt;= amux(i/2)(n*m+m-2 downto 0) &amp; '0';
                else
                  amux(i) &lt;= std_logic_vector(unsigned(amux(i-1))+unsigned(amux(1)));
                end if;
            end loop;

        end if;
    end if;


end process regA;

My current implementation outputs all ""00000000""s, except for amux(0). What's the problem with my approach?","If we understand you correctly, the problem is that you cannot use a signal's value in a process immediately after you make an assignment to it. The assigned values will only be available after the process finishes. If this is what you intended to do, you can use a variable for that purpose. Variables have their value updated immediately.

The code example below should be close to what you want:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity array_loader is
    generic (
        N: integer := 4;
        M: integer := 3;
        DATA_WIDTH: integer := N * M + M;
        ARRAY_DEPTH: integer := 2**M
    );
    port (
        clk: in std_logic;
        ld_a: in std_logic;
        A: in unsigned(DATA_WIDTH-1 downto 0)
    );
end;

architecture rtl of array_loader is
    type amux_type is array (0 to ARRAY_DEPTH-1) of unsigned(DATA_WIDTH-1 downto 0);
    signal amux: amux_type;

begin
    regA: process(clk)
        variable multiple: unsigned(DATA_WIDTH-1 downto 0);
    begin
        if rising_edge(clk) then
            if ld_a then
                multiple := to_unsigned(0, multiple);
                amux(0) &lt;= multiple;

                for i in 1 to amux'high loop
                    multiple := multiple + A;
                    amux(i) &lt;= multiple;
                end loop;
            end if;
        end if;
    end process;
end;


Please note that the above code is valid VHDL-2008 only; in earlier versions, ld_a would have to be compared against '1' explicitly, and it wouldn't be possible to use the generic constants N and M to calculate the value of subsequent generics.",,,,,
VHDL expression is not constant,"I am writing a VHDL program on quartus II for a CYCLONE III EP3C25 FPGA and I got an issue.

Here are the important part of my program:

odata : out std_logic_vector(15 downto 0);

signal buf_data : std_logic_vector(255 downto 0);

signal nb_word : integer :=0;

Process(clk,RST)
begin
    if(RST='0') then
        nb_word&lt;=0;
    elsif(clk'event and clk='0') then
        if(Current_state_w=s2) then
            if(nb_word&lt;=X""F0"") then
                nb_word&lt;=nb_word+16;
            else
                nb_word&lt;=0;
            end if;
        end if;
    end if;
end process;

Process(clk,RST)

begin
    if(RST='0') then
        odata&lt;=(OTHERS=&gt;'0');
    elsif(clk'event and clk='0') then
            odata&lt;=buf_data(nb_word+15 downto nb_word);
    end if;
end process;


This code is compiling fine but does not do what I want then I just wanted to change :

odata&lt;=buf_data(nb_word+15 downto nb_word);


in

odata&lt;=buf_data(nb_word downto nb_word-15);


And I changed the initialisation and reset value of nb_word at 15 instead of 0.

The problem is, when I do that and I try compiling I got this error:

Error (10779): VHDL error at VL_control.vhd(99): expression is not constant


The line corresponds to the changement of the odata line.

I really can't understand why I got this error. Why is it possible to do an addition and not a substraction? 
I also tried to define another signal and to do the substraction in the signal before addressing the buffer like that:

nb_word1 := (nb_word-15);
odata&lt;=buf_data(nb_word downto nb_word1);


But I still get the same error. Where does that come from?????","You should limit nb_word to an integer range, that way the sythesis tool knows for sure that the value of nb_word - 15 can not be negative.

Also, why do you compare an integer to a bit string literal? Why not just say if nb_word &lt; 15?",,,,,
Splitting a bit array in Verilog,"I am designing a basic AES algorithm on verilog, and I need to split a 128 bits array into 16 parts each one of 8 bits.

For example (basic 8 bit example), if I receive 10111011 I need to generate 4 outputs 10 11 10 11","A double packed array works:

reg [127:0] in;
wire [15:0] [7:0] out_1 = in; // msb in entry 15
wire [0:15] [7:0] out_2 = in; // msb in entry 0


If only one byte is needed to be read at a time, it can be done Verilog-2001 or SystemVerilog as:

reg [127:0] in;
reg [3:0] idx;
wire [7:0] out = in[8*idx +: 8];
",,,,,
Cannot compile unisim code in iverilog,"I have been trying to compile ICAP_SPARTAN6.v from the unisim librabries provided by xilinx using icarus verilog.

I get the compile error below:

/opt/Xilinx/14.3/ISE_DS/ISE/verilog/src/unisims/ICAP_SPARTAN6.v:79: syntax error
/opt/Xilinx/14.3/ISE_DS/ISE/verilog/src/unisims/ICAP_SPARTAN6.v:79: error: invalid module item.


The relevent lines of code referred to is below:

  tri (weak1, strong0) done_o = p_up;//line 78
  tri (pull1, supply0) [15:0] di_t = (icap_idone == 1 &amp;&amp; WRITE == 1)? 16'bz : dix; //line 79


I would also like to note that I am not very clear how tri works exactly. I assumed that it is similar to a wire except has 3 states but the paranthesis following it does not make sense to me and that makes debugging a little harder :)
Any help would be appreciated. -Thanks","tri and wire are equivalent.

The keywords in parentheses determine drive strength, which allows switch and gate-level modeling. The rules are somewhat complex but basically a stronger signal can override a weaker one so driving a pull1 and strong0 on the same signal may result in a 0 state, rather than X or Z.

The error looks like a bug or missing feature in iverilog. Removing the vector range allows a successful compile.",,,,,
Multiplying number by ten in verilog,"How do you multiply a binary number by ten in verilog?
Is it as simple as 

reg [7:0] a,b;
reg[31:0] p;
b= 8'b00001001;
p=a*b;


Upgraded to windows 8 and my xilinx is working atm. Need to know asap for planning stage. ","Nearly - 10 in binary is 1010! For multiplying two 8-bit numbers, you'll only need 16 bits for the result, so reg [15:0] p would do. What about:

 always @( a )
     p = a * 8'd10; 


or

wire [13:0] p;
assign p = a * 4'd10;
",,,,,
"Comparing unsigned, including metavalues, to a bit pattern","I am writing a VHDL process that needs to compare an input value to zero. The input may contain metavalues ('U', 'X', 'L', 'H', etc.), in which case zero should not be asserted.

Unfortunately, ModelSim issues a warning with each comparison:

# ** Warning: NUMERIC_STD.""="": metavalue detected, returning FALSE
#    Time: 14 ns  Iteration: 1  Instance: /tb/uut


Any ideas on how to code the below in order to avoid such warnings? Turning off numeric_std warnings globally is not an option.

library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;

entity Test is
    port (
        clk               : in std_logic;
        reset             : in std_logic;

        i_in_data         : in unsigned(31 downto 0);

        o_out_zero        : out std_logic
    );
end Test;

architecture rtl of Test is
begin
    process(clk, reset) begin
        if(reset='1') then
            o_out_zero &lt;= '0';
        elsif(rising_edge(clk)) then
            if(i_in_data = (i_in_data'range=&gt;'0')) then
                o_out_zero &lt;= '1';
            else
                o_out_zero &lt;= '0';
            end if;
        end if;
    end process;
end architecture;
","If the output of o_out_zero doesn't matter in the presence of metavalues, then the useful function to_01 from numeric_std can be used to eliminate them in the comparison expression. See also to_01xz etc for similar purposes...

Replace 

if(i_in_data = (i_in_data'range=&gt;'0')) then


with

if to_01(i_in_data) = (i_in_data'range=&gt;'0') then


and it should be good.

You do know that parentheses around the boolean expressions in an if-statement are unnecessary, right? The less VHDL looks like C, the better...",,,,,
6bit ORgate Verilog,"Would it be fair to say that the next line will work as a 6bit OR gate. So, when one of the 6 bits of ""columns"" is high that the variable ""ORgate"" will be high:

 assign  ORgate = columns[0] || columns[1] || columns[2] || columns[3] || columns[4] || columns[5];
","It will, but there's a shorter way using ""reduction operators"":

 assign ORgate = |columns;
",,,,,
Visual C project in the Xilinx Microblaze,Can I embed the C code from Visual C project in the Xilinx Microblaze? I have already created the EDK design of hardware and want to import my Visual studio based design of FIR filter into the Xilinx SDK. I don't know how to do it. Is it even possible? Any tips? Thanks!,"Recently I am playing with Spartan06 from xilinx. As far as I can understand that you cannot import Visual C project to Xilinx Microblaze.

This is because you need to use a cross compiler to target the Microblaze processor. Xilinx uses the CodeSourcery's gcc to do that. That is why you need to use the SDK to compile the program for Microblaze.

To function properly in their board, you need to write correct values to correct registers ( as per your design ); that is where Xilinx C library will come handy.

Also it will be cumbersome for you to setup the Xilinx C library in Visual C.

hope this helps,
regards",,,,,
What is wrong with my partial product generator,"I'm trying to write VHDL code for a partial product generator. The code is as follows: 

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_signed.all;
use ieee.numeric_std.all;
entity boothencoder_ppg is
port(Y: in std_logic_vector(53 downto 1);
     X: in std_logic_vector(53 downto 1);
     PPG: out std_logic_vector(53 downto 1)
     );
end boothencoder_ppg;
architecture behavioral of boothencoder_ppg is
signal U, SFT, W, M, A: std_logic;
    begin
    for m in 1 to 53 loop
    U = Y(m+1) xnor Y(m);
    SFT = Y(m-1) xnor Y(m);
    W = U and SFT;
    M = SFT? X(m-1) : X(m);
    A = M xor Y(m+1);
    PPG = A nor W;
    end loop;
end behavioral;


I'm getting errors in all the lines within the loop. Perhaps I have implemented the loop incorrectly? Any help would be great.

Thanks.","The signal assignment operator in VHDL writes as:

a &lt;= b;


In addition you need either to wrap your loop in a process or to use a for...generate construct instead of a for...loop which is a sequential statement.",,,,,
Verilog: Reg is not declared,"Here is the declaration of the reg assignment 

reg [5:0]R = {bi7 ,[15:11]RGB}; //bi7 is a parameter


but at the last line of the module i get this error where it points at the same reg assignment.

ERROR:HDLCompiler:69 - ""path.v"" Line 58: &lt;R&gt; is not declared.


Can anyone help me with this , cause my whole experience with verilog is just a book :(","In verilog, you can only assign a value to a reg in always or initial blocks. You've also got the bit range for stripping bits from you RGB bus on the wrong side of the bus name.

reg [5:0] r;
always @(RGB) begin
    r = {bi7, RGB[15:11]};
end


Note that in verilog, parameter names such as bi7 in your code, are usually defined and written in UPPER CASE to make them easy to pick out.",,,,,
Arithmetic Mean,"I need to design a circuit which accepts n numbers at the input (infinite input) and calculates the average of these numbers as the output. The numbers for the input can only be of values &lt;0,15>.
I need to implement this circuit in VHDL but I cannot find the proper algorithm since I need it to design the logical schema. I understand that I will definitely need a 4bit adder and some registers to store the values. I tried to understand the problem using moving average principle but it just did not work at all. ","For input n+1, with value x, the average will be equal to (average*n+x)/(n+1) --> ... = average + (next - average)/(n+1).
From this observation a simple algorithm can be derived:


Initialize all registers to 0
Get the next input and store it in temp register
Increase count register by 1
Subtract previous average from temp register
Divide the temp register by count
Add temp to average
Go to step 2
",,,,,
Verilog while error,"I have a school project in Verilog and I am very newbie at it. A part of the program is this 

    integer x;
    assign x=1;
    **LINE 49** while(x&lt;=9)
            begin
                assign lastBitsofP=P[1:0];
                if(lastBitsofP == 2'b00 || lastBitsofP ==2'b11)
                    begin
                    rightShift r1(shiftedValue,P);
                    end
                x=x+1;
            end


but I always get this error : ""mainModule.v"" line 49 expecting 'endmodule', found 'while' , ","You need to stop coding and think about what is going on. You are modelling hardware and connections. When you write assign x = that means ""I have a wire and I want you to drive that wire with this value"". If you have a module like r1 that you want connected it must be connected always you can't go ""oh wait, if this happens just create a multiply unit for me"".

You need to instantiate your connections at the start. If you only want the right shifted value sometimes then you can have a statement like assign out = select ? shiftedValue : unshiftedValue; And then you just need to write the logic for select.

And you'll probably want a flip-flop for your output. Something like

reg [31:0] result;
always @(posedge clk)
begin
    result &lt;= out;
end
",,,,,
generate inside generate verilog + error near generate(veri - 1137),"Writing verilog code from quite a few days and one question I have is 'Can we write generate block inside generate block'? I am writing an RTL something like this:

Where 'n' is a parameter.
reg [DATA_WIDTH:0] flops [n-1:0];

generate
  if (n &gt; 0) begin
    always @(posedge clk) begin
      if (en) begin
        flops[0] &lt;= mem[addr];
      end
     end
     generate
       genvar i;
       for (i = 1; i &lt;= n ; i = i + 1) begin
         always @(posedge clk) begin
           flops[i] &lt;= flops[i-1];
         end
       end
     endgenerate
     always @(flops[n - 1])
       douta = flops[n - 1];
   else
     always @(posedge clk) begin
       if (en) begin
         primary_output = mem[addr];
       end
     end
   end
endgenerate


While compiling the above code, I am getting :

ERROR: syntax error near generate (VERI-1137)


Not sure why. Purpose of this RTL is to create an pipeline of 'n' flops at the output side of the design.

Lets say n is 2, then circuit should become :

flop1-&gt; flop2-&gt; primary output of design


flop1 and flop2 are newly created flops.","You are a long long way from where you should be.

Verilog is not a programming language; it is a hardware description language. You model hardware as a network of concurrent processes. Each process models a small bit of hardware such as a counter, a state machine, a shift-register, some combinational logic... In Verilog, each process is coded as an always block. So, one always statement never ever can appear inside another; that makes no sense.

Secondly, generate is quite a specialised statement. You use it when you want either a large number or a variable number of concurrent processes. That is not a common thing to need, so generate is not common, but is useful when required. You don't need a generate statement to implement a parameterisable shift-register. And, because an always block is a concurrent statement it sits inside a generate statement, not the other way round.

I don't know what your design intent is exactly, to I suspect this code does not do exactly what you want. However, it does implement a parameterisable shift-register of length n and width DATA_WIDTH+1 (did you really mean that?), enabled by the en input:

module N_FLOPS #(n = 2, DATA_WIDTH = 8) (input [DATA_WIDTH:0] dina, input clk, en, output [DATA_WIDTH:0] douta);

  reg [DATA_WIDTH:0] flops [n-1:0];

  always @(posedge clk)
    if (en)
      begin : SR
        integer i;
        flops[0] &lt;= dina;
        for (i = 1; i &lt;= n ; i = i + 1) 
          flops[i] &lt;= flops[i-1];
      end

  assign douta = flops[n-1];

endmodule


http://www.edaplayground.com/x/3kuY

You can see - no generate statements required. This code conforms to this template, which suffices for any sequential logic without an asynchronous reset:

always @(posedge CLOCK)  // or negedge
  begin
    // do things that occur on the rising (or falling) edge of CLOCK
    // stuff here gets synthesised to combinational logic on the D input
    // of the resulting flip-flops
  end
",,,,,
Concatenation of Array at Output Verilog,"Total noob here, just to be clear. Only about a month in to learning Verilog.

So I have some user-defined parameters, and I want to put out a concatenation of all items in an array. For instance, if the array length were static (in this case, an array of 10 12-bit items), I could certainly do something like:

    reg [11:0] array [9:0];
    output &lt;= {array[9],...,array[0]};


But what if the array length is user-defined and therefore not a static value? For instance, if I wanted two outputs like so, with length being a parameter:

    output1 &lt;= array[0];
    output2 &lt;= {array[length-1],...,array[1]};


Been banging my head against this for a minute or two and haven't found anything in my internet searches... Hope I'm being clear enough...","Let's say you have the following:

parameter NUM_ITEMS = 10;
parameter LOWER = 1;
parameter UPPER = 9;
reg [11:0] array [NUM_ITEMS-1:0];
reg [12*(NUM_ITEMS-1)-1:0] output;


The following could work:

integer i;
always@(*) begin
    for (i=0; i &lt;= UPPER; i=i+1)
        output[i*12+:12] = array[LOWER+i];
        //alternatively output [12*i+11:12*i] = array[LOWER+i];
end


Your array elements would need to be sequential, though.",,,,,
NOTSTT error: expecting a statement in verilog,"I have this simple test code(test.v) to generate an compile error.

`timescale 1ns/10ps

`define START 'h10000000;
`define WIDTH 800
`define HEIGHT 600

module test;
integer ifm_addr;
integer ifm_idx;

initial begin
    ifm_idx = 0;
    ifm_addr = `START + ifm_idx*4*`HEIGHT*`WIDTH;
end

initial begin
#1000;
$finish;
end

endmodule


when I run ncvlog test.v, I get this error and I can't figure out what's wrong.

ncvlog: 12.20-s008: (c) Copyright 1995-2013 Cadence Design Systems, Inc.
    ifm_addr = `START + ifm_idx*4*`HEIGHT*`WIDTH;
                      |
ncvlog: *E,NOTSTT (test.v,11|19): expecting a statement [9(IEEE)].
    ifm_addr = `START + ifm_idx*4*`HEIGHT*`WIDTH;
                               |
ncvlog: *E,MISEXX (test.v,11|28): expecting an '=' or '&lt;=' sign in an assignment [9.2(IEEE)].


Please help!  

EDIT : The error was because of the ; at the end of define START 'h10000000. It makes the + appear after a statement in the initial block.","You have not defined ifm_idx.

module test;
  integer ifm_addr;
  integer ifm_idx;


  initial begin
    ifm_addr = `START + ifm_idx*4*`HEIGHT*`WIDTH;
  end
",,,,,
change xilinx ise default text editor to notepad++,"I want to add custom editor to Xilinx ISE project nevigator.
How change xilinx ise default  text editor to notepad++?","For the Windows version, in Xilinx ISE 14.7 under Edit > Preferences > ISE General > Editors, select the ""Custom"" editor and set the command line syntax to:


  notepad++ $1 -n$2


Then make sure that Notepad++ is listed in your Path environment variable. It's not there by default. To add it, go to My Computer > Properties > Advanced System Settings > Environment Variables and find the Path variable under the system variables. Add the directory that contains Notepad++ to the end of the list. It's likely ""C:\Program Files (x86)\Notepad++"" if you used the default settings.",,,,,
verilog expecting a semicolon error near generate block,"It's been years I've been working with verilog but recently I'm testing something with verilog. During a ncvlog compile, I have an error for which I can't find the cause. Below is the code(not complete yet).

`include ""default.v""

module conv (
    input clr,
    input clk,
    input start_conv,
    output integer raddr,
    output integer waddr,
    input  real data_in,
    output real data_out
);

parameter NUM_CONV = `DEF_NUM_CONV;


genvar i;
generate
for (i=0; i&lt;NUM_CONV; i=i+1) begin : uconv
unit_conv inst() (
    .clr (clr),
    .clk (clk),
    .start (start_conv),
    .rreq (rreq[i]),
    .raddr (raddr[i]),
    .rdata (rdata[i]),
    .wreq (wreq[i]),
    .waddr (waddr[i]),
    .wdata (wdata[i])
);

end
endgenerate

endmodule


The error I get is like below : 

ckim@stph45:~/Neuro/convhw] ncvlog -sv conv.v
ncvlog: 12.20-s008: (c) Copyright 1995-2013 Cadence Design Systems, Inc.
unit_conv inst() (
                 |
ncvlog: *E,EXPSMC (conv.v,19|17): expecting a semicolon (';') [12.1.2][7.1(IEEE)].


Is the port mapping syntax for generated instances wrong? According to this it seems correct though... By the way, I compile with ncvlog -SV conv.v.","Consider the following:

unit_conv inst (
    .clr (clr),
    .clk (clk),
    .start (start_conv),
    .rreq (rreq[i]),
    .raddr (raddr[i]),
    .rdata (rdata[i]),
    .wreq (wreq[i]),
    .waddr (waddr[i]),
    .wdata (wdata[i])
);
",,,,,
UVM- can single driver and a single monitor be connectes to multi interfaces?,Can a single driver and a single monitor be connected to multiple interfaces?,"Yes. but not usually a good idea for re-usability. If the interfaces are required to be used together, then it may make more sense. ",,,,,
"how ""A loop"" complete in a clock","I try to find many code to reference.

But I can't find the solution for I need.

Can anyone help me find the question &amp; solution?

Thank you very much.

The question is that i need this code can variable.

ero_check_t &lt;= erosion_buf(0)(0)+erosion_buf(0)(1)+erosion_buf(0)(2)+
               erosion_buf(1)(0)+erosion_buf(1)(1)+erosion_buf(1)(2)+
               erosion_buf(2)(0)+erosion_buf(2)(1)+erosion_buf(2)(2);


like the up code(3*3) can variable to the down code(2*2).

ero_check_t &lt;= erosion_buf(0)(0)+erosion_buf(0)(1)+
               erosion_buf(1)(0)+erosion_buf(1)(1);


how can I write? Can use loop to code?

process(rst)
begin
    if rst = '0' then
        ero_check   &lt;= ""0000000000"";
        ero_check_t &lt;= ""0000000000"";
    else
        for i in 0 to array_x loop
            for j in 0 to (array_y - 1) loop
                if i = array_x then
                    if j= 0 then
                        ero_check_t  &lt;= ero_check;
                        ero_check    &lt;= ""0000000000"";
                        exit;
                    end if;
                else
                    ero_check := ero_check + erosion_buf(i)(j);
                end if;
            end loop;
        end loop;
    end if;
end process;
","The short answer is YES. The longer answer is that you might want to check your code does exactly what you want (and there are some problems with it, too). If you want combinational logic that does this:

ero_check_t &lt;= erosion_buf(0)(0)+erosion_buf(0)(1)+erosion_buf(0)(2) + ...
               erosion_buf(1)(0)+erosion_buf(1)(1)+erosion_buf(1)(2) + ...
               erosion_buf(2)(0)+erosion_buf(2)(1)+erosion_buf(2)(2) + ...
               ...


Then something like this would do the trick:

process(erosion_buf)              -- erosion_buf is the only input
  variable e :                    -- the same type as ero_check_t
begin
  e :=                            -- zero (I don't know what type ero_check_t is)
  for i in 0 to array_x-1 loop    -- assuming array_x is the LENGTH of the x dimension
    for j in 0 to array_y-1 loop  -- assuming array_y is the LENGTH of the y dimension
       e := e + erosion_buf(i)(j);                     
    end loop;
  end loop;
  ero_check_t &lt;= e;               -- drive the output signal
end process;


ero_chek is a variable. This is initialised to zero and then the nested loops do all the additions. Finally, you drive the signal ero_check_t with the contents of the variable ero_check.",,,,,
Where should I write input transaction to the scoreboard,"I have a simple dut to test.
The input is a packet, and the output is exactly the same packet.
Therefore I don't have to predict the output, and I can compare the output transaction (from the monitor) to the input transaction.
Should I write the input transaction to the scoreboard from the sequence or from the driver?","The preferred uvm mechanism is to have a monitor at the input port which collects the data from the input bus (independent of the driver) and sends it to the scoreboard. This will enable re-use and portability of the agent. The agent can be later re-used in a passive mode and the scoreboard which is connected as the monitor will be available in the passive mode. [ the driver being absent in the passive mode the scoreboard cannot be re-used ] The monitor will also independently validate the protocol driven by the driver.

If you are very sure that you do not want to do the extra work or plan to build the monitor at a later time you can add the analysis port to the driver and send the transaction to the scoreboard from the driver. As a sequence is not a component and will be created and destroyed dynamically it's not suggested to connect the scoreboard to the sequence. Every time you create the sequence you will need to re-establish the connection with the scoreboard where as the driver/monitor connection to the scoreboard can be established once at startup during the connect_phase.

Am assuming that you cannot re-use the monitor at the output port as the output protocol is different from the input protocol.",,,,,
"Why am I getting an ""invalid aggregate"" error when trying to initialize this record in VHDL?","I want to initialize a record. I have looked online and following the style of this answer, but I am getting these errors:

From Aldec Linter:


  Compile Architecture ""TB_ARCHITECTURE"" of Entity ""ten_gig_filter_tb""
  Error: COMP96_0079: mgmt_regs_rx_TB.vhd : (97, 65): Invalid aggregate.
  Error: COMP96_0077: mgmt_regs_rx_TB.vhd : (97, 65): Undefined type of expression. Expected type 'tAPB_IBUS_RECORD'.


From XVHDL Linter:


  type of aggregate cannot be determined without context; 0 visible types match here, 32 matches.


Here is my code:

-- APB BUS - CPU interface
type tAPB_IBUS_RECORD is record

    pclk        : std_logic;                --APB Clock, all transactions are synced to this clock
    presetn     : std_logic;                --APB active low reset.
    pprot       : std_logic_vector(2 downto 0); --APB protection encoding.
    pselx       : std_logic;            --slave select pin, when asserted, will activate the slave
    penable     : std_logic;            -- Enable pin is asserted by the master after the first clock cycle and consecutively until the 
                                        -- the end of transcation indicated by pready = '1'
    pwrite      : std_logic;            -- APB Write/Read signal - '1' Write with pselx= '1', '0' - Read along with pselx = '1'
    pstrb       : std_logic_vector(3 downto 0); -- Write strobe to enable sparse data transfer on the write bus, 0 - byte lane on pwdata(7-0)
    paddr       : std_logic_vector(19 downto 0); -- 20 bit address bus
    pwdata      : std_logic_vector(31 downto 0); -- 32 bit data bus 
end record;

signal iAPB_BUS_IN         : tAPB_IBUS_RECORD := (
                             pclk =&gt; '0', presetn =&gt; '0', pprot =&gt; (others =&gt; '1'),
                             pselx =&gt; '1', pwrite =&gt; (others =&gt; '0'), penable =&gt; '1',
                             pstrb =&gt; (others =&gt; '1'), paddr =&gt; (others =&gt; '0'),
                             pwdata =&gt; (others =&gt; '0')
                           ); 
","It's because this bit is wrong:

pwrite =&gt; (others =&gt; '0'),


It should be

pwrite =&gt; '0',


because pwrite is of type std_logic.

http://www.edaplayground.com/x/5eay",,,,,
How to start with zero counter verilog,"I'm implementing a repeating bit shifter for a 16 bit number. To do this, I have a bit counter that counts how many times I've shifted and resets when I reach 4'b1111. Then I have an assign statement that feeds the MSB to an output. However, the logic makes it so that the output skips the first MSB every time. What is the most succinct way to include the first MSB, before any shifting has occurred? 

CODE

module DAC_Control(
  input [15:0]data_in,
  input clk,
  input rst,
  output data_out,
  output reg cs,
  output reg enable
  );

//bit counter
  reg [3:0] bit_counter;

//to help with shifting
  reg [15:0] shifter;

  always @(data_in)
    shifter &lt;= data_in;

//shifter
  always @(posedge (clk)) begin
    if (rst) begin
      bit_counter &lt;= 4'b0;
      enable &lt;= 1'b0;
      cs &lt;= 1'b1;
      end
    else if (bit_counter == 4'b1111) begin
      bit_counter &lt;= 4'b0;
      enable &lt;= 1'b1;
      cs &lt;= 1'b1;
    end
    else begin //this is the problem area
      bit_counter &lt;= bit_counter + 1'b1;
      enable &lt;= 1'b0;
      cs &lt;= 1'b0;
      shifter &lt;= shifter &lt;&lt; 1;

    end
  end

  assign data_out = shifter[15];

endmodule
","Firstly it would be better to have a trigger to capture the data_in. If not then in simulation ,if the data_in changes in between the shifting it will update the shifter and cause the expected output to change. It would be preferable to capture the data_in based on a qualifying event ( e.g. counter_enable in the example below) . Synthesis will produce an error as shifter has two drivers . One the continuous assignment  shifter &lt;= data_in; and other the shifting logic  shifter &lt;= shifter &lt;&lt; 1;

Updated sample code should serialize the data.

module DAC_Control(
  input [15:0]data_in,
  input  counter_enable,
  input clk,
  input rst,
  output data_out,
  output reg cs,
  output reg enable
  );

//bit counter
  reg [3:0] bit_counter;

//to help with shifting
  reg [15:0] shifter;

//shifter
  always @(posedge (clk)) begin
    if (rst) begin
      bit_counter &lt;= 4'b0;
      shifter &lt;= 0;
      end
    else if (counter_enable == 1) begin
        shifter &lt;= data_in;
        bit_counter &lt;= 4'b0;
    end
    else begin
      shifter &lt;= shifter &lt;&lt; 1; // shifting 
      bit_counter &lt;= bit_counter + 1'b1; // counter 
    end
  end

  always @(posedge (clk)) begin
    if (rst) begin
      enable &lt;= 1'b0;
      cs &lt;= 1'b1;
      end
    else if (bit_counter == 4'b1111) begin
      enable &lt;= 1'b1;
      cs &lt;= 1'b1;
    end
    else begin 
      enable &lt;= 1'b0; // generate enable signals 
      cs &lt;= 1'b0;
    end
  end

  assign data_out = shifter[15];

endmodule
",,,,,
Synchronize to posedge of clock,"Is there any way to interrogate whether the simulation is at the @(posedge clk) event aside from using a named event that's triggered at the same time?

With the following code, I can make sure that I only do stuff at the posedge of a clock:

module tb;

  bit clk;
  always #2 clk = ~clk;

  event pos_clk;


  always @(posedge clk)
    -&gt; pos_clk;

  initial begin
    // stuff happens
    @(posedge clk);
    $display(""[%0d] @(posedge clk)"", $time());

    // control is passed asynchronously to some task
    // - since it's already at a posedge, it doesn't need to wait
    some_task();

    // other stuff happens
    #1;
    $display(""[%0d] #1"", $time());

    // control is passed asynchronously to some task
    // - since it's not at a posedge, it needs to catch the next one
    some_task();

    $finish();
  end

  task some_task();
    wait (pos_clk.triggered);
    $display(""[%0d] wait (pos_clk.triggered)"", $time());
    // do relevant stuff
  endtask
endmodule


Is there some other way I could do this without the extra named event?","This is what the ##0 construct does (See section 14.11 Cycle delay: ## of the 1800-2012 LRM). You do have to define a default clocking block, which means your task has to be defined inside a module or interface

module tb;

  bit clk;
  always #2 clk = ~clk;

  default clocking cb @(posedge clk)
  endclocking

  initial begin
    // stuff happens
    @(cb) // when using clocking blocks, only use the clocking event
    $display(""[%0d] @(posedge clk)"", $time());

    // control is passed asynchronously to some task
    // - since it's already at a posedge, it doesn't need to wait
    some_task();

    // other stuff happens
    #1;
    $display(""[%0d] #1"", $time());

    // control is passed asynchronously to some task
    // - since it's not at a posedge, it needs to catch the next one
    some_task();

    $finish();
  end

  task some_task();
    ##0;
    $display(""[%0d] wait (pos_clk.triggered)"", $time());
    // do relevant stuff
  endtask
endmodule


My advice would be not to do either and figure out a way to keep the activation of some_task synchronous.",,,,,
Curly braces in verilog,"I was looking through a program and found the following code:

{a2, a1} &lt;= {a1, b};


I am not sure whether the program that I'm going through is written in Verilog or SystemVerilog. I know the curly braces are used for concatenation operation in Verilog, but then I don't quite follow what kind of concatenation is being done here. Also since I'm not sure whether the given snippet is in Verilog or SystemVerilog, I'm left confused with the code. Also does curly braces denote another operation in SystemVerilog&hellip;?

Thanks in advance ","This is just concatenation treating the Left and right hand side as one variable each. SystemVerilog 2009 replace Verilog, so is backwards compatible with most (all?) syntax.

For example

wire [0:0] l1;
wire [2:0] l2;
reg  [1:0] r1;
reg  [1:0] r2;

assign {l1,l2} = {r1,r2} ;


Is the same as

assign l1[0] = r1[1];
assign l2[2] = r1[0];
assign l2[1] = r2[1];
assign l2[0] = r2[0];
",,,,,
How can I investigate failing calibration on Spartan 6 MIG DDR,"Iâ€™m having problems with a Spartan 6 (XC6SLX16-2CSG225I) and DDR (IS43R86400D) memory interface on some custom hardware. I've tried on a SP601 dev board and all works as expected. 

Using the example project, when I enable soft_calibration, it never completes and calib_done stays low. 

If I disable calibration I can write to the memory perfectly as far as I can see. But when I try to read from it, I get a variable number of successful read commands before the Xilinx memory controller stops implementing the commands. Once this happens, the command fifo fills up and stays full. The number of successful commands varies from 8 to 300. 

I'm fairly convinced it's a timing issue, probably related to DQS centering. But because I can't get calibration to complete when enabled, I don't have continuous DQS Tuning. So I'm assuming it works with calibration disabled until the timing drifts.

Is there any obvious places I should be looking for why calibration fails? 

I know this isn't a typical stack overflow question, so if it's an inappropriate place then I'll withdraw.

Thanks","Unfortunately, the calibration process just tries to write and read content successively while adjusting taps internally.  It finds one end of success then goes the other direction and identifies that successful tap and then final settles on some where in the middle. 

This is probably more HW centric as well, so I post what I think and let someone else move the thread.


Is it just this board?  Or is it all of them that are doing it?  Have you checked?  If it's one board, and the RAM is BGA style, it could be a bad solider job.  Push you finger down slightly on the chip and see if you get different results...  After this is gets more HW centric
Does the FPGA image you are running on your custom board, have the ability to work on your devkit?  A lot of times, that isn't practical I know, but I thought I would ask as it rules out that the image you are using on the devkit has FPGA constraints you aren't getting in your custom image.
Check your length tolerances on the traces.  There should have been a length constraint. Plus or minus 50 mils something like that. No one likes to hear they need a board re-spin, but if those are out, it explains a lot.
Signal integrity.  Did you get your termination resistors in there and are they the right values?  Don't supposed you have an active probe?  
Did you get the right DDR memory.  Sometimes they use a different speed grade and that can cause all sorts of issue.
Slowing down the interface will usually help items 4 and 5. so if you are just trying to work done, you might ask for a new FPGA image with a slower clock.
",,,,,
Incomplete sensitivity list in VHDL with Sigasi editor,"Currently, I try to develop my VHDL skills and therefore I use the Sigasi plugin for Eclipse to write some VHDL code. Sigasi is a great tool, but there is one thing, which is bothering me, though. Constantly, Sigasi tosses warnings about incomplete sensitivity lists in process definitions, which are not justified from my point of view. One example is the following entity with the corresponding architecture. It's the description of a ring shift register 

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity RingShiftReg is
    generic(
        WIDTH : integer := 8
    );
    port(
        clock     : in  std_ulogic;
        reset     : in  std_ulogic;
        set       : in  std_ulogic;
        initValue : in  std_ulogic_vector(WIDTH - 1 downto 0);
        value     : out std_ulogic_vector(WIDTH - 1 downto 0)
    );
end;

architecture ringShiftRegArch of RingShiftReg is
    signal innerValue : std_ulogic_vector(WIDTH - 1 downto 0);
begin
    P1: process(clock, reset)
    begin
        if reset = '1' then
            innerValue &lt;= (others =&gt; '0');
        elsif rising_edge(clock) then
            if set = '1' then
                innerValue &lt;= initValue;
            end if;
        else
            innerValue &lt;= innerValue(WIDTH - 2 downto 0) &amp; innerValue(WIDTH - 1);
        end if;
    end process;
    value &lt;= innerValue;
end ringShiftRegArch;


The Sigasi Linter claims that the sensitivity list of process P1 is incomplete, because the signal innerValue is missing. But in my opinion, it's not necessary to put innerValue in the sensitivity list, because it's totally dependent from clock and reset.

What is correct, now?","Did you perhaps mean this?

elsif rising_edge(clock) then
  if set = '1' then
    innerValue &lt;= initValue;
  else
    innerValue &lt;= innerValue(WIDTH - 2 downto 0) &amp; innerValue(WIDTH - 1);
  end if;
end if;
",,,,,
How can you not do the `using namespace std;` eqivalent in VHDL?,"Basically, literally every VHDL file I've ever seen has a header of something like:

library ieee;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;


This seems to splat the entire contents of the relevant library into the current namespace-analog (whatever VHDL calls it, it doesn't seem to have an explicit name in the VHDL manual, or I'm reading it wrong).

Is there any way to not just splat everything into the current namespace? 

Removing the .all postfix seems to partially work (types have to be specified by their full paths), but it seems to break all operator overloading done by the relevant types.","Just to expand on the comments, all you need to do is delete the .all from the use clause and only import what you need.

If that includes operators and literals, the compiler will tell you what is missing...


  ghdl -a test_qualified.vhd
  test_qualified.vhd:14:10: no function declarations for operator ""not""
  test_qualified.vhd:15:10: can't match character literal '0' with type std_ulogic
  test_qualified.vhd:15:21: no function declarations for operator ""=""
  test_qualified.vhd:15:30: can't match character literal '1' with type std_ulogic
  ghdl: compilation error


Simply import those too.

library ieee;
use ieee.std_logic_1164;
use ieee.std_logic_1164.""not"";
use ieee.std_logic_1164.""="";
use ieee.std_logic_1164.'0';
-- use ieee.std_logic_1164.'1';

entity test_qualified is
end test_qualified;

architecture test of test_qualified is

signal a,b,c : ieee.std_logic_1164.std_logic;

begin

    a &lt;= not b;
    c &lt;= '0' when a = b else ieee.std_logic_1164.'1';

end test;


Apparently, not many people feel they need this level of control of the namespaces. But it is possible.

If I found myself repeating this fine control in different compilation units, I'd learn about VHDL-2008's context keyword and declare a context specific to my application.",,,,,
Reading a specific line from a *.txt file in VHDL,"I am writing code that should somehow simulate an instruction memory read. The memory (in which data are stored in 1 byte long words) is represented by a *.txt file having 1 word per line; since instructions are 32 bit long I have to retrieve 4 words at the time, in order to concatenate them and build a complete instruction, to be sent as output. Such a memory is not accessed sequentially, but the instructions to be read may reside at any line of the file (as consequence to a jump or branch). 
As an example, the memory text file looks like this (the string ""InstrN"" isn't actually in the file; I wrote it here just to point out the distinction between subsequent instructions. The real file is made up only of 8 bits per line)

Instr1 11111111
       11111111
       11111111
       11111111
Instr2 00000000
       ........


Thus, the core of my work resides in the process to read from this file, for which I have written the following code:

read_instruction_memory : PROCESS(clk)
    FILE     mem           : TEXT; 
    VARIABLE mem_line      : LINE;
    VARIABLE read_byte     : STD_ULOGIC_VECTOR(7 DOWNTO 0);     -- byte of read memory
    VARIABLE line_counter  : INTEGER := 0;              -- counter to keep track of how many lines have already been read; it's initialized to 0 at the beginning of the process
    VARIABLE target_line   : INTEGER;                   -- line to be read, computed according to ""pc"" (program counter)
BEGIN 
    IF (clk'EVENT AND clk = '1') THEN 
        file_open(mem, ""instruction_memory.txt"", READ_MODE);
        target_line := to_integer(unsigned(pc));    
        WHILE line_counter &lt; (target_line + 4) LOOP
            IF NOT endfile(mem) THEN                    -- discarded lines (don't correspond to the wanted lines)
                readline(mem, mem_line);
                IF line_counter &gt;= target_line  THEN        -- subsequent four words are loaded
                    read(mem_line, read_byte);
                    instr(7+8*(line_counter - target_line) DOWNTO 8*(line_counter - target_line)) &lt;= to_StdUlogicVector(read_byte);
                END IF;
            END IF;
            line_counter := line_counter + 1;
        END LOOP;
        file_close(mem);
    END IF;
END PROCESS read_instruction_memory;


Basicly, on the clock rising edge, the process enters a loop in which reads one line per iteration, disregarding it until it corresponds to one of the words of the instruction to retrieve; then, stores it into the proper portion of the instruction instr (from right to left in the vector). The fact that I open and close the file at each execution of the process implies that the read begins at the beginning of the file at each time, doesn't it?

The problem is that it doesn't work: when I start the simulation, the std_ulogic_vector results always undefined and I just can't understand why. Please, let me know whether it is an ""algorithmic"" error or it is just due to my poor understanding of I/O functions.","Creating an MCVE:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.textio.all;

entity readinstr is
end entity;

architecture foo of readinstr is
    signal pc:      std_ulogic_vector (7 downto 0) := x""08"";
    signal clk:     std_ulogic := '0';
    signal instr:   std_ulogic_vector (31 downto 0);

begin
read_instruction_memory: 
    process (clk)
        file     mem:            text; 
        variable mem_line:       line;
        variable read_byte:      std_ulogic_vector(7 downto 0);     -- byte of read memory
        variable line_counter:   integer := 0;              -- counter to keep track of how many lines have already been read; it's initialized to 0 at the beginning of the process
        variable target_line:    integer;                   -- line to be read, computed according to ""pc"" (program counter)
    begin 
        if clk'event and clk = '1' then 
            file_open(mem, ""instruction_memory.txt"", read_mode);
            target_line := to_integer(unsigned(pc));    
            while line_counter &lt; target_line + 4 loop
                if not endfile(mem) then                    -- discarded lines (don't correspond to the wanted lines)
                    readline(mem, mem_line);
                    if line_counter &gt;= target_line  then        -- subsequent four words are loaded
                        read(mem_line, read_byte);
                        instr(7+8*(line_counter - target_line) downto 8*(line_counter - target_line)) &lt;= to_stdulogicvector(read_byte);
                        report ""read_byte = "" &amp; to_string(read_byte);
                    end if;
                end if;
                line_counter := line_counter + 1;
            end loop;
            file_close(mem);
        end if;
    end process read_instruction_memory;

MONITOR:
    process (instr)
    begin
        if now &gt; 0 ns then
            report ""instr = "" &amp; to_string(instr);
        end if;
    end process;

CLOCK:
    process
    begin
        wait for 10 ns;
        clk &lt;= not clk;
        wait for 10 ns;
        wait;
    end process;
end architecture;


With a instruction_memory.txt:


  00000000
  00000001
  00000010
  00000011
  00010000
  00010001
  00010010
  00010011
  00100000
  00100001
  00100010
  00100011
  00110000
  00110001
  00110010
  00110011  


Reveals:


  ghdl -a --std=08 readinstr.vhdl
  ghdl -e --std=08 readinstr
  ghdl -r readinstr
  readinstr.vhdl:32:25:@10ns:(report note): read_byte = 00100000
  readinstr.vhdl:32:25:@10ns:(report note): read_byte = 00100001
  readinstr.vhdl:32:25:@10ns:(report note): read_byte = 00100010
  readinstr.vhdl:32:25:@10ns:(report note): read_byte = 00100011
  readinstr.vhdl:45:13:@10ns:(report note): instr = 00100011001000100010000100100000  


That your code appears to actually be doing the right thing.

You close the file in the last statement of the if statement for the clock edge, and you open the file as the first statement of the if statement. That should work for successive clocks (which isn't tested in this MCVE).

Signal updates don't occur until every pending process has resumed and suspended.

The report statement for read_byte showed the correct values.

(I removed some superfluous parentheses pairs).


  Basicly, on the clock rising edge, the process enters a loop in which reads one line per iteration, disregarding it until it corresponds to one of the words of the instruction to retrieve; then, stores it into the proper portion of the instruction instr (from right to left in the vector). The fact that I open and close the file at each execution of the process implies that the read begins at the beginning of the file at each time, doesn't it?


Yes the file will be opened each clock, and 'scanned', the four lines represented by the PC are assembled to instras long as END_FILE does not return true.


  The problem is that it doesn't work: when I start the simulation, the std_ulogic_vector results always undefined and I just can't understand why. Please, let me know whether it is an ""algorithmic"" error or it is just due to my poor understanding of I/O functions.


There's not enough of your design presented in your question to rule out algorithmic errors. There are a few things that might be done differently in the code you do show. We can also point to 'systemic' issues that might be cause errors due to not shown code.

For instance detecting the clock edge using value and 'EVENT is subject to a false positive should you initialize clk to a '1'. The IEEE std_logic_1164 package contains two functions, rising_edge and falling_edge that require a transition between a zero ('L' or '0') and a one ('H' or '1') to detect an edge instead of just an event and a level.

Looking at systemic issues also points out an actual problem in your process. Variable line_counter is not assigned a value of 0 every time there's a rising edge event in the process. A successive instruction will be fetched from the wrong place.  line_counter would tell us the right PC value being read but it would fetch the first four bytes from instruction_memory.txt because line_counter isn't reset. This would show up by having the right line_counter value with the wrong read_byte values.

Fixing that:

architecture foo of readinstr is
    signal pc:              std_ulogic_vector (7 downto 0) := x""08"";
    signal clk:             std_ulogic := '0';
    signal instr:           std_ulogic_vector (31 downto 0);

begin

read_instruction_memory: 
    process (clk)
        file     mem:            text; 
        variable mem_line:       line;
        variable read_byte:      std_ulogic_vector(7 downto 0); 
        variable line_counter:   integer := 0; -- INTIALIZSATION NOT NEEDED
        variable target_line:    integer;
    begin 
        if clk'event and clk = '1' then
            line_counter := 0;
            file_open(mem, ""instruction_memory.txt"", read_mode);
            target_line := to_integer(unsigned(pc)); 
            while line_counter &lt; target_line + 4 loop
                if not endfile(mem) then 
                    readline(mem, mem_line);
                    if line_counter &gt;= target_line  then 
                    report ""line_counter = "" &amp; integer'image(line_counter);
                        read(mem_line, read_byte);
                        instr(7 + 8 * (line_counter - target_line) downto 8 * (line_counter - target_line)) &lt;= read_byte;
                        report ""read_byte = "" &amp; to_string(read_byte);
                    end if;
                end if;
                line_counter := line_counter + 1;
            end loop;
            file_close(mem);
        end if;
    end process read_instruction_memory;

POSITION_COUNTER:
    process (clk)
    begin
        if rising_edge(clk) then
            pc &lt;= std_ulogic_vector(unsigned(pc) + 4);
        end if;
    end process;

MONITOR:
    process (instr)
    begin
        if now &gt; 0 ns then
            report ""instr = "" &amp; to_string(instr);
        end if;
    end process;

PC_MONITOR:
    process (pc)
    begin
        report ""pc = "" &amp; to_string(pc);
    end process;

CLOCK:
    process
    begin
        wait for 10 ns;
        clk &lt;= not clk;
        wait for 10 ns;
        clk &lt;= not clk;
        wait for 10 ns;
        clk &lt;= not clk;
        wait for 10 ns;
        wait;
    end process;
end architecture;


And we get:


  ghdl -a --std=08 readinstr.vhdl
  ghdl -e --std=08 readinstr
  ghdl -r readinstr
  readinstr.vhdl:131:9:@0ms:(report note): pc = 00001000
  readinstr.vhdl:100:21:@10ns:(report note): line_counter = 8
  readinstr.vhdl:103:25:@10ns:(report note): read_byte = 00100000
  readinstr.vhdl:100:21:@10ns:(report note): line_counter = 9
  readinstr.vhdl:103:25:@10ns:(report note): read_byte = 00100001
  readinstr.vhdl:100:21:@10ns:(report note): line_counter = 10
  readinstr.vhdl:103:25:@10ns:(report note): read_byte = 00100010
  readinstr.vhdl:100:21:@10ns:(report note): line_counter = 11
  readinstr.vhdl:103:25:@10ns:(report note): read_byte = 00100011
  readinstr.vhdl:124:13:@10ns:(report note): instr = 00100011001000100010000100100000
  readinstr.vhdl:131:9:@10ns:(report note): pc = 00001100
  readinstr.vhdl:100:21:@30ns:(report note): line_counter = 12
  readinstr.vhdl:103:25:@30ns:(report note): read_byte = 00110000
  readinstr.vhdl:100:21:@30ns:(report note): line_counter = 13
  readinstr.vhdl:103:25:@30ns:(report note): read_byte = 00110001
  readinstr.vhdl:100:21:@30ns:(report note): line_counter = 14
  readinstr.vhdl:103:25:@30ns:(report note): read_byte = 00110010
  readinstr.vhdl:100:21:@30ns:(report note): line_counter = 15
  readinstr.vhdl:103:25:@30ns:(report note): read_byte = 00110011
  readinstr.vhdl:124:13:@30ns:(report note): instr = 00110011001100100011000100110000
  readinstr.vhdl:131:9:@30ns:(report note): pc = 00010000  


Which correctly shows fetching two consecutive instructions.

Also note I removed a superfluous to_stdulogicvector conversion for read_byte.

This doesn't get us any closer to your systemic issue but does allow speculation.  Do you have a reset that's valid for multiple clocks? There's also the possibility you have multiple drivers for instr. Without an MCVE your reading audience is a bit in the dark.

And all this also brings up another idea. How about initializing a memory array as an object from the file instruction_memory.txt, 'seeking' the position in a file is particularly cumbersome in VHDL.

And yes there actually  was an error in the read_instruction_memory process, revealed by modeling. line_counter wasn't reset before each execution of the while loop.

There's a chance this would have been revealed in the process of creating an MCVE to duplicate the problem. And if not it would have become apparent to those answering your question with a little instrumentation (the report statements). ",,,,,
Power consumption estimation from number of FLOPS (floating point operations)?,"I have extracted how many flops (floating point operations) each of my algorithms are consuming,


I wonder if I implement this algorithms on FPGA or on a CPU, can predict (roughly at least) how much power is going to be consumed? 


Both power estimation in either CPU or ASIC/FPGA are good for me. I am seeking something like a formula. I have this journal paper, for Intel CPUs. It gives power consumption per instruction (not only floating point operation but all those addressing, control, etc. instructions) so I need something more general to give power based on FLOPS not number of instructions of the code in a special processor.","Re CPU: It's not really possible with modern architectures. Let's assuming your program is running on bare metal (i.e. avoiding the complexities of modern OSs, other applications, interrupt processing, optimizing compilers, etc). Circuitry that isn't being used, the modern processor will operate at a reduced power level. There are also hardware power conservation states such as P (Power) and C (Sleep) states that are instruction independent and will vary your power consumption even with the same instruction sequence. Even if we assume your app is CPU-bound (meaning there are no periods long enough to allow the processor to drop into hardware power saving states), we can't predict power usage except at a gross statistical level. Instruction streams are pipelined, taken out-of-order, fused, etc. And this doesn't even include the memory hierarchy, etc. 

FPGA: Oh, heck. My experience with FPGA is so old, that I really don't want to say from when. All I can say is that way back, when huge monsters roamed the earth, you could estimate power usage since you knew the circuit design, and the power consumption of on and off gates. I can't imagine that there aren't modern power conservation technologies built into modern FPGAs. Even so, what small literature I scanned implies that a lot of FPGA power technology is based upon a-priori analysis and optimization. See Design techniques for FPGA power optimization, and 40-nm FPGA Power Management and Advantages. (I just did a quick search and scan of the papers, by the way, so don't pay too much attention to my conclusion.)",,,,,
VHDL compiler error,"ERROR:HDLParsers:164 - ""C:/.Xilinx/Counter/Main.vhd"" Line 35. parse error, unexpected ENTITY, expecting COMMA or SEMICOLON

I don't know what error it pointing out... I am not able to see what it means, could someone clarify it for me.. 

----------------------------------------------------------------------------------
-- Company: 
-- Engineer: 
-- 
-- Create Date:    23:52:28 03/05/2014 
-- Design Name: 
-- Module Name:    Main - Behavioral 
-- Project Name: 
-- Target Devices: 
-- Tool versions: 
-- Description: 
--
-- Dependencies: 
--
-- Revision: 
-- Revision 0.01 - File Created
-- Additional Comments: 
--
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL
-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx primitives in this code.
--library UNISIM;
--use UNISIM.VComponents.all;




entity Main is
PORT(
        CLK: in std_logic;
        LED: out std_logic_vector (7 downto 0)
        );

end Main;


architecture Behavioral of Main is
signal counter: std_logic_vector (7 downto 0);
signal prescaler:  std_logic_vector( 22 downto 0);
begin

CounterProcess: process(CLK)
begin
if rising_edge(CLK) then
    if prescaler &lt; ""1111111111111111111111"" then 
        prescaler &lt;= prescaler + 1;
        else
            prescaler &lt;= (others =&gt; '0'); 
            counter &lt;= counter + 1;
    end if;
end if; 
end process;

LED &lt;= counter; 

end Behavioral;
","You're missing a semicolon:

 use IEEE.STD_LOGIC_ARITH.ALL   


after the use clause.

The reason why the VHDL analyzer complains way down there, is because that's where the next lexical token is found.  Comments have no meaning to language analysis in VHDL, it would be clear to see if you removed them.  The token string goes:  reserved word ALL, reserved word ENTITY, in a place where lexical analysis would expect a semicolon for ending the use clause.  

Theoretically the reserved word ALL is sufficient to tell you you're missing either a semicolon or comma as the next lexical token.  That the distinction isn't made is a clue to parser implementation.",,,,,
How to identify the core which is running the interrupt handler?,"This is specific to XILINX-7000 family boards which has dual core A9 cortex CPU.  In the function OEMInterruptHandler I want to find out the core on which the current code is executing. This is for debug purpose as I found out that when the GPIO IRQ is targeted to CORE0 everything works fine but on CORE1 the GPIO IRQ is being preempted. The priority of GPIO IRQ is 0. The priority of all other IRQs are 0xA0. IRQs 0-31 are targeted on both cores and all other SPI except GPIO are targeted to core0. The OS is Windows CE 2013. Here is code from OEMInterruptHandler

    ULONG sys_intr = SYSINTR_NOP;
    UINT32 gic_iar = 0;
    UINT32 core;
    UINT32 irq = 0;

    gic_iar = (INREG32(&amp;g_GICCpu-&gt;INTACK));
    irq = ((gic_iar &amp; GIC_CPU_INTACK_INTID_MASK) &lt;&lt; GIC_CPU_INTACK_INTID_SHIFT);
    // read the core 
    core = readcore();
    // enable interrupts
    INTERRUPTS_ON();
    ....


I am looking for the implementation of readcore() function.

Thanks","If you're in an interrupt handler you're presumably at PL1, in which case you can just read the MPIDR directly:

readcore:
    MRC  p15, 0, r0, c0, c0, 5
    AND  r0, r0, #3
    BX   lr
",,,,,
VHDL: std_logic_vector Leftshift and right shift operator?,"How would anyone peform a rightshift or left shift in VHDL on a STD_LOGIC_VECTor... 

It will not work , why??`

AN &lt;= ""0001"";        
CounterProcess: process(CLK,Switch)
    begin
    if rising_edge(CLK) then
        if prescaler &lt; limit then 
            prescaler &lt;= prescaler + 1;
            else
                prescaler &lt;= (others =&gt; '0'); 
                counter &lt;= counter + 1;
                AN sll 1;
        end if;
    end if; 
    end process;
    An &lt;= anode;

    Segment &lt;= counter; 

    end Behavioral;


I get the Error message: sll can not have such operands in this context. 
But in which context can it then be used in, and how can perform my left shift?

these are my includes:

    library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;


isn't the one needed to perform my leftshift operations included??



Complete code

entity Main is
PORT(
        CLK: in std_logic;
        LED: out std_logic_vector (7 downto 0);
        Switch: in std_logic_vector(7 downto 0);
        Segment: out std_logic_vector (7 downto 0); 
        AN: out std_logic_vector (3 downto 0) 
        );

end Main;


architecture Behavioral of Main is
signal counter: std_logic_vector (7 downto 0);
signal prescaler:  std_logic_vector(25 downto 0);
signal limit: std_logic_vector (25 downto 0);
signal anode: std_logic_vector (3 downto 0);
begin
AN &lt;= ""0001"";

ScalerChoice: Process(switch)
begin
CASE Switch IS
when ""00000001"" =&gt; limit &lt;= ""10111110101111000010000000""; -- 1 Hz;
when ""00000010"" =&gt; limit &lt;= ""00111111100101000000101011""; -- 3 HZ
When ""00000100"" =&gt; limit &lt;= ""00010011000100101101000000""; -- 10 Hz
when ""00001000"" =&gt; limit &lt;= ""00000111101000010010000000""; -- 25 Hz
When ""00010000"" =&gt; limit &lt;= ""00000011110100001001000000""; -- 50 Hz; 
when ""00100000"" =&gt; limit &lt;= ""00000001111010000100100000""; -- 100 hz
when others =&gt; limit &lt;=      ""00000000000000000000000001""; -- 50 MHz
end case;
end process;


CounterProcess: process(CLK,Switch)
begin
if rising_edge(CLK) then
    if prescaler &lt; limit then 
        prescaler &lt;= prescaler + 1;
        else
            prescaler &lt;= (others =&gt; '0'); 
            counter &lt;= counter + 1;
            AN sll AN 1;
    end if;
end if; 
end process;

Segment &lt;= counter; 

end Behavioral;
","EDIT 1:

Your Code Edited with reset logic, notice the addition of the RESET signal to the ports list, the deletion of the asynchronous line setting that value, addition of RESET to the sensitivity list of your CounterProcess process, the addition of the if(RESET = '1') line, and change of your if to an elsif, as well as the change of your shifting line:

I actually don't know what your An &lt;= Anode line is doing, and believe this to be in error also.

entity Main is PORT(
    RESET:   in  std_logic;
    CLK:     in  std_logic;
    LED:     out std_logic_vector(7 downto 0);
    Switch:  in  std_logic_vector(7 downto 0);
    Segment: out std_logic_vector(7 downto 0); 
    AN:      out std_logic_vector(3 downto 0)
);
end Main;

architecture Behavioral of Main is
signal counter:   std_logic_vector(7  downto 0);
signal prescaler: std_logic_vector(25 downto 0);
signal limit:     std_logic_vector(25 downto 0);
signal anode:     std_logic_vector(3  downto 0);

begin

ScalerChoice: Process(switch)
begin
CASE Switch IS
when ""00000001"" =&gt; limit &lt;= ""10111110101111000010000000""; -- 1 Hz;
when ""00000010"" =&gt; limit &lt;= ""00111111100101000000101011""; -- 3 HZ
When ""00000100"" =&gt; limit &lt;= ""00010011000100101101000000""; -- 10 Hz
when ""00001000"" =&gt; limit &lt;= ""00000111101000010010000000""; -- 25 Hz
When ""00010000"" =&gt; limit &lt;= ""00000011110100001001000000""; -- 50 Hz; 
when ""00100000"" =&gt; limit &lt;= ""00000001111010000100100000""; -- 100 hz
when others =&gt; limit &lt;=     ""00000000000000000000000001""; -- 50 MHz
end case;
end process;


CounterProcess: process(RESET, CLK, Switch)
begin
    if(RESET = '1') then
        AN &lt;= ""0001"";
    elsif rising_edge(CLK) then
        if prescaler &lt; limit then 
            prescaler &lt;= prescaler + 1;
        else
            prescaler &lt;= (others =&gt; '0'); 
            counter &lt;= counter + 1;
            AN &lt;= std_logic_vector(unsigned(AN) sll 1);
        end if;
    end if;
end process;

An &lt;= anode;
Segment &lt;= counter; 

end Behavioral;


you need to write the line that you currently have:

AN sll 1;


as 

AN &lt;= AN sll 1;


Remember that AN is essentially like a variable that needs to be ""set"".  Like your line above

counter &lt;= counter + 1;
",,,,,
Reset If-Else statement produces improper results,"I've been trying to debug this code, but I cannot find an error in it. However, it's not producing the results that I expect. Here's the code:

module countAdd( btn, reset, thousands, hundreds, tens, ones, led);

  //Port Assignments
  input [2:0] btn;
  input reset;

  output [0:7] thousands, hundreds, tens, ones;
  output reg led;

  //Internal Port Assignments
  reg [15:0] sum;
  wire [15:0] sumBCD;
  reg [15:0] inc;

  //Add some stuff
  always @(btn or reset)
    begin

        //Determine which button is active
        case(btn)
            3'b110: inc &lt;= 1;
            3'b101: inc &lt;= 10;
            3'b011: inc &lt;= 100;
            default: inc &lt;= 0;
        endcase

        //Add
        sum &lt;= sum + inc;

        //Should we reset?
        if(reset)
            begin
                sum &lt;= 0;
                led &lt;= 1;
            end
        else
            begin
                led &lt;= 0;
            end

    end

  //translate sum to sumBCD
  binToBCD translate (sum, sumBCD[15:12], sumBCD[11:8], sumBCD[7:4], sumBCD[3:0]);

  //display results on SS display
  ssFromBCD seg0 (sumBCD[3:0], ones);
  ssFromBCD seg1 (sumBCD[7:4], tens);
  ssFromBCD seg2 (sumBCD[11:8], hundreds);
  ssFromBCD seg3 (sumBCD[15:12], thousands);
endmodule


module binToBCD(sum, thousands, hundreds, tens, ones);
  //Port Assignments
  input [15:0] sum;
  output reg [3:0] thousands;
  output reg [3:0] hundreds;
  output reg [3:0] tens;
  output reg [3:0] ones;

  //Begin conversion
  integer i;
  always @(sum)
    begin
        //set 1000's, 100's, 10's, and 1's to 0
        thousands = 4'd0;
        hundreds = 4'd0;
        tens = 4'd0;
        ones = 4'd0;

        for(i = 15; i &gt;= 0; i=i-1)
            begin
                //Add 3 to columns &gt;= 5
                if(thousands &gt;= 5)
                    thousands = thousands + 3;
                if(hundreds &gt;= 5)
                    hundreds = hundreds + 3;
                if(tens &gt;= 5)
                    tens = tens + 3;
                if(ones &gt;= 5)
                    ones = ones + 3;

                //Shift left ones
                thousands = thousands &lt;&lt; 1;
                thousands[0] = hundreds[3];
                hundreds = hundreds &lt;&lt; 1;
                hundreds[0] = tens[3];
                tens = tens &lt;&lt; 1;
                tens[0] = ones[3];
                ones = ones &lt;&lt; 1;
                ones[0] = sum[i];   
            end

    end 
endmodule

module ssFromBCD(in, ssOut);
  //Port Assignments
  input [3:0] in;
  output reg [0:7] ssOut;

  always @(in)
    begin
        case(in)
            4'b0000: ssOut = 8'b00000011;
            4'b0001: ssOut = 8'b10011111;
            4'b0010: ssOut = 8'b00100101;
            4'b0011: ssOut = 8'b00001101;
            4'b0100: ssOut = 8'b10011001;
            4'b0101: ssOut = 8'b01001001;
            4'b0110: ssOut = 8'b01000001;
            4'b0111: ssOut = 8'b00011111;
            4'b1000: ssOut = 8'b00000001;
            4'b1001: ssOut = 8'b00011001;
            default: ssOut = 8'b11111111;
        endcase
    end
endmodule


This code does not have a testbench; it's instead loaded onto a DE0 board. The idea is that when I press button 1, the sum is supposed to increment by 1. Button 2 increments it by 10, and button 3 increments it by 100. However, the if-else module that encapsulates reset seems to be causing some serious issues. 

For instance, when I activate the switch controlling reset, the sum goes to 0 as expected. However, when I try to increment the sum with any of the three buttons, a random number is added - not a 1, 10, or 100. 

I've also tried moving the if-else statement before the case statement. Another issue arises. Even if the switch is not activated, the sum is set to 0 as if it ignores the reset condition. However, if I activate the switch, an led turns on. If I turn it off, the led deactivates. However, sum will always be set to 0 regardless of the state of the switch. In this case, though, if I hold a button I see that a 1, 10, or 100 is added to the sum. As soon as I release it, the sum is reset to 0. 

Obviously, I believe something is wrong with my if-else statement. I'm not sure why it's not working as I intended. Basically, the logic is as follows:


Determine which button is depressed, assign an increment accordingly
Add the increment value to sum
Should the sum be reset? If yes, set sum to 0. 


Note that the last two modules are straightforward. bintoBCD converts the binary string sum into its BCD equivalency. Then ssFromBCD is simply a seven segment display encoder. ","A random number is being displayed because sum is continuously being incremented while btn is changing states. A clear start and stop point must be explicit. 

Try sampling btn with a clock. In a combination block assign inc. If past_btn equals btn, then assign inc to zero. sum should be assigned in a clocked block.

alwasy @* begin
 if (past_btn == btn) inc = 'b0;
 else begin
   // case(btn) ...
 end
end

always @(posedge clk) begin
  past_btn &lt;= btn;
  if (!reset)  sum &lt;= 'b0;
  else         sum &lt;= sum + inc;
end


If you are still getting random numbers, then the buttons are likely not denounced. In this case add another stage to the button sampling and use only the sampled values.

alwasy @* begin
 if (past_btn == sync_btn) inc = 'b0;
 else begin
   // case(sync_btn) ...
 end
end

always @(posedge clk) begin
  sync_btn &lt;= btn;
  past_btn &lt;= sync_btn;
  if (!reset)  sum &lt;= 'b0;
  else         sum &lt;= sum + inc;
end


Always make a test bench and run in simulation. Debugging from FPGA is difficult with logic bugs and implementation issues.",,,,,
Why are these SystemVerilog processes not ending?,"The program below starts four processes. The task first waits for the last process to start executing and then waits for the first process to terminate. At that point, the parent process forcibly terminates all forked processes that have not yet completed.

program automatic test;

initial begin
     do_n_ways;
end

task do_n_ways;
    process job[1:4];

for(int i=1;i&lt;=4;i++) 
fork
    automatic int j = i;
    job[j] = process::self();
    $display(""process %d starting..."",j);
    if(j==2) begin
        #100 $display(""delay 2ns"");
    end
join_none

for(int j = 1;j&lt;=4;j++) begin //wait for all process starting 
    wait(job[j] != null);
end

job[1].await();               //wait for first process finish

for(int j=1;j&lt;=4;j++) begin
    if(job[j].status != process::FINISHED) begin
        job[j].kill();
        $display(""process %d killed..."",j);
    end
end
endtask

endprogram


It appears that process #2 never gets killed since I never see ""process 2 killed..."" Why does this process continue to run?","You're missing a begin..end when starting your processes. Your fork should look like this:

fork
  automatic int j = i;
  begin // treat everything from here as an own process
    job[j] = process::self();
    $display(""process %d starting..."",j);
    if(j==2) begin
      #100 $display(""delay 2ns"");
    end
  end
join_none


By putting that begin..end, you treat all statements as belonging to one process. What your code was doing is spawning a separate process for each statement, i.e. one for the $display(...), one for the if(...) and one for assigning the job.

Here's a working example on EDA Playground: http://www.edaplayground.com/x/2f8
I changed program to module to work on that ModelSim version.",,,,,
Counter Not Testing As Expected? [VHDL],"I'm trying to make a 32 bit counter in VHDL. Below is my code:

LIBRARY ieee; 
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY counter32 IS 
PORT (en, clk, clr: IN STD_LOGIC; 
count: OUT STD_LOGIC_VECTOR(4 DOWNTO 0)); 

END counter32;

ARCHITECTURE rtl OF counter32 IS 

SIGNAL count_result: STD_LOGIC_VECTOR(4 DOWNTO 0); 

BEGIN
counter32: PROCESS(clk, clr) 

BEGIN 
count &lt;= ""00000""; --Initialize counter to all zeroes

IF (clr = '0') THEN 
count_result &lt;= ""00000""; 

ELSIF (clk = '1' and clk'EVENT) THEN 

IF (en = '1') THEN
count &lt;= STD_LOGIC_VECTOR(unsigned(count_result) + 1); 
count &lt;= STD_LOGIC_VECTOR(count_result);

 ELSIF (count_result = ""11111"") THEN
 count_result &lt;= ""00000"";

END IF; 

END IF; 

END PROCESS counter32;

END rtl;


My test bench code is here:

library ieee; 
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity counter32_tb is
end counter32_tb;

architecture io of counter32_tb is

component counter32 is
port(en,clk,clr:in std_logic; count:out std_logic_vector(4 downto 0)); 
end component;

for all: counter32 use entity work.counter32(rtl);

signal en,clk,clr:std_logic;
signal count:std_logic_vector(4 downto 0);

begin

count &lt;= ""00000"";
g0: counter32 port map(en,clk,clr,count);

p0: process

begin
en  &lt;= '1';
clk &lt;= '0';
clr &lt;= '1';
wait for 10ns;
en  &lt;= '1';
clk &lt;= '1';
clr &lt;= '1';
wait for 10ns;
en  &lt;= '1';
clk &lt;= '0';
clr &lt;= '1';
wait for 10ns;
en  &lt;= '1';
clk &lt;= '1';
clr &lt;= '1';
wait for 10ns;
en  &lt;= '1';
clk &lt;= '0';
clr &lt;= '1';
wait for 10ns;
en &lt;= '1';
clk &lt;= '1';
clr &lt;= '0';
end process;

end io;


Whenever I test, however, an addition of 1 gives a 'U' STD_LOGIC value and a red bar in testing, as you can see here:



Any idea what the matter is? I'm really confused!","Any idea what the matter is?

Your waveform doesn't match your test bench stimulus.

There are three assignments to the signal count which appears to show in your waveform (at the test bench level).  An initial assignment to ""00000"", and two conditional assignments.  The bouncing back and forth is caused by the process sensitity to clk, bouncing back to ""00000"" on the following edge of clock using the first assignment statement.

In a process statement the last assignment is the one that takes effect.  You're writing it to ""00000"" and changing that to count_result conditionally based on the positive edge of clock.  Note that you aren't actually loading count with count_result + 1 either, the next assignment provides the current value of count_result.  While we're on the subject the type conversion to std_logic_vector isn't needed either, count_result is already a std_logic_vector.

The unknown (red) 'flash' at the clock edge is because you haven't actually cleared count_result.  The only event on clr is from 'U' to '1' and causes no clear.

The vhdl design code is not functional as a counter.

This:

library ieee; 
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity counter32 is 
    port (
        en, clk, clr: in  std_logic; 
        count:        out std_logic_vector(4 downto 0)
    ); 

end counter32;

architecture rtl of counter32 is 

    signal count_result: std_logic_vector(4 downto 0); 

begin
counter: process(clk, clr) 

    begin 

        if clr = '0' then 
            count_result &lt;= (others =&gt; '0'); 

        elsif clk = '1' and clk'event and en = '1' then 

                count_result &lt;= std_logic_vector(unsigned(count_result) + 1); 

        end if;         

    end process;

    count &lt;= count_result;
end rtl;

library ieee;
use ieee.std_logic_1164.all;

entity counter32_tb is
end entity;

architecture foo of counter32_tb is
    signal en:      std_logic:= '0';
    signal clr:     std_logic:= '1';
    signal clk:     std_logic:= '0';
    signal count:   std_logic_vector (4 downto 0);
begin
DUT:   entity work.counter32
    port map (
        en =&gt; en,
        clk =&gt; clk,
        clr =&gt; clr,
        count =&gt; count
    );

CLOCK:
    process
    begin 
        wait for 10 ns;
        clk &lt;= not clk;
        if Now &gt; 720 ns then
            wait;
        end if;

    end process;

STIMULUS:
    process
    begin
        clr &lt;= '0';
        en &lt;=  '1';
        wait for 20 ns;
        clr &lt;= '1';
        wait for 20 ns;
        wait for 20 ns;
        wait for 20 ns;
        wait for 20 ns;
        wait for 20 ns;
        en &lt;= '0';
        wait for 20 ns;
        en &lt;= '1';

        wait;
    end process;
end architecture;


Gives this:



The reason no end cases are necessary in the count arithmetic are due to how the unsigned ""+"" operator works, calling unsigned_add in the package body for numeric_std.  End counts are something you need to worry about in scalar increments.

The purpose behind having count (mode out) and count_result, is to allow the count value to be read internally for versions of VHDL predating IEEE Std 1076-2008.  For a -2008 compliant simulation you should be only using count.  Note the above simulation shown will run on earlier versions of VHDL.

You could likewise make count_result a variable.

And I trust you're aware based on signal array sizes this is a 5 bit counter and not a 32 bit counter.  Converting to the latter is relatively easy.",,,,,
Can a VHDL configuration have generics of it's own?,"What I want to do:  

I want to pass the current date and time to a VHDL testbench so I can create nicer report file names.

The Problem:  

The Top level VHDL file that is being called from my simulation TCL scripts is a configuration and I don't know how to pass the genericto it. The interesing part of the TCL script is the following:  

set reportfilename ""report_$testcase_id""
append reportfilename [clock format [clock seconds] -format _%Y-%m-%d_%H:%M]
vsim -t 10fs -gG_TC_REPORTFILE=$reportfilename -novopt work.CFG_TB_TOP_tc0027 - wlf result_$testcase_id.wlf  


The resulting VSIM call looks like this: 

# vsim -t 10fs -wlf result_tc0027.wlf -novopt -gG_TC_REPORTFILE=report_tc0027_2014-03-05_13:22 work.CFG_TB_TOP_tc0027 


The problem is that G_TC_REPORTFILE is not a generic of CFG_TB_TOP_tc0027.vhd, but of one of the modules configured IN CFG_TB_TOP_tc0027.vhd  

The relevant part of CFG_TB_TOP_tc0027.vhd:

configuration CFG_TB_TOP_tc0027 of TB_TOP_CFG is
   for testcaseexecution
      for TB_TOP_E_INST : TB_TOP_E
         -------------------------------------------------------------
         -- Testbench configuration
         -------------------------------------------------------------

         use entity work.TB_TOP_E(TB_TOP_sim)
            generic map (
               G_TC_STIMULUSFILE =&gt; ""./testcases/tc0027.txt"",  -- 
               G_TC_REPORTFILE   =&gt; ""./results/report_tc0027.txt"",
               G_TB_VNR          =&gt; ""V_03.10"",
               G_TC_NR           =&gt; 27);    -- 

         for TB_TOP_A_sim


How would I pass the value from the TCL file to the generic G_TC_REPORTFILE of the TB_TOP_E entity? Can I somehow add a generic to the CFG file, or can I somehow specify for which entity the generic in the TCL file is meant? Best-case-scenario would be if I would not have to edit the vhdl files, only the TCL scripts.  

The simulator is ModelSim SE 10.0b, I'm using VHDL 2008.","I have just found the answer myself:  

You can indeed specify a path to the generic you want to overwrite. I changed the TCL file like this:  

set reportfilename ""./results/report_$testcase_id""
append reportfilename [clock format [clock seconds] -format _%Y-%m-%d_%H-%M.txt]
vsim -t 10fs -GTB_TOP_CFG/TB_TOP_E_INST/G_TC_REPORTFILE=$reportfilename -novopt work.CFG_TB_TOP_tc0027 -wlf result_$testcase_id.wlf


Which produces the following VSIM call:  

# vsim -t 10fs -wlf result_tc0027.wlf -novopt -GTB_TOP_CFG/TB_TOP_E_INST/G_TC_REPORTFILE=./results/report_tc0027_2014-03-05_14-06.txt work.CFG_TB_TOP_tc0027 


In addition to adding the path TB_TOP_CFG/TP_TOP_E_INST/ I also had to remove the : from the timestamp, as modelsim/vhdl did not handle it.",,,,,
Latch generated when attempting to create a memory bus in VHDL,"I have been trying to attempt to create a simple memory in the FPGA that I can write to using another processor. I know I should use the FPGA RAM but somebody told me that I can make a simple register just using this code below:

vcap_data_store : process(resetb,clk)
begin
    if resetb = '0' then
        vcap_data_in11 &lt;= ""0000000000000000000000"";
        vcap_data_in12 &lt;= ""0000000000000000000000"";
        vcap_data_in13 &lt;= ""0000000000000000000000"";
        vcap_data_in14 &lt;= ""0000000000000000000000"";
    elsif (rising_edge(clk)) then
        vcap_data_in11 &lt;= vcap_data_in_11;
        vcap_data_in12 &lt;= vcap_data_in_12;
        vcap_data_in13 &lt;= vcap_data_in_13;
        vcap_data_in14 &lt;= vcap_data_in_14;
    end if;
end process;

vdi_input_gen : process(vdi_csb, vdi_wrb, vdi_indt)
begin

    if (vdi_csb = '0' and vdi_wrb = '0') then
        if vdi_addr = ""00000"" then
            vcap_data_in_11(15 downto 0) &lt;= vdi_indt(15 downto 0);
        elsif vdi_addr = ""00001"" then
            vcap_data_in_11(21 downto 16) &lt;= vdi_indt(5 downto 0);
        elsif vdi_addr = ""00010"" then
            vcap_data_in_12(15 downto 0) &lt;= vdi_indt(15 downto 0);
        elsif vdi_addr = ""00011"" then
            vcap_data_in_12(21 downto 16) &lt;= vdi_indt(5 downto 0);
        elsif vdi_addr = ""00100"" then
            vcap_data_in_13(15 downto 0) &lt;= vdi_indt(15 downto 0);
        elsif vdi_addr = ""00101"" then
            vcap_data_in_13(21 downto 16) &lt;= vdi_indt(5 downto 0);
        elsif vdi_addr = ""00110"" then
            vcap_data_in_14(15 downto 0) &lt;= vdi_indt(15 downto 0);
        elsif vdi_addr = ""00111"" then
            vcap_data_in_14(21 downto 16) &lt;= vdi_indt(5 downto 0);
                    end if;
    end if;

end process;


The thing is that I kept on getting these errors:

WARNING:Xst:737 - Found 1-bit latch for signal &lt;vcap_data_in_11_7&gt;. Latches may be
generated from incomplete case or if statements. We do not recommend the use of latches
in FPGA/CPLD designs, as they may lead to timing problems.


I don't want to use latches, but I don't know how to turn these into registers.
FYI I use the ""buffer"" type for the vcap_data_in11.

Is there any workaround to implement these as registers?

I'm quite new to VHDL, although I know 1 of the 10 commandments of VDHL ""Thou shalt use registers, never latches"", so I want to solve this warning.

It would be great if you can show me the way!","I have two separate recommendations.  The first fixes your code as it is.  The second (recommended) proposes a better way to structure the code for this problem

The first, the following will fix your code as it is, but is not the best answer.  The problem is because second process does not define what the signals vcap_data_in_11, ... get when they are not selected.  The quick answer is to use default assignments.  Note, the code is hard to read since you picked names that are too similar.  

vdi_input_gen : process(vdi_csb, vdi_wrb, vdi_indt)
begin
   -- default assignments:
   vcap_data_in_11 &lt;= vcap_data_in11 ;   -- tempQ &lt;= Q;
   vcap_data_in_12 &lt;= vcap_data_in12 ; 
   vcap_data_in_13 &lt;= vcap_data_in13 ; 
   vcap_data_in_14 &lt;= vcap_data_in14 ; 

   -- your other code goes here:
    if (vdi_csb = '0' and vdi_wrb = '0') then
        if vdi_addr = ""00000"" then
            vcap_data_in_11(15 downto 0) &lt;= vdi_indt(15 downto 0);
        elsif vdi_addr = ""00001"" then
            vcap_data_in_11(21 downto 16) &lt;= vdi_indt(5 downto 0);
        elsif vdi_addr = ""00010"" then
    . . . 

    end if;
end process;


My bigger recommendation is to re-write your code into a single process.  Surprised I am the first to recommend this as others feel strongly about this and I actually don't.  My main concern is about writing simple, readable code.  I also recommend that you use a case statement rather than if when processing the same object (in this case vdi_addr):

Hence, your code becomes the following.  Note you no longer need a default assignment because in a clocked process, the feedback becomes a load enable condition (which is required for this problem) rather than a latch.  

vcap_data_store : process(resetb,clk)
begin
    if resetb = '0' then
        vcap_data_in11 &lt;= ""0000000000000000000000"";
        vcap_data_in12 &lt;= ""0000000000000000000000"";
        vcap_data_in13 &lt;= ""0000000000000000000000"";
        vcap_data_in14 &lt;= ""0000000000000000000000"";
    elsif (rising_edge(clk)) then
      if (vdi_csb = '0' and vdi_wrb = '0') then
        case vdi_addr is
          when ""00000"" =&gt;   vcap_data_in11(15 downto 0)  &lt;= vdi_indt(15 downto 0);
          when ""00001"" =&gt;   vcap_data_in11(21 downto 16) &lt;= vdi_indt( 5 downto 0);
          when ""00010"" =&gt;   vcap_data_in12(15 downto 0)  &lt;= vdi_indt(15 downto 0);
          when ""00011"" =&gt;   vcap_data_in12(21 downto 16) &lt;= vdi_indt( 5 downto 0);
          when ""00100"" =&gt;   vcap_data_in13(15 downto 0)  &lt;= vdi_indt(15 downto 0);
          when ""00101"" =&gt;   vcap_data_in13(21 downto 16) &lt;= vdi_indt( 5 downto 0);
          when ""00110"" =&gt;   vcap_data_in14(15 downto 0)  &lt;= vdi_indt(15 downto 0);
          when ""00111"" =&gt;   vcap_data_in14(21 downto 16) &lt;= vdi_indt( 5 downto 0);
          when others  =&gt;   null ; -- do nothing !
        end case;
      end if;
    end if;
end process;
",,,,,
can't include float_pkg into project,"I have Altera Quartus II 7.2 (SP 2) installed and I'm unable to include the float_pkg package. I've done some research and it seems that there are various vendors for various versions of the VHDL language, however, none seem to fit in my project. I've tried the following:

library ieee_proposed;
use ieee_proposed.float_pkg.all;


and

library ieee;
use ieee.float_pkg.all;


(I've also found some third library, but I forgot what it was, it doesn't matter since it worked out the same as those two)

When compiling, I get the error: design library ""ieee_proposed"" does not contain primary unit ""float_pkg"".

Can someone clarify what is the proper way to use floats, where to find these libraries and how to explicitly include them?","I don't believe Quartus 7.2 supports float_pkg. In fact, as of 13.0, I believe support for float_pkg still hasn't been added yet. Your only option right now may be to download a backwards-compatible approximated version of the package and compile that in yourself.",,,,,
constant connection on instance pin in vhdl'87,"I have following simple testcase :

library ieee;
use ieee.std_logic_1164.all;

entity top is
end top;

architecture top of top is
component foo
  port (A : std_logic_vector(1 downto 0));
end component;

begin
inst : foo port map (A(1) =&gt; '0', A(0) =&gt; '0');
end top;

------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;

entity foo is
  port (A : std_logic_vector(1 downto 0));
end foo;

architecture foo of foo is
begin
end foo;


When running modelsim on this, it runs fine. But, when I run modelsim with option '-87', it gives me error that  Error: top.vhd(13): (vcom-1451) Actual (enumeration literal '0') for formal ""A"" is not signal name. I am not getting this. Is this some illegal RTL in VHDL'87?

If this is not supported in VHDL'87, then what would be right way to connect a constant to instance pin.","Looking in Modelsim's Verror messages:


  vcom Message # 1451: The actual designator is not a static signal
  name, it is an expression. In a VHDL 1987 port map, the actual
  designator in an association element must be either a static signal
  name or a conversion function call whose only argument is a static
  signal name. In a subprogram association list in any VHDL language
  version, the actual associated with a class SIGNAL subprogram
  parameter must be a static signal name.
  Later versions of VHDL allow
  flexibility in the actual in a port map.
  Try using the -93, -2002, or -2008 switch to vcom.
   [DOC: IEEE Std 1076-1987 VHDL LRM - 2.1.1.2 Signal parameters,
                                 4.3.3.2 Association Lists]
   [DOC: IEEE Std 1076-1993 VHDL LRM - 2.1.1.2 Signal parameters]  


So, yes there's a difference in what is valid for an an actual in a port association. The -1993 'liberalization' would also be applicable on later versions (-2002, -2008).

The actual needs to be named and not simply an expression.  Inputs with default values can be left open.",,,,,
Complex port connection in Verilog,"Please help to understand the following syntax of verilog port definition.

module same_port (.a(i), .b(i)); 
// Name â€™iâ€?is declared inside themodule as a inout port.
// Names â€™aâ€?and â€™bâ€?are
// defined for port connections.


Is this connection legal?","Yes, this is legal.  It looks like you took this example straight from section 23.2.2.1  of the standard (Non-ANSI style port declarations).  As it says there you have two ports a and b which are both connected to internal net i.  When you instantiate this module you can use named port connections to connect two different things to i:

same_port inst(.a(connection1), .b(connection2));


In the above instantiation, both connection1  and connection2 will be connected to inst.i.

Even though this is  legal, I would advise against using it unless you have a good reason to.  This is not very commonly used syntax and could cause confusion for someone else looking at your code.  The only place I have seen this is in a verilog netlist automatically generated from an schematic.",,,,,
4-Bit verilog adder not passing carry bit,"I had my 2-bit adder working, except for some reason it is not passing the carry bit.   For instance if I use A=1 and B=1  the result S=00,  but if either A or B  is 1 i get S=1
?i tried printing out the values and it seems my c1 wire in the 2nd module isn't being set, and for some reason Cout is. 

So with a input of A=1, B=1,  S=00 and Cout=1 
when it should be.            S=10 and Cout=0

I have only been using Verilog for one day so the syntax is very new to me.

module fulladder(Cin,A,B,S,Cout); // dont forget semi colon
    input A,B, Cin; // defaults to 1 bit or [0,0] size
    output S, Cout;
    wire XOR1,AND1,AND2;

    xor(XOR1,A,B);
    and(AND1,A,B);
    xor(S,Cin,XOR1);
    and(AND2,Cin,XOR1);
    or(Cout,AND2,AND1);

endmodule

module adder4(Cin,A,B,S,Cout);
input Cin;
input [0:1]A;
input [0:1]B;
output [0:1]S;
output Cout;
wire c1;

fulladder FA1(Cin,A[0:0],B[0:0],S[0:0],c1);
fulladder FA2(c1,A[1:1],B[1:1],S[1:1],Cout);
endmodule


module t_adder;

reg Cin;
reg [1:0]A;
reg [1:0]B;// to declare size, must be on own line, wires can be more than 1 bit
wire [1:0]S;
wire Cout;
adder4 add4bit(Cin,A,B,S,Cout);

initial 
begin
    A = 1; B = 1; Cin = 0;
    #1$display(""S=%b Cout = %b"",S,Cout);
end

endmodule
","You're reversing the bit order in the adder4 module, by declaring the inputs as [0:1], where elsewhere it is [1:0].

Since you reverse the bits, to adder4 it looks like you are adding A=2'b10, B=2'b10, which gives the output you see (3'b100).",,,,,
Need help finding pin assignments,"I am trying to output sound on a FPGA through its stereo out. In Verilog I've declared ""stereo"" as an output and have some code to generate sound. However, I cannot find the pin assignments for the stereo out to assign to ""speaker"".

I'm using DE2i-150 FPGA Development Kit.","Yours Board's FPGA Doesn't have any circuit to play music so it uses an Audio codec to do this job. It must be noted that the board contain Audio CODEC ""Realtek ALC272VA3-GR"" therefore its gives sound so i think you first see the connection of this IC(Audio codec) to your FPGA,then give input to those pin which connect to this Codec IC. 

The link to your Audio Codec Datasheet is here",,,,,
"""Identifier not declared"" in Verilog. Anyone know why I'm getting this?","Been working for a while on figuring this problem out, but brief searches produced nothing and Verilog syntax guides don't seem to provide any useful information.
I am compiling these two Verilog files together along with another that consists solely of the pre-made gates (ANDs, ORs, NANDs, NORs and NOT) used.

// 2-to-4 Decoder implemented in structural verilog style.
module decoder_2_to_4 (B, A, G, Y0, Y1, Y2, Y3);
input B;
input A;
input G;
output Y0;
output Y1;
output Y2;
output Y3;
wire NOTB;
wire NOTA;

    // Structural verilog style.
NOT u1 (B,NOTB);
NOT u2 (A,NOTA);
AND3 u3 (NOTB,NOTA,G,Y0);
AND3 u4 (NOTB,A,G,Y1);
AND3 u5 (B,NOTA,G,Y2);
AND3 u6 (B,A,G,Y3);

endmodule




`timescale 1 ns / 100 ps

module test_fixture;
reg done;
//  reg [1:0] test_input;   //2 input
reg [2:0] test_input;   //3 input
wire f0, f1, f2, f3;        //Put output wires here

initial
begin
   $dumpfile(""decoders.vcd""); // save waveforms in this file
   $dumpvars;                 // saves all waveforms

   // initialize done signal to 0
   done = 1'b0;
/*
//2 Input Test
   // test 00 case
   test_input[1] = 0;
   test_input[0] = 0;

   // wait 5 ns, then test 001 case
   #5 
   test_input[1] = 0;
   test_input[0] = 1;

   // wait another 5 ns, then test 010 case
   #5
   test_input[1] = 1;
   test_input[0] = 0;

   // wait another 5 ns, then test 011 case
   #5
   test_input[1] = 1;
   test_input[0] = 1;

   // Bogus kluge to extend simulation time for better viewing.
   #5 done = 1'b1;

   $finish;       // finished with simulation
end
*/
// 3 input test

   // test 000 case
   test_input[2] = 0;
   test_input[1] = 0;
   test_input[0] = 0;

   // wait 5 ns, then test 001 case
   #5 
   test_input[2] = 0;
   test_input[1] = 0;
   test_input[0] = 1;

   // wait another 5 ns, then test 010 case
   #5
   test_input[2] = 0;
   test_input[1] = 1;
   test_input[0] = 0;

   // wait another 5 ns, then test 011 case
   #5
   test_input[2] = 0;
   test_input[1] = 1;
   test_input[0] = 1;

   // wait another 5 ns, then test 100 case
   #5
   test_input[2] = 1;
   test_input[1] = 0;
   test_input[0] = 0;

   // wait another 5 ns, then test 101 case
   #5
   test_input[2] = 1;
   test_input[1] = 0;
   test_input[0] = 1;

   // wait another 5 ns, then test 110 case
   #5
   test_input[2] = 1;
   test_input[1] = 1;
   test_input[0] = 0;

   // wait another 5 ns, then test 111 case
   #5
   test_input[2] = 1;
   test_input[1] = 1;
   test_input[0] = 1;


// Instantiate circuit
decoder_2_to_4 u0 (test_input[2], test_input[1], test_input[0], f0, f1, f2, f3);
end
endmodule   // test_fixture




The problem is that when I compile I receive the following errors:

Identifier (decoder_2_to_4) not declared
""test.v"", 94:

syntax error
""test.v', 94: decoder_2_to_4 u0&lt;-


Does anyone have a clue why I am getting this? I really have no idea what is going on, and a nudge in the right direction would certainly help. Thanks in advance.

Edit: To further confirm the compilation error, the prebuilt_gates file (the one not listed) and Decoders.v (the file containing the 2-to-4 Decoder implementation) both compile together just fine without test.v (the second file posted and the one that is noted by the errors.)
Problem is definitely in there somewhere.","The circuit should not be instantiate inside the initial block.

// Instantiate circuit
decoder_2_to_4 u0 (test_input[2], test_input[1], test_input[0], f0, f1, f2, f3);
end
endmodule   // test_fixture


should be:

end
// Instantiate circuit
decoder_2_to_4 u0 (test_input[2], test_input[1], test_input[0], f0, f1, f2, f3);
endmodule   // test_fixture




modules can only be instantiated inside other modules or generated-blocks (and generate-blocks can only be instantiated inside modules). It is illegal to instantiate module in any other manner such as inside a initial-block or always-block.

Instantiating a module inside an initial, always, task, or function will attempt to treat the module as an variable, of which non exists and give an error.

The actual rule itself is spreed out in IEEE Std 1800-2012 Annex A. Look for all the places module_instantiation is used within Annex A.",,,,,
Small change in VHDL register file results in huge difference in total logical elements,"I am new to VHDL and one of my assignments was to create an 8-bit register file. I noticed that by changing a single line of code, I could significantly increase or decrease the total number of logical elements. I am trying to understand why this causes such a significant change.

When enable is high, the register file stores the value of dataIn in the location of selectWrite. dataOut displays the value stored in the location of selectRead.

If dataOut &lt;= entry(readIndex); is placed inside of process(clock), the total number of logical elements used is:

Total logical elements: 9/33,216 ( &lt; 1% )
    Total combinatorial functions 9/33,216 ( &lt; 1% )
    Dedicated logic registers 0/33,216 ( 0% )


However, if dataOut &lt;= entry(readIndex); is placed outside of process(clock) thousands more logical elements are used:

Total logical elements: 2,672/33,216 ( 8% )
    Total combinatorial functions 1,656/33,216 ( 5% )
    Dedicated logic registers 2,048/33,216 ( 6% )


I understand that when placed inside of process(clock), dataOut will only change on the clock edge, and when placed outside of process(clock), dataOut will change unpredictably.

Why does this change cause so many more logic elements to be used?

library ieee;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;

entity RegisterFile is
port(
    clock  : in std_logic;
    reset  : in std_logic;
    dataIn : in std_logic_vector(7 downto 0);
    enable : in std_logic;
    selectRead  : in std_logic_vector(7 downto 0);
    selectWrite : in std_logic_vector(7 downto 0);

    dataOut : out std_logic_vector(7 downto 0)
);
end RegisterFile;

architecture RegisterFileArchitecture of RegisterFile is
    type RegisterEntry is array (0 to 255) of std_logic_vector(7 downto 0);
    signal entry : RegisterEntry;
    signal readIndex  : integer;
    signal writeIndex : integer;
begin
    -- Update read/write indices
    readIndex &lt;= to_integer(unsigned(selectRead));
    writeIndex &lt;= to_integer(unsigned(selectWrite));

    process(clock)
    begin
        if (rising_edge(clock)) then
            -- Update selected data
            dataOut &lt;= entry(readIndex);    

            if (reset = '1') then
                entry(writeIndex) &lt;= ""00000000"";
            elsif (enable = '1') then
                entry(writeIndex) &lt;= dataIn;
            end if; 
        end if;
    end process;
end RegisterFileArchitecture;
","You need to study the FPGA architecture you are using.  When you have a large memory to implement, you most likely want to use the devices dedicated RAM blocks, called Block RAM in Xilinx.  Block RAM has a specific structure - especially with respect to reading and writing with a clock edge vs Asynchronously (combinationaly).  If your code matches it, it will use the Block RAM and very little other logic.  If your code does not match a Block RAM, then you will use logic cells instead.

Look at your report further and see what it reports in each case about block RAM usage.  Look at Xilinx's documentation about the structure of Block RAM.",,,,,
reading the value of input when clk ='1' in the mid way of clk,"I know about rising_edge(clk) and when clk'event and clk ='1'. 
i guess they detect edge.
but lets say i want to read the input when clk is high and in mid way. I guess I am able to write what I want to convey so how can we do that?
If I am not correct please explain.
thanks","In a testbench, or synthesisable into real hardware?

Assuming your clock has period clk_period, declared something like

constant clk_period : time := 100 ns;   -- for 10 MHz
clk &lt;= not clk after  clk_period/2;


you can write testbench code like

wait until rising_edge(clk);
wait for clk_period/4;
value &lt;= my_input;


However this is not synthesisable. In real hardware you need a different approach. Most FPGAs have clock generation modules (PLLs, DLLs, DCMs) which will allow you to generate phase shifted or inverted clocks, and you can use such a block to accomplish your task. More specific suggestions would depend on the actual FPGA you are using, and whether you have any faster clocks available. 

For example, given clk and clk_2x which are phase aligned (so that each clk edge is a clk_2x rising edge) you can use the falling edge of clk_2x while clk is high.

process(clk_2x)
begin   -- capture data
   if falling_edge(clk_2x) then
      if clk = '1' then
         temp &lt;= data_in;
      end if;
   end if;
end process;

process(clk)
begin    -- resynch to main clock domain
   if rising_edge(clk) then
      value &lt;= temp;
   end if;
end process;


Alternative approaches can involve clocking the ADC from delayed, inverted or otherwise modified clocks, or using selectable delays in IOBs on the input data so that the (delayed) data is stable during the clock edge.

This is something that - without really good sim models of the external parts, can be quite tricky to get right in simulation, and needs thorough testing on actual hardware. I have sometimes used phase controllable clocks to external parts and mapped out the range of phases that worked before picking one phase or delay value for production.",,,,,
Errors with Counters in FPGA Resetting (using VHDL),"I am trying to make a design with multiple counters cycling from 0 to 109. However, the counters do not reset at 109, but rather 127 (their max value) when on the FPGA. They do work in simulation though. Below is my code:

speaker_processing_r : process(us_clock)
begin
    if(rising_edge(us_clock)) then   
        if(i_reset = '1') then
            output_counter_r_0 &lt;= 0;
            output_counter_r_1 &lt;= (sample_period);
            output_counter_r_2 &lt;= (sample_period*2);
            output_counter_r_3 &lt;= (sample_period*3);
            output_counter_r_4 &lt;= (sample_period*4);    
            data_r_0           &lt;= X""00"";
            data_r_1           &lt;= X""00"";
            data_r_2           &lt;= X""00"";
            data_r_3           &lt;= X""00"";
            data_r_4           &lt;= X""00"";                                            

        else    

            --Output Conditions based on delays calculated or inserted
            if(output_counter_r_0 = 2) then
                data_r_0 &lt;= shift_register_r(0);
            elsif(output_counter_r_0 = delay_1) then
                data_r_1 &lt;= shift_register_r(0);
            elsif(output_counter_r_0 = delay_2) then
                data_r_2 &lt;= shift_register_r(0); 
            elsif(output_counter_r_0 = delay_3) then
                data_r_3 &lt;= shift_register_r(0);
            elsif(output_counter_r_0 = delay_4) then
                data_r_4 &lt;= shift_register_r(0);
            elsif(output_counter_r_0 = (sample_period*5-1)) then
                output_counter_r_0    &lt;= 0;
            end if;

            if(output_counter_r_1 = 2) then
                data_r_0 &lt;= shift_register_r(1);
            elsif(output_counter_r_1 = delay_1) then
                data_r_1 &lt;= shift_register_r(1);
            elsif(output_counter_r_1 = delay_2) then
                data_r_2 &lt;= shift_register_r(1); 
            elsif(output_counter_r_1 = delay_3) then
                data_r_3 &lt;= shift_register_r(1);
            elsif(output_counter_r_1 = delay_4) then
                data_r_4 &lt;= shift_register_r(1);
            elsif(output_counter_r_1 = (sample_period*5-1)) then
                output_counter_r_1    &lt;= 0;
            end if;

            if(output_counter_r_2 = 2) then
                data_r_0 &lt;= shift_register_r(2);
            elsif(output_counter_r_2 = delay_1) then
                data_r_1 &lt;= shift_register_r(2);
            elsif(output_counter_r_2 = delay_2) then
                data_r_2 &lt;= shift_register_r(2); 
            elsif(output_counter_r_2 = delay_3) then
                data_r_3 &lt;= shift_register_r(2);
            elsif(output_counter_r_2 = delay_4) then
                data_r_4 &lt;= shift_register_r(2);
            elsif(output_counter_r_2 = (sample_period*5-1)) then
                output_counter_r_2    &lt;= 0;
            end if;

            if(output_counter_r_3 = 2) then
                data_r_0 &lt;= shift_register_r(3);
            elsif(output_counter_r_3 = delay_1) then
                data_r_1 &lt;= shift_register_r(3);
            elsif(output_counter_r_3 = delay_2) then
                data_r_2 &lt;= shift_register_r(3); 
            elsif(output_counter_r_3 = delay_3) then
                data_r_3 &lt;= shift_register_r(3);
            elsif(output_counter_r_3 = delay_4) then
                data_r_4 &lt;= shift_register_r(3);
            elsif(output_counter_r_3 = (sample_period*5-1)) then
                output_counter_r_3    &lt;= 0;
            end if;

            if(output_counter_r_4 = 2) then
                data_r_0 &lt;= shift_register_r(4);
            elsif(output_counter_r_4 = delay_1) then
                data_r_1 &lt;= shift_register_r(4);
            elsif(output_counter_r_4 = delay_2) then
                data_r_2 &lt;= shift_register_r(4); 
            elsif(output_counter_r_4 = delay_3) then
                data_r_3 &lt;= shift_register_r(4);
            elsif(output_counter_r_4 = delay_4) then
                data_r_4 &lt;= shift_register_r(4);
            elsif(output_counter_r_4 = (sample_period*5-1)) then
                output_counter_r_4    &lt;= 0;
            end if;

            output_counter_r_0 &lt;= output_counter_r_0 +1;
            output_counter_r_1 &lt;= output_counter_r_1 +1;
            output_counter_r_2 &lt;= output_counter_r_2 +1;
            output_counter_r_3 &lt;= output_counter_r_3 +1;
            output_counter_r_4 &lt;= output_counter_r_4 +1;

        end if;     
    end if;
end process;


All of the delay (delay_1, delay_2, delay_3, delay_4) signals are generics as well as sample_period. The period of us_clock is 1 microsecond. Any insight as to why they do not reset is appreciated.","I see one obvious problem and one potential problem.

First, as you are assigning output_counter_r_* &lt;= output_counter_r_* + 1 at the end of the process, these take precedence over the assignments within the if blocks (see How does signal assignment work in a process?). The counter signal assignment doesn't ""take effect"" until the process completes here, so anything before those increment statements will be ignored. I'm surprised it worked in sim, actually. What simulator are you using?

The second potential problem is that the rollover condition of the counter is contingent on none of the preceding if-conditions being true. Is this intentional? It shouldn't be an issue unless any delay_* happens to be equal to sample_period*5-1, but you may want to try splitting it as:

if(output_counter_r_0 = 2) then
  data_r_0 &lt;= shift_register_r(0);
elsif(output_counter_r_0 = delay_1) then
  data_r_1 &lt;= shift_register_r(0);
elsif(output_counter_r_0 = delay_2) then
  data_r_2 &lt;= shift_register_r(0); 
elsif(output_counter_r_0 = delay_3) then
  data_r_3 &lt;= shift_register_r(0);
elsif(output_counter_r_0 = delay_4) then
  data_r_4 &lt;= shift_register_r(0);
end if;

if(output_counter_r_0 = (sample_period*5-1)) then
  output_counter_r_0    &lt;= 0;
else
  output_counter_r_0 &lt;= output_counter_r_0 +1;
end if;


(Unless that's not the function you intended.)

Edit for further explanation

Basically, in a process in VHDL, signals are only assigned when the process suspends/waits (i.e., for normal processes, at the end), which means that only the last assignment to the signal is used. This is useful for several reasons that I won't get into here, but the result is that since you're always incrementing the counters at the end of the process, anything else you've done to them earlier in the process will be ignored. You can code it the way I've shown above, unless it was intentional that your rollover condition was dependent on the other counter comparisons - ""if = 2, do this, otherwise if = delay_1 do this, ... otherwise if it's at the limit, roll it over."" With that logic, the counter will only roll over if none of the other conditions is true.

If this was intentional, the easiest solution would just be to move the increments to the beginning of the process, so they would be overridden by the rollover checks. An alternate (perhaps safer?) solution would be modifying the second if block above to explicitly check for exactly what conditions you want. Up to you.",,,,,
Converting C Macro to VHDL,"I'm fairly new to VHDL and trying to convert two given C macros to be executed as a single instruction on my FPGA. The macros are:

#define m_in_bits(buf, num) (buf) &gt;&gt; (24 - (num)) // buf is uint32_t
#define m_ext_bits(buf, i) ((buf) &lt; (1&lt;&lt;((i)-1)) ? (buf) + (((-1)&lt;&lt;(i)) + 1) : (buf))


And the C code that uses the macros is:

m_ext_bits(m_in_bits(buffer, size), size);


I'm having issues with getting m_ext_bits to properly compile. Here's my VHDL:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity myEntity is
port(
  signal buffer: in std_logic_vector(31 downto 0);
  signal result: out std_logic_vector(31 downto 0)
);
end entity myEntity;

architecture myArch of myEntity  is
  signal size : signed (3 downto 0);
begin

size &lt;= signed(buffer(27 downto 24));

result(15 downto 0) &lt;= std_logic_vector(signed(buffer(23 downto 0)) srl (24 - to_integer(size))
                     + signed((-1 sll to_integer(size)) + 1)); -- the offending line

end architecture myArch ;


The long line beginning with result(15 downto 0) &lt;= actually compiles without error (that implements the m_in_bits macro). However, when I add the following line, beginning with the +, errors occur. I tried playing around with casting the std_logic_vector and signed types and the errors change.


  type of expression is ambiguous - ""SIGNED"" or ""UNSIGNED"" are two possible matches...
  can't determine definition of operator """"sll"""" -- found 0 possible definitions...
  illegal SIGNED in expression...


I think it's a matter of proper casting and using the correct types to fulfill the required operations.","First, buffer is a reserved VHDL word, so change that; using argbuf below.

The expression -1 sll to_integer(size) is not defined in VHDL, since the
integer value -1 is a numerical expression only with no bit representation
specified by VHDL, so shifting is not possible.  Neither are operations like
bitwise and, or, etc. on integers.  A -1 representation in 24-bit signed type can be created as:

to_signed(-1, 24)


There is a length issue with the assign, since 16-bit signal (result(15 downto
0)) is assigned with 24-bit value (based on right side argbuf(23 downto 0)).

The srl should then compile when the above is addressed.

Code as:

result(15 downto 0) &lt;= std_logic_vector(resize((signed(argbuf(23 downto 0)) srl (24 - to_integer(size)))
                                               + signed((to_signed(-1, 24) sll to_integer(size)) + 1), 16));


However, the VHDL shift operators, e.g. srl, may give unexpected results, as
described in this page ""Arithmetic and logical shifts and rotates are done with
functions in VHDL, not
operators"",
so you may consider using the shift functions defined in numeric_std instead,
e.g. shift_right, as a general coding style.  Code with functions as:

result(15 downto 0) &lt;= std_logic_vector(resize(shift_right(signed(argbuf(23 downto 0)), 24 - to_integer(size))
                                               + signed(shift_left(to_signed(-1, 24), to_integer(size)) + 1), 16));
",,,,,
VHDL: Concat inout std_logic into std_logic_vector signal,"I have several tri-stateable (inout) std_logic port pins defined in my top-level port declaration. I have a dedicated internal component that is needing to utilize these, but its port is defined as having an inout std_logic_vector (not my code and I can't change), which I need to concatenate my std_logic into a std_logic_vector to make it happy.

The problem is: I'm not sure how to do this. 

I thought that ALIAS would be the correct route, but apparently the concatenation operator can't be used when defining an alias.

Then I thought I'd just use a std_logic_vector internal signal:

mySignal &lt;= inOutBit2 &amp; inOutBit1 &amp; inOutBit0; --Input route

componentPort =&gt; mySignal, --Component use

inOutBit2 &lt;= mySignal(2);
inOutBit1 &lt;= mySignal(1);
inOutBit0 &lt;= mySignal(0); --Output route


but this would not synthesize as it viewed inOutBitn as having multiple drivers. 

Is there anything I can do to get this to synthesize? I know I can just declare my top-level inout port to be a std_logic_vector, but that is sub-optimal as we have a a well defined port-labeling convention.","Based on your description, I understand that both the top-level ports and the component ports are mode inout.  

If this is so, then it may help if you connect the component ports directly to the external inout ports at std_logic level, like:

componentPort(0) =&gt; inOutBit0,  --Component use
componentPort(1) =&gt; inOutBit1,  --Component use
componentPort(2) =&gt; inOutBit2,  --Component use


The intermediate mySignal is then not required.

However, the description says that synthesis reports multiple drivers for inOutBitn, but I would expect that it reported multiple drivers for mySignal in the original code.",,,,,
Test a signal's existance from its name written in a string,"I'm having a problem with modelsim and I'm not even sure that a solution exists.

For one of my projects, I have to drive (and spy) some testbench signals with text files as input. I want to use *init_signal_drive* and *init_signal_spy* procedure to keep signal names (in text files) as string.

The problem is : if the name in the text file doesn't fit the actual name of the signal in the testbench, functions *init_signal_xxx* will fail without lots of information.

What I want to do is to test the existance of the signal from its ""string"" name before calling the *init_signal_xxx* procedure.

Does anyone know if it's possible and how to do it ?

A second solution for my problem would be to catch the state of the *init_signal_xxx* procedure (passed or failed), but I'm not sure it's possible anyway.

Thanks a lot","If you wanted, you could make a record with strings to 'wrap' around your actual signal. This is a little kludgey, but it is hard for me to think of another way, short of head-hurting magic with files that would be even worse in VHDL. So:

type stdWithName is
     record
         name : String;
         value : std_logic;
end record;


you could then initialize this like:

signal val : std_logic := '0';
signal withName : stdWithName := (""withName"",val);


and compare the name like

if (withName.name = ""withName"") then
      -- huzzah! a match. 
end if;
",,,,,
finding power of a number,"I have a very big number which is a product of several small primes. I know the number and also I know the prime factors but I don't know their powers. for example:

(2^a)x(3^b)x(5^c)x(7^d)x(11^e)x .. = 2310


Now I want to recover the exponents in a very fast and efficient manner. I want to implement it in an FPGA.

Regards,","The issue is that you are doing a linear search for the right power when you should be doing a binary search. Below is an example showing how to the case where the power of p is 10 (p^10). This method finds the power in O(log N) divisions rather than O(N).

First find the upper limit by increasing the power quickly until it's too high, which happens at step 5. Then it uses a binary search to find the actual power.


Check divisibility by p. Works.
Check divisibility by p^2. Works.
Check divisibility by p^4. Works.
Check divisibility by p^8. Works.
Check divisibility by p^16. Doesn't work. Undo/ignore this one.
Check divisibility by p^((8+16)/2)=p^12. Doesn't work. Undo/ignore this one.
Check divisibility by p^((8+12)/2)=p^10. Works, but might be too low.
Check divisibility by p^((10+12)/2)=p^11. Doesn't work. Undo/ignore this one.
Since ((10+11)/2)=10.5 is not an integer, the power most be the low end, which is 10.


Note, there is a method where you actually divide by p, and at step 4, you've actually divided the number by p^(1+2+4+8)=p^15, but it's a bit more difficult to explain the binary search part. However, the size of the number being divided gets smaller, so division operations are faster.",,,,,
Find the combinations of 2 1's in a binary number,"We have a binary number and we need to generate combination of 2 1's from the given number. If given such a combination of 2 1's we should be able to produce the next combination.

Example:-

Given vector   : 10101111 Given combination : 10100000 output       : 10001000
Given vector   : 10101111 Given combination : 10001000 output       : 10000100
Given vector   : 10101111 Given combination : 10000010 output       : 10000001
Given vector   : 10101111 Given combination : 10000001 output       : 00101000
Given vector   : 10101111 Given combination : 00101000 output       : 00100100


Edit:
Once the 2nd 1 reaches the last 1 in the given binary number, the 1st 1 is incremented(set to next '1' in the binary number and the 2nd '1' is made the '1' that comes after the 1st '1'(as in eg 4))

This is to be done in hardware so it should not be computationally complex. How can we design this module in VHDL.","Here is some asynchronous code that will do the job:



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity nex2ones is
    Port ( vector : in   STD_LOGIC_VECTOR (1 to 8);
           combo1 : in   STD_LOGIC_VECTOR (1 to 8);
           combo2 : out  STD_LOGIC_VECTOR (1 to 8);
           error  : out  STD_LOGIC);
end nex2ones;

architecture Behavioral of nex2ones is

type int_array_8 is array (1 to 8) of integer range 0 to 8;

begin

process (vector,combo1)

variable ones_ixs        : int_array_8; 
variable first_combo1_ix : integer range 0 to 8 := 0;
variable second_combo1_ix: integer range 0 to 8 := 0;
variable first_combo1_k  : integer range 0 to 9 := 0;
variable second_combo1_k : integer range 0 to 9 := 0;
variable k               : integer range 1 to 9;

begin

ones_ixs := (others =&gt; 0); -- indices of 1s in vector
combo2   &lt;= (others =&gt; '0');
k := 1;
first_combo1_ix  := 0;
second_combo1_ix := 0;
first_combo1_k   := 0;  -- corresponding ptr to ones_ixs
second_combo1_k  := 0;
error            &lt;= '0';

for j in 1 to 8 loop

  if combo1(j) = '1' then
      if first_combo1_ix = 0 then
        first_combo1_ix := j;   
        first_combo1_k := k;
      else
        second_combo1_ix := j;
        second_combo1_k := k;
      end if;
  end if;

  if vector(j) = '1' then
    ones_ixs(k) := j; 
    k := k + 1;
  end if;

end loop;  

if k &gt; 1 then k := k - 1; end if; -- point to last nonzero index

if (first_combo1_ix = 0 or second_combo1_ix = 0)
  --or (first_combo1_ix = ones_ixs(k-1) and second_combo1_ix = ones_ixs(k)) 
  or (k &lt; 2) then 
  error &lt;= '1';
else -- no error proceed
  if second_combo1_ix = ones_ixs(k) then              -- can't slide 2nd anymore
    if (second_combo1_k - first_combo1_k) &gt; 1 then    -- is 1st movable
        combo2(ones_ixs(first_combo1_k + 1)) &lt;= '1';    -- move 1st
        if (second_combo1_k - first_combo1_k) &gt; 2 then  -- is 2nd movable
          combo2(ones_ixs(first_combo1_k + 2)) &lt;= '1'; -- move 2nd
        else
          combo2(ones_ixs(second_combo1_k)) &lt;= '1';     -- leave 2nd be
        end if;
      else
        error &lt;= '1'; -- no mas
      end if;
  else
    combo2(ones_ixs(first_combo1_k)) &lt;= '1';      -- leave 1st be
      combo2(ones_ixs(second_combo1_k + 1)) &lt;= '1'; -- next
  end if;
end if;

end process;

end Behavioral;




Testbench output:

   ps       vector   combo1   combo2        
                                   error      
      0     00000000 00000000 00000000 1 
 100000     10101111 10100000 10001000 0 
 200000     10101111 10001000 10000100 0 
 300000     10101111 10000010 10000001 0 
 400000     10101111 10000001 00101000 0 
 500000     10101111 00101000 00100100 0 
 600000     10101111 00100100 00100010 0 
 700000     10101111 00000011 00000000 1 
 800000     11001110 00000110 00000000 1 
 900000     10001110 00001010 00000110 0 
1000000     11001110 00001010 00000110 0 
",,,,,
VHDL: how do I perform multiple things for one case?,"I am getting this error message which i don't understand for this codepiece

Segmentvalue: process(Anode,counter_1r, counter_10r,counter_100r, counter_1000r)
begin
case anode is 
when  0 =&gt; An &lt;= ""1110"" &amp;&amp; segment &lt;= counter_1r;
when    1 =&gt; AN &lt;= ""1101"" &amp;&amp; segment &lt;= counter_10r;
when    2 =&gt; An &lt;= ""1011"" &amp;&amp; segment &lt;= counter_100r;
When  3 =&gt; An &lt;= ""0111"" &amp;&amp; segment &lt;= counter_1000r;
when others =&gt; null;
end case;

end process;


It's likely because of the use of &amp;&amp; which usually used in c++ when multiple things have to be done, but how is it vhdl?","Try this

Segmentvalue: process(Anode,counter_1r, counter_10r,counter_100r, counter_1000r)
begin
case anode is 
when  0 =&gt; An &lt;= ""1110""; segment &lt;= counter_1r;
when    1 =&gt; AN &lt;= ""1101""; segment &lt;= counter_10r;
when    2 =&gt; An &lt;= ""1011""; segment &lt;= counter_100r;
When  3 =&gt; An &lt;= ""0111""; segment &lt;= counter_1000r;
when others =&gt; null;
end case;

end process;
",,,,,
Finding an unused index in a Verilog array?,"I am writing a Verilog module that needs to maintain an array. Each index can be used or unused. I am providing an interface into the module to allow a client to request a resource. I want the module to be able to lookup the next unused index &amp; use that index to allocate that resource to a client. 

I am stuck on the best way to find an unused index in Verilog. Does it make sense to stick the unused indexes in a FIFO? Or when a resource is requested, to iterate through the array to find the first unused one? Is there some other, better, Verilog pattern for handling this?

Thanks.","As with all things the answer is ""it depends""!  Some things to consider:


What is your synthesis target and what resources are available?
How large is the array?
Is the array a contiguous block of memory?
How frequently do requests occur?
How quickly must the response be provided?
What clock frequency are you aiming for?
Where are you aiming in optimised implementation vs. time to market vs. device resource usage?


Without knowing the above it's impossible to provide a definite answer, however below are a few techniques you could consider.  Clearly if you can exploit some property of your particular use case there may be some optimisations (as @dwikle states in some cases a simple FIFO would be sufficient).

Register Bitmask

Maintain a bitmask of populated entries.  This works OK for for smaller arrays where it's acceptable to use a 1-bit register for each array location.

If you need single cycle response times and must handle consecutive back-to-back requests then you can derive the next free index using a bitscan followed by a onehot to binary coder.  This is often used for arbitration or interrupt masking and you can find code snippets and explanations in the Altera Advanced Synthesis Cookbook optimised for (previous generation) FPGAs.

This won't scale well to large arrays, but you can pipeline over multiple cycles if you don't to handle need back-to-back requests in a single cycle.

Memory

If your target provides memory blocks and your array size is large then you can utilise a memory block to store the state.  Again there are a couple of ways to do it:

Store a populated flag

Similar to using a register, just use a single bit flag for each memory.  This will scale to support large arrays.  To find the next free entry you perform a search through the memory.  Typically you'd read a wide slice (say 64 bits) and then scan that vector in a single cycle using the bitscan technique above, thus your maximum search time is ARRAY_SIZE/64.  You can also build more interesting capabilities in this way, for example a CAM.

Store addresses of array locations

This has the advantage that your array doesn't necessarily need to be contiguous in memory.  The simplest way to manage this is simply have a FIFO of unused addresses and a FIFO of used addresses. This is not the most efficient mechanism but makes the logic simplistic (allocating and freeing entries is simply a case of reading an address from one FIFO and writing to the other).",,,,,
"VHDL: Type of ""variable"" is incompatible with type of <=","Could some explain why i get syntax error with this piece of code..

An &lt;= ""1110"" when anode = ""00"" else
AN &lt;= ""1101"" when anode = ""01"" else
An &lt;= ""1011"" when anode = ""10"" else 
An &lt;= ""0111"" when anode = ""11"";

segment &lt;= counter_1r    when anode = ""00"" else
segment &lt;= counter_10r   when anode = ""01"" else
segment &lt;= counter_100r  when anode = ""10"" else
segment &lt;= counter_1000r When anode = ""11"";


it says 

ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 181. Type of An is incompatible with type of &lt;=.
ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 182. Type of An is incompatible with type of &lt;=.
ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 183. Type of An is incompatible with type of &lt;=.
ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 181. Type of An is incompatible with type of &lt;=.
ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 182. Type of An is incompatible with type of &lt;=.
ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 183. Type of An is incompatible with type of &lt;=.
ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 186. Type of segment is incompatible with type of &lt;=.
ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 187. Type of segment is incompatible with type of &lt;=.
ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 188. Type of segment is incompatible with type of &lt;=.
ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 186. Type of segment is incompatible with type of &lt;=.
ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 187. Type of segment is incompatible with type of &lt;=.
ERROR:HDLParsers:800 - ""C:/.Xilinx/Stopur/main.vhd"" Line 188. Type of segment is incompatible with type of &lt;=.


Which i Don't understand, because In my code i've set all the affected element in my entity to be output, they are all using the same type. 

PORT(
    CLK: in std_logic;
--  LED: out std_logic_vector (7 downto 0);
--  Switch: in std_logic_vector(7 downto 0);
    Segment: out std_logic_vector (7 downto 0); 
    AN: out std_logic_vector (3 downto 0) 
);
end Main;

architecture Behavioral of Main is
    signal counter_1000:  integer range 0 to 9;
    signal counter_100:   integer range 0 to 9;
    signal counter_10:    integer range 0 to 9;
    signal counter_1:     integer range 0 to 9;
    signal counter_1r:    std_logic_vector(7 downto 0);
    signal counter_10r:   std_logic_vector(7 downto 0);
    signal counter_100r:  std_logic_vector(7 downto 0);
    signal counter_1000r: std_logic_vector(7 downto 0);
    signal prescaler:     integer range 0 to 50000000;
    signal limit:         integer range 0 to 50000000;
    signal Anode:         std_logic_vector(1 downto 0);
begin
","To see why you get the error message, look at your code like this:

An &lt;= ""1110"" when anode = ""00"" else (AN &lt;= ""1101"")....


The else clause will be compiled as a comparison of AN with 1101 to see if it's less-than-or-equal-to.  Which is of type boolean, which is incompatible with the type of An, a vector.  (I wish VHDL hadn't picked &lt;= as an assignment operator, but there we are!)

The syntax you need is more like this (note the lack of &lt;= on the other lines)

An &lt;= ""1110"" when anode = ""00"" else
      ""1101"" when anode = ""01"" else
      ""1011"" when anode = ""10"" else    
      ""0111"" when anode = ""11"" else
      null;
",,,,,
From Assembler to C-Compiler,"i designed a small RISC in verilog. Which steps do I have to take to create a c compiler which uses my assembler-language? Or is it possible to modify a conventional compiler like gcc, cause I don't want to make things like linker, ...

Thanks","You need to use an unmodified C lexer+parser (often called the front end), and a modified code generation component (the back end) to do that. 

Eli Bendersky's pycparser can be used as the front end, and Atul's mini C compiler can be used as inspiration for the code generating back end: http://people.cs.uchicago.edu/~varmaa/mini_c/

With Eli Bendersky's pycparser, all you need to do is convert the AST to a Control Flow Graph (CFG) and generate code from there. It is easier to start with supporting a subset of C than the full shebang.

The two tools are written in Python, but you didn't mention any implementation language preferences :)

I have found most open sourcen compilers (except clang it seems) too tightly coupled to easily modify the back end. Clang and especially GCC are not easy to dive into, nowhere NEAR as easy as the two above. And since Eli's parser does full C99 (it parses everything I've thrown at it) it seem like a nice front end to use for further development.
The examples on the Github project demonstrates most of the features of the project and it's easy to get started. The example that parses C to literal English is worth taking a look at, but may take a while to fully grok. It basically handles any C expression, so it is a good reference for how to handle the different nodes of the AST.

I also recommended the tools above, in my answer to this question: Build AST from C code",,,,,
FSM model of FIR filter,"I want to make a FSM model of FIR, for that I need to write FIR calculation code line in FSM implementation.

Here is the actual and correct code for FIR 

entity fir_4tap is
  port(   Clk : in std_logic; --clock signal
          Clk_fast : in std_logic;
          --  Xin : in signed(7 downto 0); --input signal
          bit_in : in std_logic;
          bit_out : out std_logic;
          Yout : out signed(15 downto 0)  --filter output
  );
end fir_4tap;

architecture Behavioral of fir_4tap is
  signal add_out3 : signed(15 downto 0) := (others =&gt; '0');
  signal index : unsigned(2 downto 0) := (others =&gt;'0');
  signal counter : unsigned(3 downto 0) := (others =&gt; '0');
  signal p : unsigned(1 downto 0) := (others =&gt; '0');
  signal k : unsigned(1 downto 0) := (others =&gt; '0');
  signal j : unsigned(1 downto 0) := (others =&gt; '0');
  type array_signed is array(8 downto 0) of signed(7 downto 0);
  signal z : array_signed := (others =&gt; ""00000000"");
  type array_signed1 is array(3 downto 0) of signed(7 downto 0);
  signal H : array_signed1 := (others =&gt; ""00000000"");
  signal Xin : array_signed1 := (others =&gt; ""00000000"");
begin
  z(0) &lt;= to_signed(-3,8);
  z(1) &lt;= to_signed(1,8); 
  z(2) &lt;= to_signed(0,8);
  z(3) &lt;= to_signed(-2,8);
  z(4) &lt;= to_signed(-1,8); 
  z(5) &lt;= to_signed(4,8); 
  z(6) &lt;= to_signed(-5,8);
  z(7) &lt;= to_signed(6,8); 
  z(8) &lt;= to_signed(0,8);
  H(0) &lt;= to_signed(-2,8);
  H(1) &lt;= to_signed(-1,8);
  H(2) &lt;= to_signed(3,8);
  H(3) &lt;= to_signed(4,8);

  process (clk) 
  begin
    if (rising_edge(Clk)) then 
      index &lt;= index +1;
      if (index = ""111"") then 
        Xin(to_integer(p)) &lt;= z(to_integer(counter));                                              k &lt;= p;
        p &lt;= p + 1;
        ***-- This part of the code has problem, I want to write the line which is summing --up for add_out3 in a for loop.***
        add_out3 &lt;= (others =&gt; '0');
        add_out3 &lt;=  Xin(to_integer(k))*H(to_integer(j)) + Xin(to_integer(k-1))*H(to_integer(j+1)) + Xin(to_integer(k-2))*H(to_integer(j+2)) + Xin(to_integer(k-3))*H(to_integer(j+3));
        Yout &lt;= add_out3;
      end if;
    end if;
  end process;
end Behavioral;


Now Below is the FSM implementation try by me but not getting the same out sample as input can somebody tell me what could be the problem in the code?

----------------FSM implementation of the FIR filter ----------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;


entity test is
port(   Clk : in std_logic; --clock signal
          Clk_fast : in std_logic;
          bit_in : in std_logic;
          bit_out : out std_logic;
        Yout : out signed(15 downto 0)  --filter output
        );


end test;

architecture Behavioral of test is
signal data_buffer : signed(7 downto 0) := (others =&gt; '0');
signal index : unsigned(2 downto 0) := (others =&gt;'0');


signal counter : unsigned(3 downto 0) := (others =&gt; '0');

type array_signed is array(8 downto 0) of signed(7 downto 0);
signal z : array_signed := (others =&gt; ""00000000"");

type array_signed1 is array(3 downto 0) of signed(7 downto 0);
signal H : array_signed1 := (others =&gt; ""00000000"");

signal input : signed(7 downto 0) := (others =&gt; '0');

type MULT_TYPE is array(3 downto 0) of signed(15 downto 0);
signal MULT_array : MULT_TYPE := (others =&gt; ""0000000000000000"");

type ADD_TYPE is array(3 downto 0) of signed(15 downto 0);
signal ADD_array : ADD_TYPE := (others =&gt; ""0000000000000000"");

constant ZERO : signed(15 downto 0) := (others =&gt; '0');

type state_type is (s0,s1,s2,s3);  --type of state machine.
signal current_s : state_type := s0;  --current and next state declaration.
signal next_s : state_type := s0; 

signal reset : std_logic := '0';
signal go : std_logic := '0';
signal change_state : std_logic := '0' ;
signal counter_FSM_monitor : unsigned( 6 downto 0) := ""0000000""; 

begin

z(0) &lt;= to_signed(-3,8);
z(1) &lt;= to_signed(1,8); 
z(2) &lt;= to_signed(0,8);
z(3) &lt;= to_signed(-2,8);
z(4) &lt;= to_signed(-1,8); 
z(5) &lt;= to_signed(4,8); 
z(6) &lt;= to_signed(-5,8);
z(7) &lt;= to_signed(6,8); 
z(8) &lt;= to_signed(0,8);

H(0) &lt;= to_signed(-2,8);
H(1) &lt;= to_signed(-1,8);
H(2) &lt;= to_signed(3,8);
H(3) &lt;= to_signed(4,8);




process (Clk) is
begin
if falling_edge(Clk) then 

data_buffer(to_integer(index)) &lt;= bit_in;
index &lt;= index +1;
if (index = ""111"") then 
input &lt;= z(to_integer(counter));

counter &lt;= counter + 1;
if(counter = ""1000"") then 
counter &lt;= ""0000"";
end if; 
end if;
end if;
end process;


process (clk_fast)
begin

if (falling_edge(clk_fast)) then

counter_FSM_monitor &lt;= counter_FSM_monitor + 1;

if( to_integer(counter_FSM_monitor) = 76) then 
counter_FSM_monitor &lt;= ""0000000"";
end if;

case change_state is 

when '1' =&gt; 
current_s &lt;= next_s;   --state change.                 

when '0' =&gt; --current_s &lt;= s0;                 
when others =&gt;
end case;
end if;
end process;

Process(current_s,input)
begin 
if ( to_integer(counter_FSM_monitor) &lt; 64 ) then 
-- waiting for the Input
elsif (to_integer(counter_FSM_monitor) &gt;= 64 and to_integer(counter_FSM_monitor) &lt; 76) then 


---------------------------------------------- FSM ----------------------------------------


case current_s is 

when s0 =&gt; 
mult_array(0) &lt;= input*H(3);
ADD_array(0) &lt;= ZERO + mult_array(0);
next_s &lt;= s1;
change_state &lt;= '1';

when s1 =&gt; 
mult_array(1) &lt;= input*H(2);
ADD_array(1) &lt;= mult_array(1) + ADD_array(0);
next_s &lt;= s2;
change_state &lt;= '1';

when s2 =&gt; 
mult_array(2) &lt;= input*H(1);
ADD_array(2) &lt;= mult_array(2) + ADD_array(1);
next_s &lt;= s3;
change_state &lt;= '1';

when s3 =&gt; 
mult_array(3) &lt;= input*H(0);
ADD_array(3) &lt;= mult_array(3) + ADD_array(2);
Yout &lt;= ADD_array(3);
next_s &lt;= s0;
change_state &lt;= '1';

when others =&gt; 
next_s &lt;= s0;-- never comes here
change_state &lt;= '1';
end case;
---------------------------------------------- FSM ----------------------------------------
end if;
end process;
end Behavioral;


How ever I am not able to receive the same output which I received by the first code.
FSM code gives the correct output for the first out but from the second out sample it gives wrong result.Can somebody tell me what I am doing wrong ? ","This answer is for the initial version of the question but Now question has been changed.
Made add_out3 a variable instead of a signal.

for i in 0 to 3 loop 
add_out3 := add_out3 + Xin(k-i)*H(i); 
end loop;


Did the above changes in the for loop It works fine.
So the code in my question is a correct code for FIR also, works smoothly.
Learnt that one needs to be very careful while using signal or variables. All the signals get a new value at the same time i.e at the end of clock period, while in variables values gets updated as assigned within a process. Tried to run the simulation step by step and figured out the problem.",,,,,
creating a constant vector of variable width in verilog,"I'm writing some synthesizable Verilog. I need to create a value to use as a mask in a larger expression. This value is a sequence of 1's, when the length is stored in some register:

buffer &amp; {offset{1'h1}}; 


where buffer and offset are both registers. What I expect is for buffer to be anded with 11111... of width offset. However, the compiler says this illegal in verilog, since offset needs to be constant. 

Instead, I wrote the following:

buffer &amp; ~({WIDTH{1'h1}} &lt;&lt; offset)


where WIDTH is a constant. This works. Both expressions are equivalent in terms of values, but obviously not in terms of the hardware that would be synthesized. 

What's the difference?","The difference is because of the rules for context-determined expressions (detailed in sections 11.6 and 11.8 of the IEEE 1800-2017 LRM) require the width of all operands of an expression be known at compile time. 

Your example is too simple to show where the complication arises, but let's say buffer was 16-bit signed variable. To perform bitwise-and (&amp;), you first need to know size of both operands, then extend the smaller operand to match the size of the larger operand. If we don't know what the size of {offset{1'h1}} is, we don't know whether it needs to 0-extended, or buffer needs to be sign-extended. 

Of course, the language could be defined to allow this so it works, but synthesis tools would be creating a lot of unnecessary additional hardware. And if we start applying this to more complex expressions, trying to determine how the bit-widths propagate becomes unmanageable.",,,,,
Do outputs declared in output and reg both have to have number of bits?,"Are these two lines of code in verilog the same?


output[1:0] r;

reg[1:0] r;
output[1:0] r;

reg r;


Do the number of bits have to be declared twice?","No. No No.

Verilog offers a few styles of declaring ports. The recommend way is known as ANSI-style, where you only mention the port name once.

module m(output reg [1:0] r, input clk);


It unfortunate that this style does not appear first in the LRM.
And, yes using the style in your question requires that the bit widths match.",,,,,
Wait for input state change to start process,"I'm programming a Coolrunner2 (XC2C64A) CPLD with the ISE Project Navigator software. For now, it should only act as a logical or gate (output = o_buzzer) between a pin from a PIC32 (input = i_pic) and a RPi CM3 (input = i_cm). 

o_buzzer &lt;= i_pic or i_cm;

The problem is that when the power supply gets connected, the pins of the PIC32 are configured as inputs so the CPLD sees it as high impedance (Z) and outputs a 1 untill the pins are configured. So I'm trying to let the CPLD wait untill i_pic isn't Z anymore.

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity or_gate is
    Port ( i_pic : in  STD_LOGIC;
           i_cm : in  STD_LOGIC;
           o_buzzer : out  STD_LOGIC);
end or_gate;

architecture Behavioral of or_gate is

begin

    process_or : process(i_pic,i_cm)

    begin

        while (i_pic = 'Z') loop

        end loop;

        o_buzzer &lt;= i_pic or i_cm;
    end process process_or;

end Behavioral;


This gives me a warning: 


  line 46: Loop body will iterate zero times.


And when implementing it doesn't work. Buzzer still beeps till the pins are initialized.

Using the while loop:

while (i_pic = 'Z') loop
    o_buzzer &lt;= '0';
end loop;


Gives me:


  Loop has iterated 64 times. Use ""set -loop_iteration_limit XX"" to iterate more.""


How can I let the process wait untill i_pic is logical low and not Z anymore?","You cannot test for 'Z' in synthesisable code. You can test for a '1' (or 'H') or for a '0' (or 'L'). You cannot test for a 'Z'. What hardware would do this? Some kind of analogue hardware, not some kind of digital hardware. That is why you cannot test for 'Z' in synthesisable code.",,,,,
How are OpenCL work-group scheduled on Intel FPGA?,"I have a question about work-group scheduling on multiple CUs in Intel FPGA. As work-groups are assigned to available CUs, when is a CU considered available? Is it when the last work-item of the previous work-group has abandonedâ€?the pipeline or when it is at its second stage (so every stage of the pipeline is occupied by the previous work-group except the first one)? This decision is taken by the hardware scheduler, but I haven't found any public documentation explaining any of this.

Edit: I'm talking about the automatic process that takes place when using Intel OpenCL SDK for FPGA, not a custom design with HDL.","Apart from work-items, work-groups are also pipelined in each CU. Hence, you have multiple work-groups in-flight in the same CU at the same time, to maximize pipeline efficiency. If your design uses local-memory-based buffers, when you check the HTML report, you will see that the compiler is further replicating those buffers to support a specific number of ""Simultaneous Work-groups"". The number of such work-groups seems to be equal to pipeline depth per CU divided by work-group size. In the end, all work-item from all work-groups running simultaneously in the same CU are pipelined one after another, with work-items belonging to each CU using their own local buffers, and barrier synchronization being enforced per work-group. A new work-group will be scheduled in each CU, probably after one of the simultaneously-running work-groups has completely left the CU.

P.S. It is probably easier to get help related to Intel FPGA SDK for OpenCL in their own forum.

P.P.S. The details of Intel's OpenCL work-item scheduler is not documented anywhere.",,,,,
Verilog DUT System Verilog testbench: output to wire assignment 1s replaced with Xs,"I have a Modelsim testbench in System Verilog testing a Verilog top-level module (ufm1) with another Verilog module (wishbone) used inside it, there's also a System Verilog &quot;stub&quot; (wishbone_sim) that is connected to the DUT in the testbench.
The DUT and the inner module were originally in System Verilog and worked fine but I had to convert them to Verilog to be able to use Diamond LSE (leaving the testbench in System Verilog)
The inner module inside the DUT has an output which I'm connecting to a wire (was originally a reg in the System Verilog version because it gave an error otherwise) inside the DUT and then using the wire to assign to a reg in a procedural block inside the DUT.
Inside the inner module this output is basically assigned directly from an input.
Now when I'm simulating this the input in the inner module is fine but the output (should be the same because it is a direct assign) is different with Xs in place of 1s.
The issue only starts appearing when the output of the inner module (rd_data) is assigned to the wire (wb_rd_data), which looks strange to be because I don't see how connecting an output port to a wire would affect its value.
The wire inside the DUT is wb_rd_data which is connected to the rd_data port of the inner wishbone module.
How do I fix this?
DUT:
module ufm1(clk, ufm_wr_rq, ufm_rd_rq, ufm_wr_data, ufm_wr_ack, ufm_rd_data, ufm_rd_ack, ufm_done, wb_clk, wb_rst, wb_cyc, wb_stb, wb_we, wb_addr, wb_dat_i, wb_dat_o, wb_ack);

input clk;
input ufm_wr_rq, ufm_rd_rq;
input [7:0] ufm_wr_data;
output reg ufm_wr_ack;
output [7:0] ufm_rd_data;
output ufm_rd_ack;
output reg ufm_done = 0;

output wb_clk;
output wb_rst;
output wb_cyc;
output wb_stb;
output wb_we;
output [7:0] wb_addr;
output [7:0] wb_dat_i;
input [7:0] wb_dat_o;
input wb_ack;

      parameter WR_OF = 8'h10;
      parameter WR_CF = 8'h11;
      parameter WR = 8'h12;
      parameter WRE = 8'h13;
      parameter RD = 8'h20;
      parameter RDI = 8'h21;
      parameter JMPI = 8'h30;
      parameter END = 8'h40;

      parameter Z00 = 8'h00;
      parameter FF = 8'hFF;

      parameter WR_CMDS = 4'h1;
      parameter RD_CMDS = 4'h2;
      parameter JMP_CMDS = 4'h3;
      parameter END_CMDS = 4'h4;

      parameter CMD_EN_CFG_I = 8'h74;
      parameter CMD_DIS_CFG_I = 8'h26;
      parameter CMD_RD_ST = 8'h3C;
      parameter CMD_ZERO_ADDR = 8'h47;
      parameter CMD_RD_UFM = 8'hCA;
      parameter CMD_WR_UFM = 8'hC9;
      parameter CMD_ERASE_UFM = 8'hCB;
      parameter CMD_BYPASS = 8'hFF;

      parameter ST_IDL = 3'd0;
      parameter ST_NEXT_CMD = 3'd1;   
      parameter ST_WT_WR = 3'd2;
      parameter ST_WT_RD = 3'd3;

      parameter CMDS_NUM = 9'd196;
      parameter WR_PRG_START_INDEX = 9'd103;

      parameter [CMDS_NUM*8-1:0] CMDS = {
            //**** Erase and read
            //Enabled configuration interface
            WR_OF, WR, CMD_EN_CFG_I, WR, 8'h08, WR, Z00, WR, Z00, WR_CF,
            //Read config status register and repeat till not busy
            WR_OF, WR, CMD_RD_ST,    WR, Z00,   WR, Z00, WR, Z00, RD, RD, RD, WR_CF, JMPI,
            //Zero UFM address
            WR_OF, WR, CMD_ZERO_ADDR,WR, Z00,   WR, Z00, WR, Z00, WR_CF,
            //Read UFM page 0 (16 bytes) 
            WR_OF, WR, CMD_RD_UFM, WR,   Z00,   WR, Z00, WR, 8'h01,
            RDI,RDI,RDI,RDI,RDI,RDI,RDI,RDI,RDI,RDI,RDI,RDI,RDI,RDI,RDI,RDI,
            WR_CF,
            //Erase UFM
            WR_OF, WR, CMD_ERASE_UFM,WR, Z00,   WR, Z00, WR, Z00, WR_CF,
            //Read config status register and repeat till not busy
            WR_OF, WR, CMD_RD_ST,    WR, Z00,   WR, Z00, WR, Z00, RD, RD, RD, WR_CF, JMPI, 
            //Disable configuration interface
            WR_OF, WR, CMD_DIS_CFG_I, WR, Z00, WR, Z00, WR_CF,
            //Bypass (NOP)
            WR_OF, WR, CMD_BYPASS,    WR, FF,  WR, FF,  WR,  FF, WR_CF,

            END,  
            
            //**** Write
            //Enabled configuration interface
            WR_OF, WR, CMD_EN_CFG_I, WR, 8'h08, WR, Z00, WR, Z00, WR_CF,
            //Read config status register and repeat till not busy
            WR_OF, WR, CMD_RD_ST,    WR, Z00,   WR, Z00, WR, Z00, RD, RD, RD, WR_CF, JMPI,
            //Zero UFM address
            WR_OF, WR, CMD_ZERO_ADDR,WR, Z00,   WR, Z00, WR, Z00, WR_CF,
            //Write UFM page 0 (16 bytes) 
            WR_OF, WR, CMD_WR_UFM, WR,   Z00,   WR, Z00, WR, 8'h01,
            WRE,WRE,WRE,WRE,WRE,WRE,WRE,WRE,WRE,WRE,WRE,WRE,WRE,WRE,WRE,WRE,
            WR_CF,
            //Read config status register and repeat till not busy
            WR_OF, WR, CMD_RD_ST,    WR, Z00,   WR, Z00, WR, Z00, RD, RD, RD, WR_CF, JMPI, 
            //Disable configuration interface
            WR_OF, WR, CMD_DIS_CFG_I, WR, Z00, WR, Z00, WR_CF,
            //Bypass (NOP)
            WR_OF, WR, CMD_BYPASS,    WR, FF,  WR, FF,  WR,  FF, WR_CF,

            END  
      };

      

      reg wb_wr_rq = 0, wb_rd_rq = 0;
      reg [7:0] wb_wr_data = 0;
      wire [7:0] wb_rd_data = 0;
      reg [7:0] addr = 0;       

      wishbone wishbone(.clk(clk), .wr_rq(wb_wr_rq), .rd_rq(wb_rd_rq), .wr_data(wb_wr_data), .rd_data(wb_rd_data),
                        .addr(addr), .done(wb_done), .wb_clk(wb_clk), .wb_rst(wb_rst), .wb_cyc(wb_cyc), .wb_stb(wb_stb),
                        .wb_we(wb_we), .wb_addr(wb_addr), .wb_dat_i(wb_dat_i), .wb_dat_o(wb_dat_o), .wb_ack(wb_ack));


      reg [2:0] st = 0;
      reg [2:0] prev_st = 0;
      reg [7:0] prev_cmd = 0;
      reg [CMDS_NUM*8-1:0] cmds = CMDS;
      reg [8:0] cmd_index = 0;
      reg [7:0] lst_rd_data = 0;
      
      wire [7:0] cur_cmd = cmds[((CMDS_NUM-cmd_index-1)*8)+:8];
      wire [7:0] next_cmd = cmds[((CMDS_NUM-cmd_index-2)*8)+:8];

      assign is_cmd_wre = (cur_cmd == WRE);
      assign is_1cmd_wr = (cur_cmd == WRE || cur_cmd == WR_OF || cur_cmd == WR_CF);

      assign ufm_rd_ack = (prev_st == ST_WT_RD) &amp;&amp; (prev_cmd == RDI) &amp;&amp; wb_done;
      assign ufm_rd_data = ufm_rd_ack ? wb_rd_data : 0;

      always @(posedge clk)
      begin

        prev_st &lt;= st;
        prev_cmd &lt;= cur_cmd;

        case(st)
          ST_IDL:
          begin
            ufm_done &lt;= 0;
            if(ufm_rd_rq)
            begin            
              st &lt;= ST_NEXT_CMD;
            end
            else
            if(ufm_wr_rq)
            begin
              st &lt;= ST_NEXT_CMD;
              cmd_index &lt;= WR_PRG_START_INDEX;
            end           
          end          
          ST_NEXT_CMD:           
            case(cur_cmd[7:4])
               WR_CMDS:
               begin
                 wb_wr_rq &lt;= 1;
                 wb_wr_data &lt;= (cur_cmd == WR_OF) ? 8'h80 :
                           (cur_cmd == WR_CF ? 8'h00 : (is_cmd_wre ? ufm_wr_data : next_cmd));
                 addr &lt;= (cur_cmd == WR_OF || cur_cmd == WR_CF) ? 8'h70 : 8'h71;
                 ufm_wr_ack &lt;= is_cmd_wre;                                   
                 st &lt;= ST_WT_WR;
               end

               RD_CMDS:
               begin
                 wb_rd_rq &lt;= 1;
                 addr &lt;= 8'h73;
                 st &lt;= ST_WT_RD;                  
               end

               JMP_CMDS:
               begin
                 st &lt;= ST_NEXT_CMD;

                 if(lst_rd_data[4]) //if busy
                 begin
                   cmd_index &lt;= cmd_index - 13; //assuming the previous command is reading the status register 
                 end
                 else
                 begin
                   cmd_index &lt;= cmd_index + 1;
                 end
               end 

               END_CMDS:
               begin
                 st &lt;= ST_IDL;
                 cmd_index &lt;= 0;
                 ufm_done &lt;= 1;
               end              
            endcase

          ST_WT_WR:
          begin
            wb_wr_rq &lt;= 0;
            ufm_wr_ack &lt;= 0;
            if(wb_done)
            begin
               wb_wr_data &lt;= 0; //todo: not necessary, can be removed if doesn't fit
               cmd_index &lt;= cmd_index + (is_1cmd_wr ? 1 : 2);
               st &lt;= ST_NEXT_CMD;
            end
          end

          ST_WT_RD:
          begin
            wb_rd_rq &lt;= 0;
            if(wb_done)
            begin              
              lst_rd_data &lt;= wb_rd_data;
              cmd_index &lt;= cmd_index + 1;
              st &lt;= ST_NEXT_CMD; 
            end
          end         
        endcase
      end

endmodule

Inner Module:
module wishbone(clk, wr_rq, rd_rq, done, addr, wr_data, rd_data, wb_clk, wb_rst, wb_cyc, wb_stb, wb_we, wb_addr, wb_dat_i, wb_dat_o, wb_ack);

input clk;
input wr_rq, rd_rq;
output done;
input [7:0] addr;
input [7:0] wr_data;
output [7:0] rd_data;


output wb_clk;
output wb_rst;
output wb_cyc;
output wb_stb;
output wb_we;
output [7:0] wb_addr;
output [7:0] wb_dat_i;
input [7:0] wb_dat_o;
input wb_ack;

reg wr_in_progress = 0;
reg rd_in_progress = 0;

assign done = wb_ack;
assign wb_clk = clk;
assign wb_addr = (wr_in_progress || rd_in_progress) ? addr : 0;
assign wb_dat_i = wr_in_progress ? wr_data : 0;
assign rd_data = wb_dat_o;
assign wb_rst = 0;
assign wb_cyc = wr_in_progress || rd_in_progress;
assign wb_stb = wb_cyc;
assign wb_we = wr_in_progress;

always @(posedge clk)
begin
    if(!wr_in_progress &amp;&amp; !rd_in_progress)
    begin
         if(wr_rq)
         begin
            wr_in_progress &lt;= 1;            
         end
         else if(rd_rq)
         begin
            rd_in_progress &lt;= 1;
         end
    end
    else if(wr_in_progress &amp;&amp; wb_ack)
    begin
         wr_in_progress &lt;= 0;
    end
    else if(rd_in_progress &amp;&amp; wb_ack)
    begin
         rd_in_progress &lt;= 0;         
    end   
end

endmodule

Testbench:
`timescale 100ps / 100ps

module ufm1_tb;

      parameter WR_OF = 8'h10;
      parameter WR_CF = 8'h11;
      parameter WR = 8'h12;
      parameter WRE = 8'h13;
      parameter RD = 8'h20;
      parameter RDI = 8'h21;
      parameter JMPI = 8'h30;
      parameter END = 8'h40;

      parameter Z00 = 8'h00;
      parameter FF = 8'hFF;

      parameter WR_CMDS = 4'h1;
      parameter RD_CMDS = 4'h2;
      parameter JMS_CMDS = 4'h3;

      parameter CMD_EN_CFG_I = 8'h74;
      parameter CMD_DIS_CFG_I = 8'h26;
      parameter CMD_RD_ST = 8'h3C;
      parameter CMD_ZERO_ADDR = 8'h47;
      parameter CMD_RD_UFM = 8'hCA;
      parameter CMD_WR_UFM = 8'hC9;
      parameter CMD_ERASE_UFM = 8'hCB;
      parameter CMD_BYPASS = 8'hFF;

parameter CD = 200; //100ps*200=20nS (50MHz)
parameter HCD = CD/2; 
parameter QCD = CD/4;

parameter IGNORE = 8'h00;
parameter BUSY = 8'h10;
parameter FREE = 8'h00;

parameter [7:0] DATA [] = '{
            //**** erase/read
            //First busy wait
            IGNORE, IGNORE, BUSY,
            IGNORE, IGNORE, FREE,
            //UFM Page 0 read
            8'hA0,8'hA1,8'hA2,8'hA3,8'hA4,8'hA5,8'hA6,8'hA7,8'hA8,8'hA9,8'hAA,8'hAB,8'hAC,8'hAD,8'hAE,8'hAF,
            //Second busy wait 
            IGNORE, IGNORE, BUSY,
            IGNORE, IGNORE, BUSY,
            IGNORE, IGNORE, FREE,

            //**** write
            //First busy wait
            IGNORE, IGNORE, BUSY,
            IGNORE, IGNORE, FREE,
            
            //Second busy wait 
            IGNORE, IGNORE, BUSY,
            IGNORE, IGNORE, BUSY,
            IGNORE, IGNORE, FREE 
      };

parameter [7:0] DELAYS [] = '{{dut.CMDS_NUM}{8'h0}};
parameter [7:0] WRDATA [] = '{8'hBF,8'hBE,8'hBD,8'hBC,8'hBB,8'hBA,8'hB9,8'hB8,8'hB7,8'hB6,8'hB5,8'hB4,8'hB3,8'hB2,8'hB1,8'hB0};

parameter ST_IDLE = 0;
parameter ST_READING = 1;
parameter ST_WRITING = 2;
parameter ST_FINISHED = 3;

reg clk = 0;

always #(HCD) clk = ~clk;

wishbone_sim
#(
  .CD(CD),
  .DATA(DATA),
  .NUM_OPERATIONS(dut.CMDS_NUM),
  .DELAYS('{{dut.CMDS_NUM}{0'h0}})
)
wb_sim(.wb_clk(dut.wb_clk), .wb_rst(dut.wb_rst), .wb_stb(dut.wb_stb), .wb_cyc(dut.wb_cyc), .wb_we(dut.wb_we), .wb_addr(dut.wb_addr), .wb_dat_i(dut.wb_dat_i), .wb_dat_o(dut.wb_dat_o), .wb_ack(dut.wb_ack));

reg ufm_wr_rq = 0;
reg ufm_rd_rq = 0;
reg [3:0] st = ST_IDLE;
reg [7:0] ufm_wr_data = 8'bZ;
reg [4:0] ufm_wr_data_idx = 0;

wire [7:0] ufm_rd_data;
wire [7:0] wb_addr;
wire [7:0] wb_dat_i;
wire [7:0] wb_dat_o;

ufm1 dut(clk, ufm_wr_rq, ufm_rd_rq, ufm_wr_data, ufm_wr_ack, ufm_rd_data, ufm_rd_ack, ufm_done,
         wb_clk, wb_rst, wb_cyc, wb_stb, wb_we, wb_addr, wb_dat_i, wb_dat_o, wb_ack);

always @(posedge clk)
begin
   case(st)
      ST_IDLE:
      begin
        ufm_rd_rq &lt;= 1;
        st &lt;= ST_READING;        
      end
      ST_READING:
      begin
        ufm_rd_rq &lt;= 0;
        if(ufm_done)
        begin
          ufm_wr_rq &lt;= 1;
          ufm_wr_data &lt;= WRDATA[ufm_wr_data_idx];
          ufm_wr_data_idx &lt;= ufm_wr_data_idx + 1;
          st &lt;= ST_WRITING;
        end
      end
      ST_WRITING:
      begin
        ufm_wr_rq &lt;= 0;
        if(ufm_wr_ack)
        begin
          ufm_wr_data &lt;= WRDATA[ufm_wr_data_idx];
          ufm_wr_data_idx &lt;= ufm_wr_data_idx + 1;
        end
        if(ufm_done) st &lt;= ST_FINISHED;
      end
   endcase    
end

endmodule
","The issue was that I had a default value for the wb_rd_data wire inside the DUT:

wire [7:0] wb_rd_data = 0;


So it should have been just

wire [7:0] wb_rd_data;


So it has multiple assignments to the same wire - from the port and the default value and the bits that conflicted came up as Xs.

I had to try to synthesize this in Diamond to find the issue.",,,,,
How to connect ports to a Bus properly in VHDL?,"i am currently fooling around with some VHDL Code to try out a view things. 
For my current approach i need to split up a bus into ports. Therefore it would be the prettiest solution to ""hard connect"" the bus with the ports in the entity declaration. Is this possible?

Or is the only solution to connect them in the architecture and ""write"" them into each other in there?

This is the snippet i am trying to implement accordingly. 

entity test is
  port (
    bus    : out std_ulogic_vector(3 downto 0);
    port3   : out std_ulogic;
    port2   : out std_ulogic;
    port1   : out std_ulogic;
    port0   : out std_ulogic;
  );
end test;


Thank you very much for your help. ","The entity describes the external connectivity. The Architecture describes its internal behaviour. So ""hardwiring"" in the entity is not possible.

In your example, you would need to connect the ports to the same connects as the ""bus"" output

Note: bus is a reserved word in VHDL.",,,,,
How to write string values in Verilog testbench?,"I am trying to write a Verilog test-bench where I have to write output of some registers. I want to write L instead of 0, and H instead of 1 e.g '100101' as g 'HLLHLH'. I know about writing binary, hex or decimal value, but I am not sure whether it can be done in Verilog or not?","Assuming you're not using SystemVerilog, you could write a task, eg:

task LHwrite (input integer bin, input integer length);
  integer i;
  for (i=length-1; i&gt;=0; i=i-1)
    $write(""%s"", ""L""-(bin[i]*8'h4));
endtask 


bin is the value you want to display (up to 32 bits); length is the number of bits you want to display. The task iterates over the input:

for (i=length-1; i&gt;=0; i=i-1)


and then uses the $write system task (which is like $display but without a newline) to display the string you want. This is calculated based on the knowledge that the ASCII code for 'H' is 8'h48 and for 'L' is 8'h4C. 

https://www.edaplayground.com/x/4Ewk

module M;

  task LHwrite (input integer bin, input integer length);
    integer i;
    for (i=length-1; i&gt;=0; i=i-1)
      $write(""%s"", ""L""-(bin[i]*8'h4));
  endtask 

  initial
    begin : test
      reg [5:0] bin = 6'b100101;
      LHwrite(bin, 6);
      $write(""\n"");
    end

endmodule
",,,,,
"Pipelining an adder that sum 256, 20-bit words in Verilog?","I suppose this isn't so much a Verilog question as a logic question.  I need to add up 256, 20-bit words.  This is how I implemented it for a smaller number of words, and it worked.  With the large number of words, there are timing errors. 

module sum(clk, input_vect, out_sum);
input clk;
input [256*20-1 : 0] input_vect;
reg [25 : 0] out_sum_inter;
output reg [25 : 0] out_sum;
integer i;

always @ * 
begin
    out_sum_inter = 0;
    for(i = 0; i &lt; 256; i = i + 1)
        out_sum_inter = out_sum_inter + input_vect[20*i - 1 -: 20];
end

always @ (posedge clk)
out_sum &lt;= out_sum_inter;

endmodule


So, if not obvious, I have the combinational part split up from the sequential part.  My goal is that out_sum is only updated after I am sure the value of out_sum_inter is determined properly.

Thanks a lot.  I think I may need to pipeline this adder, but I am unsure how.","Your synthesiser probably does automatic pipelining. If it does, you need to add enough flip-flops at the output of your adder and the synthesiser will move them back as required. 

How many is enough? Enough to close the timing. Do some experiments.

Why can't the synthesiser just add the right number of flip-flops? Because synthesisers never ever change the latency through your design: they can only move flip-flops around relative to the combinational logic immediately connected to them. ",,,,,
Array of parameters in systemverilog,"I try to instantiate array of parameters, e.g.

module top();
    parameter array_size = 10;
    parameter par_array [array_size] = '{array_size{12}};

    initial begin
        $display(""%d"",par_array[array_size-1]);
    end
endmodule


But when I try to compile this module in questasim, I get this kind of error


  -- Compiling module top
  ** Error: (vlog-13069) parameters_array.sv(3): near ""["": syntax error, unexpected '[', expecting ';' or ','.


Search on this subject led me to the following topic and answerer says that systemverilog does allow this kind of construction.
I really don't want use long parameter vector, cause it's lead to new difficulties and this construction is compiling in Vivado (but for the sake of verification I need to use Questa).","parameter arrays are only supported in system verilog. So, make sure that you compile in the system verilog mode (file extension .sv or whatever qualifiers you need).

Also you'd better do int in your case:

parameter int par_array [array_size] = '{array_size{12}};`
----------^^^
",,,,,
is return stack implemented in Zynq 7000 SOC,"I am working on some research project based on ZC706 board that contain Zynq-7000 soc. i need to know that Cortex-A9 Cpu in Zynq-7000 implemented Return Stack Buffer (Return Stack Buffer is an program flow speculation technique like branch prediction) or no. In Zynq-7000 Technical reference manual i saw some registers that indicate that Return Stack was implemented or no.



as you can see in ETMCCER register bit 23 indicate return stack implementation detail and it's reset value is 0.

now i want to know that this means that Return Stack did not implemented in this SOC? Right?

excuse me for simple question, but i am really in doubt and i am wondering that implementing of return stack buffer is optional in ARM cores.","The return stack feature in the PTM is unrelated to performance features in the processor.

With PTM (and ETMv4), an indirect branch address does not need to be traced if it matches the state of a previously traced branch and link instruction. This allows some reduction in the trace bandwidth.

All PTM and ETM built for A-class CPU will probably implement the return stack. Since all these registers above are RAZ, I'm guessing there is no PTM in this device (but that contradicts the datasheet).",,,,,
"Alternative of ""can not set both range and type on function declaration"" in verilog?","I am making a verilog code for calculation of variance, in my verilog code I am calling a definition file, the definition file is as follows

`define MAXIMUM_FUNC_WIDTH  64

function integer clog2(input reg [`MAXIMUM_FUNC_WIDTH-1:0] value); 
    begin 
        value = value-1;
        for (clog2=0; value&gt;0; clog2=clog2+1)
            value = value&gt;&gt;1;
    end 
endfunction

function reg [`MAXIMUM_FUNC_WIDTH-1:0] pow(input integer base, input integer index); 
   begin
       for (pow=1; index&gt;=0; pow=pow*base)
           index = index - 1;
   end
endfunction


but in the line  function reg [MAXIMUM_FUNC_WIDTH-1:0] pow(input integer base, input integer index); it is showing error like can not set both range and type on function declaration. In think this is related to system verilog. But how can I use the same line for verilog only.","The Verilog standard only allowed a simple type name, or a range (assumed to be reg, but not both. SystemVerilog allows both as a packed array.",,,,,
Verilog addition unexpectedly results in x,"The output of this executable is x until you remove d from the c assignment. The output is x x x x. When d is removed from the assignment, the output is as expected ""2 3 4 5"".

module test();
  logic [1:0] a, b, d;
  logic [2:0] c;
  assign c = a+b+d;
  initial begin
    d = 0;
    a = 1;
    b = 1;
    $display(c);
    a = 2;
    b = 1;
    $display(c);
    a = 2;
    b = 2;
    $display(c);
    a = 2;
    b = 3;
    d = 3;
    $display(c);
  end

endmodule
","Both outputs are valid, you have a race condition.

A continuous assign statement is a concurrent process that waits for signals on the RHS to change, then evaluates the expression and makes the assignment.

The initial block is another concurrent process. As you procedurally make assignments to each signal, the scheduler is free to jump to to the other process and execute it, ... or it can continue executing statements until hitting a blocking delay, or it terminates. 

If fact, many tools in-line continuous assignments as an optimization, only executing them when the lhs gets referenced. That could be what's happening here when you remove d from the rhs.",,,,,
How can you get a binary number with n number of '1's in VHDL?,"I want to generate a random number using uniform(). The maximum value must be equal to the maximum value of a N bit integer.

So I need to generate the value of a binary number with n '1's

Thank you","uniform gives you a real number ranging from 0.0 to 1.0. You need to scale it to fit the desired value range and optionally convert it into a std_logic_vector.

For example for a N bit target value:

uniform(seed1, seed2, rand);
rand_int := integer(floor(rand*2.0**N));
sig      &lt;= std_logic_vector(to_unsigned(rand_int,N));
",,,,,
Writing a code for a CRC using D-FlipFlop in VHDL,"I'm learning VHDL for a university project. The goal is to write a CRC circuit given a certain polynomial. I found online solution that uses register but I wanted to do it by using actual D-FlipFlop.

So I created the D-FlipFlop and put in my main file several instances of them using generate to be more flexible and be able to add or remove flipflop easily.

library IEEE;
use IEEE.std_logic_1164.all;

entity LFSR is
    generic (NBit   : positive := 8);
    port(
        clk :in     std_logic;
        reset   :in     std_logic;
        din :in     std_logic;
        dout    :out    std_logic_vector(Nbit-1 downto 0)
        );
    end LFSR;
architecture rtl of LFSR is

    component DFC
        port(
            clk :in std_logic;
            reset   :in std_logic;
            d   :in std_logic;
            crc :out    std_logic;
            q   :out    std_logic
        );  
    end component DFC;

    signal q_s  : std_logic_vector (NBit-1 downto 0):= (others =&gt; '0');
    signal crc_t    : std_logic_vector (NBit-1 downto 0):= (others =&gt; '0'); --registro temporaneo su cui fare le operazioni

    signal int_0    :std_logic := '0';
    signal int_2    :std_logic := '0';
    signal int_4    :std_logic := '0';
    signal int_8    :std_logic := '0';




    begin 
        int_0&lt;= din xor q_s(7);
        int_2&lt;= q_s(1) xor q_s(7);
        int_4&lt;= q_s(3) xor q_s(7);

        GEN: for i in 0 to Nbit-1 generate

            FIRST:  if i=0 generate
                    FF1: DFC port map (
                            clk     =&gt; clk,
                            reset   =&gt; reset,
                            d   =&gt; int_0,
                            crc =&gt; crc_t(i), --funziona benissimo se metto dout(i)
                            q   =&gt; q_s(i)
                            );

                end generate FIRST; 

            THIRD: if i=2 generate
                    FF2: DFC port map (
                            clk     =&gt; clk,
                            reset   =&gt; reset,
                            d   =&gt; int_2,
                            crc =&gt; crc_t(i),
                            q   =&gt; q_s(i)
                                );
                end generate THIRD;

            FIFTH: if i=4 generate
                    FF4: DFC port map (
                            clk     =&gt; clk,
                            reset   =&gt; reset,
                            d   =&gt; int_4,
                            crc =&gt; crc_t(i),
                            q   =&gt; q_s(i)
                                );
                end generate FIFTH;


            INTERNAL: if i&gt;0 and i&lt;Nbit-1 and i/= 2 and i/=4 generate
                    FFI: DFC port map (
                            clk     =&gt; clk,
                            reset   =&gt; reset,
                            d   =&gt; q_s(i-1),
                            crc =&gt; crc_t(i),
                            q   =&gt; q_s(i)
                                );
                end generate INTERNAL;

            LAST:    if i=Nbit-1 generate
                    FFN: DFC port map (
                            clk     =&gt; clk,
                            reset   =&gt; reset,
                            d   =&gt; q_s(i-1),
                            crc =&gt; crc_t(i),
                            q   =&gt; q_s(i)
                            );
                end generate LAST;
    end generate GEN;


    variable t : natural := 0;

    begin
        if(rising_edge(clk)) then
            t:= t+1;
            if t=24 then 
                dout &lt;= crc_t;
            end if;
        end if;
    end process;

end rtl;



Of course on line 35, where I put ""d    => din xor q_s(Nbit-1)"", the compiler gives me an error. How can I obtain the result I want to get?

I tried putting intermediary signal to pass this problem, but I can't understand why this is not working as expected.

This is the code of the DFC component:


library IEEE;
use IEEE.std_logic_1164.all;

entity DFC is 
    port(
        clk :in std_logic;
        reset   :in std_logic;
        d   :in std_logic;
        crc :out    std_logic;
        q   :out    std_logic
    );  
end DFC;

architecture rtl of DFC is
    begin
        process(clk, reset, d)
        begin
            if(reset = '1')then
                q &lt;= '0';
                crc&lt;= '0';
            elsif (clk'event and clk='1') then
                q &lt;= d;
                crc &lt;= d;
            end if;
        end process;
end rtl;



Thanks all for the aswers.
Gabriele.

Edit: I added all the LFSR code and the DFC code. ","Your question is incomplete because it does not have a minimal reproductible code. In other word, it is hard to help you.

Prior to VHDL-2008:
You cannot perform such action : d =&gt; din xor q_s(Nbit-1) because this line is seen as an operation and that is not possible in an instantiation of an entity or a component.

(like in this post for example: https://electronics.stackexchange.com/questions/184893/warning-actual-for-formal-port-a-is-neither-a-static-name-nor-a-globally-stati)

However, there is a way to work around that, you have to create a new signal 

Notice that when you use your code, the error should be something like: Actual for formal port a is neither a static name nor a globally static expression

With VHDL-2008:

If look in the norm: http://www.fis.agh.edu.pl/~skoczen/hdl/ieee_std/ieee1076-2008.pdf
You can find on paragraph 6.5.6.3 Port clauses:


  If a formal port of mode in is associated with an expression that is not globally static (see 9.4.1) and the
  formal is of an unconstrained or partially constrained composite type requiring determination of index
  ranges from the actual according to the rules of 5.3.2.2, then the expression shall be one of the following:
  
  
  The name of an object whose subtype is globally static
  An indexed name whose prefix is one of the members of this list
  A slice name whose prefix is one of the members of this list and whose discrete range is a globally static discrete range
  An aggregate, provided all choices are locally static and all expressions in element associations are expressions described in this list
  A function call whose return type mark denotes a globally static subtype
  A qualified expression or type conversion whose type mark denotes a globally static subtype
  An expression described in this list and enclosed in parentheses
  


In other word, in VHDL-2008, the code you provided should work.

About your initialization problem, it is unclear, what signals/varibles are not initialized ? The best you can do is, if your first question is well answered by this post, then accept it has a solution or edit your question for more clarity. Then ask an other question in an other thread about the initialization problem. You can also post your question on Electronics Stackexchange",,,,,
Error with VHDL integer signal connecting Verilog integer input,"I trying to connect VHDL module's output integer port to signal. And this signal will connect other module. (This module wrote in Verilog). But I encounter this 


  ERROR :
  VHDL integer data type not supported for actual signals in component
  instantiation across language boundaries. Port ""fifo4_frame_number"" is
  an integer VHDL signal connected to a Verilog port.


I must also say that i can generate bitstream. there is no problem.","An integer in VHDL is fundamentally different to an integer in Verilog, so it is no surprise that they are not compatible. The integer type in VHDL is like an integer type in any other language, whereas the integer type in Verilog is just short hand for a vector. This

integer i;


and this

reg signed [31:0] i;


are exactly equivalent in Verilog. As others have said, you need to convert to std_logic_vector in VHDL.",,,,,
Verilog counter does not trigger for different clock signals,"I'm trying to write a counter that simply tracks the positive edge of a clock and increments a variable when it does. The caveat is this circuit must switch between different clock sources. The counter and clock multiplexer function as intended for the default clock in simulation, but the counter does not seem to be seeing the positive edges of the second clock signal. I've tested the multiplexer on its own, and it passes the clock signal through correctly. Any thoughts?

The top module:

module hw1_top(reset, updown, inp, clkSwitch, Clk100MHz, testClock2, out);
input reset, updown, Clk100MHz, testClock2;
input [15:0] inp;
input [3:0] clkSwitch;

output [15:0] out;

wire muxtoclk;

ClockMux mux(
    .c1(Clk100MHz),
    .c2(testClock2),
    .switch(clkSwitch),
    .cOut(muxtoclk)
);

UDCounter counter(
    .RST(reset),
    .UD(updown),
    .INP(inp),
    .CLK(muxtoclk),
    .OUT(out)
);  
endmodule


Counter:

module UDCounter(RST, UD, INP, CLK, OUT);
input RST, UD, CLK; //1 bit inputs
input [15:0] INP; //16 bit input

output reg [15:0] OUT; //16 bit output, must be reg for sequential

initial
    OUT &lt;= INP; //when we start, counter initializes to whatever the input is

always@(posedge CLK or posedge RST) //on every positive edge of the clock cycle, or if reset is triggered...
    if(RST == 1'b1) //if reset is high, set counter back to the initial input
        OUT &lt;= INP;
    else //if reset isn't triggered...
        if(UD == 1'b0) //if up/down is in up position, count up
            begin
                OUT &lt;= OUT + 1;
            end
        else //if in down, count down
            begin
                OUT &lt;= OUT -1;
            end
endmodule


Multiplexer:

module ClockMux(c1,c2,switch,cOut);switch,cOut);
input c1,c2;
input [3:0] switch;

output reg cOut;

always@(switch,c1,c2) //updates whenever the switch or clock changes
    case(switch)
        4'b0000: cOut &lt;= c1;
        4'b0001: cOut &lt;= c2;
    endcase
 endmodule


Top level testbench and waveform:

module hw1_top_tb();
reg reset, updown, Clk100MHz, testClock2;
reg [15:0] inp;

wire [15:0] out;
reg [3:0] switchValue;

hw1_top topmod(
    .reset(reset),
    .updown(updown),
    .inp(inp),
    .clkSwitch(switchValue),
    .Clk100MHz(Clk100MHz),
    .out(out)
);

initial Clk100MHz = 0;
always #5 Clk100MHz = ~Clk100MHz;

initial testClock2 = 0;
always #3 testClock2 = ~testClock2;

initial begin
    reset = 0; updown = 0; inp = 16'b0; switchValue = 4'b0000; 
    #10;
    reset = 1; updown = 0; inp = 16'b0; switchValue = 4'b0000; 
    #10; //toggles the reset briefly to clear dc's

    reset = 0; updown = 0; inp = 16'b0; switchValue = 4'b0000;
    #40;
    reset = 1; updown = 0; inp = 16'b0; switchValue = 4'b0001; //counter is not listening here
    #10;
    reset = 0; updown = 0; inp = 16'b0; switchValue = 4'b0001; //counter is not listening here
    #23;
    reset = 1; updown = 0; inp = 16'b0; switchValue = 4'b0000; //when we switch back, it's doing great
    #13;
    reset = 0; updown = 0; inp = 16'b0; switchValue = 4'b0000;
    #23;
    $finish;
end
 endmodule


","You never connected testClock2 in your instantiation topmod of hw1_top:

hw1_top topmod(
    .reset(reset),
    .updown(updown),
    .inp(inp),
    .clkSwitch(switchValue),
    .Clk100MHz(Clk100MHz),
    .testClock2(testClock2), // this is missing
    .out(out)
);
",,,,,
Access enum name in Systemverilog,"I want to be able to retrieve the names for the types in an enumeration without having to actually assign a variable to them. Hence, given an enumeration like this 

class my_class;
   typedef enum bit {
      ONE,
      TWO
   } fsm_state_t;
endclass


I know I can access the name of a declared variable like this:

class another_class;
...
my_class::fsm_state_t state = my_class::ONE;
   print(state.name());
...
endclass


Is it possible to access the names of the enum without actually having to declare and assign a variable? What I mean is something like this:

class another_class;
...
   print(my_class::ONE);
   print(my_class::TWO);
...
endclass
","No, built-in methods cannot be called on types.",,,,,
verilog code of FIFO (first in first out) is not showing the proper result?,"I wanted to design a FIFO having a certain depth and width.  The Verilog code of the FIFO is written in Vivado 2017.4.  The code is able to to read the input data, but it is only showing XX as the output. The design sources and test bench of the FIFO is given below. Help me to find the problem.

module fifo #(parameter WIDTH=8, parameter DEPTH=8) (
    input wire [WIDTH-1:0] data_in,
    output reg [WIDTH-1:0] data_out,
        output reg data_valid,
        input wire reset,
    input wire clk
    );
        function integer clog2(input reg [32-1:0] value); 
        begin 
            value = value-1;
            for (clog2=0; value&gt;0; clog2=clog2+1)
                value = value&gt;&gt;1;
        end 
    endfunction
        reg [WIDTH-1:0] data [DEPTH-1:0];
    reg [clog2(DEPTH)-1:0] write_pointer;
    reg [clog2(DEPTH)-1:0] read_pointer;
        always @(posedge clk) begin
        if (reset == 1'b0) begin
            write_pointer &lt;= 0;
            read_pointer &lt;= 1;
            data_valid &lt;= 0;
        end else begin
            if (write_pointer == DEPTH-1) write_pointer &lt;= 0;
            else write_pointer &lt;= write_pointer + 1;
                if (read_pointer == DEPTH-1) read_pointer &lt;= 0;
            else read_pointer &lt;= read_pointer + 1;
                data[write_pointer] &lt;= data_in;
            data_out &lt;= data[read_pointer];
        end
            if (read_pointer == 0) data_valid &lt;= 1'b1;
    end
    endmodule


test bench

`timescale 1ns / 1ps
module fifo_tb;
    parameter WIDTH = 16;
    parameter DEPTH = 8;
    reg reset;
    reg clk;
reg [(WIDTH-1):0] data_in;
    wire [(WIDTH-1):0] data_out;
    wire data_valid;    
   fifo #(WIDTH,DEPTH) U0(data_in,data_out,data_valid,reset,clk);
     initial begin
        clk = 0;
        reset = 1;
        #1 reset = 0;
        #1 reset = 1;

    end

    // Create clock
    always
    #5 clk = ~clk;

reg signed [15:0] rom_memory [4096-1:0];
integer i=0;
initial 
begin
    $readmemh(""C:\\Users\\input_7_zz.txt"",rom_memory);

end

always@(posedge clk )
begin
    if(~reset)
    begin
    data_in &lt;= 0;
    end
    else
    begin
      data_in &lt;= rom_memory[i];
     i &lt;= i+ 1;
 end

end
endmodule
","In your test bench code the clock is changed every 5 ticks:

// Create clock
always
    #5 clk = ~clk;


The reset in RTL uses posedge of this clock:

always @(posedge clk) begin
    if (reset == 1'b0) begin
        write_pointer &lt;= 0;
        read_pointer &lt;= 1;
        data_valid &lt;= 0;


So, the reset action could happen only if the posedge clk could be detected during the reset period. In other words you have a synchronous reset.

Nevertheless, in your test bench code your reset lasts only a single tick:

initial begin
    clk = 0;
    reset = 1;
    #1 reset = 0;
    #1 reset = 1; // &lt;&lt; one tick after the reset was asserted.
end


Potentially you have 2 possible solutions.

1) keep the synchronous reset, but make sure that the posedge of the clk could be detected during the reset. So, make it bigger than a clock cycle (or at least half clock cycle if you are sure when it comes). Something like 5 should work in your case. Make it 10 or more to be sure for arbitrary starting points.

initial begin
    clk = 0;
    reset = 1;
    #1 reset = 0;
    #5 reset = 1; // &lt;&lt; 5 tick after the reset was asserted. 


The reset above will last from time 1 to time 6. The first posegde will happen at time 5. So, it should be sufficient in your case. 

2) you can use an asynchronous reset in RTL which will look as the following:

always @(posedge clk or reset) begin
    if (reset == 1'b0) begin
        write_pointer &lt;= 0;
        read_pointer &lt;= 1;
        data_valid &lt;= 0;


In the above case the always block will be executed whenever 'reset' changes. However you have to be careful about the timing of other assignment there. They could happen when you deassert reset with some offset from the posedge clk.",,,,,
Non blocking statements with delays,"always@(a)
begin
#1 t&lt;=a;
#1 c&lt;=t;
end


I am analysing above verilog code with test bench as given below

   a=0;
#5 a=1;
#5 a=0;
#5 a=1;
#5;


Here is my analysis:
From above test bench I can tell that 'a' is a clock signal of total 20ns length with OFF and ON time of 5ns both respectively.At 0th ns, 'a' is changed from X to 0. So always block gets triggered.since first statement inside block is having 1ns inter delay, it waits for 1ns. after 1ns compiler gets to know that it is non blocking statement so just evaluation will be done not assignment.hence 'a' value will be stored as temporary and parallelly it executes second statement.since second one also has inter delay,it waits for 1ns. and then evaluation is done.since both the evaluations are done, assignment will happen now.

    time   a   t   c
    0ns    0   x   x
    1ns    0   x   x
    2ns    0   x   x
    3ns    0   0   x
    4ns    0   0   x


is this analysis correct?","No, that is not what happens, non-blocking assignments work different then what you describe.

You are right in that the actual assignment of a non-blocking statement is deferred, executed ""later"". But when is ""later""? 

'non-blocking' events are processed when there are no more outstanding blocking events. But before processing delays. Thus as soon as the simulator sees that it has to process your #1, it first handles all non-blocking assignments and only then start processing the delay.
Which means even before it starts the #1 delay t already has received the value of a. 

There is a whole chapter in the Verilog standard which describes in what order the various 'actions' should be performed.",,,,,
How do I add the bits of a vector and at the same time save the value in a vector signal? I use google translator**,"I am trying to know if the amount of ""1"" in a std_logic_vector is an odd or even number. For that I am trying to use an ""if"" statement along with a counter, but I don't get the expected result.

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_unsigned.all;

entity prueba2 is
port (
          entrada: in std_logic_vector(0 to 10)
        );
end prueba2;

architecture Behavioral of prueba2 is

signal bit1: std_logic_vector(0 to 3):= (others =&gt; '0');

begin

prueba: process(entrada)

    --variable suma: unsigned(0 to 2):= (others =&gt; '0');

begin
    for i in 0 to 10 loop
        if (entrada(i)= '1') then
            bit1 &lt;= bit1+1;
        end if;
    end loop;

end process;

end Behavioral;




I am not getting errors in the syntax, but for example, by entering a vector ""1111111111"" I receive as output in the simulation, using ISE design Suite, the value ""0001"" instead of ""1010"". I appreciate your corrections and code suggestions.","See IEEE Std 1076-2008 10.5.2.2 Executing a simple assignment statement, 14.7.3.4 Simulation cycle and 14.7.3.4 Signal update.

Signals aren't updated immediately. The current simulation cycle isn't complete until every process sensitive to an event has executed and potentially scheduled signal updates and subsequently suspended. Simulation time is advanced to the time the next signal update is scheduled. Signals are updated at the beginning of a simulation cycle before any suspended processes resume due to a signal event. 

Processes both suspend and resume executing wait statements (see 10.2 Wait statement). A process statement (11.3) with a sensitivity list has an implicit wait statement as the last statement with it's sensitivity list having the contents of the process sensitivity list. 

The signal bit1 won't update while the loop is executing, there is no implicit or explicit wait statement causing the process to suspend.

To solve the issue use a variable:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_unsigned.all;  -- arithmetic for std_logic_vector

entity prueba2 is
    port (
        entrada: in std_logic_vector(0 to 10) := (others =&gt; '1')
    );
end entity prueba2;

architecture behavioral of prueba2 is
    signal bit1: std_logic_vector(0 to 3):= (others =&gt; '0');
    function to_string (inp: std_logic_vector) return string is
            variable image_str: string (1 to inp'length);
            alias input_str:  std_logic_vector (1 to inp'length) is inp;
    begin
        for i in input_str'range loop
            image_str(i) := character'VALUE(std_ulogic'IMAGE(input_str(i)));
        end loop;
        return image_str;
    end function;
begin

prueba: 
    process (entrada)  -- sensitivity list implies wait as final statement
        -- variable suma: unsigned(0 to 2):= (others =&gt; '0');
        variable suma: std_logic_vector(0 to 3); 
    begin
        suma := (others =&gt; '0'); -- start at 0 every time
        for i in entrada'range loop
            if entrada(i) = '1' then
                -- bit1 &lt;= bit1+1 -- signals don't update until the beginning
                -- of the next simulation cycle (at the soonest)
                suma := suma + 1; -- variables assignment is immediate
            end if;
        end loop;
        report ""bit1 will be assigned "" &amp; to_string(suma); 
        bit1 &lt;= suma; -- both the same length processes communicate with signals
        -- wait on entrada;  -- implicit wait statement, process suspends
    end process;
end architecture behavioral;


You can see the variable has the same length as bit1. That's required, you input entrada has a length of 11 which requires a 4 bit value to accumulate the number of '1's.

There are some embellishments for testing. Some simulators will allow you to simulate a top level with ports as long as inputs have default values or can be forced. Here entrada is supplied with all '1's. The to_string function is provided in revision -2008 of the standard, also provided here for compatibility with earlier revisions. The report statement tells us the value of suma that will be assigned to bit1.

When the design unit is analyzed and elaborated (compiled) then run:

ghdl -a --ieee=synopsys -fexplicit prueba2.vhdl
ghdl -e --ieee=synopsys -fexplicit prueba2
ghdl -r prueba2
prueba2.vhdl:37:9:@0ms:(report note): bit1 will be assigned 1011


The loop has successfully counted all the '1's, and bit1 will have an update scheduled with the same simulation time (here 0 ms). The simulator will execute a follow on simulation cycle (a delta cycle) then without any further schedule signal updates scheduled in any projected output waveform (a queue) the simulation time will advance to TIME'HIGH and simulation will end.

When a simulation starts every process executes at least once following initialization. The event on bit1 will cause a signal value update but there are no processes in the stand alone example sensitive to bit1 and simulation will cease.

The default value on the input entrada, function to_string and the report statement can be removed, they are present for testing, a testbench not having been provided.",,,,,
Multiple conflicting drivers for reg assigned in only one always block,"I'm working on a simple video signal timing module in Verilog, as a learning project. I've understood from earlier study that each reg should be assigned from only one always block, so I arranged my system into two state machine blocks and then one block for populating the output registers, as shown below:

module video_timing
(
    input wire reset,
    input wire clk,

    output reg [15:0] x,
    output reg [15:0] y,
    output reg hsync,
    output reg vsync,
    output reg visible
);

    // State constants for our two timing state machines (one horizontal, one vertical)
    `define VIDEO_SYNC       2'd0
    `define VIDEO_BACKPORCH  2'd1
    `define VIDEO_ACTIVE     2'd2
    `define VIDEO_FRONTPORCH 2'd3

    // These settings are for 720p, assuming clk is running at 74.25 MHz
    `define VIDEO_H_SYNC_PIXELS   16'd40
    `define VIDEO_H_BP_PIXELS     16'd220
    `define VIDEO_H_ACTIVE_PIXELS 16'd1280
    `define VIDEO_H_FP_PIXELS     16'd110
    `define VIDEO_H_SYNC_ACTIVE   1'b1
    `define VIDEO_V_SYNC_LINES    16'd5
    `define VIDEO_V_BP_LINES      16'd20
    `define VIDEO_V_ACTIVE_LINES  16'd720
    `define VIDEO_V_FP_LINES      16'd5
    `define VIDEO_V_SYNC_ACTIVE   1'b1

    reg [1:0] state_h;
    reg [15:0] count_h; // 1-based so we will stop when count_h is the total pixels for the current state
    reg inc_v = 1'b0;
    reg [1:0] state_v;
    reg [15:0] count_v; // 1-based so we will stop when count_v is the total lines for the current state

    // Change outputs on clock.
    // (These update one clock step behind everything else below, but that's
    //  okay because the lengths of all the periods are still correct.)
    always @(posedge clk) begin
        if (reset == 1'b1) begin
            hsync   &lt;= ~`VIDEO_H_SYNC_ACTIVE;
            vsync   &lt;= ~`VIDEO_V_SYNC_ACTIVE;
            visible &lt;= 1'b0;
            x       &lt;= 16'd0;
            y       &lt;= 16'd0;
        end else begin
            hsync   &lt;= (state_h == `VIDEO_SYNC) ^ (~`VIDEO_H_SYNC_ACTIVE);
            vsync   &lt;= (state_v == `VIDEO_SYNC) ^ (~`VIDEO_V_SYNC_ACTIVE);
            visible &lt;= (state_h == `VIDEO_ACTIVE) &amp;&amp; (state_v == `VIDEO_ACTIVE);
            x       &lt;= count_h - 1;
            y       &lt;= count_v - 1;
         end
    end

    // Horizontal state machine
    always @(posedge clk) begin
        if (reset == 1'b1) begin
            count_h &lt;= 16'b1;
            state_h &lt;= `VIDEO_FRONTPORCH;
        end else begin
            inc_v &lt;= 0;
            count_h &lt;= count_h + 16'd1;

            case (state_h)
                `VIDEO_SYNC: begin
                    if (count_h == `VIDEO_H_SYNC_PIXELS) begin
                        state_h &lt;= `VIDEO_BACKPORCH;
                        count_h &lt;= 16'b1;
                    end
                end
                `VIDEO_BACKPORCH: begin
                    if (count_h == `VIDEO_H_BP_PIXELS) begin
                        state_h &lt;= `VIDEO_ACTIVE;
                        count_h &lt;= 16'b1;
                    end
                end
                `VIDEO_ACTIVE: begin
                    if (count_h == `VIDEO_H_ACTIVE_PIXELS) begin
                        state_h &lt;= `VIDEO_FRONTPORCH;
                        count_h &lt;= 16'b1;
                    end
                end
                `VIDEO_FRONTPORCH: begin
                    if (count_h == `VIDEO_H_FP_PIXELS) begin
                        state_h &lt;= `VIDEO_SYNC;
                        count_h &lt;= 16'b1;
                        inc_v &lt;= 1;
                    end
                end
            endcase
        end
    end

    // Vertical state machine
    always @(posedge clk) begin
        if (reset == 1'b1) begin
            count_v &lt;= 16'b1;
            state_v &lt;= `VIDEO_FRONTPORCH;
        end else begin
            if (inc_v) begin
                count_v &lt;= count_v + 16'd1;
                case (state_v)
                    `VIDEO_SYNC: begin
                        if (count_v == `VIDEO_V_SYNC_LINES) begin
                            state_v &lt;= `VIDEO_BACKPORCH;
                            count_v &lt;= 16'b1;
                        end
                    end
                    `VIDEO_BACKPORCH: begin
                        if (count_v == `VIDEO_V_BP_LINES) begin
                            state_v &lt;= `VIDEO_ACTIVE;
                            count_v &lt;= 16'b1;
                        end
                    end
                    `VIDEO_ACTIVE: begin
                        if (count_v == `VIDEO_V_ACTIVE_LINES) begin
                            state_v &lt;= `VIDEO_FRONTPORCH;
                            count_v &lt;= 16'b1;
                        end
                    end
                    `VIDEO_FRONTPORCH: begin
                        if (count_v == `VIDEO_V_FP_LINES) begin
                            state_v &lt;= `VIDEO_SYNC;
                            count_v &lt;= 16'b1;
                        end
                    end
                endcase
            end
        end
    end

endmodule


When attempting to synthesize this using the IceStorm toolchain, yosys warns that there are multiple drivers for hsync:

Warning: multiple conflicting drivers for top.\timing.hsync:
    port Q[0] of cell $techmap\timing.$procdff$109 ($adff)
    port Q[0] of cell $techmap\timing.$procdff$110 ($adff)


nextpnr-ice40 then subsequently fails on the same problem:

ERROR: multiple drivers on net 'P1B4' ($auto$simplemap.cc:496:simplemap_adff$375.Q and $auto$simplemap.cc:496:simplemap_adff$376.Q)
ERROR: Loading design failed.


I've tried a few different permutations to try to resolve this, and made some observations:


If I change the assignment in the case (reset) 0: block (in the first always) to just hsync &lt;= 'VIDEO_H_SYNC_ACTIVE then the result is synthesizable, and does indeed assert hsync constantly when not in reset as I'd expect after making that change.
If I remove the hsync &lt;= (state_h == 'VIDEO_SYNC) ^ (~'VIDEO_H_SYNC_ACTIVE) line entirely but retain the hsync &lt;= ~'VIDEO_H_SYNC_ACTIVE during reset then the result is also sythesizable, and hsync is constantly unasserted.


(I replaced backticks with ' above just because backtick is the Markdown metacharacter for inline verbatim text. I'm using backticks for the constants in my actual program.)

This has led me to conclude that the expression on the right hand side of hsync &lt;= that is the problem. But I'm then confused as to why the very similar following vsync &lt;= line doesn't produce a similar error:

hsync &lt;= (state_h == `VIDEO_SYNC) ^ (~`VIDEO_H_SYNC_ACTIVE);
vsync &lt;= (state_v == `VIDEO_SYNC) ^ (~`VIDEO_V_SYNC_ACTIVE);


The module behaves as I expected under simulation with iverilog.

I'm using Yosys 0.8 and nextpnr built from git sha1 a6a4349. I also tried upgrading to Yosys 0.9 and got the same result, but I suspect the fault is mine, not in the toolchain.","This pattern of asynchronous resets is not permitted by the IEEE synthesis standard (1364.1). Only an if statement can be used thus:

",,,,,
range of modulus operator in verilog,"What is range of % operator in Verilog? In C I know if I write number%10 then output is between 0 and 9. But I tried in Verilog and result I am getting is between -9 and 9? Why is that? 

enter code here
module testbench;
integer i;
reg signed [15:0] a,b;
initial
begin
for(i = 0; i &lt; 9; i = i + 1)
begin
    a= $random%10;
    b= $random%20;  
    $display(""A: %d and B : %d"",a,b);
end
end
endmodule
","Modulus can return negative numbers as clearly stated in Verilog's IEEE Std 1364-2001 &sect; 4.1.5 Arithmetic operators as well as SystemVerilog's IEEE Std 1800-2012 &sect; 11.4.3 Arithmetic operators


  The result of a modulus operation shall take the sign of the first operand.  


Both LRMs (Language Reference Manual) also give examples.

To guarantee a positive number, you can use $unsigned(). Example:

a = $unsigned($random) % 10;


If you enable SystemVerilog, you can replace $unsigned($random) with $urandom or replace $unsigned($random) % 10 with $urandom_range(9, 0); see IEEE Std 1800-2012 &sect; 18.13 Random number system functions and methods



FYI : C/C++ does the same with negative numbers. Refer to prior answered questions: Modulo operation with negative numbers and Modulo operator with negative values",,,,,
SystemVerilog Instantiated Modules Share Inputs When They Shouldn't (Easy Solution)?,"I am having a small issue here in when I instantiated my modules. I am using a generate loop to create 100 instances of 2 counters (16 &amp; 32 bit counters). Each counter should have their own independent controls (UPDN &amp; EN), but they share a clock and a reset.

Module Descriptions:

SAT_COUNTER.sv   // SIMPLE COUNTER MODULE

TWO_SC.sv        // INSTANTIATES TWO SAT_COUNTER MODULES (16 BIT &amp; 32 BIT 
COUNTERS)

GEN_SC.sv        // INSTANTIATES 100 MODULES OF TWO_SC MODULES

tb_GEN_SC.sv     // TESTBENCH

I am sure that my problem is in the GEN_SC module where I instantiate all 100..

I appreciate any help! Thank you in advance!

module SAT_COUNTER(
    COUNT,          // SCALABLE COUNT OUTPUT
    CLK,            // CLOCK
    al_RST,         // ACTIVE LOW RESET
    UPDN,           // COUNTER WILL COUNT: UP = 1; DN = 0;
    EN);            // ENABLE

    parameter WIDTH = 8;

    input CLK, al_RST, UPDN, EN;
    output reg [WIDTH-1:0] COUNT;

    ...

endmodule

 //**********************

module TWO_SC(
  COUNT1,       // N-BIT COUNTER OUTPUT
  COUNT2,       // M-BIT COUNTER OUTPUT
  CLK,          // CLOCK
  al_RST,       // ACTIVE-LOW RESET
  UPDN,         // DIR. CONTROL
  EN);          // ENABLE

  parameter WIDTH1 = 16;
  parameter WIDTH2 = 32;

  input CLK, al_RST;
  input [1:0] UPDN, EN;
  output [WIDTH1-1:0] COUNT1;
  output [WIDTH2-1:0] COUNT2;

  SAT_COUNTER   #(WIDTH1) GSC1(.COUNT(COUNT1), .CLK(CLK), .al_RST(al_RST), .UPDN(UPDN[0]), .EN(EN[0]));
  SAT_COUNTER   #(WIDTH2) GSC2(.COUNT(COUNT2), .CLK(CLK), .al_RST(al_RST), .UPDN(UPDN[1]), .EN(EN[1]));

endmodule

//**********************

module GEN_SC(
  COUNT1,       // COUNT1
  COUNT2,       // COUNT2
  CLK,          // CLOCK
  al_RST,       // ACTIVE-LOW RESET
  UPDN,         // DIR. CONTROL
  EN);          // ENABLE

  parameter MOD_COUNT = 100;
  parameter WIDTH1 = 16;
  parameter WIDTH2 = 32;

  input CLK, al_RST;
  input [1:0] UPDN [MOD_COUNT-1:0];
  input [1:0] EN [MOD_COUNT-1:0];
  output [WIDTH1-1:0] COUNT1;
  output [WIDTH2-1:0] COUNT2;

  genvar j;

      generate
        for(j = 0; j &lt; MOD_COUNT; j++) begin: SC
          TWO_SC    #(.WIDTH1(WIDTH1), .WIDTH2(WIDTH2))    TWOCOUNTERS(.COUNT1(COUNT1), .COUNT2(COUNT2), .CLK(CLK), .al_RST(al_RST), .UPDN(UPDN[j]), .EN(EN[j]));
         end
      endgenerate


endmodule

//**********************

module tb_GEN_SC();

parameter MOD_COUNT = 100;
parameter WIDTH1 = 16;
parameter WIDTH2 = 32;

  reg CLK, al_RST;
  reg [1:0] UPDN [MOD_COUNT-1:0];
  reg [1:0] EN [MOD_COUNT-1:0];
  wire [WIDTH1-1:0] COUNT1;
  wire [WIDTH2-1:0] COUNT2;

  GEN_SC    #(.WIDTH1(WIDTH1), .WIDTH2(WIDTH2))    UUT(COUNT1, COUNT2, CLK, al_RST, UPDN, EN);

    initial begin
CLK = 1'b1;
  forever
    #5 CLK = ~CLK;
  end

    initial
    $monitorb(""%d  COUNT = %b (%d) | UPDN = %b | EN = %b | COUNT = %b (%d) | UPDN = %b | EN = %b | al_RST = %b | CLK = %b"", $time, UUT.SC[87].TWOCOUNTERS.COUNT1, UUT.SC[87].TWOCOUNTERS.COUNT1, UUT.SC[87].TWOCOUNTERS.UPDN[0], UUT.SC[87].TWOCOUNTERS.EN[0], UUT.SC[99].TWOCOUNTERS.COUNT1, UUT.SC[99].TWOCOUNTERS.COUNT1, UUT.SC[99].TWOCOUNTERS.UPDN[0], UUT.SC[99].TWOCOUNTERS.EN[0], al_RST, CLK);

    initial begin
    $vcdpluson;
            UUT.SC[87].TWOCOUNTERS.GSC1.UPDN = 1; UUT.SC[99].TWOCOUNTERS.GSC1.UPDN = 1; EN = 0; al_RST = 1;
    #10                                           UUT.SC[99].TWOCOUNTERS.GSC1.UPDN = 0;         al_RST = 0;           // RESET COUNTER
    #10                                                                                 EN = 1; al_RST = 1;         // ENABLE COUNTER AND COUNT UP (HITS MAX)
    #200    UUT.SC[87].TWOCOUNTERS.GSC1.UPDN = 0; UUT.SC[99].TWOCOUNTERS.GSC1.UPDN = 1; EN = 1;                     // BEGIN TO COUNT DOWN
    #10                                       EN = 0;
    #60                                       EN = 3;
//      #230    UPDN = 1; UPDN = 0;
    #3017                                     al_RST = 0;
    #100                                      al_RST = 1;
    #20 $finish;
    end    


/////////// ERRORS I GET /////////////////

Error-[IBLHS-NT] Illegal behavioral left hand side
tb_GEN_SC.sv, 34
  Net type cannot be used on the left side of this assignment.
  The offending expression is : tb_GEN_SC.UUT.SC[87].TWOCOUNTERS.GSC1.UPDN
  Source info: tb_GEN_SC.UUT.SC[87].TWOCOUNTERS.GSC1.UPDN = 1;

Error-[IBLHS-NT] Illegal behavioral left hand side
tb_GEN_SC.sv, 34
  Net type cannot be used on the left side of this assignment.
  The offending expression is : tb_GEN_SC.UUT.SC[99].TWOCOUNTERS.GSC1.UPDN
  Source info: tb_GEN_SC.UUT.SC[99].TWOCOUNTERS.GSC1.UPDN = 1;

Error-[IUDA] Incompatible dimensions
tb_GEN_SC.sv, 34
  Incompatible unpacked dimensions in assignment
  Arrays with incompatible unpacked dimensions  cannot be used in assignments,
  initializations and instantiations.

Error-[ICTA] Incompatible complex type
tb_GEN_SC.sv, 34
  Incompatible complex type assignment
  Type of source expression is incompatible with type of target expression. 
  Mismatching types cannot be used in assignments, initializations and 
  instantiations. The type of the target is 'reg[1:0]$[99:0]', while the type 
  of the source is 'int'.
  Source Expression: 0","You have just one UPDB and one EN port in port list. So how you wana apply different UPDN and EN to instances?

An idea is to define an array with size of MOD_COUNT so that each element has its own control input. then in genvar loop you can use the index. like this:

input [1:0] UPDN  [MOD_COUNT-1:0];
input [1:0] EN [MOD_COUNT-1:0];


...

generate
    for(j = 0; j &lt; MOD_COUNT; j++) begin: SC

  TWO_SC    #(.WIDTH1(WIDTH1), .WIDTH2(WIDTH2))    TWOCOUNTERS(.COUNT1(COUNT1),
 .COUNT2(COUNT2), .CLK(CLK), .al_RST(al_RST),      .UPDN(UPDN[j]), .EN(EN[j]));

 end
  endgenerate
",,,,,
System Verilog - forcing a signal to invert / flip,"Is forcing a signal's bit to flip using this method valid ?

1.

task
begin
force higher_level.lower_level.a[1] = ~higher_level.lower_level.a[1];
end 


I've tried this with mixed results at best. Sometimes the bit flips, while sometimes it remains the the same.

However, I've also written a less elegant code with for the same purpose of flipping the bits, which works all the time, as seen below:

2.

task
begin
if(higher_level.lower_level.a[1] == 1'b1)
force higher_level.lower_level.a[1] = 1'b0;
else
force higher_level.lower_level.a[1] = 1'b1;
end


Is the first code not good way of flipping the bits? Or is there something else I'm missing out? 

Wherehigher_level.lower_level.a[51:0] is a 52-bit signal 

Thanks :D","No, that first method won't work. If it did, it would be like a infinite loop oscillator. 

The second method requires you to setup a sampling process where you need to decide when to sample a.

If a is being driven by some expression, you can force it to be the inverse of that expression.",,,,,
Cross-compilation with libraries,"I am working on Windows 7, using Eclipse DS-5, to cross-compile projects for Altera SoC (FPGA+ARM). The toolchain is supplied by Altera tools, and it looks as follows :

GCC C++ Compiler 4 [arm-linux-gnueabihf]
GCC C Compiler 4 [arm-linux-gnueabihf]
GCC Assembler 4 [arm-linux-gnueabihf]
GCC C Linker 4 [arm-linux-gnueabihf]
GCC C++ Linker 4 [arm-linux-gnueabihf]
GCC Archiver 4 [arm-linux-gnueabihf]


The Altera SoC board is running Angstrom Linux distribution on ARM. 

I need to add some libraries (e.g. libcURL) and set the Eclipse project settings, to include the library in compilation.

MY UNDERSTANDING:
Libraries in general contain 2 components. The headers and the library definition files (in binary format). The compiler requires the header files, The linker is then linking the library files.

(If anything above is wrong, please correct me).

MY QUESTIONS:

1) In case the binary files are not supplied for ARM processor, do I need to use Altera tools to compile the library source code on my Windows 7 machine with ARM compiler ? 
I believe to use the Altera supplied compiler terminal, to run ./configure, make

2) For such widely used libraries such as libcURL, there are pre-compiled binaries for different platforms. How do I know what the compiled library looks like ? What files are necessary for Eclipse to compile the whole project (please be specific : *.lib, *.a, *.h, ...) 

SUMMARY:
I am perplexed by cross-compilation, I am not sure, which compiler is required, and which library files are required.

Most common error I have came across is :

cannot find -lcurl


Does that mean the compiler can see *.h files, but the Linker is not able to locate binary files ?","Finally, I did the following :

I have copied the library source files to my target platform (Altera De_nano_SoC ARM) and compiled the library there (Angstrom Linux, compiler arm-angstrom-linux-gnueabi). This requires setting configuration file in library folder, and running make and make install commands.

Once compiled, I copied the output files (headers *.h and static library files *.a OR shared library files *.so - depending on compilation configuration) to my host machine (Windows 7). Then I have added the files to my Eclipse DS-5 project.

The Eclipse requires the path of .../include folder with header files *.h and the .../lib folder including *.a or *.so files.",,,,,
iverilog syntax for include?,"I'm trying to include a Verilog file (alu.v) in my main file (cpu.v). Both files are in the same directory.

'include ""alu.v""

 module cpu();
 ...
 ...
 endmodule


When I try to compile it, I get the following error.

cpu.v:1 syntax error
I give up


I don't see how the include statement is wrong. I'm sure my syntax is correct like shown here.","Don't be so sure! Proof you mess with something, it does not work.

The preprocessor directives in Verilog begin with a back-tick (`) not an apostrophe (').

Try:

`include ""alu.v""


Instead of:

'include ""alu.v""
",,,,,
Difference between assigning signal inside process vs assigning actual ouput,"So through my own study I understand that if we assign a signal inside a process, it will update after the process. Now if we directly assign an output a value will it also get updated after the process or not?
I am attaching two versions as a simple example to demonstrate what I mean.

Version 1: 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity testing is
port(
    clk : in std_logic;
    a   : in std_logic;
    b   : in std_logic;
    c   : out std_logic
);

end testing;

architecture arch of testing is

signal temp: std_logic;

begin

process(clk)

begin

    if(rising_edge(clk)) then

        if(a = '1' and b = '1') then

            temp &lt;= '1'

        end if;

    end if;

end process;

c &lt;= temp;

end arch;


Now the other version:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity testing is
port(
    clk : in std_logic;
    a   : in std_logic;
    b   : in std_logic;
    c   : out std_logic
);

end testing;

architecture arch of Intermediate is

begin

process(clk)

begin

    if(rising_edge(clk)) then

        if(a = '1' and b = '1') then

            C &lt;= '1';

        end if;

    end if;

end process;

end arch;


Is there a timing difference here? Will C go high sooner in the second version than compared to the first version? ","C will be assigned (slightly) earlier in your second example, compared to your first. Also, less resources are used, as there is no intermediate register (temp) in your second example.

In your first example, temp will be assigned on the falling edge of clock, and C is a concurrent assignment (ie. As soon as temp changes, C changes). However, in practice this assignment happens some ""small amount of time"" after temp changes, due to signal propagation.

In your second example, you are directly assigning to C, which will occur on the falling clock edge.

I know the example you have provided is somewhat contrived, but you could achieve the same with:

process(clk)
begin
    if rising_edge(clk) then
        c &lt;= a and b;
    end if;
end process;
",,,,,
unpacked union in systemverilog,"
  typedef union {
        logic [1:0] c3; 
        bit [3:0] a3; 
        byte b3; 
    } pack3;
  
  pack3 p3;


According to LRM, the default initialization is according to the first member of union i.e logic in above example, therefore, c3 assign to X and rest to assign to 0 but when I compile in ModelSim and check in object window then there is a different result for a3 and b3.Also when I assign p3.a3 = 4'b0010; the value of a3 and b3 changes but not c3.Please Explain? I know there is only memory available for each variable so update in any value reflects all.",There are no guarantees if you write to one member of an unpacked union and try to read another member (except for one special provision mentioned at the end of section 7.3 Unions in the 1800-2012 LRM). You need to use a packed union if you want a guarantee in the layout of overlapping members. ,,,,,
Associative array with wildcard in system verilog,"Is it possible to iterate over an associative array with wildcard ""*"" using foreach loop?","No. IEEE 1800-2012 &sect; 7.8.1 Wildcard index type states:


  Associative arrays that specify a wildcard index type shall not be
  used in a foreach loop (see
  12.7.3) or with an array manipulation method (see 7.12) that returns an index value or array of values.
",,,,,
Verilog FIR filter code error,"I'm having issues with the signal output of my FIR signal. The signal does not filter out and there's a lot of static. Although my implementation seems to be working fine. My multiplier function has been created from the existing libraries in the quartus software and was set to signed multiplication. I really have no idea whats going on and would appreciate any help! Thank you!

Code: 

`timescale 1ns / 1ps
module fir_filter (input sample_clock, input reset, input [15:0]     input_sample1,     output [15:0] output_sample1);

parameter N = 65; //Specify the number of taps

reg  [15:0] delayholder[N-1:0];

wire [31:0] summation[N-1:0];

wire [15:0] finsummations[N-1:0];
wire [15:0] finsummation;

integer x;
integer z;

//Specifying our coefficients
reg signed[15:0] coeffs[200:0];


always @(*)
begin

for (x=0; x&lt;N; x=x+31)
begin

coeffs[x+0] = 0;
coeffs[x+1] = 2267;
coeffs[x+2] = 0;
coeffs[x+3] = -3030;
coeffs[x+4] = 0;
coeffs[x+5] = 4621;
coeffs[x+6] = 0;
coeffs[x+7] = -6337;
coeffs[x+8] = 0;
coeffs[x+9] = 7985;
coeffs[x+10] = 0;
coeffs[x+11] = -9536;
coeffs[x+12] = 1;
coeffs[x+13] = 10265;
coeffs[x+14] = -1;
coeffs[x+15] = 87720;
coeffs[x+16] = -1;
coeffs[x+17] = 10265;
coeffs[x+18] = 1;
coeffs[x+19] = -9536;
coeffs[x+20] = 0;
coeffs[x+21] = 7985;
coeffs[x+22] = 0;
coeffs[x+23] = -6337;
coeffs[x+24] = 0;
coeffs[x+25] = 4621;
coeffs[x+26] = 0;
coeffs[x+27] = -3030;
coeffs[x+28] = 0;
coeffs[x+29] = 2267;
coeffs[x+30] = 0;
 end
end

generate
genvar i;
for (i=0; i&lt;N; i=i+1)
begin: mult1
    multiplier mult1(.dataa(coeffs[i]),     .datab(delayholder[i]),.result(summation[i]));
end
endgenerate

always @(posedge sample_clock or posedge reset)
begin
if(reset)
    begin
      output_sample1 = 0;
      for (z=0; z&lt;N; z=z+1)
      begin
      delayholder[z] = 0;
      end
end

else
    begin  
      for (z=N-1; z&gt;0; z=z-1)
      begin
      delayholder[z] = delayholder[z-1];
      end
      delayholder[0] = input_sample1;
end

     for (z=0; z&lt;N; z=z+1)
     begin
    finsummations[z] = summation[z] &gt;&gt; 15;  //{summation[z][15],        summation[z][15], summation[z][15:2]}
    end

      finsummation = 0;
     for (z=0; z&lt;N; z=z+1)
      begin
      finsummation = finsummation + finsummations[z];
      end

      output_sample1 = finsummation;
end

endmodule


Multiplier code:

`timescale 1 ps / 1 ps
module multiplier (dataa,datab,result);

input  [15:0]  dataa;
input    [15:0]  datab;
output [31:0]  result;

wire [31:0] sub_wire0;
wire [31:0] result = sub_wire0[31:0];

lpm_mult    lpm_mult_component (
            .dataa (dataa),
            .datab (datab),
            .result (sub_wire0),
            .aclr (1'b0),
            .clken (1'b1),
            .clock (1'b0),
            .sum (1'b0));
defparam
    lpm_mult_component.lpm_hint = ""MAXIMIZE_SPEED=5"",
    lpm_mult_component.lpm_representation = ""SIGNED"",
    lpm_mult_component.lpm_type = ""LPM_MULT"",
    lpm_mult_component.lpm_widtha = 16,
    lpm_mult_component.lpm_widthb = 16,
    lpm_mult_component.lpm_widthp = 32;
","I'm no expert on filters, but I see a couple of potential issues in the block of code used to initialize the coefficients. First, I'd suggest making this an initial block since it only really needs to happen once. Second, with a 16-bit signed value, you have a range of -32767 to +32768, but one of your coefficients is 87720, which is out of range. Since Verilog is not strongly typed like VHDL, you can do this, but the results will not be what you want. You either need to change that coefficient value or increase the bit-width of your coefficients and change your multiplier code to work with the increased width. Finally, you have a 201 coefficients specified, but your assignment logic is only going to assign values to coeffs 0 through 92. This should show up as a bunch of ""X""s in your simulation (you did try this in simulation, right?). When synthesizing your design, your tool should complain, but it may just assign zero values to the initialized locations (Xilinx's Vivado does this, I'm not sure how about other tools). In any case, there is going to be a difference between what you hope to achieve and what the tool will produce. ",,,,,
Not getting simulated output for an error free verilog code,"I'm somewhat new to verilog. So this question might be very simple. 
I'm trying to simulate an finite state machine using verilog.
Brief description: 
There are three states: 0,1 &amp; 2. By default, State is 0.
The state changes to 1 only if input is 01.
The state changes to 2 only if input is 10.
The state changes back to 0 only if input is 00.
The code is getting simulated successfully, but I.m getting no output. Please help me with the problem.

Code: (State.v)

module State(
    input clk,
    input reset,
     input [3:0] in,
     output [3:0] out,
     output [3:0] state
    );

     wire clk,reset;
     wire [3:0] in;
     reg [3:0] out;
     reg [3:0] state;

     always @(posedge clk or posedge reset)
      begin
      if (reset == 1)
        begin
            state = 0;
        end
      else 
        begin
            case (state)
                0: if(in == 2'b01)
                         state = 1;
                        else
                         state = 0;
                1: if(in == 2'b10) 
                        state = 2;
                      else
                       state = 1;
                2: if(in == 2'b00)
                        state = 0;
                      else
                       state = 2;
                default: state = 0;     
            endcase 
        end 
     end    

     always @(*)
        begin
            case (state)
                0: out = 2'b00;
                1: out = 2'b01;
                2: out = 2'b10;
                default: out = 2'b00;
            endcase     
        end     

endmodule


Testbench: (StateTestBench.v)

module StateTestBench;

    // Inputs
    reg clk;
    reg reset;
    reg [3:0] in;

    // Outputs
    reg [3:0] out;
    reg [3:0] state;

    always
        begin
            #1 clk = !clk;
        end 

    // Instantiate the Unit Under Test (UUT)
    State uut (
        .clk(clk), 
        .reset(reset), 
        .in(in),
        .out(out),
        .state(state) 
    );

    initial begin
        // Initialize Inputs
        clk = 0;
        reset = 0;

        #1 reset = 1;
        #10 reset = 0;
        #5 in = 2'b00;
        #10 in = 2'b01;
        #10 in = 2'b10;



    end

endmodule
",I guess you simulate state.v instead of StateTestBench.v. Because your testbench has a bug! Outputs out and state MUST be wires.,,,,,
How to use 2 different instances of the same class intest?,"I have the following run_phase task in one of my test:

   //run_phase
   task run_phase(uvm_phase phase);
      tx_big_sml_diff_sequence tx_seq_i;
      axi_config_reg_sequence axi_seq_i;
      phase.raise_objection(.obj(this));
      for (int i = 2; i &lt;= 9; i++) begin
                tx_seq_i = tx_big_sml_diff_sequence::type_id::create(.name(""tx_seq_i""), .contxt(get_full_name()));
                axi_seq_i = axi_config_reg_sequence::type_id::create(.name(""axi_seq_i""), .contxt(get_full_name()));
                axi_seq_i.transfers[0] = i;
                axi_seq_i.addr = `TX_FE_LIN_INT_ADDR;
                fork
                    begin
                       tx_seq_i.start(grb_env_i.tx_lin_int_agent_i.tx_lin_int_sequencer);   
                    end
                    begin
                       axi_seq_i.start(grb_env_i.axi_agent_i.axi_sequencer);
                    end
                join
      end
      phase.drop_objection(.obj(this));
      super.run_phase(phase);
   endtask // run_phase


Where axi_config_reg_sequence is sequence which is responsible for config specific reg (according to given address).

I want to config another reg beside TX_FE_LIN_INT_ADDR, how can I use the same sequence for config another?","You are not providing any details about the axi_config_reg_sequence implementation, so I am going to assume that the addr variable automatically takes care of configuring a register at that particular address.  If that is the case, you can instantiate the same sequence one more time and then start it on the same sequencer as seen below:

          tx_seq_i = tx_big_sml_diff_sequence::type_id::create(.name(""tx_seq_i""), .contxt(get_full_name()));
          axi_seq1_i = axi_config_reg_sequence::type_id::create(.name(""axi_seq1_i""), .contxt(get_full_name()));
          axi_seq2_i = axi_config_reg_sequence::type_id::create(.name(""axi_seq2_i""), .contxt(get_full_name()));

          axi_seq1_i.transfers[0] = i;
          axi_seq1_i.addr = `TX_FE_LIN_INT_ADDR;

          axi_seq2_i.transfers[0] = `SET_THIS_VARIABLE_AS_NEEDED;
          axi_seq2_i.addr = `YOUR_OTHER_ADDRESS_GOES_HERE;

          fork
              begin
                 tx_seq_i.start(grb_env_i.tx_lin_int_agent_i.tx_lin_int_sequencer);   
              end
              begin
                 axi_seq1_i.start(grb_env_i.axi_agent_i.axi_sequencer);
                 axi_seq2_i.start(grb_env_i.axi_agent_i.axi_sequencer);
              end
          join
",,,,,
multipile 8bit registers connected to the same output (VHDL),"I create a 64bytes RAM using two 3bit address registers and cross bar of the 3 bit registers using two 3to8 decoders. Here is the VHDL code:

library ieee;
use ieee.std_logic_1164.all;

entity ram88 is
  port(a : in std_logic_vector (2 downto 0);
       s0: in std_logic;
       s1: in std_logic;
       s:  in std_logic;
       e:  in std_logic;
       io_in: in std_logic_vector (7 downto 0);
       io_out:out std_logic_vector (7 downto 0));

end ram88;

architecture behavior of ram88 is

  component reg3 is
    port( a : in std_logic_vector (2 downto 0);
          ss,e : in std_logic; --st and enable
          b : out std_logic_vector (2 downto 0));
  end component;

  component reg8 is
    port( a : in std_logic_vector (7 downto 0);
          ss,e : in std_logic; --st and enable
          b : out std_logic_vector (7 downto 0));
  end component;

  component decod8 is
    port( a : in std_logic_vector (2 downto 0);
          b : out std_logic_vector (7 downto 0));
  end component;

  signal e1 : std_logic := '1';
  signal l0, l1 : std_logic_vector (2 downto 0);
  signal ll0, ll1 : std_logic_vector (7 downto 0);
  type arr2d is array (7 downto 0, 7 downto 0) of std_logic;  
  signal andij, fin_s, fin_e : arr2d;

begin

  e1 &lt;= '1';

  reg0: reg3 port map ( a =&gt; a, ss =&gt; s0, e =&gt; e1, b =&gt; l0);
  reg1: reg3 port map ( a =&gt; a, ss =&gt; s1, e =&gt; e1, b =&gt; l1);
  decod0: decod8 port map(a =&gt; l0, b =&gt; ll0);
  decod1: decod8 port map(a =&gt; l1, b =&gt; ll1);

  mem_blks_ii:
  for ii in 0 to 7 generate
    mem_blks_jj:
    for jj in 0 to 7 generate
      andij(ii,jj) &lt;= ll0(ii) and ll1(jj);
      fin_s(ii,jj) &lt;= andij(ii,jj) and s;
      fin_e(ii,jj) &lt;= andij(ii,jj) and e;
      regij: reg8 port map(a=&gt; io_in, ss=&gt; fin_s(ii,jj), e =&gt; fin_e(ii,jj), b =&gt; io_out);
    end generate mem_blks_jj;
  end generate mem_blks_ii;


end behavior;


Then I use the following test unit for simulation. It sets the value 00000001 at memory address 000x000. At the end, it retrieves the value by setting the enable signal:

library ieee;
use ieee.std_logic_1164.all;

entity ram88_bench is

end ram88_bench;

architecture behavior of ram88_bench is

  component ram88
  port(a : in std_logic_vector (2 downto 0);
       s0: in std_logic;
       s1: in std_logic;
       s:  in std_logic;
       e:  in std_logic;
       io_in: in std_logic_vector (7 downto 0);
       io_out:out std_logic_vector (7 downto 0));
  end component;

  signal abar : std_logic_vector (2 downto 0);
  signal s0bar, s1bar, sbar, ebar:  std_logic;
  signal io_in_bar, io_out_bar: std_logic_vector (7 downto 0);

begin

  ram0: ram88 port map(a=&gt;abar, s0=&gt; s0bar, s1=&gt; s1bar
                       , s=&gt; sbar, e=&gt; ebar
                       , io_in =&gt; io_in_bar, io_out=&gt; io_out_bar);

  process
  begin

    -- set (0,1) for access point in memory
    abar &lt;= ""000"";
    s0bar &lt;= '1';
    s1bar &lt;= '0';
    wait for 2 fs;
    s0bar &lt;= '0';

    abar &lt;= ""000"";
    s1bar &lt;= '1';
    wait for 2 fs;
    s1bar &lt;= '0';

    -- store the value ...
    ebar &lt;= '1';
    sbar &lt;= '1';
    io_in_bar &lt;= ""00000001"";
    wait for 2 fs;
    sbar &lt;= '0';

    ---- temporary clear the value before retrieval
    --sbar &lt;= '0';
    --ebar &lt;= '0';
    ---- io_in_bar &lt;= ""00000000"";    
    --wait for 2 fs;

    --retrieve the value ????
    ebar &lt;= '1';
    sbar &lt;= '0';
    wait for 6 fs;

    wait;

  end process;

end behavior;


The problem is that the value in io_out_bar is forced to unknowns ""0X"" instead of expected 00000001 at the end of simulation! I couldn't figure out why but I guess since all 8bit RAM registers are connected to the same output, it can't be determined which one is the real value we need to retrieve. How can I resolve this issue?  ","You're question isn't a Minimal, Complete and Verifiable example and it helps to demonstrate the solution.  Some quick and dirty entities for instantiation:

library ieee;
use ieee.std_logic_1164.all;

entity reg3 is
    port (
        a:      in  std_logic_vector (2 downto 0);
        ss,e:   in  std_logic;
        b:      out std_logic_vector (2 downto 0)
    );
end entity;

architecture foo of reg3 is
begin
    b &lt;= a when ss = '1' and e = '1';
end architecture;

library ieee;
use ieee.std_logic_1164.all;

entity decod8 is
    port (
        a:      in  std_logic_vector (2 downto 0);
        b:      out std_logic_vector (7 downto 0)
    );
end entity;

architecture foo of decod8 is
    use ieee.numeric_std.all;
begin
    process (a)
        variable idx:   natural range 0 to 7;
    begin
        idx := to_integer(unsigned(a));
        b &lt;= (others =&gt; '0');
        b(idx) &lt;= '1';
    end process;
end architecture;

library ieee;
use ieee.std_logic_1164.all;

entity reg8 is
    port (
        a:      in  std_logic_vector (7 downto 0);
        ss,e:   in  std_logic;
        b:      out std_logic_vector (7 downto 0)
    );
end entity;

architecture foo of reg8 is
begin
    b &lt;= a when ss = '1' and e = '1';
end architecture;    



  ... I guess since all 8bit RAM registers are connected to the same output, it can't be determined which one is the real value we need to retrieve. How can I resolve this issue?


You surmise correctly, all 64 8 bit registers drive io_out.

The idea here is to select only one at a time according to the index supplied to the RAM.  The example uses the same write addresses from the l0 and l1 latches, used to select 1 of 64 8 bit registers for output.

It's done purely behaviorally here, but could be done with instantiated multiplexers (selectors):

architecture behavior of ram88 is

  component reg3 is
    port( a : in std_logic_vector (2 downto 0);
          ss,e : in std_logic; --st and enable
          b : out std_logic_vector (2 downto 0));
  end component;

  component reg8 is
    port( a : in std_logic_vector (7 downto 0);
          ss,e : in std_logic; --st and enable
          b : out std_logic_vector (7 downto 0));
  end component;

  component decod8 is
    port( a : in std_logic_vector (2 downto 0);
          b : out std_logic_vector (7 downto 0));
  end component;

  signal e1 : std_logic := '1';
  signal l0, l1 : std_logic_vector (2 downto 0);
  signal ll0, ll1 : std_logic_vector (7 downto 0);
  type arr2d is array (7 downto 0, 7 downto 0) of std_logic;  
  signal andij, fin_s, fin_e : arr2d;
  type mux is array (7 downto 0, 7 downto 0) of    -- ADDED
              std_logic_vector (7 downto 0);
  signal mux88: mux;                               -- ADDED
  signal idxii, idxjj:  natural range 0 to 7;      -- ADDED
  use ieee.numeric_std.all;                        -- ADDED

begin

  e1 &lt;= '1';

  idxii &lt;= to_integer(unsigned(l0));              -- ADDED
  idxjj &lt;= to_integer(unsigned(l1));              -- ADDED

  reg0: reg3 port map ( a =&gt; a, ss =&gt; s0, e =&gt; e1, b =&gt; l0);
  reg1: reg3 port map ( a =&gt; a, ss =&gt; s1, e =&gt; e1, b =&gt; l1);
  decod0: decod8 port map(a =&gt; l0, b =&gt; ll0);
  decod1: decod8 port map(a =&gt; l1, b =&gt; ll1);

  mem_blks_ii:
  for ii in 0 to 7 generate
    mem_blks_jj:
    for jj in 0 to 7 generate
      andij(ii,jj) &lt;= ll0(ii) and ll1(jj);
      fin_s(ii,jj) &lt;= andij(ii,jj) and s;
      fin_e(ii,jj) &lt;= andij(ii,jj) and e;
    -- regij: reg8 port map(a=&gt; io_in, ss=&gt; fin_s(ii,jj), e =&gt; fin_e(ii,jj), b =&gt; io_out);   -- CHANGED 
    regij: reg8 port map(a=&gt; io_in, ss=&gt; fin_s(ii,jj), e =&gt; fin_e(ii,jj), b =&gt; mux88(ii,jj));        -- CHANGED 
    end generate mem_blks_jj;
  end generate mem_blks_ii;

  io_out &lt;= mux88(idxii, idxjj);    -- ADDED READBACK MUX

end behavior;


And that gives: 



RAM read back.

The 8 by 8 by 8-bit std_logic_vector value has one of 64 b-bit values selected by the two added indexes. If you were to construct it from instantiated components, synthesize and count where all the logic gates are you'd find it's about the same size as the latches used for RAM and their fan-in buffers, and quite a bit bigger than the write steering logic.",,,,,
Whether $display syntax works during post-route simulation in verilog HDL,"I am trying to monitor one internal signal during post-route simulation.

So I used $display syntax within the verilog code.

However, in console nothing is showing.

I used the following syntax within my verilog code 

always @(negedge clk)
begin
$display(""Decimal: %d"", idatabuf); 
end


So my question is whether the $display syntax does not work for post route simulation?

Anyways, I am going the crude way of getting the internal signal as output. But, if the syntax $display works, my life would be more easier. ","As Laleh said, $display is not synthetizable. To do what you want you should use hierarchical reference on your signal after synthesis in your testbench. e.g. In your testbench you can add: 

always@* 
  $display(""Decimal: %d"", u_top.u_mymod.idatabuf);`


It should print idatabuf each time it changes.

N.B.: If the signal you want to monitor is an internal signal and not a pin of a hierarchical module, synthesis tools tend to simplify for logical optimization. If you want to monitor such a signal you should bind to drive a black box input. In Synopsys tools, the simplest way to make a black box is to create an empty module.

module BlackBox (I,O);
  parameter SIZE=1;
  input [SIZE-1:0] I;
  output[SIZE-1:0] O;
endmodule
",,,,,
Why is this MUX with const. inputs not optimised away?,"This is a follow-up question to Combinatorial synthesis: Better technology mapping results.

I am using Yosys (version 0.5+ (git sha1 f13e387, gcc 5.3.1-8ubuntu2 -O2 -fstack-protector-strong -fPIC -Os)) with the following synthesis script:

read_liberty -lib  my_library.lib
read_verilog test.v
hierarchy -check -top test
proc; opt; memory; opt; fsm -norecode; opt
techmap; opt
dfflibmap -liberty my_library.lib
abc -liberty my_library.lib -script \
    +strash;ifraig;scorr;dc2;dretime;strash;&amp;get,-n;&amp;dch,-f;&amp;nf,{D};&amp;put
hilomap -hicell LIB_TIEHI Y -locell LIB_TIELO Y
clean
write_verilog -noattr -noexpr output.v
stat


...to synthesise the following Verilog code (test.v):

module mux4(
    input  i0, i1, i2, i3,
    input  s0, s1,
    output z);
  reg    zint;
  always @(*) begin
    case ({s1, s0})
      2'b00:   zint = i0;
      2'b01:   zint = i1;   
      2'b10:   zint = i2;   
      2'b11:   zint = i3;   
      default: zint = i3;
    endcase
  end
  assign z = zint;
endmodule

module test (
    input a,b,c,d,
    output result
  );
  mux4 inst (
    .i0(a), .i1(b), .i2(c), .i3(d), 
    .s0(1'b0), .s1(1'b0),           # constants here!
    .z(result)
  );
endmodule


The synthesis results include a LIB_MUX4 instance with both S0 and S1 tied low by two LIB_TIELO instances.

Why doesn't Yosys see that S0 and S1 are constant and reduce the output to something like this

module test(a, b, c, d, result);
  input a;
  input b;
  input c;
  input d;
  output result;
  assign result = a;
endmodule


instead?

I tried using the clean -purge, opt_muxtree and opt_clean commands, but without success - the static LIB_MUX instance is always in the resulting netlist.","
You need to run flatten if you want optimization across hierarchical boundaries.
You probably want to run opt -full shortly before running techmap, but after running high-level optimizations like fsm and share.
JFYI: If you do not provide all files necessary to run your test case, people will not be able to reproduce what you are talking about. I don't have your my_library.lib, so I did not even bother trying to run your code.
",,,,,
Driving a bitslice of a virtual interface signal through a task,"I'm trying to create a task that's responsible for setting a bit of a vector and clearing it after one clock cycle. My driver code is attached below:
class my_if_driver extends uvm_driver;
  `uvm_component_utils(my_if_driver)
 
  // Members
  // UVM stuff
  virtual my_if_interface vif;
 
  function new(string name=&quot;my_if_driver&quot;, uvm_component parent);
    super.new(name, parent);
  endfunction
 
  extern function void build_phase(uvm_phase phase);
  extern function void connect_phase(uvm_phase phase);
  extern task          run_phase(uvm_phase phase);
 
  extern task drive_my_if(my_if_transaction txn);
  extern task set_then_clear(ref logic signal);
endclass
 
function void my_if_driver::build_phase(uvm_phase phase);
endfunction
 
function void my_if_driver::connect_phase(uvm_phase phase);
endfunction
 
task my_if_driver::run_phase(uvm_phase phase);
  @(posedge vif.resetn);
  forever begin
    seq_item_port.get_next_item(req);
    fork
      drive_my_if(req);
    join_none
    seq_item_port.item_done(req);
  end
endtask

// NOTE: each 'command-signal' has bit for each tid (transaction ID)
task my_if_driver::drive_my_if(my_if_transaction txn);
  // Wait for delay
  repeat (txn.cycle_delay) @(posedge vif.clk);
  // Then drive appropriate signal
  if (txn.my_if_cmd == my_if_transaction::CMDA) begin
    set_then_clear(vif.my_if_cmd_a[txn.tid]);
  end
  else if (txn.my_if_cmd == my_if_transaction::CMDB) begin
    set_then_clear(vif.my_if_cmd_b[txn.tid]);
  end
  else if (txn.my_if_cmd == my_if_transaction::CMDC) begin
    set_then_clear(vif.my_if_cmd_c[txn.tid]);
  end
endtask
 
task my_if_driver::set_then_clear(ref logic signal);
  signal &lt;= 1'b1;
  @(posedge vif.clk);
  signal &lt;= 1'b0;
endtask

I get the following errors (Questa 10.6) :

** Error: path_to_driver.svh(53): LHS in non-blocking assignment may not be an automatic variable
** Error: path_to_driver.svh(55): LHS in non-blocking assignment may not be an automatic variable

These point to the non-blocking assignments to 'signal' in the set_then_clear task. Is there a way to point to a bitslice of a virtual interface via a ref argument?","The LRM says 


  Because a variable passed by reference may be an automatic variable, a
  ref argument shall not be used in any context forbidden for automatic
  variables.


And you cannot pass a bit select of a packed variable by reference, only the whole variable. 

There is no easy way to do this without writing separate tasks for each cmd, or a big case statement inside a signal task that selects the interface variable you want to assign. ",,,,,
Does the process get activated or suspended?,"I am still having a little bit of trouble understanding the sensitivity list and it activating a process. 
most textbooks say that a process is activated every time an event occurs on a signal inside the sensitivity list.

process(in)
begin
    x &lt;= in;
end process;


Now looking at this example, ""in"" is an input declared in the entity. Now if ""in"" starts off at 0 and changes to 1 then the process would activate and the value of x would take in value ""in"". Now suppose after in changed from 0 to 1 that it now stays at constant value of 1. Does this mean the process will not get activated? Will x still give output of '1'? I want to say that it wont get activated and will only activate once in changes back from 1 back to 0. Can someone please confirm? ","Within the sensitivity list (I assume this is hardware language, VHDL has the same exact syntax and format), whenever there is some type of signal change (L-> H, 0 ->1, 1-> 0... any change in the variable you listed within the sensitivity list), it will activate the process and the process will execute until completion, which then the process will end. When the process end, signals/outputs (depends on how you interpret them) will be stored on a driver, which will update given signals after some propagation delay.

So from your second statement, yes. If it changes to 0 -> 1, the process activates, if its 1 -> 0, the process activates, and if in remains 1, the process will not be activated. So x's value remains.",,,,,
ISim shows U for all outputs,"I have a simple VHDL design and test bench that does not produce the expected output. ISim shows 'U' for all the outputs until the 'running' state is achieved (myState='1'). Then they show 0 and X values. The first PROCESS block should set all outputs to '0' when ENABLE is '0'. The test bench toggles ENABLE 0-1-0 to insure an event triggers the process, but the outputs stay at 'U'. Is the problem in the design, the test, or both?

VHDL

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity TestHarness1 is
port (
    ADAT_WDCLK : in std_logic;
    ADAT_BCLK: in std_logic;
    ADAT_OUT12: in std_logic;
    ENABLE: in std_logic;

    PCM_FS : out std_logic;
    PCM_CLK : out std_logic;
    PCM_DIN : out std_logic
);
end TestHarness1;

architecture Behavioral of TestHarness1 is
    --type state is (STOPPED, RUNNING);
    signal tmp : std_logic;
    signal myState : std_logic;
begin
    PCM_DIN &lt;= tmp; 

    -- State management process
    process (ENABLE, ADAT_WDCLK) begin -- Eval on input changes
        if (ENABLE = '0') then 
            myState &lt;= '0'; --STOPPED;
            PCM_FS &lt;= '0'; -- All outputs muted
            PCM_CLK &lt;= '0';
            tmp &lt;= '0';
        else
            if (myState = '0' and rising_edge(ADAT_WDCLK)) then
                -- Move to running state only at start of a frame
                myState &lt;= '1'; --RUNNING;
            end if;
        end if;
    end process;

    -- Output process
    process (ADAT_WDCLK, ADAT_BCLK, myState) variable counter: integer := 0; begin
        -- Only do something if we are in running state, process above
        -- sets outputs when stopped.
        if (myState = '1') then

            -- Pass the clocks through, inverting the bit clock
            PCM_FS &lt;= ADAT_WDCLK;
            PCM_CLK &lt;= not ADAT_BCLK;

            -- Generate fixed bit pattern data '11000101'
            if rising_edge(ADAT_WDCLK) then
                -- This would happen naturally since there are 4 bytes per word clock
                counter := 0;
            end if;
            if falling_edge(ADAT_WDCLK) then
                -- This would happen naturally since there are 4 bytes per word clock
                counter := 0;
            end if;
            if rising_edge(ADAT_BCLK) then -- Change data state only on falling edge of output PCM_CLK
                if counter = 0 or counter = 1 or counter = 5 or counter = 7 then
                    tmp &lt;= '1';
                else
                    tmp &lt;= '0';
                end if;
                if (counter = 7) then
                    counter := 0;       -- Reset counter
                else
                    counter := counter + 1; -- Just inc counter
                end if;

            end if;
        end if;
    end process;
end Behavioral;


Test Bench

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;

ENTITY TH1TestBench3 IS
END TH1TestBench3;

ARCHITECTURE behavior OF TH1TestBench3 IS 

    -- Component Declaration for the Unit Under Test (UUT)

    COMPONENT TestHarness1
    PORT(
         ADAT_WDCLK : IN  std_logic;
         ADAT_BCLK : IN  std_logic;
         ADAT_OUT12 : IN  std_logic;
         ENABLE : IN  std_logic;
         PCM_FS : OUT  std_logic;
         PCM_CLK : OUT  std_logic;
         PCM_DIN : OUT  std_logic
        );
    END COMPONENT;


   --Inputs
   signal ADAT_WDCLK : std_logic := '0';
   signal ADAT_BCLK : std_logic := '0';
   signal ADAT_OUT12 : std_logic := '0';
   signal ENABLE : std_logic := '0';

    --Outputs
   signal PCM_FS : std_logic;
   signal PCM_CLK : std_logic;
   signal PCM_DIN : std_logic;

   -- Clock period definitions. Note WDCLK is defined in terms of the bit clock
    -- to insure they are exactly in sync.
   constant ADAT_BCLK_period : time := 326 ns; -- About 3.072MHz (https://www.sensorsone.com/frequency-to-period-calculator/)
   constant ADAT_WDCLK_period : time := ADAT_BCLK_period * 64; -- 48KHz

BEGIN

    -- Instantiate the Unit Under Test (UUT)
   uut: TestHarness1 PORT MAP (
          ADAT_WDCLK =&gt; ADAT_WDCLK,
          ADAT_BCLK =&gt; ADAT_BCLK,
          ADAT_OUT12 =&gt; ADAT_OUT12,
          ENABLE =&gt; ENABLE,
          PCM_FS =&gt; PCM_FS,
          PCM_CLK =&gt; PCM_CLK,
          PCM_DIN =&gt; PCM_DIN
        );


   -- Clock process definitions
   ADAT_WDCLK_process :process
   begin
        ADAT_WDCLK &lt;= '0';
        wait for ADAT_WDCLK_period/2;
        ADAT_WDCLK &lt;= '1';
        wait for ADAT_WDCLK_period/2;
   end process;

   ADAT_BCLK_process :process
   begin
        ADAT_BCLK &lt;= '1';
        wait for ADAT_BCLK_period/2;
        ADAT_BCLK &lt;= '0';
        wait for ADAT_BCLK_period/2;
   end process;


   -- Stimulus process
   stim_proc: process
   begin        
      -- hold reset state for 100 ns.
      wait for 100 ns;  
        ENABLE &lt;= '1';
        wait for 100 ns;
        ENABLE &lt;= '0';
        wait for 7500 ns;
        ENABLE &lt;= '1';


      wait for ADAT_WDCLK_period*10;

      -- insert stimulus here 

      wait;
   end process;

END;


ISim shows the ENABLE pulse early in the simulation, but the outputs remain 'U' until the rising edge of the WCLK with ENABLE=1. Then they start to change (as designed) but they show some X values.



Modified VHDL

For reference, here is the modified VHDL that resolves the problem of U's and X's in the simulation output. However, there is a functional problem with the PCM_DIN output... seems like it is delayed one (BCLK) cycle. I expected it to be '1' as soon as ADAT_WDCLK goes high the first time after ENABLE. But it does not go to '1' until a BLCK cycle later.

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity TestHarness1 is
port (
    ADAT_WDCLK : in std_logic;
    ADAT_BCLK: in std_logic;
    ADAT_OUT12: in std_logic;
    ENABLE: in std_logic;

    PCM_FS : out std_logic;
    PCM_CLK : out std_logic;
    PCM_DIN : out std_logic
);
end TestHarness1;

architecture Behavioral of TestHarness1 is
    --type state is (STOPPED, RUNNING);
    signal tmp : std_logic;
    signal myState : std_logic;
begin
    PCM_DIN &lt;= tmp; 

    -- State management process
    process (ENABLE, ADAT_WDCLK) begin -- Eval on input changes
        if (ENABLE = '0') then 
            myState &lt;= '0'; --STOPPED;
        else
            if (myState = '0' and rising_edge(ADAT_WDCLK)) then
                -- Move to running state only at start of a frame
                myState &lt;= '1'; --RUNNING;
            end if;
        end if;
    end process;

    -- Output process
    process (ADAT_WDCLK, ADAT_BCLK, myState) variable counter: integer := 0; begin
        -- Only do something if we are in running state
        if (myState = '0') then
            PCM_FS &lt;= '0'; -- All outputs muted
            PCM_CLK &lt;= '0';
            tmp &lt;= '0';
        elsif (myState = '1') then
            -- Pass the clocks through, inverting the bit clock
            PCM_FS &lt;= ADAT_WDCLK;
            PCM_CLK &lt;= not ADAT_BCLK;

            if rising_edge(ADAT_BCLK) then -- Generate fixed serial bit pattern
                if counter = 0 or counter = 1 or counter = 5 or counter = 7 then
                    tmp &lt;= '1';
                else
                    tmp &lt;= '0';
                end if;
                if (counter = 7) then
                    counter := 0;       -- Reset counter
                else
                    counter := counter + 1; -- Just inc counter
                end if;

            end if;
        end if;
    end process;

end Behavioral;


ISim of the above (including the internal myState signal)... why is PCM_DIN delayed one BCLK cycle?

","Regarding the 'X' (Forcing Unknown) values you are seeing:

You are driving the signals PCM_FS, PCM_CLK and tmp from multiple processes, which results in the simulator being unable to resolve the value  being driven. You need to fix this such that they are only being driven from one process, or drive 'Z' when they are not in use.

Regarding the 'U' values, they exist because you have no initial values for the signals. Once you write the signals for the first time (after the enable), they will be assigned for the first time.",,,,,
Signal value won't be initialized during simulation,"We've a project for college where we have to simulate a MAC unit for DSP.
For the simulation, I'm using Aldec Riviera Pro 2014.06 through EDA playground.
The problem is that even though I initialized a 32-bit signed signal named add_res, at the simulation its value will be shown as XXXX_XXXX the whole time.

Here's the simulation's result.

Here's the code of the design.vhd

LIBRARY IEEE;
USE IEEE.std_logic_1164.all;
USE IEEE.numeric_std.all;
-----------------------------
ENTITY mac IS
      PORT (B, C : IN SIGNED (15 DOWNTO 0);
          clk : IN STD_LOGIC;
          A : OUT SIGNED (31 DOWNTO 0));
END mac;
-----------------------------
ARCHITECTURE mac_rtl OF mac IS
      SIGNAL mul_res: SIGNED (31 DOWNTO 0);
      SIGNAL add_res: SIGNED (31 DOWNTO 0) := (others =&gt; '0');
BEGIN

      mul_res &lt;= B * C;

      PROCESS (clk)
      BEGIN
          A &lt;= mul_res + add_res;
          add_res &lt;= A;
      END PROCESS;

END mac_rtl;


And here's the code of the testbench.vhd

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity testbench is
end entity testbench;

architecture BENCH of testbench is
component mac is
port (B, C : in  SIGNED (15 DOWNTO 0);
      clk : in  STD_LOGIC;
      A : out SIGNED (31 DOWNTO 0));
end component;

  signal StopClock : BOOLEAN;
  signal clk : STD_LOGIC;
  signal B, C : SIGNED (15 DOWNTO 0);
  signal A : SIGNED (31 DOWNTO 0);

begin

  ClockGenerator: process
  begin
  clk &lt;= '0';
  wait for 2 ns;
    while not StopClock loop
      clk &lt;= '0';
      wait for 1 ns;
      clk &lt;= '1';
      wait for 1 ns;
    end loop;
  wait;
  end process ClockGenerator;

  Stimulus: process 
  begin

  B &lt;= ""0000000000000010"";
  C &lt;= ""0000000000001000"";
  wait;

  end process Stimulus;

  DUT : entity work.mac
    port map (B, C, clk, A);

end architecture BENCH;


I've searched here and in Google in general for others having the same problem, but the solutions given didn't help.

I've tried and with a Reset variable from testbench, but nothing. It's like it won't be initialized at all, while everything else work normally.","The issue is that the value of add_res and mul_res have to be known at the time add_res is loaded into a register.

Note that the process is sensitive to clk but doesn't use an edge nor qualify with a value of clk. 

I modified your architecture to qualify add_res update to the rising edge of clk. There's a built in assumption you have non-metavalue values on mult_res at that time. That can be dealt with in part by defining a default initial value. 

Also the new value of A is not available until signals are update, which doesn't occur while there are any processes pending to be resumed in the current simulation cycle. This means you need to assign to add_res (which holds the accumulated value anyway) and assign to A outside the process:

ARCHITECTURE mac_rtl OF mac IS
      SIGNAL mul_res: SIGNED (31 DOWNTO 0) := (others =&gt; '0'); -- added init val
      SIGNAL add_res: SIGNED (31 DOWNTO 0) := (others =&gt; '0');
BEGIN

      mul_res &lt;= B * C;

      PROCESS (clk)
      BEGIN
          if rising_edge(clk) then  -- ADDED
              -- A &lt;= mul_res + add_res;  CHANGED
              add_res &lt;= mul_res + add_res;
              -- add_res &lt;= A;            CHANGED
          end if;                   -- ADDED
      END PROCESS;

      A &lt;= add_res; 

END mac_rtl;


And this gives:



You could note there is no need to try to collapse A and add_res. For simulation purposes delta cycles caused by signal assignments that take effect after 0 simulation time has passed do not take simulation time. 

Scheduled signal updates and delta cycles are used to emulate concurrency in signals that are inherently assigned sequentially. (And yes in the modified architecture the assignment to A will occur one delta cycle later than add_res).

(And yes I put a StopClock transaction at the tail end of the stimuli in process Stimulus in the testbench).",,,,,
System Verilog- How to ensure that specific code will be executed before another?,"I have the following code in my monitor:

virtual task run_phase(uvm_phase phase);
      fork
     begin : clock_c
        forever begin
           wait(vif.fact_log2_samp != fact_log2_samp_init);
           for(int counter = 0; counter &lt; 46; counter++) begin
          check = 1'b0;
          @(posedge vif.clk);
           end
          **check =1'b1;**
        end// forever
     end// clock_c 
     begin : main_0
        forever begin
           mon_trx = tx_lin_int_transaction::type_id::create(""mon_trx"");
           mon_trx.fact_log_2 = fact_log2_samp_init;           
           **wait (vif.xn_valid == 1'b1);**
           #1;   
           mon_trx.rand_data_xi = vif.xi;
           mon_trx.rand_data_xq = vif.xq;
           if (check == 1'b0)
         mon_trx.check = FALSE;
           else
          fact_log2_samp_init = vif.fact_log2_samp;
           $cast(t, mon_trx.clone());
           //send transaction to scoreboard via TLM write()
           ap.write(t);
           wait (vif.xn_valid == 1'b0);
        end// forever
     end// main_0
      join
   endtask: run_phase


The problem is that

wait(vif.xn_valid == 1'b1);


and the code after it execute just before

check =1'b1;


(same time).
How can I ensure that the

check =1'b1;


will execute before?","I would follow the named events method, as AndresM suggested, but if you need a quick sync in the very same block with the very same trigger condition, a simple #0 might solve the issue, thou it is unreliable due to the simulation time handling reasons. Might worth a try:

begin : clock_c
  ...
    **check =1'b1;**
  ...
end
begin : main_0
  ...
  #0;
  **wait (vif.xn_valid == 1'b1);**
  ...
end


also you can use labels for the begin-end blocks to look and read better, eg.:
begin: main_0, end: main_0 instead of end // main_o",,,,,
Can't make the required diagram,"This is the code for a 9-bit parity generator, but it is not giving the required RTL view in Quartus   

Library IEEE;
use IEEE.std_logic_1164.all;

entity PG is
port (A,B,C,D,E,F,G,H,I : IN std_logic;
      Even : OUT std_logic );
end PG;

Architecture arch of PG is
    Signal J,K,L,M,N,O,P,Odd : std_logic ;
BEGIN
    J &lt;= A xor B;
    K &lt;= C xor D;
    L &lt;= E xor F;
    M &lt;= G xor H;
    N &lt;= J xor K;
    O &lt;= L xor M;
    P &lt;= N xor O;
    Odd &lt;= P xor I;
    Even &lt;= not Odd;
END arch;


This is the required image that is required as output:



This is the output RTL image that I get:

","It looks like the correct RTL view to me. Quartus has chosen to display the logic as one 9-input XOR gate instead of many 2-input XOR gates. The boolean behaviour of both is identical. There is no ODD output, because ODD is a signal not an output.",,,,,
Vivado Input/output standard violation when mapping ports,"I am writing a vhdl module that is to be implemented on the Artix-7 Basys 3 FPGA board. My design runs synthesis and implementation successfully however when I run write bitstream, I receive this error: 


  [DRC 23-20] Rule violation (NSTD-1) Unspecified I/O Standard - 1 out of 29 logical ports use I/O standard (IOSTANDARD) value 'DEFAULT', instead of a user assigned specific value. This may cause I/O contention or incompatibility with the board power or connectivity affecting performance, signal integrity or in extreme cases cause damage to the device or the components to which it is connected. To correct this violation, specify all I/O standards. This design will fail to generate a bitstream unless all logical ports have a user specified I/O standard value defined. To allow bitstream creation with unspecified I/O standard values (not recommended), use this command: set_property SEVERITY {Warning} [get_drc_checks NSTD-1].  NOTE: When using the Vivado Runs infrastructure (e.g. launch_runs Tcl command), add this command to a .tcl file and add that file as a pre-hook for write_bitstream step for the implementation run. Problem ports: segt[7].


As you can see, it lists segt as the problem port. This for the 7 segment display, I renamed it to ""segt"" from ""seg"" which is its default name but this did not keep the error from occurring. Its strange because I ran into this error when using the default name ""sw"" for the switches and ""btnC"" for the button in my module. I renamed ""sw"" to ""sw1"" and ""btnC"" to ""btnC1"" in the master.xdc file andIi stopped getting the error for those particular ports. Any help would be much appreciated.

Here is the main module:

entity timer_test is
    port(
    clk: in std_logic;
    btnC1: in std_logic;
    an: out std_logic_vector(3 downto 0);
    segt: out std_logic_vector(7 downto 0);
    led: out std_logic_vector(15 downto 0);
    sw1: in std_logic_vector(15 downto 0)
    );
end timer_test;

architecture arch of timer_test is
    signal d3,d2, d1, d0: std_logic_vector(3 downto 0);
    signal one_sec: std_logic;
begin
    disp_unit: entity work.disp_hex_mux
      port map(
         clk=&gt;clk, reset=&gt;'0',
         hex3=&gt;d3, hex2=&gt;d2, hex1=&gt;d1, hex0=&gt;d0,
         dp_in=&gt;""1101"", an=&gt;an, sseg=&gt;segt);

    divider_unit: entity work.clock_divider
        port map(
            clk=&gt;clk,
            start=&gt;'1',
            onesec=&gt;one_sec);

    counter_unit: entity work.count_down_timer
        port map(
            min_in(7 downto 0)=&gt;sw1(15 downto 8),
            sec_in(7 downto 0)=&gt;sw1(7 downto 0),
            clk=&gt;clk,
            one_sec=&gt;one_sec,
            reset=&gt;btnC1,
            d3=&gt;d3 ,d2 =&gt;d2, d1=&gt;d1, d0=&gt;d0,
            led=&gt;led);
end arch;


Relevant portion of the Master.xdc:

## Clock signal
set_property PACKAGE_PIN W5 [get_ports clk]                         
    set_property IOSTANDARD LVCMOS33 [get_ports clk]
    create_clock -add -name sys_clk_pin -period 10.00 -waveform {0 5} [get_ports clk]

## Switches
set_property PACKAGE_PIN V17 [get_ports {sw1[0]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[0]}]
set_property PACKAGE_PIN V16 [get_ports {sw1[1]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[1]}]
set_property PACKAGE_PIN W16 [get_ports {sw1[2]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[2]}]
set_property PACKAGE_PIN W17 [get_ports {sw1[3]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[3]}]
set_property PACKAGE_PIN W15 [get_ports {sw1[4]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[4]}]
set_property PACKAGE_PIN V15 [get_ports {sw1[5]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[5]}]
set_property PACKAGE_PIN W14 [get_ports {sw1[6]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[6]}]
set_property PACKAGE_PIN W13 [get_ports {sw1[7]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[7]}]
set_property PACKAGE_PIN V2 [get_ports {sw1[8]}]                    
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[8]}]
set_property PACKAGE_PIN T3 [get_ports {sw1[9]}]                    
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[9]}]
set_property PACKAGE_PIN T2 [get_ports {sw1[10]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[10]}]
set_property PACKAGE_PIN R3 [get_ports {sw1[11]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[11]}]
set_property PACKAGE_PIN W2 [get_ports {sw1[12]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[12]}]
set_property PACKAGE_PIN U1 [get_ports {sw1[13]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[13]}]
set_property PACKAGE_PIN T1 [get_ports {sw1[14]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[14]}]
set_property PACKAGE_PIN R2 [get_ports {sw1[15]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {sw1[15]}]


## LEDs
set_property PACKAGE_PIN U16 [get_ports {led[0]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[0]}]
set_property PACKAGE_PIN E19 [get_ports {led[1]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[1]}]
set_property PACKAGE_PIN U19 [get_ports {led[2]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[2]}]
set_property PACKAGE_PIN V19 [get_ports {led[3]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[3]}]
set_property PACKAGE_PIN W18 [get_ports {led[4]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[4]}]
set_property PACKAGE_PIN U15 [get_ports {led[5]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[5]}]
set_property PACKAGE_PIN U14 [get_ports {led[6]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[6]}]
set_property PACKAGE_PIN V14 [get_ports {led[7]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[7]}]
set_property PACKAGE_PIN V13 [get_ports {led[8]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[8]}]
set_property PACKAGE_PIN V3 [get_ports {led[9]}]                    
    set_property IOSTANDARD LVCMOS33 [get_ports {led[9]}]
set_property PACKAGE_PIN W3 [get_ports {led[10]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[10]}]
set_property PACKAGE_PIN U3 [get_ports {led[11]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[11]}]
set_property PACKAGE_PIN P3 [get_ports {led[12]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[12]}]
set_property PACKAGE_PIN N3 [get_ports {led[13]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[13]}]
set_property PACKAGE_PIN P1 [get_ports {led[14]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[14]}]
set_property PACKAGE_PIN L1 [get_ports {led[15]}]                   
    set_property IOSTANDARD LVCMOS33 [get_ports {led[15]}]


#7 segment display
set_property PACKAGE_PIN W7 [get_ports {segt[6]}]
set_property IOSTANDARD LVCMOS33 [get_ports {segt[6]}]
set_property PACKAGE_PIN W6 [get_ports {segt[5]}]
set_property IOSTANDARD LVCMOS33 [get_ports {segt[5]}]
set_property PACKAGE_PIN U8 [get_ports {segt[4]}]
set_property IOSTANDARD LVCMOS33 [get_ports {segt[4]}]
set_property PACKAGE_PIN V8 [get_ports {segt[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {segt[3]}]
set_property PACKAGE_PIN U5 [get_ports {segt[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {segt[2]}]
set_property PACKAGE_PIN V5 [get_ports {segt[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {segt[1]}]
set_property PACKAGE_PIN U7 [get_ports {segt[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {segt[0]}]

set_property PACKAGE_PIN V7 [get_ports dp]                          
    set_property IOSTANDARD LVCMOS33 [get_ports dp]

set_property PACKAGE_PIN U2 [get_ports {an[0]}]                 
    set_property IOSTANDARD LVCMOS33 [get_ports {an[0]}]
set_property PACKAGE_PIN U4 [get_ports {an[1]}]                 
    set_property IOSTANDARD LVCMOS33 [get_ports {an[1]}]
set_property PACKAGE_PIN V4 [get_ports {an[2]}]                 
    set_property IOSTANDARD LVCMOS33 [get_ports {an[2]}]
set_property PACKAGE_PIN W4 [get_ports {an[3]}]                 
    set_property IOSTANDARD LVCMOS33 [get_ports {an[3]}]


##Buttons
set_property PACKAGE_PIN U18 [get_ports btnC1]                      
    set_property IOSTANDARD LVCMOS33 [get_ports btnC1]


How can I fix these rule violations?","The error message specifically says that only 1 out of 29 ports is affected, so that tells us that we're just looking for one pin with an issue. The end of the error message specifies segt[7]. Your declaration for segt is the following:

segt: out std_logic_vector(7 downto 0);


Remember that in VHDL, downto is inclusive. That means segt has 8 elements.

Now look at your constraints file: there is no IO standard specified for segt[7]. You've only included segt[6] through segt[0], and none of those are included in your error. Just add segt[7]'s IO standard specification:

set_property PACKAGE_PIN &lt;pin&gt; [get_ports {segt[7]}]
    set_property IOSTANDARD LVCMOS33 [get_ports {segt[7]}]
",,,,,
Generating 2 clock pulses in VHDL,"Although I have completed a university course in digital logic, I am new to VHDL design and I am hoping if someone can help me create 2 clock signals which depend on the state of one another. 

I am using a 50 MHz clock on a DE2-115 FPGA board that is used to create a 5MHz clock (named dclk_5). However, the simulation is showing the two signal but only up to 200 ns of run time and won't run any longer. Why doesnt the simulation run longer than 200 ns? 

datasheet of the 2 clocks:



Alternative VHDL Design for testing dclk_5 and clk_50 which synthesizes but simulation is not correct:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity DCLK_top is
port(
    clk_50  : in std_logic;
    sw         : in std_logic;
    dclk_5  : out std_logic
);

end DCLK_top;

architecture behaviour of DCLK_top is
    signal clk_counter          : integer range 0 to 10 := 0;
    signal dclk_counter         : integer range 0 to 8  := 0;
    signal dclk_pause_counter   : integer range 0 to 7  := 0;

    signal dclk_pause               : std_logic := '0';
    signal clk_pause_counter    : integer range 0 to 7 := 0;

begin
    dclk_proc : process(clk_50)
    begin

        if(clk_50'event and clk_50='1' ) then
            clk_counter &lt;= clk_counter+1;

            if(clk_counter=10) then
                clk_counter &lt;= 0;
            end if;

            if(clk_counter&lt;5) then
                dclk_5 &lt;= '0';
            else
                dclk_5 &lt;= '1';
            end if;
        end if;

    end process dclk_proc;
end architecture behaviour; 


Picture of simulation:

","Well, your code in not that bad, but there is one problem.

clk_counter &lt;= clk_counter+1;
if(clk_counter=10) then
    clk_counter &lt;= 0;
end if;


So the &lt;= assignment is not assigned until the end of the process. So clk_counter is 9 for the whole process. It will be set to 10, but not until the end of the process, so the if-statement does not trigger.
So the next evaluation of the process, clk_counter is 10. Now the if-statement /will/ trigger. However, before that you want to assign 10+1 = 11 to clk_counter.... But that is not allowed, because the range of clk_counter is 0 to 10. You could set the range to 11 and this will not happen. but then the code does not do what you want it to do.
So, cleaner code is better imho. E.g.:

if(clk_counter&lt;10) then
    clk_counter &lt;= clk_counter+1;
else
    clk_counter &lt;= 0;
end if;


You could also separate the assignment of dclk from the process. E.g.:

dclk &lt;= '0' when (clk_counter&lt;5) else '1';


But this is not glitch friendly. You should preferably clock your assignment, like you are already doing.",,,,,
VHDL signed data in std_logic_vector to unsigned data,"I have an ADC (LTC1407A-1) on an FPGA board that is populating a 14-bit register with 2's compliment signed data. I want to convert this data to be unsigned:


Source data range: -8192 to 8191
Target data range: 0 to 16383


However, whatever I try, I can't seem to get the desired result. My current section of working code for the VHDL register module is as follows:

library IEEE;
use ieee.std_logic_arith.all;
use ieee.std_logic_1164.all;

entity reg10 is
    Port ( clk : in  STD_LOGIC;                         --50MHz clock
           reset : in  STD_LOGIC;                       --asynchronous reset
           i_load : in  STD_LOGIC;                      --load signal
           i_data : in  STD_LOGIC_VECTOR (13 downto 0); --data signal
           o_data : out  STD_LOGIC_VECTOR (15 downto 0) --output data
    );
end reg10;

architecture Behavioral of reg10 is
    signal s_data : STD_LOGIC_VECTOR(9 downto 0);
    signal f_data : STD_LOGIC_VECTOR(13 downto 0);
    signal t_sign : signed (13 downto 0);
begin
    process(clk, reset)
    begin
        if reset = '1' then
            s_data &lt;= ""0000000000"";
        elsif clk'event and clk = '1' then
            t_sign &lt;= SIGNED(i_data);
            f_data &lt;= STD_LOGIC_VECTOR(t_sign);
            s_data &lt;= ""00"" &amp; f_data(13 downto 6);
        end if;
    end process;
    o_data &lt;= ""000010"" &amp; s_data(9 downto 0);
end Behavioral;


I have done plenty of searching around and find lots of examples where the conversion can be done, but, I don't understand the correct approach to take. I have tried assigning i_data as signed, casting between variables internally, and many other recommended solutions, but all to no avail.

signal t_sign : signed (13 downto 0);
f_data &lt;= conv_std_logic_vector(i_data, 14);


The code buffers a changing input vector, and formats the data into an output vector for a VGA controller to display.

Help appreciated. Thanks.","The first error is:

use ieee.std_logic_arith.all;


Don't do that. Do this:

use ieee.numeric_std.all;


The other library already treats std_logic as signed or unsigned. You shouldn't want that.
Then cast from signed to std_logic_vector to unsigned. e.g.:

[signal] foo &lt;= unsigned(std_logic_vector(signed(bar)));


however, in you case the input is already std_logic, so just cast to unsigned. It should work, unless your input representation is non-standard. (I.e. has an offset). IF it has an offset, do something like:

[signal] foo &lt;= unsigned(std_logic_vector(signed(bar)+offset));


N.B. &lt;= [signal] assignments are assigned at the next delta (https://en.wikipedia.org/wiki/Delta_delay). So in a process that is evaluated within one delta (i.e. without wait statements), they are not applied until after the process ends. So in you example, even though f_data is assigned by the data in t_sign the line after t_sign is assigned, t_sign will not change until the end of the process, so its change will not directly effect f_data. Instead the process will trigger on the next clk and clk'event and clk = '1' will assign f_data the new processed value t_sign. In effect each &lt;= will insert a register in your example.

edit:
I myself would probably use a cast to integer.

foo &lt;= to_unsigned(to_integer(bar)+offset, foo'length);
",,,,,
design ROM to save filter coefficients in verilog,"I want to store filter coefficients(fixed values) in ROM using verilog.Below is the code for ROM using case.



module rom_using_case (
address , // Address input
data    , // Data output
read_en , // Read Enable 
ce        // Chip Enable
);
input [3:0] address;
output [7:0] data;
input read_en;
input ce;

reg [7:0] data ;

always @ (ce or read_en or address)
begin
  case (address)
    0 : data = 10;
    1 : data = 55;
    2 : data = 244;
    3 : data = 0;
    4 : data = 1;
    5 : data = 8'hff;
    6 : data = 8'h11;
    7 : data = 8'h1;
    8 : data = 8'h10;
    9 : data = 8'h0;
    10 : data = 8'h10;
    11 : data = 8'h15;
    12 : data = 8'h60;
    13 : data = 8'h90;
    14 : data = 8'h70;
    15 : data = 8'h90;
  endcase
end

endmodule




what does the case block do in the above code?
can i store filter coefficients in data variable in the case block?
can i access those filter coefficients?","As you state the coefficients will be stored in a RAM LUT or in a ROM block.
The code is (somewhat) self-descriptive, the always  is sensitive to the address then each time the address changes its value the stored value will be assigned to data, case is the selector for which location of the memory block will be assinged to data.

Your implementation is enough for small filters, but if you need a lot of coefficients it will get hard to maintain.

For this purpose you can use the $readmemh or $readmemb. Those are verilog intrisic tasks.

From: https://www.csee.umbc.edu/~tinoosh/cmpe415/slides/Rom-LUT-verilog.pdf

The $readmemh system task expects the content of the named file to be
a sequence of hexadecimal numbers, separated by spaces or line breaks.
Similarly, $readmemb expects the file to contain a sequence of binary.

Here is a snippet which shows how to use it:

reg [19:0] data_ROM [0:511];
...
initial $readmemh(""rom.data"", data_ROM); 
always @(address)
  if (ce &amp; read_en)
    d_out = data_ROM[address];


The ""rom.data"" contains the coefficients in text. For example, in your case:

8'hA
8'h37
8'hF4
8'h0
8'h1
8'hff
8'h11
8'h1
8'h10
8'h0
8'h10
8'h15
8'h60
8'h90
8'h70
8'h90
",,,,,
Assign a single element of a nettype struct,"The usual assignment style to a Systemverilog net defined by a typedef struct, like

typedef struct {
real V;
real I;
real R;
}  SVAstruct;
// resolution function ommitted
nettype SVAstruct SVAnet with res_SVA;


is 

inout SVAnet P;
assign P = '{Vout,0,0};


So the assignments are done simultaneously for all elements of the net structure. Assignments like 

P.R = 100;


give an error. Is there any method to do individual assignments?","You cannot do that. Once you create a nettype with a particular data type, each driver needs all fields of type in order to execute its resolution function. 

Imagine if you wanted a signal to represent the force on an physical object. A force is a vector quantity that has both magnitude and direction. If each driver on that signal represents a force vector, there is no way to drive a direction without knowing what the magnitude is.

You can create a variable with the same type as a net and then you can make individual assignments to fields of that variable.

inout SVAnet P;
...
SVAstruct S
assign P = S;
...
S.R = 100;
",,,,,
looking for Altera HPS to FPGA custom component integrations guideline using Qsys,"I am looking for HPS to FPGA custom component integrations guideline using Qsys. I have De0 nano SoC board. I am new to SoC FPGA programming. I still could not found a material or tutorial for HPS to custom VHDL or Verilog component integration. I need to get to know what are the connections that I should make and how to/ where to declare them in C code on ARM processor and the entity of the FPGA custom designed component. Can any body post some links.

I have read following tutorials from Altera.
Avalon Interface Specifications pdf,
ARM_A9_intro_intelfpga pdf,
Intel_FPGA_Monitor_Program_ARM pdf,
making qsys component pdf,
Using_GIC - ARM HPS pdf,
External_Bus_to_Avalon_Bridge -nios II pdf,
Avalon_to_External_Bus_Bridge nios II pdf,
DE0-Nano-SoC_Computer_ARM pdf.","On the FPGA side Quartus is used to instantiate the HPS as an IP Core in QSys. HPS-to-FPGA bridges can be enabled and IP connected to it. Either do it in QSys or export the bus via a bridge into a wrapper VHDL or Verilog design.

There is a QSys section in Volume 1 of the Quartus Handbook:
https://www.altera.com/products/design-software/fpga-design/quartus-prime/support.html

On the HPS side, you have to generate a new Preloader from the Quartus output. You will have to write a Linux kernel driver for you device and probably create a DeviceTree entry. You can do simple tests with the mw/md commands in UBoot or Linux userspace e.g. by mmapping /dev/mem.

RocketBoards.org is a great resource. Your board is compatible with Atlas-SoC Development Platform: https://rocketboards.org/foswiki/view/Documentation/AtlasSoCDevelopmentPlatform#Getting_Started",,,,,
Pseudo Random Number Generator using LFSR in VHDL,"I'm having a bit of trouble creating a prng using the lfsr method. Here is my code:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity pseudorng is
Port ( clock : in STD_LOGIC;
       reset : in STD_LOGIC;
       Q : out STD_LOGIC_VECTOR (7 downto 0);
       check: out STD_LOGIC);

       constant seed: STD_LOGIC_VECTOR(7 downto 0) := ""00000001"";
end pseudorng;

architecture Behavioral of pseudorng is

signal temp: STD_LOGIC;
signal Qt: STD_LOGIC_VECTOR(7 downto 0);

begin

PROCESS(clock)
BEGIN

IF rising_edge(clock) THEN
IF (reset='1') THEN Qt &lt;= ""00000000"";
ELSE Qt &lt;= seed; 
END IF;
temp &lt;= Qt(4) XOR Qt(3) XOR Qt(2) XOR Qt(0);
--Qt &lt;= temp &amp; Qt(7 downto 1);

END IF;
END PROCESS;

check &lt;= temp;
Q &lt;= Qt;

end Behavioral;


Here is the simulation I have ran:
prng sim

Firstly, the check output is just there so I can monitor the output of the temp signal. Secondly, the line that is commented out is what is causing the problem.

As can be seen from the simulation, on the first rising edge of the clock, the Qt signal reads the seed. However, and this is my question, for some reason the temp signal only XORs the bits of the Qt signal on the second rising edge of the clock. It remains undefined on the first clock pulse. Why is that? If it operated on the first rising edge right after the Qt signal reads the seed, then I could uncomment the line that shifts the bits and it would solve my problem. Any help would be much appreciated!

Here is the test bench if anyone cares:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity tb_pseudorng is
end tb_pseudorng;

architecture bench of tb_pseudorng is

COMPONENT pseudorng
      Port ( clock : in STD_LOGIC;
      reset : in STD_LOGIC;
      Q : out STD_LOGIC_VECTOR (7 downto 0);
      check: out STD_LOGIC);
END COMPONENT;

signal clock1: STD_LOGIC;
signal reset1: STD_LOGIC;
signal Q1: STD_LOGIC_VECTOR(7 downto 0);
signal check1: STD_LOGIC;

begin

mapping: pseudorng PORT MAP(
clock =&gt; clock1,
reset =&gt; reset1,
Q =&gt; Q1,
check =&gt; check1);

clock: PROCESS
BEGIN
clock1&lt;='0'; wait for 50ns;
clock1&lt;='1'; wait for 50ns;
END PROCESS;

reset: PROCESS
BEGIN
reset1&lt;='0'; wait for 900ns;
END PROCESS; 

end bench;
","I made some slight modifications to what you had (you are pretty much there though); I don't think the LFSR would step properly otherwise. I added an enable signal to the LFSR so you can effectively control when you want it to step. Resulting sim is here.

Just as a sidenote, you could also include a load and seed inputs if you wanted to seed the LFSR with a different value (instead of making it const).

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity pseudorng is
Port ( clock : in STD_LOGIC;
       reset : in STD_LOGIC;
       en : in STD_LOGIC;
       Q : out STD_LOGIC_VECTOR (7 downto 0);
       check: out STD_LOGIC);

--       constant seed: STD_LOGIC_VECTOR(7 downto 0) := ""00000001"";
end pseudorng;

architecture Behavioral of pseudorng is

--signal temp: STD_LOGIC;
signal Qt: STD_LOGIC_VECTOR(7 downto 0) := x""01"";

begin

PROCESS(clock)
variable tmp : STD_LOGIC := '0';
BEGIN

IF rising_edge(clock) THEN
   IF (reset='1') THEN
   -- credit to QuantumRipple for pointing out that this should not
   -- be reset to all 0's, as you will enter an invalid state
      Qt &lt;= x""01""; 
   --ELSE Qt &lt;= seed;
   ELSIF en = '1' THEN
      tmp := Qt(4) XOR Qt(3) XOR Qt(2) XOR Qt(0);
      Qt &lt;= tmp &amp; Qt(7 downto 1);
   END IF;

END IF;
END PROCESS;
-- check &lt;= temp;
check &lt;= Qt(7);
Q &lt;= Qt;

end Behavioral;


And tb:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity tb_pseudorng is
end tb_pseudorng;

architecture bench of tb_pseudorng is

COMPONENT pseudorng
      Port ( clock : in STD_LOGIC;
      reset : in STD_LOGIC;
      en : in STD_LOGIC;
      Q : out STD_LOGIC_VECTOR (7 downto 0);
      check: out STD_LOGIC);
END COMPONENT;

signal clock1: STD_LOGIC;
signal reset1: STD_LOGIC;
signal Q1: STD_LOGIC_VECTOR(7 downto 0);
signal check1: STD_LOGIC;
signal en : STD_LOGIC;

begin

mapping: pseudorng PORT MAP(
clock =&gt; clock1,
reset =&gt; reset1,
en =&gt; en,
Q =&gt; Q1,
check =&gt; check1);

clock: PROCESS
BEGIN
   clock1 &lt;= '0'; wait for 50 ns;
   clock1 &lt;= '1'; wait for 50 ns;
END PROCESS;

reset: PROCESS
BEGIN
   reset1 &lt;= '0';
   en &lt;= '1';
   wait for 900 ns;
END PROCESS;

end bench;
",,,,,
case statement in property not working for QuestaSim 10.4B,"I am trying to write a property with a case statement, straight out of the SystemVerilog 2012 LRM.

property p_rate_select (logic [1:0] rate);
    case (rate)
            2'd0 : $rose(i_ffs_rdcount == 1) |=&gt; $fell(o_telem_fifo_ready_n);
            2'd1 : $rose(i_ffs_rdcount == 2) |=&gt; $fell(o_telem_fifo_ready_n);
            2'd2 : $rose(i_ffs_rdcount == 3) |=&gt; $fell(o_telem_fifo_ready_n);
            2'd3 : $rose(i_ffs_rdcount == 4) |=&gt; $fell(o_telem_fifo_ready_n);
         default : 0;
    endcase
endproperty


Using QuestaSim 10.4B, I get the following error:


  ** Error: (vlog-13069) checker.sv(196):
  near ""case"": syntax error, unexpected case, expecting disable.


Is case statements not supported with this version of Questasim?",You need Questa 10.4e or newer.,,,,,
How to choose the initramfs source files with buildroot and Nios2 FPGA,"I built latest version of Linux from Altera for my Altera DE2-115 FPGA. It won't boot properly because of something with the file system. Maybe you know what I should do? I suppose it is some option in make menuconfig but I don't know what do to. 

Linux version 4.9.0-00104-g84d4f8a-dirty (developer@1604) (gcc version 6.2.0 (Sourcery CodeBench Lite 2016.11-32) ) #28 Wed Apr 5 04:23:07 CEST 2017
bootconsole [early0] enabled
early_console initialized at 0xe8001440
On node 0 totalpages: 32768
free_area_init_node: node 0, pgdat c022166c, node_mem_map c0254b80
  Normal zone: 256 pages used for memmap
  Normal zone: 0 pages reserved
  Normal zone: 32768 pages, LIFO batch:7
pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768
pcpu-alloc: [0] 0 
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 32512
Kernel command line: debug console=ttyAL0,115200
PID hash table entries: 512 (order: -1, 2048 bytes)
Dentry cache hash table entries: 16384 (order: 4, 65536 bytes)
Inode-cache hash table entries: 8192 (order: 3, 32768 bytes)
Sorting __ex_table...
Memory: 127528K/131072K available (1750K kernel code, 66K rwdata, 284K rodata, 76K init, 191K bss, 3544K reserved, 0K cma-reserved)
SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
NR_IRQS:64 nr_irqs:64 0
clocksource: nios2-clksrc: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 38225208935 ns
Console: colour dummy device 80x25
Calibrating delay loop (skipped), value calculated using timer frequency.. 100.00 BogoMIPS (lpj=50000)
pid_max: default: 32768 minimum: 301
Mount-cache hash table entries: 1024 (order: 0, 4096 bytes)
Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes)
cpu cpu0: Error -2 creating of_node link
clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1911260446275000 ns
random: fast init done
clocksource: Switched to clocksource nios2-clksrc
futex hash table entries: 256 (order: -1, 3072 bytes)
workingset: timestamp_bits=30 max_order=15 bucket_order=0
Block layer SCSI generic (bsg) driver version 0.4 loaded (major 254)
io scheduler noop registered
io scheduler deadline registered
io scheduler cfq registered (default)
8001440.serial: ttyJ0 at MMIO 0x8001440 (irq = 2, base_baud = 0) is a Altera JTAG UART
mousedev: PS/2 mouse device common for all mice
Warning: unable to open an initial console.
List of all partitions:
No filesystem could mount root, tried: 
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
random: crng init done




I found the option in menuconfig and now I get a different error:

Linux version 4.9.0-00104-g84d4f8a-dirty (developer@1604) (gcc version 6.2.0 (Sourcery CodeBench Lite 2016.11-32) ) #37 Wed Apr 5 11:23:36 CEST 2017
bootconsole [early0] enabled
early_console initialized at 0xe8001440
On node 0 totalpages: 32768
free_area_init_node: node 0, pgdat c03cf6b0, node_mem_map c0402b80
  Normal zone: 256 pages used for memmap
  Normal zone: 0 pages reserved
  Normal zone: 32768 pages, LIFO batch:7
pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768
pcpu-alloc: [0] 0 
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 32512
Kernel command line: debug console=ttyAL0,115200
PID hash table entries: 512 (order: -1, 2048 bytes)
Dentry cache hash table entries: 16384 (order: 4, 65536 bytes)
Inode-cache hash table entries: 8192 (order: 3, 32768 bytes)
Sorting __ex_table...
Memory: 125808K/131072K available (1775K kernel code, 67K rwdata, 288K rodata, 1768K init, 191K bss, 5264K reserved, 0K cma-reserved)
SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
NR_IRQS:64 nr_irqs:64 0
clocksource: nios2-clksrc: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 38225208935 ns
Console: colour dummy device 80x25
Calibrating delay loop (skipped), value calculated using timer frequency.. 100.00 BogoMIPS (lpj=50000)
pid_max: default: 32768 minimum: 301
Mount-cache hash table entries: 1024 (order: 0, 4096 bytes)
Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes)
cpu cpu0: Error -2 creating of_node link
clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1911260446275000 ns
random: fast init done
clocksource: Switched to clocksource nios2-clksrc
futex hash table entries: 256 (order: -1, 3072 bytes)
workingset: timestamp_bits=30 max_order=15 bucket_order=0
Block layer SCSI generic (bsg) driver version 0.4 loaded (major 254)
io scheduler noop registered
io scheduler deadline registered
io scheduler cfq registered (default)
8001440.serial: ttyJ0 at MMIO 0x8001440 (irq = 2, base_baud = 0) is a Altera JTAG UART
mousedev: PS/2 mouse device common for all mice
Warning: unable to open an initial console.
Freeing unused kernel memory: 1768K (c01bd000 - c0377000)
This architecture does not have kernel memory protection.
Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000100

---[ end Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000100

random: crng init done




Now I select the directory of my buildroot files,

~$ ls -ahl /home/developer/nios2/buildroot/output/images/
total 9,6M
drwxr-xr-x 2 developer developer 4,0K apr  5 07:56 .
drwxrwxr-x 6 developer developer 4,0K apr  5 07:33 ..
-rw-r--r-- 1 developer developer 3,7M apr  5 07:56 rootfs.cpio
-rw-r--r-- 1 developer developer 2,1M apr  5 07:56 rootfs.jffs2
-rw-r--r-- 1 developer developer 3,8M apr  5 07:56 rootfs.tar


then I get this output

Linux version 4.9.0-00104-g84d4f8a-dirty (developer@1604) (gcc version 6.2.0 (Sourcery CodeBench Lite 2016.11-32) ) #40 Wed Apr 5 11:35:15 CEST 2017
bootconsole [early0] enabled
early_console initialized at 0xe8001440
On node 0 totalpages: 32768
free_area_init_node: node 0, pgdat c07736b0, node_mem_map c07a6b80
  Normal zone: 256 pages used for memmap
  Normal zone: 0 pages reserved
  Normal zone: 32768 pages, LIFO batch:7
ï¿½pcpu-alloc: s0 r0 d32768 u32768 alloc=1*32768
pcpu-alloc: [0] 0 
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 32512
Kernel command line: debug console=ttyAL0,115200
PID hash table entries: 512 (order: -1, 2048 bytes)
Dentry cache hash table entries: 16384 (order: 4, 65536 bytes)
Inode-cache hash table entries: 8192 (order: 3, 32768 bytes)
Sorting __ex_table...
ï¿½Memory: 122080K/131072K available (1775K kernel code, 67K rwdata, 288K rodata, 5496K init, 191K bss, 8992K reserved, 0K cma-reserved)
SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
NR_IRQS:64 nr_irqs:64 0
clocksource: nios2-clksrc: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 38225208935 ns
Console: colour dummy device 80x25
Calibrating delay loop (skipped), value calculated using timer frequency.. 100.00 BogoMIPS (lpj=50000)
pid_max: default: 32768 minimum: 301
ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Mount-cache hash table entries: 1024 (order: 0, 4096 bytes)
Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes)
cpu cpu0: Error -2 creating of_node link
clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1911260446275000 ns
random: fast init done
clocksource: Switched to clocksource nios2-clksrc
futex hash table entries: 256 (order: -1, 3072 bytes)
workingset: timestamp_bits=30 max_order=15 bucket_order=0
random: crng init done
Block layer SCSI generic (bsg) driver version 0.4 loaded (major 254)
io scheduler noop registered
io scheduler deadline registered
io scheduler cfq registered (default)
8001440.serial: ttyJ0 at MMIO 0x8001440 (irq = 2, base_baud = 0) is a Altera JTAG UART
mousedev: PS/2 mouse device common for all mice
Warning: unable to open an initial console.
Failed to create /dev/root: -2
List of all partitions:
No filesystem could mount root, tried: 
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
","At first, please note that the instruction of rocketboard wiki page isn't complete. To recompile the Nios2's kernel is not so easy task, because it has many bugs, insufficient instructions and confusions of maintainers themselves. Secondly,  Linux kernel itself is a quite huge software. You need miscellaneous knowledge, including ancient (for example virtual terminal tty0) technique.  So, it is a fantasy to think that the command 'make menuconfig' and  'make' will do everything well. Please think seriously the above answer 'Where is your initrd?'.",,,,,
"What does ""+ 3"" in while (*(MPcore_private_timer_ptr + 3) == 0) mean?","I am currently reading through DE0-Nano-SoC Computer System
with ARM Cortex-A9 user guide i found a c code in it and i don't understand what does  ""+ 3""  in ""*(MPcore_private_timer_ptr + 3)"" mean?  

while (1)
{
*HPS_GPIO1_ptr = HPS_LEDG; // turn on/off LEDG
while (*(MPcore_private_timer_ptr + 3) == 0)
; // wait for timer to expire
*(MPcore_private_timer_ptr + 3) = 1; // reset timer flag bit
HPS_LEDG ^= bit_24_pattern; // toggle bit that controls LEDG
}
","
  Blockquote
  
  *(MPcore_private_timer_ptr + 3) = 1; // reset timer flag bit


Is synonimum of :


  *(&amp;MPcore_private_timer_ptr[3]) = 1; // reset timer flag bit
",,,,,
Non-specific `include file name - System Verilog compiler directives,"I want to use the `include directive to call upon a non-specific file name. For example,
there is this file name ""name_defines.svh"" in some other directory. Since the ""name"" of ""name_defines.svh"" changes(it can be eg, a_defines.svh, b_defines.svh.. etc), is it possible if I just use

`include ""_defines.svh""


or

`include ""*_defines.svh""


so that the system verilog compiler finds the file name and include it in my current .sv file, just as if I used

`include ""name_defines.svh""


p.s. - assume that no other files in the working directory has the trailing  ""_defines.svh"" wordings and is unique to only ""name_defines.svh""","SystemVerilog does not have a mechanism to do this. Wildcard file matching is a feature of the shell you are running your simulation from.

If there is only one file you would like to include in your current working directory, it should have the same name. Or, your invoking script can put a link from the specific name to the generic name. Another option is to define the file name with a macro on your command line

+define+FILE=""name_defines.svh""

`include `FILE


Note that you may need to escape the quotes on your command line depending on the shell you are using. ",,,,,
"Error: /..integrator.vhd(47): near ""process"": (vcom-1576) expecting IF VHDL","I'm trying to add two registers storing signed bits one of 3-bit[FRQ(2 downto 0)] and other is 7-bit[PHS(6 downto 0)]...and has to store the addition of these two registers in 7-bit register [PHS(6 downto 0)]. Thanks in advance for your helpful gesture.

the error I get is..>>>
Error: /..integrator.vhd(47): near ""process"": (vcom-1576) expecting IF VHDL

here is my code:

    library IEEE;
    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    --use ieee.std_logic_unsigned.all;


    entity integ is
        port (
            SMP_CLK : in std_logic;
            RESET : in std_logic;
            PHS : out signed (6 downto 0);
            FRQ : in signed (2 downto 0)
              );
    end integ;

    architecture behaviour of integ is

    signal sig_FRQ   : signed(2 downto 0) := (others =&gt; '0');
    signal ext_FRQ   : signed(6 downto 0) := (others =&gt; '0');
    signal sig_PHS   : signed(6 downto 0) := (others =&gt; '0');
    signal temp_PHS   : signed(6 downto 0) := (others =&gt; '0');

    begin 

    sig_FRQ &lt;=FRQ;
    temp_PHS &lt;= sig_PHS;
    --PHS &lt;=signal_PHS;
    process (SMP_CLK, RESET)
    begin

    if sig_FRQ(2)='1' then
        ext_FRQ(6 downto 3) &lt;= b""0000"";
    else 
        ext_FRQ(6 downto 3) &lt;= b""1111"";
    --end if;

    if RESET='1' then
       sig_PHS &lt;= b""0000000"";


    elsif (rising_edge(SMP_CLK) ) then
    --  temp_PHS &lt;= sig_PHS;
           sig_PHS &lt;= signed(ext_FRQ) + signed(temp_PHS);



end process;


sig_PHS =&gt; PHS;

end behaviour; 
","You have some mess with if-elsif-else statement. After the line with ext_FRQ(6 downto 3) &lt;= b""1111""; you have commented --end if; if you want to continue if-elsif-else statement next condition should start with elsif word rather than simple if as in your code. 

And you need to close the if-elsif-else construction in the end. 

As well as you need to add to sensitivity list sig_FRQ signal because you use it in comparison, if you don't add it to sensitivity list the following construction

if sig_FRQ(2)='1' then
    ext_FRQ(6 downto 3) &lt;= b""0000"";
else 
    ext_FRQ(6 downto 3) &lt;= b""1111"";
end if;


will work wrong.

In your case I suppose right version of the if-elsif-else constructions looks like:

process (sig_FRQ)
begin
    if sig_FRQ(2)='1' then
        ext_FRQ(6 downto 3) &lt;= b""0000"";
    else 
        ext_FRQ(6 downto 3) &lt;= b""1111"";
    end if;
end process;

process (SMP_CLK, RESET)
    if RESET='1' then
        sig_PHS &lt;= b""0000000"";
    elsif (rising_edge(SMP_CLK)) then
        --temp_PHS &lt;= sig_PHS;
        sig_PHS &lt;= ext_FRQ + temp_PHS;
    end if;
end process;


In the end, if you would like to assign result to output, you need to use another operator 

PHS &lt;= sig_PHS;.",,,,,
Creating a custom pcore for Xilinx ISE 14.7?,"A bit of a general question, but what is the most popular/common/easiest way of creating a custom pcore?

I have seen some examples and they were mostly done on Matlab and since I do not have Matlab anywhere, I am a bit lost here. There has got to be a proper way of doing without it!

Thank you in advance!!!","You can create it with VHDL or Verilog languages, but after that you need to make few files like .mdp and .pao, create directory move all the files there and then put the directory to a library.

Detailed information you can find in Xilinx Manual",,,,,
Changing a Qsys design to run latest version of uClinux,"I'm using a design in Qsys to run uClinux v2.6. 



I would like to run a newer Linx but I wa told that I must change the Qsys design and add another timer because newer Linux uses two timers. Is that correct and where can I find information about that?

The board I use is Altera DE2-115 and it works to run old linux 2.6 with the Qsys design. 

","You can find the documentation here: https://rocketboards.org/foswiki/view/Documentation/NiosIILinuxUserManual

The information on the website confirms the two timers need, I have not tested with only one. I am using kernel 4.1 ltsi on DE2-115 and it works fine. ",,,,,
Superfluous buffers/inverters in synthesised netlist,"This is another follow-up question to Combinatorial synthesis: Better technology mapping results.

This is my Yosys TCL control script:

yosys -import
set libfile osu018_stdcells.lib
read_liberty -lib  $libfile
read_verilog test.v
hierarchy; 
procs; opt
memory; opt
fsm -norecode; opt -full
techmap; opt -full
dfflibmap -liberty $libfile
abc -liberty $libfile \
    -script {+strash;ifraig;scorr;dc2;dretime;strash;&amp;get,-n;&amp;dch,-f;&amp;nf,{D};&amp;put}
clean
write_verilog test_synth.v


The osu018_stdcells.lib file used is part of the Qflow version 1.1 package.

This is the test.v file:

module test (
    input rx_clk,
    input rxena,
    input rstn,
    input [2:0] d,
    output reg [2:0] q
  );
  wire rx_rstn = rstn &amp; rxena;
  always @ (negedge rx_clk or negedge rx_rstn) begin
    if (!rx_rstn) begin
      q &lt;= 0;
    end else begin
      q &lt;= d;
    end
  end
endmodule


Yosys (version 0.5+ (git sha1 f13e387, gcc 5.3.1-8ubuntu2 -O2 -fstack-protector-strong -fPIC -Os)) produces the following test_synth.v output netlist:

/* Generated by Yosys 0.5+ (git sha1 f13e387, gcc 5.3.1-8ubuntu2 -O2 -fstack-protector-strong -fPIC -Os) */

(* src = ""test.v:1"" *)
module test(rx_clk, rxena, rstn, d, q);
  wire _0_;
  wire _1_;
  wire _2_;
  (* src = ""test.v:5"" *)
  input [2:0] d;
  (* src = ""test.v:6"" *)
  output [2:0] q;
  (* src = ""test.v:4"" *)
  input rstn;
  (* src = ""test.v:2"" *)
  input rx_clk;
  (* src = ""test.v:8"" *)
  wire rx_rstn;
  (* src = ""test.v:3"" *)
  input rxena;
  INVX1 _3_ (
    .A(rx_clk),
    .Y(_0_)
  );
  AND2X1 _4_ (
    .A(rstn),
    .B(rxena),
    .Y(rx_rstn)
  );
  INVX1 _5_ (
    .A(rx_clk),
    .Y(_1_)
  );
  INVX1 _6_ (
    .A(rx_clk),
    .Y(_2_)
  );
  DFFSR _7_ (
    .CLK(_1_),
    .D(d[0]),
    .Q(q[0]),
    .R(rx_rstn),
    .S(1'b1)
  );
  DFFSR _8_ (
    .CLK(_2_),
    .D(d[1]),
    .Q(q[1]),
    .R(rx_rstn),
    .S(1'b1)
  );
  DFFSR _9_ (
    .CLK(_0_),
    .D(d[2]),
    .Q(q[2]),
    .R(rx_rstn),
    .S(1'b1)
  );
endmodule


Obviously, there are 3 instances of the INVX1 cell, one for each of the three flip-flops in this design.  I would have expected only one of these inverters and its driven net shared between the flip-flop CLK inputs.

In another design (with about 30 registers that are triggered off the falling clock edge), I have seen just one inverter but its output goes through one buffer per flip-flop, which is also not ideal.

Is there a way to get Yosys to combine/share these resources among the registers?","
  Is there a way to get Yosys to combine/share these resources among the registers?


Simply run opt_merge after running dfflibmap.",,,,,
XML TO TCL Parsing for Xilinx Vivado to generate Architecture,"I am using Xilinx Vivado 2014.4 . i am doing a project to generate Block diagram for custom Architecture on Vivado . For that i want to generate a TCL file using XML document . I have exhausted all the Resource available on the internet but could not find any answer to parse an XML file to TCL Script .

An example XML file to generate Microblaze architecture with UARTLITE peripheral

&lt;?xml version=""1.0""?&gt;
&lt;System&gt;
 &lt;MicroBlaze id=""0""&gt;
    &lt;Parameter&gt;
        &lt;NAME&gt;mb0&lt;/NAME&gt;
        &lt;ICACHE_BASEADDR&gt;0xa0000000&lt;/ICACHE_BASEADDR&gt;
        &lt;ICACHE_HIGHADDR&gt;0xafffffff&lt;/ICACHE_HIGHADDR&gt;
    &lt;/Parameter&gt;
    &lt;Bus_Interface&gt;
        &lt;M_AXI_DP&gt;axiinter0&lt;/M_AXI_DP&gt;
    &lt;/Bus_Interface&gt;
 &lt;/MicroBlaze&gt;
 &lt;AXI_Interconnect id=""0""&gt;
    &lt;Parameter&gt;
        &lt;NAME&gt;axiinter0&lt;/NAME&gt;
    &lt;/Parameter&gt;
 &lt;/AXI_Interconnect&gt;
 &lt;Uartlite id=""0""&gt;
    &lt;Parameter&gt;
        &lt;NAME&gt;uart0&lt;/NAME&gt;
        &lt;BASEADDR&gt;0x40600000&lt;/BASEADDR&gt;
        &lt;HIGHADDR&gt;0x4060ffff&lt;/HIGHADDR&gt;
    &lt;/Parameter&gt;
 &lt;Bus_Interface&gt;
    &lt;S_AXI&gt;axiinter0&lt;/S_AXI&gt;
 &lt;/Bus_Interface&gt;
 &lt;/Uartlite&gt;
 &lt;/System&gt;


How to convert this into working TCL script for Xilinx Vivado","XML is (usually) a general document description language. Tcl is a programming language. They're fairly different.

You can tell Tcl to parse an XML document. The preferred package for doing this is tDOM:

package require tdom

# Parse the XML document
set f [open ""theinputfile.xml""]
set doc [dom parse [read $f]]
close $f

# Get the interesting part
set root [$doc documentElement]

# Iterate over the child elements
foreach elem [$root selectNodes ""./*""] {
    puts ""I've got a [$elem nodeName]""
}


Which will produce output like:


I've got a MicroBlaze
I've got a AXI_Interconnect
I've got a Uartlite


How to transform this into what you actually wantâ€?well, you know that better than I do.",,,,,
vhdl simulation does not work,"I was writing VHDL code in order to find the numbers in a set ranging from 0 to 7 which do not have any common divisors with the other numbers in the set. I tried to implement it on BASYS 3 board. It is working on BASYS 3 but when I tried to write a test bench for my code, I got lots of U's and UU's.Why do you think this is the case? How can I write a proper test bench? I'm a beginner so any idea would help.

TOP MODULE:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity Top is
    Port ( Basys_Clock_Top : in STD_LOGIC;
           New_Clock_Top : out std_logic_vector(3 downto 0);
           SegDisp_Top : out std_logic_vector(6 downto 0);
           Binary_Top : out std_logic_vector(3 downto 0);
           F : out STD_LOGIC);
end Top;

architecture Behavioral of Top is
    --clock component 
    component NewClock
        Port ( New_Clock : out std_logic_vector(3 downto 0);
               Basys_Clock : in STD_LOGIC);
    end component;

    --ssd component
    component SSD
    Port ( Basys_Clock : in STD_LOGIC;
               Binary : in std_logic_vector(3 downto 0);
               SegDisplay : out std_logic_vector(6 downto 0));
    end component; 

    --signals
    signal X, Y, Z, Cont : std_logic;
    signal BCD_Top : std_logic_vector(3 downto 0);

begin
    --port maps
    NewClockModule : NewClock port map( New_Clock =&gt; New_Clock_Top, Basys_Clock =&gt; Basys_Clock_Top);
    SSDModule : SSD port map( Basys_Clock =&gt; Basys_Clock_Top, Binary =&gt; BCD_Top, SegDisplay =&gt; SegDisp_Top);

    --input assignment
    New_Clock_Top(0) &lt;= Z;
    New_Clock_Top(1) &lt;= Y;
    New_Clock_Top(2) &lt;= X;

    Binary_Top &lt;= ""1110"";
    F &lt;= Z or ((not X) and Y);
    F &lt;= Cont;

    process(BCD_Top, Cont)
    begin
        if(Cont = '1') then
            BCD_Top(0) &lt;= Z;
            BCD_Top(1) &lt;= Y;
            BCD_Top(2) &lt;= X;
            BCD_Top(3) &lt;= '0';
        else
            BCD_Top &lt;= ""1111"";
        end if;
    end process;
end Behavioral; 


This is the test bench:

TEST BENCH:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
--use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity TestBench is
--  Port ( );
end TestBench;

architecture Behavioral of TestBench is
    component Top
        Port ( Basys_Clock_Top : in STD_LOGIC;
               New_Clock_Top : out std_logic_vector(3 downto 0);
               SegDisp_Top : out std_logic_vector(6 downto 0);
               Binary_Top : out std_logic_vector(3 downto 0);
               F : out STD_LOGIC);
    end component;

    --signals
    signal Basys_Clock_Top : STD_LOGIC;
    signal New_Clock_Top : std_logic_vector(3 downto 0);
    signal Binary_Top : std_logic_vector(3 downto 0);
    signal SegDisp_Top : std_logic_vector(6 downto 0);
    signal F : std_logic; 

begin
    uut : Top Port Map ( Basys_Clock_Top =&gt; Basys_Clock_Top, New_Clock_Top =&gt; New_Clock_Top, SegDisp_Top =&gt; SegDisp_Top, Binary_Top =&gt; Binary_Top, F =&gt; F);

    stim_proc : process
    begin
        Basys_Clock_Top &lt;= '0';
        wait for 10 ps;
        Basys_Clock_Top &lt;= '1';
        wait for 10 ps;
        Basys_Clock_Top &lt;= '0';
    end process;
end Behavioral;
","One thing I notice: in your TOP module, X, Y, Z, and Cont are not assigned anything.  But you use their values....which will therefore be U",,,,,
Implement a 32x64 register file in Verilog,"Here are the specifications of the register file:


Buses A, B, and W are 64 bits wide.

When RegWr is set to 1, then the data on Bus W is stored in the
register     specified by Rw, on the negative (falling) clock edge.

Register 31 must always read zero. 

Data from registers (as specified by Ra and Rb) is sent on Bus A and
Bus B respectively, after a delay of 2 tics. 

Writes to the register file must have a delay of 3 tics.


The Register File module should have the following interface:

module RegisterFile(BusA, BusB, BusW, RA, RB, RW, RegWr, Clk);


Here is my current program

module RegisterFile(BusA, BusB, BusW, RA, RB, RW, RegWr, Clk);
 output [63:0] BusA;
 output [63:0] BusB;
 output [63:0] BusW;
 input RA;
 input RB;
 input RW;
 input RegWr;
 input Clk;
 reg [31:0] registers [31:0];

 assign #2 BusA = registers [0];
 assign #2 BusB = registers [1];

 always @ (negedge Clk) begin
  if(RegWr &amp; RW !=0)
    registers[RW] &lt;= #3 BusW;
 end
endmodule


I am wondering how to initialize the RA and RB to zero, and wondering how to send the data from RA and RB to BusA and BusB correctly","There are a few things that need to be changed in the code first 


BusA, BusB and BusW are data buses each 64 bits wide. BusW is being used as the input bus, while BusA and BusB are output buses. Therefore the declaration of the ports needs to change as

input [63:0] BusW;
output [63:0] BusA, BusB;

The register file has a depth of 32. and RA, RB and RW are the address buses. These addresses need to be 5 bits wide.

input [4:0] RA,RB,RW;

The complete code can then be re-written as

module RegisterFile(BusA, BusB, BusW, RA, RB, RW, RegWr, Clk);
  output [63:0] BusA, BusB;
  input [63:0] BusW;
  input [4:0] RA, RB, RW;
  input RegWr;
  input Clk;

  reg [63:0] registers [31:0];

  assign #2 BusA = registers[RA];
  assign #2 BusB = registers[RB];

  always @ (negedge Clk) 
  begin
    if(RegWr)
      if (RW != 4'd31)
        registers[RW] &lt;= #3 BusW;
      else 
        // This is done to allow the user to reset the 0th location to a zero value.
        registers[0] &lt;= #3 'd0; 
  end
endmodule



I have simulated this code on edaplayground and also created a small testbench to test it. Here is the link to the code and testbench
https://www.edaplayground.com/x/5DXC",,,,,
VHDL Syntax error in user defined package RNG for genetic algorithm in line number 5,"Library IEEE;

use IEEE.STD_LOGIC_1164.ALL;

use IEEE.STD_LOGIC_ARITH.ALL;

use IEEE.STD_LOGIC_UNSIGNED.ALL;

Type arr is array (1 to mut_bits) of integer;

type chrom_matrix is array (1 to pop_size) of std_logic_vector(1 to n_comp);

type fitness_arr is array (1 to pop_size) of integer range 0 to 1000;

--type fitness_arr1 is array(1 to pop_size) of real;

type adj_matrix is array (1 to n_comp,1 to n_comp) of bit;


function evalfnc (signal chromosome: in std_logic_vector(1 to 8); signal cut_info:adj_matrix) return integer;

procedure randg (variable x,y,t:in integer range 0 to 1000; variable z: out integer);

procedure convert_bit(variable a:in integer;variable y:out std_logic_vector(8 downto 1));

end rng;

package body rng is

procedure randg (variable x,y,t:in integer range 0 to 1000; variable z: out integer) is

variable val, a:integer range 0 to 1000:= 0;

begin

if x&gt;y then

a:= x-y;

else

a:= y-x;

end if;

if t &gt; 3*a then

  val:= (t-a)/2;

  elsif t &gt; a then

  val:= t-a;

    else

    val:= (x+y+t)/2;

    end if;

    z:= val;

    end randg;

    function evalfnc (signal chromosome: in std_logic_vector(1 to 8); signal cut_info:adj_matrix) return integer is

    variable fitness: integer range 0 to 500:= 0;

    variable cut_val: integer range 0 to 15:= 0;

    variable max_fit:integer range 0 to 360:=100;

    begin

     for i in 1 to n_comp loop

       for j in 1 to n_comp loop

        if cut_info(i,j)= â€?â€?then

                               cut_val:= cut_val +1;

             end if;

    end loop;

 end loop;

   fitness := max_fit - cut_val;

   return fitness;

   end evalfnc;


procedure convert_bit(variable a:in integer ; variable y:out std_logic_vector(8 downto 1)) is

variable no:std_logic_vector(8 downto 1):=â€?0000000â€?

variable num: integer range 0 to 256;

begin

    num:= a;

if num &lt;= 255 and num&gt;= 128 then

no(8):=â€?â€?

num:=num - 128;

end if;

if num &lt; 128 and num &gt;= 64 then

     no(7):=â€?â€?

     num:=num - 64;

end if;

     if num &lt; 64 and num &gt;= 32 then

     no(6):=â€?â€?

     num:=num âˆ?2;

end if;

if num &lt; 32 and num &gt;= 16 then

     no(5):=â€?â€?

     num:=num - 16;

       end if;

        if num &lt; 16 and num &gt;= 8 then

       no(4):=â€?â€?

       num:=num - 8;

           end if;

           if num &lt; 8 and num &gt;= 4 then

        no(3):=â€?â€?

         num:=num - 4;

                end if;

                if num &lt; 4 and num &gt;= 2 then

           no(2):=â€?â€?

          num:=num - 2;

                end if;

                if num &lt; 2 then

           no(1):=â€?â€?

           end if;

y:= no;

end convert_bit;

end rng;
",Line 5 should read package rng is.,,,,,
what is the best way to handle defines in system verilog/uvm,"I have a verification component which is used by many teams. I have a define say ADDRESS_WIDTH and i set it to the max of all the requirements from all the teams. 

But that does not look like the ideal solution. Is there a way this can be handled in the SV/UVM way.

I thought of couple of ways 


I list this as a parameter in the agent so that people can use defparams to update it, but then also I would need a way to handle interfaces separately. 


This leaves a potential hole, where someone might update one place and not change another place. 


There is also a command line option to update a define, but that is not ideal solution if the parameter list is too many.
I can have a separate defines file and everyone can have their own defines file, but that would depend on the compilation order.


Please let me know what other better solutions are there.

Thanks in advance.","Use a package to define the parameters that both the interface and verification component will use and therefor keep in sync. Each team can modify the package to suit their needs. 

Create another package that specifies the legal range of values for those parameters and have either the interface or verification use assertions to check the values of the team's package.",,,,,
making Arithmetic in verilog (sign extension) edited,"(edited) i'm working on the verilog Arithmetic project and i got stuck on the sign extension part(assuming this is the problem). i have 4bit input A, B and should have 8 bit output. for some of the process(sum, sub...) i need to use sign extend to make the 8bit output. so for the body of arithmetic, i have this code. this is half of the code. i didn't include the half part cuz it's just long.. 

module arithmetic(A, B, AN0, DP, sum, sub, mult, div, comp, shiftLeft, 
shiftRight, signExtend);

   input signed [3:0] A, B;

   output [7:0] sum, sub, mult, div, comp, shiftLeft, shiftRight, 
   signExtend;

   output AN0, DP;

   //sum
   reg [4:0] qsum;   
   always@ (A, B)
      qsum = A+B;

   assign sum = {{3{qsum[4]}},qsum};

   //sub
   reg [4:0] qsub;

   always@ (A, B)
      qsub = A-B;

   assign sub = {{3{qsub[4]}},qsub};

   //mult
   reg [7:0] qmult;
   always@ (A, B)
      qmult = A * B;

   assign mult = qmult;


and when i checked my simulation, it doesn't have any values but Z, and Xs. it doesn't even show any input values. why is that happening?? thank you

(edited) this is my test bench code. there are 8 operations(sum, subtract, multiply, division, comparator, shiftleft, shiftright, sign extension)

module lap3_top_tb();
reg signed [3:0] A, B;
reg [2:0] Operation;
wire [7:0] Result;
wire DP, AN0;

lab3_top ulap3_top(
  .A(A),
  .B(B),
  .Operation(Operation),
  .Result(Result),
  .DP(DP),
  .AN0(AN0)
);

initial begin
   A = 6; B = 7; Operation = 0;
   #20;
   A = -6; B = -7; Operation = 0;
   #20;      
   A = 6; B = 7; Operation = 1;
   #20;
   A = -6; B = -7; Operation = 1;
   #20;
   A = 6; B = 7; Operation = 2;
   #20;
   A = -6; B = 7; Operation = 2;
   #20;
   A = 7; B = 4; Operation = 3;
   #20;
   A = 7; B = 0; Operation = 3;
   #20;
   A = 6; B = 7; Operation = 4;
   #20;
   A = -6; B = -7; Operation = 4;
   #20;
   A = 1; B = 6; Operation = 5;
   #20;
   A = 1; B = -6; Operation = 5;
   #20;
   A = 1; B = 6; Operation = 6;
   #20;
   A = 1; B = -6; Operation = 6;
   #20;
   A = 6; B = 0; Operation = 7;
   #20;
   A = -5; B = 0; Operation = 7;
   #20;
end

endmodule


the lap3_top file is here. (mux_8_1 will pick the output and out thru Result. if you need code, let me know! but i think mux works fine)

module lap3_top(A, B, Operation, Result, AN0, DP);
   input signed [3:0] A, B;
   input [2:0] Operation;
   output AN0, DP;

   output [7:0] Result;
   wire a, b, c, d, e, f, g, h;

   arithmetic uarithmetic(
   .A(A), 
   .B(B), 
   .AN0(AN0), 
   .DP(DP), 
   .sum(a), 
   .sub(b), 
   .mult(c), 
   .div(d), 
   .comp(e), 
   .shiftLeft(f), 
   .shiftRight(g), 
   .signExtend(h)
   );

   mux_8_1 umux8_1(
   .A(a), 
   .B(b), 
   .C(c), 
   .D(d), 
   .E(e), 
   .F(f), 
   .G(g), 
   .H(h), 
   .Operation(Operation), 
   .Result(Result)
   );

endmodule


thank you so much guys! ","I try to simulate your code and found a following mistake in your code: when you instantiation top module in the testbench module you use lab3_top ulap3_top(...); lab3_top name of module, but module which would you like to has another name module lap3_top(...); lap3_top.

I changed the name and everything works well (on waveform you can see ZZ state,
 because I haven't mux_8_1 module in the code and few operation haven't description)

P.S. By the way, I suppose that you use Vivado as you add this tag. And if that, there has a hint how to check errors like this (with different names in module and in instantiation or when you have some errors in module that it couldn't be compiled in library). If you expand all your modules in hierarchyâ€?you will find ? sign in module where error is. ",,,,,
Verilog carry lookahead adder,"`timescale 100ns/1ps

module CarryLAS_tb;

reg [7:0] a;
reg [7:0] b;
reg ci;

wire [7:0] sum;
wire of; //overflow
wire co;

integer i;

CarryLAS_8 CLA(a,b,ci,sum,co,of);   



initial begin 

a=0;
b=0;
ci=0;

end


initial begin // all possible cases 

for(i=0; i&lt;262144; i=i+1) // 2^18


#10 {a, b, ci} = i;


end

endmodule

module CarryLAS_8(a,b,ci,sum,co,of);

input [7:0] a,b;

input ci; // 0; Add 1: Subtract

output [7:0] sum;
output co;
output of;

wire[7:0] c;

wire[7:0] xb;

xor(xb[0],b[0],ci);

xor(xb[1],b[1],ci);

xor(xb[2],b[2],ci);

xor(xb[3],b[3],ci);

xor(xb[4],b[4],ci);

xor(xb[5],b[5],ci);

xor(xb[6],b[6],ci);

xor(xb[7],b[7],ci);

xor(of,c[7],c[6]);

xor(co,c[7],ci);

CarryLA_8 CLAS(a,xb,ci,sum,co);


endmodule


module CarryLA_8(a,b,ci,sum,co);

input [7:0] a,b;
input ci;

output [7:0] sum;
output co;

wire [7:0] sum;
wire cm,co;

CarryLA_4 CLA0(a[3:0],b[3:0],ci,sum[3:0],cm);
CarryLA_4 CLA1(a[7:4],b[7:4],cm,sum[7:4],cm);

endmodule


module CarryLA_4(a,b,ci,sum,co);

input [3:0] a,b;

input ci; // 0; Add 1: Subtract

output [3:0] sum;

output co;

wire[3:0] g,p,cout;
wire G0,P0;
wire[9:0] w;

and a0(g[0],a[0],b[0]); 
and a1(g[1],a[1],b[1]); 
and a2(g[2],a[2],b[2]); 
and a3(g[3],a[3],b[3]); 


xor x0(p[0],a[0],b[0]);
xor x1(p[1],a[1],b[1]);
xor x2(p[2],a[2],b[2]);
xor x3(p[3],a[3],b[3]);

and and0(w[0],p[0],ci);
or or0(cout[0],g[0],w[0]);

and and1(w[1],p[1],p[0],ci);
and and2(w[2],p[1],g[0]);
or or1(cout[1],g[1],w[2],w[1]);

and and3(w[3],p[2],p[1],p[0],ci);
and and4(w[4],p[2],p[1],g[0]);
and and5(w[5],p[2],g[1]);
or or2(cout[2],g[2],w[5],w[4],w[3]);

and and6(w[6],p[3],p[2],p[1],g[0]);
and and7(w[7],p[3],p[2],g[1]);
and and8(g[2],a[2],b[2]); 
or or3(G0,g[3],w[8],w[7],w[6]);

and and9(P0,p[3],p[2],p[1],p[0]);

and and10(w[9],P0,ci);
or or4(cout[3],G0,w[9]);

and and11(co,cout[3],1);

xor xor0(sum[0],p[0],ci);
xor xor1(sum[1],p[1],cout[0]);
xor xor2(sum[2],p[2],cout[1]);
xor xor3(sum[3],p[3],cout[2]);



endmodule


This is my Verilog code. simulated well, but the result kinda sucks. 
'sum' produces values with some Xs, and 'co', 'of'(overflow detection) are also Xs. I couldn't find out what the problem is. It might be about carry I think.
Could anyone help me with this?
Any help would be really appreciated.
Thanks in advance.

Captured waveform is attached

enter image description here

enter image description here","You have multiple drivers on wire [8:0] c.  In your generate you have:

or o1 (c[i+1],g[i],q[i]);


and then you have the FullAdder instances that drive c:

FullAdder a0(a[0],b[0],ci,sum[0],c[0]);


I can't be certain that this is the reason that it won't simulate, but it certainly will make it not function correctly.",,,,,
Verilog simulation errors,"In the simulation, 'a' won't be change its value and I can't seem to know why.
'carry out(co)' always comes out as HiZ, and the 'sum' creates a bit weird values. 'of(overflow)' value as well
Can anybody help me out with this?
Any help will be appreciated.
Thanks a lot in advance.        

    `timescale 100ps/1ps    
module RCA_tb;
reg [7:0] a;
reg [7:0] b;
reg ci;
wire [7:0] sum;
wire co;
wire of; //overflow
integer i;

RippleCA RCA(a,b,ci,sum,co,of); 

initial begin 

    a=0;
    b=0;
    ci=0;

    end



    initial begin // all possible cases 

    for(i=0; i&lt;256; i=i+1)


    #10 {a, b, ci} = i;


    end
endmodule

module RippleCA(a,b,ci,sum,co,of);
input [7:0] a;
input [7:0] b;
input ci;
output [7:0] sum;
output co;
output of;
wire[6:0] c;
FullAdder a1(a[0],b[0],ci,sum[0],c[0]);
FullAdder a2(a[1],b[1],c[0],sum[1],c[1]);
FullAdder a3(a[2],b[2],c[1],sum[2],c[2]);
FullAdder a4(a[3],b[3],c[2],sum[3],c[3]);
FullAdder a5(a[4],b[4],c[3],sum[4],c[4]);
FullAdder a6(a[5],b[5],c[4],sum[5],c[5]);
FullAdder a7(a[6],b[6],c[5],sum[6],c[6]);
FullAdder a8(a[7],b[7],c[6],sum[7],cout);
xor x2(of,c[6],co); //overflow detection
endmodule
module FullAdder (
a,b,ci,sum,co
);
input a,b,ci;
output sum,co;
wire w1, w2, w3;
xor x1(sum, a, b, ci);
and a1(w1,a,b);
and a2(w2,b,ci);
and a3(w3,ci,a);
or o1(co,w1,w2,w3);
endmodule


This is my Verilog code.

enter image description here

enter image description here","You declared

reg [7:0] a;
reg [7:0] b;
reg ci;


And assigned 

{a, b, ci} = i;


{a,b,ci} is 17 bits wide but you are counting i to up to 255 which is 8 bits wide, in this case a will always be zero. If you increase your for loop to for(i=0; i&lt;262144; i=i+1) you should be able to test it.",,,,,
"In Verilog, how to wait for level-sensitive and edge-sensitive events simultaneously?","When writing a testbench in Verilog, in a ""task"" I need to wait for such an event to occur, that is: while signal_a is 1'b1, signal_b is having a posedge. However, unfortunately I tried but got no good solution:

@(tb_hready and posedge tb_hclk)        ;//(1)
wait(tb_hready) @(posedge tb_hclk)      ;//(2)
wait(tb_hready &amp;&amp; posedge tb_hclk)      ;//(3)
if(tb_hready) @(posedge tb_hclk)        ;//(4)


(1) is grammar error;

(2) grammar is good, but it will first wait for tb_hready to go high, then pick up the posedge even if tb_hready is low again; -- this is not what I want.

(3) is grammar error;

(4) grammar is good, but does NOT implement what I want, seems like in such expression it does NOT ""wait"" for tb_hready to become high at all.

I figured this should be something rather easy, but I just cannot get what I want, nor does Google help much. Anyone have any suggestions? thx~~","@(posedge tb_hclk iff tb_hready)
",,,,,
Compare std_logic_vector in a if() condition vhdl,"I am trying to compare counting value (std_logic_vector) with a defined hex value. but i dont get the result the way i did as below

signal count : STD_LOGIC_VECTOR(res_bits-1 DOWNTO 0):= x""0000""; --res_bits =16
signal round : STD_LOGIC_VECTOR(res_bits-1 DOWNTO 0):= x""0000"";
signal cnt : STD_LOGIC_VECTOR(res_bits-1 DOWNTO 0):= x""0000""; --res_bits =16
    process(clk_50)
begin
    if (falling_edge(clk_50)) then
        t(1)&lt;=t(0); 
        t(0)&lt;=A;
        t(3)&lt;=t(2); 
        t(2)&lt;=B;
        case (temp) is
            when ""0001"" =&gt; cnt&lt;= cnt + '1';
            when ""0010"" =&gt; cnt&lt;= cnt - '1';
            when ""1000"" =&gt; cnt&lt;= cnt + '1';     
            when ""1011"" =&gt; cnt&lt;= cnt - '1';

        end case;
        count &lt;= cnt;
        if (count = x""0320"") then --if count 800
            round &lt;= round + '1';
            cnt &lt;= x""0000"";   -- reset cnt
            count &lt;= x""0000"";   -- reset count
        end if;
    end if;
end process;
","First things first: What do you think a std_logic_vector is? std_logic_vector is an array of std_logic. std_logic is an std_ulogic which has been resolved. std_ulogic is a type that defines states of an electrical line in digital circuits. But more importantly: std_logic[_vector] is not an integer type.

If you want to do arithmetic with the + and - operators, you should use an arithmetic type. signed and unsigned, defined in numeric_std, are best suited for this. so don't use use ieee.std_logic_arith.all(non standard), but use use ieee.numeric_std.all (defined in the standard).



Next, some information an resetting a signal. What if you decide to set res_bits = 17? Then

signal count : STD_LOGIC_VECTOR(res_bits-1 DOWNTO 0):= x""0000"";


will not work. So instead use others to set all bits to '0' for maximum flexibility. I.e.

signal count : UNSIGNED(res_bits-1 DOWNTO 0) := (others =&gt; '0');




Now lets look at the process... Hmmm. There are a number of assignments to temp... but you never define temp. Cannot help you there...

Then look at the case statements. case (temp) is.... I see a when for 1, 2, 4, 7, 8, etc... but what happens when temp is e.g. 0? You need to define a when for all possibilities. But what if you don't want to do anything for these cases? ... Just do null! E.g.

case (temp) is
    when ""0001"" =&gt; cnt&lt;= cnt + '1';
    [...]
    when ""1110"" =&gt; cnt&lt;= cnt + '1';
    when others =&gt; null; -- &lt;== required
end case;




Another thing for case-statements. Combine situations with the pipe symbol.

case (temp) is
    when ""0001"" | ""0111"" | ""1000"" | ""1110"" =&gt; cnt &lt;= cnt + '1';
    when ""0010"" | ""0100"" | ""1011"" | ""1101"" =&gt; cnt &lt;= cnt - '1';
    when others =&gt; null;
end case;




Then about signal assignment. A value applied to a signal will not be applied until the next delta cycle. But this delta cycle does not occur until after the process is finished. E.g.:


Imagine cnt=799=x""031F"" and temp=""0001"" when the process starts.
at the case statement, cnt &lt;= cnt + 1 is selected. This operation is scheduled for the next delta cycle, nut cnt will stay 799 for now.
So, at count &lt;= cnt;, 799 will be scheduled to be assigned to count, not 800! But as this operation is also scheduled, count will for now still have it's old value (likely 798).
This means that at if (count =, count will still be seen as 798. It will take another two clock cycles for count to reach 800, due to the extra registers inferred.


You should probably use variables for temporary values in the process. But watch out with what you are doing: variables loose their value when the process finishes and should never be used outside of the process.",,,,,
VHDL error: type specified in Qualified Expression must match type implied for expression by context,"I'm trying to use a function created by myself (it's the first time I try it so I might probably have done something wrong there).

When I try to compile I get the following error message: Error (13815): VHDL Qualified Expression error at Averageador.vhd(38): divide type specified in Qualified Expression must match unsigned type that is implied for expression by context

Divide is the name of my function. This function divides any 16bit unsigned value by an unknown unsigned value and gives the result as a fixed point 32bit unsigned value, where 16bit are on each side of the point. This is the code:

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;

package propios is

 --function declaration.
function divide (a : UNSIGNED; b: UNSIGNED) return UNSIGNED;
end propios;   --end of package.

package body propios is  --start of package body
--definition of function
function  divide (a : UNSIGNED; b: UNSIGNED) return UNSIGNED is
variable a_int : unsigned(a'length+7 downto 0):= (others =&gt; '0');
variable b_int : unsigned(b'length-1 downto 0):=b;
variable r : unsigned(b'length downto 0):= (others =&gt; '0');
variable q : unsigned(31 downto 0):= (others =&gt; '0');
begin
a_int(a'length+7 downto 16):=a;
for i in a'length+7 downto 0 loop
    r(b'length downto 1):=r(b'length-1 downto 0);
    r(0) := a_int(i);
    if (r&gt;=q) then
        r:=r-b_int;
        q(i):='1';
    end if;
end loop;
return q;
end divide;
--end function
end propios;  --end of the package body


I return q which is a 32-bit unsigned.

This is a code in which I use the function and prompts the error message:

   library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.propios.all;

ENTITY test IS --Con alimentaciÃ³n de datos posiciÃ³n a posiciÃ³n, no vector de golpe.

END test;
Architecture simple of test is
signal a:unsigned(15 downto 0);
signal b:unsigned(13 downto 0);
signal c: unsigned(31 downto 0);
begin


process 
begin
a&lt;=""1100100110100111"";
b&lt;=""00000000000010"";
c&lt;= divide(a,b);


end process;


end simple;


Any suggestions? Thank you","The problem is caused (as user1155120 said) by using the package std_logic_arith on the package and numeric_std on the test. Therefore, even if both are called unsigned they are not compatible with each other.

Both codes contained other errors which have also been corrected but were not related to this first error.

This is the package with a function for dividing 2 unsigned numbers with 16bits after the coma:

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

package propios is

 --function declaration.
function divide (a : UNSIGNED; b: UNSIGNED) return UNSIGNED;
end propios;   --end of package.

package body propios is  --start of package body
--definition of function
function  divide (a : UNSIGNED; b: UNSIGNED) return UNSIGNED is
variable a_int : unsigned(a'length+15 downto 0):= (others =&gt; '0');--Length is 16 bit longer than a
variable b_int : unsigned(b'length-1 downto 0):=b;
variable r : unsigned(b'length downto 0):= (others =&gt; '0');
variable q : unsigned(a'length+15 downto 0):= (others =&gt; '0');--Same length as a_int
variable i: natural;

begin
a_int(a'length+15 downto 16):=a;--the MSBits are ""a"" and the rest will be 0's
for i in a'length+15 downto 0 loop--division using a modified version of integer division (unsigned) with remainder as seen in:
--https://en.wikipedia.org/wiki/Division_algorithm
    r(b'length downto 1):=r(b'length-1 downto 0);
    r(0) := a_int(i);
    if (r&gt;=b_int) then
        r:=r-b_int;
        q(i):='1';
    end if;
end loop;
return q;
end divide;
--end function
end propios;  --end of the package body


This is a simple test to check its functionality:

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
use work.propios.all;

ENTITY test IS --Con alimentaciÃ³n de datos posiciÃ³n a posiciÃ³n, no vector de golpe.

END test;
Architecture simple of test is
signal a:unsigned(23 downto 0);
signal b:unsigned(13 downto 0);
signal c: unsigned(39 downto 0);
begin


process 
begin
a&lt;=""000000001100100110100111"";
b&lt;=""00000000010010"";
wait for 200ps;
c&lt;= divide (a , b);

wait;   
end process;


end simple;


To check the result have in mind that the last 16 bits of the result are behind the fixed point.",,,,,
Is there any way to simulate entries for systemverilog?,"I have the following input: logic SWI[7: 0], which I would like to control from another executable, in C ++ for example.

And I have the following outputs: logic LED[7:0], SEG[7: 0], which I would like to get in real time.

Is there any way to simulate systemverilog in such a way that I can simulate inputs and get outputs (in this model)?

Example code that I would like to run:

logic T1, T2;
always_comb begin
    T1 &lt;= SWI[0];
    T2 &lt;= SWI[1];

    LED[0] &lt;= T1 &amp;&amp; T2;
end


I'm sorry for bad english.","You can use DPI (C/C++ code linked to the simulation) to get/set values of Verilog signals. Then you can implement some IPC from this DPI code to another executable (e.g. using sockets, pipes etc.).",,,,,
Is it possible to fully compile a module and then instantiate it in a testbench separately?,"Is it possible to make a fully compiled and standalone version of an RTL module, like a snapshot in Cadence terms, and then later instantiate this compiled module into a testbench?
Ultimately, running another compile step to create a final snapshot which contains the originally delivered snapshot but now instantiated in the testbench.

If so, are there any special considerations when compiling the original snapshot to enable this and how would you instantiate such a compiled object within a testbench?","Yes. But every simulation tool has slightly different approaches to the compilation flow. Most tools break this flow into a number steps: parsing, optimization, elaboration, and initialization (the snapshot you mention is the last step). Not all tools give you access to all the individual steps.

There are several ways to achieve what you ask for, but the choice really depends on why you want to do this, and what limitations you are willing to work with. 

You can parse your module's source code into a library and then re-use that same library for compiling many different test benches. But usually the time consuming part is optimization. 

Questa provides what you are looking for in what they call the Pre-compiled Design Unit (PDU) flow. You can optimize your RTL module and save it back into a library, and Questa simply choses the optimized module instead of the un-optimized module during elaboration. The special considerations are that you need to preserve any signals from optimization that might have hierarchical references from the testbench. ",,,,,
Libero SoC timing constraints (*.sdc) difference,"After designing RTL I create my_design.sdc file (for constraining clocks, input/output delays, ...) using Synplify pro. When constraints are correct, I click on synthesize and I get another my_design_sdc.sdc file automatically. If I right click on the first one, I can select ""Use for synthesis"" and ""Use for compile"" for my_design_sdc.sdc file. What I don't understand is, which file is for what, because after compile and place and route, there is also SmartTime software which takes the my_design_sdc.sdc file.

Q1: What relations are between these two files?

Q2: Does one have to have both of them in complete chain (RTL design to program)?

Q3: If so, how can I be sure that relations between constraints are the same, if SmartTime has different commands than Synplify?

Synplify multicycle constraint definition:

set_multicycle_path [-start|-end] [-from {objectList}] [-through {objectList} [-through {objectList} ...]] [-to {objectList}] pathMultiplier[-disable] [-commentcommentString]

SmartTime multicycle constraint definition:

set_multicycle_path ncycles [-setup] [-hold] [-from from_list] [â€“through through_list] [-to to_list] 

Also, Synplify uses define_clock command for clock constrain definition and SmartTime uses create_clock. Those are only few differences.

I'm using:


Libero SoC v11.8 sp2 (in classic constraint flow view)
IGLOO2
","Q1: Synplify auto-generates a smarttime SDC-file based on the clock settings you gave synplify. So that you don't have to define all your clocks twice. As you already figured out, Synplify and Smarttime require slightly different SDC files.

Q2: Depends on your project. Typically you create a SDC file for Synplify, containing basically only clock information. Then you take the auto-generated SDC from synplify and give it to the 'compile' step, together with a third SDC where you define all input/output delays, false paths, and things like that.

Q3: That is what the auto-generated file is for. It allows you to define all the clock settings in only one SDC file.

Keep in mind that the SDC info you give Synplify is typically not terribly important. It just helps Synplify make slightly better area/speed optimization calls sometimes.
The SDC files you give to the compile step are the critical ones. Here your clocks, input/output delays and false paths must be 100% correct.

By the way: Multicycle paths are basically an ""expert level mechanism"". Very difficult to get those right. It is something which is very rarely used in proper design. Their function is however very frequently misunderstood and misused, causing unstable designs.
In all likelyhood, multi cycle path constraints is not something which you should use in your design.",,,,,
Programming device in vivado using tcl,"I am trying out programming my digilent FPGA through the vivado command line.  After opening the hardware server I can program my device as follows...

program_hw_devices [get_hw_devices xc7a100t_0]


Then if I run puts [get_hw_devices xc7a100t_0] it outputs xc7a100t_0 which leads me to think that I should be able to just do something like program_hw_devices xc7a100t_0.  This however fails and I get the following output.


  ERROR: [Common 17-161] Invalid option
  value 'xc7a100t_0' specified for 'hw_device'.


I don't really understand what is wrong with this.  I thought the two commands would be equivalent since I just passed it what was returned by get_hw_devices.  Also I thought the type of everything in tcl was just a string.  Does the output of [get_hw_devices xc7a100t_0] have some special type?","Looking at usage patterns, we see that the recommended usage is:

program_hw_devices [lindex [get_hw_devices] 0]


Given the text of the output of get_hw_devices is a â€œsimpleâ€?word (no spaces or Tcl metacharacters), I suspect that the device tokens are actually special values that have non-trivial types hanging off the back end of their representation. We don't recommend that approach as it can lead to very weird error messages (such as the one you got), but given that it is so, you need to use exactly the pattern as described above so that you strip exactly one level of list-ness away.



For future reference, the script at that link (which was supposedly working) was:


# Connect to the Digilent Cable on localhost:3121

connect_hw_server -url localhost:3121
current_hw_target [get_hw_targets */xilinx_tcf/Digilent/12345]
open_hw_target

# Program and Refresh the XC7K325T Device

current_hw_device [lindex [get_hw_devices] 0]
refresh_hw_device -update_hw_probes false [lindex [get_hw_devices] 0]
set_property PROGRAM.FILE {C:/design.bit} [lindex [get_hw_devices] 0]
set_property PROBES.FILE {C:/design.ltx} [lindex [get_hw_devices] 0]

program_hw_devices [lindex [get_hw_devices] 0]
refresh_hw_device [lindex [get_hw_devices] 0]



I would have written it more like this myself:

# Connect to the Digilent Cable on localhost:3121
connect_hw_server -url localhost:3121
current_hw_target [get_hw_targets */xilinx_tcf/Digilent/12345]
open_hw_target

# Program and Refresh the XC7K325T Device
set Device [lindex [get_hw_devices] 0]
current_hw_device $Device
refresh_hw_device -update_hw_probes false $Device
set_property PROGRAM.FILE ""C:/design.bit"" $Device
set_property PROBES.FILE ""C:/design.ltx"" $Device

program_hw_devices $Device
refresh_hw_device $Device


so that I only do the list extraction once, but that's purely style; if one works, the other should as well.",,,,,
Can nettype be used to define struct in System Verilog?,"Can nettype be used to define struct in SystemVerilog language?

I am getting failure in defining so, can anybody tell me?","A nettype cannot be used as a member of a struct. Only other data types can be used as struct members. A nettype is a kind of signal that can have a data type, including a struct, but a nettype itself is not a data type. ",,,,,
Assigning an array to a vector 32 bits at the time,"I have an array 32 bit wide of n elements and I am trying to assign these elements to a vector, I have the following code:

 function automatic logic [SIZE-1:0] my_function (my_array x_map);

    logic SIZE-1:0] y_map               = '0;
    int fctr                            = (SIZE)/32;
    int top_bnd                         = 31;
    int lwr_bnd                         = 0;

for(int k0 = 0; k0 &lt; fctr; k0++)
    begin

    y_map[top_bnd:lwr_bnd]              = x_map[k0];
    top_bnd                             = (top_bnd + 32'hFFFF);
    lwr_bnd                             = (lwr_bnd + 32'hFFFF);

    end

return y_map;

endfunction


However this is not working and I get two errors:

1) ""the range of the part select is illegal""
2) ""Cannot evaluate the expression in left slicing expression, the expression must be compile time constant""

Thanks","You might want to use the streaming operators for this

y_map = {&lt;&lt;32{x_map}};


BTW, you should show the declarations of all identifiers in your example, i.e. my_array.",,,,,
10821 HDL error - Porting VHDL code from Xlinx to Altera,"I'm trying to synthesize a code in VHDL on Quartus II that describes RAM blocks. But this code was meant to be synthesized for a Xlinx chip.

It's part of a lecture from https://opencores.org/project/cpu_lecture

Here follow the entity header:

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity RAMB4_S4_S4 is
generic(INIT_00 : bit_vector := X""00000000000000000000000000000000""
                              &amp;  ""00000000000000000000000000000000"";
        INIT_01 : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_02 : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_03 : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_04 : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_05 : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_06 : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_07 : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_08 : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_09 : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_0A : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_0B : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_0C : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_0D : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_0E : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"";
        INIT_0F : bit_vector := X""00000000000000000000000000000000""
                              &amp; X""00000000000000000000000000000000"");

port(   ADDRA   : in  std_logic_vector(9 downto 0);
        ADDRB   : in  std_logic_vector(9 downto 0);
        CLKA    : in  std_ulogic;
        CLKB    : in  std_ulogic;
        DIA     : in  std_logic_vector(3 downto 0);
        DIB     : in  std_logic_vector(3 downto 0);
        ENA     : in  std_ulogic;
        ENB     : in  std_ulogic;
        RSTA    : in  std_ulogic;
        RSTB    : in  std_ulogic;
        WEA     : in  std_ulogic;
        WEB     : in  std_ulogic;

        DOA     : out std_logic_vector(3 downto 0);
        DOB     : out std_logic_vector(3 downto 0));
end RAMB4_S4_S4;


The part of the code that is giving me trouble is:

if (rising_edge(CLKB)) then
        if (ENB = '1') then
            DOB(3) &lt;= cv(DATA(conv_integer(ADDRB &amp; ""11"")));
            DOB(2) &lt;= cv(DATA(conv_integer(ADDRB &amp; ""10"")));
            DOB(1) &lt;= cv(DATA(conv_integer(ADDRB &amp; ""01"")));
            DOB(0) &lt;= cv(DATA(conv_integer(ADDRB &amp; ""00"")));
            if (WEB = '1') then
                DATA(conv_integer(ADDRB &amp; ""11"")) &lt;= cv1(DIB(3));
                DATA(conv_integer(ADDRB &amp; ""10"")) &lt;= cv1(DIB(2));
                DATA(conv_integer(ADDRB &amp; ""01"")) &lt;= cv1(DIB(1));
                DATA(conv_integer(ADDRB &amp; ""00"")) &lt;= cv1(DIB(0));
            end if;
        end if;
    end if;


And I'm getting the following error message:

Error (10821): HDL error at RAMB4_S4_S4.vhd(129): can't infer register for ""DATA[0]"" because its behavior does not match any supported register model


As I said before, I know that this code was meant to be synthesized to a Xlinx chip. What I don't know is witch features in this code are not supported by the Quartus II synthesizer and how to modify it in a proper way to by synthesized. ","This sounds to me like (what I've recently learnt is) an XY problem: asking about an attempted solution rather than the actual problem. 

The way to get this code working with Intel (Altera) is to find out what kind of RAM this is and to generate the same RAM using Intel's IP generator and then to connect that up in the same place in the code. You will almost certainly find that the interface to the Intel RAM will not be exactly the same as the Xilinx. A good way to fix this is to write an alternative architecture for the Xilinx RAM and to instantiate the Intel RAM in that architecture, doing the necessary name-changing, sense-changing and anything other hacking required there. Such a dummy layer of hierarchy is call a wrapper.

It may well be the case that the Xilinx RAM is not synthesisable on Xilinx tools either, but is instead just a simulation model, intended to be used in place of the output of a RAM generated by the Xilinx IP generator. 

The actual reason for your error message is not because some ""features in this code are not supported by the Quartus II synthesizer"" per se, but because Quartus is not recognising the code as being a RAM and so is trying to synthesise flip-flops. It is then discovering that the code cannot be synthesised using flip-flops (because it is modelling the behaviour of a RAM). ",,,,,
How can I write my C program in two functions?,"I was wondering how I can write my C code (just one single .c with a couple of different functions) into just two functions with inputs and outputs. 
I am looking for these because I am going two put some part of my code into CPU and leave the other in FPGA, they can communicate with each other via the interface in Zynq family board (e.g. ZC706).

In this regards, via the Vivado HLS, I have to have just one single Function which can be translated to e.g. VHDL via the Vivado HLS and the other function can stay in CPU.

Thanks in advance and if needed can share my code.","Not at all!

There are no pthreads or functions in FPGA.
You must think the FPGA is more like a circuit. There are physical connections like wires. Internally especially in the Zynq family you can communicate through the RAM, DMA controllers or via Registers.
There is documentation from Xilinx, what you need is AXI/AXI Stream.

But what you want to do is writing any C code and run them in the FPGA area like in a processor. And this approach is not promising.

In Vivado HLS you can write ""functions"" in C/C++/OpenCL/SystemC but it is only a block with inputs and outputs translated to a hardware description language (VHDL/Verilog).
You have to export it and add it in your Vivado Project to use it.
At this point maybe your IP created in HLS will do something you expect, but there is still a lot of work todo connecting the Ports in the right manner.

My advice is get familiar with the Zynq family and especially the AXI protocol. If you feel familiar with DMA/AXI4/AXI4S and how to access them from ARM and Logic then start using HLS. Otherwise you will not have the feeling how to write code HLS understands.",,,,,
Is always block needed for a generate-instantiated module to propagate the sensitivity list?,"I am getting confuse when coding Verilog which involves the mixture of always block, generate block and instantiation. Appreciate if somebody could help me on this.

block_A is a module which will reset x when rst signal is asserted. I tested block_A and see that x are being reset to 0 when rst signal is asserted. This is fairy straightforward.

module block_A #(parameter N=4) ( 
    input clk, rst, 
    input signed [N-1:0] w [3:0];
    output logic signed [N+2:0] x [3:0]
);

genvar i;
generate
    for (i=0; i&lt;=3; i=i+1) begin
        always_ff @ (posedge clk, posedge rst) begin
            if (rst)    x[i] &lt;= 0;
            else        x[i] &lt;= x_[i];
        end
    end
endgenerate


However, when I try to instantiate multiple block_A into the top module using generate block, I observe a very strange scenario. x[6] and x[7] are not being reset to 0. Am I doing it in the wrong way? Should I create another always_ff block and put this generate block inside it? Meaning, we need to propagate the sensitivity list? It doesn't look sensible to put the generate block under the existing always_ff block as it is generated in loop fashion.

module top #(parameter N=4) (
    input clk, rst, 
    input signed [N-1:0] w [15:0],
    output logic signed [N+5:0] y [15:0]
};

logic signed [N+2:0] x [15:0];

genvar i;
generate
    for (i=0; i&lt;=15; i=i+1) begin: pipeline_y
        always_ff @ (posedge clk, posedge rst) begin
            if (rst)    y[i] &lt;= 0;
            else        y[i] &lt;= y_[i];
        end
    end
endgenerate

genvar j;
generate
    for (j=0; j&lt;=15; j=j+4) begin: my_block
        block_A #(.N(N)) my_block_A(.w(w[j+3:j]),.x(x[j+3:j]),.rst(rst),.clk(clk));
    end
endgenerate
","Looks like I am looking for solution in the wrong direction.

The reason for 'X' state at x[6] and x[7] is due to the array 

input signed [N-1:0] w [15:0]


in which w is unpacked array with N packed bits.

block_A #(.N(N)) my_block_A(.w(w[j+3:j]),.x(x[j+3:j]),.rst(rst),.clk(clk));


This will work when w is defined as a 2D packed array.

Solution:

input signed [15:0][N-1:0] w
logic signed [15:0][N+2:0] x 
",,,,,
Implementations of an Adder in VHDL comparison,"Can someone explain me why this implementation works

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;

entity Adder is
    port(A: in std_logic_vector(3 downto 0);
    B: in std_logic_vector(3 downto 0);
    SUM: out std_logic_vector(3 downto 0);
    CO: out std_logic);
end;

architecture DescriptionAdders of Adder is

signal temp:  std_logic_vector(4 downto 0);
signal temp1: std_logic_vector(4 downto 0);
signal temp2: std_logic_vector(4 downto 0);

begin

temp1 &lt;= '0' &amp; A;
temp2 &lt;= '0' &amp; B;
temp &lt;= std_logic_vector(unsigned(temp1) + unsigned(temp2));

SUM &lt;= temp(3 downto 0);
CO &lt;= temp(4);

end;


while this doesn't (the SUM is XX when it starts running, then it is always one step behind the real result, but the temps update well).

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;

entity Adder is
    port(A: in std_logic_vector(3 downto 0);
    B: in std_logic_vector(3 downto 0);
    SUM: out std_logic_vector(3 downto 0);
    CO: out std_logic);
end;

architecture DescriptionAdders of Adder is

signal temp:  std_logic_vector(4 downto 0);
signal temp1: std_logic_vector(4 downto 0);
signal temp2: std_logic_vector(4 downto 0);

begin

process(A, B) is
begin
    temp1 &lt;= '0' &amp; A;
    temp2 &lt;= '0' &amp; B;
    temp &lt;= std_logic_vector(unsigned(temp1) + unsigned(temp2));
end process;

SUM &lt;= temp(3 downto 0);
CO &lt;= temp(4);

end;


Sorry if the question is too easy, I'm a begginer.","This question seems to be based about a common misconception of how VHDL simulation works.

process(A, B)


means the process will be triggered at an event of A or B. What happens in the process are assignments to additional objects

temp1 &lt;= '0' &amp; A;
temp2 &lt;= '0' &amp; B;
temp &lt;= std_logic_vector(unsigned(temp1) + unsigned(temp2));


This means three events will be scheduled, one to each of temp1, temp2 and temp. But the way VHDL works, the actual assignments will not occur until the next delta cycle. Which occurs after the process is evaluated. So even though the lines for assignment to temp1 and temp2 are located before the assignemnt to temp, their values have not been changed yet.

Considering values of temp1 and temp2 change after the process is finished, the assignment to temp is missed. Unless you re-enter the process, by adding the objects to the sensitivity list. E.g.

process(A, B, temp1, temp2) is
begin
    temp1 &lt;= '0' &amp; A;
    temp2 &lt;= '0' &amp; B;
    temp &lt;= std_logic_vector(unsigned(temp1) + unsigned(temp2));
end process;


An alternative solution would be to use variables, which can change inside of the process. But please note that variables can cause difficulties in logic synthesis if not properly used. This example will work:

process(A, B) is
    variable temp1, temp2 : std_logic_vector(4 downto 0);
begin
    temp1 := '0' &amp; A;
    temp2 := '0' &amp; B;
    temp &lt;= std_logic_vector(unsigned(temp1) + unsigned(temp2));
end process;


But the question is: why do you need temp1 and temp2 at all. Just write

process(A, B) is
begin
    temp &lt;= std_logic_vector(unsigned('0' &amp; A) + unsigned('0' &amp; B));
end process;


Or a bit more flexible

process(A, B) is
begin
    temp &lt;= std_logic_vector(
        resize(unsigned(A), temp'length) +
        resize(unsigned(B), temp'length));
end process;


Or even using the integer type (limited to 32 bits!)

process(A, B) is
begin
    temp &lt;= std_logic_vector(to_unsigned(
        to_integer(unsigned(A)) + to_integer(unsigned(B))
        , temp'length));
end process;
",,,,,
Assign 2d std_logic_vector with another 1d std_logic_vector in VHDL,"I have this port  

PORT (
    A : IN  STD_LOGIC_VECTOR(31 downto 0);
    B : IN  STD_LOGIC_VECTOR(31 downto 0);
    C : IN  STD_LOGIC_VECTOR(31 downto 0);
    F : OUT STD_LOGIC_VECTOR(31 downto 0);
);


and this signal  

SIGNAL data : std_logic_2d(31 downto 0, 2 downto 0);


I need to assign data(all,0) with A and data(all,1) with B and so on
like that  

data(?,0) &lt;= A;
data(?,1) &lt;= B;
data(?,2) &lt;= C;


what can I put instead of ""?"" in the code to perform it??","Solution 1 - process and for-loop:

A process is used to host a sequential for loop. You need to add all read signals to the sensitivity list: A, B, C.

process(A, B, C)
begin
  for i in A'range loop
    data(i, 0) &lt;= A(i);
    data(i, 1) &lt;= B(i);
    data(i, 2) &lt;= C(i);
  end loop;
end process;


Solution 2 - for-generate:

A generate loop is used to create lots of concurrent assignments.

gen: for i in A'range generate
  data(i, 0) &lt;= A(i);
  data(i, 1) &lt;= B(i);
  data(i, 2) &lt;= C(i);
end generate;


Solution 3 - a assignment procesdure:

A procedure is used to encapsulate the assignment to rows.

procedure assign_col(signal slm : out T_SLM; slv : std_logic_vector; constant ColIndex : natural) is
  variable temp : std_logic_vector(slm'range(1));
begin
  temp := slv;
    for i in temp'range loop
      slm(i, ColIndex)  &lt;= temp(i);
  end loop;
end procedure;


Source: PoC.vectors.assign_col

Usage:

assign_col(data, A, 0);
assign_col(data, B, 1);
assign_col(data, C, 2);


The package PoC.vectors contains a lot of new types, functions and procedures to handle true std_logic based 2D arrays in VHDL.",,,,,
Logical circuits functions and designing vhdl code,"I don't know if those 2 functions i have found using Karnaugh tables are mathcing the VHDL code below (I am not really good at VHDL).

The functions :

f &lt;= (x3 or x5) and (x2 or x4') and (x4' or x5) and (x1' or x2) and (x2' or x4 or x5')

and

g &lt;= (x2 or x4' or x5') and (x2 or x3' or x4') and (x2' or x4 or x5') and (x1' or x2 or x5') and (x1 or x3' or x4' or x5')

Here is the code:

basic_components.vhd :

library ieee;
use ieee.std_logic_1164.all;
package basic_components is
  -- AND2 declaration
 component myAND2
        port (in1, in2: in std_logic; out1: out std_logic);
 end component;
 -- OR2 declaration
  component myOR2
       port (in1, in2: in std_logic; out1: out std_logic);
 end component;
  --NOT1 declaration
  component myNOT1           
       port (in1: in std_logic; out1: out std_logic);
 end component;
end package basic_components;

library ieee;
use ieee.std_logic_1164.all;

 -- 2 input AND gate
 entity myAND2 is

       port (in1, in2: in std_logic; out1: out std_logic);
 end myAND2;
 architecture model_conc of myAND2 is
       begin

                 out1 &lt;= in1 and in2;
 end model_conc;
  -- 2 input OR gate
library ieee;
use ieee.std_logic_1164.all;
  entity myOR2 is

       port (in1, in2: in std_logic; out1: out std_logic);
 end myOR2;
 architecture model_conc2 of myOR2 is
       begin

                 out1 &lt;= in1 or in2;
 end model_conc2;
  -- 1 input NOT gate
library ieee;
use ieee.std_logic_1164.all;
  entity myNOT1 is

       port (in1: in std_logic; out1: out std_logic);
 end myNOT1;
 architecture model_conc3 of myNOT1 is
       begin

                 out1 &lt;= not in1;
 end model_conc3;


problem1.vhd:

    library ieee, basic_components;
use ieee.std_logic_1164.all;
use work.basic_components.all;
entity Problem1 is
    port (x1, x2, x3,x4,x5: in std_logic;
    f,g: out std_logic);
end Problem1;

architecture structural of Problem1 is
signal not_x1,not_x2,not_x3,not_x4,not_x5,pos1,pos2,pos3,pos4,pos5,pos6,pos7,pos8,pos9: std_logic;

begin

I0: myNOT1 port map(x1,not_x1);
I1: myNOT1 port map(x2,not_x2);
I2: myNOT1 port map(x3,not_x3);
I3: myNOT1 port map(x4,not_x4);
I4: myNOT1 port map(x5,not_x5);
I5: myOR2 port map(x2,not_x4,pos1);
I6: myOR2 port map(x3,x5,pos2);
I7: myOR2 port map(not_x4,x5,pos3);
I8: myOR2 port map(not_x1,x2,pos4);
I9: myOR3 port map(not_x2,x4,not_x5,pos5);
I10: myOR3 port map(not_x2,not_x4,not_x5,pos6);
I11: myOR3 port map(x2,not_x3,not_x4,pos7);
I12: myOR3 port map(not_x1,x2,not_x5,pos8);
I13: myOR4 port map(not_x1,not_x3,not_x4,x5,pos9);
I14: myAND5 port map(pos1,pos2,pos3,pos4,pos5,f);
I15:myAND5 port map(pos5,pos6,pos7,pos8,pos9,g);

end structural;
","As the comments in your post say, this way of writing VHDL is not ""practical"". But you can write your equations in a better way and compile/simulate both results at the same time to compare.

library ieee, basic_components;
  use ieee.std_logic_1164.all;
  use work.basic_components.all;

entity Problem1 is
    port (x1, x2, x3,x4,x5: in std_logic;
    f,g: out std_logic);
end Problem1;

architecture structural of Problem1 is
signal not_x1,not_x2,not_x3,not_x4,not_x5,pos1,pos2,pos3,pos4,pos5,pos6,pos7,pos8,pos9,f1,f2,g1,g2: std_logic;

begin
-- First equations the way VHDL is meaned to be used
f1 &lt;= (x3 or x5) and (x2 or not x4) and (not x4 or x5) and (not x1 or x2) and (not x2 or x4 or not x5);
g1 &lt;= (x2 or not x4 or not x5) and (x2 or not x3 or not x4) and (not x2 or x4 or not x5) and (not x1 or x2 or not x5) and (x1 or not x3 or not x4 or not x5);

-- Second equations, your school problem
I0: myNOT1 port map(x1,not_x1);
I1: myNOT1 port map(x2,not_x2);
I2: myNOT1 port map(x3,not_x3);
I3: myNOT1 port map(x4,not_x4);
I4: myNOT1 port map(x5,not_x5);
I5: myOR2 port map(x2,not_x4,pos1);
I6: myOR2 port map(x3,x5,pos2);
I7: myOR2 port map(not_x4,x5,pos3);
I8: myOR2 port map(not_x1,x2,pos4);
I9: myOR3 port map(not_x2,x4,not_x5,pos5);
I10: myOR3 port map(not_x2,not_x4,not_x5,pos6);
I11: myOR3 port map(x2,not_x3,not_x4,pos7);
I12: myOR3 port map(not_x1,x2,not_x5,pos8);
I13: myOR4 port map(not_x1,not_x3,not_x4,x5,pos9);
I14: myAND5 port map(pos1,pos2,pos3,pos4,pos5,f2);  -- Here, f is replaced by f2 
I15:myAND5 port map(pos5,pos6,pos7,pos8,pos9,g2);  -- Here, g is replaced by g2 

-- process for auto-test
process(f1,f2,g1,g2)
begin
  -- this will test the equation f1=f2, if wrong the simulator will stop with the message ""F calcul is wrong""
  assert (f1 = f2) report ""F calcul is wrong"" severity failure;
  -- this will test the equation g1=g2, if wrong the simulator will stop with the message ""G calcul is wrong""
  assert (g1 = g2) report ""G calcul is wrong"" severity failure;
end process;

-- output is linked to your school solution
f &lt;= f2;
g &lt;= g2;

end architecture;


Now you have to write a testbench to give the 32 possible inputs to your entity and see if the simulator complains about anything.",,,,,
VHDL simulation hangs even though it shows no error,"I'm new to VHDL language and right now I'm trying to make a controlable stepper motor. It should be something like this (I actually got this picture from my code with Tina)

And this is my code: 

LIBRARY ieee;                
USE ieee.std_logic_1164.ALL;            
USE ieee.std_logic_signed.ALL;         
ENTITY state_stepper_halfstep IS         
PORT(clk, plus, minus, start: IN    STD_LOGIC;
     q0,q1,q2,q3: OUT STD_LOGIC;
         a7,b7,c7,d7,e7,f7,g7,h7: OUT std_logic);
END state_stepper_halfstep;

ARCHITECTURE arc OF state_stepper_halfstep IS
    TYPE state_type IS (s0, s1, s2, s3, s4, s5, s6, s7);
    SIGNAL state: state_type;
        SIGNAL q: STD_LOGIC_VECTOR(3 downto 0);
        SIGNAL counter: integer range 0 to 21 :=11;
        SIGNAL digit: std_logic_vector (7 downto 0);
BEGIN

PROCESS (plus, minus, start, clk)
BEGIN 

IF rising_edge(plus) THEN  --  + Rotation value
    counter &lt;= counter+1;
    IF counter &gt; 20 THEN
        counter &lt;= 20;
    END IF; 

ELSIF rising_edge(minus) THEN  --  - Rotation Value
    counter &lt;= counter-1;
    IF counter &lt; 2 THEN
        counter &lt;= 2;
    END IF;
END IF;

    IF start = '1' THEN
        IF counter &gt; 11 THEN  -- When value &gt; 0
            WHILE counter &gt; 11 LOOP  -- Clockwise looping
                EXIT WHEN counter = 11;
                IF rising_edge(clk) THEN        -- Clockwise Steps
                    CASE state IS
                        WHEN s0 =&gt; state &lt;= s1;
                        WHEN s1 =&gt; state &lt;= s2;
                        WHEN s2 =&gt; state &lt;= s3;
                        WHEN s3 =&gt; state &lt;= s4;
                        WHEN s4 =&gt; state &lt;= s5;
                        WHEN s5 =&gt; state &lt;= s6;
                        WHEN s6 =&gt; state &lt;= s7;
                                   counter &lt;= counter-1;
                        WHEN s7 =&gt; state &lt;= s0;
                    END CASE;
                END IF;
            END LOOP;

        ELSIF counter &lt; 11 THEN  -- When value &lt; 0
            WHILE counter &lt; 11 LOOP -- Counter-clockwise looping
                EXIT WHEN counter = 11;             
                IF rising_edge(clk) THEN        -- Counter-clockwise Steps
                    CASE state IS
                        WHEN s0 =&gt; state &lt;= s7;
                        WHEN s7 =&gt; state &lt;= s6;
                        WHEN s6 =&gt; state &lt;= s5;
                        WHEN s5 =&gt; state &lt;= s4;
                        WHEN s4 =&gt; state &lt;= s3;
                        WHEN s3 =&gt; state &lt;= s2;
                        WHEN s2 =&gt; state &lt;= s1;
                                   counter &lt;= counter+1;
                        WHEN s1 =&gt; state &lt;= s0;
                    END CASE;
                END IF;
            END LOOP;

        ELSIF counter = 11 THEN -- When value = 0
            counter &lt;= counter;

        END IF;

    ELSE state &lt;= state;

    END IF;

END PROCESS;

WITH state SELECT
    q   &lt;=  ""0001""  WHEN    s0,
            ""0011""  WHEN    s1,
            ""0010""  WHEN    s2,
            ""0110""  WHEN    s3,
            ""0100""  WHEN    s4,
            ""1100""  WHEN    s5,
            ""1000""  WHEN    s6,
            ""1001""  WHEN    s7;

q0 &lt;= q(0);
q1 &lt;= q(1);
q2 &lt;= q(2);
q3 &lt;= q(3);

    with counter select
digit&lt;= ""11000000"" when 11,
    ""11111001"" when 12,
    ""10100100"" when 13,
    ""10110000"" when 14,
    ""10011001"" when 15,
    ""10010010"" when 16,
    ""10000010"" when 17,
    ""11111000"" when 18,
    ""10000000"" when 19,
    ""10010000"" when 20,
    ""01111001"" when 10,
    ""00100100"" when 9,
    ""00110000"" when 8,
    ""00011001"" when 7,
    ""00010010"" when 6,
    ""00000010"" when 5,
    ""01111000"" when 4,
    ""00000000"" when 3,
    ""00010000"" when 2;
    a7 &lt;= digit(0);
b7 &lt;= digit(1);
c7 &lt;= digit(2);
d7 &lt;= digit(3);
e7 &lt;= digit(4);
f7 &lt;= digit(5);
g7 &lt;= digit(6);
h7 &lt;= digit(7);
END arc;



This how it actually should work: 
    1. I can choose how many times the stepper motor (indicated with LEDs) will rotate with the ""plus"" and ""minus"" switches (it can counts from -9 to 9)
    2. The 7 segment's dot is a negative sign for the number shown in the display 
    3. Postive value will make the motor rotate in clockwise direction 
    4. Negative value (shown with dot in 7 segments) will make the motor rotate in counter-clockwise direction 
    5. Everytime the motor completes 1 rotation, the 7 segments number should be reduced by 1 number 
    6. Stepper motor will only start to rotate if I start it (with giving a high logic to ""start"" input)


Problem occurs whenever I'm trying to simulate the circuit and hit ""start"". Tina will just go hang and then ""Not Responding"". To be honest, I'm not sure about what mistake I've made in my code because Tina shows no error whenever I try to ""Enter New Macro"" with my VHDL code.


My best guess is I've made mistake in my looping command

    IF start = '1' THEN
        IF counter &gt; 11 THEN  -- When value &gt; 0
            WHILE counter &gt; 11 LOOP  -- Clockwise looping
                EXIT WHEN counter = 11;
                IF rising_edge(clk) THEN        -- Clockwise Steps
                    CASE state IS
                        WHEN s0 =&gt; state &lt;= s1;
                        WHEN s1 =&gt; state &lt;= s2;
                        WHEN s2 =&gt; state &lt;= s3;
                        WHEN s3 =&gt; state &lt;= s4;
                        WHEN s4 =&gt; state &lt;= s5;
                        WHEN s5 =&gt; state &lt;= s6;
                        WHEN s6 =&gt; state &lt;= s7;
                                   counter &lt;= counter-1;
                        WHEN s7 =&gt; state &lt;= s0;
                    END CASE;
                END IF;
            END LOOP;

        ELSIF counter &lt; 11 THEN  -- When value &lt; 0
            WHILE counter &lt; 11 LOOP -- Counter-clockwise looping
                EXIT WHEN counter = 11;             
                IF rising_edge(clk) THEN        -- Counter-clockwise Steps
                    CASE state IS
                        WHEN s0 =&gt; state &lt;= s7;
                        WHEN s7 =&gt; state &lt;= s6;
                        WHEN s6 =&gt; state &lt;= s5;
                        WHEN s5 =&gt; state &lt;= s4;
                        WHEN s4 =&gt; state &lt;= s3;
                        WHEN s3 =&gt; state &lt;= s2;
                        WHEN s2 =&gt; state &lt;= s1;
                                   counter &lt;= counter+1;
                        WHEN s1 =&gt; state &lt;= s0;
                    END CASE;
                END IF;
            END LOOP;



I would really glad if someone could point out the mistake. Thank you in advance and have a good day!","What you are trying to achieve is a direct port from a computer language to VHDL. HDLs don't work this way and you'll have to shift your paradigm if you want to achieve this design. Here are a few tips:


The description of your entity and architecture seem ok
The main process' sensitivity list shows that you expect it to run ""step by step"", like thread but that cannot be done this way in HDL for synthesis. The model for hardware design description is that a process is run once throughout for each time there is an event on the signals listed in the sensivity list. The process cannot block while waiting for further events. If your sensitivity list signals are tested for values, that means that your process is combinatorial (pure logic). It's not what you intend to get (you have a clk signal). So your process should only have one signal in its sensitivity list: clk. After that, your process body can start with a unique IF rising_edge(clk) THEN that clearly indicates a clocked process.
Clocked processes don't manage data passed the present clock cycle, so you have to think of the states you want to save from one cycle to the next and drive them as signals.
Signals are exotic beasts compared to variables and you need to understand how they work with respect to events and time. For instance counter &lt;= counter; is useless.
The textual specification of behaviour of your system looks like the description of state machine. Why not refine it formally and flesh it out as a state of your system? See a simple example here
Generally, for synthesis, you need a kind of reset signal to be sure all your states are initialized by hardware.
",,,,,
Dynamic Arrray Size in VHDL,"I want to use dynamic range of array , so using ""N"" for converting an incoming vector signal to integer.  Using the specifc incoming port ""Size"" gives me an error, while fixed vector produces perfect output.

architecture EXAMPLE of Computation is

signal size :std_logic_vector (7 downto 0);

process (ACLK, SLAVE_ARESETN) is

variable N: integer:=conv_integer  (""00000111"") ;  ---WORKING

--variable N: integer:=conv_integer  (size) ; -- Not working
type memory is array (N downto 0 ) of std_logic_vector (31 downto 0 ); 

variable RAM :memory; 


Only reason to do this type of coding is send as much data as possible to FPGA .As I need to send Data from DDR to Custom IP via DMA in vivado may be more than 100 MB. so kindly guide me if I am trying to implement in wrong way as stated above. ","You can't do that in VHDL. What kind of hardware would be generated by your code? If you don't know, the synthesizer won't either.

The way to do this kind of thing is to set N to the largest value you want to support, and use size in your logic to control your logic appropriately. It's difficult to give more pointers without more information, but as an example, you could use a counter to address your ram, and have it reset when it's greater than size.

Update

Here's a counter example. You have to make sure that size doesn't change while operating or it will fall into an unknown state. A real design should have reset states to ensure correct behaviour.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity example is
port (
    clk : std_logic;
    rst : in std_logic;
    size : in unsigned(7 downto 0);
    wr : in std_logic;
    din : in std_logic_vector(31 downto 0)
);
end entity;

architecture rtl of example is
    signal counter : unsigned(7 downto 0);

    type ram_t is array(0 to 255) of std_logic_vector(31 downto 0);
    signal ram : ram_t;
begin

    RAM_WR: process(clk)
    begin
        if rising_edge(clk) then
            if rst = '1' then
                counter &lt;= (others =&gt; '0');
            else
                if wr = '1' then
                    ram(to_integer(counter)) &lt;= din;

                    if counter = size then
                        counter &lt;= (others =&gt; '0');
                    else
                        counter &lt;= counter + 1;
                    end if;
                end if;
            end if;
        end if;
    end process RAM_WR;

end architecture rtl;
",,,,,
How to get source of a sampled bin in Coverage in QuestaSIM,"I'm using QuestaSIM and have a merged coverage report from regression.

From my merged coverage report, how can I trace a sampled bin back to its simulation (test name &amp; seed value)?","Well I have found out the answer of the question, so here I am posting it.

In QuestaSIM, while merging the coverage a flag can be used for the same purpose.

vcover merge -testassociated  

This flag will keep an eye on each test's contribution to the coverage. So after merged coverage report, while opening it in questa, again one flag can be used for getting that, which bins were hit by which tests.

vsim -coverage -cvgbintstamp 

So in the coverage report, on any bin, just right click and select ""Find Tests that hit"". So you will have list of tests, which have hit that particular bin.",,,,,
Behavioral into FlipFlop Structural,"In this code, when reset equals 1 the s becomes 1000 and when reset equals 0 the s becomes 0100 then 0010 then 0001 and it starts all over again with 1000 as the start value, only if the clock is up.

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.std_logic_unsigned.all; 


entity clock_behav is
  port (clock  : in  std_logic;
          reset   : in  std_logic;
          s  : out std_logic_vector (3 downto 0));
end clock_behav;

architecture behav of clock_behav is
begin
process(clock,reset)
variable shift_counter: integer := 0;
begin
if (reset='1') then
    s&lt;=""1000"";
    shift_counter := 1;
else
    if(clock'event and clock='1') then
        if(shift_counter =1) then
            s&lt;=""0100"";
            shift_counter := 2;
        elsif(shift_counter =2) then
            s&lt;=""0010"";
            shift_counter := 3;
        elsif(shift_counter =3) then
            s&lt;=""0001"";
            shift_counter := 0;
        else
            s&lt;=""1000"";
            shift_counter := 1;
        end if;
    end if;

end if;
end process;
end behav;


I want to create this 
 
With FlipFlops as you can see, one Set and 3 Reset. But, I struggle to move from behavioral into structural, because in VHDL we can't have in process port maps. Of course I tried many things, as you can see below, but it's impossible to recreate it with flipflops if the port maps are not inside the process. As you can clearly understand , my knowledge about VHDL it's not that great. Also, I want you to tell me if I did right when I changed the flipflop D and Q types, it was std_logic and I changed it to std_logic_vector . I did this for the purpose of this exercise.

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.std_logic_unsigned.all; 


entity clock_structural is
  port (clock  : in  std_logic;
          reset   : in  std_logic;
          s  : out std_logic_vector (3 downto 0));
end clock_structural;


architecture behavior of clock_structural is
signal t,t1,t2,t3 : std_logic_vector (3 downto 0);
component flipflop_new
port
 (D : in std_logic_vector (3 downto 0);
 CLK : in std_logic;
 CLR : in std_logic;
 Q : out std_logic_vector (3 downto 0));
end component;

component flipflop_set
port
 (D_s : in std_logic_vector (3 downto 0);
 CLK_s : in std_logic;
 CLR_s : in std_logic;
 Q_s : out std_logic_vector (3 downto 0));
end component;
begin
process(clock,reset)
variable shift_counter: integer := 0;
begin
if (reset='1') then
    t&lt;=""1000"";  

    shift_counter := 1;
else
    if(clock'event and clock='1') then
        if(shift_counter =1) then
            shift_counter := 2;
        elsif(shift_counter =2) then
            shift_counter := 3;
        elsif(shift_counter =3) then
            shift_counter := 0;
        else
            shift_counter := 1;
        end if;
end if;

end if;

end process;

FFS1: flipflop_set port map(t,clock,reset,t1);
s&lt;=t1;
FFR1: flipflop_new port map(t1,clock, reset,t2);
s&lt;=t2;
FFR2: flipflop_new port map(t2,clock, reset,t3);
s&lt;=t3;
FFR3: flipflop_new port map(t3,clock, reset,s);

end behavior ;



library IEEE;
use IEEE.std_logic_1164.all;
use ieee.std_logic_unsigned.all; 

entity flipflop_new is
 port ( D : in std_logic_vector (3 downto 0);
 CLK : in std_logic;
 CLR : in std_logic;
 Q : out std_logic_vector (3 downto 0)
 );
end flipflop_new; 


architecture behavior of flipflop_new is
begin
process(CLK)
begin
if CLR='0' then null;
elsif RISING_EDGE(CLK) then
Q &lt;= D;
end if;
end process ;
end behavior ;

library IEEE;
use IEEE.std_logic_1164.all;
use ieee.std_logic_unsigned.all; 

entity flipflop_set is
 port ( D_s : in std_logic_vector (3 downto 0);
 CLK_s : in std_logic;
 CLR_s : in std_logic;
 Q_s : out std_logic_vector (3 downto 0)
 );
end flipflop_set; 


architecture behavior of flipflop_set is
begin
process(CLK_s)
begin
if CLR_s='1' then null;
elsif RISING_EDGE(CLK_s) then
Q_s &lt;= D_s;
end if;
end process ;
end behavior ;
","There are several things to change or improve. A structural VHDL model should describe your schematic, which you don't really do.

First, why do you have shift_counter in your structural? You don't need that process.

Second, you instantiate 4 of your flip-flop entity which are each 4 bits wide, while your schematic's has 4 flip-flops. Basically, you instantiate a total of 16 registers when you need 4. Why is your flip-flop model 4 bits wide? It should be a single bit.

Third, look at your flip-flop description:

process(CLK)
begin
    if CLR='0' then
        null;
    elsif RISING_EDGE(CLK) then
        Q &lt;= D;
    end if;
end process ;


Does it seems what a flip-flop do? The Q &lt;= D when the clock rises is fine, but does nothing happens when the clr of the flip-flop is active? Your output should reset/set in that case, which is not what your VHDL describe.

Another error is that you assign your output s 3 times. s must be assigned once, but you can assign bit individually like s(0) &lt;= t1.

Finally, you don't describe the feedback. The output of your last flip-flop is s, while the input of the first flip-flop is t. From your schematic, they should be connected together.",,,,,
Is it possible to simplify this IF conditional statement in Verilog?,"I'm was trying to create a binary counter, but when I simplified the IF statement, it stopped to work.

This code works: 

if(counter&lt;500000)
    counter&lt;=counter+1;
else
    counter&lt;=0;
if (counter==0)
    if(LEDR&lt;262143)
        LEDR &lt;= LEDR+1;
    else
        LEDR&lt;=0;


this doesn't : 

if(counter&lt;500000)
    counter&lt;=counter+1;
else
    counter&lt;=0;
if (counter==0 &amp;&amp; LEDR&lt;262143)
    LEDR &lt;= LEDR+1;
else
    LEDR&lt;=0;
","The two versions of your code are not equivalent.

In your original version, the else part is contained inside the counter == 0 condition, and will be executed when counter == 0 and LEDR &gt;= 262143:

if (counter==0)
    if(LEDR&lt;262143)
        LEDR &lt;= LEDR+1;
    else // counter must be 0 here
        LEDR&lt;=0;


In the ""simplified"" version, the else part will be executed when the opposite of counter == 0 &amp;&amp; LEDR &lt; 262143 is true, which is the case if counter != 0 or LEDR &gt;= 262143.

if (counter==0 &amp;&amp; LEDR&lt;262143)
    LEDR &lt;= LEDR+1;
else // counter could be different from 0
    LEDR&lt;=0;


You can visualize the difference by listing all possible combinations in a table:

counter == 0 | LEDR &lt; 262143 | LEDR &lt;= 0 executed | LEDR &lt;= LEDR+1 executed
             |               | orig.    new       | orig.    new
-------------+---------------+--------------------+------------------------
false        | false         | no      *yes*      | no       no
false        | true          | no      *yes*      | no       no
true         | false         | yes      yes       | no       no
true         | true          | no       no        | yes      yes


As you can see, the new version behaves differently when counter != 0.

Actually, it is not possible to simplify the desired behaviour to a single if-else statement, because this would mean that you can only distinguish between the two cases of executing either LEDR &lt;= LEDR + 1 or LEDR &lt;= 0. But in the original code there is a third case (when counter != 0) where you execute nothing at all and leave LEDR untouched.",,,,,
How can i instantiate a module inside an if statement in verilog?,"if (btn[0] == 1)
    begin
        operaciones op(A,B,numop,C);
        display disp(C,led);
    end


I need to instantiate it inside this if, how can i do that?","Before you go and use a generate statement for this (which allows module instantiation inside an if statement), you need to consider what you are saying. From what it appears you are trying to do in your code snippet, when button 0 is pressed, you want to do some operation and display the result on the LEDs. However, you are treating modules like function calls when they are something very different.

Module instantiations are declarations that the module hardware exists within its parent module. So, when I have something like this:

module top;

  module_name instances_name( ... );

endmodule


I declare that a module_name (all the hardware of module_name) exists within top (which probably has more hardware). Think of modules as ICs and the parent module as a breadboard, instantiating that module is like putting that IC down on the breadboard with the port connections being your wires to each pin of that IC. All the ICs necesary to do anything that design does exist on in the circuit somewhere; they dont appear and disappear depending on what the user inputs.

Now think back to what you wanted to say: you are saying, when buttton 0 is pressed, put this IC on the breadboard. If not pressed, take it away. As ICs dont appear and disappear from a circuit board, this doesnt make sense. So you need to treat module instantiations the same way you'd treat ICs if you were building the design on a breadboard; you can declare there is hardware to preform this operation (put down and wire up the IC), and when botton 0 is pressed, route the output from that hardware to the LEDs (using another IC or small circuit to do the routing; think mux).",,,,,
LATCH Primitive disables outputs?,"So I understand the concept of a latch, but I'm not seeing how I am inferring one here as my else condition should cover all the possible paths through this process. Quartus is telling me it is disabling the greenLEDS and redLEDs because of LATCH primitive, as well as there is an inferred latch on them. Am I missing something here?

process(current,advance,playerWins,dealerWins) begin
  if(advance) then
        case current is
          when START =&gt;
                deal           &lt;= '1';
                dealTo         &lt;= '1';
                dealToCardSlot &lt;= ""00"";
                greenLeds &lt;= (others =&gt; '0');
                redLeds &lt;= (others =&gt; '0');
          when PT1 =&gt;
                deal           &lt;= '1';
                dealTo         &lt;= '1';
                dealToCardSlot &lt;= ""01"";
                greenLeds &lt;= (others =&gt; '0');
                redLeds &lt;= (others =&gt; '0');
          when DT1 =&gt;
                deal           &lt;= '1';
                dealTo         &lt;= '0';
                dealToCardSlot &lt;= ""00"";
                greenLeds &lt;= (others =&gt; '0');
                redLeds &lt;= (others =&gt; '0');
          when PT2 =&gt;
                deal           &lt;= '1';
                dealTo         &lt;= '1';
                dealToCardSlot &lt;= ""10"";
                greenLeds &lt;= (others =&gt; '0');
                redLeds &lt;= (others =&gt; '0');
          when PT3 =&gt;
                deal           &lt;= '1';
                dealTo         &lt;= '1';
                dealToCardSlot &lt;= ""11"";
                greenLeds &lt;= (others =&gt; '0');
                redLeds &lt;= (others =&gt; '0');
          when DT2 =&gt;
                deal           &lt;= '1';
                dealTo         &lt;= '0';
                dealToCardSlot &lt;= ""01"";
                greenLeds &lt;= (others =&gt; '0');
                redLeds &lt;= (others =&gt; '0');
          when DT3 =&gt;
                deal           &lt;= '1';
                dealTo         &lt;= '0';
                dealToCardSlot &lt;= ""10"";
                greenLeds &lt;= (others =&gt; '0');
                redLeds &lt;= (others =&gt; '0');
          when DT4 =&gt;
                deal           &lt;= '1';
                dealTo         &lt;= '0';
                dealToCardSlot &lt;= ""11"";
                greenLeds &lt;= (others =&gt; '0');
                redLeds &lt;= (others =&gt; '0');
          when WIN =&gt;
                deal           &lt;= '0';
                dealTo         &lt;= '0';
                dealToCardSlot &lt;= ""00"";
                if(playerWins) then
                    greenLeds &lt;= (others =&gt; '1');
                elsif(dealerWins) then
                    redLeds &lt;= (others =&gt; '1');
                else
                    greenLeds &lt;= (others =&gt; '0');
                    redLeds &lt;= (others =&gt; '0');
                end if;
          when ENDGAME =&gt;
                deal           &lt;= '0';
                dealTo         &lt;= '1';
                dealToCardSlot &lt;= ""00"";
                greenLeds &lt;= (others =&gt; '0');
                redLeds &lt;= (others =&gt; '0');
          when others =&gt;
                deal           &lt;= '0';
                dealTo         &lt;= '0';
                dealToCardSlot &lt;= ""00"";
                greenLeds &lt;= (others =&gt; '0');
                redLeds &lt;= (others =&gt; '0');
          end case;
  else
    deal           &lt;= '0';
    dealTo         &lt;= '0';
    dealToCardSlot &lt;= ""00"";
    greenLeds &lt;= (others =&gt; '0');
    redLeds &lt;= (others =&gt; '0');
  end if;
end process;
","      when WIN =&gt;
            deal           &lt;= '0';
            dealTo         &lt;= '0';
            dealToCardSlot &lt;= ""00"";
            if(playerWins) then
                greenLeds &lt;= (others =&gt; '1');
            elsif(dealerWins) then
                redLeds &lt;= (others =&gt; '1');
            else
                greenLeds &lt;= (others =&gt; '0');
                redLeds &lt;= (others =&gt; '0');
            end if;


You do not assign redLeds if playerWins is false and dealerWins is true. Likewise, you do not assign greenLeds if playerWins is true.",,,,,
Correct arithmetic(cycle) shift in verilog,"I'm new to verilog and am stuck on one curious moment. I'm trying to do a cycled leds blinking(green lights from left to right and red ones from right to left). I have 12 leds and am synchronizing my program with clock(CLK). 

I wanted to use arithmetic shift for this, but for some reason &lt;&lt;&lt; and &gt;&gt;&gt; behave like &lt;&lt; and &gt;&gt;, so the shift is not cyclic. Why is this so? Am I doing something wrong?

I'm putting the whole code just in case it's necessary, its very short:

module test1(
  input CLK,
  output [11:0] MLED 
); 
reg [11:0] tmp; 
reg [11:0] tmpred;
reg [11:0] tmpgreen;
assign MLED = tmp; 
reg [1:0] COUNTER;
wire [1:0] COUNTER_WIRE;  
assign COUNTER_WIRE=COUNTER; 

wire  LOG; 
assign LOG=(COUNTER_WIRE==2'd3) ? 1'b1 : 1'b0;  

initial 
  begin 
    tmp&lt;=12'b100000000001;
    tmpred&lt;=12'b000000000001;
    tmpgreen&lt;=12'b100000000000;
  COUNTER&lt;=0; 
  end 

always@(posedge CLK) 
  begin 
    if (LOG) 
      begin 
        tmpred &lt;= $signed(tmpred) &lt;&lt;&lt; 2;
        tmpgreen &lt;= $signed(tmpgreen) &gt;&gt;&gt; 2;
        tmp &lt;= tmpred | tmpgreen;
      end 
    COUNTER &lt;= COUNTER + 1'b1; 
  end 
endmodule 
","&lt;&lt;&lt; and &gt;&gt;&gt; are signed shift operators - ie 0xF0 &gt;&gt;&gt; 1 = 0xF8 vs 0xF0 &gt;&gt; 1 = 0x78. Right shifting will beahve differently, but the &lt;&lt;&lt; will be the same as &lt;&lt;.

To do a cyclic right shift, use tempred &lt;= {tempred[0],tempred[11:1]}; instead.",,,,,
The differences between 5 behavioral model for OR gate,"I want to design 5 behavioral model for OR gate. What is the difference between these models? Each of models implement which of delays (inertial delay and transport delay) and what is the reason?

Model 1: LHS blocking

#4 O = (A | B);


Model 2: LHS non-blocking

#4 O &lt;= (A | B);


Model 3: RHS blocking

O = #4 (A | B);


Model 4: RHS non-blocking

O &lt;= #4 (A | B);


Model 5: Continuous assignment

assign #4 O = (A | B);
","There is a very good paper ""Correct Methods For Adding Delays To Verilog Behavioral Models"" by Clifford E. Cummings, where you can find some hints about using different delay models in Verilog:


Blocking assignment delay models:


  Modeling Guideline: do not place delays on the LHS of
  blocking assignments to model combinational logic. This
  is a bad coding style.
  Testbench Guideline: placing delays on the LHS of
  blocking assignments in a testbench is reasonable since
  the delay is just being used to time-space sequential input
  stimulus events.

RHS blocking delays:


  Modeling Guideline: do not place delays on the RHS of
  blocking assignments to model combinational logic. This
  is a bad coding style.
  Testbench Guideline: do not place delays on the RHS of
  blocking assignments in a testbench.
  General Guideline: placing a delay on the RHS of any
  blocking assignment is both confusing and a poor coding
  style. This Verilog coding practice should be avoided.

Nonblocking assignment delay models:


  Modeling Guideline: do not place delays on the LHS of
  nonblocking assignments to model combinational logic.
  This is a bad coding style.
  Testbench Guideline: nonblocking assignments are less
  efficient to simulate than blocking assignments; therefore,
  in general, placing delays on the LHS of nonblocking
  assignments for either modeling or testbench generation is
  discouraged.

RHS nonblocking delays:


  Recommended Application: Use this coding style to
  model behavioral delay-line logic.
  Modeling Guideline: place delays on the RHS of
  nonblocking assignments only when trying to model
  transport output-propagation behavior. This coding style
  will accurately model delay lines and combinational logic
  with pure transport delays; however, this coding style
  generally causes slower simulations.
  Testbench Guideline: This coding style is often used in
  testbenches when stimulus must be scheduled on future
  clock edges or after a set delay, while not blocking the
  assignment of subsequent stimulus events in the same
  procedural block.

Continuous assignment delay models:


  RHS delay model is illegal with continuous assignment




Models mentioned earlier model following delays:


Adding delays to continuous assignments accurately models combinational logic with inertial delays.
Adding delays to the right hand side (RHS) of nonblocking assignments will accurately model combinational logic with transport
delays.
",,,,,
Random Generator using UNIFORM,"I am trying to generate a random number for a little game and I tried to use the UNIFORM function from the package MATH_REAL.

I get a value when I test my code, but it never changes. I tried to make the code happen at every rising_edge but it didn't change anything. I couldn't find or think of an effective fix.

I think I know that problem is simply that my random number is generated only once, but I couldn't figure out a way to change this.

Here is what I implemented (my variation with the clock) :

    rand: process (count1) 
        variable seed1, seed2 : positive;
        variable rand : real;
        variable int_rand : integer range 1 to 5;
    begin
        if rst_i='1' then
            count1 &lt;= 1;
        elsif rising_edge(clk_i) then
            UNIFORM(seed1, seed2, rand);
            int_rand := INTEGER(TRUNC(rand*5.0));
            count1 &lt;= int_rand;
        end if;
    end process;


The value of count1 is then used in another process. The above code gives the same simulation results as simply :

    rand: process (count1) 
        variable seed1, seed2 : positive;
        variable rand : real;
        variable int_rand : integer range 1 to 5;
    begin
        UNIFORM(seed1, seed2, rand);
        int_rand := INTEGER(TRUNC(rand*5.0));
        count1 &lt;= int_rand;
    end process;


Is there a simple way to ensure more that a random number is generated more than once?","When the purpose is to generate a random number on count1 for every rising edge of clk_i, then update the sensitivity list for the process to (assuming async reset by rst_i):

rand: process (rst_i, clk_i)


This will make the process reexecute at every change of rst_i or clk_i, where the sensitivity list of count1 reexecutes at change of count1 only.

Note that variable int_rand : integer range 1 to 5; should be range 0 to 4, since uniform result is > 0.0 and &lt; 1.0.

An interesting behavior is, that a sensitivity list of rand: process (count1) as for the second process, without the if guarding generation on count1, will actually make the process reexecute several times start of simulation, until the generated count1 value is identical to the previous count1 value, in which case the is no change on count1 to trigger reexecution of the process, and then process is then not executed any more.",,,,,
Dynamic Coverpoints in Coverage Systemverilog,"class conf;
  typedef struct packed
  {
    int ns_size;
    int limit;
  } ns;

  int num_ns_supported;
  ns num_ns[];

  function new(input int s=5);     
    num_ns_supported = s;
    num_ns = new[s];
    foreach(num_ns[i])
    begin
      num_ns[i].ns_size = (1000 * (i+1));         
    end
  endfunction
endclass

class pac;
  int nsid=1;
  int slba;
endclass

class c;
  pac p;
  conf cfg;

  covergroup x;
    option.per_instance = 1;
    a : coverpoint p.slba
    {
      bins range[3] = {[32'h0000_0000 : cfg.num_ns[p.nsid-1].ns_size]};
    }
  endgroup

  function new(input conf ca);     
    p = new();
    cfg = ca;
    x = new();
  endfunction

  function void sample(input pac p1);
    p = p1;
    x.sample();
  endfunction
endclass

program p1;
  conf cfg = new(6);
  pac p = new();
  c co = new(cfg);

  initial
  begin
    p.nsid = 1;
    p.slba = 550;
    co.sample(p);
    p.nsid = 2;
    co.sample(p);
  end  
endprogram


In this code, I need to cover slba with ranges associated to the respected num_ns structure.

But in this code, ranges will be divided according to num_ns[0] only.

So how can I reuse same coverpoint to generate dynamic ranges depending upon the variable value on the sampling time?","What you are asking for cannot be done, nor does it make any sense. See https://verificationacademy.com/forums/coverage/how-get-values-different-bins-coverpoint",,,,,
Preventing Underflow and Overflow,"  module threshold(input[7:0] oLCD_R1,
                  input[7:0] oLCD_G1,
                  input[7:0] oLCD_B1,
                  input[7:0] Rcapture1,
                  input[7:0] Gcapture1,
                  input[7:0] Bcapture1,
                  input oDEN1,
                  output reg[7:0] oLCD_R2,
                  output reg[7:0] oLCD_G2,
                  output reg[7:0] oLCD_B2,
                  output oDEN2,
                  output  [7:0] Rlower,
                  output  [7:0] Rupper,
                  output  [7:0] Glower,
                  output  [7:0] Gupper,
                  output  [7:0] Blower,
                  output  [7:0] Bupper
                );
assign Rlower = Rcapture1;
assign Rupper = Rcapture;
assign oDEN2 = oDEN1;

always @(*)
begin
     if (Rcaputre1 &lt; 30)
     begin
     Rlower = 30;
     end
     if (Rcaputre1 &gt; 225)
       begin
       Rupper = 225;
      end
end 
  begin
  if (
      ( ( Rcapture1 - 30  &lt; oLCD_R1)  &amp;&amp;  (oLCD_R1 &lt; Rcapture1 + 30 ) ) &amp;&amp; 
      ( ( Gcapture1 - 30  &lt; oLCD_G1)  &amp;&amp;  (oLCD_G1 &lt; Gcapture1 + 30 ) ) &amp;&amp;
      ( ( Bcapture1 - 30  &lt; oLCD_B1)  &amp;&amp;  (oLCD_B1 &lt; Bcapture1 + 30 ) )
    )   

  begin
 oLCD_R2 = 255;
 oLCD_G2 = 192;
 oLCD_B2 = 0;
 end 
    else 
    begin   
     oLCD_R2 = oLCD_R1;
     oLCD_G2 = oLCD_G1;
     oLCD_B2 = oLCD_B1;
     end 
  end
 endmodule


i am trying to prevent underflow and overflow during subtraction and addition for my Rcapture but it appears that it cant work due to errors  of object 'Rlower' on left hand side of assignment must have a net type? i declare it as a output reg why do i still get this error for both Rlower and Rupper

so by changing the statement 

assign Rlower = Rcapture1 ? Rcapture1 &lt; 30  : Rlower == 30;
assign Rupper = Rcapture1 ? Rcapture1 &lt; 225 : Rupper == 225;

assign Glower = Gcapture1 ? Gcapture1 &lt; 30  : Glower == 30;
assign Gupper = Gcapture1 ? Gcapture1 &lt; 225 : Gupper == 225;

assign Blower = Bcapture1 ? Bcapture1 &lt; 30  : Blower == 30;
assign Bupper = Bcapture1 ? Bcapture1 &lt; 225 : Bupper == 225;


will this stop the underflow and overflow problem?","regs (and output regs) are assigned values in always blocks. Signals declared as a wire or output are considered to be ""net-type"", and they are assigned a value using an assign statement.

Either move Rlower into an always block, or remove the reg from the declaration. Same applies to Rupper.",,,,,
"""+ can not have such operands in this context."" error ( VHDL CODE)","
  
  can not have such operands in this context
  


Can someone tell me what is wrong and how to fix it please?

I tried to search the problem on the internet, why can't I add to STD_LOGIC_VECTOR and I didn't find anything that explains right my problem. So here I am asking you guys what's the problem?

entity Modes is
    Port ( RST : in  STD_LOGIC;
           CLK_33MHZ : in  STD_LOGIC;
           BTN : in  STD_LOGIC;
           LED : out  STD_LOGIC);
end Modes;

architecture Behavioral of Modes is

 signal ledstatus : STD_LOGIC;
 signal mode : STD_LOGIC_VECTOR(1 downto 0);
 signal modestatus : STD_LOGIC_VECTOR (1 downto 0);

begin 

 process(CLK_33MHZ,RST)

 variable cnt : integer range 0 to 33000000;

begin

 if(RST = '1') then
    cnt := 0;
    mode &lt;= ""00"";
    LED &lt;= '0';
    ledstatus &lt;= '0';
     elsif(rising_edge(CLK_33MHZ)) then
        if(BTN = '1') then
            elsif(mode = ""11"") then
                mode &lt;= ""00"";
                else
                **mode &lt;= mode + ""01"";** -- the problem in the code
            end if;
         if(mode = ""00"") then
            LED &lt;= '0';
            elsif(mode = ""01"") then
                LED &lt;= '1';
                 elsif(mode = ""10"") then
                if(cnt = 33000000) then
                   LED &lt;= not ledstatus;
                else
                   cnt := cnt + 1;
                end if;
             elsif(mode = ""11"") then
                if(cnt = 330000) then
                   LED &lt;= not ledstatus;
                else
                   cnt := cnt + 1;
                end if;
       end if;
 end if;
 LED &lt;= ledstatus; 

 end process;

end Behavioral;
","A std_logic_vector is just a vector of bits - it isn't necessarily a number.  The + operator has no meaning in this context.

You need to explicitly state that it is a number, in your case an unsigned number, and then convert it back to a std_logic_vector:

mode &lt;= std_logic_vector(unsigned(mode) + 1);


When mode is equal to 3, adding 1 will make it wrap back round to 0.

There are plenty of other issues with your code but this will fix that immediate synthesis error.",,,,,
Why do I get no output at my VHDL multiplier?,"I am trying to make a 4 bit multiplier. Here is my top level design:


And here are the two modules:



However when I try to simulate this I get no output. My testbench:

    ARCHITECTURE behavior OF sim3 IS 

    -- Component Declaration for the Unit Under Test (UUT)

    COMPONENT multiplicator
    PORT(
         a : IN  std_logic_vector(3 downto 0);
         b : IN  std_logic_vector(3 downto 0);
         reset : IN  std_logic;
         clk : IN  std_logic;
         start : IN  std_logic;
         prod : OUT  std_logic_vector(7 downto 0);
         ready : OUT  std_logic
        );
    END COMPONENT;


   --Inputs
   signal a : std_logic_vector(3 downto 0) := (others =&gt; '0');
   signal b : std_logic_vector(3 downto 0) := (others =&gt; '0');
   signal reset : std_logic := '0';
   signal clk : std_logic := '0';
   signal start : std_logic := '0';

    --Outputs
   signal prod : std_logic_vector(7 downto 0);
   signal ready : std_logic;

   -- Clock period definitions
   constant clk_period : time := 10 ns;

BEGIN

    -- Instantiate the Unit Under Test (UUT)
   uut: multiplicator PORT MAP (
          a =&gt; a,
          b =&gt; b,
          reset =&gt; reset,
          clk =&gt; clk,
          start =&gt; start,
          prod =&gt; prod,
          ready =&gt; ready
        );

   -- Clock process definitions
   clk_process :process
   begin
        clk &lt;= '0';
        wait for clk_period/2;
        clk &lt;= '1';
        wait for clk_period/2;
   end process;


   -- Stimulus process
   stim_proc: process
   begin        
        wait for clk_period;
        reset&lt;='1';
        wait for clk_period;
        reset&lt;='0';
        a&lt;=""0011"";
        b&lt;=""0010"";
        start &lt;='1';
        wait for clk_period*10;
   end process;

END;


When I am setting the start to '1' the simulation just stops. I don't know why. I get the folowing error:

ERROR: at 20 ns(10000): Iteration limit 10000 is reached. Possible zero delay oscillation detected where simulation can not advance in time because signals can not resolve to a stable value in File ""D:/faculta/PL II/multiplicator/reg8.vhd"" Line 45. Please correct this code in order to advance past the current simulation time.




I don't see what could be wrong at that line:

q_s &lt;= ""00000000"" WHEN reset='1' ELSE d WHEN reset='0' and load='1' ELSE q_s;


Some help please? ","Don't use a register with a load enable, use clock edge register. The iteration limit is a delta cycle limit in ISIM. Introducing a '1' in b you get a striking oscillator, a loop with delta cycle delays and inversion (the summing). Make num4, reg4 and reg8 clock edge driven with their loads as enables, this appears compatible with Lab10  which shows the use of a clock (and the VHDL source for @scary_jeff, albeit expressed in type BIT instead of std_logic). This feedback phenomenon is mentioned in William Kafig's book VHDL 101 Everything you need to know to get started,  in Chapter 4.

Google Translate helps.  No one ever seems to provide their handouts for their assignments.

If you look at the original implementation of assignment to q_s in reg4:

block1: 
    block (ck = '1' and not ck'stable)
    begin
        q_s &lt;= guarded ""0000"" when reset = '1' else
                           d  when reset = '0' and load = '1' else
                         q_s;
    end block block1;


I'd translate this into a synthesizable process statement instead of a block statement, making in clear reg4 (and reg8) is a clocked register:

block1: 
    process (ck)
    begin
        if rising_edge(ck) then 
            if reset = '1' then
                q_s &lt;= (others =&gt; '0');
            elsif load = '1' then
                q_s &lt;= d;
            end if;
        end if;
    end process;


The reason the original works is because a block statement can have a guard statement. 

The change makes it clear the q_s is a clocked register with a synchronous reset.

You also might note we no longer reference q_s and can assign q directly.

In the control state machine the process assigning next_state to current_state can likewise be updated:

    process (ck)
    begin
        if ck'event and ck = '1' then  -- or rising_edge(ck)
            current_state &lt;= next_state;
        end if;
    end process;


Simply for readability.  It's uncommon to use the form not ck'stable for signifying a clock event, noting you also appear to have missed the implication in implementing reg8, potentially in reg4 and automat as well.

The synthesis eligibility of a guarded expression as an edge sensitive clock is demonstrated in IEEE Std 1076.6-2004, 
6.1.3.6 Edge-sensitive storage using a guarded block.",,,,,
What is the difference between these verilog codes?,"I'm was following a tutorial to blink a led in my fpga.
These are the codes presented : 

1) 

module LED (    
    input      [17:0] SW,
    output reg [17:0] LEDR
);    
    assign led = switch;
endmodule


2) --------

module LED (    
    input [17:0] SW,
    output reg [17:0] LEDR
);
    always @(*)
        led = switch;
endmodule


3) ---------

module LED (        
    input CLOCK_50,
    input [17:0] SW,
    output reg [17:0] LEDR
);

    always @(posedge CLOCK_50)
        LEDR = SW;
endmodule
","Your first example uses continuous assignment to set the value of led to the value of switch. It's like connecting led and switch directly with a wire. Whenever switch changes, led also changes.

Your second example does the same thing but uses an always block. always blocks have a sensitivity list, which contains signals that will trigger the block to run. In this case, it's *, meaning that it triggers any time any of the signals in the blocks change. I believe this is identical to your first example. 

Your third example uses sequential logic to set LEDR to SW. In this case, the always block triggers only when the CLOCK_50 signal goes high from a non-high state. If CLOCK_50 never rises, LEDR is never set to any value.

By the way, I don't think your first or second examples are synthesizable. I think led and switch should be LEDR and SW.

These articles give a better description of the concepts in your examples:

Assignments : http://verilog.renerta.com/mobile/source/vrg00005.htm

Always Blocks: http://www.asic-world.com/verilog/verilog_one_day3.html",,,,,
Design 32 bit arithmetic logic unit (ALU),"I write this coder for an ALU. This ALU controlled with ctrl signals and do some works like add, subtract, and, or, ... When output is zero, oZero signals should be active.

I have some errors in marked lines. What is my mistake?

module ALU_32 (iA, iB ,iCin ,ctrl, oCarry,oZero, out);    
input [31:0] iA,iB;
output [31:0] out;
input iCin,ctrl;
output oCarry,oZero;
reg [31:0] out;
reg oCarry;
reg oZero;
always@ (ctrl)
    begin 
        case(ctrl)
            4'b0: out&lt;=iA&amp;iB;
            4'b0001: out&lt;=iA|iB;
            4'b0010: {oCarry ,out}&lt;=iA+iB;
            4'b0011: out&lt;=iA~|iB;    //error
            4'b0100: 
            begin 
                if(iA==iB)
                    out&lt;=32'b1;
            end  
            4'b0101: out&lt;=iA-iB;  //error
            4'b0110:    //error
            begin 
                if(iA&lt;iB)
                    out&lt;=32'b1;
                else
                    out&lt;=32'b0;
                end
            4'b0111:   out&lt;=iA*iB;     //error
            4'b1000: out&lt;=iA/iB;        //error

        end
       always@(out)
           begin
               if(out==0)
                   oZero&lt;=1;
               end

      endmodule
","As Qiu pointed out, iA~|iB should be ~(iA|iB) and you are missing an endcase. In addition to that:


ctrl needs to be 4-bits wide. IE input [3:0] ctrl
Combinational block need to declare all elements in the sensitivity list or use auto-sensitivity. With always @(ctrl) the simulator will not use see changes in iA or iB. Instead use always @* for auto-sensitivity. you should always use auto-sensitivity for combinational logic unless you are limited to the 1995 version of the IEEE Std 1364 (odds are you are not), in which case you need always @(ctrl or iA or iB or iCin). Auto-sensitivity (@* or @(*)) was added to the standard in 2001.
You should not use non-blocking assignments (&lt;=) with combinaitional logic, use blocking assignments (=). Non-blocking should be used to assign flip-flops and latches.
out and oCarry are not assigned a known value in every condition, this infers them as latches. Latch logic designs are prone to timing issues and need to be used with caution. Most FPGAs have a limited number of latches and some have some. A coding style change can remove the infered latch and there are two main ways to do so.


Assign the outputs in every condition. Make sure a default condition is declared in an case-statement:

always @* begin
  case(ctrl)
  4'b0000 :
    begin
      out = iA&amp;iB;
      oCarry = 1'b0;
    end
  // conditions assigning both 'out' and 'oCarry'
  default:
    begin
      out = 32'0;
      oCarry = 1'b0;
    end
  endcase
end

Assign the values to a default value before the case-statement. The case-statement will override the default values.

always @* begin
  // default value
  out = 32'd0;
  oCarry = 1'b0;
  // calculate value, override default
  case(ctrl)
    4'b0000 : out = iA&amp;iB;
    // ...
    4'b0010: {oCarry ,out} = iA+iB;
    // ...
    4'b1000: out = iA/iB;
  endcase
end


oZero is also an inferred latch. It can only be assigned to 1, there is no path to 0. You can:


always @* oZero = (out==0);
Merge the always block with oZero = (out==0); below endcase 
assign oZero = (out==0); // Make sure 'oZero' is a wire (not reg)





Other suggestions (optional)


ANSI style header. Added in IEEE Std 1364-2001 and supported by all modern simulators and synthesizers. It is more compact than the Non-ANSI style of IEEE Std 1364-1995.

module ALU_32 (    
  input [31:0] iA, iB,
  input        iCin,
  input [3:0]  ctrl,
  output reg  oCarry, oZero,
  output reg [31:0] out );

You suggested there where errors with iA*iB and iA/iB. In verilog, there is nothing wrong. Synthesis tools may have an issue because 32-bit by 32-bit multiplier / dividers tend to take a lot of resources. You may need to pipeline the operations in separate modules. FPGA may have a predefined module, so check the data sheet.
",,,,,
VHDL audio sample volume control,"I was searching a lot about this problem, but I cant find anything usefull... 
The problem is, Im making echo efect on FPGA chip.. I have everything prepared, like BRAM for delay, input, output with delay, but I can't find out, how to change volume of output which is coming back to input, to mix them together and send them again to BRAM..
Becouse when I just simply conect output to input, it makes a cycle of BRAM to infinite, but I need to change the volume of output, which is coming back to input, to half of its volume..
I read it can be achived by shifting sample to the right, but it makes a lot of noise over the sample..

Im using 16 bit samples

So I'm asking for ideas about how to control volume of sample, everything else I have prepared..","So i find out what was my problem.. I was shifting sample vector right, but I just made it by ""0"" &amp; sample(15 downto 1) but it was signed, so I had to copy MSB instead of adding just plain ""0"".. so answer is

sample(15) &amp; sample(15 downto 1)


this make sample half of the original volume.. its like sample * 0,5",,,,,
Count Edges over specific Period of Time in VHDL,"For speed measurement of an electric motor I would like to count the amount of rising and falling edges of an encoder-input in a time-interval of 10ms. 

To do this I have implementet a clock divider for my 40 MHz Clock as follows:

entity SpeedCLK is
Port ( CLK          : in  STD_LOGIC;
       CLKspeed     : out  STD_LOGIC);
end SpeedCLK;
architecture Behavioral of SpeedCLK is
signal CounterCLK   : NATURAL range 0 to 400001;
begin

SpeedCounter : process
begin
wait until rising_edge(CLK);
CounterCLK &lt;= CounterCLK + 1;
if CounterCLK &lt; 400000 then
    CLKspeed        &lt;= '0';
else
    CLKspeed        &lt;= '1';
    CounterCLK      &lt;= 0;
end if;
end process SpeedCounter;

end Behavioral;


This should make CLKSpeed '1' every 10 ms. I use this block as a component in my Toplevel VHDL-Module. In the next Block I count the Edges from my encoderinput(QEPA) with a shift register to debounce the Input Signal.

entity SpeedMeasure is
Port (
    QEPA        :   in      STD_LOGIC;
    CLK     :   in      STD_LOGIC;
    CLKSpeed    :   in      STD_LOGIC;
    Speed       :   OUT INTEGER -- in rpm
    );
end SpeedMeasure;

architecture Behavioral of SpeedMeasure is

begin
Edges : process(CLKSpeed, CLK)

variable detect     : STD_LOGIC_VECTOR(5 downto 0) := ""000000"";
variable    EdgesPerTime    : INTEGER := 0;
variable    CountQEPA       : INTEGER := 0;

begin
if CLKSpeed = '1' then
    EdgesPerTime := countQEPA;
    countQEPA := 0;
ELSIF (CLK'EVENT AND CLK = '1') THEN
    detect(5 downto 1) := detect(4 downto 0);
    detect(0) := QEPA;
if (detect = ""011111"") OR (detect = ""100000"") then 
countQEPA := countQEPA + 1;
    else
        countQEPA := countQEPA;
    end if;
end if; 
Speed &lt;= EdgesPerTime;
end process Edges;


end Behavioral;


This should write the current value of CountQEPA in my variable edgesPerTime every 10 ms and reset the Counter afterwards. 
The signal Speed gets transmitted via uart. Unfortunatly with the reset of CountQEPA every 10ms I receive a constant value of 0 for EdgesPerTime. If I remove the reset line in the code, I can receive an increasing value for EdgesPerTime until the largest number for Integer (2^16) is reached, at which Point the Counter resets to 0. 

What is the correct implementation in VHDL to count rising and falling edges in a set period of time?

Any help is greatly apreciated as I am still very new to vhdl.","You're building a latch using a variable. Your synthesis tool inferred an asynchronous reset CLKSpeed for countQEPA and since your latch EdgesPerTime latches countQEPA when its write enable CLKSpeed is asserted, you only see the reset countQEPA value of 0.

You should build proper synchronous logic:

signal CountQEPA : integer                      := 0;
signal detect    : std_logic_vector(5 downto 0) := (others =&gt; '0');
begin

edge_cnt_p : process (
    CLK
    )
begin

    if (rising_edge(CLK)) then

        -- synchronous reset
        if (CLKSpeed = '1') then

            countQEPA &lt;= 0;

        elsif ((detect = ""011111"") or (detect = ""100000"")) then

            countQEPA &lt;= countQEPA + 1;

        end if;

    end if;

end process edge_cnt_p;

edge_debounce_p : process (
    CLK
    )
begin

    if (rising_edge(CLK)) then

        detect &lt;= detect(detect'left downto 1) &amp; QEPA;

    end if;

end process edge_debounce_p;

count_register_p : process (
    CLK
    )
begin

    if (rising_edge(CLK)) then

        -- synchronous write enable
        if (CLKSpeed = '1') then

            Speed &lt;= countQEPA;

        end if;

    end if;

end process count_register_p;


I'm not a big fan of variables, but it seems synthesis tools got a lot smarter these days. As you can see, I made three separate processes to show what we actually want going on. CountQEPA and debounce are signals now, because they need to be readable from other processes.

I assume CLKSpeed is synchronous to CLK (40 MHz). If it isn't, then you should think about handshaking between the clock domains.

You can of course make a single process out of these individual processes. In general, I try to avoid variables, because they can easily be used to describe behavior that is not synthesizable, like you found out the hard way.



I'm not sure how long your encoder bounces, but if you do sample at 40 MHz, a 6 bit shift register will likely not work as that's only a 125 ns debounce (you use the lower 5 bits only for debouncing, the top bit for noticing state changes).

Speaking of your debouncer. Consider the following case:

debounce QEPA
 111111   1
 111111   0 &lt;-- glitch/bounce on encoder line; 25 ns wide
 111110   1
 111101   1
 111011   1
 110111   1
 101111   1
 011111   1 &lt;-- fake edge detected


That's probably not what you want. You should compare your debounced signal to the last stable state instead of assuming state'delayed(5 * clk_period) being a stable state.



As I said above, I'm assuming CLK is your 40 MHz clock. You needn't sample your encoder signal that fast, because a proper debouncer would take a large number of shift register bits at no added value to you, because you have to divide that clock down to 1 kHz anyway for your time-slot counting.

Instead, take into account the maximum frequency of your encoder signal. You would want to oversample that at least by double that frequency, quadruple that frequency to be safe. So you have four samples per ""bit time"". 

Since you're expecting many edges at 1 kHz, I assume your encoder is at least two orders of magnitude fast, i.e. 100 kHz. So scale 40 Mhz down to 400 kHz and shift in QEPA for debouncing. Sample these 400 kHz down to 1 kHz for your time slot measurements.



On a side note: What kind of motor encoding only uses a single bit? Are you sure you're not dealing with a quadrature encoder?",,,,,
Verilog: generic parameters,"I have several verilog (not system-verilog) blocks where I want to generate them depending on other parameters. As an example:

module some_module (in, out)

realtime p = 3.5; // the parameter which I want to change

initial begin
if ('global_parameter == 1)
    p = 5.8;
if ('global_parameter == 2)
    p = 4.4;
end

core_module #(p) core (in, out);
endmodule


Here, ""global_parameter"" is defined in a header file but overridden at simulation time by using simulator parameters. And my core module uses ""p"" for delay value like in this example:

module core_module(in, out)

parameter p = 1;

always out &lt;= #p in; // p should be constant

endmodule


Therefore, I'm hoping to have the core module with updated parameter ""p"". But this scenario is not simulate-able. Could you please recommend me a possible solid solution for this problem if possible?

Thank you","A parameter needs to be a parameter type throughout the design. You cannot pass a variable as a parameter.
You can use a generate block to control instantiation:
module core_module#(parameter realtime P=1)(input in, output out);
  always @(in) out &lt;= #(P) in; // p should be constant
endmodule

module some_module (input in, output out);
  generate
    if (GLOBAL_PARAMETER == 1) begin : cfg_1
      core_module #(5.8) core (in, out);
    end
    else if (GLOBAL_PARAMETER == 2) begin : cfg_2
      core_module #(4.4) core (in, out);
    end
    else begin : cfg_dflt
      core_module #(3.5) core (in, out); // default
    end
  endgenerate
endmodule

You can also calculate the parameter in a single line:
module some_module (input in, output out);
  parameter P = (GLOBAL_PARAMETER == 1) ? 5.8 : (GLOBAL_PARAMETER == 2) ? 4.4 : 3.5;
  core_module #(P) core (in, out); // default
endmodule

Alternatively (since you can not synthesizing), you can have the delay value be a variable, then force the value through hierarchical reference. Example:
module core_module (input in, output out);
  realtime p = 1;
  always @(in) out &lt;= #(p) in; // this p is a variable
endmodule

module some_module (input in, output out);
  realtime p = 3.5;
  core_module core (in, out);
  initial begin
    if (GLOBAL_PARAMETER == 1)
      p = 5.8;
    else if (GLOBAL_PARAMETER == 2)
      p = 4.4;
    force core.p = p; // force hierarchical variable assignment
  end
endmodule

 Note: all example are compatible with IEEE Std 1364-2001 and IEEE Std 1364-2005, utilizing ANSI header style and generate blocks. These features do not exist in IEEE Std 1364-1995

I'm not aware of any clean Verilog only solutions. You can try embed code (such as Perl's EP3, Ruby's eRuby/ruby_it, Python's prepro, etc.) As I mention in another answer to a somewhat similar question, here. A challenge with embedded is the need to be pre-compiled/processed, making them more like `define then parameters.
If SystemVerilog is an option, you can do the following: (Refer to IEEE Std 1800-2012 Â§ 6.20 Constants; example near the end of Â§ 6.20.2)
module some_module (input in, output out);
  parameter realtime P [3] = '{3.5, 5.8, 4.4};
  core_module #(P[GLOBAL_PARAMETER]) core (in, out);
endmodule
",,,,,
FPGA logic cells,"I have an small presentation about FPGA techonology. My questions is: If your FPGA has 85k logic cells, does this mean it can run 85k operations simultaneously?
What I am trying to achieve is to shock the audience with some crazy illustrated facts about FPGA technology or facts. The people who listens now very little about FPGA, so I want to impress them.","What's inside a 'cell' can vary per manufacturer, but the Xilinx definition (using this manufacturer as an example, as these are the devices that I'm familiar with) is one four-input look-up table, and one register. Xilinx devices are made up of a number of 'slices', and these contain a number of functional elements. These might include:


Look-up tables
Registers
Multiplexers
Logic for use in carry chains
etc


As an example, a Spartan6 LX4 has 600 slices, and the marketing material claims that this is equivalent to 3840 'logic cells'. You can look in the user guide for a device to determine exactly what is contained inside a slice.

In addition to this, there are other resources such as multipliers, memories, PLLs, etc.

I suppose you could say that one logic cell can perform one operation, but a single cell is only capable of very simple operations, for example an AND gate, 2:1 multiplexer, etc.",,,,,
Systemverilog: Simulation error when passing structs as module input\outputs,"I am trying to pass one structure as an input and get the output in another structure. However I am having some issues during simulation. The following example code compiles fine in questasim, however the simulation gives the following error:


  Connection type 'core_tb_sv_unit.struct ' is incompatible with
  'core_sv_unit.struct ' for  port (struct_in):  Struct/union types must
  match.


MyStruct.sv

`ifndef _DEF_
`define _DEF_

typedef struct {
    real instr;
    real addr;
} instr_packet_s;

`endif


core.sv

`timescale 1ns / 1ns
`include ""MyStruct.sv""

module core(
    input instr_packet_s struct_in,
    output instr_packet_s struct_out

);
initial begin
     $display(""Initial"");
end

endmodule


core_tb.sv

`include ""MyStruct.sv""

module core_tb();

instr_packet_s struct_in_tb,struct_out_tb; 

assign struct_in_tb.instr=2;
assign struct_in_tb.addr=3;


core u_core(
.struct_in(struct_in_tb),
.struct_out(struct_out_tb)
);
endmodule


What am I missing?. 

I know interfaces are the suggested workflow here,but the input to the model will be passed to a C routine using DPI. The DPI interface supports structures, I do not think it supports interfaces. This is why I would like to stick to simple structures.","SystemVerilog has strong typing rules for user defined types. A typed declared in one scope is not the same as a type declared in another scope, even if it has the same name and same internal layout. A user defined type is only compatible with itself. Define your types in a package and import the package in each file. See http://go.mentor.com/package-import-versus-include

By default, Questa treats each file on the vlog command line as a separate compilation unit, like C/C++. So all compiler directives (`defines) and declaration in the first file are not visible to the contents of the second file. So your typedef gets executed when compiling both the core.sv and core_tb.sv files.

I believe incisive concatenates all the files on the command line, and then compiles the file, so there is only one compilation unit, and there is only on typedef.

There is a way to change the Questa default, but I'm not going to tell you it because I don't recommend doing it that way. It makes things very difficult when you want to take advantage of separate compilation in larger environments.",,,,,
Updating a classes' variable in a constructor through pass by reference?,"Blazing ahead with newfound knowledge of SystemVerilog's inner workings I've set out to use one of these fandangled pass-by-reference features to update a classes' counter in the constructor of another class. The setup (stripped to the basics) looks somewhat like this:

class my_queue;
  int unsigned num_items; //Want to track the number of items this Queue has seen.

  function push_new_item();
     item new_item = new(num_items);
  endfunction

endclass

class parent_item;
   int unsigned x_th_item;
   function new(ref int unsigned num_items);
      x_th_item = num_items;
      num_items += 1; //This should increase the counter in num_items.
   endfunction
endclass

class item extends parent_item;
   function new(ref int unsigned num_items);
      super.new(num_items);
   endfunction
endclass


The issue is that my compiler is complaining about an

Illegal connection to the ref port 'num_items' of function/task parent_item::new, formal argument should have same type as actual argument.


I have an idea on how to fix this: Moving the increment after the call to new() in push_new_items.
But then I still won't know how to correctly use pass-by-refrence in SV so what's causing the error?
Is it the other pass-by-reference or maybe a syntactical error?","Qiu did point me to the issue with my code. My problem was that, whilst the variables were declared correctly on both ends, one of my constructors was written:

function new(ref int num_items);


where it should have rather been

function new(ref int unsigned num_items);


Thank you Qiu.",,,,,
VHDL simulation stuck in for loop,"I'm doing simulation testing for some VHDL I wrote and when I run it in ModelSim it gets stuck.  When I hit 'break' it has an arrow pointing to the For loop in the following function:

function MOD_3 (a, b, c : UNSIGNED (1023 downto 0)) return UNSIGNED is

  VARIABLE x : UNSIGNED (1023 downto 0) := TO_UNSIGNED(1, 1024);
  VARIABLE y : UNSIGNED (1023 downto 0) := a;
  VARIABLE b_temp : UNSIGNED (1023 downto 0) := b;

begin

  for I in 0 to 1024 loop
    if b_temp &gt; 0 then
      if b_temp MOD 2 = 1 then
        x := (x * y) MOD c;
      end if;
      y := (y * y) MOD c;
      b_temp := b_temp / 2;
    else
      exit;
    end if;
  end loop;

  return x MOD c;

end function;


I originally had this as a while loop which I realize is not good for synthesizing.  So I converted it to a for loop with the condition that b_temp is greater than 0.  b_temp is a 1024-bit unsigned and so if it is the largest number that could be represented by 1024 bits and divided in half (which I do in each iteration) 1024 times, shouldn't it definitely be 0?

I have a feeling my problem lies in the large multiplications...if I comment out x := (x * y) MOD c and y := (y * y) MOD c then it exits the loop.  So the only thing I can think of is it takes too long to carry out these 1024-bit multiplications?  If this is the case, is there any built-in way I can optimize this to make it faster, or is my only option to implement something like Karatsuba multiplication, etc...?","I'm of the opinion implementing a Montgomery multiplier in numeric_std function calls may not improve simulation as much as you'd like (while giving synthesis eligibility). 

The issue is the number of dynamically elaborated subprogram calls vs. their operand sizes vs. fitting in your CPU-running-Modelsim's L1/L2/L3 caches. 

It does do wonders for targeting synthesis in an FPGA or a SIMD GPU implementation.  

See Subversion Repositories BasicRSA file modmult.vhd (which has a generic size). I successfully converted this to using numeric_std[_unsigned].

If I recall correctly this appears inspired by 
a Masters thesis (Efficient Hardware Architectures for Modular Multiplication) by David Narh Amanor in 2005 outlining a Java and a VHDL implementation in various word sizes.

I found the OpenCores implementation mentioned in a Stackoverflow question (Montgomery multiplication VHDL Implementation) and found the generic sized version in the SVN repository (the downloadable version is 16 bit) and the mention of the thesis in A 1024 â€?Bit Implementation of the Faster Montgomery Multiplier Using VHDL (by David Narh Anamor, the original link having expired). Note the quoted FPGA implementation performance under 42 usec.

Notice the length 1024 version specified by a generic would still be performing dynamically elaborated function calls with length 1024 operands (although not the ""*""s, the ""mod""s or the ""/""s. You'd still be doing millions of function calls with dynamically elaborated (passed on an expression stack) 1024 bit parameters. We're simply changing how many millions of large parameter subroutine calls and how long they can take.

And that also brings up the possibility of an integer vector implementation (bignum equivalent) in VHDL, which would potential increase simulation performance even more (and you're likely in uncharted territory here).

A subprogram based version of the OpenCores model using variable parameters would be telling. (Whether or not you can impress anyone showing them a simulation model executing, or whether there's this looong pause interrupted by everyone taking furtive glances at the wall clock and looking bored). ",,,,,
What is wrong in this verilog code?,"I'm studying verilog and trying to apply the concepts in my fpga.
It supossed to work in this way : 
When Switch 1 is on, all red leds turn on.
When Switch 2 is on, all green leds turn on.
When Switch 3 is on, all leds turn on.
The problem is when I put it in my fpga switch .
Could someone tell me why?
Here's my code  :

module LED (

    input CLOCK_50,
    input [17:0] SW,
    output reg [17:0] LEDR,
    output reg [9:0] LEDG
);

always@(posedge(CLOCK_50))

    begin
        case(SW[0])
            0:
                LEDR = 0;
            1: 
                LEDR = ~LEDR;
        endcase

        case(SW[1])
            0:
                LEDG = 0;
            1:
                LEDG = ~LEDG;
        endcase 
        case(SW[2])
            0:
                begin
                    LEDR = 0;
                    LEDG = 0;
                end
            1:
                begin
                    LEDR = ~LEDR;
                    LEDG = ~LEDG;
                end
        endcase 

    end
endmodule
","Some problems in the code are:


for this situation is best with non-blocking assign. Explication 12
you are reassigning LEDR and LEDG with the case(SW[2]) statement
You are toggling the values of LEDG and LEDR on each posedge(CLOCK_50). this is the reason why you see low intensity in leds.    


tips:


you can use bit notation (also hex) like LEDG = 10'b1111111111; or LEDG = 10'b1111_1111_11; (hex: 10'h3AA)
you can use a case for the SW like:

case(SW)
    3'b000:
        ...
    3'b001:
        ...
    3'b010:
        ...
    3'b100:
        ...
    default:
        ...

",,,,,
"Convert binary ( integer and fraction) from VHDL to decimal, negative value in C code","I have a 14-bit data that is fed from FPGA in vhdl, The NIos II processor reads the 14-bit data from FPGA and do some processing tasks, where Nios II system is programmed in C code

The 14-bit data can be positive, zero or negative. In Altera compiler, I can only define the data to be 8,16 or 32. So I define this to be 16 bit data.

First, I need to check if the data is negative, if it is negative, I need to pad the first two MSB to be bit '1' so the system detects it as negative value instead of positive value. 

Second, I need to compute the real value of this binary representation into a decimal value of BOTH integer and fraction.

I learned from this link (Correct algorithm to convert binary floating point &quot;1101.11&quot; into decimal (13.75)?) that I could convert a binary (consists of both integer and fraction) to decimal values.

To be specified, I am able to use this code quoted from this link (Correct algorithm to convert binary floating point &quot;1101.11&quot; into decimal (13.75)?) , reproduced as below:

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

double convert(const char binary[]){
  int bi,i;
  int len = 0;
  int dot = -1;
  double result = 0;

  for(bi = 0; binary[bi] != '\0'; bi++){
    if(binary[bi] == '.'){
      dot = bi;
    }
    len++;
  }
  if(dot == -1)
    dot=len;

  for(i = dot; i &gt;= 0 ; i--){
    if (binary[i] == '1'){
      result += (double) pow(2,(dot-i-1));
    }
  }
  for(i=dot; binary[i] != '\0'; i++){
    if (binary[i] == '1'){
      result += 1.0/(double) pow(2.0,(double)(i-dot));
    }
  }
  return result;
}

int main()
{
   char  bin[] = ""1101.11"";
   char  bin1[] = ""1101"";
   char  bin2[] = ""1101."";
   char  bin3[] = "".11"";

   printf(""%s -&gt; %f\n"",bin, convert(bin)); 
   printf(""%s -&gt; %f\n"",bin1, convert(bin1)); 
   printf(""%s -&gt; %f\n"",bin2, convert(bin2)); 
   printf(""%s -&gt; %f\n"",bin3, convert(bin3)); 

   return 0;
}


I am wondering if this code can be used to check for negative value? I did try with a binary string of 11111101.11 and it gives the output of 253.75... 

I have two questions:


What are the modifications I need to do in order to read a negative value? 


I know that I can do the bit shift (as below) to check if the msb is 1, if it is 1, I know it is negative value... 

if (14bit_data &amp; 0x2000) //if true, it is negative value


The issue is, since it involves fraction part (but not only integer), it confused me a bit if the method still works...


If the binary number is originally not in string format, is there any way I could convert it to string? The binary number is originally fed from a fpga block written in VHDL say, 14 bits, with msb as the sign bit, the following 6 bits are the magnitude for integer and the last 6 bits are the magnitude for fractional part. I need the decimal value in C code for Altera Nios II processor.
","I think this should work:

float convert14BitsToFloat(int16_t in)
{
    /* Sign-extend in, since it is 14 bits */
    if (in &amp; 0x2000) in |= 0xC000;

    /* convert to float with 6 decimal places (64 = 2^6) */
    return (float)in / 64.0f;
}


To convert any number to string, I would use sprintf. Be aware it may significantly increase the size of your application. If you don't need the float and what to keep a small application, you should make your own conversion function.",,,,,
Access parent class variables from nested class,"I want to access the variables width/height/size from the nested class, putting static infront of them works, but is there another way?

class random_messages; 

    int                 max_x;
    int                 max_y;
    rand int            width; 
    rand int            height;
    rand int            size; 

    class rand_x;
        randc int  loc_x;        
        constraint sizes {
            loc_x  &lt; width / 2**(size+3); //accessing here
            loc_x  &gt; 0;
        }        
    endclass

endlcass
","Don't make the confusion of thinking that just because you define class rand_x inside the class random_messages, it automatically means that an object of the nested class gets instantiated inside an object of the wrapper class. Declaring a nested class only changes the scope where it is defined.

In your case, if you want to access variables of the parent object, you'll have to do the following:

(in the nested class) Declare a handle to the parent and take the parent in as a constructor parameter:

class rand_x;
  // ...

  protected random_messages m_parent;

  function new(random_messages parent);
    m_parent = parent;
  endfunction
endclass


(in the outer class) Declare an instance of the inner class and pass yourself as its parent:

class random_messages;
  // ...

  rand rand_x x;

  function new();
    x = new(this);
  endfunction
endclass
",,,,,
Using .do files with ModelSim (10.3a),"Here is the (brief) context for my question : 

I am working in VHDL (with Microsemi's Design Suite, Libero) and I use ModelSim to simulate my work. To that extent, I use a classic VDHL TestBench and, to save time, a .do Macro File.
This .do Macro file contains very basic commands such as ""restart"" or deleting/adding waves.

Even if I'm not expecting much from such a file, it would be convenient for me to include in it more actions, that I have to perform by hand with the Graphical Interface like, something that I use quite a lot : combining signals into a custom bus. This action is very simple to do in Modelsim's graphical interface but I can't find anywhere how to perform this in a .do Macro File.

So my question is : 

Where can I find some good documentation regarding these ModelSim's .do Macro Files?
Or am I missing the point about the use of these files? Is it relevant to use it in sich a way?

I really hate to ask this kind of question here but, even if I was able to find some info here and there on various websites, I found nothing significant. I have been through quit a lot of ModelSim help documents or user guides but it almost always focused on the graphical interface.","You can find a command reference manual for your ModelSim version here:
www.microsemi.com/document-portal/doc_view/134097-modelsim-command-reference-manual-v10-3a.

You should also be able to find this and other documentation in ModelSim under ""Help"" > ""PE Documentation - PDF Bookcase"" (substitute 'PE' for the edition you are running).

You should see all the usual commands like 'add wave'. These can be used in .do files, and TCL script files.",,,,,
Data shifting in verilog,"I have a number of 32 bit. I need only its first 8 bits. I think I can do this by two methods: one is by shifting the number to 24 bits right and other is by simply assigning the last 8 bits to a variable.
Here is what I am trying to do:

module Data_shiftin(
input reset_n, clk,
input [31:0]    data_in,
output [31:0] data_out
);  
  reg [31:0] data_reg;
  reg data_out;
  always @ (posedge clk)
  begin 
      data_out&lt;=data_in[31:23];
  end
endmodule 


But I am getting only last bit i.e. 32nd bit of the number. I don't know where  I am doing error. 
Thanks!

P.S: I am a newbie to this language.","The assignment you have is correct, but you are only getting one bit because you are redeclaring data_out as a single-bit reg.  Try changing:

reg data_out


To:

reg[31:0] data_out


A better option though it to use Verilog-2000 style port declarations and place the reg keyword in the port list.

Example:

module Data_shiftin(
  input  wire        reset_n, 
  input  wire        clk,
  input  wire [31:0] data_in,
  output reg  [31:0] data_out
); 

always @ (posedge clk)
  begin 
    data_out &lt;= data_in[31:23];
  end
endmodule 


Note also that your tool may warn you about a width mismatch because you are assigning an 8-bit value to a 32-bit value.  To explicitly assign only the lower 8 bits of data_out you should use:

data_out[7:0] &lt;= data_in[31:23]
",,,,,
Writing testbench in Modelsim,"I am trying to write a test bench in verilog in modelsim. I have written the code for test bench as well as for module under test. But while compiling it, i am getting a error saying that compilation failed .
So do we have to write the test bench code in separate module and also the same for the module under test?

//Writing a test bench
module test_bench;
wire w1,w2,w3;
xyz(w1,w2,w3);
test_xyz(w1,w2,w3);
endmodule;


//Now we will define the modules which we have intsantiated in the testbench       module

//Defining the module xyz

module xyz(f,A,B);
input A,B;
output f;
nor(f,A,B);
endmodule;

//Defining the test module which we are going to apply to the module xyz

module test_xyz(f,A,B); 
input f;
output A,B;
initial 
begin 
$monitor ($time ,""A=%b"",""B=%b"", ""f=%b"",A,B,f);
#10 A=0;B=0;
#10 A=1;B=0;
#10 A=1;B=1;
#10 $finish ;
end
endmodule;
","endmodule does not require a semicolon.

Instances should have instance names:

module test_bench;
  wire          w1,w2,w3;
  xyz      dut (w1,w2,w3);
  test_xyz test(w1,w2,w3);
endmodule


If your going to drive signals from an initial or alwys block, they need to be reg not wire in the localscope*.

module test_xyz(f,A,B); 
  input f;
  output reg A,B; //A B are regs


*localscope : where the wire is being driven it is a reg but the output of a module drives a wire. Verilog types do not cross port boundaries.

Example on EDA Playground.",,,,,
Edit top verilog component generated by Qsys,"Is it possible to modify Verilog generated by Qsys before Quartus synthesis ?

I designed a component under Qsys. I added the design.qsys file under my Quartus (14.0) project and selected it as Â«top-levelÂ».

Qsys generate a verilog top component named design.v but if I modify it Quartus will erase my modifications when synthesize project.

I want to modify the top component to Â«exportÂ» some avalon signal on fpga I/O (chipselect and write) to see it on my oscilloscope.","Ok, I found the solution.
In fact, I selected design.qsys as Â«top-levelÂ». Doing this regenerate all HDL code.
To avoid this, adding design.qip is a prefered way. This file can be found under the directory :
design/synthesis/design.qip",,,,,
How to define sum result's width?,"I have few unsigned, 8bits-wide number that i need to add/subtract together. Below the example:

 h_tmp &lt;= signed(r4(calc_cnt - 2) + r4(calc_cnt - 1) + r4(calc_cnt) + 
                                        r4(calc_cnt + 1) + r4(calc_cnt + 2) - 
                                        r2(calc_cnt - 2) - r2(calc_cnt - 1) - r2(calc_cnt) -
                                        r2(calc_cnt + 1) - r2(calc_cnt + 2));


I know that a 13 bit wide result is ok for the numbers that I have, so i defined h_tmp as a signed (12 downto 0). Now, after synthesis I have the following warning

Width mismatch. &lt;h_tmp&gt; has a width of 13 bits but assigned expression is 8-bit wide.


It seems that the synthesiser inferred a 8bits-wide result of the calculation, what have I done incorrectly?","Assuming the addition/subtraction (+/-) is based on the ieee.numeric_std
package (or ieee.std_logic_arith and ieee.std_logic_unsigned), the result
length of an addition/subtraction is that of the longest argument.

So if all your arguments in the addition/subtraction chain are 8 bits long,
then all the additions are made as 8-bit additions/subtractions, even through
you assign to a 13-bit result.

So start the addition/subtraction chain with resize of the first argument to
the length of the result, like below for ieee.numeric_std package:

h_tmp &lt;= signed(resize(r4(calc_cnt - 2), h_tmp'length) + r4(calc_cnt - 1) ...


For ieee.std_logic_arith package use conv_unsigned.",,,,,
GHDL: How do I bind components?,"I'm running automated testbenches with ghdl (0.32rc1). Some of my testbenches require unisim primitives from Xilinx ISE.

I have prepared two external files, if one would like to test my example. To run my example, you'll need a Xilinx ISE or Vivado installation, so you can find the MUXCY primitive. It's located in the folder &lt;InstallDir&gt;\ISE_DS\ISE\vhdl\src\unisims\primitive.

I analyzed the three files with the following ghdl commands:

PS D:\Temp\ghdl&gt; C:\Tools\GHDL\0.32RC1\bin\ghdl.exe -a --work=work C:\Xilinx\14.7\ISE_DS\ISE\vhdl\src\unisims\primitive\MUXCY.vhd
PS D:\Temp\ghdl&gt; C:\Tools\GHDL\0.32RC1\bin\ghdl.exe -a --work=poc .\arith_prefix_and.vhdl
PS D:\Temp\ghdl&gt; C:\Tools\GHDL\0.32RC1\bin\ghdl.exe -a --work=test .\arith_prefix_and_tb.vhdl
.\arith_prefix_and_tb.vhdl:96:16:warning: universal integer bound must be numeric literal or attribute


So far no errors.
Now I started the simulation, which is just ghdl.exe -r on Windows (Linux: -e and -r):

PS D:\Temp\ghdl&gt; C:\Tools\GHDL\0.32RC1\bin\ghdl.exe -r --work=test arith_prefix_and_tb
.\arith_prefix_and.vhdl:79:40:warning: 'mux' is not bound
.\arith_prefix_and.vhdl:43:14:warning: (in default configuration of arith_prefix_and(rtl))


Now ghdl reports that mux could not be bound.
I also tried the parameters --syn-binding and -P., but nothing changed.

What do I have to do to bind the MUXCY component?

P.S. Can someone create a 'ghdl' tag? I don't have enough reputation :)","Here is how I would fix this:

First, analyze the MUXCY in the unisim library as it is intended to be, like so:

ghdl -a --work=unisim C:\Xilinx\14.7\ISE_DS\ISE\vhdl\src\unisims\primitive\MUXCY.vhd


Note the --work=unisim in that command.

Then, make sure you add library UNISIM; at the top of your arith_prefix_and.vhdl file.

That should do it.

What I think is happening here is that, since you are overwriting the name of the work library to poc with the --work=poc when analyzing arith_prefix_and.vhdl, it does not see the the MUXCY entity analyzed in the actual library named work, and so it cannot find a default entity to which to bind the MUXCY component.",,,,,
My VHDL ALU code behave awkward,"I have a problem with VHDL ALU code. I have to make simple ALU with 4 operations with 4-bit operands. I implemented these operations correctly and they work well. For executing I use E2LP board. For choosing the operation I selected 4 JOY buttons,one for each operation. Problem is that when I press button to execute operation and depress it I want result to stay on LEDs while I don't select any other operation, but that's not happening. For first 5 LEDs this works fine, but upper 3 not.This only works for one operation. My simulation results are correct. Here is code an schema of project.Thank you in advance.

----------------------------------------------------------------------------------  Control logic
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


    Port ( --clk : in STD_LOGIC;
              in_saberi : in  STD_LOGIC;
           in_mnozi : in  STD_LOGIC;
           in_ili : in  STD_LOGIC;
           in_rotiraj : in  STD_LOGIC;
           out_saberi : out  STD_LOGIC;
           out_mnozi : out  STD_LOGIC;
           out_ili : out  STD_LOGIC;
           out_rotiraj : out  STD_LOGIC);
end upravljanje;

architecture Behavioral of upravljanje is
signal tmps : std_logic := '1';
signal tmpm : std_logic := '1';
signal tmpi : std_logic := '1';
signal tmpr : std_logic := '1';

begin
logika : process(in_saberi,in_mnozi,in_ili,in_rotiraj)
begin
    if (in_saberi='0' and in_mnozi='1' and in_ili='1' and in_rotiraj='1') then
        tmps &lt;= in_saberi;
        tmpm &lt;= in_mnozi;
        tmpi &lt;= in_ili;
        tmpr &lt;= in_rotiraj;
    elsif (in_mnozi='0' and in_saberi='1' and in_ili='1' and in_rotiraj='1') then
        tmps &lt;= in_saberi;
        tmpm &lt;= in_mnozi;
        tmpi &lt;= in_ili;
        tmpr &lt;= in_rotiraj;
    elsif (in_saberi='1' and in_mnozi='1' and in_ili='0' and in_rotiraj='1') then
        tmps &lt;= in_saberi;
        tmpm &lt;= in_mnozi;
        tmpi &lt;= in_ili;
        tmpr &lt;= in_rotiraj;
    elsif (in_saberi='1' and in_mnozi='1' and in_ili='1' and in_rotiraj='0') then
        tmps &lt;= in_saberi;
        tmpm &lt;= in_mnozi;
        tmpi &lt;= in_ili;
        tmpr &lt;= in_rotiraj;
    elsif (in_saberi='1' and in_mnozi='1' and in_ili='1' and in_rotiraj='1') then
        tmps &lt;=  tmps;
        tmpm &lt;= tmpm;
        tmpi &lt;= tmpi;
        tmpr &lt;= tmpr;
    else
        tmps &lt;= '1';
        tmpm &lt;= '1';
        tmpi &lt;= '1';
        tmpr &lt;= '1';
    end if;

end process logika;
    out_saberi &lt;= tmps;
    out_mnozi &lt;= tmpm;
    out_ili &lt;= tmpi;
    out_rotiraj &lt;= tmpr;

end Behavioral;


--------------------------------------------------------------------------

-- this is for operation add
entity sabirac is
    Port ( clk : in  STD_LOGIC;
              data1 : in  STD_LOGIC_VECTOR (3 downto 0);
           data2 : in  STD_LOGIC_VECTOR (3 downto 0);
           saberi : in  STD_LOGIC;
           result : out  STD_LOGIC_VECTOR (7 downto 0));
end sabirac;

architecture Behavioral of sabirac is
signal c : std_logic_vector (5 downto 0) := ""000000"";
signal tmp : std_logic_vector (7 downto 0) := ""00000000"";

begin
sabiranje : process(clk,saberi)
begin
    if (saberi='0') then
        tmp(0) &lt;= data1(0) xor data2(0);
        c(0) &lt;= data1(0) and data2(0);
        tmp(1) &lt;= data1(1) xor data2(1) xor c(0);
        c(1) &lt;= (data1(1) and data2(1)) or (data1(1) and c(0)) or (data2(1) and c(0));
        tmp(2) &lt;= data1(2) xor data2(2) xor c(1);
        c(2) &lt;= (data1(2) and data2(2)) or (data1(2) and c(1)) or (data2(2) and c(1));
        tmp(3) &lt;= data1(3) xor data2(3) xor c(2);
        if(data1(3) = data2(3)) then
            c(3) &lt;= (data1(3) and data2(3)) or (data1(3) and c(2)) or (data2(3) and c(2));
            tmp(4) &lt;= c(3);
            tmp(5) &lt;= c(3);
            tmp(6) &lt;= c(3);
            tmp(7) &lt;= c(3);
        else
           c(3) &lt;= data1(3) xor data2(3) xor c(2);
            tmp(4) &lt;= c(3);
            tmp(5) &lt;= c(3);
            tmp(6) &lt;= c(3);
            tmp(7) &lt;= c(3);
        end if;


    else
        tmp &lt;= ""ZZZZZZZZ"";
    end if;
end process sabiranje;

    result &lt;= tmp;

end Behavioral;

-----------------------------------------------------------------------------

entity mul is
    Port (
              clk : in STD_LOGIC;
              pomnozi : in STD_LOGIC;
              data1 : in  STD_LOGIC_VECTOR (3 downto 0);
           data2 : in  STD_LOGIC_VECTOR (3 downto 0);
           result : out  STD_LOGIC_VECTOR (7 downto 0));
end mul;

architecture Behavioral of mul is

begin
mnozenje : process (clk,pomnozi)
begin
    if (pomnozi='0') then
        result &lt;= std_logic_vector(signed(data1) * signed(data2));
    else
        result &lt;= ""ZZZZZZZZ"";
    end if;     
end process mnozenje;

end Behavioral;

--------------------------------------------------------------------------

entity rotate is
    Port ( clk : in  STD_LOGIC;
           rotiraj : in  STD_LOGIC;
           data1 : in  STD_LOGIC_VECTOR (3 downto 0);
           data2 : in  STD_LOGIC_VECTOR (3 downto 0);
           result : out  STD_LOGIC_VECTOR (7 downto 0));
end rotate;

architecture Behavioral of rotate is
signal tmp : std_logic_vector (3 downto 0) := ""0000"";
signal tmp2 : std_logic_vector (7 downto 0) := ""00000000"";

begin
rotacija : process(clk,rotiraj)
begin
    if (rotiraj='0') then

        tmp &lt;= std_logic_vector(rotate_left(unsigned(data1),to_integer(unsigned(data2))));
        tmp2(0) &lt;= tmp(0);
        tmp2(1) &lt;= tmp(1);
        tmp2(2) &lt;= tmp(2);
        tmp2(3) &lt;= tmp(3);
        tmp2(4) &lt;= '0';
        tmp2(5) &lt;= '0';
        tmp2(6) &lt;= '0';
        tmp2(7) &lt;= '0';
    else
        tmp2 &lt;= ""ZZZZZZZZ"";
    end if;
end process rotacija;
    result &lt;= tmp2;
end Behavioral;

--------------------------------------------------------------------------
-- Logic OR operation
entity logicko_ILI is
    Port ( clk : in  STD_LOGIC;
           data1 : in  STD_LOGIC_VECTOR (3 downto 0);
           data2 : in  STD_LOGIC_VECTOR (3 downto 0);
           logili : in  STD_LOGIC;
           result : out STD_LOGIC_VECTOR (7 downto 0));
end logicko_ILI;

architecture Behavioral of logicko_ILI is
signal c : std_logic_vector (5 downto 0) := ""000000"";
signal tmp : std_logic_vector (7 downto 0) := ""00000000"";

begin
logicko : process(clk,logili)
begin
    if (logili = '0') then
        tmp(0) &lt;= data1(0) or data2(0);
        tmp(1) &lt;= data1(1) or data2(1);
        tmp(2) &lt;= data1(2) or data2(2);
        tmp(3) &lt;= data1(3) or data2(3);
        tmp(4) &lt;= '0';
        tmp(5) &lt;= '1';
        tmp(6) &lt;= '1';
        tmp(7) &lt;= '1';
    else
        tmp &lt;= ""ZZZZZZZZ"";
    end if;
end process logicko;

  result &lt;= tmp;    

end Behavioral;
","I think you should even use your clk and reset signals in process. Your design is completely asynchron! This is a very bad idea.

A synchron process with asynchron reset look like this:

test : process (clk,reset)
begin
if (reset) then
 c = 0;
elsif (rising_edge(clk)) then
 c = a + b;
end if;
end process:
",,,,,
Verilog pipeline,"I'm trying to make a easy game using HD44780 LCD. 
My idea is to use a BUSY signal to hold off any commands until previous command is executed. I want to use counter and case for sequences of commands while another block is holded by BUSY signal.

Something like this:

    case (counter)
    0: CMD_REG = CLEAR_LCD;
    1: CMD_REG = WRITE_PLR;
    2: ME_BUSY = 0;
    endcase

    if(DRIVER_BUSY == 0 &amp;&amp; counter &lt; 2) begin
        ENABLE_DRIVER &lt;= 1;
        counter &lt;= counter + 1;
    end
    if (counter &gt; 2) begin
        counter &lt;= 4'd0;
    end


But it feels ""wrong"". I dont have any serious experience with Verilog so can someone tell me how it should be done?  ","While your idea seems fine, it might be better to use an Finite State Machine [FSM] ( http://en.wikipedia.org/wiki/Finite-state_machine ). Pretty much this just means that instead of a counter, you would have a variable holding a series of states with more human readable names. Using this, you need only have a case statement defining your next state and output logic depending on the current state.

While this FSM will basically be implemented as a counter, its much easier to read. I cant tell exactly how to make it would with your code, but it might look something like this:

// State register
always @(posedge clk) begin
  state &lt;= next_state;
end

// Next state and output logic
always @(*) begin
  // Default values
  CMD_REG = CLEAR_LCD;
  ME_BUSY = 1'b0;
  ENABLE_DRIVER = 1'b0;

  next_state = WAIT; // Im using enum style, but if you cant use enums, you can always use macros (`WAIT)

  case (state)
    WAIT: begin // counter == 0
      if (DRIVER_BUSY == 0) begin
        next_state = WAIT_MORE;
      end
    WAIT_MORE: begin // counter == 1
      ENABLE_DRIVER = 1'b1;
      CMD_REG = WRITE_PLR;

      if (DRIVER_BUSY == 0) begin
        next_state = NOT_BUSY_HOLD;
      end
    NOT_BUSY_HOLD: begin // counter == 2, here it looks like you get stuck due to your conditionals (at counter == 2, it doesnt increment nor reset)
      ...


But you get the idea hopefully.",,,,,
how to avoid delay in the output of simple process statement in VHDL,"i am a beginner in VHDL. i want ot know why there is a delay of one cycle in the following code.and how to avoid it..at the same time in verilog the statement always @(posedge clk) dont have any delay.. how to do the same in VHDL

library IEEE;
 use IEEE.std_logic_1164.all;

   -- entity
entity t_ff_s is
port ( T,S,CLK : in std_logic;
Q : out std_logic);
 end t_ff_s;
 -- entity
 architecture my_t_ff_s of t_ff_s is
signal t_tmp : std_logic; -- intermediate signal declaration
  begin
    tff: process (S,rising_edge(clk))
     begin
        if (S = '0') then
     t_tmp &lt;= '1';
      --elsif (rising_edge(CLK)) then
     else 
     t_tmp &lt;= T XOR t_tmp; -- temp output assignment
     end if;
    end process tff;
     Q &lt;= t_tmp; -- final output assignment
     end my_t_ff_s;
","Sensitivity lists in VHDL don't take an edge specification like in Verilog. VHDL is more flexible in that you can freely use the 'event signal attribute anywhere within a process to implement edge triggered behavior. You can mix level and edge sensitive logic witho