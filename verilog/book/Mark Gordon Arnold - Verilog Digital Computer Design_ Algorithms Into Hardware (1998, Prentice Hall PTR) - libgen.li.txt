Verilog Digital
Computer Design

Algorithms into
Hardware

ISBN 0-13-639253-9

91 0111161111 1



Verilog Digital
Computer Design

Algorithms into Hardware

Mark Gordon Arnold
University of Wyoming

Prentice Hall PTR
Upper Saddle River, NJ 07458

http://www.phptr.com



I

Pre
Ad

1. WH'
1.1

1.
1.

Editorial/Production Supervision: Craig Little 1.2
Acquisitions Editor: Bernard M. Goodwin 1.3
Manufacturing Manager: Alan Fischer 1.4
Marketing Manager: Miles Williams
Cover Design Director: Jerry Votta 1.5
Cover Design: TalarAgasyan 1.6

1.7
© 1999 by Prentice Hall PTR

< Prentice-Hall, Inc. 2. DES'
A Simon & Schuster Company 2.1
Upper Saddle River, NJ 07458

2.

All product names mentioned herein are the trademarks of their respective owners.

Prentice Hall books are widely used by corporations and government agencies for training, marketing, and resale.

2.
The publisher offers discounts on this book when ordered in bulk quantities.
For more information, contact the Corporate Sales Department at 800-382-3419, fax: 201-236-7141,
email: corpsales@prenhall.com or write

Corporate Sales Department 2.
Prentice Hall PTR
One Lake Street
Upper Saddle River, NJ 07458

All rights reserved. No part of this book may be
reproduced, in any form or by any means, without
permission in writing from the publisher.

Printed in the United States of America
109 8 7 6 5 4 3 2 2.

2.
ISBN 0-13-639253-9

Prentice-Hall International (UK) Limited, London
Prentice-Hall of Australia Pty. Limited, Sydney
Prentice-Hall Canada Inc., Toronto
Prentice-Hall Hispanoamericana, S.A., Mexico 2.
Prentice-Hall of India Private Limited, New Delhi 2.2
Prentice-Hall of Japan, Inc., Tokyo 2.
Simon &S chuster Asia Pte. Ltd., Singapore
Editora Prentice-Hall do Brasil, Ltda., Rio de Janeiro 2.

2.
2.



F - -A E 0

Table of Contents
Page

Preface.............................................................................................................. xxvii
Acknowledgements ......................................... xxix

1. WHY VERILOG COMPUTER DESIGN? . .................................. 1
1.1 What is computer design? ................... . . 1.......................

1.1.1 General-purpose computers ............. ................................ 1
1.1.2 Special-purpose computers......................................................................1

1.2 A brief history of computer/digital technology ............................................ 2
1.3 Translating algorithms into hardware ............................................ 3
1.4 Hardware description languages ............................................ 4
1.5 Typography ............................................. 5
1.6 Assumed background ............................................. 6
1.7 Conclusion ............................................. 6

I TVVF.TC NTNT A &4-
. -lJ-----l --- --------------------------.......... 7

2.1 What is an ASM chart? ....... ............................. . . . . 7
2.1.1 ASM chart commands ........................................ 9

2.1.1.1 Asserting a one-bit signal ........................................ 9
2.1.1.2 Outputting a multi-bit command........................................................ 10

marketing, and resale. 2.1.1.3 Register transfer ................ . . 11
2.1.2 Decisions inASM charts . . . ..................................... 12

6-7141, 2.1.2.1 Relations ......................................... 13
2.1.2.2 External status .. ...................................... 14

2.1.3 Inputs and outputs of an ASM ........................................ 15
2.1.3.1 ASM inputs ......................................... 16

2.1.3.1.1 Externalstatusinputs ........................................ 16
2.1.3.1.2 External data inputs .......... .............................. 16

2.1.3.2 ASM outputs ................ .. ...................... 17
2.1.3.2.1 External command outputs ........................................ 18
2.1.3.2.2 External data outputs ........................................ 18

2.1.4 Goto-less style ...... ................... . 18
2.1.5 Top-down design . . ...................................... 19

2.1.5.1 Pure behavioral .. ...................................... 19
2.1.5.2 Mixed ......................................... 20
2.1.5.3 Pure structure ................ .. ...................... 22

2.1.6 Design automation ........................................ 22
2.2 Pure behavioral example . . . . .................................... 22

2.2.1 A push button interface .................. ...................... 24
2.2.2 An ASM incorporating software dependencies ...................................... 26
2.2.3 Eliminating state TEST ......... ............................... 29
2.2.4 Eliminating state INIT . ....................................... 31

V

I'



f

Page
2.2.5 Saving the quotient ............................................... 33 3.
2.2.6 Variations within the loop ............................................... 34
2.2.7 Eliminate state ZEROR3 .............. ................................. 38

2.3 Mixed examples ............................................... . 40
2.3.1 First example ............................................... 41
2.3.2 Second example ............................................... 45 3.
2.3.3 Third example ............................................... 46
2.3.4 Methodical versus central ALU architectures ........................................ 48

2.4 Pure structural example ........... .................................... 49
2.4.1 First example ............................................... 49

2.4.2 Second example ............................................... 51 3.8
2.5 Hierarchical design ......... ....................................... 52 3.8

2.5.1 How pure is "pure"? ............................................... 56 3.

2.5.2 Hierarchy in the first example ..................... .......................... 57 3.

2.6 Conclusion ............................................... 59
2.7 Further Reading ................................................ 59
2.8 Exercises ............................................... 60

3. VERILOG HARDWARE DESCRIPTION LANGUAGE ..... 64
3.1 Simulation versus synthesis . . ............................................. 64
3.2 Verilog versus VHDL . . . ............................................ 65
3.3 Role of test code ............................................... 65
3.4 Behavioral features of Verilog . . ............................................. 66

3.4.1 Variable declaration ..................... .......................... 67
3.4.2 Statements legal in behavioral Verilog . ................................6. 8 3.9

3.4.3 Expressions .. ............................................. 69 3.

3.4.4 Blocks ............................................... 70
3.4.5 Constants ............................................... 73
3.4.6 Macros, include files and comments ............................................... 73 3.

3.5 Structural features of Verilog . . ............................................. 74
3.5.1 Instantiating multiple gates .................... ........................... 75
3.5.2 Comparison with behavioral code ............................................... 76 3.1'

3.5.3 Interconnection errors: four-valued logic . ..............................7.7 3.

3.5.3.1 High impedance ............................................... 77 3.

3.5.3.2 Unknown value ............................................... 78 3.

3.5.3.3 Use in behavioral code ............... ................................ 78 3.

3.6 $time ................................................ 81 3.

3.6.1 Multiple blocks ................................................ 81 3.

3.6.2 Sequence versus $time .............................................. 82 3

3.6.3 Scheduling processes and deadlock . ..................................8. 2 3.
3.7 Time control ............................................... 83 3.

3.

vi



if

Page
Page

........................... 33 3.7.1 # time control. . ........................................................................................ 83

........................... 34 3.7.1.1 Using # in test code .................................................... 84

.......................... 38 3.7.1.2 Modeling combinational logic with # ................................................ 85

........................... 40 3.7.1.3 Generating the system clock with # for simulation .......................... 87

.......................... 41 3.7.1.4 Ordering processes without advancing $time ............. ....................... 87
. ................. 45 3.7.2 @t ime control .................................................... 88

........................... 46 3.7.2.1 Efficient behavioral modeling of combinational logic with @ ... 89

.......................... 48 3.7.2.2 Modeling synchronous registers .................................................... 90

.......................... 49 3.7.2.3 Modeling synchronous logic controllers. . 91

.......................... 49 3.7.2.4 @ for debugging display.................................................................... 92

.......................... 51 3.7.3 wait . . . . ................................................ 93

.......................... 52 3.8 Assignment with time control .................................................... 94

........................... 56 3.8.1 Blocking procedural assignment ................................................ .... 95

.......................... 57 3.8.2 Non-blocking procedural assignment . . .................................................... 95
........................... 59 3.8.2.1 Problem with <= for RTN for simulation .......................................... 96
........................... 59 3.8.2.2 Proper use of <= for RTN in simulation ............................................ 98
.......................... 60 3.8.2.3 Translating goto-less ASMs to behavioral Verilog ......... ................... 99

3.8.2.3.1 Implicit versus explicit style........................................................ 99
, 3.8.2.3.2 Identifying the infinite loop .100
............6..4.................. 6.4.. 
........................... 64 3.8.2.3.3 Recognizing if else .101

3.8.2.3.4 Recognizing a single alternative. ...................................... 103
........................... 65
.--,,,,,-,--,,65 3.8.2.3.5 Recognizing while loops .104
........................... 66 3.8.2.3.6 Recognizing forever .106

3.8.2.3.7 Translating into an if at the bottom 
---......... of 

67 forever .108
........... 68 3.9 Tasks and functions . . . . ..................................... 109
...........................6 9 3.9.1 Tasks .......................................... . 109
............................ 70 3.9.1.1 Example task .......................................... 110
.......................... 73 3.9.1.2 enternewstate task ......................................... 112
.. ......... 73 3.9.2 Functions ..... ...................................... 114
.......................... 74 3.9.2.1 Realfunction example ......................................... 115
7----.11,11.11.....1 .. 75 3.9.2.2 Using a function to model combinational logic ................................ 115
.......................... 76 3.10 Structural Verilog, modules and ports ......................................... 117
........................... 77 3.10.1 input ports . . . . 118
......................... 77 3.10.2 output ports . . . . 119

...........................7 8 3.10.3 inout ports . . . . 119
---........ 78 3.10.4 Historical analogy: pins versus ports ...................................... 119

--........ ......... 81 3.10.5 Example of a module defined with a behavioral instance .... 121
. ......... 81 3.10.6 Example of a module defined with a structural instance .... 123
........................... 82 3.10.7 More examples of behavioral and structural instances .... 123
...........................8 2 3.10.8 Hierarchical names . . . . 125
........................... 83 3.10.9 Data structures . . . .126

3.10.10 Parameters .. 128

vii



Page

3.11 Conclusion ................................................... 129
3.12 Further reading ................................................... 130
3.13 Exercises ................................................... 131

4. THREE STAGES FOR VERILOG DESIGN ................................................... 
4.1 Pure 134

behavioral examples . . . ................................................1 34
4.1.1 Four-state division machine.................................................................... 134

4.1.1.1 Overview of the source code ................................................... 135
4.1.1.2 Details on slowdivision-system ................................................... 137

4.1.2 Verilog catches the error ............................................ 140
4.1.3 Importance of test code ....................... ............................ 141
4.1.4 Additional pure behavioral examples . ................................1..4 3
4.1.5 Pure behavioral stage of the two-state division machine . .................1..4 8

4.2 Mixed stage of the two-state division machine ............................................ 150
4.2.1 Building block devices ................................................... 150

4.2.1.1 enabled register portlist ................ .... ............ .... 51
4.2.1.2 counter-register portlist .151 6.1
4.2.1.3 alul8l portlist .152 6.2
4.2.1.4 comparator portlist .153
4.2.1.5 mux2 portlist .153 6.3

4.2.2 Mixed stage 6.
............................................... 

4.2.3 154
Architecture for the division machine 6.

............................................... 154
4.2.4 Controller for the division machine........................................................ 6.

157
4.3 Pure structural stage of the two state 6.

division machine ................................ 161
4.3.1 The pure structural controller 6.

........................................ 162
4.3.2 next-statejlogic module 6.

............................................. 162
4.3.3 stategen function ................................................ 6.

163
4.3.4 Testing state-gen ............................................... 6.

165
4.3.5 It seems to work ............................................... 6.

166
4.4 Hierarchical refinement of the controller 6.

. . ............................................. 167
4.4.1 A logic equation approach...................................................................... 6.

167
4.4.2 At last: a netlist ............................................... 6.

168
4.4.3 Post-synthesis simulation 6.

............................................ 170
4.4.4 Resetting the present state 6.

..................... .......................... 
4.5 172

Conclusion . . . ............................................ 6.
176 6

4.6 Exercises . . . ............................................ 176 6
6

5. ADVANCED ASM TECHNIQUES ............................................... 177 6
5.1 Moore versus Mealy ............................................... 

5.1.1 177
Silly example of behavioral Mealy machine .......................................... 178

5.1.2 Silly example of mixed Mealy machine ............................................... 179
5.1.3 Silly example of structural Mealy machine ............................................ 180 6.6

6.7
viii



Page
Page

............................. 129 5.2 Mealy version of the division machine .................................................. 181

............................ 130
5.2.1 Eliminating state INIT again ...................... ............................ 181

............................ 131 5.2.2 Merging states COMPUTEI and COMPUTE2 ...................................... 183
5.2.3 Conditionally loading r2 .................................................. 184

............................ 134 5.2.4 Asserting READY early .................................................. 185

............................ 134 5.3 Translating Mealy ASMs into behavioral Verilog ........................................ 186
............................ 134 5.4 Translating complex (goto) ASMs into behavioral Verilog . ...................1. 88
............................. 135 5.4.1 Bottom testing loop .................................................. 189
............................ 137 5.4.2 Time control within a decision .................................................. 191
............................. 140 r 5.4.3 Arbitrary gotos .................................................. 194
........................... 141 5.5 Translating conditional command signals into Verilog ........... ..................... 194
............................. 143 5.6 Single-state Mealy ASMs .................................................. 196
ae .......... 148 5.7 Conclusion .................................................. 197
........................... 150
............................ 150 6. DESIGNING FOR SPEED AND COST .................................................. 198
........................... 151 6.1 Propagation delay. . ........................................................................................ 199
., ........... 151 6.2 Factors that determine clock frequency . . ................................................ 199
. .......... 152 6.3 Example of netlist propagation delay .................................................. 200
. 153 6.3.1 A priori worst case timing analysis .................................................. 202
. 153 6.3.2 Simulation timing analysis ........................................... 204
. 154 6.3.3 Hazards ................................................... 205
. 154 6.3.4 Advanced gate-level modeling ........................................ 
. 207

157 6.4 Abstracting propagation delay . . . ............................................2..0. 9
. 161 6.4.1 Inadequate models for propagation delay .............................................. 209
. 162 6.4.2 Event variables in Verilog ............................................ 212
. 162 6.4.3 The disable statement .................................................. 213
. 163 6.4.4 A clock with a PERIOD parameter .................................................. 215
. 165 6.4.5 Propagation delay in the division machine . ............................2..1 5
............................ 166 6.5 Single cycle, multi-cycle and pipeline . . . ....................................2..1..7....... 
. .......... 167 6.5.1 Quadratic polynomial evaluator example . .............................2..1 8
........................... 167 6.5.2 Behavioral single cycle .................................................. 219
............................ 168 6.5.3 Behavioral multi-cycle .................................................. 224
............................ 170 6.5.4 First attempt at pipelining ............................................ 226
........................... 172 6.5.5 Pipelining the ma ................................................... 229
............................ 176 6.5.6 Flushing the pipeline .................................................. 231
........................... 176 6.5.7 Filling the pipeline.................................................................................. 231

6.5.8 Architectures for the quadratic evaluator . ..............................2. 35
........................... 177 6.5.8.1 Single-cycle architecture .................................................. 235
........................... 177 6.5.8.2 Multi-cycle architecture ................ .................................. 238
........................... 178

6.5.8.3 Pipelined architecture .................................................. 241
............................ 179 6.6 Conclusion . . . . .............................................. 245
............................ 180

6.7 Further reading . .................................................. 247

ix



Page

6.8 Exercises .247

7. ONE HOT DESIGNS ... 249
7.1 Moore ASM to one hot .. . 249 8

7.1.1 Rectangle/flip flop .. 249
7.1.2 Arrow/wire .. 250
7.1.3 Joining together/OR gate .. 250
7.1.4 Decision/demux .. 250
7.1.5 Summary of the one hot method .. 250
7.1.6 First example .. 252

7.2 Verilog to one hot .. . 255
7.2.1 Continuous assignment .. 255
7.2.2 One hot using continuous assignment .. 258

7.2.2.1 One hot with if else . 258
7.2.2.2 One hot with if . 263
7.2.2.3 One hot with while . 264

7.3 Mealy commands in a one hot machine .. . 266
7.4 Moore command signals with Mealy <= .. . 266

7.4.1 Example to illustrate the technique .. 266
7.4.2 Pure behavioral two-state division example .. 270
7.4.3 Mixed two-state division example .. 271

7.5 Bottom testing loops with disable inside forever .. . 273 8.
7.6 Conclusion .. . 275
7.7 Further reading .. . 275
7.8 Exercises .. . 276

8. GENERAL-PURPOSE COMPUTERS . 277
8.1 Introduction and history .. . . 277
8.2 Structure of the machine . 279

8.2.1 CPU, peripheral and memory . 280 8.
8.2.2 Memory: data and the stored program .. . 280

8.2.2.1 Unidirectional buses versus a bidirectional bus . . 281
8.2.2.2 Deterministic versus non-deterministic access time . . 282
8.2.2.3 Synchronous versus asynchronous memory . . 282

8.2.2.3.1 Synchronous memory.................................................................. 282 8.
8.2.2.3.2 Asynchronous memory . 285 8.

8.2.2.4 Static versus dynamic memory .. 286 8.
8.2.2.5 Volatile versus non-volatile .. 286

8.2.3 History of memory technology .. . 286 9. PD]
8.3 Behavioral fetch/execute .. . . 290 9

8.3.1 Limited instruction set .. . 291 9
8.3.1.1 The PDP-8 .. 291

x



Page Page
8.3.1.2 History of the PDP-8 . . ............................................... 291
8.3.1.3 Instruction subset .................................................. 291

............................. 247 8.3.1.4 Registers needed for fetch/execute . . ....................................2..9..2....... 
8.3.1.5 ASM for fetch/execute .............................. ................... 294

............................. 249 8.3.1.6 Example machine language program . ............................................... 298

............................. 249 8.3.2 Including more in the instruction set ................................................. 302

............................. 249 8.3.2.1 ASM implementing additional instructions ...................................... 303

.............................. 250 8.3.2.2 States for additional instructions . . ......................................3..0..5..... 

............................. 250 8.3.2.2.1 Instruction described with concatenation .................................... 305

............................. 250 8.3.2.2.2 Additional non-memory reference instructions ............................ 308

............................. 250 8.3.2.2.3 Additional memory reference instructions ...................... ............ 309

............................. 252 8.3.2.2.4 Skip instructions .............. ................................... 310

.............................. 255 8.3.2.3 Extra states for interface . . ...............................................3 12

.............................. 255 8.3.2.4 Memory as a separate actor ................................................. 312

............................. 258 8.3.2.4.1 Top-level structure of the machine .............................................. 313

.............................. 258 8.3.2.4.2 Pure behavioral ASM with memory as a separate actor .............. 314

............................. 263 8.3.2.5 Our old friend: division . . ............................................... 314

............................. 264 8.3.2.5.1 Complete childish division program in C .316

.............................. 266 8.3.2.5.2 User Interface for the software .317

.............................. 266 8.3.2.5.3 Childish division program in machine language .318

............................. 266 8.3.2.5.4 Analysis of childish division software .319

.............................. 270 8.3.2.5.5 Comparison with special-purpose implementation .320

............................. 271 8.3.2.5.6 Trade-off between hardware and software .322

.............................. 273 8.4 Mixed fetch/execute ............................................... . 324

.............................. 275 8.4.1 A methodical approach for designing the architecture . ...................3..2 4

.............................. 275 8.4.2 Choosing register types ..................... .......................... 326

............................. 276 8.4.3 Remaining register transfers .......................................... 330
8.4.4 Putting the architecture together ....................................... 330

.............................. 277 8.4.5 Implementing the decisions .................... ........................... 333
.............................. 277 8.4.6 Mixed ASM ............................................... 333
............................. 279 8.4.7 Block diagram ............................................... 335
.............................. 280 8.5 Memory hierarchy ............................................... 336
.............................. 280 8.5.1 Cache memory ................................................ 337
............................. 281 8.5.2 Memory handshaking ................................................ 341

e ........... 282
8.5.3 Architecture for a simple memory hierarchy . ..........................3..4 4

.............................. 282 8.5.4 Effect of cache size on the childish division program ............................ 351

............................. 282 8.6 Conclusion ............................................... 351
.............................. 285 8.7 Further reading ........................................ 352
.............................. 286 8.8 Exercises ............................................... 352
.............................. 286
.............................. 286 9. PIPELINED GENERAL-PURPOSE PROCESSOR .......................................... 354
............................. 290 9.1 First attempt to pipeline ............................................... 354
............................. 291 9.2 Example of independent instructions ............................................... 357

.............................. 291
xi



-

I
Page

9.3 Data dependencies .............................................. 359
9.4 Data forwarding .............................................. 360
9.5 Control dependencies: implementing JMP .............................................. 362
9.6 Skip instructions in a pipeline .............. ................................ 365 I(

9.7 Our old friend: division .............................................. 368 H
9.8 Multi-port memory .............................................. 372 1(
9.9 Pipelined PDP-8 architecture .............................................. 374
9.10 Conclusion .............................................. 375
9.11 Further reading .............................................. 375
9.12 Exercises .............................................. 375

10. RISC PROCESSORS .............................................. 377 11(
10.1 History of CISC versus RISC .............................................. 377 1

1
10.2 The ARM . .............................................. 378 1
10.3 Princeton versus Harvard architecture . . ........................................3..7.9. 
10.4 The register file ....... .. ............................3.7..9....... 
10.5 Three operands are faster than one ...................... ........................ 380
10.6 ARM subset .............................................. 382 11

10.6.1 Data processing instructions .. 382 1.
10.6.2 Branch instruction .. 383
10.6.3 Program status register . .384
10.6.4 Conditional execution . .385
10.6.5 Immediate operands . .387 1

10.7 Multi-cycle implementation of the ARM subset ........................................ 388 1
10.7.1 Fake SWI as a halt ................... ........................ 388
10.7.2 Fetch states ............................................ 390 1
10.7.3 The condx function ........................................... 390
10.7.4 Data processing ............................................ 391 1l S1

10.7.4.1 The dp function ........................................... 391 11.
10.7.4.2 Conditional assignment of psr ....................... .................... 391 1
10.7.4.3 Use of macros ........................................... 391 1

10.7.5 Branch ............................................ 392 1
10.7.5.1 Multiplying by four ........................................... 393 1
10.7.5.2 Adding four in the multi-cycle implementation .............................. 393 11
10.7.5.3 Sign extension macro .......... ................................. 393

10.7.6 Verilog for the multi-cycle implementation . ..........................3..9 3 1
10.8 Pipelined implementation . . . ........................................ 396

10.8.1 ASM for three-stage pipeline . .396 l
10.8.2 Mealy ASM . .398
10.8.3 Two parallel activities .. 398 1
10.8.4 Proper use of <= .. 400 l
10.8.5 Verilog for the pipelined implementation . .400

10.9 Superscalar implementation . . . .................... 402
xii



F

Page
Page

............................. 359

............................. 360 10.9.1 Multiple-port register file ..................................... 403
............................ 362 10.9.2 Interleaved memory ............... .. .................... 403
............................ 365 10.9.3 Examples of dependencies ..................................... 404
............................ 368 10.9.4 Speculative execution .. ................................... 406
............................ 372 10.9.5 Register renaming .. ................................... 406
............................. 374 10.9.5.1 First special-purpose renaming example . 407
............................. 375 10.9.5.2 Second special-purpose renaming example . 409
............................. 375 10.9.6 ASM for the superscalar implementation .. 412
............................ 375 10.9.7 Three parallel activities .. 412

10.9.7.1 Pipeline, parallel and speculative execution . 412
............................ 377 10.9.7.2 Dealing with register renaming . 415
........................... 377 10.9.8 Verilog for the superscalar ARM .. 416
............................ 378 10.9.8.1 The depend function . 416
............................. 379 10.9.8.2 Translating the ASM to Verilog . 418
........................... 379 10.9.8.3 Code coverage . 418
............................ 380 10.9.8.4 Using 'ifdef for the cover task . 419
............................ 382 10.9.9 Test programs .. 421
............................ 382 10.9.9.1 AtestofRI5 . 421
........................... 383 10.9.9.2 Our old friend: division . 423
............................ 384 10.9.9.3 Faster childish division . 426
............................ 385 10.9.9.4 Childish division with conditional instructions . 427
............................. 387 10.10 Comparison of childish division implementations . . 430
........................... 388 10.11 Conclusions .. 433
........................... 388 10.12 Further reading .. 434
............................ 390 10.13 Exercises .. 434
............................ 390
............................ 391 11 SYNTHESIS . 438
............................ 391 11.1 Overview of synthesis .. . 438
........................... 391 11.1.1 Design flow . 439
............................. 391 11.1.2 Testing approaches . 441
........................... 392 11.1.3 Tools used in this chapter . 442
............................ 393 11.1.4 TheM4-128/64CPLD . 442
........................... 393 11.2 Verilog synthesis styles .. . 444
. .......... 393 11.2.1 Behavioral synthesis of registers .............. ....................... 444
............................ 393 11.2.2 Behavioral synthesis of combinational logic ..................................... 444
............................ 396 11.2.3 Behavioral synthesis of implicit style state machines .......................... 445
. .......... 396 11.2.4 Behavioral synthesis of explicit style state machines ............................ 445
........................... 398 11.2.5 Structural synthesis ..................................... 445
. .......... 398 11.3 Synthesizing enabled-register . . .445
. .......... 400 11.3.1 Instantiation by name ................................. 447
............................ 400 11.3.2 Modules supplied by PLSynthesizer ............... .................. 447
............................. 402 11.3.3 Technology specific mapping with PLDesigner ................................. 448

11.3.4 Modules supplied by PLDesigner ............ ..................... 450
xiii



Page
11.3.5 The synthesized design ...................................... 451
11.3.6 Mapping to specific pins ...................................... 453

11.4 Synthesizing a combinational adder ...................................... 454
11.4.1 Test code ...................................... 455
11.4.2 Alternate coding with case ...................................... 457

11.5 Synthesizing an implicit style bit serial adder . . ..............................4..6..0.. 
11.5.1 First attempt at a bit serial adder ............................. 461
11.5.2 Macros needed for implicit style synthesis ................. ............ 462
11.5.3 Using a shift register approach ............................. 462
11.5.4 Using a loop ............................. 463
11.5.5 Test code ............................. 464
11.5.6 Synthesizing ............................. 466

11.6 Switch debouncing and single pulsing .469
11.7 Explicit style switch debouncer .472
11.8 Putting it all together: structural synthesis .474
11.9 A bit serial PDP-8 .475

11.9.1 Verilog for the bit serial CPU . .476
11.9.2 Test code .. 479
11.9.3 Our old friend: division .. 481
11.9.4 Synthesizing and fabricating the PDP-8 . .482

11.10 Conclusions .483
11.11 Further reading .484
11.12 Exercises .484

Appendices

A. MACHINE AND  ASSEMBLY  LANGUAGE .4...8..5............................................... 485

B . PD P-8 CO M M A N DS S  ..4...8..7...................................................................................... 487
Me m ory reference instructions ..4..8..7....................................................................... 487
N on-me mo ry  reference instructions ..4..8..9............................................................... 489
G roup 1I  m icroinstructions ....................................................................................................................................................................  489
G roup 2 mi croinstructions 

... . .... .. . . .. . ... ............................................................................................................................... ..................................... 4179V0

C. COMBINATIONAL LOGIC  BUILDING BLOCKS ..4...9..1.................................. 491
C. . 1I  M odells  of reality ..4..9..1..................................................................................... 491

C. . 1. 1I Ideal com binational logic mo del ..4..9..2....................................................... 492
C. . 1.2 Wo rst  case delay m odel ..4..9..2..................................................................... C

492
C. . 1.3 A ctual gate-level delay mo del .4...9..2........................................................... C

492
C. . 1.4 Physical delay m odel ..4..9...3........................................................................ c

493
C ..2 Bus ..4..9..3........................................................................................................... 493

xiiv



Page Page
............................. 451 2.1 Unidirectional ........................ 493
............................ 453 2.2 Place and route ........................ 494
............................ 454 2.3 Active high versus active low ........................ 495
............................. 455 2.4 Speed and cost ........................ 496
............................. 457 2.5 Broadcasting with a bus ........................ 496
............................. 460 2.6 Subbus ........................ 498
............................ 461 Adder ........................ 500
............................ 462 3.1 Carry out ........................ 500
............................. 462 3.2 Speed and cost ........................ 501
............................ 463 Multiplexer ........................ 502
............................. 464 4.1 Speed and cost ........................ 502
............................. 466 Other arithmetic units ........................ 503
............................. 469 .5.1 Incrementor ........................ 503
............................. 472 Z.5.1.1 Speedandcost ........................ 504
............... 474 .5.2 Ones complementor ........................ 504
............... 475 Z.5.2.1 Speed and cost ........................ 504
................ 476 .5.3 Twos complementor ........................ 504
................ 479 .5.4 Subtractor ........................ 505
............... 481 .5.5 Shifters ........................ 505
................ 482 .5.6 Multiplier ........................ 507
............... 483 Z.5.6.1 Speed and cost ........................ 507
................ 484 .5.7 Division ........................ 507
............... 484 Arithmetic logic unit ........................ 507

.6.1 Logical operations ........................ 509

.6.2 Arithmetic operations ........................ 510

.6.3 Status ........................ 511
Comparator ........................ 511

.7.1 Speed and cost ........................ 512
................ 485 Demux ........................ 513

.8.1 Speed and cost ........................ 513
............... 487 .8.2 Misuse of demuxes ........................ 514
................ 487 Decoders ........................ 515
................ 489 .9.1 Speed and cost ........................ 517
............... 489 .9.2 Other kinds of decoders ........................ 517
............... 490 0 Encoders ........................ 517

1 Programmable devices ........................ 518
................ 491 .11.1 Read only memory ........................ 518
................ 491 .11.2 Complex PLDs ........................ 520
................ 492 2 Conclusions ........................ 520
................ 492 3 Further reading ........................ 521
................ 492 4 Exercises ........................ 521
................ 493
................ 493

xv



Page
D. SEQUENTIAL LOGIC BUILDING BLOCKS . ................................ 525

D.1 System clock ........................................... 525
D.2 Timing Diagrams ........................................... 526
D.3 Synchronous Logic ........................................... 527
D.4 Bus timing diagrams ........................................... 528
D.5 The D-type register ........................................... 529
D.6 Enabled D-type register ........................................... 531
D.7 Up counter register ........................................... 533
D.8 Up/down counter ........................................... 535
D.9 Shift register ........................................... 536
D.10 Unusedinputs ........................................... 538
D.11 Highly specialized registers ............ ............................... 540
D.12 Further Reading ........................................... 541
D.13 Exercises ........................................... 541

E. TRI-STATE DEVICES ............................................ 543
E. 1 Switches ........................................... 543

E. 1.1 Use of switches in non-tri-state gates ........................................... 544
E.1.2 Use of switches in tri-state gates .................. ......................... 545

E.2 Single bit tri-state gate in structural Verilog ........................................... 545
E.3 Bus drivers ........................................... 547
E.4 Uses of tri-state ........................................... 548

E.4.1 Tri-state buffers as a mux replacement ........................................... 548
E.4.1.1 HHOoWw  Vve--riiliotvgg ppriovcLe;srssesse sfiourr--valiueeda ilooggiic  ....................................................................................  5.)4499
E.4.1.2 The tri declaration .......................................................... ................................. 550

E.4.2 Bidirectional buses  ............................................ ...................................... 551
E.4.2.1 The inout declaration .................. ...................................................................  551
E..4..2..2  A read/write regiister ...................................................................................... ............................... 552

E.5 Further Reading ............................................ ................................................. 554
E.6 Exercises ............................................ ........................................................... 55554

F. TO O LS  AND RESOU RCES .............................................................. ................................. 556
F.  1I  Prentice Hall ...................................................................................... ....................................................... 556
F.2 VeriWe ll  Simu lator  ...................................................................................... ............................................. 5556
F.3 M 4-128/64 dermnoboard .. ..................................................................................... ....................................... 557
F.A4 W irewrap,  supplies ............................................ ............................................. 557
F.5 VerilogEAS SYY  ............................................ ..................................................... 557
F.6 PLDesigner .......................................................... ....................................................... 558
F.7 VITO ............................................ ................................................................. 558
FE. 8  Open Verilog International (OVI) ....................... ......................................................  559
F.9 Other Verilog and programm a abbllee  logic vendorrss  .....................................................  560
F.10 PDP-8 ............................................ ............................................................... 560

xvi

i



Page Page
. ,.......... 525 F.11 ARM ............................................... 560
............................ 525
........................... 526 G. ARM INSTRUCTIONS ............................................... 561
............................ 527 1. Efficient instruction set ............................................... 561
............................ 528 2. Instruction set summary ............................................... 561
............................ 529 Register Model ................................................ 562
........................... 531
........................... 533 H. ANOTHER VIEW ON NON-BLOCKING ASSIGNMENT ............................ 564
............................ 535 H.1 Sequential logic ............................................... 564
........................... 536 H.2 $strobe ............................................... 566
........................... 538 H.3 Inertial versus transport delay ............................................... 566
.......................... 540 H.4 Sequence preservation ............................................... 567
........................... 541 H.5 Further reading ............................................... 567
............................ 541

I^ . (...A..SR...JA.I.1.X.s.5.A...t.X.. .s.................................................................................................................... 
............................ 543
............................ 543 J. LIMITATIONS ON MEALY WITH IMPLICIT STYLE .580
........................... 544 J.1 Further Reading .582
........................... 545
. .......... 545
............................ 547
., .......... 548
.......................... 548
............................ 549
. .......... 550
. .......... 551
. .......... 551
........................... 552
........................... 554
.......................... 554

. .......... 556
........................... 556
........................... 556
........................... 557
.......................... 557
........................... 557
......................... 558
.......................... 558
.......................... 559
.......................... 560
........................... 560

xvii



ff-- I 0

List of Figures
Page

2. DESIGNING ASMs
Figure 2- 1. ASM with three states ..................... .............................. 8
Figure 2-2. ASM with command outputs............................................................ 9
Figure 2-3. Equivalent to figure 2-2 ................................................... 10
Figure 2-4. ASM with multi-bit output .................................... 11............... 
Figure 2-5. ASM with register output ............................. ...................... 12
Figure 2-6. ASM with decision ................ ................................... 13
Figure 2-7. ASMs with external status ................................................... 15
Figure 2-8. Block diagram ................................................... 16
Figure 2-9. Two ways to test multi-bit input ...................................................... 17
Figure 2-10. Pure behavioral block diagram........................................................ 20
Figure 2-11. Mixed block diagram ..................... .............................. 21
Figure 2-12. ASM for friendly user interface ................................................... 25
Figure 2-13. Block diagram ................................................... 25
Figure 2-14. ASM for software paradigm (COMPUTEI at top) .......................... 26
Figure 2-15. ASM for software paradigm (COMPUTEl at bottom) .................... 27
Figure 2-16. Incorrect four-state division machine .............................................. 29
Figure 2-17. Correct four-state division machine ................................................ 30
Figure 2-18. Incorrect user interface (throws quotient away) ................ .............. 32
Figure 2-19. Saving quotient in r3 ................................................... 33
Figure 2-20. Handling quotient of zero ................................................... 34
Figure 2-21. Incorrect rearrangement of states ................................................... 35
Figure 2-22. Incorrect parallelization attempt ................................................... 36
Figure 2-23. Correct parallelization ........................................... 37
Figure 2-24. Goto-less two-state childish division ASM . ..............................3..9..... 
Figure 2-25. Equivalent to figure 2-24 ......................................... 40
Figure 2-26. Architecture using subtractor ................................................... 42
Figure 2-27. Architecture using ALU ...................... ............................. 43
Figure 2-28. Methodical architecture .......................................... 44
Figure 2-29. Mixed ASM corresponding to figures 2-24 and 2-28 . . 44
Figure 2-30. System diagram ................................................... 45
Figure 2-31. Mixed ASM corresponding to figures 2-14 and 2-28 . . 46
Figure 2-32. Central ALU architecture ...................... ............................. 47
Figure 2-33. Mixed ASM corresponding to figures 2-14 and 2-32 . . 47
Figure 2-34. Controller ................................................... 50
Figure 2-35. Block diagram and behavioral ASM for adder . . 53
Figure 2-36. Flattened circuit diagram for adder . ..............................5..3 
Figure 2-37. Definition of the adder module . .................................5..5 
Figure 2-38. Definition of the full-adder module ................................................ 55
Figure 2-39. Definition of the half-adder module ................................................ 55

xix

A



Page

Figure 2-40. Hierarchical instantiation of modules .............................................. 56 ra;i
Figure 2-41. "Pure" behavioral block diagram .................................................... 57 Fi
Figure 2-42. Mixed block diagram ....................................... .................... 57 Fi
Figure 2-43. "Pure" structural block diagram ...................................................... 58 Fi

Fi
3. VERILOG HARDWARE DESCRIPTION LANGUAGE Fi

Figure 3- 1. Exclusive or built with ANDs, OR and inverters ............. ............... 75 Fi
Figure 3-2. Every ASM has an infinite loop ...................................................... 100
Figure 3-3. ASM corresponding to if else .......................................................... 102 FN
Figure 3-4. ASM without else ......................... .................................. 103 F
Figure 3-5. ASM with while ....................... .................................... 105
Figure 3-6. Equivalent to figure 3-5 ........................................................... 105 F
Figure 3-7. ASM needing forever ....................................... .................... 107 F
Figure 3-8. Two ways to draw if at the bottom of forever .................................. 108 F

4. THREE STAGES FOR VERILOG DESIGN F
Figure 4-1. Architecture with names used forVerilog coding ............................ 155

F
Figure 4-2. Netlist for the childish division controller ........................................ 170

F
5. ADVANCED ASM TECHNIQUES

Figure 5-1. Behavioral Mealy ASM ........................................................... 178 F
Figure 5-2. Mixed Mealy ASM ........................................................... 180
Figure 5-3. Mealy division machine with two states in loop .............................. 182 F
Figure 5-4. Incorrect Mealy division ASM ........................................................ 183 F
Figure 5-5. Mealy division ASM with conditional load ................. ................... 184
Figure 5-6. Mealy division ASM with conditional READY .............. ................ 185 F
Figure 5-7. ASM for combinational logic (decoder) .......................................... 196 I

6. DESIGNING FOR SPEED AND COST GI
Figure 6- 1. Adder with names used in structural Verilog ................ .................. 202 I
Figure 6-2. Two instantiations of adder ........................................................... 210 I
Figure 6-3. Timing diagram for division machine with abstract I

propagation delay ........................................................... 216
Figure 6-4. Example contents of x and y ........................................................... 219
Figure 6-5. Behavioral single-cycle ASM with only v. * .................................... 220
Figure 6-6. Equivalent single-cycle ASM with = for combinational logic ........ 220
Figure 6-7. Behavioral multi-cycle ASM ........................................................... 224
Figure 6-8. Analogy to factory ........................................................... 227
Figure 6-9. Incorrect pipelined ASM ........................................................... 228
Figure 6-10. Pipelined ASM with multiple addresses but without flush .............. 230

xx

-



Page Page

............................ 56 Figure 6-11. Correct pipelined ASM that fills and flushes ................. ................. 232

........................... 57 Figure 6-12. Single-cycle architecture ........................................................ 235
........................... 57 Figure 6-13. Timing diagram for single-cycle ASM ............................. ............... 237
........................... 58 Figure 6-14. Multi-cycle architecture ....................................... ................. 238

Figure 6-15. Timing diagram for multi-cycle ...................................................... 240
Figure 6-16. Pipelined architecture ........................... ............................. 241

........................... 75 Figure 6-17. Timing diagram for pipelined ASM ................................................ 245

........................... 100

........................... 102 7. ONE HOT DESIGNS

........................... 103 Figure 7-1. Moore ASMs and corresponding components of one hot
........................... 105 controllers ........................................................ 251
............................ 105 Figure 7-2. One hot controller for ASMs of sections 2.2.2 and 2.3.3 .......... ...... 253
........................... 107 Figure 7-3. Power-on device for one hot controllers .......................................... 254
............................ 108 Figure 7-4. One hot controller for ASMs of sections 2.2.7 and 2.3.1 ................ 254

Figure 7-5. Architecture generated from implicit Verilog of sections
7.2.2.1 and 3.8.2.3.3 ........................................................ 260

Figure 7-6. Controller generated from implicit Verilog of sections
. ,.......... 155
........................... 170 7.2.2.1 and 3.8.2.3.3 ........................................................ 262

Figure 7-7. Controller generated from implicit Verilog of sections
7.2.2.2 and 3.8.2.3.4 ......................... ............................... 264

Figure 7-8. Controller generated from implicit Verilog of sections
........................... 178 7.2.2.3 and 3.8.2.3.5 ........................ ................................ 

.......................... 265
180 Figure 7-9. Example with Moore command signal ............................................ 266

........................... 182 Figure 7-10. Current command approach suitable for Moore or Mealy

.......................... 183 controller........................................................................................ 

.......................... 184 268
Figure 7-11. Next command approach suitable only for Moore controller .......... 268

.......................... 185

........................... 196 Figure 7-12. Behavioral ASM with <- for next command approach ........... ....... 268
Figure 7-13. Example bottom testing loop ........................................................ 273

8. GENERAL-PURPOSE COMPUTERS
.......................... 202 Figure 8-1. Block diagram of typical general-purpose 
........................... computer ............. ......... 279

210
Figure 8-2. Symbol for memory with unidirectional data buses ........................ 281
Figure 8-3. Symbol for memory with bidirectional data bus .............................. 

........................... 282
216 Figure 8-4. Symbol for synchronous memory .................................................... 

........................... 283
219 Figure 8-5. Implementation of synchronous memory ........................................ 284

........................... 220 Figure 8-6. Symbol for asynchronous memory .................................................. 285
ional logic ........ 220 Figure 8-7. ASM implementing four instructions of PDP-8 ................ .............. 294
........................... 224 Figure 8-8. ASM implementing more instructions of the PDP-8 ............. ......... 304
........................... 227 Figure 8-9. Block diagram for the PDP-8 system .............................................. 312

........................... 228 Figure 8-10. System composed of processor (controller and architecture)
aftl ush ......... 230 with memory as a separate actor .................................................... 313

xxi



Page

Figure 8-11. ASM with memory as a separate actor ............................................ 315
Figure 8-12. Architecture for PDP-8 subset ................................................ 332 APPE]
Figure 8-13. Mixed ASM for PDP-8 subset ................................................ 334 Fi
Figure 8-14. Block diagram for PDP-8 subset ................................................ 335 Fi
Figure 8-15. ASMs without and with memory read handshaking ........................ 342 Fi
Figure 8-16. ASM with memory write handshaking ............................................ 343 Fi
Figure 8-17. Connection of processor to memory hierarchy ................................ 344 Fi
Figure 8-18. Memory hierarchy architecture with direct mapped Fi

write-through cache ................................................ 346 Fi
Figure 8-19. ASM for direct mapped write-through cache memory Fi

controller ................................................ 347 Fi
Fi

9. PIPELINED GENERAL-PURPOSE PROCESSOR Fi
Figure 9- 1. Incorrect pipelined ASM ....................................................... 355 Fi
Figure 9-2. Pipelined fetch/execute with data forwarding .................................. 361 Fi
Figure 9-3. Pipelined fetch/execture with JMP .................................................. 363 Fi
Figure 9-4. Symbol for multi-port memory ....................................................... 372 Fi
Figure 9-5. Implementation of multi-ported memory ................ ........................ 373 Fi
Figure 9-6. Architecture for pipelined PDP-8 .................................................... 374 Fi

Fi
10. RISC PROCESSORS Fi

Figure 10- 1. Multi-cycle ASM for ARM subset ................................................. 389 Fi
Figure 10-2. Pipelined ASM for ARM subset .................................................... 397 Fi
Figure 10-3. Non-interleaved memory ....................................................... 404 Fi
Figure 10-4. Interleaved memory ....................................................... 404 Fi
Figure 10-5. Forwarding results of dependent instructions slows clock ............ 405 Fi
Figure 10-6. Superscalar ASM for ARM subset ................................................. 411 Fi

Fi
11. SYNTHESIS Fi

Figure 11-1. Design flow for CPLD synthesis ................................. 440 Fi
Figure 11-2. Physical pins of M4-128/64 used for two-bit enabled Fi

register ... 452 Fi
Figure 11-3. Macrocells in M4-128/64 implementing enabled register bit Fi

slices . 453 Fi
Figure 11-4. Macrocells in the M4- 128/64 for low-order two-bit slices Fi

of adder .456 Fi
Figure 11-5. Block diagram for r2 portion of architecture .467 Fi
Figure 11-6. Macrocells implementing low-order bit slices of r2 .469 Fi
Figure 11-7. Ideal versus actual switch behavior shows need for Fi

debouncing .470 Fi
Fi
Fi

xxii



- -

Page
Page

............... 315

.............. 332

............... 334 APPENDIX C COMBINATIONAL LOGIC BUILDING BLOCKS

............... 335 Figure C-1. Synbol for a four-bit unidirectional bus .......................................... 493
g.............342 Figure C-2. Implementation of a four-bit bus .................................................... 494
............... 343 Figure C-3. Transmitting 15 on a four-bit bus .................................................... 494

Figure C-4. Transmitting 7 on a four-bit bus .................................................... 494
Figure C-5. One possible routing of a four-bit bus ........................... ................. 495

d..............346 Figure C-6. Unnecessary device .............................. ............................ 497
iory Figure C-7. Transmitting on one bus to multiple destinations for free .......... ....4 97

Figure C-8. Implementation 
.......................... of figure C-7 

347 .......................................................... 497
Figure C-9. Using the same name at every node ................................................ 498
Figure C-10. Combinational device to divide by two (three-bit output) ............... 498
Figure C-il . Implementation of figure C-10 ........................................................ 499

............... 355 Figure C-12. Combinational device to divide by two (four-bit output) ............... 499

............... 361 Figure C- 13. Implementation 

.............. of figure 
363 C- 12 ........................................................ 499

Figure C-14. Combinational device to add two n-bit values (n+1 bit 
............... output) ...... 500

372 Figure C-15. Treating the 
.............. high-order 

373 bit as carry out ......................... ................. 500
Figure C-16. Alternate symbol 

.............. for figure 
374 C-15 .................................................... 501

Figure C-17. Adder without carry out .......................................................... 501
Figure C- 18. Symbol for multiplexer .......................................................... 502
Figure C-19. Symbol for incrementor.................................................................. 

.............. 389 503
Figure C-20. Inefficient implementation of incrementor ...................................... 

.............. 503
397 Figure C-21. Symbol for ones complementor . ...........................................5..0..4...... 

...............404 Figure C-22. Symbol for twos complementor . ..........................................5.................404 0..4....... 
Figure C-23. Possible implementation 

ws clock ..... of twos complementor 
405 ......... ................... 504

Figure C-24. Symbol for subtractor .......................................................... 
...... ........ 411 505

Figure C-25. Symbol for shifter .......................................................... 505
Figure C-26. Symbol for shifter with shift input . ..............................5..0 5
Figure C-27. Symbol for barrel shifter with shift count input . ....................5..0 6

............... 440 Figure C-28. Possible implementation of barrel shifter .
bled .........................5..0 6

Figure C-29. Symbol for multiplier ........................................... 507
.............. 452 Figure C-30. Symbol for Arithmetic Logic Unit (ALU) .............. ........................ 508
register bit Figure C-3 1. Possible implementation of ALU . ...............................5..0 8
............... 453 Figure C-32. Symbol for comparator .......................................... 512
bit slices Figure C-33. Symbol for equality comparator . ................................5..1 2
............... 456 Figure C-34. Symbol for demux .......................................................... 513
.............. 467 Figure C-35. Misuse of demux .................... ....................................5.1. 4
r2 ............ 469 Figure C-36. Proper design omits demux .......................................................... 514

Figure C-37. Symbol for binary to unary decoder . .............................5..1 5
............... 470 Figure C-38. Possible implementation of decoder . .............................5..1 6

Figure C-39. Alternate implementation of decoder . ............................5..1 6
Figure C-40. Symbol for priority encoder ...................................... 517

xxiii



Page

Figure C-41. Symbol for a Read Only Memory (ROM) .................. .................... 519 Fi
Figure C-42. Possible implementation of a ROM ................................................ 520 Fi

Fi
APPENDIX D.SEQUENTIAL LOGIC BUILDING BLOCKS Fi

Figure D-1. Universal connection to system clock signal shown ........... ........... 525 Fi
Figure D-2. Universal connection to system clock signal assumed .................... 525 Fi
Figure D-3. An analog waveform for the system clock signal .......................... 526 Fi
Figure D-4. A digital abstraction of the system clock signal .............................. 526 Fi
Figure D-5. The system clock divides time into cycles ...................................... 527 Fi
Figure D-6. An ideal synchronous timing diagram ............................................ 527 Fi
Figure D-7. A realistic synchronous timing diagram with propagation delay .... 528 Fi
Figure D-8. An asynchronous timing diagram .................................................... 528
Figure D-9. Timing diagram showing individual bits of a bus ............. ............. 529
Figure D-10. Timing diagram showing numeric values on a bus in decimal ...... 529
Figure D- 11. Notation used for bus timing diagrams ...................... .................... 529
Figure D-12. Symbol for D-type register ............................................................. 529
Figure D-13. Example timing diagram for D-type register .................................. 530
Figure D-14. Another timing diagram for D-type register ................ .................. 530
Figure D-15. Symbol for enabled D-type register ................................................ 531
Figure D-16. Example timing diagram for enabled D-type register ........... ......... 532
Figure D- 17. Implementation of enabled D-type register using simple

D-type and mux ............................................................. 532
Figure D-18. Symbol for up counter register ........................................................ 533
Figure D-19. Implementation of up counter register using simple

D-type register and combinational logic ..................... ................... 534
Figure D-20. Symbol for up/down counter register .............................................. 535
Figure D-21. Implementation of up/down counter register .................................. 536
Figure D-22. Symbol for shift register register .................................................... 537
Figure D-23. Implementation of shift register ...................................................... 537
Figure D-24. Symbols for other registers ............................................................ 538
Figure D-25. Implementations for these registers using a loadable

clearable up counter ............................................................. 538
Figure D-26. Symbol for a non-clearable up counter .......................................... 539
Figure D-27. Possible implementation using a clearable up counter . ..............5...3 9
Figure D-28. Symbol for a non-clearable shift register . .........................5..4 0
Figure D-29. Possible implementation using a clearable shift register ................ 540

APPENDIX E.TRI-STATE DEVICES
Figure E- 1. An open switch causes a light to be off ........................ .................. 543
Figure E-2. A closed switch causes the light to be on ........................................ 544
Figure E-3. A gate producing 0 as output .......................................................... 544
Figure E-4. A gate producing as output .......................................................... 544

xxiv



ff-- I 1

Page
Page

.......................... 519 Figure E-5. A gate producing z as output ..................... ...................... 545

.......................... 520 Figure E-6. A tri-state gate ........................................... 545
Figure E-7. Effect of tri-state gate when enable is 1. ......................................... 546
Figure E-8. Effect of tri-state gate when enable is 0 .......................................... 546

vn .......... 525 Figure E-9. Tri-state bus driver ........................................... 547

med .......... 525 Figure E- 10. Using tri-state bus drivers to form a mux ........................................ 549

.......................... 526 Figure E- 11. One bidirectional bus ........................................... 551

........................... 526 Figure E- 12. Two unidirectional buses .............. ............................. 551

........................... 527 Figure E- 13. A read/write register with a bidirectional bus .................................. 552

.......................... 527 Figure E-14. Implementation of figure E-13 ........................................... 552

?agation delay .... 528 Figure E-15. Instantiation of two read/write registers .......................................... 553

............................ 528
.......................... 529

s in decimal ...... 529
.......................... 529
............................ 529
............................ 530
........................... 530
............................ 531
ster .......... 532
simple
........................... 532
............................ .5.3.3...
?le

........................... 534

............................ 535

............................ 536

........................... 537

............................ 537

........................... 538
ible
............................ .5.3.8...
........................... 539
unter .......... 539
............................. 540
register .......... 540

............................ 543

............................. 544

............................ 544

............................ 544

xxv

L



Preface
When I started teaching Verilog to electrical engineering and computer science seniors at
the University of Wyoming, there were only two books and a handful of papers on the
subject, in contrast to the overwhelming body of academic literature written about VHDL.
Previously, VHDL had been unsuccessful in this course. For all its linguistic merits, VHDL
is too complex for the first-time user. Verilog, on the other hand, is much more straightfor-
ward and allows the first-time user to focus on the design rather than on language details.
Yet Verilog is powerful enough to describe very exotic designs, as illustrated in chapters 8-
11.

As its subtitle indicates, this book emphasizes the algorithmic nature of digital computer
design. This book uses the manual notation of Algorithmic State Machine (ASM) charts
(chapter 2) as the master plan for designs. This book uses a top-down approach, which is
based on the designer's faith that details can be ignored at the beginning of the design
process, so that the designer's total effort can be to develop a correct algorithm.
Chapters 2-11 use the same elementary algorithm, referred to as the childish division algo-
rithm, for many hardware and software examples. Because this algorithm is so simple, it
allows the reader to focus on the Verilog and computer design topics being covered by each
chapter. This book is unique in showing the correspondence of ASM charts to implicit style
Verilog (chapters 3, 5 and 7). All chapters emphasize a feature of Verilog, known as non-
blocking assignment or Register Transfer Notation (RTN), which is the main distinction
between software and synchronous hardware. Except for chapter 6, this book ignores (ab-
stracts away) propagation delay. Instead, the emphasis here is toward designs that are
accurate on a clock cycle by clock cycle basis with non-blocking assignment. (Many exist-
ing Verilog books either provide too much propagation delay information or are so abstract
as to be inaccurate on a clock cycle basis. Appendices C and D motivate the abstraction
level used here.)

Chapter 4 gives a novel three-stage design process (behavioral, mixed, structural), which
exercises the reader's understanding of many elementary features of Verilog. Chapter 7
explains an automated one hot preprocessor, known as VITO, that eliminates the need to go
though this manual three-stage process.
This book defers the introduction of Mealy machines until chapter 5 because my experi-
ence has been that the complex interactions of decisions and non-blocking assignments in a
Mealy machine are confusing to the first-time designer. Understanding chapter 5 is only
necessary to understand chapters 9 and 10, appendix J and sections 7.4 and 11.6.
The goal is to emphasize a few enduring concepts of computer design, such as pipelined
(chapters 6 and 9) and superscalar (chapter 10) approaches, and show that these concepts
are a natural outgrowth of the non-blocking assignment. Chapter 6 uses ASM charts and
implicit Verilog to describe pipelining of a special-purpose machine with only the material
of chapter 4. Chapters 8, 9 and 11 use the classic PDP-8 as an illustration of the basic
principles of a stored program computer and cache memory. Chapter 8 depends only on the
ASM material of chapter 2. Chapter 9 requires an understanding of all preceding chapters,

xxvii



except chapter 7. The capstone of this book, chapter 10 (which depends on chapter 9), uses
the elegant ARM instruction set to explore the RISC approach, again with the unique com-
bination of ASMs, implicit Verilog and non-blocking assignment.
Chapters 3-6, 9 and 10 emphasize Verilog simulation as a tool for uncovering bugs in a
design prior to fabrication. Test code (sometimes called a testbench) that simulates the
operating environment for the machine is given with most designs. Chapter 10 introduces
the concept of Verilog code coverage. Chapters 7 and 11, which are partially accessible to
a reader who understands chapter 3, uses specific synthesis tools for programmable logic to
illustrate general techniques that apply to most vendors' tools. Even in synthesis, simula-
tion is an important part of the design flow. Chapter 11 will be much more meaningful after
the reader has grasped chapters 1-9. The designs in chapter 11 have been tested and down-
loaded (www. phptr . com) into Vantis CPLDs using a tool available to readers of this
book (appendix F), but these designs should also be usable with minor modifications for
other chips, such as FPGAs.
Appendices A, B and G give background on the machine language examples used in chap-
ters 8-11. Appendices C and D give the block diagram notation used in all chapters for
combinational logic and sequential logic, respectively. Chapters 1-11 do not use tri-state
bidirectional buses, but appendix E explains the Verilog coding of such buses.
This book touches upon several different areas, such as "computer design," "state machine
design," "assembly language programming," "computer organization," "computer arithmetic,"
"computer architecture," "register transfer logic design," "hardware/software trade-offs,"
"VLSI design,"" "parallel processing" and "programmable logic design." I would ask the
reader not to try to place this book into the pigeon hole of some narrow academic category.
Rather, I would hope the reader will appreciate in all these digital and computer design
topics the common thread which the ASM and Verilog notations highlight. This book just
scratches the surface of computer design and of Verilog. Space limitations prevented inclu-
sion of material on interfacing (other than section 11.6) and on multiprocessing. The ex-
amples of childish division, PDP-8 and ARM algorithms were chosen for their simplicity.
Sections labeled "Further reading" at the end of most chapters indicate where an interested
reader can find more advanced concepts and algorithms, as well as more sophisticated fea-
tures of Verilog. Appendix F indicates postal and Web addresses for obtaining additional
tools and resources. It is hoped that the simple examples of Verilog and ASMs in this book
will enable the reader to proceed to these more advanced computer design concepts.
In places, this book states my opinions rather boldly. I respect readers who have differing
interpretations and methodologies, but I would ask such readers to look past these distinc-
tions to the unique and valuable approaches in this book that are not found elsewhere. I
have sprinkled (somewhat biased) historical tidbits, primarily from the first quarter century
of electronic computer design, to illustrate how enduring algorithms are, and how transient
technology is. Languages are more algorithmic than they are technological. Just look at the
endurance of the COBOL language for business software. Hardware description languages
will no doubt change as the twenty-first century unfolds, but I suspect whatever they be-
come, they will include something very much like contemporary implicit style Verilog.

xxviii



-

ends on chapter 9), uses Acknowledgments
in with the unique corn-

The author would like to thank the following people who have contributed to the content of
the computer design laboratory 

r uncovering at the University 
bugs in of 

a Wyoming: Tighe Fagan, Rick Joslin,
Bob Lynn, Susan Taylor McClendon, 

,nch) Philip 
that Schlump, 

simulates Elaine 
the Sinclair, Tony Wallace and

Cao Xu.
Chapter 10 introduces

e partially accessible to The author would also like to thank his colleagues at the University of Wyoming, especially
programmable logic to Tom Bailey whose editorial advice is appreciated very much, John Cowles who cheerfully

en in synthesis, simula- endured a semester of teaching the computer design laboratory, Jerry Cupal who convinced
I more meaningful after the author to try Verilog and Richard Sandige who has engaged the author in stimulating
'been tested and down- discussions about digital design.
lable to readers of this The author wishes to acknowledge the tremendous contribution of James Shuler of SUNY
ninor modifications for (Brockport, NY) in the development of the VITO preprocessor described in chapter 7 and

appendix F. The author gratefully acknowledges Elliot Mednick of Wellspring Solutions
examples used in chap- (Salem, NH) for making a limited version of its VeriWell' Verilog simulator available to
used in all chapters for everyone. The author is extremely grateful to Kevin Bush of MINC, Inc. (Colorado Springs,
-11 do not use tri-state CO) for making a limited version of its VerilogEASY synthesis tool available to readers of
;uch buses. this book.

design," "state machine The author sincerely thanks Freddy Engineer of MINC, Inc. and Neal Sample of Stanford
"'computer arithmetic," for proofreading the manuscript. The author also thanks Karolyn Durer, Peggy Hopkins
re/software trade-offs," and Phyllis Ranz for their assistance in the manuscript preparation. The author wishes to
sign." I would ask the acknowledge the contribution of his editors at Prentice Hall: Russ Hall, Camille Trentacoste,
row academic category. Diane Spina, Bart Blanken, Craig Little and Bernard Goodwin.
Il and computer design Finally, the author wishes to express deep appreciation to Frank Prosser and David Winkel
ghlight. This book just of Indiana University for the inspiration they provided with The Art of DigitalD esign. It is
rations prevented inclu- hoped that the material presented here will contribute a fraction of what The Art of Digital
iltiprocessing. The ex- Design has.
ien for their simplicity.
ate where an interested
more sophisticated fea-
or obtaining additional
and ASMs in this book
design concepts.
lers who have differing
look past these distinc-
lot found elsewhere. I
he first quarter century
are, and how transient

Logical. Just look at the
'description languages

pect whatever they be-
iplicit style Verilog.

xxix



dedicated to the memory of my father,
:ordon William Arnold,
)uragement and sense of humor
last year of his life stimulated

e writing of this book.
ew as a wonderful dad,
and I cherished him.



1. WHY VERILOG
COMPUTER DESIGN?

1.1 What is computer design?
A computer is a machine that processes information. A machine, of course, is some
tangible device (i.e., hardware) built by hooking together physical components, such
as transistors, in an appropriate arrangement. Processing occurs when the machine fol-
lows the steps of a mathematical algorithm. Information is represented in the machine
by bits, each of which is either 0 or 1. This book only considers digital information
(i.e., bits) and does not consider analog information. Analog information can be ap-
proximated by digital information by using a sufficient number of bits.
Computer design is the thought process that arrives at how to construct the tangible
hardware so that it implements the desired algorithm. The goal is to turn an algorithm
into hardware. Computer designers have two ways to look at the machines they build:
the way they act (known as the behavioral viewpoint, which is closely related to algo-
rithms), and the way they are built (known as the structuralv iewpoint, which is like a
"blueprint" for building the machine).

1.1.1 General-purpose computers
When you say the word computer today, it brings to mind what we refer to as a general-
purpose computer, which you can program with software to implement any algorithm.
With a general-purpose computer it is not necessary to build a new machine to imple-
ment each new algorithm. Programming such a general-purpose machine is often done
with a conventional high-level language, such as C, C++, Java or Pascal.

1.1.2 Special-purpose computers
If you accept the definition of a computer given in section 1.1 , there are many kinds of
machines that fit this description in addition to general-purpose computers. We will
refer to these other kinds of machines as special-purpose computers, which are non-
programmable machines that implement one specific algorithm. A general-purpose
computer is actually like a special-purpose computer that implements one algorithm,
known as fetch/execute, that interprets a software program. The fetch/execute algo-
rithm is fairly complex, so it is easier to study computer design by first looking at how
simpler algorithms (than fetch/execute) can be transformed into hardware. For example,
a traffic light is controlled by a machine that indicates when different colored lights are

Why Verilog Computer Design? I



to be turned on. This machine is not programmable. Once it is designed, it always does multane
the same boring thing: green, yellow, red, green, yellow, red, ... Nevertheless, by the Colossu
above definition, it is a computer. It follows a particular (although boring) algorithm. the mat]
Special-purpose computers are ubiquitous because, in large volumes, it is more eco- puter, a
nomical to manufacture a special-purpose computer that implements one boring algo- Mark I,
rithm than to purchase a general-purpose computer and waste most of its capabilities 1948.
on that boring algorithm. However, for small volumes, or for problems where the speci- 194
fications change frequently (such as tax accounting), the software approach is more In the I
economical. only lar
There are only a handful of general-purpose computers on the market, and so there are advance
not many jobs for designers for these popular machines. On the other hand, many non- vacuum
computer industries use special-purpose computers as parts for the products they manu- tages th
facture, and so job opportunities exist for designers of special-purpose machines. Also, This, of
special-purpose computers play a role in the peripheral devices, such as modems, that tions co
attach to general-purpose computers. tal desil

bits. De
hand-he

1.2 A brief history of computer/digital technology econor
The history of computer design highlights two things: changing technologies and last- In the 1
ing concepts. It is important to make a distinction between a concept and a technology. on a ci
Information and algorithms are mathematical concepts that exist regardless of the physi- Interai
cal details of their implementation with a particular technology. Many of the algo- powe 
rithms used in computers today were discovered by the great minds of mathematics cidei
decades or centuries ago.
Almost four centuries ago, Blaise Pascal (for whom the language is named) built one of Since t
the first mechanical calculators (which required a great deal of human intervention to gies. It 
operate). Pascal is remembered today however because he discovered several interest- chips c(
ing algorithms, such as "Pascal's triangle," which are still in common use. A century But the
and a half ago, Charles Babbage succeeded in using the technology of his day (preci- mented
sion cams and gears) to build the first fully automatic special-purpose computer for
tabulating mathematical functions. Babbage also envisioned a general-purpose ma-
chine (with its fetch/execute algorithm) but was unable to complete it due to financial 1.3
difficulties.

In the bn
The invention of the vacuum tube was the technological advance that made building hardwa
computers affordable. For a fraction of the cost of a machine built with cams and gears, and 19(
a vacuum tube computer could automatically carry out hundreds of algorithm steps in needs n
a second. During the 1930s, C. Wynn-Williams in Great Britain built the first binary less km
counter with vacuum tubes and the team of John Atanasoff and Charles Berry at Iowa of softv
State University built the first vacuum tube special-purpose computer for solving si-

2 2V erilog Digital Computer Design: Algorithms into Hardware



W

signed, it always does multaneous equations. During World War II, several computers were built, including
. Nevertheless, by the Colossus (in Great Britain), which was used to break coded German messages. In 1945,
gh boring) algorithm. the mathematician John von Neumann popularized the idea of a general-purpose com-
lumes, it is more eco- puter, and his name is often synonymous with a machine that implements the fetch/
ients one boring algo- execute algorithm. The first operational general-purpose computer was the Manchester
nost of its capabilities Mark I, which was a vacuum tube machine built in England that ran its first program in
)lems where the speci- 1948.
rare approach is more In the 1950s, general-purpose vacuum tube computers cost millions of dollars, and

only large corporations and governments owned them. The next major technological
arket, and so there are advance came with the invention of the transistor, which can do the same thing that a
fther hand, many non- vacuum tube can do faster and more economically. Transistors also have the advan-
e products they manu- tages that they run cooler and have a longer life than vacuum tubes.
rpose machines. Also, This, of course, lowered the cost of general-purpose computers so that smaller corpora-
such as modems, that tions could own them, but it also made the application of digital design practical. Digi-

tal designs are special-purpose computers built using electronic circuits that process
bits. Devices like digital watches, digital microwave oven timers, digital thermostats,
hand-held calculators, etc. are all controlled by special-purpose computers that became

-hnology economical with the invention of the transistor and related digital electronics.

technologies and last- In the 1960s, it became possible to manufacture hundreds or thousands of transistors
cept and a technology. on a chip of semiconductor material, known as an integrated circuit, at very low cost.
egardless of the physi- Integrated circuits made it possible to mass-produce general-purpose computers, as
,y. Many of the algo- well as digital electronic chips. Special- and general-purpose computers are now so
ninds of mathematics powerful and affordable that they are part of almost every complex device built, from

children's toys to the space shuttle.

is named) built one of Since the 1960s, there have been continual improvements in semiconductor technolo-
human intervention to gies. It is now possible to get millions of transistors on a single chip. Of course, today's
vered several interest- chips cost a fraction of the price of, and run faster and cooler than, their predecessors.
mmon use. A century But the algorithms that these chips implement are similar to the algorithms imple-
ogy of his day (preci- mented with earlier technologies.
purpose computer for
general-purpose ma-

lete it due to financial 1.3 Translating algorithms into hardware
In the beginning, hardware designers were programmers and vice versa. The world of

ce that made building hardware design and software design fragmented into separate camps during the 1950s
t with cams and gears, and 1960s as advancing technology made software programming easier. The industry

of algorithm steps in needs many more programmers than hardware designers and programmers require far
i built the first binary less knowledge of the physical machine than hardware designers. Despite this, the role
Charles Berry at Iowa of software designers and hardware designers is essentially the same: solve a problem.
mputer for solving si-

Hardware Why Verilog Computer Design? 3



Although many hardware designers realized in the 1960s and 1970s that their primary known a,
job was to develop an algorithm that solves a problem and translate that algorithm into This boo
hardware, some hardware designers lost sight of this essential truth. describe:
An early notation for describing digital hardware that provides tremendous clarity in Ultimate
this regard is the Algorithmic State Machine (ASM), which was invented in the early tive abot
1960s by T.E. Osborne. As the name suggests, the ASM notation emphasizes the algo- compute
rithmic nature of the machines being designed. Chapter 2 explains the ASM notation, about the
and how it can be used manually to translate an algorithm into hardware. This notation and ASN
is used throughout the rest of this book.

1.5
1.4 Hardware description languages Fonts an
Unfortunately, hardware designers were inundated with the overwhelming technologi- below:
cal changes that occurred with semiconductor electronics. Many hardware designers
lost track of the advances in design methodology that occurred in software. Around
1980, as semiconductor technology advanced, it got more and more difficult to design
hardware. Up to that time, most hardware design was done manually. Designers real-
ized that the ever-increasing power of general-purpose computers could be harnessed
to aid them in designing the next generation of chips. The goal of using the current
generation of general-purpose computers to help design the next generation of special-
and general-purpose computers required bringing the worlds of hardware and soft-
ware back together again.

Out of this union was born the concept of the Hardware Description Language (HDL).
Being a computer language, an HDL allows use of many of the timesaving software
methodologies that hardware designers had been lacking. But as a hardware language,
the HDL allows the expression of concepts that previously could only be expressed by
manual notations, such as the ASM notation and circuit diagrams.
As technology advances, the details about HDLs will undoubtedly change in the fu-
ture, but studying an HDL instills fundamental concepts that will endure. These ideas,
originally thought of as hardware concepts, are becoming more important in software
due to the increased importance of software parallel processing and object-oriented
programming. There is a deep theoretic similarity between the concepts in software
fields (such as operating systems and data structures) and the concepts in computer
design. The growing popularity of HDLs attest to this fact: hardware is becoming
more like software, and vice versa.

Chapter 3 discusses a popular HDL, known as Verilog, which is easy to learn because
it has a syntax similar to C and Pascal. Verilog was developed in the early 1980s by
Philip Moorby as a proprietary HDL for a company that was later accquired by Ca-
dence Design Systems, which put the Verilog standard into the public domain. It is now

4 Verilog Digital Computer Design: Algorithms into Hardware



1970s that their primary known as IEEE 1364. Verilog is used together 
slate with 

that ASM 
algorithm charts 

into in the rest of this book.
This book is not just about Verilog or 

truth. ASM charts for their own sake; this book also
describes how these notations illuminate the thought processes of a computer designer.

,s tremendous clarity in Ultimately, computation takes place on hardware. As children, all of us were inquisi-
'as invented in the early tive about everything: "How does this work?" Even if you do not plan on becoming a
)n emphasizes the algo- computer designer, it seems reasonable that you should be able to answer that question
lains the ASM notation, about the machines that are at the heart of your chosen career. The power of the Verilog
hardware. This notation and ASM notations give us insight for answering this question.

1.5 Typography
Fonts are used in this book to distinguish between different kinds of text, as explained

-rwhelming technologi- below:
iny hardware designers Times is used in 
ed the 

in bulk 
software. of the text 

Around for
discussion.

more difficult to design
inually. Designers real- Bold Times is used to emphasize important
ters could be harnessed or surprising concepts.
al of using the current Italic is used for 

Lt the 
generation definition 

of special- of an
important term 

of or 
hardware phrase.

and soft-
Courier is used for Verilog text, exactly

as it is typed 
ption into 

Language the file, 
(HDL). and

he for 
timesaving similar notations 

software taken from
ASM charts, 

is a hardware hardware 
language, dia-

grams, and simulation 
Id only results.

be expressed by This font is 
Ms. also used for parts

of other high level languages,
tedly change in the fu- such as C.
'ill endure. These ideas,

Bold Courier is used for parts of Verilog 
e important text

in software
ing and that 

object-oriented are important in the discus-
sion that precedes 

ie concepts or follows
in software them.

concepts in computer
hardware is becoming Italic Courier is used to describe parts of

Verilog syntax, such as a
is easy to learn because statement, which can be re-

placed 
d in the early with 

1980s some 
by particular

symbol, such 
later as while. 

accquired Also,
by Ca-

it is used 
public domain. to highlight 

It is now complex
simulation results.

9H ardware
Why Verilog Computer Design? 5



1.6 Assumed background 17
It is assumed that the reader has a reasonable amount of experience programming in a
conventional high-level language, such as C, C++, Java or Pascal. Programming expe-
rience in assembly language (appendices A, B and G) is very helpful. It is assumed that
the reader can understand binary, octal and hexadecimal notations, can convert these to
and from decimal and can perform arithmetic in these bases. It is also assumed that the
reader is familiar with the common combinational logic gates (AND, OR, NOT, etc.),
and that the reader knows about the common digital building blocks used in digital
design (appendices C, D and E).

1.7 Conclusion
The few computers built in the nineteenth century were based on classical mechanics
(cams and gears visible to the naked eye). Almost all the computers built in the twenti-
eth century have been based on electronics. It is hard to say what technologies will be
prevalent for computers in the twenty-first century.

Conventional semiconductor technology will someday reach its limit (based on the
minimum size of a transistor and the speed of light). Technologies based on recombinate
DNA, photonics, quantum mechanics, superconductivity and nanomechanics (cams
and gears built of individual atoms) are all contenders to be the computer technology of
the twenty-first century. The point is that it does not matter: technology changes every
day, but concepts endure. The intellectual journey you travel by turning an algorithm
into hardware illustrates these enduring concepts. I hope you enjoy the journey!

6 Verilog Digital Computer Design: Algorithms into Hardware



ience programming in a 2- DESIGNING ASMs
cal. Programming expe-

This chapter explains the graphical 
-lpful. It is assumed notation 

that used throughout the rest of this book. This
graphical 

)ns, can notation 
convert helps 

these a hardware 
to designer working only with pencil and paper. Chap-

ters 4 and above 
is also require 

assumed that 
that the 

the reader understand the notation explained in this chap-
ter. Chapter 3 describes an 

(AND, alternative 
OR, NOT, textual 

etc.), notation, known as Verilog, more suitable
for automation 

gbl ocks (computer-aided 
used in digital design), where software tools help the designer pro-

duce a correct machine. The reader of this book will acquire a thorough understanding
of both the notation in chapter 3 and the notation in this chapter, but we begin at the
beginning with the most important question a hardware designer can ask: "How do I
write down the particular algorithm that the hardware is supposed to follow?"

on classical mechanics 2.1. What is an ASM chart?
uters built in the twenti- An Algorithmic State Machine (ASM) chart is a flowchart-like notation that describes
hat technologies will be the step-by-step operations of an algorithm in precise units of time. ASM charts are

useful when you want to design hardware that implements some particular algorithm.
its limit (based on the The ASM chart can describe the behavior of the hardware without having to specify

es based on recombinate particular hardware devices to implement that algorithm. This allows you to make sure
I nanomechanics (cams that the algorithm is correct before choosing an interconnection of particular hardware
computer technology of ("a structure") that implements the behavior described by the ASM. The most serious
chnology changes every errors in hardware design do not result from connecting wires to the wrong place ("bad
by turning an algorithm structure") but instead are the fault of designers not thinking through their algorithms
rnjoy the journey! completely ("bad behavior"). Designing a hardware structure is much more expensive

than describing its behavior, and so it is sensible to spend extra time on the behavioral
ASM chart before considering how to implement it with a hardware structure.
Although an ASM chart looks similar to a conventional software flowchart, the inter-
pretation of an ASM chart differs from a conventional software flowchart with regard
to how the passage of time relates to the operation of the algorithm. In software, the
exact amount of time from one algorithm step to the next is not explicitly described by
a flowchart. In the ASM chart, each step of the algorithm takes an exact amount of
time, known as the clock period or clock cycle. There are also other time-related dis-
tinctions in the ASM chart notation which are described later.
An ASM chart is composed of rectangles, diamonds (or equivalently diamonds can be
drawn as hexagons for notational convenience), ovals and arrows that interconnect the
rectangles, diamonds and ovals. ASM charts composed only of rectangles and dia-
monds are said to describe Moore machines. ASM charts that also include ovals are
said to describe Mealy machines. Mealy machines are described in chapter 5, and some

to Hardware Designing ASMs 7



of the more advanced concepts in chapter 7 and chapters 9 and above require the reader
to understand Mealy notation. At this time, we For 

will exm
ignore the use of ovals and concen-

trate only on ASM charts for Moore machines. YELL(

Each rectangle is said to describe a state. A The 
label, fol

such as a number or preferably a
meaningful name, can be written on the outside chart, 

of the tI
rectangle. The term present state

refers to which rectangle of the ASM chart is connec
active during a particular clock period.

The term next state indicates which rectangle of Althou,
the ASM chart will be active during

the next clock period. The ASM chart indicates troller,
how to determine the next state (given

the present state) by an arrow that points from tended
the rectangle of the present state to the

rectangle of the next state. Each arrow eventually arrives at one of the rectangles in the
ASM chart. Since it has a finite number of rectangles, there is at least one loop in an 2.1.1
ASM chart. An ASM chart is said to describe a particularfinite state machine. Unlike Normal
software, there is no way to stop or halt a finite state machine (unless you pull the a desig
plug). section
There is a relationship between the ASM chart and its behavior. For example, consider
the following ASM chart with three states:

2.1.1.
Asignc

GREEN mation.
gives a
name o
the mai

YELLOW
rectang
an exar

RED

Figure 2-1. ASM with three states.

Assuming that we start in state GREEN, and that the clock has a period of 0.5 seconds,
the ASM chart will make the following state transitions forever:

present next
time state state
0.0 GREEN YELLOW
0.5 YELLOW RED
1.0 RED GREEN
1.5 GREEN Figt4

YELLOW
2.0 YELLOW RED
2.5 RED GREEN

STOP,;
the ASI

8 Verilog Digital Computer Design: Algorithms into Hardware



bove require the reader ple, between 0.5 and 1.0, the ASM is in state YELLOW. It is again in state
se of ovals and concen- I between 2.0 and 2.5.

wing sections explain the commands that can occur in rectangles of an ASM
iumber or preferably a decisions that can occur in diamonds of an ASM chart, the input and output
.The term present state ns to a machine described by an ASM chart and issues of ASM chart style.
,articular clock period. the examples in the following sections vaguely resemble a traffic light con-
rt will be active during ey are not intended to solve such a practical problem. They are instead in-
ne the next state (given lely to illustrate ASM chart notation and style.
the present state to the
of the rectangles in the
at least one loop in an ASM chart commands
state machine. Unlike the rectangle for a state is not empty. There are three command notations that

te (unless you pull the r can choose to put inside the rectangle, which are described in the following

For example, consider
Asserting a one-bit signal

s a bit (or as explained in section 2.1.1.2, a group of bits) that conveys infor-
.signal is transmitted via a wire (or similar physical medium). The designer
final (and its corresponding wire) a name to document its purpose. When the
signal occurs inside a rectangle of an ASM chart, that signal is asserted when
ne is in the state corresponding to the rectangle in question. In other state
;, where that signal is not mentioned, that signal takes on its default value. As
le, assume the default value for the signal STOP is 0. In the following:

GREEN F| 1

I I
YELLOW

period of 0.5 seconds, STOP

RED
STOP

2-2. ASM with command outputs.

1 be 1 when the ASM is in state RED or state YELLOW. STOP will be 0 when
is in state GREEN. The following illustrates this situation:

7H ardware
Designing ASMs 9



present next
time state state
0.0 GREEN YELLOW STOP=0

0.5 YELLOW RED STOP=1
1.0 RED GREEN STOP=1
1.5 GREEN YELLOW STOP=0
2.0 YELLOW RED STOP=1
2.5 
... RED 

... GREEN 
... STOP=1

...

2.1.1.2 Outputting a multi-bit command
When the name of a signal is on the left of an equal sign (=) inside a rectangle, 
signal that

takes on the value specified on the right of the equal sign during the state corre- Figu
sponding to the rectangle in question. In other state rectangles, where that signal is not
mentioned, that signal takes on its default value.

In the a
The following two diagrams show ASM charts that use =. The first of these ASMs 
equivalent is

to the ASM given in section 2.1.1. The second example introduces a two-bit
bus SPEED whose default value is 00.

GREEN

YELLOW

2.1.1.3
The lasi

RED physica
uses foi
describe

Most all
Figure2 -3. Equivalent tofigure 2-2. comput

signer v
such ter
decisior
by an ar
at the be
left of a
clock c)

10 Verilog Digital Computer Design: Algorithms into Hardware



- -
GREEN 

m
OP=o SPEED =3
oP=1
'OP=1
OP=O YELLOW
)P=1 STOP
)P=1 SPEED=1 ]

RED [ STOP

inside a rectangle, that
during the state corre- Figure 2-4. ASM with multi-bit output.

where that signal is not
In the above, SPEED is 0 in state RED, 1 in state YELLOW and 3 in state GREEN.

first of these ASMs is
ple introduces a two-bit

present next output
time state state
0.0 GREEN YELLOW STOP=0 SPEED=11
0.5 YELLOW RED STOP=1 SPEED=01
1.0 RED GREEN STOP=1 SPEED=00
1.5 GREEN YELLOW STOP=0 SPEED=11
2.0 YELLOW RED STOP=1 SPEED=01
2.5 RED GREEN STOP=1 SPEED=00
... ... ... ... ...

2.1.1.3 Register transfer
The last two notations are simply a way of indicating how state names translate into
physical signals, such as STOP and SPEED. Although we will eventually find many
uses for these two notations, they are by themselves not the most convenient way to
describe an algorithm.

Most algorithms manipulate variables that change their values during the course of the
computation. It is necessary to have a place to store such values. Eventually, the de-
signer will choose some kind of synchronous hardware register (appendix D) to hold
such temporary values. In ASM chart notation, it is not necessary to make this design
decision in order to describe an algorithm. Register Transfer Notation (RTN) (denoted
by an arrow inside a rectangle) tells what happens to the register on the left of the arrow
at the beginning of the next clock cycle. If a particular register is not mentioned on the
left of an arrow in a state, the value of that register will remain the same in the next
clock cycle. For example,

PH ardware Designing ASMs 11



I
GREEN

SPEED=3 1
YELLOW STOP

SPEED=1
COUNT- COUNT+1

I
I

RED
STOP

COUNT- COUNT+2
I 

Figure 2-5. ASM with register output.

in the above assume that a three-bit COUNT register is 000 at time 0:
present next

time state state
0.0 GREEN YELLOW STOP=0 SPEED=11 COUNT=000
0.5 YELLOW RED STOP=1 SPEED=01 COUNT=000
1.0 RED GREEN STOP=1 SPEED=00 COUNT=001
1.5 GREEN YELLOW STOP=0 SPEED=11 COUNT=011
2.0 YELLOW RED STOP=1 SPEED=01 COUNT=011
2.5 RED GREEN STOP=1 SPEED=00 COUNT=100
... ... ... ... ... ...

Unlike STOP and SPEED, COUNT is not a function of the present state.
whenever the ASM is in state GREEN, STOP is 0. The first time in s1
COUNT is 000, but the second time in state GREEN, COUNT is 011.

Notice that the - causes a delayed assignment, which is different thai
with conventional software programming languages, such as C. This is
distinction to keep in mind when designing ASM charts. One of the i
that reoccurs throughout this book is the consequence of designing
that use this kind of delayed assignment. Although at first a novice 
find <- unnatural and may make mistakes because of a misunderstanding
the reader masters the concept of this delayed assignment, all of the advar
in later chapters will become much more understandable.

2.1.2 Decisions in ASM charts
One or more diamonds (or hexagons) following a rectangle indicate a d
ASM chart. The decision inside the diamond occurs at the same time as ti

12 Verilog Digital Computer Design: Algorithms into Hardwa



described in the rectangle. There are two kinds of conditions that a designer can put
inside a diamond in an ASM chart. These decisions are described in the following
sections.

2.1.2.1 Relations
Relational operators ( ==, <, >, <=, >=, != ) as well as logical operators (&&, II,!) can
occur inside a diamond. It is also permissible to use the shorter bitwise operators (&,I,^,-)
inside a diamond when all of the operands are only one-bit wide. When the relation in
the diamond involves registers also used in the rectangle pointing to that diamond, the
action taken is often different than would occur in software. Because the decision in the
diamond occurs at the same time as the operations described in the rectangle, you
ignore whatever register transfer occurs inside the rectangle to decide what the next
state will be. The register transfer is an independent issue, which will only take effect at
the beginning of the next clock cycle. As a illustration of such a decision, consider:

rNT=000 4
GREEN

NT=000 SPEED=3 ]
FNT=001
rNT=011
rNT=011 YELLOW STOP
NT=100 SPEED=1 I

COUNT- COUNT+1

ant state. For example,
time in state GREEN,
is 0 1.

erent than assignment
RED

. This is an important STOP
of the central topics COUNT CUNT+2
designing algorithms ,

novice designer may
,rstanding of A-, Figure 

once 2-6. ASM with decision.

the advanced concepts

At first glance, it might appear that the ASM will get stuck in the loop the first time the
machine enters state YELLOW because COUNT+1 is 001. However the decision
COUNT != 0 is based on the current value of COUNT, which 

licate remains 
a decision 000 

in until 
an the

beginning of the next clock cycle. Therefore 
time the ASM exits 

as the from 
operations state YELLOW and

proceeds to RED. On the second time the machine enters state YELLOW, COUNT is
01 1, and so it stays in state YELLOW for six clock periods. The only reason the ASM
ever leaves state YELLOW is because the three-bit COUNT wraps around from 7 to 0.

Hardware
Designing ASMs 13



present next
M4mo -i->F c--

|IL[.a   U t1! GREE!
0.0 GREEN YELLOW STOP=0 SPEED=11 COUNT=000
0.5 YELLOW RED STOP=1 SPEED=01 COUNT=000
1.0 RED GREEN STOP=1 SPEED=00 COUNT=001
1.5 GREEN YELLOW STOP=0 SPEED=11 COUNT=011
2.0 YELLOW YELLOW STOP=1 SPEED=01 COUNT=011
2.5 YELLOW YELLOW STOP=1 SPEED=01 COUNT=100
3.0 YELLOW YELLOW STOP=1 SPEED=01 COUNT=101 YELLOV
3.5 YELLOW YELLOW STOP=1 SPEED=01 COUNT=110
4.0 YELLOW YELLOW STOP=1 SPEED=01 COUNT=111
4.5 YELLOW RED STOP=1 SPEED=01 COUNT=000
5.0 RED GREEN STOP=1 SPEED=00 COUNT=001
... ... ... ... ... ...

The highlighted line shows the last time the ASM is in state YELLOW. The next state
is RED because COUNT is 000. REI

2.1.2.2 External status Fi
Many hardware systems are composed of independent actors working cooperatively
but in parallel to each other. We use actor as an ambiguous term that incorporates other
digital hardware (i.e., special- and general-purpose computers) as well as non-digital The at
hardware and people who communicate with the machine described by an ASM chart. WALE
From a designer's standpoint, the details of the other actors are normally unimportant. When
These actors need to send information to the machine described by the ASM chart. The m
When such external information can be represented in only one bit, it is known as
external status. (Multi-bit signals can be broken down into several single-bit status 2.1.3
signals if desired.) External status signals have names that are simply labels for physi- AnAS
cal wires connecting the machine that implements the ASM chart to the outside world. its inte
By convention, the name of a status signal can occur by itself inside a diamond. The structu
meaning of such a diamond is the same as testing if the status signal is equal to one. For provid
example, larger

inputs
are eit
ASM

In add
gram i
ments
descril

14 Verilog Digital Computer Design: Algorithms into Hardware



GREEN
9T=000
9T=000
qT=001
NT=011
UT=011
UT=100
.T=101

1T=110 YELLOW
9T=111
IT-000
qT=001

,LOW. The next state
RED

working cooperatively Figure2 -7. ASMs with external status.
hat incorporates other
is well as non-digital The above ASMs are equivalent to each other. They will stay in 
)ed state 

by an GREEN 
ASM chart. until

WALKBUTTON is 1 during the last clock period that the ASM is in state GREEN.
Ormally unimportant. When WALKBUTTON is 1 in state GREEN, the next state will be state YELLOW.
d by the ASM chart. The machine ignores WALKBUTTON when it is in state YELLOW or in state RED.
te bit, it is known as
reral single-bit status
nply 2.1.3 

labels Inputs 
for physi- and outputs of an ASM

:t o the outside world. An ASM chart describes the behavior of a piece of digital hardware without specifying
its 

iside internal 
a diamond. structure. 

The The machine described by an ASM chart is often part of a larger
al is equal to one. For structure. The machine receives inputs from other actors in that larger structure and

provides outputs to other actors in that larger structure. In order to be part of such a
larger structure, the machine described by an ASM chart must have a limited set of
inputp orts (to receive information) and output ports (to send information). These ports
are either single wires or buses having names that correspond to names used in the
ASM chart.

In addition to its ASM chart, we can draw a block diagram of a machine. Such a dia-
gram is sometimes called a black box because it hides the internal structure that imple-
ments the machine. The only thing we know is that the behavior of the machine is
described by the corresponding ASM, and that the machine has inputs as specified by

hardware DesigningASMs 15



arrows pointing into the black box, and outputs as specified by arrows pointing out of being i
the black box. As is standard notation in all hardware structure diagrams, when the 2-9 shc
input or output ports are more than one bit wide, the width is specified by a slash. left tree
The following is a block diagram of the machine described by the ASM chart in 2.1.2.2: o three

WALKBUTTON STOP C- 
EXAMPLEl 

ASM 7'SPEED| 

COUNT

Figure 2-8. Block diagram. NO

2.1.3.1 ASM inputs
There are two kinds of inputs to a machine described by an ASM chart and black box
diagram. It is somewhat arbitrary which of these two approaches a designer uses. The
designer is free to choose the way that seems most appropriate for the problem at hand.
It is permissible for a designer to mix these two approaches in a particular ASM. Since BLO,
it plays a role later in the design process, the distinction between these two kinds of
inputs is important to note.

2.1.3.1.1 External status inputs 3
A designer may consider a one-bit input port as an external status input when it is
mentioned only by itself in diamond(s). Such status inputs are usually interpreted as
providing an answer from the outside world to some yes/no question, such as "has the
button been pressed?" As an example, in the block diagram above in section 2.1.3, Fig
WALKBUTTON is the only external status input.

It isn 
2.1.3.1.2 External data inputs easier
When an input of any width is used only on the right-hand side of register transfers in must l
rectangles and/or only in relational decisions, it is considered an external data input.
Such data inputs usually play the same role that input variables play in conventional In the
programming languages.

It is arbitrary whether the designer wishes to consider a one-bit input as a status or data 2.1.3
input, as was illustrated in section 2.1.2.2. When a multi-bit input is used only with There
relational operations in diamonds (and not on the right of register transfers in rect- box d
angles), a designer may consider such a multi-bit input as being composed of several based
status input bits. For example, consider a machine with an external three-bit data input comnr
A. At some point in the behavior of the machine, the ASM needs to test if the value distin

16 Verilog Digital Computer Design: Algorithms into Hardware



arrows pointing out of being input to the machine from the outside world on the bus A is equal to two. Figure
e diagrams, when the 2-9 shows the block diagram and two equivalent ASM charts. The ASM chart on the
ecified by a slash. left treats A as a single data input, but the ASM on the right treats A as being composed
ASM chart in 2.1.2.2: of three status inputs (A[21, A[1] and A[O]).

NT

4 chart and black box
; a designer uses. The
r the problem at hand.
)articularA SM. Since BLOCK DIAGRAM
an these two kinds of

A EXAMPLE
3 MACHINE

atus input when it is
usually interpreted as
tion, such as "has the
love in section 2.1.3, Figure 2-9. Two ways to test multi-bit input.

It is natural for designers to treat yes/no information as status. In most other cases, it is
easier for the designer to consider something as a data input than to consider it as a

ifr egister transfers in status input, as the above ASMs illustrate. Inputs used on the right of register transfers
i external data input. must be treated as data inputs.
play in conventional In the block diagram above in figure 2-8, there are no external data inputs.

put as a status or data 2.1.3.2 ASM outputs
)ut is used only with There are two kinds of outputs from a machine described by an ASM chart 
;ter and 

transfers black
in rect- box diagram. Unlike the two kinds of inputs, with outputs the designer 

composed makes 
of a choice

several based on how the output is generated in the ASM. From that point on, 
l three-bit the designer 

data input is
committed to that kind of output. Since it plays a role later in the design process, 

Is to test the
if the value distinction between these two kinds of outputs is important to note.

hardware Designing ASMs 17



2.1.3.2.1 External command outputs Arbitt
External command outputs are generated as described in sections 2.1.1.1 and 2.1.1.2. mostly
They are a function only of the present state of the ASM (assuming, as we have been so analol
far, that ovals are not present in the ASM so that it represents a Moore machine). Com- ware.
mand outputs do not retain their value when changing from one state to the next. If a staten
particular command output is not mentioned in the next state, it reverts to its default is ted
value. In the block diagram given in section 2.1.3, the external command outputs are the gc
STOP and SPEED. ling n

2.1.3.2.2 External data outputs 2.1.5
External data outputs are register names mentioned on the left of a register transfer in at There
least one rectangle. Unlike command outputs, data outputs can retain their value when the bc
changing from one state to the next. If a particular data output is not mentioned in the solve!
present state, it continues to hold its current value during the next state. Not all registers The d
used in an ASM are necessarily output by the ASM. If a register is not specified as an soluti
output from the block diagram, it is an internal register, which the outside world is not perfect
allowed to examine (because no bus has been provided to connect that register to the as fit
outside world.) The only external data output of the block diagram in section 2.1.3 is time,
COUNT. tem.

The o
2.1.4 Goto-less style the dc
ASM charts allow a designer to specify an arbitrarily complex set of decisions to deter- has a
mine the next state. In theory, the possible next states for a particular state could be any is not
of the rectangles in the ASM chart. Of course, in every particular case (based on regis-to Wo
ter values and status inputs during that clock period), the ASM deterministically de- thing
scribes a particular next state to which the ASM goes in the next clock period. The alrea(
problem for a careless designer is that the number of possible next states to consider solve
could be quite large if the ASM is large. The flaw here is not in the technical capability the 
of ASM di

charts (and corresponding hardware) to correctly implement such complex usefu
decisions, but rather in the capability of designers to comprehend their designs. ntop-d
Similar problems were encountered decades ago in software design. At that time, the
high-level language goto statement was quite popular. Psychological studies have We 
shown that people are only able to keep a few details in their short-term memory at any
time. Using goto statements correctly requires that a designer remember too many
details when the program gets to be of any size. Dijkstra popularized the idea in 1968
that software programmers should avoid the use of goto statements in order to make This
software more readable, and more likely to be correct. ters c

scribe
only

18 Verilog Digital Computer Design: Algorithms into Hardware



W M I I

Arbitrary next states in a flowchart are just like go tos in software. Therefore, we will
ins 2.1.1.1 and 2.1.1.2. mostly use "got o-less" style ASM charts. Such ASMs are limited to decisions that are
ng, as we have been so analogous to the high-level language style that is nowadays standard practice in soft-
voore machine). Com- ware. In other words, we will try to make our decisions act like high-level language i f
e state to the next. If a statements, and our loops act like high-level language while statements. Although it
it reverts to its default is technically possible to make an ASM chart look like a plate of spaghetti, the goal of
command outputs are the got o-less style is to avoid such a mess. On rare occasions, there may be a compel-

ling need to use an ASM chart which violates the goto-less style.

2.1.5 Top-down design
a register transfer in at There are two basic approaches to solving problems: bottom up and top down. With
etain their value when the bottom-up approach, the designer begins with some tiny detail of the problem and
s not mentioned in the solves that detail. The designer then goes on to some unrelated tiny detail, and solves it.
ts tate. Not all registers The designer will eventually have to "glue" the details together to form the complete
r is not specified as an solution. On large problems, bottom-up designed pieces usually do not "fit" together
ie outside world is not perfectly. This problem happens because the designer did not view the separate details
iect that register to the as fitting into some master plan. An unreasonably large percentage of the designer's
ram in section 2.1.3 is time at the end of the project is wasted on integrating the details into a complete sys-

tem.

The opposite of the bottom-up approach is top-down design. In the top down approach,
the designer starts with a master plan. The details come later, and because the designer

Ito f decisions to deter- has a master plan, the details will fit perfectly into the final solution. Top- down design
ular state could be any is not natural for novice designers. If you have never built hardware before, it is natural
r case (based on regis- to worry about how the details will work (voltages, wires, gates, etc.). Leaming some-

deterministically de- thing new is a mostly bottom-up process, but experienced designers use what they have
ext clock period. The already learned in a top-down fashion. Top-down design is based on faith: you have
iext states to consider solved details similar to those in your current problem before, and so you can ignore
ie technical capability the details when you begin the solution to the current problem. An ASM chart is a
cement such complex useful notation for describing the overall actions of a hardware system without getting
id their designs. into the hardware details. Therefore, the ASM chart makes a good starting point for the

top-down design process.
sign. At that time, the
iological studies have We will take the top-down design process through three stages, briefly described in the
rt-term memory at any following subsections (2.1.5.1 through 2.1.5.3).
rr emember too many

rized the idea in 1968 2.1.5.1 Pure behavioral
ients in order to make This is the most important stage. It is the stage that most of the examples in later chap-

ters concentrate on. In this stage of the top-down design process, the machine is de-
scribed with a single ASM chart using primarily RTN and relational decisions. The
only differences between the pure behavioral solution and a software solution is that

Hardware Designing ASMs 19

t



the ASM chart describes the passage of time relating to the hardware system clock (as cepts
explained in sections 2.1.1 and 2.1.2) and the machine described by the ASM chart tis fa
connects to the external world via hardware ports (section 2.1.3). A practical example in an
of taking a simple problem and exploring various solutions using pure behavioral ASM design
charts is given in section 2.2. The only kind of structure that exists in the pure behav- The cc
ioral stage consists of the input and output ports, as illustrated by the of RT
following: 

output
from t

EXTERNAL EXTERNAL is still
isci

STATUS COMMAND descri
INPUTS OUTPUTS 

MACHINE rather
EXTERNAL about:

EXTERNAL carry 
DATA DATA now 

INPUTS OUTPUTS identi

Figure the cc
2 -10. Pure behavioralb lock diagram.

2.1.5.2 Mixed
A pure behavioral ASM chart is merely the statement of an algorithm with precise
timing information and includes an indication of which operations occur in parallel. It
does not describe precisely what hardware components implement the computation.
The goal of computer design is to arrive at a "blueprint" of a physical machine. The
pure behavioral ASM chart is merely a description of what the designer wants the
machine to do. It does not tell how to connect the physical components together. Soft- ,
ware people wonder why the problem is not done upon completing the behavior ASM.
After all, we do have a solution (an algorithm). Hardware people wonder why we
spend so much time with ASM charts. After all, we do not yet have a solution (physical Fi
hardware). The answer to both groups is: have patience. The pure behavioral stage is
important because it enhances the likelihood the designer will produce a correct solu-
tion. The next stage, which is known as the mixed stage, accomplishes part of the trans- Ath(
formation from the algorithm into a physical hardware structure. more
The mixed stage of the top-down design process partitions the problem into two sepa- for t
rate but interdependent actors: the controller and the architecture. The architecture natio
(sometimes called the datapath) is the place where physical hardware registers will mixe
implement the register transfers originally conceived in the pure behavioral stage. The has t
architecture also contains combinational logic circuits that perform computations re- tectu
quired by the algorithm. What the architecture cannot do by itself is sequence events andE
according to the master plan given in the behavioral ASM. This is why the controller 2.2 i
exists as an independent actor. The controller tells the architecture what to do during tion
each clock cycle so that the master plan is carried out. Although it may seem the con-
20 Verilog Digital Computer Design: Algorithms into Hardware



dware system clock (as cepts of controller and architecture make things more complicated, in fact working in
ibed by the ASM chart this fashion simplifies the thought process. In theory, it is possible to design a machine
3). A practical example in an extreme way that either has no architecture or has no controller. Such extreme
g pure behavioral ASM designs are as unnatural to think about as software without variable declarations.
dists in the pure behav-
s illustrated by The 

the controller issues commands (as explained in sections 2.1.1.1 and 2.1.1.2) instead
of RTN. The architecture receives and acts upon those commands and responds by
outputting status. The controller makes decisions based on such status signals received
from the architecture (as explained in section 2.1.2.2) instead of relational decisions. It

INAL is still possible to draw an ASM chart at this stage of the design, but the ASM chart only
kND describes the independent action of the controller (in terms of commands and status),
JTS rather than the complete behavior of the system. This is what top-down design is all

about: moving from one master plan 
NAL (the behavioral ASM) to greater detail on how to

carry out the master plan (the mixed ASM). The hardware structure in the mixed stage
TS now has more detail. From the standpoint of the outside world, the mixed stage is

identical to the pure behavioral stage, but internally we now see the interconnection of
the controller and the architecture.

.... .. ... .. ... .. ... .... .. ... .. ... .. ... .. ... .. ... .. .... . ... .. ... .... .. ... .. ... .. ... .. ... .. ... .. ... .. ... .. ......
, MACHINE

lgorithm with precise
ins occur in parallel. It Im I I I I
nent the computation.
)hysical machine. The
ie designer wants the
)onents together. Soft-
ng the behavior ASM.
ople wonder why we
ye a solution (physical
ire behavioral Figure 

stage 2-11. 
is Mixed block diagram.

*oduce a correct solu-
ishes part of the trans-

Although, in theory, the architecture could be described by ASM chart(s), it is usually
more effective to use a hardware structure diagram. This is because a single ASM chart

roblem into two sepa- for the architecture could easily have billions of states (corresponding to all the combi-
ture. The architecture nations of values that all the registers in the system could have). Therefore, at the
Lrdware registers will mixed level of abstraction, we use an ASM chart to describe the controller (which still
behavioral stage. The has the same number of states) but use a hardware block diagram to describe the archi-
)rm computations re- tecture. This stage of the design is known as mixed because it is a mixture of behavior

Jlf is sequence events and structure. Examples of translating some of the pure behavioral solutions of section
is why the controller 2.2 into mixed behavioral controller/structural architecture solutions are given in sec-
ire what to do during tion 2.3.
it may seem the con-

Hardware Designing ASMs 21



2.1.5.3 Pure structure
The final stage of the design process is to implement the ASM chart for the cot
as a hardware structure. This translation from the mixed stage to the pure sti
stage is quite mechanical, and in fact software tools exist that create controlle
ware automatically. One can simply describe the controller as a table that says
the present state and status inputs, what the next state and command outputs 
Various techniques exist to turn such a table into a hardware structure. For ex
such a table can be burned into a Read Only Memory (ROM). The only other ha
required for the controller besides the ROM is a register to hold the present sta
amples of translating some of the mixed ASM charts of section 2.3 into pure str
solutions are given in section 2.4.

2.1.6 Design automation
Synthesis tools exist (chapter 11) that automate much of the final stages of the
process explained above. When using such tools, the designer's job is essentiall
plete at the end of the pure behavioral stage. Many designers skip over the mixe
and go straight to the pure structural stage, from which the synthesis tool can au
cally create the netlist of gates needed to fabricate an integrated circuit.

Nevertheless, it is important for a designer to understand how all these stages
carried out manually in order for the designer to know how to create an efficii
correct design. The remainder of this chapter gives manual examples of the three
described above (pure behavioral, mixed, pure structural). The most important c
stages is the pure behavioral stage because, unless that stage is correct, the res
design process (either manual or automated) is pointless.

2.2 Pure behavioral example
To illustrate the design process for a pure behavioral ASM, we need a simple alE
to implement in hardware. One such algorithm comes from the definition of ur
integer division. This definition is probably the first thing you ever learned abo
sion when you were a child, and so we will refer to the algorithm that derives fri
definition as the childish division algorithm.

By way of illustration, suppose you give a child the following problem: "Yc
seven friends and twenty-one cookies. How can you divide your cookies equally
your friends?" One solution is to give each friend one cookie, and note that eact
received a new cookie. Check to see if there are enough cookies left to give anot
to each person. Since there are, repeat this process. When you are done, you w
noted that each person has received three cookies.

22 Verilog Digital Computer Design: Algorithms into Hardware



The name "childish" may seem pejorative, but this algorithm has a very honored place
hart for the controller in the history of computer design (section 8.1). Like a child, this algorithm is simple
to the pure structure and unpretentious, yet it raises important issues that also apply to much more compli-
reate controller hard- cated algorithms. Variations on the childish division algorithm are used throughout the
table that says, given rest of this book. Even Snoopy can tell whether or not this algorithm has been imple-
nand outputs will be. mented correctly:
,ucture. For example,

zo nly other hardware
the present state. Ex-
.3 into pure structural

I stages of the design
)b is essentially com-
over the mixed stage PEANUTS ©U nited Feature Syndicate. Reprinted by Permission.

sis tool can automati-
circuit. Of course, high-level software languages are sophisticated enough to have integer

division built in. If the variable x is the number of cookies, and y is the number of
11th ese stages can be friends, x/y is the solution to this problem. In hardware, division is seldom imple-
reate an efficient and mented as a combinational logic building block (although for small bus sizes this is
les of the three stages certainly feasible). This means we need to use an ASM chart to describe a division
3st important of these algorithm. There are much more efficient algorithms than this childish algorithm that
orrect, the rest of the are normally implemented in hardware, but the childish division algorithm will allow

us to emphasize the properties of ASM charts without having to get into obscure math-
ematical detail to justify the algorithm. Why this childish algorithm works is obvious.
Before considering the hardware implementation of this childish algorithm, let's con-
sider how to code it in software, such as in the C programming language:

nd a simple algorithm rl = x;
efinition of unsigned r2 = 0;
or learned about divi- while (rl >= y)
that derives from this {

rl = rl - y;
problem: "You have r2 = r2 + 1;

)okies equally among I
note that each friend

ft to give another one Upon exiting from the loop, r2 will be x/y. This is a slow algorithm when the answer
done, you will have r2 is of any appreciable size because the loop executes r2 times.

This software algorithm would still work when the statements inside the loop are in-
terchanged. These two statements are independent of each other (the new value of r1
does not depend on the old value of r2 and vice versa):

hardware
DesigningA SMs 23



r
r
w

2.2.1 A push button interfac
Before we can put the childish divisic
sider how the eventual hardware will
will assume the only other actor is a I
ASM data inputs for x and y, and wt.
x/y. Software designers have sophist
board and mouse software drivers) tI
ware. Such software solves two funi
actors try to communicate: what data 
transfer occur? These problems arise
allel to each other. In hardware, these
bility of the designer of the ASM cha

A simple user interface scheme that Vv
user working with a push button that
use. When the user pushes the button,
design of such a push button is actual
which we will ignore for the moment

Also, we will assume that the divisi
READY is 1, the machine is waiting
0, the machine is busy computing thi
machine will output the valid quotien
to wait at least two clock cycles bef
value of the buses x and y in binary
leaves x and y alone during the comp
the machine would malfunction if an 
tions tries to use the machine.

The overall appearance of the ASM 
be:

24 Verilog Digital ComputE



IDLE[
READY

I

I~~~ implement computaion of 
s ' Ed quotient.These state(s) do 

Anot assert READ 

hart, we need to con-
,tors. In this case, we
er, who will give our Figure2 -12. ASMforfriendly user interface.
 to answer back with
)ose from (using key-
to interact with soft- READY
vays arise when two
when should the data
independently in par- x/y
but it is the responsi-

Figure 2-13. Block diagram.
tat we have afriendly
b, that our ASM can The cloud will be 
ngle replaced 

clock cycle by one 
(the or more rectangles and one or more diamonds re-

quired to implement 
ing with ASM the childish 

charts division algorithm. None of the rectangles that re-
place the cloud will assert the READY signal. This means that on the next clock cycle
after the user pushes pb, READY will become 0. READY only becomes I when the

EADY signal. When states in the cloud have finished and the ASM loops back to state IDLE.
:n. When READY is In the following 
)ecomes sections, 

1 again, we will 
the examine several different ways to implement the

childish division algorithm 
ser hidden 

is patient in the 
enough cloud. An experienced hardware designer

would not need to go through 
in. so many 

The user alternatives 
sets the to arrive at our final solution. The

reason we will look at so many 
the different 

button. The ways 
user to do the same thing is to illustrate

important properties of 
vill ASM 

not consider charts that 
how are somewhat different than conventional soft-

ware. In this discussion, 
t obey these we will 

assump- see that certain ASM charts that look reasonable to one
familiar with software are actually incorrect and that some ASM charts that look some-
what strange are actually correct. Later, in section 2.3, we will use some of the pure

block diagram will behavioral ASMs we develop in this section as the starting point for the mixed stage of
the top-down design process. These examples will also be used in later chapters.

Hardware DesigningA SMs 25



E

2.2.2 An ASM incorporating software dependencies
The software paradigm used by conventional programming languages, such as C, can
be described as each statement completes whatever action it is meant to accomplish
before the software proceeds to execute the next statement in the program. Ultimately,
all such software programs execute on some kind of hardware, therefore, it must be
possible to describe this software paradigm using the ASM chart notation. Although it
is often inefficient, a software algorithm can always be translated correctly into an
ASM with the following rules:

1. Each assignment statement is written by itself in RTN in a
unique rectangle that is not followed by a diamond.

2. Each if or while is translated into an empty rectangle
with a diamond to implement the decision.

With this approach, either of the following ASMs correctly implements the software
algorithm for division given earlier:

The,(
top 0
softA
whetI
evani

The 
been
waits
of ri
these
tuall)
IDLE
tains

Figure2 -14. ASMfor software paradigm( COMPUTEI at top). view
assigi

State
checl

XA lthough in the following and C
example there is a diamond in state IDLE involving an external status signal, the

original software algorithm does not mention this in 
status set

signal (pb), and so the software paradigm is pre-
served in this example.

26 Verilog Digital Computer Design: Algorithms into Hardware



cies
guages, such as C, can IDLE r1_x
meant to accomplish READY
>pr ogram. Ultimately,
therefore, it must be 

t notation. Although it p
.ated correctly into an INI

{TN in a TEST

ectangle rl3y

plements the software _COMT

COMPUTEl 
rl - r - y

Figure 2-15. ASMfor software paradigm (COMPUTE] at bottom).

The only difference between these two ASMs is whether state COMPUTEl is at the
top of the loop or at the bottom of the loop. Since these ASMs exactly model the way
software executes one statement at a time (one software statement per ASM rectangle),
whether r or r2 gets a value assigned first is irrelevant, because this was also irrel-
evant in software.

The value of x is assigned to the register rl in state IDLE. Although this could have
been done in an additional state, since we have assumed (see section 2.2. 1) that the user
waits at least two clock cycles when READY is before pushing pb, the initialization
1 orf l can occur here. The value of x will 

-rl not be loaded 
-y into rl until the second of

these two clock cycles. If pb is true, the ASM proceeds to state INIT, which will even-
tually cause r2 to change. If pb is false, as would be the case most of the time, state

-R2+1 IDLE simply loops to itself. Since state IDLE leaves r2 alone and r2 typically con-
tains the last quotient, this user interface allows the user as much time as required to

!P). view the quotient. The user interface, not the division algorithm, requires that r2 be
assigned after the pb test.

State INIT makes sure that r2 is 0 at the time the ASM enters state TEST. State TEST
checks if rl>=y, just as the while statement does in software. States COMPUTEl
and COMPUTE2 implement each software assignment statement as RTN commands

n external status signal, the in separate clock cycles.
software paradigm is pre-

Hardware
DesigningA SMs 27



The latter ASA
Both of these ASMs work when x < y. For example, the following shows how the

PUTE1 schedi
ASMs proceed when x is 5 and y is 7 (all values are shown in decimal for ease of

does not take 
understanding): cannot be part

IDLE rl= ? r2= ? pb=O ready=1

IDLE rl= 5 r2= ? pb=1 ready=1

INIT rl= 5 r2= ? pb=O ready=O 2.2.3 Elin
TEST rl= 5 r2= 0 pb=O ready=0 The empty rec
IDLE rl= 5 r2= 0 pb=0 ready=1 lation from so

in with other
diamond follc

The way each of the above ASMs operates is slightly different when x >= y. The

following shows how the ASM with COMPUTE 1 at the top of the loop proceeds when diamond take
computation 

x is 14 and y is 7: pend on the c(
IDLE rl= ? r2= ? pb=0 ready=1 2-15) that has
IDLE rl= 14 r2= ? pb=1 ready=1

INIT rl= 14 r2= ? pb=0 ready=O

TEST rl= 14 r2= 0 pb=0 ready=0

COMPUTE1 rl= 14 r2= 0 pb=0 ready=O

COMPUTE2 rl= 7 r2= 0 pb=0 ready=0

TEST rl= 7 r2= 1 pb=O ready=0

COMPUTE1 rl= 7 r2= 1 pb=0 ready=0

COMPUTE2 rl= 0 r2= 1 pb=0 ready=0

TEST rl= 0 r2= 2 pb=0 ready=0

IDLE rl= 0 r2= 2 pb=0 ready=1

IDLE rl= ? r2= 2 pb=O ready=1

The time to compute the quotient with this ASM includes at least two clock periods in

state IDLE, a clock period in state INIT, and the time for the loop. The number of times
through the loop is the same as the final quotient (r2). Since there are three states in the
loop, the total time to compute the quotient is at least 3 + 3 * quo t i ent.

Here is what happens with the ASM that has COMPUTE2 at the top of the loop:

IDLE rl= ? r2= ? pb=O ready=1

IDLE rl= 14 r2= ? pb=1 ready=1

INIT rl= 14 r2= ? pb=0 ready=O

TEST rl= 14 r2= 0 pb=0 ready=O

COMPUTE2 rl= 14 r2= 0 pb=0 ready=0
Figure 2-

COMPUTE1 rl= 14 r2= 1 pb=0 ready=0

TEST rl= 7 r2= 1 pb=O ready=0

COMPUTE2 rl= 7 r2= 1 pb=O ready=0 The only dif
COMPUTE1 rl= 7 r2= 2 pb=0 ready=0 for x<y, it I
TEST rl= 0 r2= 2 pb=0 ready=O error, assum
IDLE rl= 0 r2= 2 pb=0 ready=1

IDLE rl= ? r2= 2 pb=O ready=1

28 Verilog Digital Computer Design: Algorithms into Hardware



owing shows how the The latter ASM illustrates the need for an empty rectangle in state TEST. State COM-
in decimal for ease of PUTE1 schedules a change in register ri (for example, from 7 to 0), but the change

does not take effect until the beginning of the next clock cycle. Therefore the decision
cannot be part of state COMPUTE 

ady=1 1 but instead needs the empty rectangle (state TEST).
ady=1
ady=O 2.2.3 Eliminating state TEST
ady=O
ady=1 The empty rectangle for state TEST was introduced only to allow a mechanical trans-

lation from software to an ASM. In many instances, a decision like this can be merged
in with other states. Remember with an ASM that a non-empty rectangle having a

when x >= y. The diamond following it means the computation in the rectangle and the decision in the
ie loop proceeds when diamond take place in parallel. It is inappropriate to merge a decision onto states doing

computation when the outcome of the decision (in the software paradigm) could de-
pend on the 

ady=1 computation. Consider the following modified version of the ASM (figure
ady=1 2-15) that has COMPUTE2 at the top of the loop:
ady=O
ady=O
ady=O
ady=O
ady=O
ady=O
ady=O
ady=O
ady=1
ady=1

t two clock periods in
.The number of times
-are three states in the
tient.

top of the loop:

ady=1
ady=1
ady=O
ady=O
ady=O
ady=O Figure 2-16. Incorrectf our-state division machine.
ady=O
ady=O

The only 
ady=O difference here is that state TEST has been eliminated. Although this works
ady=O for x<y, it fails to compute the correct quotient for x>=y. As an illustration of this
ady=1 error, assume that rl is twelve bits and consider when x is 14 and y is 7:
ady=1

Hardware DesigningA SMs 29



IDLE rl= ? r2= ? pb=O ready=1 ThisASM
IDLE rl= 14 r2= ? pb=1 ready=1 PUTE2. I
INIT rl= 14 r2= ? pb=O ready=O computati
COMPUTE2 rl= 14 r2= 0 pb=0 ready=0 consider 
COMPUTE1 rl= 14 r2= 1 pb=0 ready=O
COMPUTE2 rl= 7 r2= 1 pb=0 ready=O
COMPUTE1 rl= 7 r2= 2 pb=O ready=O
COMPUTE2 rl= 0 r2= 2 pb=0 ready=0
COMPUTE1 rl= 0 r2= 3 pb=0 ready=0
IDLE r1=4089 r2= 3 pb=0 ready=1
IDLE rl= ? r2= 3 pb=0 ready=1

The decision r 1> =y actually occurs separately in two states: INIT and COMPUTE 1.
In state INIT, the only computation involves r2, and so the decision (14 is >= 7) pro-
ceeds correctly. The problem exists in state COMPUTE1 because the computation The secon
changes ri, and the decision is based on r. The second time in state COMPUTE1, 7 to0. Thi
ri is still 7, although it is scheduled to become 0 at the beginning of the next clock COM[PUT
cycle. The decision is based on the current value (7), and so the loop executes one more based on tl
time than it should and the incorrect value of r2 (3) results. The mysterious decimal times and
4089 is the side effect of 12-bit underflow (4089+7=212).

rema un
Although it is incorrect to remove state TEST in the last example, what about removing Although I
state TEST in the other ASM (figure 2-14, with COMPUTE 1 at the top of the loop)? executes f

22A 
In addition
the ASM c
sider elim
tangle for

Figure 2-17. Correctfour-stated ivison machine.

30 Verilog Digital ComputerD esign: Algorithms into Hardware

U



-

aady=1 This ASM has the decision rl>=y happening in two different states: INIT and COM-
eady=1 PUTE2. The difference here is that the decision is not dependent on the result of the
aady=0 computation in state COMPUTE2. Therefore, this ASM is correct. As an illustration,
aady=0 consider when x is 14 and y is 7:
eady=0
aady=0 IDLE rl= ? r2= ? pb=0 ready=1
mady=0 IDLE rl= 14 r2= ? pb=1 ready=1
eady=0 INIT rl= 14 r2= ? pb=0 ready=0
Bady=0 COMPUTE1 rl= 14 r2= 0 pb=0 ready=0

eady=1 COMPUTE2 rl= 7 r2= 0 pb=0 ready=O
Bady=1 COMPUTE1 rl= 7 r2= 1 pb=0 ready=0

COMPUTE2 rl= 
,~oh^i,eaos wu ipoms 0 r2= 1 pb=O ready=0

h enay  xts(t eh1tacee4bur oitic0iP
-r1| NICTaO n1MdM PPUUTTEE1l.. IDLE rl= 0 r2= 2 pb=0 ready=1

IDLE 
isioni(s 1 rl= 

>4 = 7 ) pro- ? r2= 2 pb=O ready=1

_aueaucsec tho)em ppuuttaattiioonn The second time in state COMPUTE 1 schedules the assignment that changes 
in sttate C( rl 

O,MPPUUTTEE1I, from
, 7 to 0. This takes effect at the beginning of the clock cycle when the 

nliing ASM 
of the enters 

next state
clock COMPUTE2 for the second time. The decision, which is now part of COMPUTE2, 

oope 
is

xesc ountees  more based on the correct value (0). This means the loop goes through the correct number of
he mysates rdioeucsi mal times and the quotient in r2 is correct. As was the case with the earlier ASMs, r2 will

remain unchanged until pb is pushed again.
wabhoaut tt  removing Although the ASMs in section 2.2.2 are also correct, this ASM has the 

NItThe advantage 
  atnodp  Co(f tLhhee  loop)? that it

executes faster as it requires only 3 +2 * quotient clock cycles.

NnI dC 2.2.4 Eliminating state INIT
is 1 4 h In addition to being able to describe a decision and a computation that occur in parallel,

the ASM chart notation can describe multiple computations that occur in parallel. Con-
sider eliminating state INIT by merging the assignment of zero to r2 into the rec-
tangle for state IDLE:

PH ardware DesigningA SMs 31



2.2.5 S
ri- X 

IDLE r2ADY One way t
extra regis

0 b 

0 CIOMU l
| r- ri

COMPUT2
r2 - r2 +1

Figure 2-18. Incorrectu ser interface (throws quotient away).

You may have as many RTN assignments occurring in parallel within a state as you
want as long as each left-hand side within that state is unique. In this instance, ri and
r2 are scheduled to have new values assigned at the beginning of the next clock cycle.
Since we have assumed that the user will ensure that the ASM stays in state IDLE Figure g
while x remains constant for at least two clock cycles, ri and r2 will be properly
initialized before entering the loop. This ASM will correctly compute the quotient and This ASM 
leave the loop after the proper number of times for the same reason. To illustrate what is 14 and y
this ASM does, consider the same example as the other ASMs (when x is 14 and y is ID
7): ID

IDLE rl= ? r2= 0 pb=0 ready=1 CO
IDLE rl= 14 r2= 0 pb=1 ready=1 CO
COMPUTE1 rl= 14 r2= 0 pb=0 ready=O CO
COMPUTE2 rl= 7 r2= 0 pb=0 ready=0 CO
COMPUTE1 rl= 7 r2= 1 pb=0 ready=0 CO
COMPUTE2 rl= 0 r2= 1 pb=O ready=0 CO
IDLE rl= 0 r2= 2 pb=0 ready=1 ID
IDLE rl= ? r2= 0 pb=O ready=1 ID

There is a new problem with this ASM that we have not seen before: the quotient (2) Unfortunate
exists in r2 for only one clock cycle. This ASM throws it away because the assignment to be zero, r
of 0 to r2 is in state IDLE. From a mathematical standpoint, this ASM is correct, but assignment
from a user interface standpoint, it is unacceptable. zero. One w

test for the 

32 Verilog Digital Computer Design: Algorithms into Hardware



2.2.5 Saving the quotient
One way to overcome the user interface problem in section 2.2.4 is to introduce an
extra register, r3, that saves the quotient in a new state COMPUTE3:

1 -.- r1- y|

FE21
2--r2 +i1 

el within a state as you
In this instance, ri and
of the next clock cycle.
M stays in state IDLE Figure 2-19. Saving quotient in r3.
nd r2 will be properly
mpute the quotient and This ASM works for x>=y (the quotient is now in r3, not r2). For example, when x

:ason. To illustrate what is 14 and y is 7:
(when x is 14 and y is

IDLE rl= ? r2= 0 r3= ? pb=0 ready=1
IDLE rl= 14 r2= 0 r3= ? pb=1 ready=1

-eady=1 COMPUTEI rl= 14 r2= 0 r3= ? pb=O ready=0
.eady=1 COMPUTE2 rl= 7 r2= 0 r3= ? pb=0 ready=0
:eady=0 COMPUTE3 rl= 7 r2= 1 r3= ? pb=0 ready=0
.eady=0 COMPUTE1 rl= 7 r2= 1 r3= 1 pb=0 ready=0
-eady=0 COMPUTE2 rl= 0 r2= 1 r3= 1 pb=0 ready=0
-eady=0 COMPUTE3 rl= 0 r2= 2 r3= 1 pb=0 ready=0
.eady=1 IDLE rl= 0 r2= 2 r3= 2 pb=0 ready=1
?eady=1 IDLE rl= ? r2= 0 r3= 2 pb=0 ready=1

before: the quotient (2) Unfortunately, there is a subtle error in the above ASM: when the answer is supposed
because the assignment to be zero, r3 is left unchanged instead of being cleared. This occurs because the only
this ASM is correct, but assignment to r3 is inside the loop, but the loop never executes when the quotient is

zero. One way to overcome this problem is to include an extra decision in the ASM to
test for the special case that x<y (which can be done by testing if rl>=y is false):

no Hardware Designing ASMs 33



IDLE

READY l

Figure 2

Figure 2-20. Handling quotient of zero. Here is an e

* ID
ZEROR3 0 COPD

. CO

!;~~ID
Of course, this has the disadvantage of taking longer (2 +3 * quo ti ent clock cycles), ,c
but sometimes a designer must consider a slower solution to eventually discover a cc
faster solution. lo

2.2.6 Variations within the loop The value i
Let's take the final ASM of section 2.2.5 and consider some variations of it inside theX
loop that will make it incorrect. Our eventual goal is to find a faster solution that is gd Anotherthi
correct, but for the moment, let's just play around and see how we can break this ASM. states CONV

One incorrect hing to do would be toa ssign to r3 before incrementing r2:

34 Verilog Digital Computer Design: Algorithms into Hardware



Figure 2-21. Incorrectr earrangemento f states.

Here is an example when x is 14 and y is 7 of what kind of error occurs:
IDLE rl= ? r2= 0 r3= ? pb=0 ready=1
IDLE rl= 14 r2= 0 r3= ? pb=1 ready=1
COMPUTE1 rl= 14 r2= 0 r3= ? pb=0 ready=0
COMPUTE3 rl= 7 r2= 0 r3= ? pb=0 ready=0
COMPUTE2 rl= 7 r2= 0 r3= 0 pb=0 ready=O

,otient clock cycles), COMPUTE1 rl= 7 r2= 1 r3= 0 pb=O ready=O

eventually discover a COMPUTE3 rl= 0 r2= 1 r3= 0 pb=0 ready=O
COMPUTE2 rl= 0 r2= 1 r3= 1 pb=O ready=O
IDLE rl= 0 r2= 2 r3= 1 pb=O ready-1
IDLE rl= ? r2= 0 r3= 1 pb=O ready=1

The value in r3 is one less than it should be since it was assigned 
ariations too early.

of it inside the
a faster solution that is Another thing to try (which unfortunately will also fail for similar reasons) is to merge
we can break this ASM. states COMPUTE2 and COMPUTE3 into a single state COMPUTE23:

ementing r2:

o Hardware Designing ASMs 35



IDLE 1

-L<

r

Figure 2-22. Incorrectp arallelizationa ttempt.
Figure 2-23. 

Here is an example when x is 14 and y is 7 of what kind of error occurs:
This ASM is coi

IDLE rl= ? r2= 0 r3= 0 pb=0 ready=1 y is 7):
IDLE rl= 14 r2= 0 r3= 0 pb=1 ready=1
COMPUTE1 rl= 14 r2= 0 r3= 0 pb=0 ready=0 IDLE
COMPUTE23 rl= 7 r2= 0 r3= 0 pb=0 ready=0 IDLE
COMPUTE1 rl= 7 r2= 1 r3= 0 pb=0 ready=0 COMPUTI
COMPUTE23 rl= 0 r2= 1 r3= 0 pb=0 ready=0 COMPUTI
IDLE rl= 0 r2= 2 r3= 1 pb=O ready=l COMPUTI
IDLE rl= ? r2= 0 r3= 1 pb=0 ready=1 IDLE

IDLE
Even though inside the rectangle the assignment to r2 is written above the assignment
to r3, they happen in parallel. The meaning of a state in an ASM is not affected by The decision inv,
the order in which a designer writes the commands inside the rectangle. Since state IDLE), and
there is a dependency between the commands in state COMPUTE23, this ASM is not of r2 and r3 obE
equivalent to the correct solution of section 2.2.5 but is instead equivalent to the incor- of these things oc
rect solution given a moment ago. After the second time in state COMPUTE23, r2 is tial software para
incremented (from to 2), but r3 changes to the old value of r2 (1), which is not what a state). We are n
we want. correct result mu,
Although all of the above variations may seem hopeless, there is in fact a correct and Although in this,
faster solution if we press on with this kind of variation. Let's merge all three com- tient when the A
mands into a single state COMPUTE: important. It con

36 Verilog Digital Computer Design: Algorithms into Hardware



Figure 223. Correctp arallelization.

or occurs:
This ASM is correct, as illustrated by the example used before (when x is 14 and

ready=1
y is 7:

ready=l
ready=0 IDLE rl= ? r2= 0 r3= ? pb=0 ready=1
ready=0 IDLE rl= 14 r2= 0 r3= ? pb=1 ready=1
ready=0 COMPUTE rl= 14 r2= 0 r3= ? pb=0 ready=0
ready=0 COMPUTE rl= 7 r2= 1 r3= 0 pb=0 ready=0
ready=1 COMPUTE rl= 0 r2= 2 r3= 1 pb=0 ready=O
ready=1 IDLE rl= 4089 r2= 3 r3= 2 pb=O ready=1

IDLE rl= ? r2= 0 r3= 2 pb=O ready=1
a above the assignment
SM is not affected by The decision involving rl>=y is part of state COMPUTE (as well as being part of
e the rectangle. Since state IDLE), and ri is affected in state COMPUTE. Also there is the interdependence
rTE23, this ASM is not of r2 and r3 observed earlier. The reason why state COMPUTE works here is that all
equivalent to the incor- of these things occur at the same time in parallel. We have now totally left the sequen-
e COMPUTE23, r is tial software paradigm of section 2.2.1 (one statement at a time; no dependency within
R( 1), which is not what a state). We are now using the dependency in the algorithm with parallelism to get the

correct result much faster.

is in fact a correct and Although in this ASM r3 still serves as the place where the user can observe the quo-
s merge all three corn- tient when the ASM returns to state IDLE, r3 accomplishes something even more

important. It compensates for the fact that the loop in state COMPUTE executes one

)H ardware
DesigningA SMs 37



more time than the software loop would. Even though r2 becomes one more than the
correct quotient, r3 is loaded with the old value of r2 each time through the loop. On IDL
the last time through the loop, r3 is scheduled to be loaded with the correct quotient.

The loop in state COMPUTE is interesting because it has a property that software
loops seldom have: it either does not execute or it executes at least two times. This is
because the decision rl>=y is part of both states IDLE and COMPUTE. To illustrate
this, consider when x is 7 and y is 7:

IDLE rl= ? r2= 0 r3= ? pb=O ready=1
IDLE rl= 7 r2= 0 r3= ? pb=1 ready=1
COMPUTE rl= 7 r2= 0 r3= ? pb=O ready=O
COMPUTE rl= 0 r2= 1 r3= 0 pb=O ready=O
IDLE rl=4089 r2= 2 r3= 1 pb=O ready=1
IDLE rl= ? r2= 0 r3= 1 pb=O ready=1

You can see that rl is 7 in state IDLE, and so the ASM proceeds to state COMPUTE.
In state COMPUTE, rl is scheduled to change, but it remains 7 the first time in state
COMPUTE; Figure 

thus the 2-24.
next state is state COMPUTE (it loops back to itself). Only on the

second time through state COMPUTE has the scheduled change to rl taken place;
thus the next state finally becomes IDLE. Since pb is tru(
As with earlier ASMs, this ASM works for x<y only because of state ZEROR3. For time. Whether t
example, consider when x is 5 and y is 7: values x>=y th

change the oper
IDLE rl= ? r2= 0 r3= ? pb=O ready=l x<y. Rather tha
IDLE rl= 5 r2= 0 r3= ? pb=l ready=l

once. In this cas
ZEROR3 rl= 5 r2= 0 r3= ? pb=O ready=0
IDLE rl= 5 r2= 0 r3= 0 pb=O ready=l not >= y.
IDLE rl= ? r2= 0 r3= 0 pb=O ready=l For example, cc

The time required for this ASM is 3 +quot i ent clock cycles. IDLE
IDLE

COMPU
2.2.7 Eliminate state ZEROR3 IDLE

If the loop in state COMPUTE could execute one or more (rather than two or more) IDLE

times, it would be possible to eliminate state ZEROR3. This would work because r2 is
already 0, and the assignment of r2 to r3 would achieve the desired effect of clearing The fact that rI
r3. in the earlier AS

at data output r
One way to describe this in ASM chart notation is to note that pb is true when making
the transition from state IDLE to state COMPUTE (the first time into the loop), but pb The time requir
remains false until the quotient is computed (by our original assumption about a friendly The above ASM
user). Let's change the decision so that it ORs the status signal pb together with the In essence, ther
result of the rl>=y: (testing pb). In

38 Verilog Digital Computer Design: Algorithms into Hardware



omes one more than the
ne through the loop. On
ith the correct quotient.

property that software
least two times. This is
OMPUTE. To illustrate

ready=1
ready=1
ready=0
ready=0
ready=1
ready=1

,ds to state COMPUTE.
7 the first time in state

ck to Figure 
itself). Only 2-24. 

on the Goto-less two-state childish division ASM.
mge to rl taken place;

Since pb is true for only one clock cycle, this only causes the loop to go in the first
of state ZEROR3. For time. Whether to repeat the loop subsequent times depends only on ri. Since for all

values x>=y the loop occurs at least twice anyway, ORing pb in the decision does not
change the operation of the ASM for x>=y. ORing pb only affects what happens when

ready=1
x<y. Rather than executing state COMPUTE zero times, ORing 

ready=1 pb forces it to execute
once. In this 

ready=0 case, state COMPUTE will not execute more than once because x (ri) is
ready=1 not >= y.
ready=1 For example, consider when x is 5 and y is 7:

IDLE rl= ? r2= 0 r3= ? pb=0 ready=1
IDLE rl= 5 r2= 0 r3= ? pb=1 ready=1
COMPUTE rl= 5 r2= 0 r3= ? pb=0 ready=O
IDLE rl=4094 r2= 1 r3= 0 pb=0 ready=1

father than two or more) IDLE rl= ? r2= 0 r3= 0 pb=0 ready=1
uld work because r2 is

lesired effect of clearing The fact that rI and r2 are different after executing state COMPUTE than they were
in the earlier ASM after executing state ZEROR3 is irrelevant since the user only looks
at data output r3.

pb is true when making
ne into the loop), but pb The time required for this ASM is also 3 +quotient clock cycles.
umption about a friendly The above ASM was arranged to follow the goto-less style mentioned in section 2.1.4.
tal pb together with the In essence, there is a whi 1 e loop (testing r 1 > =y pb) nested inside an i f statement

(testing pb). In order to describe this ASM in the goto-less style, pb is tested twice

to Hardware Designing ASMs 39



coming out of state IDLE. Such ASMs with redundant tests (in the same clock cycle) 2.3.1 First 
can be simplified into shorter equivalent ASM notation. Although this equivalent ASM We could use an
is truly identical and would be implemented with the same hardware, it does not follow % behavioral ASM
a style that can be thought of in terms of i f s and whi 1 es: consider the AS.

chart for the diN
cause they are 
mixed stage, we

Consider the RI
loaded with x,;
three registers a
at the beginning

There are man)
mands. The de,
ease, personal r
ture. The only 
rectly impleme
behavioral AS
to choose regisl
many of the req
a counter regis

Figure 2-25. Equivalent to figure 2-24. required in stat
COMPUTE). V

Also, in the above, the order of the statements within state COMPUTE were re- from the ASM i
arranged for ease of understanding. As mentioned earlier, changing the order with a
rectangle does not change the meaning. Which way you draw the ASM is both a matter If the designer
of personal taste and also a matter of how you intend to use it. We will see examples to provide for t
where both forms of this ASM prove useful. At this stage it is important for you to be dix C) in the a
comfortable that these two ASMs mean exactly the same thing because under all pos- would just mal
sible circumstances they cause the same state transitions and computations to occur. we will choose

On the other h
outside the reg

2.3 Mixed examples plest register
hardware will

The three stages of the top-down design process were discussed in section 2.1.5. Sec-
r3.

tion 2.2 gives several alternative ways to describe the childish division algorithm in the
first stage of the top-down design process (as a pure behavioral ASM). This section Having decide
continues this same example into the second stage of the top-down design process. In how those reg
the second stage, we partition the division machine into a controller and an architec- RTN in state (
ture. ments, and r3

parallel. This i

40 Verilog Digital Computer Design: Algorithms into Hardware



the same clock cycle) iple
Yh this equivalent ASM

he ASM charts in section 2.2 as an example of 
ware, translating 

it does not follow a pure
structural architecture and a behavioral controller. For example,
rt described in section 2.2.7, which is the simplest correct ASM
machine. We can, for the moment, ignore pb and READY be-
d ports (and will remain the same in the mixed stage). In the
to eliminate RTN commands and relational decisions.

mmands in this ASM chart. In state IDLE, ri is scheduled to be
parallel r2 is scheduled to be cleared. In state COMPUTE, all
eduled to change. Of course, these scheduled changes take effect
en ext clock cycle.

)le hardware structures that could implement these RTN com-
makes an arbitrary decision (based on speed, cost, availability,
ce, etc.) about what hardware components to use in the architec-
nent is that interconnection of the chosen components can cor-

RTN transfers with the precise timing indicated by the original
The easiest (but not necessarily best) way to accomplish this is

ponents (like those in appendix D) that internally take care of as
TN commands as possible. For example, if the designer chooses
r2, the counter can internally take care of clearing r2 (as is
E)a nd also take care of incrementing r2 (as is required in state

COMPUTE were re- e able to eliminate the RTN commands (such as r2 <- r2+1)
nging the order with a d replace them with internal command signals (such as incr2).
ieA SM is both a matter choose a non-counter register for r2, the designer would have
We will see examples :ions with additional combinational devices (like those in appen-
mportant for you to be ure. It is not wrong to choose a non-counter register for r2; it
because under all pos- ,signer work harder. To keep this example as simple as possible,
)mputations to occur. ter register for r2.

;isters rl and r3 are loaded with values that must come from
like a simple counter). Therefore, it is sensible to use the sim-
ent possible (the enabled register) for rl and r3. Additional

d in section 2.1.5. Sec- ired to make available the new values to be loaded into rl and
ivision algorithm in the
ral ASM). This section ek ind of registers to use in the architecture, we need to consider
own design process. In *ei nterconnected. For a moment, let's concentrate only on the
troller and an architec- TE. In this state, ri will be loaded with a difference, r2 incre-

ided with the old value of r2. All three of these actions occur in
Foerx ample, that the difference must be computed by a dedicated

7 Hardware Designing ASMs 41



0

combinational device (such as a subtractor). Such a combinational device is always When muxctr
computing the difference between r 1 and y (even though that difference is loaded into output of the n
ri only when the controller is in state COMPUTE). appears as foll

Loading r3 with the old value of r2 is easy. The output port of the r2 counter register
is simply connected via a bus to the input port of the r3 enabled register. If the only
state to mention rl, r2 or r3 were state COMPUTE, we would have the following
architecture:

muxctrl
Y

12

Figure2 -27.

Although the a]
Figure 2-26. Architecture using subtractor 2.2.7, it does nc

relational decis
but the above architecture fails to implement the RTN of state IDLE. The above archi- a comparator) I
tecture provides no way for rl to be loaded with x. relational comic

One stead 
approach of referrii

that often allows an architecture to deal with different kinds of RTN in
different status signals. 

states I
is to use an Arithmetic Logic Unit (ALU), which is capable of many and y.

different operations, instead of a dedicated combinational device (such as a subtractor).
Also, there is often a need for one or more muxes so that the proper information can be There are three
routed to the ALU. In this particular ASM, there are only two different results that There is no >=
might be loaded into r 1: either the difference of r and y or passing through x un- strictly < outpi
changed. This means the ALU must be capable of at least two different operations: output is the in
computing the difference of the ALU's two data inputs and passing through the ALU's
second At last, 

input we 
unchanged. hav

The ALU is commanded to do these operations by particular tional 
bit patterns decision

on the six-bit aluctrl bus. Symbolically, we will refer to these bit pat-
terns to 

as translate 
'DIFFERENCE the

and 'PASS. The grave accent ('), which is also known as
backquote ASM 

or tick, chart. 
indicates Th

a symbol that is replaced by a particular bit pattern. incr2) instead
On one hand, the ALU should be able to subtract y; on the other hand, the ALU should decisions. The
be able to pass x. To accomplish this requires a mux which can select either x or y. The incr2 or 1dr
output of this mux is connected as the second input of the ALU. Input 0 of this mux is tion on the righ
connected to the external bus x. Input of this mux is connected to the external bus y. the combinatio

42 Verilog Digital Computer Design: Algorithms into Hardware



ational device is always When muxctrl isO, the output of the mux is the same as x. When muxctrl is 1, the
difference is loaded into output of the mux is the same as y. Using the mux and ALU, the architecture now

appears as follows:

f the r2 counter register
bled register. If the only
vould have the following

clrr2 icr2 Idr3

Idr3

12
Figure 2-27. Architecture using ALU.

Although the above architecture implements all the RTN of the ASM chart in section
2.2.7, it does not consider the relational decision rl>=y. The simplest way to translate
relational decisions into the mixed stage is to dedicate a combinational device (usually

IDLE. The above archi- a comparator) for calculating an internal status signal that indicates the result of the
relational comparison. In the mixed ASM, this internal status signal will be tested in-
stead of referring to the relational decision. 

ifferent This is 
kinds why ultimately 

of RTN in the ASM uses only
status signals. In this particular instance, we will use a comparator 

fich is capable whose 
of many inputs are ri

and y.
ce (such as a subtractor).
'oper information can be There are three outputs of a comparator: the strictly <, the exactly == and the strictly >.
No different results that There is no >= output, but we can obtain that output, since it is the complement of the
r passing through x un- strictly < output. We will use the strictly < output as the input of an inverter, whose
vo different operations: output is the internal status signal rgey.
sing through the ALU's At last, we have an architecture which can correctly 
operations implement 

by particular all the RTN and rela-
tional decisions of the ASM chart 

ill in section 
refer to 2.2.7. 

these Now 
bit it 

pat- will be a mechanical matter
to translate the pure behavioral ASM chart of section 2.2.7 

which into 
is an 

also equivalent 
known as mixed

ASM chart. The purpose of this translation 
ticular will 

bit pattern. be to use command signals (such as
incr2) instead of RTN, and to use status signals (such as rgey) instead of relational

,r hand, the ALU should decisions. The - in RTN translates to a command signal (such as drl, clrr2,
select either x or y. The incr2 or dr3) corresponding to the register on the left of the arrow. The computa-
J. Input 0 of this mux is tion on the right of the arrow may or may not require additional commands directed to
ed to the external bus y. the combinational logic units, such as the ALU and mux.

to Hardware DesigningA SMs 43



This translation from pure behavioral ASM to mixed ASM always relates to a particu-
lar architecture D.VI... .C that the designer has in mind. Although many architectures might have
been DIVISIC

chosen for one pure behavioral ASM, each architecture will have a distinct mixed
ASM. The following shows the particular architecture we have just developed and the
corresponding translation of the pure behavioral ASM of section 2.2.7 into the particu-
lar mixed ASM required by this architecture. Finally, we give a system block diagram .X~ e
showing the interconnection of this particular controller (as described by the mixed
ASM) and this particular architecture: pb

L
rl gey

: 12
Y ig 

clrr2 incr2 Idr3 .... .. .. ......

Figure2 -30

r2 12 r3 1 2 The external c
translation to tl

Figure 2-28. Methodical architecture. 2.3.2 Seco
It happens in th
implement any
architecture to 
just happens th
same register 
implement the 
signed for maxi
For example, t]
architecture an(
thus the data oi
mixed ASM ch

Figure 2-29. Mixed ASM correspondingt ofigures 2-24 and 2-28.

44 Verilog Digital Computer Design: Algorithms into Hardware



wvays relates to a particu- ...............................................-.--.-.--.-----.---.--
architectures might have DIVISION MACHINE
till have a distinct mixed
'e just developed and the
on 2.2.7 into the particu-
a system block diagram
described by the mixed pb CONTROLLER ARCHITECTURE

in2incr2 1
rigey x~~~~~~~~~~~~~~~~~~~~~~~~~lcr

rl gey x j/
i ~~12 READY 

incr2 Idr3 ...............................
4 l Figure 2-30. System diagram.

2 12 12 The external command READY and the external status pb are not affected by the
_3 >translation to the mixed stage.

2.3.2 Second example
It happens in this example that the architecture just developed could have been used to
implement any of the ASM charts in section 2.2. (It is rare for the same methodical
architecture to work with different ASMs.) In general, this would not be the case, but it
just happens that the ASM chart of section 2.2.7 requires maximal parallelism of the
same register transfers as the other ASMs. All the other ASM charts of section 2.2
implement the same RTN commands with less parallelism, and so an architecture de-
signed for maximal parallelism can implement an ASM that demands less parallelism.
For example, the first ASM of section 2.2.2 could be implemented using the same
architecture and system block diagram. The register r3 is not used by this ASM chart,
thus the data output of the machine should be r2 instead of r3. Figure 2-31 is the
mixed ASM chart that corresponds to this architecture and the ASM of section 2.2.2:

)IFFERENCE
1

d 2-28.

to Hardware DesigningA SMs 45



The carry out (
IDLE Idrl 

aluctrI =PASSB be used to det
ASM of sectio

muxctrl = 0
READY rectangle will 

commanded to
0 1 effect of compi

pb< ;architectureK  an

TEST 

r gei
\ ~COMPUTE1
0 Idrl

aluctrI =\DIFFERENC
muxctr = 1

COMPUTE2|
| _ incr2

Figure 2-31. Mixed ASM correspondingt o figures 2-14 and 2-28. Figure 2-3,

2.3.3 Third example IDLE d
If we are content with the slower ASM chart of alu

section 2.2.2, perhaps we can find a mu
cheaper architecture (with less potential for parallelism) that can correctly implement RE
the RTN given in section 2.2.2. Of course, such an architecture could not implement
ASM charts, such as that in section 2.2.7, which require more parallelism. One way to 0
reduce cost (at the expense of speed) is to use the ALU as a central unit that can do
many different operations. In particular, it can output the value zero (when aluctrl
is 'ZERO) and it can increment (when aluctrl is 'INCREMENT). Since theALU is
used for everything, the mux must have enough inputs to provide anything required by
the ALU. In this instance, there is a three-input mux (with a two-bit muxctrl). This
allows the mux to select x, rl or r2 to be output to the bus which is the a input of
the ALU.

It is no longer necessary for r2 to be a counter register since the ALU can increment its
input, and the mux can provide the value of r2 to the ALU. The output of the ALU
must be available on a central bus, from which both rl and r2 can be loaded. (This
ASM does not use r3.)

Figure 2-i

46 Verilog Digital Computer Design: Algorithms into Hardware



The carry out (cout) status signal output from the ALU is available at no cost. It can
be used to determine the result of the rl>=y test. This is permissible because the
ASM of section 2.2.2 has an empty rectangle for state TEST. In the mixed ASM, this
rectangle will not be empty, although no registers will be loaded. The ALU is simply
commanded to compute a difference without issuing a register load signal. As a side
effect of computing the difference, -cout indicates rl>=y. The following shows the
architecture and mixed ASM chart for the third example:

IdrI 1 

rl 21 ALU

)IFFERENC muxctrl cout
Idr2 y b4

1 ~~~~~~~~~~~~~~~~~~~~~~12
l ' xsy~~~~~~~~~~~~~12 6

lcr2 aluctr

d 2-28. Figure2 -32. Central ALU architecture.

perhaps we can find a muxctrT= 0
an correctly implement READY
re could not implement
Parallelism. One way to 1
central unit that can do p
zero (when aluctrl INIT Idr2

ENT). Since the ALU is I aluctrl __ZERO

le anything required by TEST
o-bit muxctrl). This muxctrl = 1
which is the a input of

ALU can increment its muxctrl = 1
Moeu tput of the ALU CMP2Idd

2 can be loaded. (This COMPUTE21

Figure 2-33. Mixed ASM corresponding to figures 2-14 and 2-32.

v Hardware DesigningA SMs 47



2.3.4 Methodical versus central ALU architectures
There is a spectrum of possible section 

ways 2.3
to choose an architecture at the 

design process. At one extreme is the because 
central it

ALU approach, illu
2.3.3, where one ALU does all the computation transfers.

required by the entire
other extreme are methodical approaches, illustrated by sections 2.3.
each computation in the algorithm is done by a different hardware
ALU approach typically uses less hardware but only works with certa
For example, 2.4 Pi

the ASM that works with the methodical approach in sel
work with the central ALU In the 

approach mix
because that ASM performs mc

putation per clock cycle. a 
The controlle

following table highlights the differen
two approaches: tion contir

into the th
l section 2.1

Central ALU Met The third s
What does computation? one ALU regA implement

then stage, the 
regi level of th
to instead de5
muxe mation to

What ALU output connects to? chine. The
every register only

What kind of register? enabled all 2.4.1 F
Number of - per clock cycle one To translat

many
name a sp,

Speed slower fast requiremel
signer (wh

Cost lower high For an AS:
Example states, a tw

2.3 .3 2.3. the job. Fo
Figures 2-32, 2-33 general, 

2-28 an
2-22

I The mixed
that being

In the methodical architecture of section 2.3.2, the output of the ALU sented by 
ri, but in the central ALU architecture of section 2.3.3, the output c
nects to both rl and r2. In We 

the also 
ASM ne

implemented with the methodicz C, for an 
011001.

The structi
next state 

2Including customized registers (other than those described in appendix D) built using combinatic
n

tional logic that are tailored to the specific algorithm. See section 7.2.2.1 for an examp: tional logic

48 Vridoq f);it-l ,7n,1 no; /..: -
TI--V, Dig-,X Vurr~uL/esign: Algorithms into Hardi



es section 2.3.1, there are multiple - per clock cycle. The central ALU approach is slower
the mixed stage of the because it takes an ASM that uses more clock cycles to accomplish similar register
illustrated in section transfers.

ntire algorithm. At the
2.3.1 and 2.3.2, where
vare unit. The central
ertain kinds of ASMs. 2.4 Pure sti actural example
n section 2.3.1 cannot In the mixed stage described in section 2.3), the division machine was partitioned into
s more than one com- a controller (described by a mixed ASM chart) and a structural architecture. This sec-
,rences between these tion continues with the same example (variations of the childish division algorithm)

into the third stage (of the three stages for the top-down design process explained in
section 2.1.5).

The third stage involves converting the mixed ASM chart into a hardware structure that
implements the behavior described by the mixed ASM chart. At the 

registers end of the third
themselves stage, the top 

or level of the system is completely described in terms of structure. The top
registers tied level of the system is no longer described in terms of what it does (behavior) but is
to dedicated instead described in terms of how to build it (structure). The desigier has enough infor-
muxes and ALUs mation to wire together the hardware components into an operational physical ma-

chine. The algorithm has become a working piece of hardware.
only one register

all kinds2 2.4.1 First example
To translate the mixed ASM chart into hardware we must assign each symbolic state

many name a specific bit pattern. The bit patterns used are completely arbitrary. The only
faster requirement is that the des gner be consistent. One approach that is easy for the de-

signer (when the number of states in the ASM chart is small) is to use a binary code.
higher For an ASM with two states, a one-bit code suffices. For an ASM with three or four

states, a two bit code will do. For an ASM with five to eight states, a three-bit code does
2.3.1 & 2.3.2 the job. For an ASM with nine to sixteen states, the designer needs a four-bit code. In

general, an ASM with n states requires a ceil  (l og2 (n) ) -bit 
2-28, code.

2-29, 2-31
The mixed ASM of section 2.3.1 is quite simple. It requires only two states. Let us say
that being in state IDLE is represented by 0, and being in state COMPUTE is repre-

LU only connects to sented by 1.
put of the ALU con- We also need to know the bit patterns that control the ALU. As explained in appendix
odical architecture of C, for an ALU inspired by the 74xx181, 'PASSB is 101010 and 'DIFFERENCE is

011001.

The structural controller is composed of two parts: the present state register, and the
next state combinational logic. The status and the present state are the inputs of the
combinational logic. The next state and the commands are the 

ising output 
muxes of 

and the 
combina- combina-

tional logic. The 
,xample. next state is the input to the present state register:

Hardware Designing ASMs 49



status -

Figure 2-34. Controller.

We can describe the next state logic with a table. For the ASM chart of section 2.3.1,
the corresponding table is:
inputs outputs
ps pb rgey ns 1drl clrr2 incr2 dr3 muxctrl aluctrl ready

For a more co
o a 0 0 1 1 0 0 0 101010 1 tools) could by
o 0 1 0 1 1 0 0 0 101010 1 actual hardwa
0 1 0 1 1 1 0 0 0 101010 1 job.
0 1 1 1 1 1 0 0 0 101010 1
1 0 0 0 1 0 1 1 1 011001 0 Several of the
1 0 1 1 1 0 1 1 1 011001 0 and 001 are id
1 1 0 1 1 0 1 1 1 011001 0 pb and not oi
1 1 1 1 1 0 1 1 1 011001 0 abbreviated f

inputs
In the above, ps stands for the representation of the present state, and ns stands for the ps pb rig
representation of the next state.

0 
One -

possible hardware implementation of this table is a ROM. The above table can be 0 1-
used as is to "bum" the ROM. Since there are three bits of address input to the ROM 1 0 0
(one bit for the present state, and two bits for the status), there are eight words (each 13- 1 1 0
bits wide) stored in the ROM for this controller. 1 - 1

Another approach would be to use the above table to derive minimized logic equations
for each bit of output and then use the logic equations to arrive at a structure composed shows a "don
of AND/OR gates. For example, the following logic equations are equivalent to the state transitio
above table: given earlier.

2.4.2 Sec
Assuming th;
follows:

50 Verilog Digital Computer Design: Algorithms into Hardware



ns = -ps&pbjps&(r1geyjpb)
1drl = 1
clrr2 = -ps
incr2 = ps
ldr3 = ps

- commands muxctrl = ps
aluctrl[5] = -ps
aluctrl[4] = ps
aluctrl[3] = 1

chart of section 2.3.1, aluctrl[2] = 0
aluctrl[l] = -ps
aluctrl[O] = ps
ready = -ps

Ialuctrl ready
tore complicated controller, using Karnaugh maps (or other logic minimization

101010 1 ould be helpful. Other approaches exist. Turning a table, such as the above, into
101010 1 iardware is a task that can be automated. Many software tools exist to aid in this
101010 1
101010 1
011001 0 1o f the entries in the above table are identical to each other. For example, 000
011001 0 [a re identical because the transition from IDLE to COMPUTE depends only on
011001 0 not on rlgey. (The second ASM chart in section 2.2.7 makes this clear.) An
011001 0 ated form of the table:

?uts outputs
, and ns stands for the b rigey ns drl clrr2 incr2 dr3 muxctrl aluctrl ready

[he above -
table can 0 

be 1 1 0 0 0 101010 1
- 1 1 1 0 0 0 

*ess input 101010 
to the ROM 1

O 0 1 0 1 1 1 011001 0
eight words (each 13- o 1 1 0 1 1 1 011001 0

1 1 1 0 1 1 1 011001 0

mized logic equations
a structure composed a "don't care" as a hyphen for those status inputs that do not affect a particular
are equivalent to the ^nsition. This table means exactly the same thing as the longer form of the table

arlier.

Second example
ing that the five states in the ASM chart of section 2.3.2 are represented as

Hardware DesigningA SMs 51



The above,
IDLE 000

flattened ci
INIT 001

of output, i
TEST 010
COMPUTE1 011
COMPUTE2 100 BLOC

the following table describes the controller: a -
2

inputs outputs
Ps pb rlgey ns 1drl clrr2 incr2 muxctrl aluctrl ready b -4-

2
000 0 - 000 1 0 0 0 101010 1
000 1 - 001 1 0 0 0 101010 1 Figure
001 - - 010 0 1 0 0 101010 0

010 - 0 000 0 0 0 0 101010 0
010 - 1 011 0 0 0 0 101010 0
011 - - 100 1 0 0 1 011001 0

100 - - 010 0 0 1 0 101010 0

101 - - 000 0 0 0 0 101010 0

11- - - 000 0 0 0 0 101010 0 a-

Using the "don't care" form of the table is useful because otherwise the table would be
32-lines long. The values of muxctrl and aluctrl in states INIT, TEST and COM-
PUTE2 are arbitrary. There are three extra state encodings (101, 110 and 111) that
should never occur in the proper operation of the machine. On power up, the physical
hardware might find itself in one of these states. To avoid problems of this kind, these
states go to state IDLE but otherwise do nothing.

2.5 Hierarchical design
Even though upon completion of the third stage, the top level of the system is described
with pure structure, some devices (actors) that make up part of the architecture or con-
troller may still be described in terms of behavior. For example, if an architecture needs
an adder, the block diagram for the architecture would simply show a device with two
inputs (let's label them a and b) and one output (sum). There are many possible hard-
ware structures that could implement such an adder. At the top level of the system we
will view the black box of an adder as being part of a structure, even though we have
not specified what internal structure (of AND/OR gates for instance) implements the
adder. Whatever internal structure is used, we can describe the behavior of the adder Figuy
with a one-state ASM chart. ASM charts such as this that have one state correspond to
combinational logic. The following shows the black box for a two- bit adder, the ASM
chart for the adder, and one of many possible internal structures (circuits) for the adder:

52 Verilog Digital Computer Design: Algorithms into Hardware



The above circuit diagram is flattened, which means it does not show any hierarchy. A
flattened circuit diagram, composed entirely of logic gates, each producing a single bit
of output, is equivalent to a netlist. A netlist is a list of gates with the corresponding

BLOCK DIAGRAM OF ADDER ASM OF ADDER (BEHAVIORAL)

a-
SUM = a-b

trl aluctrl ready

101010 1
101010 1
101010 Figure 2-35. 

0 Block diagram and behavioralA SM for adder.
101010 0
101010 0
011001 0
101010 0
101010 0
101010 0

7ise the table would be
NIT, TEST and COM-
)1, 110 and 111) that
lower up, the physical
,ms of this kind, these

he system is described
te architecture or con-
an architecture needs

low a device with two
many possible hard-

,vel of the system we
even though we have
ance) implements the
behavior of the adder
le state correspond to Figure 2-36. Flattened circuit diagramf or adder
o- bit adder, the ASM

fiorrc uthiets )a dder:

Hardware Designing ASMs 53



one-bit wires (nets) that each,
silicon foundry to fabricate an
directions (to a low-skilled W(
desired machine. Although a fi
mately what is used to build a r
the designer uses to arrive at ti
The term hierarchicald esign r(
final design. Hierarchical desig
ioral ASMs. In hierarchical de,
circuit diagram. Instead of just
fines modules. For example, th
tion of a module occurs by ins'
composed of a full-adder and a
and also instantiates a half-add,
The designer has to define a sef
posed of two half-adders and an
tiates in the definition of the fu
houses are build from identical
people live in each house. So it
They are instantiated from an id
be discussed in the next paragraj
In the final circuit, the half-add
adders is in turn composed of ar
diagrams show the adder modul
module definition and a circuit c
these definitions inside each oth(

54 V-rilog niinlrk
, --6 L-'gLtal Lome



'an be submitted to a --------- -- ---------------.- ......................
ubse d manually as SI

ipper wire to form the ADDER
iivalent netlist) is ulti-a 2
of the thought process

ign components in the b JM(1].
* I

ires, and not to behav- 2
w to arrive at the final JML21f
cted, the designer de- .............................. .....................
a module. The defini-
example, the adder is Figure 2-37. Definition of the adder module.
istantiates a full-adder

Re full-adder is corn- --
at the designer instan- HALF-

boring suburb. Such
e same. But different
Impose the full-adder.
i of the half-adder will 'ALF
Id by each half-adder. ADDER
ach of the three half-

)g ate. The following
definition, half-adder
rig the instantiation of ------------ - -- --

Figure 2-38. Definition of the full-adder module.

Figure 2-39. D... ... ... t. 

Figure 2-39. Definition of the half-adder module.

Hardware Designing ASMs 55



2.5.2 Hi
ADDER1 |................... Sections 2.2

ja  hi ) - two-state ve
increasing a
progresses tl
tectural devi

i l ~ \t . system who

j FA.............i...i.

b [1] .UM~l 9 ;i) 'sum Figure 2-

! l _ __ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~..._._;.l..,_._._
DIVISI

..-....... . .. .. . . . . . . .
--sum[2] x- 

Figure 2-40. Hierarchicali nstantiationo f modules.

Although hierarchical design can be used with either bottom-up or top-down design, it
is most important with top-down design. In top-down design, upon completion of the
third stage, the designer may apply the same three stages over again on any compo-
nents (actors) that are not standard building blocks. Building blocks such as adders are . CC
well understood, and the designer is not normally concerned about their internal struc- g e y
ture. Other problem-specific building blocks (such as the push button in the division (D
machine) would be dealt with at the end of the third stage for the top-level system. M

2.5.1 How pure is "pure"?
The terms "pure behavioral" and "pure structural" can be a little confusing. No matter
at what level of abstraction you view a hardware system, there is some irreducible
structure and some irreducible behavior. In the "pure" behavioral stage, the input and
output ports are part of some larger (unspecified) structure. In the "pure" structural
stage, the nature of the black boxes instantiated in the hardware diagram is known only .......
by their behavior. Even if the designer takes the hierarchy all the way down to the gate
level, the nature of each gate is known only by its behavior. Figure 2-

56 Verilog Digital Computer Design: Algorithms into Hardware



2.5.2 Hierarchy in the first example
Sections 2.2.7, 2.3.1 and 2.4.1 discuss the details for the three stages for the example
two-state version of the division machine. The following three diagrams illustrate the
increasing amount of structure and decreasing amount of behavior as the designer
progresses through the three stages. In each of these diagrams, black boxes (and archi-
tectural devices, which are in fact black boxes themselves) represent aspects of the
system whose internal nature is known only by behavior.

x12 DIVISION
y MACHINE

12 
(DESCRIBED BY

BEHAVIORAL / X/y
pb ASM CHART) READY

sum Figure 2-41. "Pure" behavioral block diagram.

3m2 

um[2. 

or top-down design, it
Ron completion of the
again on any compo-
cks such as adders are
ut their internal struc-
button in the division
e top-level system.

MIXED ASM incr2 
CHART) rr 

confusing. No matter : 
e is some irreducible ~~.~.~.~.. ~.~.. ~.~..~ .... ... ... ... ... ... .....  .. ..
I stage, the input and
the "pure" structural . . . . . . . . . . . . . . .. . . . . . . . . . . . . .. . . . . . . . . . . . . .. . . . . . . . . . . . .
iagram is known only
way down to the gate

Figure 2-42. Mixed block diagram.

hardware Designing ASMs 57



The third diag
DIVISION MACHINE ..... . ... .. ... .. ... .. ... .. ... .. ... .. ... .. ... .. ... .... ...... includes the n

xIf ; ,
12 mains the sam

y . ..__. ... .... ............................. n 
12- the internal sti
CONTROLLER rl gey ARCHITECTURE verter, ps, rl

: -1
12 Here is where

L NEXT
STATE . , , ,: proach. We dc

ns PRESENT Pi
STATE earlier full-ad(

REGISTER down to a gat
1 I gram. The rea

LOGIC 1 " > automated too
b I I UAL I

::
ei 61 1

aructrl
Bi _ 12 1

; I I
Idr3

., incrz- 2.6 Con
-

pb cirrz
:! _, * 1 1__ This chapter i

I .. .

'i
r2 [M behavior) and

r3 12!/y top-down des
L J ! , pure behavior

.. ..... .. ... .. ... .. ... .. ... .. ... .. ...... tion the mach
:............................................................. I In addition, 

sign). This all
READY

... ...- ...- ... ... ... ...-... ~ ... ... ... ... ... ... ...-...-...-...-...-...-... ..
...~  ~ without havip

.-.~-... --.---..--.-... .-...  .... ...........................

The next chalk
Figure 2-43. "Pure" strucuralb lock diagram. behavioral, st

The first diagram (figure 2-41), which illustrates the "pure" behavioral stage, has a
single black box. This box represents the complete division machine. The machine has 2.7 Fur
a unified behavior which can be described by a single ASM chart (see section 2.2.7). CLAIR, C. R.,
The only structure in the first stage is the port structure that allows the machine to York, 1973.'
communicate with the outside world. notation, whi.
The second diagram (figure 2-42) shows the "mixed" stage. Instantiated inside the
division machine are the controller and the architecture. In the mixed stage, the struc- GAJsI, DANIa
ture of the controller remains a mystery (i.e., a black box) which is described only in NJ, 1997. Ch
behavioral terms by the ASM chart of section 2.3.1. This ASM chart refers only to what is callec
status and command signals. The architecture, on the other hand, is visible; however
architectural devices (such as the ALU) remain as black boxes, known only by their
behavior.

58 Verilog Digital Computer Design: Algorithms into Hardware

M



The third diagram (figure 2-43) shows the "pure" structural stage. Here the controller
includes the next state logic and the present state (ps) register. The architecture re-
mains the same as in the "mixed" stage. Even though this is the "pure" structural stage,
the internal structure of the black boxes (next state logic, mux, ALU, comparator, in-
verter, ps, ri, r2 and r3 registers) remains hidden.
Here is where the power of hierarchical design comes to aid us in our top-down ap-
proach. We do not need to worry about the gate-level details of, say, the ALU. As the
earlier full-adder example illustrates, such behavioral black boxes can be decomposed
down to a gate-level netlist. For our purposes, we will be content with the third dia-
gram. The reason we do not have to work our way down to reach the gate level is that
automated tools now exist to do this dirty work.

2.6 Conclusion
This chapter illustrates two manual graphicaln otations: the ASM chart (to describe

x/y behavior) and the block diagram (to describe structure). There are three stages in the
top-down design process to turn an algorithm (behavior) into hardware (structure):
pure behavioral, mixed and pure structural. The mixed and pure structural stages parti-
tion the machine into a controller and an architecture.
In addition, this chapter describes instantiating structural modules (hierarchical de-
sign). This allows the pure structural 

READY stage to be described in an understandable way,
.. ... ... ... ... ... without having to descend to the extreme gate-level detail of a netlist.

The next chapter introduces an automated textual notation that allows us to express
behavioral, structural and hierarchical design in a unified notation.

behavioral stage, has a
chine. The machine has 2.7 Further Reading
hart (see section 2.2.7). CLAIR, C. R., Designing Logic Systems Using State Machines, 
allows the machine McGraw-Hill, 

to New
York, 1973. This short but influential book was the first to explain the ASM chart
notation, which T. E. Osborne had invented in the early 1960s at Hewlett Packard.

Instantiated inside the
mixed stage, the struc- GATsI, DANIEL D., Principles of Digital Design, Prentice Hall, Upper Saddle River,

ich is described only in NJ, 1997. Chapter 8 describes ASM charts. This book uses the term datapath to mean
;M chart refers only to what is called an architecture here and uses = rather than - for RTN.
rd, is visible; however
,s, known only by their

o Hardware DesigningA SMs 59



&.2- D)Peign san
PROSSER, FRANKLIN P. and DAVID E. WINKEL, The Art of DigitalD esign: An Introduction
to Top Down Design, 2nd ed., PTR Prentice Hall, Englewood Cliffs, NJ, 2nd ed., 1987.
Chapters 5-8 give several examples of ASM charts using RTN. This book uses the term
architecture the way it is used here.

2.8 Exercises
2-1. Give a pure behavioral ASM for a factorial machine. The factorial of n is the
product of the numbers from 1 to n. This machine has the data input, n, a push button
input, pb, a data output, prod, and an external status output, READY. READY and
pb are similar to those described in section 2.2.1. Until the user pushes the button,
READY is asserted and prod continues to be whatever it was. When the user pushes
the button, READY is no longer asserted and the machine computes the factorial by
doing no more than one multiplication per clock cycle. For example, when n= 5 after
an appropriate number of clock cycles prod becomes 120 == 1 * 1 * 2 * 3 * 4 * 5
1 * 5 * 4 * 3 * 2 * 1 and READY is asserted again.

Use a linear time algorithm in the input n, which means the exact number of clock
cycles that this machine takes to compute n! for a particular value of n can be ex-
pressed as some constant times n plus another constant. (All of the childish division
examples in this chapter are linear time algorithms in the quotient.) For example, a
machine that takes 57 * n+ 17 clock cycles to compute n! would be acceptable, but
you can probably do better than that.

2-2. Design an architecture block diagram and corresponding mixed ASM that is able
to implement the algorithm of problem 2-1 assuming the architecture is composed of
the following building blocks: up/down counter registers, multiplier, comparator and
muxes. Give a system diagram that shows how the architecture and controller fit to-
gether, labeled with appropriate signal names.

2-3. Give a table that describes the structural controller for problem 2-2.

2-4. Give a pure behavioral ASM similar to problem 2- 1, but use repeated addition to
perform multiplication. For example, l3  * 14 = = 0 + 13 +13 + 13 + 13 + 13 + 13
+13 +13 +13 +13 +13 +13 +13 +13.Directmultiplicationinasinglecycleis
not allowed. The algorithm should be suitable for implementation with the central ALU
approach. This will be a quadratic time algorithm in n because of nested loops.

2-10. For e
registers, %

60 Verilog Digital Computer Design: Algorithms into Hardware



esign: An Introduction 2-5. Design an architecture block diagram and corresponding mixed ASM for problem
iffs, NJ, 2nd ed., 1987. 2-4 assuming the following building blocks: enabled registers, muxes, comparator, and
his book uses the term the ALU described in section C.6. Give a system diagram that shows how the architec-

ture and controller fit together, labeled with appropriate signal names. Label the a and
b inputs of the ALU.

2-6. Give a table that describes the structural controller for problem 2-5.
e factorial of n is the
nput, n, 2-7. 

a push Give 
button a pure behavioral ASM similar to problem 2-4, but use a shift and add algo-

READY READY rithm 
and to perform multiplication. Direct multiplication in a single cycle is not allowed.

ier pushes Here is 
the an 

button, example of multiplying 14 by 13 using the shift and add algorithm with 4-bit
When the input 

user representations, 
pushes and an 8-bit product.

iputes the factorial by 1110
mple, when n=5 after *1101
1*1*2*3*4*5 ==

00001110 do (1) add 14 in this cycle
don' t (0) add 28 in this cycle

xact number 00111000 
of clock do (1) add 56 in this cycle

+ 01110000 do (1) add
value of 112 

n can in 
be this 

ex- cycle

Ft he childish division 10110110 product is 182
ient.) For example, a
ild be acceptable, but The number of cycles to perform a single multiplication by n is proportional to the

number of bits used to represent n, which is roughly the logarithm of n. But you have
to perform n such multiplications, and so this factorial algorithm is what is called an n

ixed ASM that is able log n time algorithm, which takes more clock cycles than a linear time algorithm but
Picture is composed of fewer clock cycles than a quadratic time algorithm when n is large. (Note that unlike
plier, comparator and the linear time algorithm of problem 2-1, this approach does not require an expensive
and controller fit to- multiplier.) You should use a methodical approach that exploits maximal parallelism.

2-8. Design an architecture block diagram and corresponding mixed ASM that is able
lem. 2-2. to implement problem 2-7 assuming the following building blocks: enabled registers,

counter registers, shift registers, muxes, adder, comparator. Give a system diagram that
e repeated addition to shows how the architecture and controller fit together, labeled with appropriate signal
+13 +13 +13 +13 names.
ion in a single cycle is
i with the central ALU 2-9. Give a table that describes the structural controller for problem 2-8. (See section
If nested loops. D.9 for details about controlling a shift register.)

2-10. For each of the following ASMs, draw a timing diagram. x, y and z are 8-bit
registers, whose values should be shown in decimal.

Hardware Designing ASMs 61



2-14. Design an
c) to implement pr

counter register,
ber of any kind

2-15. Design an
to implement pi
enabled register
system diagram

2-16. Design an
to implement pi

d) counter register
ber of any kind

y-2

2-17. Like 2-16.
bit adder, and a

I I xyS x I~~~~~~ 2-18. Design an
to implement pi
shift register (se
ter (section D.J
diagram.

2-19. Like 2-18
enabled register

2-11. Design an architecture block diagram and corresponding mixed ASM that is able any kind of mu
to implement problem 2-10, part a assuming the following building blocks: two 8-bit
counter registers, one 8-bit adder, and any number of any kind of mux. Give a system
diagram that shows how the architecture and controller fit together, labeled with appro-
priate signal names.

2-12. Like 2-11, except use: one 8-bit counter register, one 8-bit enabled register, one
8-bit ALU and any number of any kind of mux. Label the a and b inputs of the ALU.

2-13. Design an architecture block diagram and corresponding mixed ASM that is able
to implement problem 2-10, part b assuming the following building blocks: two 8-bit
enabled registers, one 8-bit adder, one 8-bit incrementor and any number of any kind of
mux. Give a system diagram.

62 Verilog Digital Computer Design: Algorithms into Hardware



2-14. Design an architecture block diagram and corresponding mixed ASM that is able
to implement problem 2-10, part c assuming the following building blocks: one 8-bit

I counter register, one 8-bit enabled register, one 8-bit ALU (section C.6) and any num-
+ ber of any kind of mux. Give a system diagram. Label the a and b inputs of the ALU.

2-15. Design an architecture block diagram and corresponding mixed ASM that is able
to implement problem 2-10, part d assuming the following building blocks: two 8-bit

I enabled registers, one 8-bit ALU (see section C.6) and one 8-bit two-input mux. Give a

]ildyn
system diagram. Label the a and b inputs of the ALU.

2-16. Design an architecture block diagram and corresponding mixed ASM that is able
to implement problem 2-10, part e assuming the following building blocks: two 8-bit
counter registers, one 8-bit enabled register, one 8-bit ALU (section C.6) and any num-
ber of any kind of mux. Give a system diagram. Label the a and b inputs of the ALU.

2-17. Like 2-16, except use: one 8-bit incrementor, three 8-bit enabled registers, one 8-
bit adder, and any number of any kind of mux.

2-18. Design an architecture block diagram and corresponding mixed ASM that is able
fl to implement problem 2-10, part f assuming the following building blocks: one 8-bit

shift register (section D.9), one 8-bit counter register, one 8-bit up/down counter regis-
ter (section D.8) and one 8-bit adder. You may not use any muxes. Give a system

I diagram.

2-19. Like 2-18, except use: one 8-bit incrementor, one 8-bit decrementor, three 8-bit
enabled registers, one 8-bit adder, one 8-bit combinational shifter, and any number of

mixed A SM that is able any kind of mux.
ildineg;  blocks: two 8-bit
I ofn mux. Give a system
her, laibeled with appro-

mix(

)it enaibled registerr,,  one
id b inaputs of the ALU.

mixedI ASM that is able
ilding .blocks: two 8-bit
y numiber of any kind of

o Hardware Designing ASMs 63



step (typically
3. VERILOG HARDWARE hardware is of

circuit from a

DESCRIPTION physical fabric
matches the ori

LANGUAGE errors.

The previous chapter describes how a designer may manually use ASM charts (to de-
scribe behavior) and block diagrams (to describe structure) in top-down hardware de- 3.2 Veri]
sign. The previous chapter also describes how a designer may think hierarchically, HDLs are text
where one module's internal structure is defined in terms of the instantiation of other down design p
modules. This chapter explains how a designer can express all of these ideas in a spe- the behavioral
cial hardware description language known as Verilog. It also explains how Verilog can tures of HDLs
test whether the design meets certain specifications. make an HDI

instantiation a

There are man
3.1 Simulation versus synthesis widely used H
Although the techniques given in chapter 2 work wonderfully to design small ma- by a company
chines by hand, for larger designs it is desirable to automate much of this process. To Verilog to a cc
automate hardware design requires a Hardware Description Language (HDL), a differ- tional (OVI).
ent notation than what we used in chapter 2 which is suitable for processing on a gen- Verilog is eas
eral-purpose computer. There are two major kinds of HDL processing that can occur: thrown in for f
simulation and synthesis. If you want to

Simulation is the interpretation of the HDL statements for the purpose of producing VHDL is a De
human readable output, such as a timing diagram, that predicts approximately how the defense contr;
hardware will behave before it is actually fabricated. As such, HDL simulation is quite those in Verily
similar to running a program in a conventional high-level language, such as Java Script, strongly influ
LISP or BASIC, that is interpreted. Simulation is useful to a designer because it allows guage that th
detection of functional errors in a design without having to fabricate the actual hard- before VHDL
ware. When a designer catches an error with simulation, the error can be corrected with VHDL than -i
a few keystrokes. If the error is not caught until the hardware is fabricated, correcting VHDL. VHD
the problem is much more costly and complicated.

Synthesis is the compilation of high-level behavioral and structural HDL statements
into a flattened gate-level netlist, which then can be used directly either to lay out a 3.3 Rot
printed circuit board, to fabricate a custom integrated circuit or to program a program- The original ]
mable logic device (such as a ROM, PLA, PLD, FPGA, CPLD, etc.). As such, synthe- guage for sini
sis is quite similar to compiling a program in a conventional high-level language, such tion for descr
as C. The difference is that, instead of producing object code that runs on the same during simul
computer, synthesis produces a physical piece of hardware that implements the com- executable st;
putation described by the HDL code. For the designer, producing the netlist is a simple original reasc

64 Verilog Digital Computer Design: Algorithms into Hardware



VARE step (typically done with only a few keystrokes), but turning the netlist into physical
hardware is often costly, especially when the goal is to obtain a custom integrated
circuit from a commercial silicon foundry. Typically after synthesis, but before the
physical fabrication, the designer simulates the synthesized netlist to see if its behavior
matches the original HDL description. Such post-synthesis simulation can prevent costly
errors.

use ASM charts (to de-
top-down hardware de- 3.2 Verilog versus VHDL

lay think hierarchically, HDLs are textual, rather than graphic, ways to describe the various stages in 
he the 

instantiation top-
of other down design process. In the same language, HDLs allow the designer to express both

I of these ideas in a spe- the behavioral and structural aspects of each stage in the design. The behavioral fea-
xplains how Verilog can tures of HDLs are quite similar to conventional high-level languages. The features that

make an HDL unique are those structural constructs that allow description of the
instantiation and interconnection of modules.

There are many proprietary HDLs in use today, but there are only two standardized and
widely used HDLs: Verilog and VHDL. Verilog began 

[ly to design as a proprietary 
small ma- HDL promoted

by a company called Cadence Data Systems, Inc., but 
nuch Cadence 

of this process. transferred 
To control of

Verilog to a consortium of companies and universities known 
nguage as Open 

(HDL), Verilog 
a differ- Interna-

tional (OVI). Many companies now produce 
For processing tools that 

on work 
a gen- with standard Verilog.

Verilog is easy to learn. It has a syntax reminiscent of C (with 
:cessing some Pascal 

that can occur: syntax
thrown in for flavor). About half of commercial HDL work in the U.S. is done in Verilog.
If you want to work as a digital hardware designer, it is important to know Verilog.

e purpose of producing VHDL is a Department of Defense (DOD) mandated 
approximately language that 

how is 
the used primarily by

defense contractors. Although most of the concepts in 
HDL VHDL 

simulation are not 
is quite different from

those in Verilog, VHDL is much harder to learn. It has 
age, such a rigid 

as and 
Java Script, unforgiving syntax

strongly influenced by Ada (which is 
signer an unpopular 

because it conventional 
allows programming lan-

guage that the DOD mandated defense software contractors to use 
tbricate for 

the many 
actual years

hard- before VHDL was developed). Although more academic 
or papers 

can be corrected are published 
with about

VHDL than Verilog, less than one-half of commercial HDL work 
is fabricated, in the U.S. is 

correcting done in
VHDL. VHDL is more popular in Europe than it is in the U.S.

ictural HDL statements
ectly either to lay out a 3.3 Role of test code
rt o program a program- The original purpose of Verilog (and VHDL) was to provide designers a unified lan-
), etc.). As such, synthe- guage for simulating gate-level netlists. Therefore, Verilog combines a structural nota-
gh-level language, such tion for describing netlists with a behavioral notation for saying how to test such netlists
z that runs on the same during simulation. The behavioral notation in Verilog looks very much like normal

at implements the com- executable statements in a procedural programming language, such as Pascal or C. The
ng the netlist is a simple original reason for using such statements in Verilog code was to provide stimulus to the

So Hardware Verilog HardwareD escription Language 65



netlist, and to test the subsequent response of the netlist. The pairs of stimulus and Varial
response are known as test vectors. The Verilgo that creates the stimulus and observes start of a
the response is known as the test code or testbench. Snoopy's "woof" in the comic strip nriables a
of section 2.2 is analougus to the role of the test codes warning us that the expected le of the s
response was not observed. For example, one way to use simulation to test whether a
small machine works is to do an exhaustive test, where the test code provides each
possible combination of inputs to the netlist and then checks the response of the netlist
to see if it is appropriate.

For example, bars are 
consider the division machine of the last chapter. Assume we have devel-

fall an
oped a flattened netlist that implements the complete machine. It would not be at all

are intend
obvious whether this netlist is correct. Since the bus width specified in this problem is
small (twelve id wire,

bits), we can write Verilog test code using procedural Verilog (similar to wo hardw
statements in C) that does an exhaustive test. A reasonable approach would be to use

i its value
two nested loops, one that varies x through all its 4096 possible values, and one that
varies y through tions are

all its 4095 possible values. At appropriate times inside the inner loop,
i wide. T

the test code would check (using an if statement) whether the output of the netlist
matches I in squar

x/y. Verilog provides most of the integer and logical operations found in C,
including those, such as division, that are difficult to implement in hardware. The origi-
nal intent was not to synthesize such code into hardware but to document how the
netlist should automatically be tested during simulation.

Verilog has all of the features you need to write conventional high-level language pro- es two vai
grams. Except for file Input/Output (/O), any program that you could write in a con- -a. nt bit o
ventional high- level language can also be written in Verilog. The original reason Verilog tred to be
provides all this software power in a "hardware" language is because it is impossible to pports th
do an exhaustive test of a complex netlist. The 12-bit division machine can be tested
exhaustively because there are only 16,773,120 combinations with the 24 bits of input
to the netlist. A well-optimized version of Verilog might be able to conduct such a
simulation in a few days or weeks. If the bus width were increased, say to 32-bits, the nowbic
time to simulate all 264 combinations would be millions of years. Rather than give up
on testing, designers write more clever test code. The test code will appear longer, but store a si
will execute in much less time. Of course, if a machine has a flaw that expresses itself sample, th
for only a few of the 264 test patterns, the probability that our fast test code will find the
flaw is usually low.

same as:

3.4 Behavioral features of Verilog
Verilog is composed of modules (which play an important role in the structural aspects
of the language, as will be described in section 3.10). All the definitions and declara-
tions in Verilog occur inside a module.

la to simple
Vwyi dth. St

66 Verilog Digital Computer Design: Algorithms into Hardware



iep airs of stimulus and 3.4.1 Variable declaration
e stimulus and observes At the start of a module, one 
woof" may 

in declare 
the comic variables 

strip to be integer or to be real.
Such variables act just 

ing us like 
that the 

the software 
expected declarations int and float in C. Here is an

example of the syntax:
elation to test whether a
test code provides each

integer x,y;
te response of the netlist real Rain-fall;

Assume we have devel- Underbars are permitted in Verilog identifiers. Verilog is case sensitive, and so
e. It would not be at all Rain_fall and rain fall are distinct variables. The declarations integer and
cified in this problem is real are intended only for use in test code. Verilog provides other data types, such as
lural Verilog (similar to reg and wire, used in the actual description of hardware. The difference between
proach would be to use these two hardware-oriented declarations primarily has to do with whether the variable
)le values, and one that is given its value by behavioral (reg) or structural (wire) Verilog code. Both of these
es inside the inner loop, declarations are treated like unsigned in C. By default, regs and wires are only
he output of the netlist one bit wide. To specify a wider reg or wire, the left and right bit positions are
I operations found in C, defined in square brackets, separated by a colon. For example:
in hardware. The origi-

t to document how the
reg [3:0] nibble,four bits;

igh-level language pro- declares two variables, each of which can contain numbers between 0 and 15. The most
)u could write in a con- significant bit of nibble isd eclared to be nibble [3], and the least significant bit
original reason Verilog is declared to be nibble [] . This approach is known as little endian notation. Verilog

cause it is impossible to also supports the opposite approach, known as big endian notation:
i machine can be tested
with the 24 bits of input reg [0:3] bigend nibble;
able to conduct such a
ased, say to 32-bits, the where now bigendnibble [3] isth e least significant bit.
trs. Rather than give up
will appear longer, but If you store a signed value' in a reg, the bits are treated as though they are unsigned.
aw that expresses itself For example, the following:
st test code will find the

I four-bits = -5;

is the same as:

in the fourbits 
structural aspects = 11;

lefinitions and declara-

1I n order to simplify dealing with twos complement values, many implementations allow integers with an
arbitrary width. Such declarations are like regs, except they are signed.

? Hardware Verilog Hardware DescriptionL anguage 67



Verilog supports concatenation of bits to form a wider wire or reg, for example, Continued
{nibble[2], nibble [1] is a two bit reg composed of the middle two bits of
nibble. Verilog also provides a shorthand for obtaining a contiguous set of bits taken if (condi

stateme
from a single reg or wire. For example, the middle two bits of nibble can also be

else
specified as nibble [2 :1 ] . It is legal to assign values using either of these notations. stateme

Verilog also allows arrays to be defined. For example, an array of reals could be de-
fined as: while (cc

stateme

for (var=
real monthly-precip[ll:0]; stateme

Each of the twelve elements of the array (from monthly-precip [0] to forever
monthlyprecip [11]) is a unique real number. Verilog also allows arrays of wires stateme
and regs to be defined. For example,

case (exg

reg [3:0] reg-arr[999:0]; cons tar

wire[3:0] wirarr[999:0]; ...
default

endcase
Here, regarr [0] is a four-bit variable that can be assigned any number between 0
and 15 by behavioral code, but wirarr [0] is a four-bit value that cannot be as-

where the italic s
signed its value from behavioral code. There are one thousand elements, each four bits

replaced with apj
wide, in each of these two arrays. Although the [ ] means bit select for scalar values,

ment is one of tn
such as nibble [3] , the [ means element select with arrays. It is illegal to com-

semicolons insic
bine these two uses of [ into one, as in i f (regarr [][3]) .To accomplish this

real, reg or a
operation requires two statements:

nibble = reg_arr[O]; 3.4.3 Expre
I ~~i(fn ibble[3]) ... An expressic

(+- I. 
(<, ==, ==,<

3.4.2 Statements legal in behavioral Verilog is an expression,
The behavioral statements of Verilog include2 the following: would be produc

or an expression
var = expression; 1. Except for ==

the result is stor
if (condition) operators, for ex;

statement three:

2 There are other, more advanced statements that are legal. Some of these are described in chapters 6
and 7. 3 Some results are di

68 Verilog Digital Computer Design: Algorithms into Hardware

M



or reg, for example, Continued
)f the middle two bits of
itiguous set of bits taken if (condition)

of nibble can also be statement

zither of these notations. else
statement

iy of reals could be de-
)

ion; condition; var=var+expression)
l

lyprecip[O] to
allows arrays of wires

ement

ien t
I any number between 0
ralue that cannot be as-
elements, each four bits t, var, expression, condition and constant are
select for scalar values, 'erilog syntax for those parts of the language. A state-
ays. It is illegal to com- tements or a series of the above statements terminated by
] ) . To accomplish this and end. A var is a variable declared as integer,

on of regs. A var cannot be declared as wire.

constants and variables (including wires) with arithmetic
Yical (&,&&, l I , , , <<, >>), relational

=,>) and conditional (?:) operators. A condition
tion might be an expression involving a single bit, (as

&&, !, <, ==, ===, <=, >=, !=, !==or>)
everal bits that is checked by Verilog to see if it is equal to
these symbols have the same meaning as in C. Assuming
it reg,) the following table illustrates the result of these

the left operand (if present) is ten and the right operand is

-are described in chapters 6

destination is declared differently.

loH ardware g Hardware DescriptionL anguage 69



name example 16-bit
unsigned declarat
result

addition initial
10+3 13

subtraction begin
10-3 7

negation stat
-10 6552 6

multiplication . . .
10*3 30

division stat
10 /3 3

remainder end
10%3 1

shift left 10<<3 80
shift endmodule

right 10>>3
& bitwise AND 10&3 1

bitwise OR 2 The name oj
10 13

bitwise exclusive OR 10^3 declaratic
9

bitwise NOT -10 6552 men 
5 t is termi

conditional operator 0?10:3 3 rather than { a
1?10:3 10 may be omitte

tial block.
logical NOT !10 0
logical AND 10&&3 1 Here 
logical is an 

OR exa
II 10113 1

less than section 3.3:
10<3 0

equal to 10==30
less than or equal to 10<=3 module tol
greater than or equal 10>=3 0 integer 
not equal 10 initial

!= 3 1
greater than 1 begin

10>3
& 10>3 I I x = 

while
beg
f

3.4.4 Blocks
All procedural statements occur in what are called blocks that are defined inside mod-
ules, after the type declarations. There are two kinds of procedural blocks: the
initial block and the always x

block. For the moment, let us consider only the
initial end

block.An initial blockis like conventional software. It starts execution $write 
and eventually (assuming there is not an infinite loop inside the initial block) it $displa:
stops execution. The simplest form for a single Verilog initial block is: endmodule

The loop involi
as a while for
it is necessary t(

70 Verilog Digital Computer Design: Algorithms into Hardware



module top;
ple 16-bit

unsigned declarations;
result

initial
13 begin
7 statement;

65526 ...
30 statement;
33 end

3 81
80 endmodule
1

3 ~~2 The name of the module (top in this case) is arbitrary. The syntax of the
11 declarationsi s as described above. All variables shouldbe declared. Eachstate-
39 ment is terminated with a semicolon. 

65525 Verilog uses the Pascal-like begin and end,
rather than { and 

3 . There is no semicolon after begin or end. The begin and end
10 may be omitted in the rare case that only one procedural statement occurs in the ini -

tial block.
0
31 Here is an example that prints out all 16,773,120 combinations of values described in

3 ~~1 section 3.3:
30

module top;
3 ~~0 integer x,y;

31 initial
31 begin

3 ~~1 x = 0;
while (x<=4095)

begin
for (y=l; y<=4095; y = y+1)
begin

$display("x=%d y=%d",x,y);
end

.t are defined inside mod- x = x + 1;
procedural blocks: the end
let us consider only the end

ftware. It starts execution $write("all );
the initial block) it $display("done");

: ial block is: endmodule

The loop involving x could have been written as a f or loop also but was shown above
as a while for illustration. Note that Verilog does not have the ++ found in C, and so
it is necessary to say something like y = y + 1. This assignment statement is just like

ito Hardware Verilog Hardware DescriptionL anguage 71



its counterpart in C: it is instantaneous. The varial
statement executes (unlike the RTN discussed in ti 3.4.5 Cons
play is a system task (which begin with $) that By default, con
printf("%d %d \n",x,y) does in C: it form fied explicitly
the string in the quotes. The system task $write d syntax b, c
except that it does not produce a new line: 'hd, and 13a

representation,
x= 0 y= 1
x= 0 y= 2 3.4.6 Mac]

As an aid to rn
x= 4095 y= 4094 example, the a
x= 4095 y= 4095
all done

The above code would fail if the declaration had bee
Later in the coc

reg [11:0] x,y; substituting the

because, although twelve bits are adequate for the ha if (aluctr
x and y become 4096 in order for the loop to stop. I $display(

Since infinite loops are useful in hardware, Verilo 1 Note the synta
which means the same thing as while (1). In additi 'DIFFERENC
above can be described as an initial block cont, anything. Macrn
simulation purposes, the following mean the same: quote.

initial initial You can detern
begin begin preprocessing f
while(l) forever

begin begin
... ...

end end
end end

For synthesis, one should use the always block for prints the mess
is not a block and cannot stand by itself. Like other defined. The 
must be inside an initial or always block. 'DIFFERENC.

Verilog allows,
clude in C an

I

72 Verilog Digital Computer Design: Algc



es value before the next
is chapter). The $dis- 3.4.5 Constants
nething similar to what By default, constants in Verilog are assumed to be decimal integers. They may be speci-
Ltual output according to fied explicitly in binary, octal, decimal, or hexadecimal by prefacing them with the
ne thing as $display, syntax 'b, o, d, or h, respectively. For example, 'bl l1, ol5, dl3,

'hd, and 13 all mean the same thing. If you wish to specify the number of bits in the
representation, this proceeds the quote: 4 bllOl, 4 ol5, 4 dl3, 4 hd.

3.4.6 Macros, include files and comments
As an aid to readability of the code, Verilog provides a way to define macros. For
example, the aluctrl codes described in 2.3.1 can be defined with:

'define DIFFERENCE 6'bO11001
'define PASSB 6'blO1010

Later in the code, a reference to these macros (preceded by a backquote) is the same as
I substituting the associated value. The following i fs mean the same:

ie test code requires that if (aluctrl == 'DIFFERENCE) if (aluctrl == 6'bOllOOl)
$display("subtracting'); $display("subtracting");

ithe syntax f orever, Note the syntax difference between variables (such as aluctrl), macros (such as
Lways block mentioned 'DIFFERENCE), andconstants (such as 6 bO11001). Variables arenotprecededby
y a forever loop. For anything. Macros are preceded by backquote. Constants may include one forward single

quote.

You can determine whether a macro is defined using ' ifdef and ' endi f. This
preprocessing feature should not be confused with if. For example, the following:

'ifdef DIFFERENCE
$display("defined");

'endif

prints 
he statement the message 

forever regardless of the value of DIFFERENCE, as long as that macro is
defined. 

I statements, The 
forever message is not printed only when there is not a define for

'DIFFERENCE.

Verilog allows you to separate your source code into more than one file (just like #in-
clude in C and { $I) in Pascal). To use code contained in another file, you say:

| 'include "filename.v"

o Hardware
Verilog Hardware Description Language 73



There are two forms of comments in Verilog, which are the same as the two forms 3.5.1 Instai
found in C++. A comment that extends only for the rest of the current line can occur Of course, there
after / /. A comment that extends for several lines begins with / * and ends with * an xor gate (re(
For example:

/* a multi line comment
that includes a declaration:

reg a;
which is ignored by Verilog

*/
reg b; // this declaration is not ignored

3.5 Structural features of Verilog
Verilog provides a rich set of built-in logic gates, including and, or, xor, nand,
nor, not and buf, that are used to describe a netlist. The syntax for these structural The order in whi
features of Verilog is quite different than for any of the behavioral features of Verilog so the following
mentioned earlier. The outputs of such gates are declared to be wire, which by itself
describes a one-bit data type. (Regardless of width, an output generated by structural
Verilog code must be declared as a wire.) The inputs to such gates may be either
declared as wire or reg (depending on whether the inputs are themselves computed
by structural or behavioral code). To instantiate such a gate, you say what kind of gate
you want (xor for example) and the name of this particular instance (since there may
be several instances of xor gates, let's name this example xl). Following the instance
name, inside parentheses are the output and input ports of the gate (for example, say the
output is a wire named c, and the inputs are a and b). The output(s) of gates are
always on the left inside the parentheses:

module easyxor;
reg a,b;
wire c; means the same
xor xl(c,a,b); circuit diagram:

endmodule

People familiar with procedural programming languages, like C, mistakenly assume
this is "passing c, a and b and then calling on xor." It is doing no such thing. It
simply says that an xor gate named xl has its output connected to c and its inputs
connected to a and b. If you are familiar with graph theory, this notation is simply a
way to describe the edges (a, b, c) and vertex (xl) of a graph that represents the
structure of a circuit.

Figure3 -1. .

74 Verilog Digital Computer Design: Algorithms into Hardware



same as the two forms 3.5.1 Instantiating multiple gates
current line can occur Of course, there is an equivalent structure of and/or gates that does the same thing as

l / * and ends with * /. an xor gate (recall the identity a-b == a&( -b) I( -a)& b):

module hardxor;
reg a,b;
wire c;
wire tl,t2,nota,not-b;

not il(nota,a);
not i2(not-b,b);
and al(tl,nota,b);
and a2(t2,a,not-b);
or ol(c,tl,t2);

endmodule
Ld, or, xor, nand,
ntax for these structural The order in which gates are instantiated in structural Verilog code does not matter, and
oral features of Verilog so the following:
wire, which by itself

generated by structural module scrambled xor;
ch gates may be either reg a,b;
e themselves computed wire c;

iu say what kind of gate wire tl,t2,nota,not-b;

stance (since there may
Following or 

the instance ol(c,tl,t2);
and al(tl,nota,b);

kte (for example, say the and a2(t2,a,not-b);
output(s) of gates are not il(nota,a);

not i2(not-b,b);

endmodule

means the same thing, because they both represent the interconnection in the following
circuit diagram:

C, mistakenly assume
loing no such thing. It
cted to c and its inputs
his notation is simply a
aph that represents the

Figure 3-1. Exclusive or built with ANDs, OR and inverters.

o Hardware Verilog Hardware Description Language 75



3.5.2 Comparison with behavioral code 3.5.3 Inter(
Structural Verilog code does not describe the order in which computations implemented In software, a bi
by such a structure are carried out by the Verilog simulator. This is in sharp contrast to the case also, bi
behavioral Verilog code, such as the following: produce electro

physical possibi
module behavioral xor; 1 'bz or 1' bx.

reg a,b; Obviously, 1 '
reg c; normally expec
reg tl,t2,nota,notb;

are represented
always ... represent 1 'bC

begin represent 1 lbC
nota = -a; such as CMOS
notb = -b; represent infon
tl = nota&b;
t2 = a&not-b; 3.5.3.1 HiA
c = tllt2;

In any technolc
end

endmodule a designer forq
means that ther

which is a correct behavioral rendition of the same idea. (The ellipses must be replaced this as high iml
byaVerilogfeaturedescribedlater.)Also, c, tl, t2, not_a and notbmust normally view
be declared as regs because this behavioral (rather than structural) code assigns val- which this wire
ues to them. active low, it.,

Furthermore, e

To rearrange the order of behavioral assignment statements is incorrect: family. For the
tinct from 1 ' h

module bad xor; example from

reg a,b;
reg c;
reg t,t2,nota,notb;

always ...
begin

C = tllt2;
tl = not_a&b;
t2 = a&notb;
not-a = -a;
not-b = -b;

end
endmodule

because not_a must be computed before t 1 by the Verilog simulator. 4Verilog also alk
scope of this boc

76 Verilog Digital Computer Design: Algorithms into Hardware



3.5.3 Interconnection errors: four-valued logic
iputations implemented In software, a bit is either a 0 or a 1. In properly functioning hardware, this is usually
is is in sharp contrast to the case also, but it is possible for gates to be wired together incorrectly in ways that

produce electronic signals that are neither 0 nor 1. To more accurately model such
physical possibilities,4 each bit in Verilog can be one of four things: 1 ' bO, 1 ' bl,
1 'bz or 1 bx.

Obviously, 1 bO and 1 bi correspond to the logical 0 and logical 1 that we would
normally expect to find in a computer. For most technologies, these two possibilities
are represented by a voltage on a wire. For example, active high TTL logic would
represent 1 ' bO as zero volts and 1 ' bl as five volts. Active low TTL logic would
represent 1 ' bO as five volts and 1 ' bl as zero volts. Other kinds of logic families,
such as CMOS, use different voltages. ECL logic uses current, rather than voltage, to
represent information, but the concept is the same.

3.5.3.1 High impedance
In any technology, it is possible for gates to be miswired. One kind of problem is when
a designer forgets to connect a wire or forgets to instantiate a necessary gate. This
means that there is a wire in the system which is not connected to anything. We refer to

lipses must be replaced this as high impedance, which in Verilog notation is 1 'bz. The TTL logic family will
._a and not_bmust normally view high impedance as being the same as five volts. If the input of a gate to
tural) code assigns val- which this wire is connected is active high, 1 bz will be treated as 1 b, but if it is

active low, it will be treated as 1 'bO. Other logic families treat 1 'bz differently.
Furthermore, electrical noise may cause 1 bz to be treated spuriously in any logic

ncorrect: family. For these reasons, it is important for a Verilog simulator to treat 1 ' bz as dis-
tinct from 1 bO and 1 b. For example, if the designer forgets the final or gate in the
example from section 3.5. 1:

module forget-orthat_outputsc;
reg a,b;
wire c;
wire tl,t2,nota,notb;

not il(nota,a);
not i2(not-b,b);
and al(tl,nota,b);
and a2(t2,a,notb);

endmodule

rnulator. 4 Verilog also allows each bit to have a strength, which is an electronic concept (below gate level) beyond the
scope of this book.

,H ardware Verilog HardwareD escription Language 77



3.5.2 Comparison with behavioral code 3.5.3 
Structural Int

Verilog code does not describe the order in which computations
by such a structure In software,,

are carried out by the Verilog simulator. This is in sh2
behavioral Verilog code, the 

such case also
as the following:

produce elec
physical pos!

module behavioral xor;
1 bz or 1 v]I

reg a,b;
reg c; Obviously, 1
reg tl,t2,not-a,not-b; normally exi

are represent
always ... represent 1'

begin represent 1'
nota = -a; such as CM(
notb = b; represent infi
tl = nota&b;
t2 = a&not-b;
c = tllt2; 3.5.3.1 h

end In any technc
endmodule a designer ft

means that th
which is a correct behavioral rendition of the same idea. (The ellipses mu: this as high ii
byaVerilogfeaturedescribedlater.)Also, c, t, t2, nota and normally vie
be declared as regs because this behavioral (rather than structural) cod, which this w
ues to them. active low, ii

Furthermore,
To rearrange the order of behavioral assignment statements is incorrect: family. For td

tinct from 1 
module bad.xor;

example fron
reg a,b;
reg c;
reg tl,t2,nota,not-b;

always ...
begin

c = tlt2;
tl = not_a&b;
t2 = a&notb;
not-a = -a;
not-b = -b;

end
endmodule

because not-a must be computed before t 1 by the Verilog simulator. 4 Verilog also all
scope of this boc

76 Verilog Digital Computer Design: Algorithms into Hardwar



3.5.3 Interconnection errors: four-valued logic
amputations implemented In software, a bit is either a 0 or a 1. In properly 
his is in sharp functioning 

contrast hardware, 
to this is usually

the case also, but it is possible for gates to be wired together incorrectly in ways that
produce electronic signals that are neither 0 nor 1. To more accurately model such
physical possibilities,4 each bit in Verilog can be one of four things: 1 bO, 1 'bl,
1 'bz or 1 bx.

Obviously, 1 'bO and 1 b correspond to the logical 0 and logical 1 that we would
normally expect to find in a computer. For most technologies, these two possibilities
are represented by a voltage on a wire. For example, active high TL logic would
represent 1 bO as zero volts and 1 'b as five volts. Active low TTL logic would
represent 1 as five volts and 1 hi as zero volts. Other kinds of logic families,
such as CMOS, use different voltages. ECL logic uses current, rather than voltage, to
represent information, but the concept is the same.

3.5.3.1 High impedance
In any technology, it is possible for gates to be miswired. One kind of problem is when
a designer forgets to connect a wire or forgets to instantiate a necessary gate. This
means that there is a wire in the system which is not connected to anything. We refer to

,llipses must be replaced this as high impedance, which in Verilog notation is 1 bz. The TTL logic family will
ta and notb must normally view high impedance as being the same as five volts. If the input of a gate to
ctural) code assigns val- which this wire is connected is active high, 1 'bz will be treated as 1 bi, but if it is

active low, it will be treated as 1 'bO. Other logic families treat 1 'bz differently.
Furthermore, electrical noise may cause 1 bz to be treated spuriously in any logic

incorrect: family. For these reasons, it is important for a Verilog simulator to treat 1 bz as dis-
tinct from 1bO and 1 bl. For example, if the designer forgets the final or gate in the
example from section 3.5.1:

module forgetor_that_outputsc;
reg a,b;
wire c;
wire tl,t2,nota,not-b;

not il(nota,a);
not i2(not b,b);
and al(tl,nota,b);
and a2(t2,a,notb);

endmodule

imulator. 4 Verilog also allows each bit to have a strength, which is an electronic concept (below gate level) beyond the
scope of this book.

7 Hardware
Verilog HardwareD escription Language 77



there is no gate th imeftic and
what a and b are. qy-when boti

HTt is bx.I
3.5.3.2 Unkn arlement suc
Another way in wl nuances.
together. This raise

IS
output a 1 ' bO, I to~
eliminate the or g

I never disl
eration is al
ver executes

%rea re two
1. === and
elligent sirn

'N

the result is correct
produce 1 bO and
bis 1 'bl orvice) il display th,
cause physical dan
Obviously, we wai
fabricate a chip th, Do help under

statements are
3.5.3.3 Use in
Behavioral code m
behavioral code st if (expi
disconnected wire state

I and - are define,
associativity, etc. a [be following

Prs:
The four-valued lo
are either 1 ' b or l I
two) applies. Whe
numeric value is ui

78 Verilo



s 1 'bz, regardless of Arithmetic and relational operators (including == and ! =) produce their usual results
only when both operands are composed of 1 bOs and 1 bis. In any other case, the
result is bx. This relates to the fact the corresponding combinational logic required to
implement such operations in hardware would not produce a reliable result under such

of two gates are wired circumstances. For example:
e of the gates wants to
'ample, if we tried to
fther: if ( a == 'bx)

$display("a is unknown");

will never display the message, even when a is 1 bx, because the result of the ==
operation is always 1'bx. 1 bx is not the same as 1 'bl, and so the $display
never executes.

There are two special comparison operators (=== and ! ==) that overcome this limita-
tion. === and ! == cannot be implemented in hardware, but they are useful in writing
intelligent simulations. For example:

if ( a === l'bx)
e two and gates both | $display("a is unknown");
) when a is 1 bO and
er. Fighting gates can will display the message if and only if a is 1 'bx.
'mes out of the chip).
problems before we

To help understand the last examples, you should realize that the following two if
statements are equivalent:

Uninitialized regs in
e for structural code, if(expression) if((expression)===1'b1)

statement; statement; 
Dperators, such as &, I

les of commutativity,
The following table summarizes how the four-valued logic works with common opera-
tors:

gs. When all the bits
rpretation (powers of
ach as 3 'bIzO, the

hardwaree Verilog Hardware Description Language 79



a b a==b a===b a!=b a!==b a&b 3.6 $ti
0 0 1 1 0 0 A 

0 Verilog sim
0 1 0 0 1 1 0 computer. Ho,
O x x 0 x 1 0 real time, dep(
O z x 0 x 1 0 is, and how ef
1 0 0 0 1 1 0 simulation resi
1 1 1 1 0 0 1 fabricated. Th
1 x x 0 x 1 x lowing discuss
1 z x 0 x 1 x
x O x 0 x 1 0
x 1 x 0 Instead, 

x Verilo
1 x

x x x 1 x that 
0 is, 

x a simu
x z x 0 x 1 x fabricated. Alt
z O x 0 x 1 0 physical time
z 1 x 0 x 1 x $time is a ur
z x x 0 x 1 x ond, but this 
z z x 1 x 0 x

This table was generated by the following Verilog 3.6.1 Mul
Verilog allows

module xzOl;
reg a,b,val[3:0];
integer ia,ib;

initial
begin

val[O] = l'bO;
val[l] = l'bl;
val[2] = l'bx;
val[3] = l'bz;
$display

("a b a==b a===b a!=b a!==b a

for (ia = 0; ia<=3; ia=ia+l)
for (ib = 0; ib<=3; ib=ib+l)
begin

a = val[ia];
b = val[ib];

The above sin
$display respective valk

("%b %b %b %b %b %b %b a is assigned
a,b,a==b,a===b,a!=b,a!==b tial blocks,

end assignments (c
end

endmodule

80 Verilog Digital Computer Design: Algc



3.6 $time
A Verilog simulator executes 

0 as a software program on a conventional 
0 general-purpose

1 1 computer. How long it takes such a computer to run a Verilog simulation, known as
x x real time, depends on several factors, such as how fast the general-purpose computer
x x is, and how efficient the simulator is. The speed with which the designer obtains the
1 1 simulation results has little to do with how fast the eventual hardware will be when it is
1 0 fabricated. Therefore, the real time required for simulation is not important in the fol-
1 x lowing discussion.
1 x
x x Instead, Verilog provides a built-in 
1 variable, $ time, which 

x represents simulated time,
that is, a simulation 

x of the 
x actual time required for a machine to operate when it is

x x fabricated. Although the value of $ time in simulation has a direct relationship to the
x x physical time in the fabricated hardware, $time is not measured in seco ads. Rather,
1 x $ time is a unitless integer. Often designers map one of these units into one nanosec-
x x ond, but this is arbitrary.
x

3.6.1 Multiple blocks
Verilog allows more than one behavioral block in a module. For example:

module twoblocks;
integer x,y;

initial
begin

a=l;
$display("a is one');

end

initial
b allb ab"'); begin

b=2;
$display("b is two');

end
endmodule

The above simulates a system in which a and b are simultaneously assigned their
respective values. This means, from a simulation standpoint, $ time is the same when

b %b %b ", a is assigned one as when b is assigned two. (Since both assignments occur in ini-
ajb,ajj|b,a-b); tial blocks, $time is 0.) Note that this does not imply the sequence in which these

assignments (or the corresponding $display statements) occur.

hardware Verilog Hardware DescriptionL anguage 81



-

3.6.2 Sequence ve 3.7 Tim
In software, we often coni

Behavioral 
it is Ve:

possible for many st,
control 

in which back tc
statements with

the Verilog 
other sir

high-level language
There 

execute are three
is something the when to restart

The advancing of $ t im

If you change the wires 3.7.1 # tin
always blocks, where e When a staten
the design is correct, the ecute the state
lar $time is irrelevant, process that dc
gates in structural Veriloj before the curl
actions of each gate or n
each behavioral block yo

3.6.3 Scheduling 
Like a multiprocessing c
cesses, one for each stru
does not advance until th,
nity to execute at that $ t

If you are familiar with
recognize that this raises
units of computation, or
Verilog simulator?

The behavioral statemen
correct to model an exclh

in

e
the above wil

the Verilog simulator woi The order in w
computing c is not interr -at a certain po'
ture of Verilog, discussed

There can be 
how the # wor

82 Verilog Digi



3.7 Time control
id sequence. In Verilog, Behavioral Verilog may include time control statements, whose purpose is to release
vancing. The sequence control back to the Verilog scheduler so that other processes may execute and also tell
he usual rules found in the Verilog simulator at what $time the current process would like to be restarted.
within different blocks There are three forms of time control that have different ways of telling the simulator
)g will do consistently. when to restart the current process: #, @ and wait.
on 3.7.

3.7.1 # time control
is equivalent to several

When 
t output a 

by one statement 
gate. If is preceded by # followed by a number, the scheduler will not ex-

cs execute at ecute 
a particu- the statement until the specified number of $ time units have passed. Any other

process 
which you that desires 

instantiate to execute earlier than the $ time specified by the # will execute
in simulate the parallel before the current process resumes. If we modify the first example from section 3.6:
the parallel actions of

module twoblockstimecontrol;
integer x,y;

schedules several pro-
The $time variable

initial
so desires an opportu- begin

#4
a=1;

semaphores, you will $display("a is one at $time=%d",$time);
;: what are the atomic end
get interrupted by the

initial
begin
#3

. Although it is nearly
b=2;

I code: $display("b is two at $time=%d",$time);
end

endmodule

the above will assign first to b (at $time=3) and then to a one unit of $ time later.
The order in which these statements execute is unambiguous because the # places them

rute because the block
tires an additional fea- at a certain point in $ time.

There can be more than one # in a block. The following nonsense module illustrates
how the # works:

Hardware Verilog Hardware DescriptionL anguage 83



modi
i]
r
W

i:

end

The first tim(
In the above code, a becomes 10 at $time 0, 40 at $time 1, 20 at $time 2, 50 at at$timeO,
$time 4, 30 at $ tinme 7 and 60 at $ time 8. The interaction of parallel blocks creates lD compute a
a behavior much more complex than that of each individual block. ileda t $ti

is the $dis]
computing al

3.7.1.1 Using # in test code The simulate
inner loop oi

One of the most important uses of # is to generate sequences of patterns at specific control, x1 c
$ times in test code to act as inputs to a machine. The # releases control from the test that"a=O b
code and gives the code that simulates the machine an opportunity to execute. Test in a similar f
code without some kind of time control would be pointless because the machine being
tested would never execute.

3.7.1.2 A
For example, suppose we would like to test the built-in xor gate by stimulating it with Physical con
all four combinations on its inputs, and printing the observed truth table: delay. This r

the output ai
change to pr
ware design
to ignore prc
behavioral'%

84 Verilog Digital ComputerD esign: Algorithms into Hardware



module top;
integer ia,ib;
reg a,b;
wire c;

xor x(c,a,b);

initial
begin

for (ia=0; ia<=l; ia = ia+l)
begin

a = ia;
for (ib=0; ib<=l; ib = ib + 1)

begin
b = ib;
#10 $display(`a=%d b=%d c==%d,a,b, c);

end
end

end
endmodul e

The first time through, a and b are initialized to be 0 at $ time 0. When #10 executes
20 at $time 2, 50 at at $time 0, the initial block relinquishes control, and xi is given the opportunity
parallel blocks creates to compute a new value (OAO=O) on the wire c. Having completed everything sched-

ock. uled at $ time 0, the simulator advances $time. The next thing scheduled to execute
is the $display statement at $time 10. (The simulator does not waste real time
computing anything for $ t ime 2 through 9 since nothing changes during this $ t ime.)
The simulatorprints out that"a=0 b=0 c=0"at $time 10 and then goes through the

of patterns at specific inner loop once again. While $time is still 10, b becomes 1. The #10 relinquishes
,s control from the test control, xl computes that c is now 1 and $time advances. The $displayprints out
Munity to execute. Test that "a=0 b=l c=1" at $time 20. The last two lines of the truth table are printed out
use the machine being in a similar fashion at $ times 30 and 40.

3.7.1.2 Modeling combinationall ogic with #
by stimulating it with Physical combinational logic devices, such as the exclusive OR gate, have propagation

uth table: delay. This means that a change in the input does not instantaneously get reflected in
the output as shown above, but instead it takes some amount of physical time for the
change to propagate through the gate. Propagation delay is a low-level detail of hard-
ware design that ultimately determines the speed of a system. Normally, we will want
to ignore propagation delay, but for a moment, let's consider how it can be modeled in
behavioral Verilog with the #.

Hardware Verilog Hardware DescriptionL anguage 8s



.

The behavioral exclusive OR example in section 3.6.3 deadlocks the simulator because There is an eq
it does not have any time control. If we put some time control in this always block control. The fo
(say a propagation delay of #1), the simulator will have an opportunity to schedule the
test code instead of deadlocking inside the always block:

module top;
integer ia,ib;
reg a,b;
reg c;

Both model an
always #1 many (but not,

c = ab; efficient from;

initial 3.7.1.3 Ge
begin Registers and 

for (ia=O; ia<=l; ia ia+l) ate such a sigr
begin and an alway

a = ia;
for (ib=O; ib<=l; ib = ib + 1)
begin

b = ib;
#10 $display("a=%d b=%d c=%d",a,b,c);

end
end

$finish;
end

endmodule

As in the last example, a and b are initialized to be 0 at $time 0. When #10 executes
at $time 0, the initial block relinquishes control, which gives the always loop
an opportunity to execute. The first thing that the always block does is to execute #1,
which relinquishes control until $time 1. Since no other block wants to execute at The above gei
$ time 1, execution of the always block resumes at $t ime 1, and it computes a new $time.
value (OAO=O) for the reg c. Because this is an always block, it loops back to the #1.
Since no other block wants to execute at $time 2, execution of the always block 3.7.1.4 Oi
resumes at $ time 2, and it recomputes the same value for the reg c that it just com- It is permissit
puted at $time 1. The always block continues to waste real time by unnecessarily control to othz
recomputing the same value all the way up to $ time 9. processes havy

will resume. 1
Finally, the $display statement executes at $time 10. The test code prints out "a=0 whose execut
b=0 c=0" and goes through its inner loop once again. While $time is still 10, b algorithmicall
becomes 1. The #10 relinquishes control, and the always block will have another ten both assignmt
chances to compute that c is now 1. The remaining lines of the truth table are printed
out in a similar fashion.

86 Verilog Digital Computer Design: Algorithms into Hardware



the simulator because re is an equivalent structural netlist notation for an always block with # time
in this always block trol. The following behavioral and structural code do similar things in $ time:
rtunity to schedule the

reg c; wire C;
always #2 xor #2 x2(c,a,b);

c = a^b;

i model an exclusive OR gate with a propagation delay of two units of $ t ime. On
.y (but not all) implementations of Verilog simulators, the structural version is more
ient from a real-time standpoint. This is discussed in greater detail in chapter 6.

.1.3 Generating the system clock with #for simulation
isters and controllers are driven by some kind of a clock signal. One way to gener-
;uch a signal is to have an initial block give the clock signal an initial value,
an always block that toggles the clock back and forth:

reg sysclk;

initial
sysclk = 0;

always #50
sysclk = -sysclk;

0. When #10 executes
ves the always loop
does is to execute #1,
k wants to execute at above generates a system clock signal, sysclk, with a period of 100 units of
and it computes a new ime.
t loops back to the #1.
Of the always block .1.4 Orderingp rocesses without advancing $t ime
reg c that it just com- permissible to use a delay of #0. This causes the current process to relinquish
time by unnecessarily trol to other processes that need to execute at the current $ time. After the other

-esses have relinquished control, but before $ time advances, the current process
resume. This kind of time control can be used to enforce an order on processes

t code prints out "a= 0 )se execution would otherwise be unpredictable. For example, the following is
$time is still 10, b )rithmically the same as the first example in 3.7.1 (b is assigned first, then a), but

i will have another ten h assignments occur at $ time 0:
truth table are printed

Hardware Verilog Hardware DescriptionL anguage 87



3.7.2.1 EJ
module two blockstimecontrol;

integer x,y; lo,
initial Although you
begin an efficient th
#0 tional logic is
a=l; always blo
$display("a is one at $time=%d",$time); though physic

end
fashion, it is 

initial
begin this. It would

b=2; the result chai
$display("b is two at $time=%d",$time);

end How do we k
endmodule (i.e., with no 

input(s) chan
until any of th

3.7.2 @ time control
When an @ precedes a statement, the scheduler will not execute the statement that
follows until the event described by the @ occurs. There are several different kinds of
events that can be specified after the @, as shown below:

.

module
@( expression) inte
@(expression or expression or ...) reg
@(posedge onebit) reg
@(negedge onebit)
@ event alwa

C
When there is a single expression in parenthesis, the @ waits until one or more bit(s) in
the result of the expression change. As long as the result of the expression init
stays the same, the block in which the @ occurs will remain suspended. When multiple be
expressions are separated by or, the @ waits until one or more bit(s) in the result of
any of the expressions change. The word or is not the same as the operator 1.

In the above, onebi t is single-bit wire or reg (declared without the square bracket).
When posedge occurs in the parenthesis, the @ waits until onebi t changes from a
0 to a 1. When negedge occurs in the parenthesis, the @ waits until onebi t changes
from a I to a 0. The following mean the same thing:

reg a,b,c; reg a,bc;
@(c) a=b; @(posedge c or negedge c) a=b; en

endmod

An event is a special kind of Verilog variable, which will be discussed later.

88 Verilog Digital Computer Design: Algorithms into Hardware



3.7.2.1 Efficient behavioral modeling of combinational
logic with @

Although you can model combinational logic behaviorally using just the #, this is not
an efficient thing to do from a simulation real-time standpoint. (Using # for combina-
tional logic is also inappropriate for synthesis.) As illustrated in section 3.7.1.2, the
always block has to reexecute many times without computing anything new. Al-

", $time);
though physical hardware gates are continuously recomputing the same result in this
fashion, it is wasteful to have a general-purpose computer spend real time simulating
this. It would be better to compute the correct result once and wait until the next time
the result changes.

",$ time);
How do we know when the output changes? Recall that perfect combinational logic
(i.e., with no propagation delay) by definition changes its output whenever any of its
input(s) change. So, we need the Verilog notation that allows us to suspend execution
until any of the inputs of the logic change:

Mutuee the statement that
veral different kinds of

module top;
integer ia,ib;

or ... )
reg a,b;
reg c;

always (a or b)
c = ab;

til one or more bit(s) in
of the expression initial

pended. When multiple begin
*eb it(s) in the result of for (ia=O; ia<=l; ia = ia+l)
ne as the operator 1. begin

a = ia;

out the square bracket). for (ib=O; ib<=l; ib = ib + 1)

nebi changes from a begin
b = ib;

until onebi t changes
#10 $display("a=%d b=%d c=%d",a,b,c);

end
end

$finish;
c) a=b; end

endmodule

discussed later.

) Hardware Verilog Hardware Description Language 89



At the beginning, both the initial and the always block start execution. Since
neither a nor b have changed yet, the always block suspends. The first time through always @

begin
the loops in the initial block, a and bare initialized to be at $time 0. When #10 if (e
executes at $timeO, the initial block relinquishes control, andthe always block dol
is given an opportunity to do something. Since a and b both changed at $ time 0, the else
@ does not suspend, but instead allows the always block to compute a new value if
(OAO=O) for the reg c. The always block loops back to the @. Since there is no way
that a or b can change anymore at $ time 0, the simulator advances $ time. The next eL
thing scheduled to execute is the $display statement at $time 10. (Like the ex-
ample in section 3.7.1.1, but unlike the example in section 3.7.1.2, the simulator does
not waste real time computing anything for $ time I through 9 since nothing changes
during that $ time.) The simulator prints out that "a=O b= 0 c= 0" at $ time 1,and end
then goes through the inner loop once again. While $time is still 10, b becomes 1.
The #10 relinquishes control, and the always block has an opportunity to do some-
thing. Since b just changed (though a did not change), the @ does not suspend, and c Note that the
is now 1. After $time advances, the $display prints out that "a=0 b= 1 c=l" at controller sen,
$ time 20. The last two lines of the truth table are printed out in a similar fashion at will ignore the
$times 30 and 40. one action (ch

of if stateme
Since this is a model of combinational logic, it is very important that every input to hardware.
the logic be listed after the @. We refer to this list of inputs to the physical gate as the
sensitivity list. 3.7.2.3 M

Most controlled
use posedgk

3.7.2.2 Modeling synchronous registers sysclk hav
Most synchronous registers that we deal with use rising edge clocks. Using @ with chart in sectic
posedge is the easiest way to model such devices. For example, consider an enabled
register whose input (of any bus width) is din and whose output (of similar width as
din) is dout. At the rising edge of the clock, when ld is 1, the value presented on alwi
din will be loaded. Otherwise dout remains the same. Assuming din, dout, d b

and sysclk are taken care of properly elsewhere in the module, the behavioral code
to model such an enabled register is:

e
Similar Verilog code can be written for a counter register that has cr, ld, and cnt
signals:

There are sevi
to promote rc

90 Verilog Digital Computer Design: Algorithms into Hardware



k start execution. Since
s. The first time through always (posedge sysclk)

at $time 0. When #10 begin
if (cir)

, and the always block
dout = 0;

hanged at $time 0, the else
o compute a new value if (d)
i. Since there is no way dout = din;
ances $ time. The next else
time 10. (Like the ex- begin
'.1.2, the simulator does if (cnt)
9 since nothing changes dout = dout + 1;

c=O" at $time 10, and end
end

s still 10, b becomes 1.
)pportunity to do some-
Joes not suspend, and c Note that the nesting of if statements indicates the priority of the commands. If a
kat"a=O b=l c=l"at controller sends this counter a command to clr and cnt at the same time, the counter
Iti n a similar fashion at will ignore the cnt command. At any $ time when this always block executes, only

one action (clearing, loading, counting or holding) occurs. Of course, improper nesting
of i f statements could yield code whose behavior would be impossible with physical

Ant that every input to hardware.
the physical gate as the

3.7.2.3 Modeling synchronous logic controllers
Most controllers are triggered by the rising edge of the system clock. It is convenient to
use posedge to model such devices. For example, assuming that stop, speed and
sysclk have been dealt with properly elsewhere in the module, the second 

clocks. ASM
Using @ with chart in section 2.1.1.2 could be modeled as:

ple, consider an enabled
put (of similar width as
the value presented on always

iing din, dout, ld begin

ule, the behavioral code @(posedge sysclk) //this models state GREEN
stop = 0;
speed = 3;

@(posedge sysclk) //this models state YELLOW
stop = 1;
speed = 1;

@(posedge sysclk) //this models state RED
stop = 1;
speed = 0;

end
has cr, ld, and cnt

There are several things to note about the above code. First, the indentation is used only
to promote readability. Assuming the code for generating sysclk given in section

o Hardware Verilog Hardware Description Language 91



3.7.1.3, the stop = 0 and speed = 3 statements execute at always 
... because there is no time control among them. The indentation #20 $di.
fact that these two statements execute atomically, as a unit, witi stop'sPE

by the simulator.

The second thing to note is that the = in Verilog is just a softwE 3.7.3 wa
ment. (The variable is modified at the $time the statement e The wait st
will retain the new value until modified again.) This is different wait statem
ASM chart notation. (The command signal is a function of the p way that @ 
mand signal does not retain the new value after the rising edge o wait statem
instead returns to its default value.) Another way of saying th ware devices
default values in standard Verilog variables as there are for A
Despite the distinction between Verilog and ASM chart notati
ASM chart in Verilog by fully specifying every command outi
those states where a command is not mentioned in an ASM cha The wait st
Verilog assignment statement that stores the default value int( when the con
corresponding to the missing ASM chart command. The stop=( will resume v
ments above were not shown in the original ASM chart but are rc
code to model what the hardware would actually do. For example,

described in c
The third thing is the names of the states are not yet included in , result is. Furtl
comments are of course ignored by Verilog.) Eventually, we wil of $time. Tl
ing meaningful state names in the actual code. machine:

The fourth thing is that this ASM chart does not have any RTN
stage). We will need an additional module 

Verilog top
notation to model ASR

reg pb;
This notation is discussed in section 3.8. integer

wire [11
wire sys

3.7.2.4 @for debugging display ...

@ can also be used for causing the Verilog simulator to print initial

shows what happens as actions unfold in the simulation. For exs begin
pb=
x =

always (a or b or c)
=

$display("a=%b b=%b c=%b at $time=%d",a,b, #250
@(po

The above block would eliminate the need for the designer t( whil1
$display statements in the test code or in the code for the ma be(

With clocked systems, it is often convenient to display informa
rising edge of the clock:

92 Verilog Digital Computer Design: Algorithms into



:$time 50, 350, 650, always (posedge sysclk)
simply highlights the #20 $display("stop=%b speed=%b at $time=%d",

,out being interrupted stop,speed,$time);

ire assignment state- 3.7.3 wait
ixecutes. The variable The wait statement is a form of time control that is quite different than # or @. The
than how we use = in wait statement stands by itself. It does not modify the statement which follows in the

resent state. The com- way that @ and # do (i.e., there must be a semicolon after the wait statement). The
if the system clock but wait statement is used primarily in test code. It is not normally used to model hard-
is is that there are no ware devices in the way @ and # are used. The syntax for the wait statement is:
.SM chart commands.
on, we can model an wait(condition);
?ut in every state. For
rt, one simply codes a The wait statement suspends the current process. The current process will resume

the Verilog variable when the condition becomes true. If the condition is already true, the current process
Oa nd speed=0 state- will resume without $ time advancing.
-quired for the Verilog

For example, suppose we want to exhaustively test one of the slow division machines
described in chapter 2. The amount of time the machine takes depends on how big the

the Verilog code. (The result is. Furthermore, different ASM charts described in chapter 2 take different amounts
I find a way of includ- of $ time. Therefore, the best approach is to use the ready signal produced by the

machine:

(i.e., it is at the mixed
module top;

Mc harts that use RTN. reg pb;
integer x,y;
wire [11:0] quotient;
wire sysclk;

debugging output that initial

ample, begin
pb= 0;
x = 0;
y = 0;

c, $time) ;l #250;
@(posedge sysclk);

o worry about putting while (x<=4095)
achine being tested. begin

for (y=l; y<=4095; y = y+1)
ition shortly after each begin

@(posedge sysclk);
pb = 1;

>H ardware Verilog HardwareD escription Language 93



Continued 3.8.1 Blo,
@(posedge sysclk); The syntax fo
pb = 0; is described ii
@(posedge sysclk); ample, three 
wait(ready);
@(posedge sysclk);
if (x/y === quotient)

$display("ok");
else
$display("error x=%d y=%d x/y=%d quotient=%d",

x,y,x/y,quotient);
end

x = x + 1; Other variatic
end assignment is

$stop; ecutes, but th
end assuming te:

endmodule declared to be
the same thin,

This test code (based on the nested loops given in section 3.4) embodies the assump-
tions we made in section 2.2. 1. The first two @ s in the loop produce the pb pulse that
lasts exactly one clock cycle. The third @ makes sure that the machine has enough time initial
to respond (and make ready 0). The wait (ready) keeps the test code synchro- begin
nized to the division machine, so that the test code is not feeding numbers to the divi-
sion machine too rapidly. The fourth @ makes sure the machine will spend the required a =

time in state IDLE, before testing the next number.
end 

The ellipsis shows where the code for the actual division machine was omitted in the
above. The quotient is produced by this machine which is not shown here. The Blocking pro(
design of this code will be discussed in the next chapter. RTN. The onc

from continui
blocking proc

3.8 Assignment with time control
The # and @ time control, discussed in sections 3.7.1 and 3.7.2, precede a statement. 3.8.2 Nor
These forms of time control delay execution of the following statement until the speci- The syntax fo
fied $time. There are two special kinds of assignment statements5 that have time dural assignrr
control inside the assignment statement. These two forms are known as blocking and This should t
non-blocking procedural assignment. charts. For ex

later chapters

5A ssignment with time control is not accepted by some commercial synthesis tools but is accepted by all
Verilog simulators. Since there are problems with intra-assignment delay (section 3.8.2.1), some authors
recommend against its use, but when used as recommended later in this chapter (section 3.8.2.2), it becomes
a powerful tool. Chapter 7 explains a preprocessor that allows all synthesis tools to accept the use proposed
in this book.

94 Verilog Digital Computer Design: Algorithms into Hardware



3.8.1 Blocking procedural assignment
The syntax for blocking procedural assignment has the # or @ notation (whose syntax
is described in sections 3.7.1 and 3.7.2) after the = but before the expression. For ex-
ample, three common forms of this are:

var = # delay expression;
var = (posedge onebit) expression;

auotient=%d", var = (negedge onebit) expression;

Other variations are also legal. What distinguishes this from a normal instantaneous
assignment is that the expression is evaluated at the $time the statement first ex-
ecutes, but the variable does not change until after the specified delay. For example,
assuming temp is a reg that is not used elsewhere in the code and that temp is
declared to be the same width as a and b, the following two fragments of code mean
the same thing:

i) embodies the assump-
roduce the pb pulse that initial
nachine has enough time initial begin
is the test code synchro- begin ...
ling numbers to the divi- ... temp = b;
te will spend the required a = @(posedge sysclk) b; @(posedge sysclk) a = temp;

end end

chine was omitted in the
is not shown here. The Blocking procedural assignment is almost what we need to model an ASM chart with

RTN. The one problem with it, as its name implies, is that it blocks the current process
from continuing to execute additional statements at the same $ time. We will not use
blocking procedural assignment for this reason.

7.2, precede a statement. 3.8.2 Non-blocking procedural assignment
statement until the speci- The syntax for a non-blocking procedural assignment is identical to a blocking proce-
ttements5 that have time dural assignment, except the assignment statement is indicated with <= instead of =.
*ek nown as blocking and This should be easy to remember, because it reminds us of the - notation in ASM

charts. For example, the most common form of the non-blocking assignment used in
later chapters is:

Isis tools but is accepted by all
Section 3.8.2.1), some authors
ter (section 3.8.2.2), it becomes var <= (posedge onebit) expression;
ools to accept the use proposed

ito Hardware Verilog Hardware DescriptionL anguage 95



Typically, onebi t is the sysclk signal mentioned it section 3.7.1.3. Although other 'ays
forms are legal, the above (posedge onebi t) form of the non-blocking assign- begin
ment is the one we use in almost every case for - in ASM charts.6 @( pose

stop
The expression is evaluated at the $ t ime the statement first executes and further state- spee
ments execute at that same $time, but the variable does not change until after the
specified delay. For example, assuming temp is a reg that is not used @ 

elsewhere (pose
in the

left-hand code and stop
that temp is declared to be the same width as a and b, the following spee

two fragments of code mean nearly the same thing: coun

alvays (posedge sysclk) @ (pose
#0 a = temp; stop

spee
initial initial c oun
begin begin nd

a <= (posedge sysclk) b; temp = b; 'er, when
produced

end end

stop=(
Note that, all by itself, the effect of the non-blocking assignment is like having a paral- stop=J
lel always block to store into a. An advantage of the <= notation is that you do not stop=J
have to code a separate always block for each register. stop=(

stop=J

A subtle detail is that the right-hand always block is the last thing to execute (#O) at stop=]

a given $time. Similarly, the <= causes the reg to change only after every other
block (including the one with the <= ) has from 

finished sect
execution. This subtle detail causes

a problem, which is discussed in the next section, and derlying 
which is c

solved in section 3.8.2.2.
g to chan

3.8.2.1 Problem I executic
with <=forR TNfor simulation

An obvious approach to translating RTN from an ASM chart into behavioral Verilog is we Verik
just to put <= for each <- in the ASM chart. For example, assuming stop, speed, t of thes(
count and sysclk are taken care of properly elsewhere, one might think that the of the res
ASM chart from section 2.1.1.3 could be translated into Verilog as: ed at the e

ED cause:
=ccurs at 
the last tI
sume and
k) cou]
d at $tii

6 The exceptions are when the left-hand side of the *- is a memory being changed every clock cycle, in ment of 3'
which case (negedge onebi t) is appropriate, as explained in section 6.5.2, and for post-synthesis (as a resi
behavorial modeling of logic equations, in which case # is appropriate, as explained in section 11.3.3.

96 Verilog Digital Computer Design: Algorithms into Hardware



i 3.7.1.3. Although other alwa ~is
he non-blocking assign- bE jgin
tarts.6 @(posedge sysclk) //this models state GREEN

stop = 0;

.ecutes and further state- speed = 3;

it change until after the
@(posedge 

lot used sysclk) 
elsewhere in the //this models state YELLOW

stop = 1;
S a and b, the following speed = 1;

count <= @(posedge sysclk) count + 1;

dge sysclk) @(posedge sysclk) //this models state RED
stop = 1;
speed = 0;
count <= 

p; @(posedge sysclk) count + 2;
er Id

b; r, when one runs this code on a Verilog simulator, the following incorrect re-
roduced (assuming the debugging always block shown in section 3.7.2.4):

stop=0 speed=ll count=000 at $time= 70
nt is like having a paral- stop=l speed=01 count=000 at $time= 170
ation is that you do not stop=l speed=00 count=001 at $time= 270

stop=0 speed=ll count=010 at $time= 370
stop=l speed=01 count=010 at $time= 470

thing to execute (#0) at stop=l speed=00 count=011 at $time= 570

only after every other
rom section 2.1.1.3 that at $time 370, count 

Phis should 
subtle detail be three 

causes instead of two.
Irlying cause of this error is the subtle detail 

olved in mentioned 
section 3.8.2.2. above: The <= causes

to change only after every other block (including the one with the <=) has
execution.

ito behavioral Verilog is ve Verilog starts to execute the statements for state YELLOW at $ time 150.
suming stop, speed, of these statements evaluates count+l at $time 150 and schedules the
ne might think that the of the result. Since count is still 3'bOOO at $time 150, the result scheduled to
g as: I at the end of $time 250 is3 'bOO1. The @ (posedge sysclk) that starts

D causes the always block to suspend until $ time 250. The problem shown
ccurs at $time 250 because the assignment initiated by the <= at $time 150
he last thing that occurs at $ time 250. Prior to the assignment, the process
ime and execute the three statements, including count <= @ (posedge
k) count + 2. Since countis still 3'bOOO, this <= schedules 3'bOlO to be
at $ time 350, which is not what happens in an ASM chart. As soon as the

:hanged every clock cycle, in ent of 3'bO0l has been scheduled at $time 250, 3'bOO1 will be stored into
6.5.2, and for post-synthesis 'as a result of the first <=).

dlained in section 11.3.3.

o Hardware Verilog Hardware Description Language 97



3.8.2.2 Proper use of <=forR TN in simulation toggles syscl
To overcome the problem described in the last section, you need to use a non-zero $time 0, it w
delay after each @( posedge sysclk) that denotes a rectangle of the ASM chart.
For example, here is the complete Verilog code to model (in a primitive way) the ASM The only new 
chart from section 2.1.1.3: #1 after each 

stop,speec
module top;

reg stop; The test code i
reg [1:0] speed; real machine, 
reg sysclk; test code for t
reg [2:0] count;

system task to
initial would otherwi

sysclk = 0;
always #50 With the #1 afi

sysclk = -sysclk;

always
begin
@(posedge sysclk) #1 //this models state GREEN

stop = 0;
speed = 3;

@(posedge sysclk) #1 //this models state YELLOW
stop = 1;
speed = 1; 3.8.2.3 Tr
count <= (posedge sysclk) count + 1; This book con

ASM with be]
@(posedge sysclk) #1 //this models state RED

stop = 1; kinds of ASMq
speed = 0; ASMs can be
count <= (posedge sysclk) count + 2; that adhere to

end

3.8.2.3.1 1
always (posedge sysclk) The approach

#20 $display("'stop=%b speed=%b count=%b at $time=%d",
while) isk n

stop,speed,count,$time);
implicitly thra

initial always bloc]
begin section 2.4.1) 

count = 0; possible circui
#600 $finish;

end Experienced h
endmodule approach conf

way. The imp]
Let's analyze the reason why each block is required in this module. The first initial

between i f ar
block is required to give sysclk a value other than l'bx at $time 0. The next block find this apprn

98 Verilog Digital Computer Design: Algorithms into Hardware



toggles sysclk so that the clock period is 100. If sysclk were not initialized at
need to use a non-zero $t ime 0, it would stay 1 bx forever (-1 bx is 1 bx).

tangle of the ASM chart.
Xpr imitive way) the ASM The only new thing in the always block that models the ASM chart is the addition of

#1 after each @( posedge sysclk). The always block that follows it displays
stop, speed and count during each state.

The test code in the final initial block simply initializes count to be 3'b00. (In a
real machine, this would occur in a state of the ASM, but instead here it is part of the
test code for the purposes of illustration only.) The test code schedules a $ f inish
system task to be called at $ time 600. This is required because the always blocks
would otherwise tell the simulator to go on forever.

With the #1 after each @, the Verilog simulator produces the following correct output:
stop=0 speed=ll count=000 at $time= 70
stop=i speed=01 count=000 at $time= 170
stop=l speed=00 count=001 at $time= 270
stop=0 

ls state speed=11 
GREEN count=011 at $time= 370

stop=l speed=01 count=011 at $time= 470
stop=l speed=00 count=100 at $time= 570

te YELLOW

3.8.2.3 Translating goto-less ASMs to behavioral Verilog
This book concentrates on several design techniques that all begin by expressing an
ASM with behavioral Verilog. Since Verilog 

ls state is 
RED a goto-less language, only certain

kinds of ASMs can be translated in this fashion. Chapters 5 and 7 explain how arbitrary
ASMs can be translated into Verilog, but this section will concentrate only on ASMs
that adhere to this highly desirable goto -less style.

3.8.2.3.1 Implicit versus explicit style
The approach of expressing a state machine with high-level statements (like if and

at $time=%d",
while) is known as implicit style because the next state of the machine is described
implicitly through the use of @( posedge sysclk) within the statements of an
always block. Implicit style is the opposite of the explicit style table (illustrated in
section 2.4.1) that requires the designer to say what state the machine goes to under all
possible circumstances.

Experienced hardware designers who are new to Verilog may find the implicit style
approach confusing because it requires thinking about a state machine in a different
way. The implicit style is much more like software concepts, such as the distinction

$$d tuimle.eT  h0e.  fTirhset  innexitt ibalol
between i f and whi 1 e. On 

ck the other hand, experienced software designers may also
find this approach difficult at first because the timing relationship between <= and

nto Hardware Verilog HardwareD escription Language 99



decisions in Verilog is different than in conventional software languages. The follow-
ing sections go through a series of examples Continued

that illustrate some typical kinds of ASM
constructs and how they translate into implicit style Verilog. always~

begin

3 .8.2 .3 .2 Identifying the infinite oop t (Po.,

Unlike software, a <:
all ASMs have at least one infinite oop. Implicit style behavioral @ (po.~

Verilog is defined by an always block. Many times this always block can also serve b <-
to implement the infinite loop of the ASM. In the following ASM, the transitions from (o.,
states FIRST, SECOND, THIRD and FOURTH are implicit. The designer does not a <:
have to say anything about their next states. The transition from FIFTH to FIRST oc- @ (poe~
curs because of the always: b <=

@ (po-
a <=

FIRST [ end
a-1

/ /Followi
4,

bLUUXNDI II hardwe
b-a // happer

11HIRD always #E
a- b always @(~

displaya

FOURTH [
b- 4 initial

begin

FIFTH [ syscl
a-55  #140C

end
endmodule

Figure 3.2 Every ASM has an infinite oop. The above is 
emphasis of th

Inside the always, there is a one to one mapping of rectangles into (pos edge there are three
syscik) statements. In this example, the ASM has five states, so the always uses other two a~
five (posedge syscik): later chapters

module top; 3.8.2.3.3 1
//Following are actual hardware registers of ASM

reg [11:0] a,b; Most ASMs ha
if statement 
ware designers

//Following is NOT a hardware register the while is 
reg sysclk;

The following
I/The following always block models actual hardware

100 1~0V0er ilog Digital Computer Design: Algorithms into Hardware



languages. The follow- Continued
me typical kinds of ASM

always
begin

@(posedge sysclk) #1; // state FIRST
a <= (posedge sysclk) 1;

Implicit style behavioral @(posedge sysclk) #1; // state SECOND
ays block can also serve b <= (posedge sysclk) a;
,SM, the transitions from @(posedge sysclk) #1; // state THIRD
t. The designer does not a <= @(posedge sysclk) b;

om FIFTH to FIRST oc- @(posedge sysclk) #1; // state FOURTH
b <= @(posedge sysclk) 4;
@(posedge sysclk) #1; // state FIFTH
a <= @(posedge sysclk) 5;

end

//Following initial and always blocks do not correspond to
// hardware. Instead they are test code that shows what
// happens when the above ASM executes

always #50 sysclk = sysclk;
always (posedge sysclk) #20

$display("%d a=%d b=%d ', $time, a, b);

initial
begin

sysclk = 0;
#1400 $stop;

end
endmodule

The above is slightly more primitive than what will be used in later chapters, but the
emphasis of this example is to show how an ASM translates into Verilog. In the above,

angles into (posedge there are three always blocks, but only the first one corresponds to hardware. The
Ltes, so the always uses other two always blocks and the initial block are necessary for simulation (in

later chapters these other blocks will be moved to other modules).

3.8.2.3.3 Recognizing if else
of ASM Most ASMs have decisions. Decisions in implicit Verilog are described either with the

if statement (possibly followed by else) or with the while statement. For hard-
ware designers without extensive software experience, determining whether the i f or
the while is appropriate for a particular decision can seem confusing at first.

The following ASM is an example where the i f else construct is appropriate:
hardware

nto Hardware Verilog HardwareD escription Language 101



-

FI I always
begin

@ (POSE
SECOND a <=

@ (pose
b <=
if (a

bec
G

FOURTH IRD

I a b enc
I

else
bec

FIFTH E

enc
@ (posE

Figure 3-3. ASM corresponding to if else. a <=
end

For brevity, only the always block that corresponds to the actual hardware is shown:
3.8.2.3.4 R.

always
begin Often, it is appr

@(posedge sysclk) #1; // state FIRST
a <= @(posedge sysclk) 1;
@(posedge sysclk) #1; // state SECOND
b <= @(posedge sysclk) a;
if (a == 1) S

begin
@(posedge sysclk) #1; // state THIRD

a <= (posedge sysclk) b;
end

else
begin

@(posedge sysclk) #1; // state FOURTH
b <= (posedge sysclk) 4;

end
@(posedge sysclk) #1; // state FIFTH
a <= @(posedge sysclk) 5;

end

The i f el s e is appropriate here because only one of the states (THIRD or FOURTH)
will execute. Because a is one in state SECOND, state THIRD will execute. In the
following very similar Verilog, state FOURTH rather than state THIRD will execute: Figure 3-4. 

102 Verilog Digital ComputerD esign: Algorithms into Hardware



always
begin

@(posedge sysclk) #1; // state FIRST
a <= (posedge sysclk) 1;
@(posedge sysclk) #1; // state SECOND
b <= (posedge sysclk) a;
if (a = 1)
begin

@(posedge sysclk) #1; // state THIRD
a <= (posedge sysclk)

end
else
begin

@(posedge sysclk) #1; // state FOURTH
b <= (posedge sysclk) 4;

end
@(posedge sysclk) #1; // state FIFTH
a <= (posedge sysclk) 5;

end

ctual hardware is shown:
3.8.2.3.4 Recognizing a single alternative
Often, it is appropriate to omit the else, as in the following ASM:

ate FIRST

ate SECOND

SECOND

ate THIRD

ate FOURTH

ate FIFTH

es (THIRD or FOURTH)
IRD will execute. In the
ate THIRD will execute: Figure 3-4. ASM without else.

Pito Hardware Verilog Hardware DescriptionL anguage 103



-

which translates to the determines 
two ASMs i!

-

always able because
begin the first of t]

@(posedge s // state FIRST
a <= @(pos
@(posedge s // state SECOND
b <= @(pos
if (a == 1
begin

@(POSE // state THIRD
a <=

@(pose // state FOURTH
b <=

end
@(posedge s // state FIFTH
a <= @(pos

end

In the above, both stat
state SECOND. The fo
to state FIFTH:

always
begin Figure 3-

@(posedge s // state FIRST
a <= @(pos
@(posedge s // state SECOND
b <= @(pos
if (a = I

begin
@(pose // state THIRD

a <=
@(pose // state FOURTH

b <= 4;
end

@(posedge s // state FIFTH
a <= @(pos

end

3.8.2.3.5 Recogn
The following two AS.
ASMs is very similar 1
not necessarily go to s

Figure3 -e
104 Verilog D



determines whether to go to state THIRD or state FIFTH. The second of the following
two ASMs is a much less desirable way to describe the identical hardware. It is undesir-
able because the a== 1 test is duplicated; however, its meaning is exactly the same as
the first of the following two ASMs:

te FIRST

te SECOND

te THIRD

te FOURTH

te FIFTH

ite because a is one in
ly from state SECOND

Figure 3-5. ASM with whi le.
:e FIRST

:e SECOND

:e THIRD

:e FOURTH

:e FIFTH

;t of the following two
it state FOURTH does
es to a decision which

Figure 3-6. Equivalent tofigure 3-5.
Hardware

Verilog Hardware DescriptionL anguage 105



The reason the first of the ASMs is preferred is because it is more obvious that it
translates into a while loop in Verilog:

always
begin

@(posedge sysclk) #1; // state FIRST
a <= @(posedge sysclk) 1;
@(posedge sysclk) #1; // state SECOND
b <= @(posedge sysclk) a;
while (a == 1)

begin
@(posedge sysclk) #1; // state THIRD

a <= @(posedge sysclk) b;
@(posedge sysclk) #1; // state FOURTH

b <= (posedge sysclk) 4;
end

@(posedge sysclk) #1; // state FIFTH
a <= (posedge sysclk) 5;

end

In fact, the only syntactic difference between the above Verilog and the Verilog in Figure 3-i
section 3.8.2.3.4 is that the word if has been changed to while. The advantage of
looking at this particular ASM as awhile loop is that the decision a==l is shared by It is almost i
both state SECOND and state FOURTH. With the while loop, the designer does not infinite loop
have to worry that the decision is actually part of two states. Many practical algorithms Verilog imph
that produce useful results (as illustrated in chapter 2) demand a loop of this style. The
while in Verilog makes this easy. always

begin
3.8.2.3.6 Recognizing forever ( (C

Sometimes machines need initialization states that execute a <
only once. Since synthesis

tools only accept for
behavioral Verilog defined with always blocks, such ASMs still b

begin with the keyword always. However, the looping action of the always is not
pertinent. (If the designer only wanted to simulate the machine, ini tial would work
just as well as always, but ultimately the synthesis tool will demand always.)

In order to describe the infinite loop that exists beyond the initialization states, the
designer must use f orever. For example, consider the following ASM:

S
end

106 Verilog Digital Computer Design: Algorithms into Hardware



is more obvious that it FI RST

SECOND
Lte FIRST

Lte SECOND

Lte THIRD

Lte FOURTH

tte FIFTH FIFTH

ilog and the Verilog in Figure 3-7. ASM needing forever.
tile. The advantage of
ision a== is shared by It is almost identical to the one in section 3.8.2.3.4, except that state FIFTH forms an
ip,t he designer does not infinite loop to state SECOND instead of going to state FIRST. The corresponding
any practical algorithms Verilog implements this using forever:
a loop of this style. The

always
begin

@(posedge sysclk) #1; / state FIRST

ly once. a 
Since <= @(posedge 

synthesis sysclk) 1;
forever

blocks, such ASMs still begin
n of the always is not @(posedge sysclk) #1; i state SECOND

, initial would work b <= @(posedge sysclk a;
demand always.) if (a == 1)

begin
initialization states, the @(posedge sysclk) #1; // state THIRD

wing ASM: a <= (posedge sysclk) b;
@ (posedge sysclk) #1; // state FOURTH

b <= @(posedge sysclk) 4;
end

@(posedge sysclk) #1; // state FIFTH
a <= (posedge sysclk 5;

end
end

to Har dwar e Verilog HardwareD escription Language 107



3.8.2.3.7 Translating into an if at the bottom of forever always 
The following two ASMs are equivalent. Many designers would think the one on the begin
left is more natural because it describes a loop involving only state THIRD. As long as @( pos
a==1, the machine stays in state THIRD. The noteworthy thing about this machine is a 
that state THIRD also forms the beginning of a separate infinite loop. (Such an infinite @ (pos

loop might be described with an always or in this case a forever.) Because b 
of this,

it is preferred to think of this ASM as an i f at the bottom of a forever, as illustrated OI

by the ASM on the right:

FIRST a 1

FOURTH
e

end

In software, ar
i f, but the coi
of nesting a n(
that forms the
behavioral Ver
gested that the
chapters. Desi

3.9 Tast
In convention;
use functions

Figure3 -8. apart 
Two into 

ways man
to draw i f at the bottom of forever. procedures: t

sometimes all(
dures) and fun

The ASM on the right tests if a != 1 to see whether to leave the loop involving only
state THIRD and proceed to state FIFTH. The reason the ASM on the right is preferred 3.9.1 TasI
is that its translation into Verilog is obvious: The syntax foi

108 Verilog Digital Computer Design: Algorithms into Hardware



forever -

always
uld think the one on the begin
state THIRD. As long as @(posedge sysclk) #1; // state FIRST

ng about this machine is a <= (posedge sysclk) 1;

e loop. (Such an infinite @(posedge sysclk) #1; // state FOURTII
b 

ever.) <= (posedge 
Because of sysclk) 

this, 4;
forever

forever, as illustrated begin
@(posedge sysclk) #1; // state THIRD

a <= (posedge sysclk) b;
if (a != 1)
begin

@(posedge sysclk) #1; // state FIFTH
a <= (posedge sysclk) 5;

end
end

end

In software, an i f never implements a loop. This is also true in Verilog of an isolated
if, but the combination of an i f at the bottom of forever or always has the effect
of nesting a non-infinite loop inside an infinite loop. It is the forever or always
that forms the looping action, not the if. This example illustrates a kind of implicit
behavioral Verilog that sometimes causes novice Verilog designers confusion. It is sug-
gested that the reader should fully appreciate this example before proceeding to later
chapters. Designers need to be careful not to confuse i f with while.

3.9 Tasks and functions
In conventional software programming languages, it is common for a programmer to
use functions and procedures (known as void functions in C) to break an algorithm
apart into manageable pieces. There are two main motivations for using functions and

er. procedures: they make the top-down design of a complex algorithm easier, and they
sometimes allow reuse of the same code. Verilog provides tasks (which are like proce-
dures) and functions, which can be called from behavioral code.

the loop involving only
on the right is preferred 3.9.1 Tasks

The syntax for a task definition is:

o Hardware Verilog HardwareD escription Language 109



forever -

always
uld think the one on the begin

state THIRD. As long as @(posedge sysclk) #1; // state FIRST

ng about this machine is a <= (posedge sysclk) 1;

e loop. (Such an infinite @(posedge sysclk) #1; // state FOURTH
b 

ever.) <= (posedge 
Because of this, sysclk) 4;

forever
forever, as illustrated

begin
@(posedge sysclk) #1; // state THIRD

a <= (posedge sysclk) b;
if (a != 1)
begin

@(posedge sysclk) #1; // state FIFTH
a <= (posedge sysclk) 5;

end
end

end

In software, an i f never implements a loop. This is also true in Verilog of an isolated

] i f, but the combination of an i f at the bottom of f orever or always has the effect
of nesting a non-infinite loop inside an infinite loop. It is the f orever or always
that forms the looping action, not the if. This example illustrates a kind of implicit
behavioral Verilog that sometimes causes novice Verilog designers confusion. It is sug-
gested that the reader should fully appreciate this example before proceeding to later
chapters. Designers need to be careful not to confuse i f with while.

3.9 Tasks and functions
In conventional software programming languages, it is common for a programmer to
use functions and procedures (known as void functions in C) to break an algorithm
apart into manageable pieces. There are two main motivations for using functions and
procedures: they make the top-down design of a complex algorithm easier, and they
sometimes allow reuse of the same code. Verilog provides tasks (which are like proce-
dures) and functions, which can be called from behavioral code.

the loop involving only
on the right is preferred 3.9.1 Tasks

The syntax for a task definition is:

o Hardware Verilog Hardware DescriptionL anguage 109



forever always
uld think the one on the begin
state THIRD. As long as @(posedge sysclk) #1; // state FIRST
rg about this machine is a <= (posedge sysclk) 1;

e loop. (Such an infinite @(posedge sysclk) #1; // state FOURTI I
b <= (posedge sysclk) 

ever.) 4;
Because of this,

forever
forever, as illustrated begin

@(posedge sysclk) #1; // state THIRD
a <= (posedge sysclk) b;
if (a != 1)

begin
@(posedge sysclk) #1; // state FIFTH

a <= (posedge sysclk) 5;
end

end
end

In software, an i f never implements a loop. This is also true in Verilog of an isolated
if, but the combination of an i f at the bottom of forever or always has the effect
of nesting a non-infinite loop inside an infinite loop. It is the forever or always
that forms the looping action, not the if. This example illustrates a kind of implicit
behavioral Verilog that sometimes causes novice Verilog designers confusion. It is sug-

I gested that the reader should fully appreciate this example before proceeding to later
chapters. Designers need to be careful not to confuse if with while.

3.9 Tasks and functions
In conventional software programming languages, it is common for a programmer to
use functions and procedures (known as void functions in C) to break an algorithm
apart into manageable pieces. There are two main motivations for using functions and
procedures: they make the top-down design of a complex algorithm easier, and they
sometimes allow reuse of the same code. Verilog provides tasks (which are like proce-
dures) and functions, which can be called from behavioral code.

the loop involving only
on the right is preferred 3.9.1 Tasks

The syntax for a task definition is:

LoH ardware Verilog HardwareD escription Language 109



task name;
input arguments;
output arguments;
inout arguments;

declarations;
begin

statement;

end
endtask

This task definition must occur inside a module. The task is usually intended to be
called only by initial blocks, always blocks and other tasks within that module.
Tasks may have any behavioral statements, including time control.

Verilog lets the designer choose the order in which the input, output and inout
definitions are given. (The order shown above is just one possibility.) The order in
which input, output and inout definitions occur is based on the calling sequence
desired by the designer. The sequence in which the formal arguments are listed in some
combination of input, output and/or inout definitions determines how the actual
arguments are bound to the formal definitions when the task is called.

The purpose of an input argument is to send information from the calling code into
the task by value. An input argument may include a width (which is equivalent to a
wire of that width) or it may be given a type of integer or real in a separate
declaration. An input argument may not be declared as a reg.

After initial
The purpose of an output argument is to send a result from the task to the groups 

calling (eaci
code by reference. An output argument must be declared as a reg, integer to 

or be shorter
real in a separate declaration.

An inout definition combines the roles of input and output. An inout argu-
ment must be declared as a reg, integer or real in a separate declaration.

3.9.1.1 Example task
Consider the following nonsense code:

110 Verilog Digital Computer Design: Algorithms into Hardware



integer count,sum,prod;
initial
begin

sum = 0;
count = 1;

sum = sum + count;
prod = sum * count;
count = count + 2;
$display(sum,prod);

sum = sum + count;
prod = sum * count;

is usually intended to be count = count + 3;
tasks within that module. $display(sum,prod);
)ntrol.

sum = sum + count;

it, output and inout prod = sum * count;

possibility.) The order in count = count + 5;

Ed on $display(sum,prod);
the calling sequence

,uments are listed in some sum sum + count;
letermines how the actual prod = sum * count;
is called. count = count + 7;

$display(sum,prod);
rom the calling code into
(which is equivalent to a $display(sum,prod,count);

r or real in a separate end

*eg.
After initializing sum and count, there is a great similarity in the following four

)m the task groups 
to the (each 

calling composed of four statements). Using a task allows this initial block
as a reg, integer or to be shortened:

integer count,sum,prod;
initial

itput. An inout argu- begin
parate declaration. sum = 0;

count = 1;
example(sum,prod,count,2);
example(sum,prod,count,3);
example(sum,prod,count,5);
example(sum,prod,count,7);
$display(sum,prod,count);

end

,zto Hardware Verilog Hardware DescriptionL anguage M1



The definition of the task example is: values to the
several arbiti

task example; reg and indi
inout sumarg; //lst positional argument
output prod arg; //2nd positional argument
inout countarg; //3rd positional argument
input numb arg; //4th positional argument

integer count-arg,numb-arg,sumarg,prod-arg;

begin
sum-arg = sum-arg + countarg;
prod arg = sum arg * count arg;
count-arg = countarg + numbarg;
$display(sumarg,prod arg);

end
endtask The always

tion 3.8.2.2:
Because the formal inout sumarg is defined first, it corresponds to the actual sum
in the initial block. Similarly, always

the formal output prodarg corresponds to
prod, begin

and the formal inout count-arg corresponds to count. In order to pass @ (p
different numbers each time to example, the formal numb-arg is defined to be S]
input. The order in which the arguments are declared (in this case with the integer
type) is irrelevant. The $ display statements produce the following: @( p

SI
1 1 S]

4 12 cl
10 60
21 231 @ (p
21 231 18

end

3.9.1.2 enternewstatet ask
The translation of the ASM chart from section The 

2.1.1.3 only c
into Verilog given in section

3.8.2.2 is correct but could be improved in two enterne,
ways. First, this translation did not

include state names as part of the Verilog code state 
(they GREEI

were only in the comments).
Second, this translation did not automatically 0 

provide for speec
default values for states where

command signals were not mentioned, as occurs in ASM chart notation.
The task tha

To overcome both of these limitations, we will define a task, which is arbitrarily given
the name enternewstate. The purpose of this task is to do things that occur
whenever the machine enters any state. This includes storing into present state a
representation of a state (which is passed as an input argument, this state), doing
the #1 (which is legal in a task) to allow the <= to work properly and giving default

112 Verilog Digital Computer Design: Algorithms into Hardware



values to the command outputs. In order to use this task, the designer needs to define
several arbitrary bit patterns for the state names, define the presentstate as a
reg and indicate the number of bits in the presentstate:

gument
gument 'define NUMSTATE-BITS 2
gument 'define GREEN 2'bOO
gument 'define YELLOW 2'bO1

'define RED 2'blO
rod-arg;

reg ['NUM_STATE_BITS-1:0] presentstate;

...

The always block that implements the ASM chart is similar to the one given in sec-
tion 3.8.2.2:

esponds to the actual sum
always

-od-arg corresponds to begin
count. In order to pass @(posedge sysclk) enter-newstate('GREEN);

nb-arg is defined to be speed = 3;
isc ase with the integer

Following: @(posedge sysclk) enter newstate('YELLOW);
stop = 1;
speed = 1;
count <= @(posedge sysclk) count + 1;

@(posedge sysclk) enter newstate('RED);
stop = 1;
count <= @(posedge sysclk) count + 2;

end

The only differences a that the state names are passed as arguments to
Verilog given in section enternewstate, and default values do not have to be mentioned. For example,

;t, this translation did not state GREEN uses the default value 0 for stop, and state RED uses the default value
only in the comments). Of or speed.

ilt values for states where
art notation. The task that accomplishes these things for this particular ASM is:

which is arbitrarily given
is to do things that occur
intopresentstate a
nt, this state), doing
operly and giving default

into Hardware Verilog Hardware DescriptionL anguage 113



task enternew state; the result to
input ['NUM_STATEBITS-l:O] this_state; exist so that
begin logic.
present-state = this_state;
#1 stop = 0; 3.9.2.1 

speed = 0; Verilog does
end

endtask function that

Even though default values are assigned for every state, since no time control occurs in
this task after the assignment of default values, those states where non-default values
are assigned work correctly. For example, assume the machine enters state GREEN at
$time 50. At that $time, present_state will be assigned 2'bOO. At $time 51,
stop and speed will assigned their defaults of 0, but since there is no more time
control, the always block which called on the task is not interruptable. At the same
$ time 51 speed changes to 3. Any other module concerned about speed at $ time
51 would only observe a change to a value of 3. To understand this, we need to distin-
guish between sequence and $time. Because the task was called, two changes oc-
curred to speed in sequence, but since they happened at the same $ time, the outside
world can only observe the last change. This creates exactly the effect we want. We are
now ready to model ASM charts that do practical things with behavioral Verilog. Ex-
amples of translating ASM charts into Verilog using tasks like this are given in chapter
4. Such a func

machine, sui
3.9.2 Functions scendental f
The syntax for a function is similar to a task:

3.9.2.2 1
function type name; A more corn

input arguments; national log
section 2.5,

decl arat i ons;
begin

statement;
...
name = expression;

end
endfunction

except only input arguments are allowed. In the function definition, type is either
integer, real or a bit width defined in square brackets. The statement(s) in a .;
function never include any time control. The name of the function must be assigned

14 Verilog Digital Computer Design: Algorithms into Hardware



the result to be returned (like the syntax of Pascal). These restrictions on functions
this_state; exist so that every use of a function could, in theory, be synthesized as combinational

logic.

3.9.2.1 Realfunction example
Verilog does not provide built-in trigonometric functions, but it is possible to define a
function that approximates such a function using a polynomial:

function real sine;
io time control occurs in input x;
here non-default values real x;

enters state GREEN at real y,y2,y3,y5,y7;
begin

1d,2 'bOO.At $time y = x*2/3.14159;
there is no more time = y*y;

erruptable. At the same y3 = y*y2;
about speed at $ time y5 = y3*y2;
I this, we need to distin- y7 y5*y2;
called, two changes oc- sine = 1.570794*y - 0. 2 6 17 9 9 *y3 +
ine $time, the outside o.0130 8 9 9*y5 - .000311665*y7;
effect we want. We are end

behavioral Verilog. Ex -endfunction

thcish apatreer  given in Such a function might be useful if a designer needs to test the Verilog model of a
machine, such as a math coprocessor, that implements an ASM to approximate tran-
scendental functions.

3.9.2.2 Using a function to model combinationall ogic
A more common use of a function in Verilog is as a behavioral way to describe combi-
national logic. For example, rather than being described by the logic gates given in
section 2.5, a half-adder can also be described by a truth table:

inputs output

a b c s

o a a 0
0 1 0 1
1 0 0 1

inition, type is either 1 1 1 0
. The statement(s) in a
nction must be assigned

to Hardware Verilog Hardware DescriptionL anguage 115



Such a table can be written in Verilog as a function defined with a case statement.
Since the result of the function is composed of more than one bit, the function is better
documented by using local variables (c and s in this example), which are concatenated
to form the result:

function [1:0] half-add;
input a,b; The actual arg
reg c,s; //local for documentation and the actual

enated to form
begin bit result is ste

case ({a,b})
2'bOO: begin

c = 0;
s = 0; 3.10 Str

end The preceding
2'bOl: begin gate), features

c = 0; how the desigi
s = 1; design.

end
2'blO: begin

Verilog code is
c = 0;
s module or an 

= 1; i
end amples in this 

2'bll: begin only one copy
c = 1; as the code tha
s = 0;

end An instantiates
default:begin tion. There ma

c = l'bx; instances. For 
s = l'bx; half-adder. It if

end
endcase many times as
half-add = {c,s}; the regs and

end particular reg
endfunction the reg of the

So half_add(0, 0) returns 2'bOO and half_add(1, 1) returns 2'blO. Both Instantiated m(
hal fadd (1,0 ) and hal fadd (0,1 ) return 2'bOl. All other possibilities, such stance. It is this
as half add (1 'bx, 0) return 2'bx. In order to use this function to model the com- that gives each
binational logic of a half-adder, the designer would define an always block with @ internally ideni
time control as explained in section 3.7.2. 1: how an instanc

The syntax for

116 Verilog Digital Computer Design: Algorithms into Hardware



ith a case statement.
it, the function is better reg C,S;

,which are concatenated
always (A or B)

{C,S) = halfadd(A,B);

The actual argument A in the always block is bound to the formal a in hal f_add,
~tion and the actual argument B is bound to the formal b. The locals c and s are concat-

enated to form a two-bit result (hence the [ 1:0] declaration for the function.) This two
bit result is stored in the two-bit concatenation { C, S } .

3.10 Structural Verilog, modules and ports
The preceding sections have covered many behavioral and a few structural (built-in
gate), features of Verilog. This section discusses the most central aspect of Verilog:
how the designer can define and instantiate Verilog modules to achieve hierarchical
design.

Verilog code is composed of one or more modules. Each module is either a top-level
module or an instantiated module. A top-level module is one (like all the earlier ex-
amples in this chapter) which is not instantiated elsewhere in the source code. There is
only one copy of a top-level module. The definition of a top-level module is the same
as the code that executes. The regs and wires in a top-level module are unique.

An instantiated module, on the other hand, is a unique executable copy of the defini-
tion. There may be many such copies. The definition is a "blueprint" for each of these
instances. For example, section 2.5 illustrates an adder that needs three instances of a
half-adder. It is only necessary to define the half-adder once. It can be instantiated as
many times as required. Each instance of an instantiated module has its own copy of
the regs and wires specified by the designer. For example, the value stored in a
particular reg in one instance of a module need not be the same as the value stored in
the reg of the same name in another instance of that module.

Instantiated modules should have ports that allow outside connections with each in-
.) returns 2'blO. Both
other possibilities, such stance. It is this interconnection (i.e., structure) with the system external to the instance

-tion to model the corn- that gives each instance its unique role in the total system. Normally, each instance is

always block with @ internally identical to other instances derived from the same module definition, and
how an instance is connected within the system gives that instance its characteristics.

The syntax for a module definition with ports is:

o Hardware Verilog Hardware DescriptionL anguage 117



-

module name (portl,port2, ... ); rect. There ar
input ... ; of whether 
output th

... ;
inout ... ; stance) or
decl arations;
structural instance; Failure to dec

wire.
behavioral instance;

3.10.2 ou
tasks

An output 
functions to the outside

to produce th,
endmodule size. When th

port should be
output port

An example behavioral co,
3.5. 1. Exam
will be give
ways 3.10.3 

or in in
a module, a An inout pc
selves bel of an inout
wire or re The Verilog c
local variab and output

'stateb uffer. T
The order i EI

definition is
one of the I 3.10.4 Hi'
input, ou Consider the a
appears in t tore in a shoi
though there wish to enter t
inout for sbopping leav4
among these the world fror
the module: things relative
from the vie center to choo

3.10.1 i There is anoti
An input Some pins are
from the out Aittle dangerou
size, or else' Yp ost of the pc

grated circuit.

Some synthesist
118 Verilog Digital Computer Design: Algorithms into Hardware



rect. There are two ways to declare the size: either as a wire of some size (regardless
of whether the module uses a behavioral instance or a structural in-
stance) or with the input definition.7

Failure to declare an input port as a wire will cause it to be treated as a single-bit
wire.

3.10.2 output ports
An output port is one through which information goes out of the module in question
to the outside world. When the module in question uses a behavioral instance
to produce the output port, the output port must be declared as a reg of some
size. When the module in question uses a structural instance, the output
port should be declared as a wire of some size. In other words, whether to declare an
output port to be a wire or reg depends on whether it is generated by structural or

uilt-in gates in section behavioral code within the module in question.
'tural instances
ance is either an al- 3.10.3 inout ports
d functions are local to An inout port is one that is used to send information both directions. The advantage
, but are not by them- of an inout port is that the same port can do two separate things (at different times).
clude specifying either The Verilog code for using an inout port is more complex than for simple input
,ntheses, as well as any and output ports. An inout port corresponds to a hardware device known as a tri-

state buffer. The details of inout ports and tristate buffers are discussed in appendix
E.

rst line of the module
e is instantiated. Every 3.10.4 Historical analogy: pins versus ports
one of the following: Consider the analogy that "ports are like the doors of a building." For buildings like a
the ports of a module store in a shopping center, some doors are labeled "IN," meaning that customers who

elves is irrelevant. Al- wish to enter the store in question should go through that door. Those who are finished
input, output and shopping leave through a different door labeled "OUT." It would be possible to look at

gner makes the choice the world from the viewpoint of the parking lot, but it is more convenient to look at
nation flow relative to things relative to the store in question (since there may be many stores in the shopping
ier looks at the system center to choose from).

There is another analogy for ports: ports are like the pins on an integrated circuit.
Some pins are inputs and some pins are outputs. This is a very good analogy, but it is a

he module in question little dangerous because when a large design is fabricated by a modem silicon foundry,
n the module to have a most of the ports in the design do not correspond to a physical pin on the final inte-
s, which is often incor- grated circuit.

7 Some synthesis tools require that the input definition have the size.

PH ardware Verilog HardwareD escription Language 119



To understand this pin analogy, let's digress for a moment and look at the history of 3.10.5 E
hierarchical design and integrated circuit technology. Before the mid- 1960s, all digital Section 
computers 2.5 (

were built using discrete electronic devices (such as relays, vacuum tubes or does 
transistors). is to de

It takes several such devices, wired together by hand in a certain structure, the 
to @ 

make time c
a gate, and of course, as we have seen in section 2.5, it takes many such gates ever, 

to since 
make a

anything remotely useful. In the early 1960's, photographic technologies be- that 
came models 

practical t
to mass-produce entire circuits composed of several devices on a wafer are 

of semiconductor physical:
material (typically silicon). The wafer is sliced into "chips," which exactly 

are mounted the 
in epoxy (or similar material) with metal pins connecting the circuitry on (sum) 

the chip is, of 
to the outside. There are several standard sizes for the number and placement with behavio

of pins. For example, one of the oldest and smallest configurations is the 16-Pin Dual national 
Inline logi(

Package (DIP). It is a rectangle with seven data pins on each side, and no pins on A reg is 
the not

top or bottom. (Two pins are reserved for power and ground.) A notch or dot at the example 
top of 

of s
the chip indicates where pin one is. is three bits:

Designers in the 1960s and 1970s were limited by the number of devices that fit onto
the chip and also by the number of pins 7

allowed in these standard sizes. Realizing the
power of hierarchical design, these designers built chips that contain standard building
blocks that fit within the number of pins available. An example is a four-bit counter in
one chip, TTL part number 74xx 163, which is still widely used. Whenever designers
needed a four-bit counter, they could simply specify a 74xx 163, without worrying about
its internal details. This, of course, is hierarchical design and provides the same mental
simplification as instantiating a module. Physically, the pins of the 74xx 163 chip would
be soldered into the final circuit.

The 
The widths 

relationship s]
between these early integrated circuits and hierarchical design is not poses!

perfect, hence the danger of saying ports are like pins. If a design needs one 13-bit
counter, a designer in the 1970s would have to specify that four 74xx163s be soldered To 
into exhaustive

the final circuit to act as a single counter. There is an interconnection between possible 
these four coml

chips so that they collectively count properly. From a hierarchical stand-
point, we want to see only one black box, with a 13-bit bus, but this counter is fabri-
cated as four 74xx1 63s wired together. Some of the physical pins (connected to another
one of the 74xx163s) have nothing to do with the ports of a 13-bit counter.

With modem silicon fabrication technologies, the limitations on the number of devices
on a chip have been eased, but the limitations on physical pins have become even more
severe. Although chips can contain millions of gates, the number of pins allowed is
seldom more than a few hundred. Hierarchical design should be driven by the problem
being solved (which is the fundamental principle of all top-down design) and not by
the limitations (such as pins) of the technology used. Every physical pin on a chip is
(part of) a Verilog port, but not every Verilog port necessarily gets 8The 

fabricated width will no
as a physical

pin(s). Even so, the analogy is a good one: ports output 
are like definitic

pins. of some commerc

120 Verilog Digital Computer Design: Algorithms into Hardware



d look at the history of 3.10.5 Example of a module defined with a behavioral instance
ie mid-1960s, all digital Section 2.5 defines an adder several ways. The simplest way to explain what an adder
relays, vacuum tubes or does is to describe it behaviorally. Since an adder is combinational logic, we can use
id in a certain structure, the @ time control technique discussed in section 3.7.2.1 to model its behavior. How-
tt akes many such gates ever, since an adder is used in a larger structure, we should make the always block
raphic technologies be- that models the adder's behavior part of a module definition. Those ports (a and b) that
reral devices on a wafer are physical inputs to the fabricated adder will be input ports to this module, and are
wed into "chips," which exactly the variables listed in the sensitivity list. The port that is a physical output
necting the circuitry on (sum) is, of course, defined to be an output port. Since this module computes sum
number and placement with behavioral code, sum is declared to be a reg. (There are no "registers" in combi-
lions is the 16-Pin Dual national logic, but a Verilog reg is used in a behavioral model of combinational logic.
ach side, and no pins on A reg is not a "register" as long as the sensitivity list has all the inputs listed.) As in the
d.) A notch or dot at the example of section 2.5, the widths of a and b are two bits each, and the width of sum

is three bits:

of devices that fit onto module adder(sum,a,b);

ard sizes. Realizing the input [1:0] a,b;

Intain standard building output [2:0] sum;
wire [1:0] 

is a ab;
four-bit counter in

reg [2:0] sum;
A. Whenever designers
without worrying about always @(a or b)
7ovides the same mental sum = a + b;
the 74xx163 chip would endmodule

The widths shown on input and output definitions are optional for simulation pur-
ierarchical design poses.8is not
Design needs one 13-bit
ir 74xx163s be soldered To exhaustively test this small adder, test code similar to section 3.7.2.1 enumerates all
iterconnection between possible combinations of a and b:
m a hierarchical stand-
ut this counter is fabri-
is (connected to another
I-bit counter.

n the number of devices
have become even more
nber of pins allowed is
e driven by the problem
own design) and not by
'hysical pin on a chip is SThe width will not be shown on later examples in this chapter, although describing the width on input and
s fabricated as a physical output definitions would be legal in simulation. The width might be required to overcome the limitations

of some commercial simulation tools.

o Hardware Verilog HardwareD escription Language 121



pump

module top;
integer ia,ib; It is the pos
reg [1:0] a,b; module is in
wire [2:0] sum;

adder adderl(sun,a,b); 3.10.6 E
Of course, i

initial described in
begin an instance

for (ia=O; ia<=3; ia = ia+1) full_add
begin

a = ia;
for (ib=O; ib<=3; ib = ib + 1)
begin
b = ib;
#1 $display(a=%d b=%d sum=%d,a,b,sum);

end
end

end
endmodule

The important thing in this top-level test module is that adder (the name of 
ule the 

definition) mod-
is instantiated in top with the name adderl. In the top-level module,

a and b are regs because, within this module (top), a and b are supplied by 
ioral behav-

code. On the other hand, sum is supplied by adderl, and so top declares 
to be a sum Since the 

wire. ad(
The syntax for instantiating a user defined module is similar to 

ating instanti- fal), all 
a of 

built-in t
gate. In this example, the local sum of top corresponds to the output sends 

port the 
(coincidentally can

named sum) of an instance of module adder. If the names (such code 
as as 

sum) in tht
in module adder were changed to other names (such as total), the 

would module and hal f_a4
work the same:

3.10.7 Mi
module adder(total,alpha,beta);

input Even though 
alphabeta; ]

output total; 3.10.6, they c
wire [1:0] alphabeta; ioral definitio
reg [2:0] total;

always (alpha or beta)
total = alpha + beta;

endmodule

9Verilog rovides
tion, to determine

122 Verilog Digital Computer Design: Algorithms into Hardware



It is the position within the parentheses, and not the names, that matter9 when the
module is instantiated in the test code.

3.10.6 Example of a module defined with a structural instance
Of course, in hierarchical design, we need a structural definition of the module. As
described in section 2.5, the module adder can be defined in terms of instantiation of
an instance of a half_adder (which we will call hal) and an instance of a
full adder (which we will call fal):

module adder(sum,a,b);
input a,b;
output sum;
wire [1:0] a,b;

a,b, sum) ; wire [2:0] sum;

wire c;

halfadder hal(c,sum[0],a[0],b[0f);
fulladder fal(sum[2],sum[1l,a[l],b[1],c);

r (the name of the mod- endmodule
In the top-level module,

are supplied by behav-
nd so top declares sum Since the adder is defined with two structural instances (named hal and
ale is similar to instanti- fal), all of the ports, including the output port, sum, are wires. The local wire c
)rresponds to the output sends the carry from the half-adder to the full-adder. Of course, we need identical test
der. If the names (such code as in the last example, and we also need module definitions for full_adder
Eas  total), the module andhalfadder.

3.10.7 More examples of behavioral and structural instances
Even though half_adder and fulladder are instantiated structurally in section
3.10.6, they can be defined either behaviorally or structurally. For example, a behav-
ioral definition of these modules is:

;

9 Verilog provides an alternative syntax, described in chapter 11, that allows the name, rather than the posi-
tion, to determine how the module is instantiated.

to Hardware Verilog Hardware DescriptionL anguage 123



module half_adder(c,s,a,b);
input a,b; There are tw
wire a,b; tween these t
output s; three local w
reg cs; within the m(

always (a or b) At this point,
{c,s) = a+b; or, xor) w

endmodule

module full_adder(cout,sa,b,cin); 3.10.8 Hi
input a,b,cin; Although por
wire a,b,cin; other in a pro
output couts; cess the inten
reg cout,s; and Pascal, h;

information. 
always (a or b or cin) for accessing

{cout,s} = a+b+cin; systems 
endmodule for a(

can access the
Once again, notice that the outputs are regs. Concatenation is used on the left of the = modules), you
to make the definition of the module simple. { cout, s} is a two-bit reg capable of
dealing with the largest possible number (2'bll) produced by a+b+cin. For example,

adderl shoN
An alternative would be to define the half_adder and full-adder modules with not accessible
structurali nstances, which means all outputs are wires: allow the desi

module halfadder(cs,a,b);
input a,b;
wire a,b;
output Cs; A name, such
wire c,s;

The following
xor xl(s,a,b);
and al(c,a,b);

endmodule EIII
which happens

module full_adder(cout,s,a,b,cin);
input a,b,cin;
wire lul

a,b,cin;
output couts;
wire cout,s; The parts of a I
wire coutl,cout2,stemp; name, except t

sponding modi
half-adder ha2(coutl,stemp,a,b); example) neve
half-adder ha3(cout2,s,cin,stemp);
or ol(cout,coutl,cout2);

endmodule

124 Verilog Digital Computer Design: Algorithms into Hardware



There are two instances of halfadder (ha2 and ha3). The only difference be-
tween these two instances is how they are connected within full_adder. There are
three local wires (coutl, cout2 and stemp) that allow internal interconnection
within the module.

At this point, we have reduced the problem down to Verilog primitive gates (and,
or, xor) whose behavior is built into Verilog.

3.10.8 Hierarchical names
cin); Although ports are intended to be the way in which modules communicate with each

other in a properly functioning system, Verilog provides a way for one module to ac-
cess the internal parts of another module. Conventional high-level languages, like C
and Pascal, have scope rules that absolutely prohibit certain kinds of access to local
information. Verilog is completely different in this regard. The philosophy of Verilog
for accessing variables is very similar the philosophy of the NT or UNIX operating
systems for accessing files: if you know the path to a file (within subdirectories), you
can access the file. Analogously in Verilog: if you know the path to a variable (within

is used on the left of the = modules), you can access the variable.
a two-bit reg capable of
by a+b+cin. For example, using the definition of adder given in section 3.10.6, and the instance

adderl shown in the test code of section 3.10.5, adderl has a local wire c that is
1_adder modules with not accessible to the outside world. The following statement in the test code would

wires: allow the designer to observe this wire, even though there is no port that outputs C:

$display(adderl.c);

A name, such as adderl c is known as a hierarchicaln ame, or path.

The following statement allows the designer to observe cout2 from the test code:

I_ $display(adderl.fal.cout2);

which happens to be the same as:
in);

$display(adderl.fal.ha3.c);

The parts of a hierarchical name are separated by periods. Every part of a hierarchical
name, except the last, is the name of an instance of a module. The names of the corre-
sponding module definitions (adder, full_adder and half_adder in the above

, b ); example) never appear in a hierarchical name.
temp);
t2);

into Hardware Verilog Hardware Description Language 125



3.10.9 Data structures Data structur
The term "structure" has three distinct meanings in computer technology. Elsewhere in data. For exa
this book, "structure" takes on its hardware meaning: the interconnection of modules sponding tot,
using wires. But you have probably heard of the other two uses of this word: "struc- since there ar
tured programming," and "data structures." The concept of "structured programming" from the outs
is a purely behavioral software concept which is closely related to what we call goto-
less programming (see section 2.1.4). "Data structures" are software objects that allow module pa
programmers to solve complex problems in a more natural way. reg [7:

reg [5:
The period notation used in Verilog for hierarchical names is reminiscent of the nota- reg [3:
tion used in conventional high-level languages for accessing components of a "data
structure" (record in Pascal, task di

struct in C, and class in C++). In fact, you can
create such integ

software "data structures" in Verilog by defining a portless module that has begin
only data, but that is intended to be instantiated. Such a portless but instantiated mod- if
ule is worthless for hardware description, but is identical to a conventional software p
"data structure." Such a module has no behavioral instances or structural instances. els
For example, a data structure could be defined to contain payroll information about an p
employee: $di

end
module payroll; endtask

reg [7:0] id; endmodule
reg [5:0] hours;
reg [3:0] rate; module to

endmodule payroll
payroll

Suppose we have two employees, j oe and j ane. Each employee has a unique in- initial
stance of this module: begin

joe

payroll joe(); joe

payroll jane(); joe
joe

initial j an

begin j ano

joe.id=254; j an

joe.hours=40; jani

joe.rate=14; end
endmodule

jane.id=255;
jane.hours=63;
jane.rate=15; This is very cli

end like C++, exc
C++.

The empty parentheses are a syntactic requirement of Verilog. In this example, the
fields of j ane contain the largest possible values.

126 Verilog Digital Computer Design: Algorithms into Hardware



Data structures usually have a limited set of operations that manipulate the fields of the
,hnology. Elsewhere in data. For example, the hours and rate fields can be combined to display the corre-

oofn mneocdtuiolens sponding total pay. This operation is defined as a local task of the module. However,
:s of this word: "struc- since there are no behavioral instances in this module, this task sits idle until it is called
actured programming" from the outside (using a hierarchical name):
I to what we call goto-
ware objects that allow module payroll;

reg [7:0] id;
reg [5:0] hours;
reg [3:0] rate;

,miniscent of the nota-
:omponents of a "data task display-pay;
C++). In fact, you can integer pay; //local
ortless module that has begin

but instantiated mod- if (hours>40)
conventional software pay = 40*rate + (hours-40)*rate*3/2;
Dr structural instances. else

11in formation about an pay = hours*rate;
$display("employee %d earns %d",id,pay);

end
endtask

endmodule

module top;
payroll joe();
payroll jane();

loyee has a unique in- initial
begin

joe.id=254;
joe.hours=40;
joe.rate=14;
joe.display-pay;
jane.id=255;
jane.hours=63;
jane.rate=15;
jane.display-pay;

end
endmodule

This is very close to the software concept of object-orientedp rogrammingi n languages
like C++, except the current version of Verilog lacks the inheritance feature found in
C++.

. In this example, the

oH ardware Verilog Hardware DescriptionL anguage 127



Data structures are a powerful use of hierarchical names, but they are somewhat afield
from the central focus of this book: hardware structures. Application of hierarchical Verilog requ
names are useful in test code, and so it is important to understand them. Also, the above reg declara
example helps illustrate what instantiation really means in Verilog. wide, the pa

put port, dot
3.10.10 Parameters
Verilog modules allow the definition of what are known Since 

as parameters. there i
These are con-

stants that can be different for each instance. For theses:
example, suppose you would like to

define a module behaviorally that models an enabled register of arbitrary width:

module enabled register(dout, din, ld, sysclk); Sometimes,
parameter WIDTH = 1;
input din,ld,sysclk; ample, a con
output dout; same:
wire [WIDTH-1:0] din;
reg [WIDTH-1:0] dout;
wire ld,sysclk;

always @(posedge sysclk)
if (d)
dout = din;

endmodule

By convention, we use capital letters for parameters, but this is not a requirement. Note
that parameters do not have a backquote preceding them.

If you instantiate this module without specifying a constant, the default given in the
parameter statement Here 

(in this is an 
example, ex

1) will be used as the WIDTH, and so the
instance R1 will be one bit wide:

wire ldRl,sysclk;
wire Rldout,Rldin;
enabled-register Rl(Rldout,Rldin,ldRl,sysclk);

To specify a non-default constant, the syntax is a # followed by a list of constants in
parentheses. Since there is only one parameter in this example, there can be only one
constant in the parentheses. For example, to instantiate a 12 -bit register for R 2:

wire ldR2,sysclk; 3.11 Cc
wire [11:0] R12dout,R12din; Modules are 
enabledregister #(12) R1 2 (Rl2dout,R12din,ldRI2,sysclk); are either top.

Instantiated n
inout. Con!
module is eit]

128 Verilog Digital Computer Design: Algorithms into Hardware



iey are somewhat afield Verilog requires that the width of a wire that attaches to an output 
flication port 

of hierarchical match the
reg declaration within the module. In this example, R12dout is a wire twelve bits

Idt hem. Also, the above wide, the parameter WIDTH in the instance Rl 2 is twelve, and 
ilog. the corresponding out-

putport,dout,isdeclaredasreg[WIDTH-1:0],whichisthesameasreg [11:0].

Since there is only one constant in the parentheses above, it is legal to omit the paren-
meters. These are con- theses:
wpose you would like to
)f arbitrary width: enabled-register #12 R12(Rl2dout,R12din,ldRl2,sysclk); I

I sysclk); Sometimes, you need more than one constant in the definition of a module. For ex-
ample, a combinational multiplier has two input buses, whose widths need not be the
same:

module multiplier(prod,a,b);
parameter WIDTHA=l,WIDTHB=l;
output prod;
input a,b;
reg [WIDTHA+WIDTHB-l:0] prod;
wire [WIDTHA-l:0] a;
wire [WIDTHB-l:0] b;

always @(a or b)
not a requirement. Note prod = a*b;

endmodule

the default given in the Here is an example of instantiating this:
the WIDTH, and so the

wire [5:0] hours;
wire [3:0] rate;
wire [9:0] pay;

ysclk); ] multiplier #(6,4) ml(pay,hours,rate);

by a list of constants in
, there can be only one
.t register for R12:

3.11 Conclusion
Modules are the basic feature of the Verilog hardware description language. Modules
are either top-level or instantiated. Top-level modules are typically used for test code.

R12,sysclk);
Instantiated modules have ports, which can be defined to be either input, output or
inout. Constants in modules may be defined with the parameter statement. A
module is either defined with a behavioral instance (always or initial

o Hardware
Verilog HardwareD escription Language 129



block(s) or with a structural instance (built-in gates 
designer-provided or instantiation 

modules). of other
Behavioral and structural instances SMrIH, 

same may DOUG]
module. be mixed in the andS imulatij

son, AL, I199
Variables produced by behavioral code, including outputs 
clared from 

to the 
be module, 

regs. Behavioral are de-
modules have the usual high-level STERNHEim, 

if and while, statements, El
as well such 

as as
time control (#, @ and wait) that Automata Pui

can indicate 
be suspended when the 

and process
resumed. The $ time variable simulates 

the fabricated the passage 
hardware. of time 

Verilog in
makes a distinction between ThOMAS, DON

and the passage algorithmic 
of $ t sequence

ime. The most important forms of time guage, Third
a constant, control are 

which # followed 
is used by

for generating the clock and test internally.
sysclk), vectors; 

which @( posedge
is used to model controllers and registers; 

sensitivity and 
list, @ followed 

which is used by a
for combinational logic. Verilog 

ing provides 
assignment the non-block-

statement, which is ideal for translating ASM 
behavioral charts 

Verilog. that use 
Verilog RTN into

also provides tasks and functions, 3.13 Exi
tures which 

in conventional like similar 
high-level fea-

languages, simplify coding. 3-1. Design b,
described 

Structural in 
modules e

have a simple syntax. They may instantiate 
vided modules other designer-pro-

to achieve hierarchical design. They may 
The also 

syntax instantiate 
for both built-in 

kinds gates.
of instantiation des  i d

is identical. All 
ule, variables 

including in a structural 
outputs, are mod-

wires.

Hierarchical names allow access to tasks 3-2. 
and Design 

variables a s
hierarchical from other modules. 

names is usually Use of
limited instances 

to test code. of ar

The next chapter uses the features of Verilog described 
three in this 

stages chapter 
(pure to express 

behavioral, the
mixed and 3-3. 

pure Modify 
structural) th(

childish of the design 
division process 

machine for the
designed manually instantiation 

in chapter of
Verilog 2. The advantage 

at each of these of using
stages is that the designer For example, 

can simulate th
is correct each 

before stage 
going to be 

on sure 
to the it

next stage. drawn 
Also, the in sectioi

final 
sized Verilog 

into a code 
working can be 

piece synthe-
of hardware, without the designer 

produce having 
a flattened to toil manually 

circuit to
diagram and netlist.

3.12 Further reading
3-4. Given the in

LEE, JAMES M., Verilog Quickstart, Kluwer, Norwell, MA, chical names are
amples 1997. 

of Gives 
implicit several 

style. ex-

PALNITKAR, S., Verilog HDL: A Guide to Digital Design 
PTR, and 

Upper Synthesis, 
Saddle Prentice 

River, Hall 3-5. Design 
NJ, 1996. behr

An excellent reference for all aspects of Verilog. ules using the te
that allows instan

130 Verilog Digital Computer Design: Algorithms into Hardware



Is or instantiation of other SMITH, DOUGLAS J., HDL Chip Design: A PracticalG uide for Designing, Synthesizing,
aices may be mixed in the and Simulating ASICs and FPGAs Using VHDL or Verilog, Doone Publications, Madi-

son, AL, 1997. A Rosetta stone between Verilog and VHDL.

from the module, are de- STERNHEIM, ELIEZER, RAJVIR SINGH and YATIN TRIVEDI, DigitalD esign with Verilog HDL,
-level statements, such as Automata Publishing, San Jose, CA, 1990. Has several case studies of using Verilog.
indicate when the process

ites the passage of time in THoMAs, DONALD E. and PHILIP R. MooRBY, The Verilog Hardware Description Lan-
een algorithmic sequence guage, Third edition, Kluwer, Norwell, MA., 1996. Explains how a simulator works

@c ontrol are # followed by internally.
,st vectors; @( posedge
,rs; and @ followed by a
)gp rovides the non-block-
Ac harts that use RTN into 3.13 Exercises
as, which like similar fea- 3-1. Design behavioral Verilog for a two-input 3-bit wide mux using the technique

described in section 3.7.2.1. The port list for this module should be:
Lntiate other designer-pro-
o instantiate built-in gates.
riables in a structural mod- I module mux2(iO, il, sel, out);

3-2. Design a structural Verilog module (mux2) equivalent to problem 3-1 using only
)m other modules. Use of instances of and, or, not and buf.

this chapter to express the 3-3. Modify the solution to problem 3-1 to use a parameter named SIZE that allows
'the design process for the instantiationofanarbitrary width for i0, il and out as explainedin section 3.10.10.
!. The advantage of using For example, the following instance of this device would be useful in the architecture
late each stage to be sure it drawn in section 2.3.1:
Terilog code can be synthe-
rh aving to toil manually to

wire muxctri;
wire [11:0] x,y,muxbus;
mux2 #12 mx(x,y,muxctrl,muxbus);

3-4. Given the instance (mx) of the module (mux2) shown in problem 3-3, what hierar-
chical names are equivalent to x, y, muxctrl and muxbus?

L, 1997. Gives several ex-

7d Synthesis, Prentice Hall 3-5. Design behavioral Verilog for combinational incrementor and decrementor mod-
e for all aspects of Verilog. ules using the technique described in section 3.7.2.1. Use a parameter named SIZE

that allows instantiation of an arbitrary width for the ports as explained in section 3.10. 10.

into Hardware Verilog Hardware DescriptionL anguage 131



3-6. Design behavioral Verilog for an up/down counter (section D.8) using the tech- to become:
nique described in section 3.7.2.2. The port list for this module should be:

@( pose(
I module updown-register(din,dout,ld,up,count,clk); I a =_ 

3-7. Modify the solutions to problem 3-6 to use a parameter named SIZE that allows Run the modifie,
instantiation of an arbitrary width for the ports as explained in section 3.10.10. circle the differed

file for the modif
are not any differ

3-8. Design behavioral Verilog for a simple D-type register (section D.5) using the
technique described in section 3.7.2.2. Use a parameter named SIZE that allows
instantiation of an arbitrary width for the ports as explained in section 3.10.10. The port 3-12. Without w
list for this module should be: scribed by the A'

clock cycles, and
run the original i

I module simpled register(din,dout,clk); of the .log file. 0
each clock cycle.

3-9. Design a structural Verilog module (updown-register) equivalent to problem log file. Finally,
3-7 using only instances of the modules defined in problems 3-3, 3-5 and 3-8. Verilog code and

if any, that exist I
Verilog. In no mi

3-10. For each of the ASM charts given in problem 2-10, translate to implicit style ences between i
Verilog using non-blocking assignment for - and @( posedge sysclk) #1 for
each rectangle, as explained in section 3.8.2.3.1. As in that example, there should be
one always that models the hardware, one always for the $display and an 3-13. Without us
always and initial for sysclk. Compare the result of simulation with the manually scribed by the As
produced timing diagram of problem 2-10. clock cycles, and

run the original i
of the .log file. 0

3-11. Without using a Verilog simulator, give a timing diagram for the machine de- each clock cycle.
scribed by the ASM chart of section 3.8.2.3.3. Show the values of a and b in the first .log file. Finally,
twelve clock cycles, and label each clock cycle to indicate which state the machine is and make a print
in. Next, run the original implicit style Verilog code equivalent to the ASM and make exist between the
a printout of the log file. On this printout, write the name of the state that the machine no more than thre
is in during each clock cycle. The manually created timing diagram should agree with using and omittir
the Verilog .log file. Finally, modify the following:

@(posedge sysclk) #1; // state FIRST
a <= (posedge sysclk) 1;

132 Verilog Digital Computer Design: Algorithms into Hardware



n D.8) using the tech- to become:
should be:

@(posedge sysclk) #1; // state FIRST
cuntclk); a = 1;

imed SIZE that allows Run the modified Verilog code and make a printout of its .log file. On this printout,
section 3.10.10. circle the differences, if any, that exist between the correct timing diagram and the log

file for the modified Verilog. In no more than three sentences, explain why there are or
are not any differences between = and <=.

section D.5) using the
ned SIZE that allows
action 3.10.10. The port 3-12. Without using a Verilog simulator, give a timing diagram for the machine de-

scribed by the ASM of section 3.8.2.3.4. Show the values of a and b in the first twelve
clock cycles, and label each clock cycle to indicate which state the machine is in. Next,
run the original implicit style Verilog code equivalent to the ASM and make a printout

c1k) ; of the .log file. On this printout write the name of the state that the machine is in during
each clock cycle. The manually created timing diagram should agree with the Verilog

) equivalent to problem .log file. Finally, modify the code to change the if to a while. Run the modified
-3, 3-5 and 3-8. Verilog code and make a printout of its .log file. On this printout, circle the differences,

if any, that exist between the correct timing diagram and the log file for the modified
Verilog. In no more than three sentences, explain why there are or are not any differ-

inslate to implicit style ences between i f and whi le.
age sysclk) #1 for
:ample, there should be
he $display and an 3-13. Without using a Verilog simulator, give a timing diagram for the machine de-
lation with the manually scribed by the ASM of section 3.8.2.3.5. Show the values of a and b in the first twelve

clock cycles, and label each clock cycle to indicate which state the machine is in. Next,
run the original implicit style Verilog code equivalent to the ASM and make a printout
of the .log file. On this printout write the name of the state that the machine is in during

im for the machine de- each clock cycle. The manually created timing diagram should agree with the Verilog
s of a and b in the first .log file. Finally, modify the code to eliminate all #s. Run the modified Verilog code
ich state the machine is and make a printout of its .log file. On this printout, circle the differences, if any, that
it to the ASM and make exist between the correct timing diagram and the .log file for the modified Verilog. In
e state that the machine no more than three sentences, explain why there are or are not any differences between
gram should agree with using and omitting #s.

te FIRST

o Hardware Verilog HardwareD escription Language 133



4. THREE STAGES FOR 4.1.1.1 Ov,
First, we have
the number of I

VERILOG DESIGN 'define N
The design of the childish division machine described in chapter 2 can be expressed in 'define I

Verilog using the language features discussed in chapter 3. This chapter uses variations 'define I
'define 

on the C
childish division machine as a simple but practical example of how to design 'define C

hardware with Verilog.

As described in sections 2.1.5.1 through 2.1.5.3, the three-stages of the top-down de- These definitio
sign process are: pure behavioral, mixed behavior/structure and pure structural. Be- of a module the
cause Verilog allows both behavioral and structural constructs, one can transform a output as a pori
design through these three stages by minor editing of the Verilog source code. Section module cl
4.1 gives several examples of how the pure behavioral ASMs of chapter 2 can be writ- para
ten in pure behavioral Verilog using the implicit style of section 3.8.2.3. Section 4.2 outp
uses one of these behavioral examples to illustrate translation into the mixed stage. reg

Section 4.3 translates the mixed example from section 4.2 into the pure structural stage
(the "explicit style" often used by Verilog designers). Section 4.4 shows that, having init

completed the three phases of our design process, Verilog allows additional cl
structure

(in this case, dealing with the controller) to be instantiated in place of behavior using alwa
the hierarchical design process described in section 2.5. #5

Chapter 7 and appendix F describe an alternate way (which can be automated) for
translating pure behavioral (implicit style) Verilog alwa

directly to a form that can be syn-
if

thesized into physical hardware. The manual technique in this chapter is more intricate endmodule
and involved than the one in chapter 7, but an understanding of the three-stage tech-
nique in this chapter will give the reader a better appreciation for the behavioral and The purpose of
structural aspects of Verilog simulation. amount of $tii

ment, the simul

Third, the modi
4.1 Pure behavioral examples needs to be defi
This section gives examples of modeling various ASM charts for the childish division module sli
algorithm with pure behavioral Verilog. input pi

output 
wire ..

4.1.1 Four-state division machine reg...
Let's consider translating the second ASM chart of section 2.2.3 (the one that has four-
states, with state COMPUTE1 at the top of the loop) into Verilog, using the
enternew-state approach described in section 3.9.1.2. endmodule

134 Verilog Digital ComputerD esign: Algorithms into Hardware



vOR 4.1.1.1 Overview of the source code
First, we have to define the arbitrary bit patterns that represent the states and indicate
the number of bits required:

'define NUMSTATEBITS 2

ter 2 can be 'define 
expressed in IDLE 2'bOO

'define INIT 2'bOl
is chapter uses variations 'define COMPUTEl 2'b10
,ample of how to design 'define COMPUTE2 2'bll

iges of the top-down de- These definitions occur outside any modules. Next, we need to include the definition
and pure structural. Be- Ifa module that generates the clock in a fashion similar to 3.7.1.3, except the clock is
cts, one can transform a <utput as a port of the module:
log source code. Section module cl(clk);
of chapter 2 can be writ- parameter TIMELIMIT = 110000;
.tion 3.8.2.3. Section 4.2 output clk;

cn into the mixed stage. reg clk;

the pure structural stage
n 4.4 shows that, having initial

clk = 0;
lows additional structure
l place of behavior using always

#50 clk = -clk;

h can be automated) for
always (posedge clk)

) a form that can be syn-
if ($time > TIME-LIMIT) #70 $stop;

;c hapter is more intricate endmodule
g of the three-stage tech-
)n for the behavioral and Ihe purpose of the parameter TIMELIMIT is to stop the simulation after a certain

mount of $time has elapsed. Without scheduling such a $stop (or $ finish) state-
nent, the simulation could continue forever.

hird, the module that implements the behavioral simulation of the actual hardware
eds to be defined with an appropriate portlist:

sf or the childish division module slowdiv system(pb,ready,x,y,r2,sysclk);
input pb,x,y,sysclk;
output ready,r2;
wire ...
reg...

2.3 (the one that has four- .. .

into Verilog, using the
endmodule

nto Hardware Three Stages for Verilog Design 135



This module corresponds to the first block diagram in section 2.5.2. At this stage, we Even for a 
are leaving the details of this module ambiguous. The discussion of the details inside 3.7.3) woulk
this module will continue in section 4.1.1.2. In the above
Finally, the last module that needs to be defined is the top-level test code. Using a stance name
technique involving #, @ and wait that is similar to the one described in section 3.7.3, pb, corresp
the test code checks if the simulated hardware can divide values of x that vary from 0 module, the
to 14 properly when y is held fixed at 7: The third an

of the same
corresponds

module top; port of the mr
reg pb; in the test cc
reg [11:0] x,y;
wire [11:0] quotient; The reason 
wire ready; stance of the
integer s; supplies sys
wire sysclk; to slowdi

because the
cl #20000 clock(sysclk); behavioral =
slowdiv system slowdiv_machine(pb,ready,xy, does not sup

quotient,sysclk);
initial

begin 4.1.1.2 
pb= 0;
x = O; Let's return I
y = 7; declare the t
#250; such as thosc
@(posedge sysclk); the presen
for (x=0; x<=14; x = x+l)
begin

@(posedge sysclk); module
pb = 1; input
@(posedge sysclk); outpul
pb = 0; wire I
@(posedge sysclk); wire
wait(ready); reg r(
@(posedge sysclk); reg [:
if (x/y === quotient) reg [
$display("ok');

else endmodu:
$display("error x=%d y=%d x/y=%d quotient=%d",

x,y,x/y,quotient);
end These declar;

$stop; in the test co(
end

endmodule

136 Verilog Digital Computer Design: Algorithms into Hardware



2.5.2. At this stage, we Even for a small machine like this, an exhaustive test (such as was given in section
;ion of the details inside 3.7.3) would be too time consuming to use as an illustration.

In the above code, note that slow division system is instantiated with the in-
level test code. Using a stance name slowdivision machine. The first port in the module, the input
-scribed in section 3.7.3, pb, corresponds to a reg in the test code of the same name. The second port in the
ies of x that vary from 0 module, the output ready, corresponds to a wire of the same name in the test code.

The third and fourth ports of the module, the inputs x and y, correspond to 12-bit regs
of the same names in the test code. The fifth port of the module, an output named r2,
corresponds to a 12-bit wire whose name is quotient in the test code. The final
port of the module, an input named sys cl k, corresponds to a wire of the same name
in the test code.

The reason syscik is a wire is because it happens to be an output port of the in-
stance of the cl module named clock. This means clock, rather than the test code,
supplies sysclk. The test code therefore has a little bit of structure connecting clock
to slowdiv machine. The variables in the test code that are regs are so declared
because the test code must supply them to slowdivisionmachine using the
behavioral =. The remaining wires are so declared because the behavioral test code

'X, y, does not supply them.
,clk);

4.1.1.2 Details on slowdivision-system
Let's return to the definition of the slowdivisionsystem module. We need to
declare the types of the inputs and outputs. Also, we need to declare local variables,
such as those that model the physical registers of the hardware (rl and r2), and also
the presentstate:

module slowdiv system(pb,ready,x,y,r2,sysclk);
input pb,x,y,sysclk;
output ready,r2;
wire pb,sysclk;
wire [11:0] x,y;
reg ready;
reg [11:0] rl,r2;
reg ['NUM_ STATE_BITS-l:0] present_state;

endmodule
quotient=%d",

These declarations were constrained by the portlist, how the module was instantiated
in the test code and by the description of the problem given in chapter 2.

'o Hardware Three Stages for Verilog Design 137



As described in section 3.9.1.2, we should define a task that simplifies the code for the
sequence of statements that must occur when the machine enters each state: always @(

$disr

task enternewstate;
input ['NUM STATEBITS-1:0] thisstate; The net effect 
begin the module giv

present_state = this-state;
#1 ready=O; 7

end
endtask

The definition of this task will be nearly identical for every pure behavioral ASM. The
only distinction from one problem to another is the list of external command outputs
(see section 2.1.3.2.1) specific to the particular machine. In this case, the only external 1

command output is ready. It has a default value of 0; thus this task must initialize it at
the beginning of every clock cycle.

Having defined the above task within the slowdivisionsystem module, it is
possible to translate the ASM from section 2.2.3 into Verilog: 1

always
begin
@(posedge sysclk) enternewstate('IDLE);
rl <= (posedge sysclk) x;
ready = 1;
if (pb)
begin
@(posedge sysclk) enter_newstate('INIT);
r2 <= (posedge sysclk) 0;
while (rl >= y)

begin
@(posedge sysclk) enter newstate('COMPUTEl);
rl <= (posedge sysclk) rl - y;
@(posedge sysclk) enter newstate('COMPUTE2);
r2 <= @(posedge sysclk) r2 + 1;

end
end The regs ri ai

end by the $displ
machine return
is the same as,

The only other thing that would be desirable to put in this module is a debugging code uses to de
display, as described in section 3.7.2.4:

138 Verilog Digital Computer Design: Algorithms into Hardware



;implifies the code for the
iters each state: always @(posedge sysclk) #20

$display("%d rl=%d r2=%d pb=%b ready=%b",
$time, rl,r2, pb, ready);

The net effect of the other modules defined in section 4.1.1.1 and all the details inside
the module given above is to produce the following simulation output from Verilog:

70 rl= x r2= x pb=0 ready=l
170 rl= 0 r2= x pb=0 ready=l
270 rl= 0 r2= x pb=0 ready=l
370 rl= 0 r2= x pb=l ready=1

ure behavioral ASM. The 470 rl= 0 r2= x pb=l ready=l
ternal command outputs 570 rl= 0 r2= 0 pb=0 ready=1

lis case, the only external ok

is task must initialize it at 670 rl= 0 r2= 0 pb=0 ready=l
770 rl= 1 r2= 0 pb=l ready=l
870 rl= 1 r2= 0 pb=0 ready=0

n-system module, it is 970 rl= 1 r2= 0 pb=0 ready=l
ok

6670 rl= 12 r2= 1 pb=0 ready=l
6770 rl= 13 r2= 1 pb=1 ready=l
6870 rl= 13 r2= 1 pb=0 ready=0
6970 rl= 13 r2= 0 pb=0 ready=0
7070 rl= 6 r2= 0 pb=0 ready=0
7170 rl= 6 r2= 1 pb=0 ready=l

ok
7270 rl= 13 r2= 1 pb=0 ready=l
7370 rl= 14 r2= 1 pb=l 

'NIT); ready=l
7470 rl= 14 r2= 1 pb=0 ready=0
7570 rl= 14 r2= 0 pb=0 ready=0
7670 rl= 7 r2= 0 pb=0 ready=0
7770 rl= 7 r2= 

e('COMPUTEl); 1 pb=0 ready=0
7870 rl= 0 r2= 1 pb=0 ready=0
7970 rl= 0 r2= 2 pb=0 ready=l

.e('COMPUTE2);
ok

The regs ri and r2 are not initialized at $time O, and so the value 12 'bx is printed
by the $disp lay simply as x (not to be confused with the variable x). Each time the
machine returns to state IDLE (ready= 1), the outputs of the machine from r2 (which
is the same as quotient) are highlighted above. These are the values that the test

module is a debugging code uses to determine that everything is "ok" each time.

vto Hardware Three Stagesfor Verilog Design 139



nplifies the code for the
,rs each state: always @(posedge sysclk) #20

$display("%d rl=%d r2=%d pb=%b ready=%b",
$time, rl,r2, pb, ready);

The net effect of the other modules defined in section 4.1.1.1 and all the details inside
the module given above is to produce the following simulation output from Verilog:

70 rl= x r2= x pb=0 ready=l
170 rl= 0 r2= x pb=0 ready=l
270 rl= 0 r2= x pb=0 ready=l
370 rl= 0 r2= x pb=l ready=l

*eb ehavioral ASM. The 470 rl= 0 r2= x pb=0 ready=0
rnal command outputs 570 rl= 0 r2= 0 pb=0 ready=l
case, the only external ok

task must initialize it at 670 rl= 0 r2= 0 pb=0 ready=l
770 rl= 1 r2= 0 pb=1 ready=l
870 rl= 1 r2= 0 pb=0 ready=0

_system module, it is 970 rl= 1 r2= 0 pb=0 ready=l
ok

6670 rl= 12 r2= 1 pb=0 readyzi
6770 rl= 13 r2= 1 pb=0 ready=l
6870 rl= 13 r2= 1 pb=l ready=l
6970 rl= 13 r2= 0 pb=0 ready=O
7070 rl= 6 r2= 0 pb=0 ready=0
7170 rl= 6 r2= 1 pb=0 ready=0

ok
7270 rl= 13 r2= 1 pb=0 ready=l
7370 rl= 14 r2= 1 pb=l ready=l
7470 rl= 14 r2= 1 pb=0 ready=0
7570 rl= 14 r2= 0 pb=0 ready=0
7670 rl= 7 r2= 0 pb=0 ready=0
7770 rl= 7 r2= 1 pb=0 ready=0

('COMPUTEl);
7870 rl= 0 r2= 1 pb=0 ready=0
7970 rl= 0 r2= 2 pb=0 ready=l

('COMPUTE2);
ok

The regs rl and r2 are not initialized at $ time 0, and so the value 12 'bx is printed
by the $display simply as x (not to be confused with the variable x). Each time the
machine returns to state IDLE (ready= 1), the outputs of the machine from r2 (which
is the same as quotient) are highlighted above. These are the values that the test

nodule is a debugging code uses to determine that everything is "ok" each time.

Hardware Three Stagesf or Verilog Design 139



4.1.2 Verilog catches the error Continued.
The first ASM chart in section 2.2.3 (with state COMPUTE2 at the top of the loop) has
an error. An advantage of using Verilog to simulate such a machine while it is still in the
behavioral stage is that Verilog can usually catch such errors before they become costly.
In this case, the Verilog code would be identical to section 4.1.1.2, except the ASM
chart would be translated as:

always Because of th
begin complete the t

thus the test o
while (rl >= y)

quotient is
begin
@(posedge sysclk) enternewstate('COMPUTE2); Rather than sl
r2 <= @(posedge sysclk) r2 + 1; designer can

@(posedge sysclk) enter_new_state('COMPUTE1);
rl <= (posedge sysclk) rl - y;

end 4.1.3 ImE
end Do not be del

end in section 4.1
automated to(

The output from the Verilog simulator makes the problem obvious: to think. In fi
signer is resp

2670 rl= 5 r2= 0 pb=0 ready=l designing tes
2770 rl= 6 r2= 0 pb=l ready=l When we beE
2870 rl= 6 r2= 0 pb=0 ready=0 assumptions
2970 rl= 6 r2= 0 pb=0 ready=l

things: there
ok

3070 rl= 6 r2= 0 pb=0 ready=l this user nee
3170 rl= 7 r2= 0 pb=l ready=l state IDLE (1
3270 rl= 7 r2= 0 pb=0 ready=0 a single cloc]
3370 rl= 7 r2= 0 pb=0 ready=0

The test cod
3470 rl= 7 r2= 1 pb=0 ready=0
3570 rl= 0 r2= 1 pb=0 ready=0 vided in the
3670 rl= 0 r2= 2 pb=0 ready=0 chine stay in
3770 rl=4089 r2= 2 pb=0 ready=l ever, a probl

error x= 7 y= 7 x/y= 1 quotient= 2 illustrated b

8670 rl= 13 r2= 2.pb= ready=1 Consider the
8770 rl= 14 r2= 2 pb=1 ready=l identical to I
8870 rl= 14 r2= 2 pb=l ready=l
8970 rl= 14 r2= 0 pb=0 ready=O
9070 rl= 14 r2= 1 pb=0 ready=0
9170 rl= 7 r2= 1 pb=0 ready=0

140 Verilog Digital Computer Design: Algorithms into Hardware



Continued.
at the top of the loop) has
chine while it is still in the 9270 rl= 7 r2= 2 pb=0 ready=0

efore they become costly. 9370 rl= 0 r2= 2 pb=0 ready=0

4.1.1.2, except the ASM 9470 rl= 0 r2= 3 pb=0 ready=0
9570 r=4089 r2= 3 pb=0 ready=1

error x= 14 y= 7 x/y= 2 quotient= 3

Because of the error (which causes the loop to execute an extra time), the time to
complete the test is longer. The wait statement in the test code compensates for this;
thus the test code is checking r2 via quotient at the proper time, but when y>=7,
quotient is just plain wrong.

ate('COMPUTE2);
Rather than spending thousands of dollars actually fabricating a faulty computer, the

1;
Ite('COPUTEl); designer can observe the problem simply from the behavioral Verilog code.
Y;

4.1.3 Importance of test code
Do not be deluded that because Verilog can sometimes catch errors such as described
in section 4.1.2 that it will always catch such errors. Just because a designer uses an
automated tool like a Verilog is not the same as saying that the designer does not have

Mvioous: to think. In fact, using such tools requires a higher level of thought process. The de-
signer is responsible not just for trying to design a machine that works, but also for

ady=1 designing test code that aggressively checks to see if the design fails.
ady=1
ady= O When we began with this example in section 2.2.1, we stated in informal English some
ady=1 assumptions about the environment in which this machine operates. We assumed two

things: there is a friendly user (who provides inputs in a specific sequence), and that
ady=1 this user needs the output of the machine to remain constant when the machine is in
ady=1 state IDLE (because the user is a person who cannot perceive events that happen within
!aaddyy==O a single clock cycle, which are typically less than a millionth of a second).
!aaddyy==O
!aaddyy==O The test code given in section 4.1.1.1 satisfies the assumption that the inputs are pro-
ady=O0 vided in the order demanded in section 2.2.1 (in particular the test code lets the ma-
eaaddyy==OO chine stay in state IDLE two clock cycles before the button is pressed). There is, how-
!ady=ll ever, a problem with the above test code with regard to the second assumption, as is
.ent= 2 illustrated below.

iady=1 Consider the ASM chart of section 2.2.4. The Verilog code to simulate this machine is
!adyy==ll identical to the previous examples, except for the following:
!ady=O
~aaddyy==O O
~aaddyy==OO
~aaddyy== O0

Wnto Hardware Three Stages for Verilog Design 141



always But as was di!
begin point because
@(posedge sysclk) enter-newstate('IDLE); ample, at $ti
rl <= @(posedge sysclk) x; this. But at $ t
r2 <= (posedge sysclk) 0;
ready = ready 

1; still ir
if (pb) The proper aE
begin make these de
while (rl >= y) of what the mt

begin
@(posedge ing, 

sysclk) and some
enternew state('COMPUTEl);

rl <= (posedge sysclk) rl - y; Nevertheless,
@(posedge sysclk) enter new state('COMPUTE2);
r2 <= (posedge sysclk) r2 + 1;

end
end 4.1.4 Add

end

The first ASM
When Verilog simulates this with the test code given earlier, it detects no errors:

70 rl= x r2= x pb=0 ready=1 always
170 rl= 0 r2= 0 pb=0 ready=l begin
270 rl= 0 r2= 0 pb=0 ready=l @( pos

370 rl= 0 r2= 0 pb=l ready=l rl <

470 rl= 0 r2= 0 pb=l ready=l r2 <

570 rl= 0 r2- 0 pb=0 ready=l read

ok if (:
be

6070 rl= 12 r2= 0 pb=0 ready=l w
6170 rl= 13 r2= 0 pb=l ready=l
6270 rl= 13 r2= 0 pb=0 ready=0
6370 rl= 6 r2= 0 pb=0 ready=0
6470 rl= 6 r2= 1 pb=O ready=1

ok
6570 rl 13 r2= 0 pb=0 ready-l
6670 rl= 14 r2= 0 pb=l ready=l
6770 rl= 14 r2= 0 pb=0 ready=0
6870 rl= 7 r2= 0 pb=0 ready=0 en

6970 rl= 7 r2= 1 pb=0 ready=0 end

7070 rl= 0 r2= 1 pb=0 ready=0
7170 rl= 0 r2- 2 pb=0 ready=l

ok

1 See J. Cooley, It
the test code pro,
correctly because

142 Verilog Digital Computer Design: Algorithms into Hardware



But as was discussed in section 2.2.4, it is unacceptable from a user interface stand-
point because it throws away the correct answer after only one clock cycle. For ex-
ample, at $ time 6470, the correct answer 1 is present in r2, and the test code notes
this. But at $ t ime 6570, the machine has thrown away the correct answer even though
ready still indicates that the correct answer should be displayed.

The proper approach is to take all details in the informal English specification and
make these details part of the test code. The test code should be a formal specification
of what the machine is supposed to do under all circumstances. This raises the interest-
ing, and somewhat unsolvable dilemma: how does the designer test the test code?'

('COMPUTEl);
Nevertheless, it is important to put reasonable effort into creating robust test code.

('COMPUTE2);

4.1.4 Additional pure behavioral examples

The first ASM chart of 2.2.5 can be translated into Verilog as:
t detects no errors:

ly=l always

ly=l begin

ly=l @(posedge sysclk) enter_new state('IDLE);

Iy=l rl <= (posedge sysclk) x;

ly=l r2 <= (posedge sysclk) 0;

ly=l ready = 1;
if (pb)
begin

Iy=l while (rl >= y)

Iy=l begin

[y=o 0(posedge sysclk) enternew-state('COMPUTE1);

ly=O rl <= (posedge sysclk) rl - y;

Lyn1 *(posedge sysclk) enter new state('COMPUTE2);
r2 <= (posedge sysclk) r2 + 1;

LIyr *(posedge sysclk) enternew state('COMPUTE3);

Iy=l r3 <= (posedge sysclk) r2;
Ly=0 end

Ly= 0 end

Ly= 0 end

Ly= 0
Ly=l

1S ee J. Cooley, Integrated System Design, July 1995, pp. 56-60 for a description of a Verilog contest where
the test code provided to the contestants was erroneous. The "winning design" would not actually work
correctly because the test code could not detect a flaw in the design.

to Hardware Three Stages for Verilog Design 143



where everything else is the same as earlier examples, except the states are represented
as:

30'
31'
32'

'define NUMSTATEBITS 2 33'
'define IDLE 2'bO0 34'
'define COMPUTEl 2'bOl 35'
'define COMPUTE2 2'blO ok
'define COMPUTE3 2'bll

. . .

The second X
and the portlist now has r3 rather than r2 as the output:

always
begin

module slowdivsystem(pb,ready,x,y,r3,sysclk); @( pos

input pb,x,y,sysclk; rl <

output ready,r3; r2 <

wire pb; read

wire [11:0] x,y; if (

reg ready; be

reg [11:0] r,r2,r3; i

reg ['NUM_STATEBITS-1:0] present-state;

Also, r3 must be mentioned in the debugging $display statement. As was described
in chapter 2, this machine fails for x<y (the quotient is unknown):

70 rl= x r2= x r3=x pb=0 ready=l
170 rl= 0 r2= 0 r3=x pb=0 ready=l
270 rl= 0 r2= 0 r3=x pb=0 ready=l e
370 rl= 0 r2= 0 r3=x pb=l ready=l
470 rl= 0 r2= 0 r3=x pb=0 ready=l
570 rl= 0 r2= 0 r3=x pb=0 ready=l

error x= 0 y= 7 x/y= 0 quotient=x
... en

end

although it does work for larger values:
where the stat

144 Verilog Digital Computer Design: Algorithms into Hardware



he states are represented

3070 rl= 6 r2= 0 r3= x pb=0 ready=l
3170 rl= 7 r2= 0 r3= x pb=l ready=l
3270 rl= 7 r2= 0 r3= x pb=0 ready=0
3370 rl= 0 r2= 0 r3= x pb=0 ready=0
3470 rl= 0 r2= 1 r3= x pb=0 ready=0
3570 rl= 0 r2= 1 r3= 1 pb=0 ready=1

ok

The second ASM chart of section 2.2.5 can be translated as:

always
begin

Lk); @(posedge sysclk) enternew state('IDLE);
rl <= @(posedge sysclk) x;
r2 <= @(posedge sysclk) 0;
ready = 1;
if (pb)
begin
if (rl >= y)
while (rl >= y)

begin
@(posedge sysclk) enternew state('COMPUTEl);

,ment. As was described rl <= @(posedge sysclk) rl - y;
wn): @(posedge sysclk) enter new state('COMPUTE2);

r2 <= @(posedge sysclk) r2 + 1;
@(posedge sysclk) enter_new state('COMPUTE3);
r3 <= @(posedge sysclk) r2;

end
else

begin
e (posedge sysclk) enternew state('ZEROR3);
r3 <= (posedge sysclk) 0;

end
end

end

where the states are represented as:

'o Hardware Three Stages for Verilog Design 145



Continued

'define NUMSTATEBITS 3
'define IDLE 3'b000

end
'define COMPUTE1 3'bO01
'define COMPUTE2 3'bOlO end
'define COMPUTE3 3'bOll
'define ZEROR3 3'blO0 The above correct

state COMPUTE
which does work correctly for all values, including x<y:

3070
3170

70 rl= x r2= x r3= x pb=0 ready=l 3270
170 rl= 0 r2= 0 r3= x pb=0 ready=l 3370
270 rl= 0 r2= 0 r3= x pb=0 ready=l 3470
370 rl= 0 r2= 0 r3= x pb=l ready=l error x=
470 rl= 0 r2= 0 r3= x pb=0 ready=0
570 rl= 0 r2= 0 r3= 0 pb=0 ready=l

ok
The corrected A'
in state COMPU

The second ASM of section 2.2.6 can be translated as: always
begin
@ (posed
rl <=

always
r2 <=

begin
ready

@(posedge sysclk) enter-newstate('IDLE);
if (pb

rl <= @(posedge sysclk) x;
begi

r2 <= @(posedge sysclk) 0;
if

ready = 1;
w

if (pb)
begin
if (rl >= y)
while (rl >= y)

begin
@(posedge sysclk) enter-newstate('COMPUTE);
rl <= @(posedge sysclk) rl - y;

els
@(posedge sysclk) enternewstate('COMPUTE23)
r2 <= (posedge sysclk) r2 + 1;
r3 <= (posedge sysclk) r2;

end
else

end
begin

end
@(posedge sysclk) enternew-state('ZEROR3);

146 Verilog Digital Computer Design: Algorithms into Hardware



Continued
r3 <= @(posedge sysclk) 0;

end
end

end

The above correctly models the design error due to inappropriate use of parallelism in
state COMPUTE23 that causes r3 to be assigned a value too early:

3070 rl= 6 r2= 0 r3. 0 pb=0 ready=l
3170 

:ly= rl= 
1 7 r2= 0 r3= 0 pb=0 ready=l

3270 
iy=1 rl= 7 r2= 0 r3= 0 pb=l ready=l

3370 
ay= 1 rl= 0 r2= 0 r3= 0 pb=0 ready=0

3470 rl= 
:ly=1 0 r2= 1 r3= 0 pb=0 ready=0

Iy=0 error x= 7 y= 7 x/y= 1 quotient= 0

aly=l

The corrected ASM chart of 2.2.6 that has all three computations happening in parallel
in state COMPUTE123 can be translated into Verilog as:

always
begin
@(posedge sysclk) enternew-state('IDLE);
rl <= @(posedge sysclk) x;
r2 <= @(posedge sysclk) 0;
ready = 1;
if (pb)
begin
if (rl >= y)
while (rI >= y)

begin
@(posedge sysclk) enter new state('COMPUTE123);
rl <= (posedge sysclk) rl - y;
r2 <= (posedge sysclk) r2 + 1;

:e('COMPUTE); r3 <= (posedge sysclk) r2;
end

:e('COMPUTE23); else
begin
@(posedge sysclk) enternewstate('ZEROR3);
r3 <= @(posedge sysclk) 0;

end
end

'ZEROR3); end

o Hardware Three Stagesfor Verilog Design 147



where the states are defined as: Continued

'define NUMSTATEBITS 2 (E
'define IDLE 2'bOO rJ
'define COMPUTE123 2'bOl r:
'define ZEROR3 2'bll rE

ii

The simulator shows that this version works correctly:
. .0.

3070 rl= 6 r2= 0 r3= 0 pb=O ready=l
3170 rl= 7 r2= 0 r3= 0 pb=1 ready=0
3270 rl= 7 r2= 0 r3= 0 pb=O ready=O
3370 rl= 0 r2= I r3= 0 pb=O ready=O
3470 r=4089 r2= 2 r3= 1 pb=O ready=1

ok
end

task 
inpi

4.1.5 Pure behavioral stage of the two-state division machine beg:

The best correct design proposed in chapter 2 for the division machine is described by pi

the ASM chart in section 2.2.7. It has the advantage that it takes only one clock cycle
each time end

it goes through the loop, and it only needs an ASM with two states. Here is endta!
how this ASM chart can be translated into a pure behavioral module, similar to the
earlier examples: alway!

$di:

'define NUM_STATEBITS 1 endmodu:
'define IDLE l'b0
'define COMPUTE l'bl

For brevity, t
'include "clock.v" simulation th

module slowdiv system(pb,ready,x,y,r3,sysclk);
input pb,x,y,sysclk;
output ready,r3;

2
wire pb;

2'
wire [11:0] x,y; 2
reg ready; 2
reg [11:0] rl,r2,r3; ok
reg ['NUMSTATEBITS-l:0] present state; 3

3
always 3

begin 3
3

148 Verilog Digital Computer Design: Algorithms into Hardware



Continued

@(posedge sysclk) enter newstate('IDLE);
rl <= @(posedge sysclk) x;
r2 <= @(posedge sysclk) 0;
ready = 1;
if (pb)
begin
while (rl >= y I pb)

begin
ay=l @(posedge sysclk) enternew state('COMPUTE);
Iy=l rl <= @(posedge sysclk) rl - y;
Iy=O r2 <= @(posedge sysclk) r2 + 1;
Iy=O r3 <= @(posedge sysclk) r2;
Iy=1 end

end
end

task enternewstate;
input ['NUM_STATE_BITS-1:0] thisstate;

ision machine begin

machine is described by present_state = this_state;

:es only one clock cycle #1 ready=0;

with two states. Here is end

. endtask
module, similar to the

always (posedge sysclk) #20
$display("%d rl=%d r2=%d r3=%d pb=%b ready=%b",

$time, rl,r2,r3, pb, ready);
endmodule

_ I~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fo rb revity, the cl module has been placed in the "clock . v" file. Here is the Verilog
sinnulation that shows it working:

2670 rl= 5 r2= 0 r3= 0 pb=0 ready=1
2770 rl= 6 r2= 0 r3= 0 pb=0 ready=1
2870 rl= 6 r2= 0 r3= 0 pb=l ready=0
2970 rl=4095 r2= 1 r3= 0 pb=0 ready=l

ok
3070 rl= 6 r2= 0 r3= 0 pb=0 ready=l
3170 rl= 7 r2= 0 r3= 0 pb=l ready=l
3270 rl= 7 r2= 0 r3= 0 pb=0 ready=0
3370 rl= 0 r2= 1 r3= 0 pb=0 ready=0
3470 rl=4089 r2= 2 r3= 1 pb=0 ready=l

7 Hardware Three Stagesfor Verilog Design 149



Continued 4.2.1.1 en
ok This module h,

sized data outl
6570 rl= 13 r2= 0 r3= 1 pb=0 ready=1 modeled by thi
6670 rl= 14 r2= 0 r3= 1 pb=1 ready=1 current value
6770 rl= 14 r2= 0 r3= 1 pb=0 ready=0 rising edge of
6870 rl= 7 r2= 1 r3= 0 pb=0 ready=0
6970 rl= 0 r2= 2 r3= 1 pb=0 ready=0
7070 rl=4089 r2= 3 r3= 2 pb=0 ready=l

ok module er
pare
inp-

This two-state machine will be the basis for the examples that show how to translate outr

from pure behavioral Verilog into mixed Verilog (section 4.2) and into pure structural reg

Verilog (section 4.3). This example is also used to illustrate the hierarchical refinement wirE

of the controller to become a netlist (section 4.4). wirE
wirE

endmodule

4.2 Mixed stage of the two-state division machine
As was explained in section 2.3.1, to translate an algorithm into hardware eventually The ellipsis inc
requires that the designer decide upon a particular architecture. The mixed stage is the and 3.10.10) g
point in the design process when the designer decides how the registers and combina- ter) and 74xx3
tional logic devices of the architecture are to be interconnected. The only constraint is signal. This me
that this interconnection be able to implement all of the RTN commands used in the value at the ne
pure behavioral stage at the times required. used in the sin

stantiating the

4.2.1 Building block devices
Verilog only provides built-in primitives for elementary gates, such as and. In order to 4.2.1.2 cc
model the mixed stage of the design, we need to define modules that simulate the bus This module I
width devices that are instantiated in the architecture. The devices outlined here are a section D.7 foi
few of the common ones from appendixes C and D. output, tc, th,

count and c
The details of just exactly how these modules work internally need not concern us now. next rising edE
We just need to know the (arbitrary) order and definition of ports in the portlist for
devices we want to use in the architecture. We will assume these devices are fully
defined in a file, "archdev . v," with behavioral code. module c(
All of these modules have a parameter, SIZE, that indicates the bus width of the data pare
inputs and outputs of the module. (The widths of command and status ports, if any, on inpi

the device are determined by the nature of the device.) out]
reg
wir(
reg

150 Verilog Digital Computer Design: Algorithms into Hardware



isterportlist
is, di, of a chosen SIZE (the default is 1), and a similar
e section D.6 for a description of the hardware being

(=1
o has the enable input, which, when it is 1, causes the

1=1

(=0 ed into the register (thereby changing do) at the next
1=0

(=o

.er(di,do,enable,clk);
1;

cik;
show how to translate
md into pure structural o;
Hierarchical refinement di;

endmod.u.l.e

machine
-o hardware eventually behavioral definition of the register (see sections 3.7.2.2
The mixed stage is the -was inspired by the 74xx377 (eight-bit enabled regis-
registers and combina- d register) TTL chips, which have an active low enable
.The only constraint is xle where the physical 74xx377 is scheduled to change
commands used in the te 74x377 will have zero volts representing the 1 bi

ble. Other than this minor detail, any architecture in-
in be constructed from these chips.

uch as and. In order to isterportlist
Asth at simulate the bus )us, di, and a similar sized data output bus, do. (See
ces outlined here are a the hardware being modeled by this module.) It has an

urrent output is at its maximal value. It also has load,
ed not concern us now. termine what the value of the counter will be after the
)orts in the portlist for
these devices are fully

er(di,do,tc,load,count,clr,clk);
e bus width of the data 1;
I status ports, if any, on unt,clr,clk;

.0;
di;

)H ardware
'e Stagesfor Verilog Design 151



Continued 4.2.1.4 cor

wire load,count,clr;
wire clk; This module mo

scription of the b
endmod..u.le b, and three static

the outputs will 1
This module was inspired by the 74xx 163 (4-bit up counter), which has active low ci r
and load signals (see the discussion in section 4.2.1.1.) Also, this chip has two inputs
that must both simultaneously be one to cause counting. The reason for having two module com

param
inputs, rather than just the one count shown above, is to simplify the connections

outpu
required to cascade the four-bit chip to form larger counters. Since at this stage of the input
design we are not at all concerned with such physical details, the above module was wire
simplified to have a single count signal. reg a

endmodule
4.2.1.3 alui81portlist
This module models a combinational ALU inspired by the 74xx181. (See section C.6
for a description of the hardware being modeled by this module.) It has two data
inputs, a and b, and a similar sized data output bus, f. It also has status outputs, cout 4.2.1.5 mm
(I when addition and similar operations produce a carry) and zero (1 when f is zero).
It is controlled by the commands: s, m and cin: This module mi

description of th
and ii, and a si

module alul8l(a,b,s,m,cin,cout,f,zero); the output is i 0
parameter SIZE = 1;
input a,b,smcin;
output cout,f,zero;
wire [SIZE-l:0] a,b; module mu)

wire mcin; parar

wire [3:0] s; input

reg [SIZE-l:0] f; outpi

reg cout,zero; wire
wire

endmod..u.le reg

endmod.u..le
In chapter 2, the ALU was considered to have a six-bit command input, aluctrl.
When this module is instantiated, this input should be subdivided in the following
fashion:

alul81 #size instancename(a,b,aluctrl[5:21,
aluctrl[l,aluctrl[0],cout,f,zero);

152 Verilog Digital Computer Design: Algorithms into Hardware



4.2.1.4 comparatorportlist

This module models a comparator inspired by the 74xx85. (See section C.7 for a de-
scription of the hardware being modeled by this module.) It has two data inputs, a and
b, and three status outputs, alt b, aeqjb, agt-b. At any time, only one of
the outputs will be 1, depending on a and b:

thich has active low ci r
this chip has two inputs

e reason for having two module comparator(a_lt-b, a_eq_b, agt-b, a, b);
implify the connections parameter SIZE = 1;

Since at this stage of the output altb, a_eqb, agtb;

, the above module was input a, b;
wire [SIZE-l:0] a,b;
reg altb, a_eq_b, agt-b;

endmodule

,xxl8l. (See section C.6
odule.) It has two data
has status outputs, cout 4.2.1.5 mux2portlist
Nero (1 when f is zero).

This module models a multiplexor inspired by the 74xx157. (See section C.4 for a
description of the hardware being modeled by this module.) It has two data inputs, i 0
and i, and a similarly sized data output, out. When the command input, sel, is 0,
the output is i . When sel is 1, the output is i:

module mux2(iO, i, sel, out);
parameter SIZE = 1;
input i0, i, sel;
output out;
wire [SIZE-1:0] i, i;
wire sel;
reg [SIZE-l:0] out;

endmnodule
tmand input, aluctri.
livided in the following

f' zero) 

ito Hardware
Three Stagesf or Verilog Design 153



4.2.2 Mixed stage
As discussed in chapter 2, the system is no longer described simply in terms of its
behavior. Instead, in the mixed stage, there is a specific structure that interconnects the
controller and the architecture:

x 0
12 r

y 1
module slow div system(pb,ready,x,y,r3,sysclk); 12

input pb,x,y,sysclk;
output ready,r3; ml
wire pb;
wire [11:0] x,y;
wire ready;
wire [11:0] r3;
wire sysclk;

wire [5:0] aluctrl;
wire muxctrl,ldrl,clrr2,incr2,ldr3,rlgey;

sysclk -
slowdiv arch a(aluctrl,muxctrl,ldrl,clrr2,

incr2,ldr3,rlgey,x,y,r3,sysclk); Figure 4-1. A
slowdiv-ctrl c(pb,ready,aluctrl,muxctrl,ldrl,

clrr2,incr2,ldr3,rlgey,sysclk);
endmodule Here is how tl

This version of slowdiv sys tem replaces the behavioral version of this module module s

discussed in section 4.1. The test code that instantiates slowdiv-system should
not notice any difference between this mixed stage module and the earlier pure behav- input a

ioral stage. Note that all ports and locals in this module are now declared to be wire output

since this module is composed simply wire 
of two structural instances, and there [5

are no
wire mu

behavioral assignment statements.
wire [1
wire [1

4.2.3 Architecture for the division machine
enabled

At the end of section 2.3.1, a particular architecture for the division machine was cho- mux2
sen that handles all the RTN and decisions required by the division machine. To aid in alul8l
understanding the Verilog that is equivalent to this architecture, figure 4-1 shows the
same architecture from section 2.3.1 redrawn with the names to be used in the Verilog
code: compara

not

counter
enabled

154 Verilog Digital Computer Design: Algorithms into Hardware



-

I simply in terms of its
re that interconnects the

Y
Lk);

sysclk -

Figure 4-1. Architecture with names usedfor Verilog coding.

Here is how this architecture can be described as a structural Verilog module:

I version of this module module slowdivarch(aluctrl,muxctrl,ldrl,
div-system should clrr2,incr2,ldr3,rlgey,x,y,r3bus,sysclk);

i the earlier pure behav- input aluctrl,muxctrl,ldrl,clrr2,incr2,ldr3,x,y,sysclk;

)w declared to be wire output rgey,r3bus;

ances, and there are no wire [5:0] aluctrl;
wire muxctrl,ldrl,clrr2,incr2,ldr3,rlgey,sysclk;
wire [11:0] x,y,r3bus;
wire [11:0] muxbus,alubus,rlbus,r2bus;

enabledregister #12 rl(alubus,rlbus,ldrl,sysclk);
'ision machine was cho- mux2 #12 mx(x,y,muxctrl,muxbus);
ision machine. To aid in alul81 #12 alu(rlbus,muxbus,aluctrl[5:2j,
re, figure 4-1 shows the aluctrl[l],aluctrl[0],,alubus,);
Dob e used in the Verilog

comparator #12 cmp(rllty, ,,rlbus,y);
not inv(rlgey,rllty);

counterregister #12 r2(,r2bus,,l'bO,incr2,clrr2,sysclk);
enabledregister #12 r3(r2bus, r3bus,ldr3,sysclk);

o Hardware
Three Stages for Verilog Design 155



Continued The next t
comparat

always (posedge sysclk) #20 than y. Th(
begin The built-it

$display("%d rl=%d r2=%d r3=%d pb=%b ready=%b", $time,
rlbus,r2bus,r3bus, There is a 
slowdivmachine.pb,slow-divmachine.ready); Its data in

$write(" %b %b WI, opposed to
ldrl,{clrr2,incr2},ldr3); and increm

$display(" muxbus=%d alubus=%d",muxbus,alubus); The tc out]
$write(" '1); but it must
$display(" muxctrl=%b aluctrl=%b", the 74xx16

muxctrl,aluctrl); high logic,
$write (" left disconi
$display(" x=%d rgey=%b",x,rlgey);

end Finally, the
endmodule from r2bu

ule. The co
The portlist for this module includes the commands that are input to this architecture At the bottc
(that were output from the controller). These commands include the six-bit aluctrl have chang
as well as muxctrl, ldrl, clrr2, incr2 and ldr3. Also, the portlist has the refer to rl}
status output rlgey. The portlist has the twelve bit data inputs x and y and the 12-bit its portlist,
data output r3bus. Of course, since there are clocked registers in the architecture, play state
they must be supplied with sysclk. The order in this portlist matches the order where not corresp
this is instantiated in section 4.2.2. designer, it
The first three structural instances (rl, mx and alu) define the portion of the block cal names 
diagram that relates to register rl. This name is no longer a reg as it was in the pure statements
behavioral stage, but is instead the instance name for an enabled register, whose mand signa
portlist is defined in section 4.2.1.1. This instance is for a twelve bit wide register values of th
(because the parameter is instantiated with 12). The input to this enabled-register below therr
comes from alubus, which is described below. The output from this the test cod
enabled-register is known as rlbus. Of course both alubus and rlbus are data input (
wires since this module is defined only with structure. The load signal for rl is ldrl,
and as is necessary in synchronous design, rl is connected to sysclk. 4.2.4 Cs
There is an instance (named mx) of mux2 (see section 4.2.1.5) instantiated to be 12 bits
wide. It selects the data input x when muxctrl is 0, and y when muxctrl is 1. Its Although ir
outputismuxbus.All of thesebuses areof course 12-bits wide. The instance of alul8l is a creativ
(see section 4.2.1.3) named alu takes its inputs from rlbus and muxbus. The

behavioral
aluctrl is provided to the appropriate ports. The cout and zero ports of alul 81

not involve
are left disconnected. The f output connects to the alubus (mentioned in the last

architecture
paragraph) that provides the input to rl.

156 Verilog Digital Computer Design: Algorithms into Hardware



io structural instances (cmp and inv) produce rgey. The instance of
or (see section 4.2.1.4) produces the output rlty when ribus is less
a_eq-b and a-gt b outputs of comparator are left disconnected.
not produces rgey from rilty.

.dy=%b", $time,
2-bit instance of counterregister (see section 4.2.1.2) named r2.

kachine.ready); ut is left disconnected. Normally this is a bad idea to leave an input (as
I", in output) disconnected. However, in this case, the counter is only cleared

nted, so the data input is not needed. The output of this counter is r2bus.
us,alubus); put of this register is not used. The load port of this instance is not utilized,

be specified as being tied to 1 bO. (In the physical TTL active low logic of
,, this would be equivalent to tying this to the five-volt supply. In active
his would be equivalent to tying it to ground.) The load port cannot be
ected. The commands incr2 and clrr2 are provided to r2, as is sysclk.

re is another instance (r3) of enabledregister whose input comes
3 and whose output is r3bus, which is the data output of this entire mod-
nmand ldr3 is provided to r3, as is sysclk.

nput to this architecture m of this module are debugging $ display statements. Some 
le of 

the six-bit the names
aluctrl ed from those used in the pure behavioral version of this machine. We 

Iso, the now
portlist has the us, r2bus and r3bus. Also, this module does not have pb or ready in

s x and y and the 12-bit and so to produce the same style output as earlier simulations, 
ters in the architecture, the $dis-

nent must use hierarchical names. (Since the $display statement 
matches does

the order where )nd to synthesized hardware, and is only there for the convenience of the
would be inappropriate to use ports to access such information. Hierarchi-

the portion of the block re exactly what we need for a situation like this.) Two extra $display
-eg as it was in the pure how signals that were not present in the pure behavioral stage. The corn-
ed-register, whose s (ldrl, {clrr2, incr2 and dr3) are displayed directly below the
twelve bit wide register er egisters they affect. Also, the values of internal buses are shown. Directly
enabledregister are the command signals that affect them. Also, the status signal output to
'he output from this (rlgey) and the data input from the test code (x) are displayed. The other
lubus and rlbus are r) is not displayed because in this test code it remains unchanged at 7.

id signal for rl is drl,
osysclk. introller for the division machine
instantiated to be 12 bits
when muxctrl is1 .I ts
The instance of alul81 stantiating the components for the architecture as described in section 4.2.3
:us and muxbus. The task that could have been done in a variety of ways, translating the pure
zero ports of alul81 tage into the mixed stage controller is a straightforward process that does

s (mentioned in the last any creativity. For a particular pure behavioral machine, and for a chosen
there is only one correct controller. To arrive at this controller,

wt Hardware Three Stages for Verilog Design 157



1. Define a module (slowdivctrl in this example) for the controller with ap- Continued
propriate declarations that match how it was instantiated in the mixed system
module (in this example, it is instantiated inside slowdiv system as shown
in section 4.2.2).

2. Initialize all the internal command signals (aluctrl, muxctrl, ldrl,
clrr2, incr2 and ldr3 in this example) used by the architecture to their
default values in the enternewstate task.

3. Move the always block from the pure behavioral system (in this example,
slowdiv system of section 4.1.5) to inside the controller module, and com-
ment out all non-blocking assignment statements (using / /).

4. Following each non-blocking assignment that is commented out, put assignment
statement(s) that assert the equivalent command signals. For example, / / r2 <=

@(posedge sysclk) 0; isfollowedbyclrr2 = 1.
5. Replace relational conditions, such as rl >= y, with status signals, such as

rlgey.

Here is the module that is instantiated in section 4.2.2 and corresponds end
to pure behav-

ioral Verilog of section 4.1.5, and that is equivalent to the mixed ASM chart of section task er
2.3.1:

input
begin
presE

module slowdivctrl(pb,ready,aluctrl,muxctrl,ldrl, #l{re

clrr2,incr2,1dr3,rlgey,syscik); end
input pb,rigey,sysclk; endtask
output ready,aluctrl,muxctrl,ldrl,clrr2,incr2,ldr3; endmodule

reg ['NUN_STATE_BITS-1:0] presentstate;

wire pb; The boldface a
reg ready; into this mixec
reg [5:0] aluctrl; which has the c
reg muxctrl,ldrl,clrr2,incr2,ldr3; Use of single b
wire rgey,sysclk; mixed controll(

tecture (althou
always ture to accomp

begin
from a data mai

@(posedge sysclk) enternewstate('IDLE);

//rl <= binational 
(posedge logic

sysclk) x;

//r2 <= @(posedge sysclk) 0; there are two re
ready = 1; shown above, a
aluctrl = 'PASSB; to represent the
muxctrl = 0; input to the arc]
ldrl = 1; Since we would
clrr2 = 1; the architecture
if (pb) signal.

158 Verilog Digital Computer Design: Algorithms into Hardware



the controller with ap- Continued
I in the mixed system
iv-system as shown begin

while (rigey I pb)
muxctrl, drl, begin

iea rchitecture to their @(posedge sysclk) enternew-state('COMPUTE);
ready = 0;
//rl <= @(posedge sysclk) rl - y;

;tem (in this example, //r2 <= @(posedge sysclk) r2 + 1;
Dllcerr2 ,m loddru3l;e, and corn- //r3 <= @(posedge sysclk) r2;
/). aluctrl = 'DIFFERENCE;

tle d ou,t),u ;pssugtm anssignment muXCtrl = 1;
orexample,//r2 <= 1drl = 1;

1. incr2 = 1;

status signals, such as ldr3 = 1;
end

end
end

esponds to pure behav-
d ASM chart of section task enternewstate;

input [NUM_STATE-BITS-1:0] thisstate;
begin
presentstate = this_state;

I,m drl, #l(ready,aluctrl,muxctrl,ldrl,clrr2,incr2,ldr3}=O;

clk); end
endtask

endmodule

The boldface above shows the editing done to transform the pure behavioral Verilog
into this mixed stage. Of some interest is the fact that the pure behavioral while,
which has the condition ( (rl>=y) Ip b),is translated above into (rlgey I pb).
Use of single bit & and | (or perhaps more clearly &&a nd I I ) is permitted inside a
mixed controller. This notation is not a data computation that must occur in the archi-
tecture (although the designer could have chosen to put a single or gate in the architec-
ture to accomplish this). It is important to distinguish this decision-making use of I
from a data manipulation use of , such as rl I y, which should be performed by com-
binational logic (such as theALU) in the architecture. In the case of ( (rl>=y) I pb),
there are two reasonable ways to translate this into the mixed stage: the way that was
shown above, and the way that requires introducing an extra signal in the architecture
to represent the or of rlgey and pb. (pb would then be classified as an external data
input to the architecture, in addition to being an external status input to the controller.)
Since we would like to minimize the number of wires that interconnect the controller to
the architecture, we chose the former approach where pb is simply an external status
signal.

.
-

to Hardware Three Stages for Verilog Design 159

.



Of course, the bit patterns for controlling the ALU must be defined outside this mod- Continued
ule:

6770 rl-
1

'define DIFFERENCE 6'bO11001
'define PASSB 6'blO1010

6870 rl=

The test code is the same as the pure behavioral system. Here is the output from the 1

completed mixed stage:
6970 rl=

1
70 rl= x r2= x r3= x pb=O ready=1

1 10 0 muxbus= 0 alubus= 0
muxctrl=0 aluctrl=101010 7070 rl=z
x= 0 rlgey=x 1

170 rl= 0 r2= 0 r3= x pb=O ready=1
1 10 0 muxbus= 0 alubus= 0

muxctrl=0 aluctrl=101010 ok
x= 0 rlgey=0

270 rl= 0 r2= 0 r3= x pb=O ready=1
1 10 0 muxbus= 0 alubus= 0

muxctrl=0 aluctrl=101010
x= 0 rlgey=0 4.3 Pure

370 rl= 0 r2= 0 r3= x pb=1 ready=1
1 10 0 muxbus= 0 alubus= 0 ma(

muxctrl=0 aluctrl=101010 Translating fro
x= 0 rgey=O cal (although s

470 rl= 0 r2= 0 r3= x pb=O ready=O same. As expL
1 01 1 muxbus= 7 alubus=4089

posed of a pres
muxctrl=1 aluctrl=011001
x= 0 rlgey=0 not a reg) anc

570 r=4089 r2= 1 r3= 0 pb=O ready=1 In the "pure" s
1 10 0 muxbus= 0 alubus= 0 havioral code (

muxctrl=0 aluctrl=101010
x= 0 rlgey=1 of the mixed s

ok defined in tern
mally necessar

6570 rl= 13 r2= 0 r3= 1 pb=O ready=1 tools exist that
1 10 0 muxbus= 14 alubus= 14 in this section i

muxctrl=0 aluctrl=101010 that the design
x= 14 rlgey=1 the kind of train

6670 rl= 14 r2= 0 r3= 1 pb=1 ready=1
1 10 0 muxbus= 14 alubus= 14

muxctrl=0 aluctrl=101010
x= 14 rlgey=1

160 Verilog Digital Computer Design: Algorithms into Hardware



Fined outside this mod- ?ed

rl1= 14 r2= 0 r3= 1 pb=0 ready=0
l 1 01 1 muxbus= 7 alubus= 7

muxctrl=1 aluctrl=011001
x= 14 rgey=1

rl 7 r2= 1 r3= 0 pb=0 ready=0
1 01 1 muxbus= 7 alubus= 0

is the output from the muxctrl=1 aluctrl=011001
x= 14 rgey=1

7rl 0 r2= 2 r3= 1 pb=0 ready=0
1 01 1 muxbus= 7 alubus=4089

muxctrl=1 aluctrl=011001
Lbus= 0 x= 14 rlgey=0
ictrl=101010 7rl1=4089 r2= 3 r3= 2 pb=0 ready=1

1 10 0 muxbus= 14 alubus= 14
muxctrl=0 aluctrl=101010

ibus= 0 x= 14 rlgey=1
ictrl=101010

abus= 0
actrl=101010

Pure structural stage of the two state division
ubus= 0 machine
uctrl=101010 ing from the mixed stage to the "pure" structural stage is an easy and mechani-

cugh somewhat tedious) process. All modules except the controller remain the
s explained in section 2.4.1, the controller module becomes a structure com-

ubus=4089 Ia present state register (which is an instance of an actual register module, and
uctrl=011001 eg) and the next state logic.

)ure" structural stage, the definition of the next state logic may remain as be-
.ubus= 0 code (a function) that is a transformation of the code inside the always block
.uctrl=101010 nixed stage. In section 4.4, we will see how the next state logic could also be

in terms of built-in gates, using hierarchical design. Fortunately, it is not nor-
ecessary to worry about the details given later in section 4.4, because synthesis
st that can automatically transform the behavioral next state function described

Lubus= 14 action into a netlist. For this reason, we consider this section to be the final step
Luctrl=101010 Jesigner has to be involved with. Section 4.4 is presented later only to motivate
L of transformations that synthesis tools are capable of.

Lubus= 14
Luctrl=101010

into Hardware Three Stagesfor Verilog Design 161



4.3.1 The pure structural controller module 
The structure of the controller is quite simple. The instance name of the
nextstatelogic is nsl. As shown in the diagram in section 2.4.1, rlgey and
pb are the inputs to nsl. Also, next_state, ldrl, incr2, clrr2, ldr3,
muxctrl, aluctrl, ready and nextstate are outputs of nsl. The input to output

ps-reg is nextstate and its output is present-state. The portlist of the
controller module is identical to the mixed stage, except the outputs are declared to be input

reg ['
wires: reg lc

reg [E
wire [

module slow-div ctrl(pb,ready,aluctrl,muxctrl,ldrl, wire 
clrr2,incr2,ldr3,rlgey,sysclk);

input pb,rlgey,sysclk; inclt
output ready,aluctrl,muxctrl,ldrl,clrr2,incr2,ldr3;

always
wire ['NUMSTATEBITS-l:0] presentstate; {next
wire pb; ree
wire ready; endmodu]
wire [5:0] aluctrl;
wire muxctrl,ldrl,clrr2,incr2,ldr3;
wire rlgey,sysclk;

4.3.3 sti
nextstate-logic nl(next-state, To create the

ldrl,incr2,clrr2,ldr3,
a portion of t

muxctrl,aluctrl,ready,
presentstate, rigey, pb);

enabled-register #('KUN_STATEBITS) psreg(next-state,
present-state,l'bl,sysclk); 1. Create a

endmodule priate in
1 plus tl

For simplicity, we are using an enabled-register for psreg with its enable are the 
inputs a

tied to 1 bl. 2. The out
this exa

4.3.2 nextstatelogic module are loca
The combinational logic that computes the next state needs to be defined. Following state wil
the technique outlined in section 3.7.2.1, there is an always block with an @ sensitiv- synthesi
ity list which has all the inputs to this module. Since the calculation of the next state behavio
and corresponding outputs is quite lengthy, this calculation is isolated in a function, 3. The assi
stategen, that is defined in the file "divbookf .v": the mixi

is also g
4. The nex

present

162 Verilog Digital Computer Design: Algorithms into Hardware

M



module nextstatelogic(nextstate,
nstance name of the

ldrl,incr2,clrr2,ldr3,
ction 2.4.1, rlgey and muxctrl,aluctrl, ready,
cr2,clrr2, ldr3, presentstate, rlgey, pb);
ts of nsl. The input to output nextstate,ldrl,incr2,clrr2,ldr3,muxctrl,
Lte. The portlist of the aluctrl,ready;

itputs are declared to be input present_state, rgey, pb;
reg ['NUM_STATE_BITS-l:0] next_state;
reg ldrl,incr2,clrr2,ldr3,muxctrl,ready;
reg [5:0] aluctrl;
wire ['NUN_STATE_BITS-l:0] presentstate;

rl, ldrl,
wire rlgey,pb;

,sysclk);

'include "divbookf.v"
acr2, ldr3;

always (presentstate or rlgey or pb)
{nextstate,ldrl,clrr2,incr2,ldr3,muxctrl,aluctrl,

ready} = stategen(presentstate, pb, rgey);
endmodule

4.3.3 stategen function
To create the file that contains 

ldr3, the state gen function is a simple matter of editing
eady, a portion of the mixed code:
gey, pb);
g(next_state,
l,sysclk); I . Create a function header that returns the proper number of bits and has the appro-

priate input arguments. The number of bits to be returned is ' NUMSTATEBITS-
1 plus the number of command output bits. The input arguments of the function

psreg with its enable are the same as the input ports of nextstate-logic. (In this example, the
inputs are ps, pb and rlgey.)

2. The output regs of the mixed controller become local regs in the function. (In
this example, ldrl, incr2, clrr2, ldr3, muxctrl, aluctrl and ready
are local regs in the function.) A local ns reg isa lso defined to hold the next

to be defined. Following state within the function. Remember that local regs of a function would never be
block with an @ sensitiv- synthesized as physical registers. They are regs simply because the function uses
culation of the next state behavioral assignment.
is isolated in a function, 3. The assignment of default values that occurs in the enternewstate task of

the mixed stage becomes the first executable statement of the function. Also, ns
is also given a default value (the starting point of the algorithm).

4. The next executable statement of the function is a case statement based on the
present state, ps. This case statement is equivalent to a truth table, as explained

nto Hardware Three Stages for Verilog Design 163



in section 3.9.2.2. The advantage of the case statement for this purpose is that it
is more compact than a truth table, and it documents some of the thought process Continued
of the earlier stages through meaningful identifiers (such as aluctrl).

5. The statements that follow each @( posedge sysclk) inside the always
block of the mixed controller are moved to a place within the case statement that
corresponds to that state. The @ and the call to enternewstate are elimi-
nated. The commented-out non-blocking assignment statements are retained for
documentation.

6. In each block of code that corresponds to a state, ns is computed. This computa-
tion, in effect, acts like a goto. It says which state in the case statement will
execute when this function is called during the next clock cycle (after ns be-
comes ps). Unlike the mixed stage, the order in which the designer types the
states into the case statement has no effect on the order in which the states ex-
ecute. The ns computation determines the order in which they execute. By put-
ting the ASM into a function, we have lost the perfect correspondence to the goto-
less style that we had in the mixed stage.

7. The next state and the outputs are concatenated to be returned from this function
in the order needed (see section 4.3.2).

Here is the state-gen function for the two-state division machine:

function 'NUNSTATE_BITS-1+12:0] en
stategen; St

input [NUM STATEBITS-1:O ps;
input pb,rlgey; end
reg ready; endfun
reg [5:0] aluctrl;
reg muxctrl,1drl,clrr2,incr2,ldr3;
reg ['INUSTATE-BITS-1:0 ns; Here boldface

begin
{nsready,aluctrl,muxctrl,ldrl,clrr2,incr2,ldr3}=0; 4.3.4 Test
case (ps) Since state

'IDLE: begin some trivial V
//rl <= (posedge sysclk) x;
//r2 <= (posedge sysclk) 0;
ready = 1; 'defineI
aluctr = 'PASSB; 'define
muxctrl = 0;
ldrl =1; 'define I

if if(rprb2) 'd1f;n 'define

- j-WWYjW"j

module t(

164 Verilog Digital Computer Design: Algorithms into Hardware



,or this purpose is that it
Continued

e of the thought process
as aluctrl). ns = 'COMPUTE;
k) inside the always else
the case statement that n = 'IDLE;
newstate are elimi- else
tements are retained for ns = 'IDLE;

end

)mputed. This computa- 'COMPUTE: begin
ready = 0;

he case statement will
//rl <= @(posedgie sysclk) rl - y;

ock cycle (after ns be- //r2 <= @(posedg e sysclk) r2 + 1;
it he designer types the //r3 <= @(posedg e sysclk) r2;
r in which the states ex- aluctrl = 'DIFFE] RENCE;
zh they execute. By put- muxctrl = 1;
-spondence to the goto- ldrl = 1;

incr2 = 1;

umed from this function ldr3 = 1;
if (rlgeylpb)

ns = 'COMPUTE;
else

nachine: ns = 'IDLE;
end

endcase
state-gen = ns,ldrl,clrr2,incr2,ldr3,

muxctrl,aluctrl,ready);
end

endfunction

Here boldface shows some changes that were made to make this work as a function.

incr2,ldr31=0; 4.3.4 Testing stategen
Since state gen is isolated in a file by itself, we can test state-gen by writing
some trivial Verilog, unrelated to any of the earlier code:

-1k) x;
Ilk) 0;

'define DIFFERENCE 6'bO11001
'define PASSB 6'blO1010

'define NUMSTATEBITS 1
'define IDLE 1'bO
'define COMPUTE l'bl

module test;

Wnto Hardware Three Stages for Verilog Design 165



Continued. 4.4 Hiej
'include "divbookf.v" Except for on

in section 4.3
be used to fab

integer i; not need to i
reg ps,pb,rlgey; creating the n

On the other I
initial so simple, it r
begin looking at the

for (i=O;i<=7;i=i+l) This problem,
begin was previous!

{ps,pb,rlgey} = i; all the physic
$display("%b %b %b %b",ps,pb,rlgey,

stategen(ps,pb,rlgey)); details until th
end to gates!

end This section il
endmodule

three-stages o
pects that are 

This produces an output which agrees with the manual derivation given in section circuit will do
2.4.1. The bit patterns used in the function must be defined, as shown above, because the netlist for
they are not defined in Admiv bookf . v AK most machine

designer.

4.3.5 It seems to work
Having tested the function to see that it behaves as expected, we can now put the 4.4.1 A o,
controller code from sections 4.3.1 through 4.3.3 together with the architecture code The state c
from section 4.2.3 to obtain the pure structural version of the two-state division ma- equations repr
chine. The simulation of this produces the same output as that of the mixed stage,
shown in section 4.2.4.

module nE
There is one additional detail, described in the next section, that we will want to con-
sider in all future designs. Since the code (including this additional detail) that the
designer develops in the pure structural stage can be run through a synthesis tool, it is
not necessary for the designer to manually transform Verilog code after reaching the output
pure structural stage. In the next section, we will see how the synthesis tool continues
to transform the Verilog code for the designer automatically. input 

reg ['5
reg ldi
reg [5:
wire ['
wire ri

always

166 Verilog Digital Computer Design: Algorithms into Hardware



4.4 Hierarchical refinement of the controller
Except for one small physical problem to be explained in this section, the Verilog code
in section 4.3 can be submitted to a synthesis tool, which produces the netlist that can
be used to fabricate the chip. Assuming we recognize and fix this little problem, we do
not need to write any more Verilog. The synthesis tool can do the rest of the job of
creating the netlist.

On the other hand, since the two-state division machine, with its childish algorithm, is
so simple, it makes a good example to illustrate what a synthesis tool does. Also, by
looking at the netlist, we will discover this small physical problem alluded to earlier.
This problem, which occurs with most controllers, has a simple solution; however, it
was previously hidden from view because behavioral Verilog usually does not model
all the physical details of a circuit. The power of top-down design is to hide those
details until the last moment. We have reached this moment of truth when we get down
to gates!

This section illustrates the need to do post-synthesis simulation prior to fabrication. All
three-stages of design (including the pure structural stage) have some behavioral as-
pects that are well above the gate level. To predict more accurately what the fabricated

ivation given in section circuit will do, we need to simulate the synthesized netlist. With this simple machine,
.s shown above, because the netlist for the controller is simple enough that we can generate it manually, but in

most machines, an automatically produced netlist would be incomprehensible to the
designer.

dw, e can now put the 4.4.1 A logic equation approach
ith the architecture code The s tategen function defined in section 4.3.3 can be replaced by a series of logic
e two-state division ma- equations representing the low-level behavior of ns 1, as explained in section 2.5:
that of the mixed stage,

module nextstatelogic(nextstate,
hat we will want to con- ldrl,incr2,clrr2,ldr3,
Mditional detail) that the muxctrl,aluctrl, ready,
ugh a synthesis tool, it is presentstate, rgey, pb);

code after reaching the output nextstate,ldri,incr2,clrr2,ldr3,muxctrl,

synthesis tool continues aluctrl,ready;
input present_state, rgey, pb;
reg ['NUN_STATE_BITS-l:0] nextstate;
reg ldrl,incr2,clrr2,ldr3,muxctrl,ready;
reg [5:0] aluctrl;
wire ['NUNSTATE_BITS-1:0] present-state;
wire rlgey,pb;

always (present state or rlgey or pb)

ito Hardware Three Stages for Verilog Design 167



11=

Continued It was popula
begin cause there is
nextstate = reason, a synl
-presentstate&pblpresent-state&(rlgeylpb); space of pos&
ldrl = 1; tion. When th
clrr2 = -present state; for it to prodt
incr2 = present state; last gotten all
ldr3 = present state;
muxctrl = present state; module n
aluctrl[5] = -present state;
aluctrl[41 = present state;
aluctrl[3] = 1;
aluctrl[21 = 0; output
aluctrl[l] = -present state;
aluctrl[O] = present state; input
ready = -present_state; wire [

end wire 1
endmodule wire [

wire [
wire r

Even though this is a rather tedious way to describe the controller, it is still a behavioral
description as explained in section 3.7.2.1. This module has an always block with @ buf bO
followed by a sensitivity list naming all the inputs to the combinational logic, and the buf bl

outputs are defined as regs. Although using logic equations in this fashion is perfectly buf b2

legal, this is not the preferred style of Verilog coding for three reasons: it is not a
netlist, a designer can easily make a mistake not 

when il
deriving the logic equations manu-

ally, and even if the logic equations are correct, they are usually meaningless to the and al
designer. One reason why we practice top-down and hierarchical design is to minimize and a2
our exposure to details, especially details as tedious as a page full of logic equations. or 01

Algorithms to manipulate Boolean or o2
equations are some of the most studied aspects of endmodul

computer design. Even prior to the introduction of Verilog, software existed to auto-
matically produce logic equations from truth tables. It would be a giant leap backward
to use Verilog with manually produced logic equations. We will not consider writing Figure 4-2 sh
modules of this style again.

Of course, ,

4.4.2 At last: a netlist built-in Verila
to all the othe

Even though logic equations should not normally be your first choice when designing that the latter
behavioral code, it is important for you to be aware of the properties of Boolean alge-
bra. Ultimately, at the lowest levels, all computation carried out on digital computers We will ignor
are the result of iterative application of Boolean equations. this is a trivia]

the controller

168 Verilog Digital Computer Design: Algorithms into Hardware



;It was popular to use logic equations manually before the introduction of HDLs be-
cause there is a one-to-one mapping between logic equations and a netlist. For the same
reason, a synthesis tool internally manipulates logic equations as it explores the vast
space of possible hardware structures that correctly implement a combinational func-

Iylpb);
tion. When the synthesis tool decides what the optimum logic equation is, it is trivial
for it to produce the netlist. Using the logic equations from section 4.4.1, we have at
last gotten all the way down to the netlist:

module nextstate logic(next state,
ldri,incr2,clrr2,ldr3,
muxctrl,aluctrl, ready,
present_state, rlgey, pb);

output next-state,ldri,incr2,clrr2,ldr3,muxctrl,
aluctrl,ready;

input present_state, rlgey, pb;
wire ['NUM_STATE_BITS-1:0] nextstate;
wire ldrl,incr2,clrr2,ldr3,muxctrl,ready;
wire [5:0] aluctrl;
wire ['NUN_STATE_BITS-l:0] presentstate;
wire rlgey,pb;

ler, it is still a behavioral
i always block with @ buf bO(ldrl,aluctrl[3J,1'bl);

binational logic, and the buf bl(aluctrl[2J,1'bO);
buf b2(incr2,ldr3,muxctrl,aluctrl[4],aluctrl[0],

i this fashion is perfectly presentstate[OJ);
tree reasons: it is not a not il(not ps,clrr2,aluctrl[5],aluctrl[1],ready,
ie logic equations manu- presentstate[O]);
aally meaningless to the and a1(not_ps_and pb,not ps,pb);
cal design is to minimize and a2(psandor,present_state[O],rlgeyorpb);

full of logic equations. or o1(rlgeyor pb,rlgey,pb);
or o2(nextstate(O],not psand_pb,psand or);

,m ost studied aspects of endmodule
software existed to auto-
be a giant leap backward
will not consider writing Figure 4-2 shows the corresponding circuit diagram.

Of course, many other possible solutions exist that produce the same truth table. The
built-in Verilog gate bu f (non-inverting buffer) passes through its last port unchanged
to all the other ports, which are outputs. The only difference between buf and not is

st choice when designing that the latter inverts its outputs.
Dperties of Boolean alge-
out on digital computers We will ignore discussing the netlist for the architectural devices, such as mux2, since

this is a trivial but tedious task. The synthesis tool would do this identically to the way
the controller was synthesized.

nto Hardware Three Stages for Verilog Design 169



1 Idr1
aluctrl [3]

0 b- aluctrl [2] 17

present-state [0] incr2
27

Idr3
muxctrl
aluctrl [4]
aluctrl [0]

cIrr2
that continues I

aluctrl [5] physical problf
aluctrl [1] gate level netlis

and 1 bzs.
ready

Although you 
tion 4.4.1) or I
equations and 

pb - -
To understand
valued logic sy;
0, this is an in
errors can caus
Since everythir

Figure 4-2. Netlist for the childish division controller. the 1 bxs and

At $time 0, a]

4.4.3 Post-synthesis not 
simulation change thes

an internal reg
Even though up to this point all the simulation results indicate that our synthesized the machine co
division machine should work, it is wise to conduct post-synthesis simulation prior to usually ' bx. I
fabricating the hardware. This is why Verilog was developed in the first place: to simu- sequence of stE
late gate level netlists. Synthesis from behavioral code is now the predominate use of flaw in the desij
Verilog, but synthesis tools appeared later in the history of Verilog than simulators for predict what ha
netlists.

Why didn't the
So let's use Verilog in the way it was originally intended to be used and simulate the reason is found
netlist given in section 4.4.2. When this simulation runs, we get a very interesting but this function ini
discouraging output:

170 Verilog DigitalC omputer Design:A lgorithms into Hardware



70 rl=x r2=x r3=x pb=O ready=x
1 xz z muxbus=x alubus=x

muxctrl=z aluctrl=xzlOxz
x= 0 rlgey=x

170 rl=x r2=x r3=x pb=O ready=x
1 xz z muxbus=x alubus=x

muxctrl=z aluctrl=xzlOxz
x= 0 rlgey=x

270 rl=x r2=x r3=x pb=O ready=x
1 xz z muxbus=x alubus=x

muxctrl=z aluctrl=xzlOxz
x= 0 rlgey=x

that continues like this for as long as you are willing to let the simulator run. This is the
physical problem alluded to earlier: as the controller is currently interconnected, the
gate level netlist does not seem to work. The simulator's output is splattered with 1 bxs
and 1 bzs.

Although you might think something is wrong with the logic equations (given in sec-
tion 4.4.1) or the equivalent netlist (given in section 4.4.2), there is not. The logic
equations and equivalent netlist are correct. What's the problem?

-onextstate [0] To understand the problem, you need to remember the intent behind having the four-
valued logic system. When 1 bxs or 1 ' bzs appear where you were expecting a 1 or a
0, this is an indication of some flaw in the design. Although major interconnection
errors can cause this (see section 3.5.3), more subtle problems can cause this as well.
Since everything is interconnected properly in this netlist, we need to understand what
the 1 bxs and 1 bzs are trying to tell us here.

At $time 0, all regs start as bxs and all wires start as bzs. If the simulation does
not change these values, that is how they will stay. The ps_ reg of the controller has
an internal reg that holds the present state. At $ time 0, it is 1 bx. The next state that

ite that our synthesized the machine computes from psreg is also unknown. A Boolean function of ' bx is
iesis simulation prior to usually ' bx. Therefore, the ps reg is reloaded with 1 bx, rather than the proper
the first place: to simu- sequence of states. The four-valued logic of the simulation has detected a potential
the predominate use of flaw in the design: we do not know what state the controller starts out in, so we cannot

rilog than simulators for predict what happens next.

Why didn't the pure structural version (see section 4.3.3) detect this problem? The
e reason is found in the definition of the stategen function. The first statement of
et  uas evder ya nidn tseirmeustliantge  bthuet this function initializes ns (which is what becomes next_state) to be 1 bO:

Three Stages for Verilog Design 171
to Hardware



{nsready,aluctrl,muxctrlldrl,clrr2,incr2,ldr3>=O; position withii
case (s) so they start at

pure structural
endcase

the problem. A

Unfortunately, this If you 
also are 

means at all
that even though ps is 'bx at $ time 0, ns will be-

come 0 after time ago. 
the first We r

rising edge. This is a disguised way of saying: $time 0, and
type resettable

{ready,aluctrl,muxctrl,ldrl,clrr2,incr2,ldr3}=O;
if (ps === l'bx I Ps === l'bz)
ns = l'bO; module rE

else paramet
case (s) input 

output

endcase wire ['
reg [S]
wire r(

The reason this is cheating is because hardware cannot implement the === operation.
Each physical wire can only carry one bit of information. Each simulated wire tested always
with === carries two bits of information (to represent 0, 1, 1 bx and 1 bz). At $time begii
0, all regs are intialiazed to bx. As soon as the above function detects bx, if

it turns
it into 0. In this indirect way, the function is informed when $time is 0. The fabri- el!
cated hardware has no way to know when $ time is 0, because a wire is simply either

or 1. end
We can make the pure structural stage act more like the netlist by omitting endmodul

ns from the
default initialization:

The above is 
is typical with

{ready,aluctrl,muxctrl,ldrl,clrr2,incr2,ldr3l=O;
case (ps) This is the firs

... sign. Asynchn
the rising edg(
synchronous<

By omitting ns here, the simulation using stategen fails similarly to the netlist. the reset sil
zero at some p
the next rising
register is con

4.4.4 Resetting the present state even should a
What post-synthesis simulation discovered is a problem that all state machines exhibit, ter would be a
and that happily has a simple solution. When the power is first turned on, we do not
know what state the machine will be in. The pure behavioral and mixed stages use

172 Verilog Digital Computer Design: Algorithms into Hardware



ncr2,ldr3l=O; position within behavioral code (rather than the psreg) to indicate the current state,
so they start at the top of the code at $ t ime 0. As explained above, the way we did the
pure structural stage (with the stategen function) tricked Verilog into disguising
the problem. At the netlist level, the problem cannot be hidden any longer.

If you are at all familiar with state machines, you probably spotted this problem a long
$time 0, ns will be- time ago. We need an asynchronous reset for the ps-reg that is activated soon after

ying: $t ime 0, and left inactive thereafter. Here is a behavioral model of such a simple D-
type resettable register:

2,ldr3}=0;

module resetableregister(di,do,reset,sysclk);
parameter SIZE=l;
input di,reset,sysclk;
output do;
wire [SIZE-1:0] di;
reg [SIZE-l:0] do;
wire reset,sysclk;

ient the === operation.
h simulated wire tested always (posedge sysclk or posedge reset)

and l bz).At $time begin

on detects bx, it turns if (reset)
do = 0;

;time is 0. The fabri- else
a wire is simply either do = di;

end

iy endmodule
omitting ns from the

The above is patterned after the 74xx 175 (six-bit resettable D-type register), except as
is typical with TTL logic, the reset signal on the 74xx175 is active low.

2,l dr3}=0;
This is the first and only time that we will admit an asynchronous signal into our de-
sign. Asynchronous means that a change happens in a register at a $time other than
the rising edge of sys cl k. Notice the difference between the cl r signal used in the
synchronous counterregister (described in sections 3.7.2.2 and 4.2.1.2) and

similarly to the netlist. the reset signal described here. Although both signals cause the register to become
zero at some point in $ t ime, the c r signal simply schedules the change to happen at
the next rising edge, but the reset signal causes the clearing to happen instantly. The
register is continually rezeroed for as long as reset is asserted because of the if,
even should a rising edge of the clock occur. Without the posedge reset, the regis-

state machines exhibit, ter would be a synchronous, clearable D-type register.
st turned on, we do not
1 and mixed stages use

o Hardware Three Stagesf or Verilog Design 173



The psreg needs to have an asynchronous reset so that it is zero 
of prior 

the to 
first the 

rising arrival
edge of sysclk. The reset signal must Continue

be provided 
user, by 

which our friendly
means for the Verilog simulation that reset becomes 

modules a port of 
and several

must be provided by the test sl
code. It is a input port of the controller:

endm
I

module slowdiv-ctrl(b.readv I
I,..,-

clrr2,incr2,ldr3,rlgey,reset,sysclk); It must a
input pb,rlgey,sysclk,reset;
output ready,aluctrlmuxctrlldrl,clrr2,incr2,ldr3;

modu:
wire ['NUM STATEBITS-1:0] presentstate; re(
wire pb;

re(
wire ready;
wire [5:0] aluctrl;
wire wil

muxctrl,ldrl,clrr2,incr2,ldr3;
wi]

wire rlgey,sysclk,reset;

int
nextstatelogic nsl(nextstate,

Wi2
ldrl,incr2,clrr2,ldr3, res
muxctrl,aluctrl,ready,
presentstate, rgey, pb); cl

rA.*tWmh1 - s ... .( 'UMSTATE-BITS) preg(nextstate, slC
present-state,reset,sysclk); slow_

endinodul e

ini
and of the system that instantiates the controller: c

I - -
module slow div-system(pb,readyxyr3,resetsysclk);

input pb,x,y,sysclkreset;
output ready,r3;
wire pb;
wire [11:0] x,y;
wire ready;

endmo
wire [11:0] r3;
wire sysclk,reset;

The test c
wire [5:0] aluctrl; present s,
wire muxctrl,ldrl,clrr2,incr2,ldr3,rlgey; simulated
slow mixed 

div-arch stall
a(aluctrl,muxctrl,ldrl,clrr2,

I incr2,ldr3,rlgey,x,y,r3,sysclk);

174 VWr.gil:Ln o lwiotA -. _ r . t w
.-- -C, -6.- -- my"tuf L"esign: AtgOritnMS into Hardware



zero prior to the arrival Continued
rovided by our friendly
omes a port of several v_ctrl c(pb,ready,aluctrl,muxctrl,ldrl,
rt of the controller: clrr2,incr2,ldr3,rlgey,reset,sysclk);

1,1 drl, pear in the test code:
ysclk);

cr2, ldr3;
op;

1:0] xy;

1:0] quotient;
!ady;

s;
ysclk;

Ir3, set;
ady,
ey, pb); 000 clock(sysclk);

ig(nextstate, .v_system

t,sysclk); _machine(pb,ready,x,y,quotient,reset,sysclk);

O;
0;
7;

,sysclk); let 0;
I reset = 1;
I reset = 0;
.0;

issues a reset pulse that lasts for 30 units of $time, which causes the
: become zero. When the netlist for the controller (section 4.4.2) is re-
h the above, it produces the same correct answers we obtained for the

, Hardware Three Stagesf or Verilog Design 175



4.5 Conclusion
The three stages of top-down design can be expressed in Verilog. The pure behavioral 5.
stage requires writing a single system module to model the machine. The only structure
at this stage is the portlist of the module. During this stage, the designer also develops
test code that instantiates the pure behavioral module. The test code is important be-
cause it is a specification of what the machine is supposed to do. By translating the
ASM that describes the machine with the enternewstate Although the

approach, the pure
behavioral Verilog is organized so that it will be easy notation 

to translate give
to the mixed stage. ware solution

In the mixed stage, the designer develops structural Verilog code for the architecture. (number of 
The modules instantiated inside the architecture may themselves be defined behavior- should be the
ally. The architecture and a controller are instantiated as the system module. The con- signer is prod
troller is behavioral code derived from the pure behavioral stage. The <= statements before one pr
are commented out and replaced with appropriate command signals for the chosen version of the
architecture, and relational conditions are replaced with appropriate status signals. The
default values for the command signals are indicated Despite 

in the the 
enternew fi

state task. solution dems
In the pure structural stage, the controller is edited to become a structural module that example, the (
instantiates a next state generator and a resettable register. The test code and portlists result in a tin
must be edited to include a reset signal. The next state generator has an always context, a mac
block modeling combinational logic which calls a function defined with a case state-
ment. The cases in this statement are copied from Our 

the search 
mixed fc

controller code. Additional
statements must be provided in each state to describe rithms, 

the and 
calculation nc

of the next state.
Default values are indicated prior to the case statement. not to do some

that solves th
The next state logic and all of the architectural building blocks of the pure structural variations on 
stage could be refined down to the gate level by using hierarchical design. However, the slowest so
synthesis tools can take a pure structural description (with all of its instantiated mod- with the notat
ules still defined behaviorally) and produce a gate-level netlist. In most cases, the pure ASM feature
structural stage is equivalent to working hardware. It is important to do post-synthesis plains how an
simulation before fabrication to insure the netlist solves the problem correctly because as well as thow
it is cheaper to find flaws before fabrication. adhered to in,

4.6 Exercises 5.1 Mo(
4-1. Use a simulator to take problems 2-1, 2-2 and 2-3 through the three-stages in Recall that an
Verilog. arrows. Chapt
4-2. Use a simulator to take problems 2-4, 2-5 referred 

and 2-6 to as 
through the three stages in

Verilog. machines. AS
ASM charts p

4-3. Use a simulator to take problems 2-7, 2-8 and 2-9 through the three-stages in less costly) th
Verilog.

176 Verilog Digital Computer Design: Algorithms into Hardware



og. The pure behavioral 5. ADVANCED ASM
,hine. The only structure
designer also develops

st code is important be- TECHNIQUES
)do. By translating the Although the ASM techniques illustrated in chapter 2 and the corresponding Verilog
ate approach, the pure notation given in chapter 4 are adequate to solve any problem, they may yield a hard-
late to the mixed stage. ware solution that is not optimal in terms of speed (number of clock cycles) and cost
ode for the architecture. (number of gates.) Despite all the marketing hype one hears, neither speed nor cost
ies be defined behavior- should be the primary concern of the designer. The primary responsibility of the de-
ystem module. The con- signer is producing a correct design. (Intel Corporation illustrated the wisdom that
age. The <= statements before one produces a fast chip one ought to design a correct chip when they sold a
I signals for the chosen version of the Pentium in 1994 whose division algorithm was incorrect.)
)riate status signals. The Despite the fact speed should not be our first concern, in many problems a correct
-ernew state task. solution demands that an algorithm find its answer by a certain time. Consider, for
a structural module that example, the onboard computers of the space shuttle. They need to compute the correct
e test code and portlists result in a timely enough fashion that the shuttle may correct its course. In such a
aerator has an always context, a machine that c omputes a correct answer too late is not a solution at all.
ined with a case state- Our search for a faster solution should always begin in the abstract world of algo-
itroller code. Additional rithms, and not in the gruesome world of gates. The best way to speed up a machine 
elation is

of the next state. not to do some trickery with gates; instead the best way is to describe a better algorithm
that solves the same problem. Chapter 2 illustrates this point with several different

cs of the pure structural variations on the division machine with the final solution being three times faster than
,hical design. However, the slowest solution. One difficulty is that certain faster algorithms cannot be expressed
of its instantiated mod- with the notations discussed in chapters 2 and 4. This chapter discusses an additional
In most cases, the pure ASM feature that helps us describe more efficient algorithms. Also, this chapter ex-
ant to do post-synthesis plains how any ASM can be written in Verilog, including those that use such notations,
blem correctly because as well as those that have complex branches that do not follow the goto-less style we

adhered to in earlier examples.

5.1 Moore versus Mealy
ugh the three-stages in Recall that an ASM chart is composed of diamonds, rectangles and ovals connected by

arrows. Chapter 2 ignored the use of ovals. Such ASM charts that do not have ovals are
referred to as Moore machines. All the ASM charts discussed previously were for Moore

ugh the three stages in machines. ASM charts that also include ovals are known as Mealy machines. Mealy
ASM charts provide a way to express algorithms that are faster (and in some instances

ugh the three-stages in less costly) than Moore ASM charts.

o Hardware Advanced ASM Techniques 177



Commands (both RTN and signal names) that occur inside a rectangle are known as Assuming, as
unconditional commands, because the commands are issued regardless of anything clock is 0.5 se
when the machine is in the state corresponding to the rectangle. Ovals are used to the hardware
describe conditional commands, that are sometimes (but not always) issued when a
machine is in a particular state. Ovals are not by themselves a state, but rather they are present
the children of some parent state that corresponds to a rectangle in the ASM chart. time St
Because ovals represent a conditional command, they must occur after one or more 0.0 GF
diamond(s). If you follow the arrows of a Mealy ASM, you would first come to a 0.5 YE
rectangle, then you would come to one or more diamond(s) and finally you would 1.0 RE
come to the oval. After the oval, the arrow might go to another diamond or a rectangle. 1.5 GF

2.0 YE
The actions in one rectangle and all ovals and diamonds that are connected (without 2.5 YE
any intervening rectangles) to that one rectangle occur in the same clock cycle. In 3.0 YE
essence, a combination of diamonds and ovals allows the designer to implement an 3.5 YE

arbitrarily nested i f e l s e construct that executes in 4.0 
a single YE

clock cycle. Large num-
bers of decisions 4.5 

can YE
be carried out in parallel by such ASM charts, allowing some 5.0 RE

algorithms to be sped up considerably. 5.5 GE
6.0 YE

5.1.1 . . ...

Silly example of behavioral Mealy machine
Suppose we take the silly ASM of section 2.1.2.1 and include two conditional com-
mand signals: Between 

STAY 0.5,
and LEAVE. STAY is supposed to be 1 while the machine stays in

state YELLOW, the 
and decision 

LEAVE d
is 1 during the last cycle that the machine is in state

YELLOW. STAY on the 
and path 

LEAVE s
are never asserted at the same time. Here is the ASM

chart: LEAVE signa
the unconditi
which is on a

GREEN
Between 2.0 
non-zero, the

YELLOW is the oval tha
cycle.

Because COL
the last clock
not asserted b

5.1.2 Sill,
An architectu:
attached to ai
comparator tc
sponding mix

Figure 5-1. Behavioral Mealy ASM.

178 Verilog Digital Computer Design: Algorithms into Hardware



rectangle are known as Assuming, as was the case for the example in section 2.1.2.1, that the period of the
regardless of anything clock is 0.5 seconds, the following illustrates what would be observed physically when

igle. Ovals are used to the hardware corresponding to this ASM operates:
always) issued when a
state, but rather they are present
ngle in the ASM chart. time state
ccur after one or more 0.0 GREEN stop=0 speed=11 count=000 stay=0 leave=0
would first come to a 0.5 YELLOW stop=1 speed=01 count=000 stay=0 leave=1
and finally you would 1.0 RED stop=1 speed=00 count=001 stay=O leave=0

diamond or a rectangle. 1.5 GREEN stop=0 speed=11 count=011 stay=0 leave=0
2.0 YELLOW stop=1 speed=01 count=011 stay=1 leave=0

are connected (without 2.5 YELLOW stop=1 speed=01 count=100 stay=1 leave=0
e same clock cycle. In 3.0 YELLOW stop=1 speed=01 count=101 stay=1 leave=0

signer to implement an 3.5 YELLOW stop=1 speed=01 count=110 stay=1 leave=0
4.0 YELLOW stop=1 speed=01 

lock count=111 
cycle. Large num- stay=1 leave=0

4.5 YELLOW stop=1 speed=01 count=000 stay=0 leave=1
:charts, allowing some 5.0 RED stop=1 speed=00 count=001 stay=0 leave=0

5.5 GREEN stop=0 speed=11 count=011 stay=O leave=0
6.0 YELLOW stop=1 speed=01 count=011 stay=1 leave=0

te
two conditional corn- Between 0.5 and 1.0, the machine is in state YELLOW, but because COUNT is zero,

tile the machine stays in the decision does not go on the path that loops back to state YELLOW but instead goes
the machine is in state on the path where the next state is state RED. On this path is an oval that asserts the
time. Here is the ASM LEAVE signal. This conditional signal is asserted during the entire clock cycle, just as

the unconditional signal STOP is asserted during the same time. The signal STAY,
which is on a different path, is not asserted during this clock cycle.
Between 2.0 and 2.5, the machine again is in state YELLOW, but because COUNT is
non-zero, the decision goes on the path that loops back to the same state. On this path
is the oval that asserts the STAY signal. The signal LEAVE is not asserted in this clock
cycle.

Because COUNT is three bits, COUNT is zero again between 4.5 and 5.0, and so this is
the last clock cycle that the machine loops in state YELLOW. This means that STAY is
not asserted but that LEAVE is asserted.

5.1.2 Silly example of mixed Mealy machine
An architecture that implements the silly example of section 5.1.1 is a counter register
attached to an adder. One input of the adder is tied to the constant two. There is a
comparator to see when COUNT is equal to zero. Here are the architecture and corre-
sponding mixed ASM:

9 Hardware Advanced ASM Techniques 179



-

A Mealy mac
LD INC function of bi

table of the nc
3 COUNT > ± 3 CMP and architects

2 / > -+~COUNTEQ0
> ~33

Ps co
00
01
01
10

SPEED, STO
only. LEAVE
signals LEAV

5.2 Mea
Section 2.2 gin
algorithm. Th
ovals in the A'

5.2.1 Elin
Section 2.2.3 

Fig 5-2. Mixed Mealy ASM. only two regis
cessful attemp
section 2.2.5 t(
2.2.4.

5.1.3 Silly example of structural Mealy machine
The generic diagram of the pure structural controller The 

given problem 
in section i

2.4.1 applies to
any machine, whether it is a Mealy or Moore machine. The tional 

next commar
state combinational

logic will be a little different when the machine is INIT 
a Mealy without 

machine than when it is a
Moore machine. With a Moore machine, only the state 

next IDLE 
state bits for

(and not the command
bits) are a function of both the present state and the status computing 

inputs. With the
a Moore ma-

chine, the commands are a function of the present a 
state transition 

only. In fro
other words, for a

Moore machine, every line of the truth table where ps is the Here 
same is the 

has AS
the same com-

mand outputs.

180 Verilog Digital Computer Design: Algorithms into Hardware



,Mealy machine is completely general. The commands as well as the next state are a
inction of both the present state and the status. To illustrate this, consider the truth
ble of the next state combinational logic for the machine described by the ASM chart
id architecture of section 5.1.2:

COUNTEQO

ps COUNTEQO ns STOP SPEED LEAVE STAY INC LD
00 - 01 0 11 0 0 0 0
01 0 10 1 01 1 0 1 0
01 1 01 1 01 0 1 1 0
10 - 00 1 00 0 0 0 1

PEED, STOP, INC and LD are unconditional commands that are a function of ps
ily. LEAVE and STAY are a function of both ps and COUNTEQO. The conditional
gnals LEAVE and STAY are the only things here that make this a Mealy machine.

.2 Mealy version of the division machine
action 2.2 gives many variations of Moore ASMs that implement the childish division
gorithm. This section describes how this algorithm can be improved by including
Wals in the ASM.

.2.1 Eliminating state INIT again
action 2.2.3 describes a correct four-state version of the division machine that uses
nly two registers (rl and r2) in the architecture. Section 2.2.4 describes an unsuc-
essful attempt to remove state INIT from this ASM. Register r3 was introduced in
ction 2.2.5 to compensate for the user interface bug that exists in the ASM of section
2.4.

ie
'e problem 

section in section 
2.4.1 applies 2.2.4 is 

to that the assignment to r2 was written as an uncondi-
)nal command 

ext state combinational in state IDLE. By using a Mealy ASM, it is possible to eliminate state
TIT without 

ichine destroying 
than when it the 

is contents 
a of register r2 when the machine is waiting in

ate 
(and IDLE 

not for 
the pb 

command to be pressed. Only when the machine is leaving state IDLE to begin
imputing the quotient 

uts. With does 
a r2 

Moore get cleared. 
ma- In other words, when the machine makes

:ransition from state IDLE to state COMPUTEI is the time when r2 
r. In other words, for a becomes zero.
ame has -re is 

the the 
same ASM:

corn-

o Hardware Advanced ASM Techniques 181



5.2.2 Merg
The above ASN
2. To achieve d
thing we did in
the following it

IDLE

Figure 5-3. Mealy division machine with two states in loop.

Here is an example that shows the machine works when x=14 and y=7 :
Figure 5-4.

IDLE rl= ? r2= ? pb=O ready=1
IDLE rl= ? r2= ? pb=O ready=1 To illustrate ho
IDLE rl= 14 r2= ? pb=1 ready=1
COMPUTE1 rl= 14 r2= 0 pb=O ready=O
COMPUTE2 rl= IDLE

7 r2= 0 pb=0 ready=O
COMPUTE1 rl= IDLE

7 r2= 1 pb=0 ready=O
COMPUTE2 rl= IDLE

0 r2= 1 pb=0 ready=O
IDLE rl= 0 COMPUTE

r2= 2 pb=0 ready=1
IDLE rl= ? r2= COMPUTE

2 pb=O ready=1
COMPUTE
IDLE

The highlighted line shows where the conditional command to clear r2 occurs. This IDLE

takes effect at the next rising edge of the clock, which is when the machine enters state
COMPUTE1 (r2 = 0 on the next line is also highlighted to illustrate this).

By the point w
Based on the assumptions used throughout all of the chapter 2 examples, the above time too many.
ASM executes in 2+2 *quotient clock cycles, which is one clock cycle faster than save the correc
the correct ASM of section 2.2.3. tion here, it wo
182 Verilog Digital Computer Design: Algorithms into Hardware



5.2.2 Merging states COMPUTE1 and COMPUTE2
The above ASM requires about twice as long as the best solution discussed in chapter
2. To achieve the same kind of speed up with the Mealy ASM, we need to do the same
thing we did in chapter 2: the operations in the loop need to occur in parallel. Consider
the following incorrect ASM:

and y7:

Figure 5-4. Incorrect Mealy division ASM.
ready=1
ready=1 illustrate how this ASM fails, consider when 
ready=. x=14, and y=7:
ready=0
ready=O IDLE rl= r2= ? pb=0 ready=1
ready=O IDLE rl= r2= ? pb=0 ready=1

ready=O IDLE rl= 14 r2= ? pb=1 ready=1 I'
ready=1 COMPUTE12 rl= 14 r2= 0 pb=0 ready=0

COMPUTE12 rl= 7 r2= 1 pb=0 ready=0
COMPUTE12 rl=

0 r2= 2 pb=0 ready=0
IDLE rl= 4089 r2= 3 pb=0 ready=1

clear r2 occurs. This IDLE rl= r2= 3 pb=0 ready=1
machine enters state

rate this).
By the point when the machine returns to state IDLE, r2 has been incremented 

examples, one
the above time too many. In section 2.2.5, this problem was solved by using the r3 register 

lock to
cycle faster than save the correct quotient. However, since we are striving for a faster and cheaper solu-

tion here, it would be better to avoid introducing the r3 register in this design.
Hardware

Advanced ASM Techniques 183



5.2.3 Conditionally loading r2 5.2.4 Ass
To solve the bug illustrated in section 5.2.2, we need to load r2 only when the machine The reason tl
stays in the loop, and to keep the old value of r2 when the machine leaves the loop to machine in 2
return to state IDLE. This of course requires another oval in the ASM: cycles while t

ing READY 
be possible to
ing READY
COMPUTE ii
so r2 is not s
state the macd
pb can be pre

The following
state COMPU
bottom of the
loop. When th
machine will I

IDLEE

0

Figure 5-5. Mealy division ASM with conditional load.

To illustrate that this ASM works correctly, consider the case we looked at in the last
section:

IDLE rl= ? r2= ? pb=0 ready=1
IDLE rl= 13 r2= ? pb=0 ready=1
IDLE rl= 14 r2= ? pb=1 ready=1
COMPUTE rl= 14 r2= 0 pb=0 ready=0
COMPUTE rl= 7 r2= 1 pb=0 ready=0
COMPUTE rl= 0 r2= 2 pb=0 ready=0
IDLE rl= 4089 r2= 2 pb=0 ready=1
IDLE rl= ? r2= 2 pb=0 ready=1

This machine can achieve the correct result in 3 +quotient clock cycles using only
two (instead of three) registers. Therefore, it is as fast as the fastest Moore machine in Figure 5-6.
chapter 2 using fewer registers.

184 Verilog Digital Computer Design: Algorithms into Hardware



5.2.4 Asserting READY early
only when the machine The reason that the Mealy machine in section 5.2.3 is no faster than the the Moore

whine leaves the loop to machine in 2.2.7 is because of the assumption that the user waits at least two clock

e ASM: cycles while the machine asserts READY. In the Moore machines of chapter 2, assert-
ing READY was the same as being in state IDLE, but with a Mealy machine, it would
be possible to assert READY one clock cycle earlier. There are two reasons why assert-
ing READY one clock cycle early works. First, during the last clock cycle of state
COMPUTE in the ASM of section 5.2.3, r2 already contains the correct quotient, and
so r2 is not scheduled to be incremented again. Second, the user is unaware of what
state the machine is in and instead relies on READY to indicate the proper time when
pb can be pressed again.

The following machine asserts READY in state IDLE and in the last clock cycle of
state COMPUTE. When the machine is in state COMPUTE, the rl >= y test at the
bottom of the loop is evaluated at the same time as the rl >= y test at the top of the
loop. When the machine stays in the loop another time, r2 is incremented. When the
machine will leave the loop, READY is asserted instead.

e we looked at in the last

D ready=1
0 ready=l
. ready=1
0 ready=O
0 ready=O
0 ready=O
0 ready=1
0 ready=1

it clock cycles using only Figure 5-6. Mealy division ASM with conditional READY
fastest Moore machine in

into Hardware Advanced ASM Techniques 185



It would not be legal to attempt to assert READY after leaving the loop because READY
is already asserted in state IDLE. The conditional Continued

assertion of READY as shown above
is legal because it can only happen in state COMPUTE. The following illustrates how @(posedge
READY is asserted for the example when x=14 and y=7 : r2 <=

end
en(

IDLE end
rl= ? r2= ? pb=0 ready=l

IDLE rl= 14 r2= ? pb=l ready=l
COMPUTE rl= 14 r2= 0 pb=0 ready=0
COMPUTE rl= 7 r2= 1 pb=0 ready=0 Although there
COMPUTE rl= 0 r2= 2 pb=O ready=1 sysclk) 0 (
IDLE rl= 4089 r2= 2 pb=0 ready=l conditional dt

As another ex;
The last time in state COMPUTE, r2 is already the correct quotient, and the condi-
tional signal READY is asserted. The user can begin counting clock cycles from this
moment, rather than having to wait an extra clock cycle. always

This machine can achieve the correct result in 2 +quotient clock cycles using only begir
two (instead of three) registers. Therefore, this Mealy machine is cheaper and faster
than any of the Moore machines given in chapter 2.

5.3 Translating Mealy ASMs into behavioral Verilog
Pure behavioral Mealy ASMs that use only RTN can usually be translated into Verilog
quite easily. Often it is as simple as using an i f statement, where the first statement
inside the i f is not time control. (A Moore machine that has an i f decision must have
time control as the first statement inside the body of the i f . Of course nested i f s are
allowed in both Moore and Mealy machines.) The statements inside an i f without
intervening time control correspond to ovals in a Mealy ASM. For example, consider
how the ASM of section 5.2.1 translates into Verilog: end

always
The condition

begin
because 

@(posedge no $t
sysclk) enternewstate('IDLE);

rl <= @(posedge sysclk) x; reevaluated by
ready = 1; As a final exai
if (pb)
begin always

r2 <= (posedge sysclk) 0; begi
while (rl >= y)

begin
@(posedge sysclk) enter_new state('COMPUTEl);

rl <= @(posedge sysclk) rl - y;

l86 Verilog Digital Computer Design: Algorithms into Hardware



he loop because READY Continued
READY as shown above
following illustrates how @(posedge sysclk) enternewstate('COMPUTE2);

r2 <= (posedge sysclk) r2 + 1;
end

end
end

)=O ready=l
)=1 ready=l
)=O ready=O
)=O ready=O Although there is time control later inside the if, the statement r2 <= @( posedge
,=O ready=1 sysclk) 0 occurs directly after the if with no intervening time control, and so is
)=O ready=l conditional during state IDLE.

As another example, consider translating the Mealy ASM of section 5.2.3 into Verilog:
quotient, and the condi-
ig clock cycles from this

always
begin

clock cycles using only @(posedge sysclk) enternewstate('IDLE);
ine is cheaper and faster rl <= (posedge sysclk) x;

ready = 1;
if (pb)
begin

r2 <= (posedge sysclk) 0;
vioral Verilog while (rl >= y)

be translated into Verilog begin

where @(posedge 
the first statement sysclk) enternewstate('COMPUTE);

rl <= @(posedge sysclk) rl - y;
an if decision must have if (rl >= y)
Of course nested i f s are r2 <= (posedge sysclk) r2 + 1;
nts inside an if without end
A. For example, consider end

end

The condition (ri >= y) always produces identical results in the if and in thewhile
because no $time passes from when it is evaluated by the if and when it is later
reevaluated by the while.

As a final example, consider translating the Mealy ASM of section 5.2.4:

always
begin

@(posedge sysclk) enternewstate('IDLE);
rl <= @(posedge sysclk) x;

COMPUTE1); ready = 1;
if (pb)
begin

nto Hardware
Advanced ASM Techniques 187



Continued. comes from the
r2 <= (posedge sysclk) 0; tions illustrate t]
while (rl >= y) ! == can solve t

begin
@(posedge sysclk) enternewstate('COMPUTE);
rl <= (posedge sysclk) rl - y; 5.4.1 Botto
if (rl >= y) A bottom testin

r2 <= (posedge sysclk) r2 + 1; difficult to trans
else in the language.

ready = 1; bottom of the lo
end

end of the loop. (In t
end the computation

stage, since Veri
The conditional command simply translates into an else. using a while.

As an illustration
states are assign

5.4 Translating complex (goto) ASMs into behavioral
Verilog

Section 2.1.4 discusses the goto-less style for ASM charts, where every decision is
described in terms of high-level while, if and case constructs. Since Verilog has
statements that correspond to these constructs, it is usually straightforward to translate
such an ASM chart into behavioral Verilog, regardless of whether it is a Moore or
Mealy ASM. It is incorrect to
On the other hand, because Verilog does not provide a goto statement, there are three
situations when translating an ASM chart into Verilog is more difficult. First, transla-
tion is difficult when an ASM chart uses a bottom testing always

loop construct, similar to the
repeat . begin

. . until of Pascal or do . . . while ( ) of C. Second, translation is @ 
difficult (posed

when an ASM chart has intervening time control before the loop exit decision stop
(as in the ASM of section 2.2.2). Third, translation is difficult when the decision can speed
only be described with gotos. while
The general solution bec

to these difficulties involves using the present_state vari-
@d

able inside if s and whiles. In the behavioral Verilog model of an ASM, the
presentstate variable indicates which algorithmic state the ASM is currently
performing. By testing the present state inside if s and whiles with the ! ==
operator, it is possible to implement arbitrary (goto-like) decisions without needing a end
goto statement. Such tests are not part of what the hardware does. Mentioning @(poseds
present_state in an ASM chart is unnecessary since an ASM chart allows arbi- stop 

trary gotos to any state. Such decisions are required only to overcome a limitation speed
of

Verilog, and so using ! == (rather than ! =) is appropriate. count
The need for using ! == end

188 Verilog Digital Computer Design: Algorithms into Hardware



comes from the fact that present_state may be bx. The following three sec-
tions illustrate the three kinds of difficulties, and how testing present_state with

== can solve the problem.

ite('COMPUTE); 5.4.1 Bottom testing loop
r- Y;

A bottom testing loop is, technically speaking, "goto-less," but such a loop is still
r2 + 1; difficult to translate because Verilog does not provide a bottom testing loop construct

in the language. In essence, since such a construct does not exist, the decision at the
bottom of the loop has to be thought of as a conditional goto that branches to the top
of the loop. (In the pure structural stage, this is how the loop would be implemented by
the computation of the next state in the stategen function.) In the pure behavioral
stage, since Verilog lacks a goto statement, the only choice is to describe such a loop
using awhile.

As an illustration, consider the nonsense ASM chart from section 2.1.2.1. Suppose the
states are assigned the following representations:

into behavioral
'define NUMSTATEBITS 2
'define GREEN 2'bOO

where every decision is
'define YELLOW 2'bOl

tructs. Since Verilog has 'define RED 2'blO
aightforward to translate
vhether it is a Moore or

It is incorrect to translate the loop involving state YELLOW using just a while:

statement, there are three
re difficult. First, transla- always

tpc onstruct, sniniilar to Xhe begin )
C. Second, translation is l.( posedge sysclk) enter new state('GREEN);

fore the loop exit decision stop = 0;
ult when the decision can speed = 3;

while(count 1= 0)
begin

presentstate van- @(posedge sysclk) enter newstate('YELLOW);
gm odel of an ASM, the stop = 1;

tate the ASM is currently speed = 1;

md whiles with the ! == count <= @(posedge sysclk) count + 1;

ecisions without needing a end
@(posedge sysclk) enter_new-state('RED);

rdware does. Mentioning
stop = 1;

an ASM chart allows arbi- speed = 0;
o overcome a limitation of count <= @(posedge sysclk) count + 2;
. The need for using ! == end

into Hardware Advanced ASM Techniques 189



because the count ! = 0 test in the while occurs as part of both states GREEN as well
YELLOW, but in the original Continued.

ASM the test is part of state YELLOW only. To illustrate
this problem, consider the simulation of the above while loon

$time= 70 ps=00 stop=0 speed=1l count=000
$time= 170 ps=10 stop=1 speed=00 count=000
$time= 270 ps=00 stop=0 speed=1l count=010 end
$time= 370 ps=00 stop=1 speed=01 count=010
$time= 470 ps=01 stop=l speed=01 count=011
$time= 570 ps=01 stop=1 speed=01 count=100 When the m
$time= 670 ps=01 stop=1 speed=01 count=101 !== will be 
$time= 770 ps=01 stop=1 speed=01 count=110 whether the
$time= 870 ps=01 stop=1 speed=01 count=111 state GREEI
$time= 970 ps=01 stop=1 speed=01 count=000
$time= condition is 

1070 ps=10 stop=1 speed=00 count=001 tion. It does i
simulation of

The condition in the while is evaluated in state GREEN at $time 51, which is the
problem. At $ time 170, the machine has gone directly to state RED, rather than to
state YELLOW $timne

where it is supposed to be. This error occurs because the whi 1 e loop $$ tt iimmee::has inserted an extra (incorrect) test whether count ! = 0 in state RED. Because count $time-
is zero, the machine avoids state YELLOW altogether, which $time-

is not the desired behav-
ior. $time=

$time=
It is an unavoidable feature of Verilog that the behavioral construct that we have to $time=
implement this loop is the while statement. Awhile loop always tests at $time=

the top of
the loop, but in hardware, as is the case here, we often want $time=

to test at the bottom of the
loop. To implement the ASM of section $time=

2.1.2.1 correctly for Verilog simulation re-
quires nullifying the fact $time=

that this while loop executes both in state GREEN and in
state YELLOW. . . .

To overcome this problem, the correct code ORs the original ASM
condition with a ! == test that mentions the bottom state of the loop. In this example,
because there is only the state YELLOW in the loop, the whi le condition At$ 

ORs time 
count 17C

!= 0 withpresentstate !== 'YELLOW: clock cycle cc

always
begin 5.4.2 Tim

@(posedge sysclk) enternew state('GREEN); An ASM chart
speed = 3; section 2.2.2 ft
while(count != 0 present-state !== 'YELLOW) problem with 

begin
algorithmic 

@(posedge tof
sysclk) enternewstate('YELLOW);

stop = 1; that Verilog ha
speed = 1; "while" loop
count <= @(posedge sysclk) count + 1;

end

190 Verilog Digital Computer Design: Algorithms into Hardware



th states GREEN as well Continued.
.LOW only. To illustrate

@(posedge sysclk) enter-newstate('RED);

.1 count=000 stop = 1;
10 count=000 count <= (posedge sysclk) count + 2;

A1 count=010 end
)1 count=010

)1 count=011 When the machine is in the bottom state of the loop (YELLOW in this example), the
)1 count=100 !== will be false, and the original ASM condition 
)1 count=101 will be the only thing that decides
)1 count=110 whether the while loop continues. When the machine is in any other state, such as
)1 count=111 state GREEN, the ! == will be true (even if present state is bx), and so the ORed
)1 count=000 condition is true. The loop will begin execution, regardless of the original ASM condi-
)0 count=001 tion. It does not matter whether count ! = 0; the loop will execute at least once. The

simulation of this code shows that it correctly models the behavior of the original ASM:

$time 51, which is the
$time= 70 

tate RED, ps=00 
rather than to stop=0 speed=l1 count=000

$time= 170 ps=01 
iecausethewhile stop=1 speed=01 count=000

loop $time= 270 ps=10 stop=1 speed=00 count=001
te RED. Because count $time= 370 ps=00 stop=0 speed=11 count=011
is not the desired behav- $time= 470 ps=01 stop=1 speed=01 count=011

$time= 570 ps=01 stop=1 speed=01 count=100
$time= 670 ps=01 stop=1 speed=01 count=101

)nstruct that we have to $time= 770 ps=01 stop=1 speed=01 count=110
always tests at the top of $time= 870 ps=01 stop=1 speed=01 count=111
test at the bottom of the $time= 970 ps=01 stop=1 speed=01 count=000
r Verilog simulation re- $time= 1070 ps=10 stop=1 speed=00 count=001
t in state GREEN and in
,O Rs the original ASM

ie loop. In this example, At $ time 170, the machine has entered state YELLOW as it should. Since during that
e condition ORs count clock cycle count is zero, the machine proceeds to state RED.

5.4.2 Time control within a decision
GREEN); An ASM chart that is translated directly from a software paradigm while loop (see

section 2.2.2 for an example) would appear to be goto-less, but in fact it is not. The
- 'YELLOW) problem with such an ASM chart is that it must have @ time control between the

algorithmic top of the loop and the place where the decision occurs. Despite the fact
te('YELLOW); that Verilog has a while loop, the testing of the condition required by a software

"while" loop occurs in the middle of the loop (after the @), rather than at the algo-

ount + 1;

ito Hardware Advanced ASM Techniques 191



rithmic top of the loop (as required by Verilog's while construct). The reason for this Continued
@0ti me control is to give the algorithm $ time to make the decision before any compu-
tations occur that could effect the outcome of the decision.

always @(1
Again, it is possible to overcome this kind of problem using a present-state == test. sa$isplay
For example, consider translating the Moore ASM chart of section 2.2.2 into behav- timE

ioral Verilog: lendmodule

module slowdivsystem(pb,ready,x,y,r2,sysclk);
input pb,x,y,sysclk; where the state
output ready, 2;
wire pb;
wire [11:0] x,y;
reg ready;
reg [11:0] rl,r2;
reg ['NUMSTATE-BITS-1:0] present state;

always
begin
@(posedge sysclk) enter_new state('IDLE);

rl <= @(posedge sysclk) x; The troublesoi
ready = 1; includes state
if (pb) loop. Three sit
begin

while loop i:
@(posedge sysclk) enternew state('INIT);
r2 <= @(posedge while 

sysclk) loopi
0;

while ((rl >= y)|presentstate !=='TEST) while loop i,
begin inside the Veri
@(posedge sysclk)enter new state('TEST); which the Veri
if (rl >= y) from state TE5
begin guaranteed to
@(posedge sysclk enter new state('COMPUTEl); !== 'TESTc

rl <= @(posedge sysclk) rl - y; situations will
@(posedge sysclk) enternew state('COMPUTE2);

r2 <= @(posedge sysclk) r2 + 1; In order to alk
end loop exits, the:

end if uses the sc
end while loop. ]

end fore the Verilo
task enter newstate;
input ['NUM_STATE_BITS-1:0] re-evaluated. 

this-state;
begin mains false sir
present-state = thisstate; is a simulation
#1 ready=0;

end
endtask

192 Verilog Digital Computer Design: Algorithms into Hardware



ruct). The reason for this Continued
ision before any compu-

always (posedge sysclk) #20
i present-state ! == test. $display("'%d ps=%b rl=%d r2=%d pb=%b ready=%b",
ection 2.2.2 into behav- $time, present_state,r1,r2, pb, ready);

endmodule

where the states are represented as:

'define NUMSTATEBITS 3
'define IDLE 3'bOOO
'define INIT 3'bOOl
'define TEST 3'bOlO
'define COMPUTEl 3'bOll
'define COMPUTE2 3'blOO

The troublesome state here is state TEST. There is a Verilog while loop whose body
includes state TEST and an if statement that includes the other states of the ASM
loop. Three situations can occur with the Verilog while loop: It is possible that the
while loop is being entered for the first time from state INIT, it is possible that the

'INIT);
while loop is to be reexecuted from state COMPUTE2, and it is possible that the

=='TEST) while loop is to exit from state TEST. In each of these three situations, the condition
inside the Verilog while loop is evaluated. The only one of these three situations in

'TEST); which the Verilog loop body does not proceed to execute is when the ASM loop exits
from state TEST. The other two situations (from state INIT and state COMPUTE2) are
guaranteed to stay inside the Verilog while loop. Therefore, the present state

_state('COMPUTEl); !== 'TEST condition makes sure that the next thing to execute in both of those two
rl - y; situations will be the algorithmic top of the Verilog while loop (state TEST).
_state('COMPUTE2);
r2 + 1; In order to allow the Verilog whi le loop to exit at the identical $ time that the ASM

loop exits, there is a nested if inside the Verilog while loop, after state TEST. This
if uses the same ASM condition (rl >= y) that was also mentioned in the Verilog
while loop. In the situation when this condition is false, no $ time has elapsed be-
fore theVerilogwhile condition ( (rl >= y) presentstate ! == 'TEST) is
re-evaluated. Since the present state is state TEST and ASM condition (rl >= y) re-
mains false since no $ time has elasped, the Verilog whi e loop exits properly. Here
is a simulation for x=14 and y=7:

to Hardware Advanced ASM Techniques 193



9370 ps=000 rl= 13 r2= 1 pb=0 ready=l The Mealy A
9470 ps=000 rl= 14 r2= 1 pb=1 ready=l below (using
9570 ps=001 rl= 14 r2= 1 pb=0 ready=0
9670 always

ps=010 rl= 14 r2= 0 pb=0 ready=0
9770 ps=011 begin

rl= 14 r2= 0 pb=0 ready=0
9870 ps=100 @( po;

rl= 7 r2= 0 pb=0 ready=0
9970 ps=010 rl= sp,

7 r2= 1 pb=0 ready=0
10070 ps=011 rl= wh.

7 r2= 1 pb=0 ready=0
10170 ps=100 rl= 0 r2= 1 pb=0 ready=0
10270 ps=010 rl= 0 r2= 2 pb=0 ready=o
10370 ps=000 rl= 0 r2= 2 pb=0 ready=l

5.4.3 Arbitrary gotos
It is poor style to use arbitrary gotos. Therefore such an example is not presented
here. Nevertheless, regardless of how messy the ASM, some combination of if s and
whiles that use === and tests with the present_state can implement the lea
ASM in Verilog. @ (poE

stc
col-

end

5.5 Translating conditional command signals into The diamond,
Verilog by the stay 

To translate a Mealy ASM, such as the one in section 5.1. 1, that has conditional com- time control bi
mand signals (rather than conditional RTN), enternewstate must include all if (and the pa
the Mealy command signal outputs. In the example ASM of section 5.1. 1, the task has zero, which m
four commands to initialize, each of which has a default of zero: become one. S

of zero.
task enter-new-state;

input ['NUM_STATE_BITS-l:0] this_state; On the other h;
begin not execute,
presentstate = this_state; enternew_
#1 stop =0;

count !=0.S
speed = 0;
stay = has elasped. 

0; Ti
leave = 0; the final call to

end fore the last cy
endtask one, but stay

Initializing such conditional command Since 
signals this 

is important is a
because in many situations

the Mealy command is explicitly mentioned only exits 
on certain from the 

paths through the ASM.
By describing the default values for all outputs from state 

(whether GRE
they are Mealy or Moore) in

enternew_state, the behavioral 'YELLOW.) 
Verilog will be Th

a one-to-one mapping of the cor-
responding ASM chart. In the above Ve

194 Verilog Digital Computer Design: Algorithms into Hardware



) ready=l The Mealy ASM chart of section 5.1.1 then can be translated into Verilog as shown
ready=l below (using the ! == technique described in section 5.4.1):

) ready=0 always
) ready=0 begin
) ready=0 @(posedge sysclk) enternew-state('GREEN);
) ready=0 speed = 3;
) ready=0 while(countl=0 I present-state !== 'YELLOW)
) ready=0 begin
) ready=0 @(posedge sysclk) enternew state('YELLOW);
) ready=O stop = 1;
) ready=l speed = 1;

count <= (posedge sysclk) count + 1;
if (countl=O)

ample is not presented stay = 1;
ombination of i f s and end

ste can implement the leave = 1;
@(posedge sysclk) enternew state('RED);

stop = 1;
count <= (posedge sysclk) count + 2;

end

inals into The diamond and oval inside the loop simply translate into an if statement followed
by the stay = 1 statement, with no intervening time control. Therefore, there is no

at has conditional corn- time control between the return from enternew-state and the execution of the
tate must include all if (and the possible consequent execution of stay= 1.) Suppose that count is non-
ction 5.1. 1, the task has zero, which means stay becomes one at the same $time that speed and count

become one. Since leave is not mentioned inside the loop, it retains its default value
of zero.

On the other hand, suppose count is zero inside the loop. This means stay=1 does
not execute, and so stay retains its default value (of zero) given to it by
enternewstate. No $time passes at the point where thewhile retests whether
count !=0. Since count is zero, thewhile isguaranteedtoexit, butstill no $time
has elasped. This means that the leave=1 statement executes at the same $time as
the final call to enternewstate ( ' YELLOW) returns back to the loop body. There-
fore the last cycle in which the machine is in state YELLOW will output leave as
one, but stay as zero.

Since this is a correct translation of a bottom testing loop, the only way the machine
ause in many situations exits from the while loop is from state YELLOW. (It is not possible to get directly
aths through the ASM. from state GREEN to the exit of the while because of the presentstate I= =
are Mealy or Moore) in 'YELLOW.) Therefore, this Verilog is a one to one mapping of the ASM.
one mapping of the cor-

In the above Verilog, the states are represented as:

o Hardware Advanced ASM Techniques 195



'define NUMSTATEBITS 2 Such an ASM
'define GREEN 2'bOO modeled in Ve
'define YELLOW 2'bOl
'define RED 2'blO wire

reg
and the following declarations occur at the beginning of the module: alw

reg stop;
reg [1:0] speed;
reg [2:0] count;
reg ['NUMSTATE BITS-1:0] presentstate;
reg stay,leave;

er

5.6 Single-state Mealy ASMs The only diffe
As discussed in section 2.4.1, an ASM with four rectangles requires two bits to repre- proper time co
sent those states. An ASM with two rectangles requires only one bit to represent those rather than an)
states. What about an ASM with only one state? As explained in section 2.5, an ASM
with only one rectangle represents pure combinational logic and therefore needs zero
bits to represent the state. (The machine is always in that one state, and so it is not
necessary to record which state the machine is in.) 5.7 Con

Moore machin
The oval notation allows such an ASM to have an arbitrarily complex decision happen- Mealy machin
ing in that one state. For example, a decoder, whose input is a two-bit bus, inbus, and chapter shows
whose outputs are o, o, o2 and o3 can be described as: rithms. Like M

Unlike Moore
diamonds. The

1 4 unconditional 

Translating a v
an i f statemei
signals (rath
enternew_

inbus == 2 1o Moore and Me
and if s. Suc

nbus == 1o presentst
with a preset
only for simula

0 Single-state Mi
behavioral fash

Figure 5-7. ASM for combinationall ogic tion of 
(decoder). combin;

196 Verilog Digital Computer Design: Algorithms into Hardware



Such an ASM bears a close resemblance to the way in which a combinational device is
modeled in Verilog:

wire [1:0] inbus;
reg oO,ol,o2,o3;

,odule: always @(inbus)
begin

oO = 0; o = 0; o2 = 0; o3 = 0; //defaults
case (inbus)

0: 00 = 1;
1: 01 = 1;
2: o2 = 1;

-state; 3: o3 = 1;
endcase

end

The only difference between the ASM and the Verilog is that the Verilog needs the
quires two bits to repre- proper time control for combinational logic, which is @ followed by a sensitivity list,
ne bit to represent those rather than any mention of the system clock.
in section 2.5, an ASM
nd therefore needs zero
te state, and so it is not 5.7 Conclusion

Moore machines have commands that occur when the machine is in a particular state.
mplex decision happen- Mealy machines allow commands in a particular state to occur based on status. This
wo-bit bus, inbus, and chapter shows how Mealy ASMs allow a designer to express faster and better algo-

rithms. Like Moore ASMs, Mealy ASMs have unconditional commands in rectangles.
Unlike Moore ASMs, Mealy ASMs have conditional commands in ovals that follow
diamonds. The conditional commands in the ovals happen at the same time as the
unconditional commands in the rectangle and the decisions in the diamonds.

Translating a Mealy ASM into behavioral Verilog is usually simple, typically involving
an i f statement with no intervening time control. When the ASM involves command
signals (rather than RTN), as would be the case at the mixed stage, the
enternewstate task must initialize the conditional commands. SomeASMs (both
Moore and Mealy) cannot be expressed in the goto-less style with simple whiles
and i f s. Such ASMs need to be translated into Verilog using !== tests of
presentstate. Acommon example of anASM that must be translated into Verilog
with a present state ! == test is a bottom testing loop. These techniques work
only for simulation. See chapter 11 for synthesis techniques.

Single-state Mealy ASMs are a general notation to describe combinational logic in a
behavioral fashion. As such, they are closely related to the behavioral Verilog descrip-
tion of combinational logic.

Lto Hardware Advanced ASM Techniques 197



6. DESIGNING FOR 6.1 Pro]
Every physica
propagation d

SPEED AND COST combinational
easons for m

Chapter 2 uses ASM charts as a description of how to carry out each step of an algo- ceptable way
rithm in an arbitrarily chosen unit of physical time, known as the clock cycle. Chapter han the desiE
3 introduces Verilog's $ t ime variable, whose incrementation by the Verilog scheduler ifter synthesi!
simulates the passage of physical time in the fabricated hardware. The example Verilog lelayless styli
clock (section 3.7.1.3) used in chapters 3 through 5 has an arbitrarily chosen clock ign, when the
period of 100 units of $time. The exact amount of physical time that this 100 units of Third, the deL
Verilog $ time relates to is not specified nor is it of any concern in chapters 3 through The purpose c
5. Up to this point, the emphasis has been on designing correct algorithms and imple- is possible. T
menting them properly in hardware. The only attempt to increase speed in chapters 2 )ractical maci
through 5 is by doing more steps in parallel, thereby requiring fewer clock cycles. The neet certain c
number of clock cycles required by an ASM chart is a mathematical property of the t is too slow (
algorithm and is separate from its physical implementation. iigher clock I
The total physical time required by a machine to compute an answer is the number of ited with opei
clock cycles required by the algorithm multiplied by the physical time of the clock
period used in the hardware implementation. Physical clocks are often measured in
frequency, rather than time. There is a reciprocal relationship between clock period and .2 Faci
clock frequency. For example, what is the total time required to divide 14 by 7 using the
machine described in section 2.2.7 when that machine is clocked at 200 MHz? Ac- Synchronous
cording to the analysis there, the number of clock cycles required by the algorithm )articular frec
(including the time for two clock cycles in state IDLE) is 3 +quoti  ent= 5 clock cycles. ;he machine)
The clock period in this example is 5 ns, and so the total time is 25 ns. -or as long w

proportionate
In the first stages of design, algorithmic correctness and speed only in terms of clock unately, ther
cycles are the primary focus of the designer. The harsh physical reality of time should he hardware,
enter into the designer's thinking only after the design has been synthesized. This chap- juency is.
ter shows how the $ time features of a Verilog simulator allow a designer to experi-
mentally determine the speed of a synthesized design without having to fabricate it. rhe propagat
This chapter also illustrates three alternative design techniques that allow a trade-off potentially pi
between speed and cost should a synthesized design fail to meet its speed require- enough time
ments. correct value.

lave its result
nterconnectic
aterconnectic
help the desig

198 Verilog Digital Computer Design: Algorithms into Hardware



takes an amount of physical time, known as
Except in section 3.7.1.2, we have modeled
having no propagation delay. There are three
combinational logic. First, it is the only ac-

Dut each step of an algo- gic for synthesis. (The synthesis tool, rather
the clock cycle. Chapter on delay of the synthesized hardware. Only
by the Verilog scheduler the netlist to see how fast it is.) Second, the

are. The example Verilog fficient to simulate in the early stages of de-
arbitrarily chosen clock with algorithmic correctness than with speed.
ime that this 100 units of
,m in chapters 3 through
Ata lgorithms and imple- *r( but not forget) as many details for as long
ease speed in chapters propagation 

2 delay, if we want to fabricate a
fewer clock cycles. The ront these details. Real-world machines must

zmatical property of en 
the if a machine is algorithmically correct, if

be practical to build. Running a machine at a
d of the machine, but there is a cost associ-

answer is the number of ncies.
ysical time of the clock
s are often measured in
etween clock period and
divide 14 by 7 using the clock frequency

cked at 200 MHz? Ac- )ntroller) are clocked by a clock signal of a
4uired by the algorithm ow enough (the clock period is long enough),
)tient=5 clock cycles. the ASM chart and the Verilog simulations.
is 25 ns. inction, increasing the clock frequency will

iachine 
J without 

only in having 
terms of to 

clock redesign it. Unfor-
)ck 

al can 
reality be. 

of Therefore, 
time should to get the most out of

vw hat the 
synthesized. maximum 

This permissible 
chap- clock fre-

w a designer to experi-
t having to fabricate it. tional device and every gate in a machine
,s that allow a trade-off actual speed of the machine. There must be
meet its speed require- combinational logic path to stabilize on its

ose interconnection of gates is shallow can
lister faster than an equivalent device whose
ately, combinational devices whose internal
more costly. Simulation and synthesis tools
ween speed and cost.

Hardware Speed and Cost 199



The factors that determine the maximum clock frequency include the delay of signals
on each wire, the propagation delay of each gate, the way such gates and wires are
interconnected to form building blocks (such as adders) and the way such building
blocks are interconnected to form the problem-specific architecture and the controller.
The designer does not have much influence on the first three factors. The implementa-
tion technology (not the designer or the synthesis tool) determines the delays of wires,
gates and devices. (Of course, the designer can choose to use a more expensive technol-
ogy to achieve higher speed. For example, by fabricating custom silicon with smaller
chip dimensions, the propagation delays of each gate are correspondingly reduced.) At
best, the designer can only give hints to the synthesis tool to favor either lower-cost
building blocks or higher-speed building blocks. If speed is essential, the designer can
manually create a netlist for a shallow (high-speed) building block, but this circum-
vents the advantages of the synthesis tool.

When using a synthesis tool, the only major factor to increase speed over which a
designer has much control is the way building blocks are interconnected to form the
architecture and the controller. The end of this chapter discusses various methods that
the designer has at the architectural level to increase speed at minimum cost. But first,
the next sections look at netlist level propagation delay, which is the underlying cause
of this difficulty.

6.3 Example of netlist propagation delay
Putting propagation delays at the netlist level is easy. You simply instantiate the built-in
gate with a parameter, which is the delay in units of $ t ime. (This works only for built-
in gates, since parameters in user-defined modules take on whatever meaning the user
desires.)

Section 2.5 explains how a two-bit adder black box can be decomposed down to the
gate level using hierarchical design. Sections 3.10.6 and 3.10.7 give the equivalent
structural (hierarchical) Verilog modules for this adder assuming no propagation delay.
As an example of modeling propagation delay, assume and and or gates have a delay
of one unit of $ time, and the more complicated xor gates have a delay of two units of
$time. A slight change to the modules from sections 3.10.6 and 3.10.7 will provide a
much more realistic model of what the actual hardware does:

200 Verilog Digital ComputerD esign: Algorithms into Hardware



ay of signals module halfadder(c,s,a,b);
nd wires are input a,b;
uch building wire a,b;
he controller. output Cs;
implementa- wire c,s;

ays of wires, xor #2 xl(s,a,b);

,sive technol- and #1 al(c,a,b);

with smaller endmodule

reduced.) At
module full-adder(cout,s,a,b,cin);

-r lower-cost input a,b,cin;
designer can wire a,b,cin;
this circum- output couts;

wire cout,s;
wire coutl,cout2,stemp;

ver which a halfadder ha2(coutl,stemp,a,b);
I to form the halfadder ha3(cout2,s,cin,stemp);
methods that or #1 ol(cout,coutl,cout2);
ost. But first, endmodule
-rlying cause Is

module adder(sum,a,b);
input a,b;
output sum;
wire [1:0] a,b;
wire [2:0] sum; U

wire c;
;e the built-in halfadder hal(c,sum[O],a[O],b[0]);
nly for built- fulladder fal(sum[2],sum[l],a[l],b[l],c);
ning the user endmodule

down to the Assuming this module is instantiated as before:
te equivalent

adder adderl(sum,a,b);
gation delay.
have a delay
ftwo units of the following diagram illustrates the interconnection of gates described by the above
till provide a Verilog:

Designingf or Speed and Cost 201



-

:adder ha- -- s----- F
.aO .a . I

a :

a[1] .. . .

. ... ... ... ... ... ... ,

ha2

.... ....._ ..Sr.M~_.....
...__

sum
. S! 3 There is also

change in a [ C

cout2 .cout l

. .sum[2]
........ . ...-.. .- ... .- ..... ..-. .. --..- -...- --..-- ..- -.... -.-

--- ---- ------------------------
Figure 6-1. Adder with names used in structural Verilog.

6.3.1 A priori worst case timing analysis
Without using simulation, we could determine how long it takes in the worst case for
the above modules to stabilize. There are many possible paths through the gates that
have to be considered to determine the longest path. For example, there is a depen-
dency of sum [2] on a [ 0 ] . A change in a [ ] could cause an incorrect result for
sum [2] until the effects of the change in a [0] can propagate through the path to
sum[2]. The following shows where this change has to propagate, and how much
$time is required:

There are othi
$ time. There
of $time afte

202 Verilog Digital Computer Design: Algorithms into Hardware



P-

Verilog name total delay thus far

a[O] 0
adderl.a[0J 0
adderl.hal.a 0
adderl.hal.al 1
adderl.hal.c 1
adderl.c 1
adderl.fal.a 1
adderl.fal.ha2.a 1
adderl.fal.ha2.al 2
adderl.fal.ha2.c 2
adderl.fal.coutl 2
adderl.fal.ol 3
adderl.fal.c 3
adderl.sum[2] 3
sum[2] 3

-0-+ sum
3 There is also a dependency of sum [ 1 ] on a [0]. The following shows where the

5l; change in a [0] has to propagate, and how much $ time is required:

Verilog name total delay thus far

a[0] 0
adderl.a[O] 0
adderl.hal.a 0
adderl.hal.al 1
adderl.hal.c 1
adderl.c 1

e worst case for adderl.fal.a 1
adderl.fal.ha2.a 1

gh the gates that adderl.fal.ha2.xl 3
iere is a depen- adderl.fal.ha2.s 3
rrect result for adderl.fal.stemp 3
ugh the path to adderl.fal.ha3.a 3
and how much adderl.fal.ha3.xl 5

adderl.fal.ha3.s 5
adderl.sum[l] 5
sum[l] 5

There are other similar delay paths, but none of them are longer than five units of
$ time. Therefore, whatever code instantiates adder must wait more than five units
of $ time after changing a and b before using sum.

DesigningforS peed and Cost 203



The test module in section 3.10.5 did not do this, so it would print out incorrect values Continued
for sum. If you simulate adderl with the test code from section 3.10.5, most of the
results printed out will be wrong. This is because the #1 in the test code is an inad- begin
equate amount of $time for adder 1 to stabilize on the correct answer. for (ic

begin
a = 

6.3.2 Simulation timing analysis for

In circuits more complex than this trivial example, it is difficult to begi
do a priori timing

analysis, especially on a synthesized netlist. Also, since a priori analysis finds the worst #7
case propagation delay, such analysis may be overly pessimistic. Therefore, designers
often use post-synthesis simulation to obtain timing information about the design.
In this example, according to the a priori timing analysis, the test code for the adder
module described end

in section 6.3.1 needs to wait longer than #5. If we use simulation to end
do the timing analysis, we would take a guess and check if the guess is an adequate $fini.
amount of delay. Here we try #7: end
module top; endmodule

integer ia,ib;
reg [1:0] a,b; 6.3.3 Haz
wire [2:0] sum; In addition to
reg [2:0] oldsum; an always b]

(#0) of each 
adder adderl(sum,a,b); adder (sum) is

it prints out a 
always #1 for a "WRONG
begin
#0 what 

if (a+b==sum) sum use
$display("a=%d b=%d sum=%d CORRECT behind 

$time=%d", the cW
a,bsum,$time); the change in

else combinational
if (sum==oldsum) glitch). Hazar(
$display("a=%d b=%d sum=%d WRONG LAG $time=%d",

a,b,sum,$time);
else Here is a parti
$display("a=%d b=%d sum=%d WRONG GLITCH $time=%d",

a,b,sum,$time);
oldsum = sum;

end
initial

204 Verilog Digital Computer Design: Algorithms into Hardware



correct values Continued
5, most of the
de is an inad- begin

r. for (ia=O; ia<=3; ia = ia+1)
begin
a = ia;
for (ib=O; ib<=3; ib = ib + 1)

i priori begin
timing

b 
re

= ib;
inds the wors.,t

#7 if (a + b === sum)
bre, designers $display(" tested CORRECT');
he design. else

br tthe  adder: $display(" tested WRONG");
end

 simulation toI
end

Ss a n adequate $finish;
end

endmodule

6.3.3 Hazards
In addition to the initial block in the test code of section 6.3.2, it is helpful to have I
an always block that monitors the change in sum at every unit of $time. At the end
(#0) of each unit of $time, the always block checks if the current output of the
adder (sum) is equal to a+b. If it is, it prints out the "CORRECT " message. If it is not,
it prints out a message explaining the reason why. There are two possible explanations
for a "WRONG" value of sum. The first is that the current value of sum is the same as

I
what sum used to be at the previous unit of $time. In other words, sum is lagging
behind the change in a or b. The other possible error is that sum has changed (due to
the change in a or b) to an incorrect value. Such a momentary incorrect value from
combinational logic with propagation delay is known as a hazard (also known as a
glitch). Hazards occur when combinational logic internally has different path delays.

Here is a partial output of this simulation:

Designing for Speed and Cost 205



(since the input
a=O b=O sum=X WRONG GLITCH $time= 1 to an incorrect
a=O b=O sum=X WRONG GLITCH $time= 2 stabilizes on th
a=O b=O sum=X WRONG GLITCH $time= 3
a=O b=O sum=O CORRECT $time= 4 Although the a
a=O b=O sum=O CORRECT $time= 5 would always t
a=O b=O sum=O CORRECT $time= 6 partial output c

tested CORRECT
a=O b=1 sum= 0 WRONG LAG $time= 7
a=O b=1 sum= 0 WRONG LAG $time= 8
a=O b=l sum=l CORRECT $time= 9 a=O I

a=O b=l sum=l CORRECT $time= 10 a=O I

a=O b=l sum=l CORRECT $time= 11 a=O I

a=O b=l sum=l CORRECT $time= 12
a=O b=l sum=l CORRECT $time= 13 a=O I

tested CORRECT a=O I
a=O I

b=2 sum=3 WRONG LAG $time= a=O I
a=2 70

b=2 sum=3 WRONG LAG $time= 
a=2 71

b=2 sum=6 WRONG GLITCH $time= 
a=2 72

b=2 sum=6 WRONG LAG $time= 73 a=2 ]
a=2
a=2 b=2 sum=4 CORRECT $time= a=2 

74 I

a=2 b=2 sum=4 CORRECT $time= a=2 
75 I

b=2 sum=4 CORRECT a=2 I$time= 76
tested CORRECT

In the above, for cases such as a= 0 b= 1, the output of sum simply retains its old value Although four
until sum makes a single change to the correct value. In essence, in these cases, it is failed to stabili
like describing the adder with the following behavioral block: correct behavic
module adder(sum,a,b); our machine tt
parameter DELAY=1; tional logic sta
output sum; ation is unlike]
input a,b; Verilog simula
reg [2:0] sum; analysis would
wire [1:0] a,b;

always (a or b)
# DELAY sum=a+b; 6.3.4 Adv

endmodule Verilog provid
ing delays, mir

where DELAY is an integer propagation delay. Although the above is an attractive way allows us to m
of viewing propagation delay, it does not describe the more complex behavior that gate to change
occurs in other cases. For example, in the simulation of the adder given in section 6.3, output to zero.
for cases such as a=2 b= 3, at first (like the other cases) the output makes no change units of $tim

output change!
206 Verilog Digital Computer Design: Algorithms into Hardware



-.9

(since the input change has not yet propagated to the output). Later, the output changes
to an incorrect result that is different from the earlier value of sum. Finally, the output
stabilizes on the correct result.

Although the a priori analysis using the circuit diagram indicates that more than #5
would always be safe, we could use simulation to see if #4 would be enough. Here is a
partial output of this simulation:

-

a=0 b=0 sum=X WRONG GLITCH $time= 1
a=0 b=0 sum=X WRONG GLITCH $time= 2
a=0 b=0 sum=X WRONG GLITCH $time= 3

tested WRONG
a=0 b=1 sum=0 WRONG GLITCH $time= 4
a=0 b=1 sum=0 WRONG LAG $time= 5
a=0 b=1 sum=1 CORRECT $time= 6
a=0 b=1 sum=l CORRECT $time= 7

tested CORRECT

a=2 b=2 sum=3 WRONG LAG $time= 40
a=2 b=2 sum=3 WRONG LAG $time= 41
a=2 b=2 sum=6 WRONG GLITCH $time= 42
a=2 b=2 sum=6 WRONG LAG $time= 43

tested WRONG

Iitss old value( Although four units of $ time was enough for the adder to stabilize in many cases, it
 cases, it is! failed to stabilize for all of them. Therefore, a longer period is required for completely

correct behavior for any possible input. On the other hand, if we knew before we build
our machine that the inputs would always be among those cases where the combina-
tional logic stabilizes early, we could run the machine faster. For an adder, such a situ-
ation is unlikely, but for other kinds of combinational logic, we might be able to use
Verilog simulation to determine that our machine can run faster than a priori worst case
analysis would predict.

6.3.4 Advanced gate-level modeling
Verilog provides three additional features for modeling gate-level delays: rising/fall-
ing delays, minimum/typical/maximum delays and speci fy blocks. The first of these

raaccttiive way allows us to model the fact that, for many electronic gate technologies, the time for a
havior that gate to change its output to one is not the same as the time for the gate to change its
;secttiioonn 6.3,. output to zero. For example, suppose the xor in the half-adder of section 6.3 takes two
no change units of $ time when its output changes to a one, but three units of $ time when its

output changes to a zero:

Designing for Speed and Cost 207

.



PWI-

xor #(2,3) xl(s,a,b); Continued

xor xl(I
Note that the xor in section 6.3 could have been described as: and al((

endmodule

I - xor #(2,2) xl(s,a,b); Not all simul
mentation for

The second of these advanced gate delay features allows us to model that there are chapter.
certain variations in the fabrication process that affect the speed of supposedly identi-
cal gates at the time of physical manufacturing. Even though the gates are supposed to
be identical, these minor variations mean some of the gates will be slower than others.
The maximum speed possible would be obtained if there were no variation during 6.4 Absi
fabrication. Using statistical quality control methods, manufacturers determine the typical As the previou
speed expected given random variations and determine a minimum acceptable speed level, Verilog
by discarding parts that do not obtain this speed. Many Verilog simulators allows arises if one v
resimulation at each of these three speeds without recompilation by specifying these nology, manul
three delays separated by colons. For example, the following: lays for bus-M

such worst caw
is still at the m

xor #(1:2:3) xl(s,a,b); a physical bw
trated in secti(

indicates a minimum delay of 1, a typical delay of 2 and a maximum delay of 3. The This section i
way in which this is used depends on a particular simulator, and not all simulators delay of a bus
implement this feature. tively advanc(

first consider
The third of these advanced gate delay features, known as the speci f y block, allows
us to model delays within modules without having to indicate delays on individual
gates. For example, the following module is equivalent to the one given in section 6.3: 6.4.1 Inai

The simplest 
module gation 

halfadder(c,s,a,b); delay i:
input a,b; by the first pa
wire a,b;
output Cs;
wire c,s; module ai

paramete:
specify output s

(a >= c) = 1; input a,:
(a >= s) = 2; reg [SIZ:
(b >= c) = 1; wire [SI.
(b >= s) = 2; always

endspecify # DE:
endmodul

208 Verilog Digital Computer Design: Algorithms into Hardware



Continued
I

xor xl(s,a,b);
and al(c,a,b);

endmodule

I Not all simulators support specify blocks. For more information, check the docu-
mentation for your simulator, or see the book by Palnitkar mentioned at the end of this

I1  that there are,I chapter.
!ppoosseeddllyy  identi-
are supposed to4
Ve.ru tlah.toarns  oadtl hloeiwrss.
ariation during 6.4 Abstracting propagation delay

II
Mine the typical As the previous sections illustrate, once a design has been synthesized down to the gate

I

tceptable speed level, Verilog can provide a fairly accurate model of propagation delay. A problem
I

arises if one wishes to estimate propagation delay before synthesis. For a given tech-
pifecyifiyning these nology, manufacturers usually publish a priori estimates of worst case propagation de-

lays for bus-width building blocks (such as adders). We would like to be able to use
such worst case estimates to simulate the propagation delay of an architecture when it
is still at the mixed stage (block diagram). The problem is that the propagation delay of
a physical bus-width device exhibits itself only as specific hazards (like those illus-

I trated in section 6.3.3) that require a synthesized netlist to be simulated.

r ellay of 3.  The( This section illustrates how Verilog can be used to model abstractly the propagation
 all simulators! delay of a bus-width device. The correct Verilog code for doing this uses some rela-

tively advanced features of Verilog. To motivate the need for these features, we will
first consider some incorrect attempts at modeling propagation delay.

Vb lock, allows!
IIoon  iindiiviiduall
 in section 63.3: 6.4.1 Inadequate models for propagation delay

The simplest Verilog code for a bus-width device that includes some notation of propa-
gation delay is similar to the code given in 6.3.3, except that the port sizes are defined
by the first parameter, and the propagation delay is defined by the second parameter:

module adder(s,a,b);
parameter SIZE = 1, DELAY = 0;
output s;
input a,b;
reg [SIZE-1:0] s;
wire [SIZE-1:0] a,b;

always @(a or b)
# DELAY s=a+b;

endmodule

re DesigningforS peed and Cost 209



- P-

As explained in section 6.3.3, this code is deficient because it does not model cases module tE
where there is a hazard but instead always models the error as a lag. reg [11

wire [:
How should a hazard be represented abstractly? The specific value that presents itself adder 
when a hazard occurs can only be predicted from the synthesized netlist. Instead, at the adder 
abstract level, we will use bx to represent the hazard. initial

module begir
adder(s,a,b);

parameter SIZE = 1, DELAY = 0;
output s;
input a,b;
reg [SIZE-l:0] #3C

s;
wire [SIZE-l:0] a,b;

always (a or b)
#4C

begin
s end

= 'bx;
always

# DELAY sa+b;
$disr

end
always

endmodule
$disr

endmodulE
Although this is an improvement, the above still has a flaw. To see why it is deficient,
consider the following design which instantiates the above adder twice: This is illustra

a / o a.a
12 + a.s 124 a2.a

1/2 > lb c 1 a2. b 12  s

8ns -- 1- Ons
lo 18ns worst cas e~

Figure 6-2. Two instantiationso f adder-.
The test code ii

The following test code gives an example how the last definition of adder gives a 8, and the seco
misleading result from simulation: b and c to ch;

$time units (
shows the corr

This flaw exis
change in t (,
additional 10 

210 Verilog Digital Computer Design: Algorithms into Hardware



model cases module test;
reg [11:0] a,b,c;
wire [11:0] t,s;

resents itself adder #(12,8) al(t,a,b);
nstead, at the adder #(12,10) a2(s,t,c);

initial
begin

a 0;
b 0;
C = 0;

#30 a = 100;
b = 20;
c = 3;

#40 $finish;
end

always @(s)
$display("$time=%d s=%d",$time,s);

always (t)
$display("$time=%d t=%d ,$time,t);

endmodule 1%
a

ti s deficient,
This is illustrated by the simulation produced from the above test code:

0
$time= 0 t=x
$time= 0 s=x

I'
$time= 8 t= 0
$time= 10 s= 0
$time= 30 t=x
$time= 30 s=x
$time= 38 t= 120
$time= 40 s= 123

The test code instantiates two adders. The first instance, a , has a propagation delay of
Older gives a 8, and the second instance, a2, has a delay of IO. At$time 30, the test code causes a,

b and c to change. A worst case analysis indicates that it should take 18 additional
$ t ime units ($ t ime=48) to produce the sum of 100+20+3; however the simulation
shows the correct sum in only 10 $ t ime units ($ t ime=40).

This flaw exists because the always block for a2 is still delaying (#10) when the
change in t (also known as a2 a) occurs at $ t ime=38. Rather than delaying an
additional 10 units of $time from $time=38, Verilog simply returns to the  time

Designingf or Speed and Cost 2ll



control at $ time 40. Since a2 . a is stable at $ time 40, the algorithmically correct modul e ad
answer 123 is available too soon. This Verilog model allows us to conclude that the paramet
machine could run faster than is physically possible. output

input a
reg [SI:

6.4.2 Event variables in Verilog wire [S:
Verilog provides special variables, known as event variables, that are helpful in over- event c]

coming the problems shown in the last section. Variables declared as events are used always
only in two places: First, in a triggering statement: start

always 
event e; # DELI

task stU
begin

S =
and, second, in time control:

end
endtask

always @ e endmodule

Unfortunately
Note: There are no parentheses around the variable in the @ time control. The -> result 123 is ai
triggers the corresponding @ to be scheduled. For example, the following prints "10"
and "30":

6.4.3 The
event e;

This statement
initial
begin it causes them

#10; optional label
-> e; statement ovei
#20
-> e;

end module adc
always e parametE

$display($time); output 
input a,
reg [SI2

Here is an example of how an event could be used to model the adder: wire [S]
event ct

always 
sta

212 Verilog Digital Computer Design: Algorithms into Hardware



nically corfrfecet module adder(s,a,b);

iincclluude that the( parameter SIZE = 1, DELAY 0;
output s;
input a,b;
reg [SIZE-l:O] s;
wire [SIZE-l:0] a,b;

helpful in over- event change;

vents are used(
always @(a or b)

start-change;

always change
# DELAY s=a+b;

task startchange;
begin

s = 'bx;
-> change;

end
endtask

endmodule

Unfortunately, the above produces the same incorrect model of the adder (the correct
Introl. The ->-, result 123 is available too soon) for the same reasons discussed in the previous section.
Ing prints "-i1o0''

6.4.3 The disable statement
This statement causes Verilog to cease execution of a labeled block. For always blocks,
it causes them to restart at the top. (It has another use, explained in section 7.5.) An
optional label is given after a colon on a begin statement. Here is how the disable
statement overcomes the problem shown in the previous section:

module adder(s,a,b);
parameter SIZE = 1, DELAY = 0;
output s;
input a,b;
reg [SIZE-l:0 s;
wire [SIZE-l:0] a,b;
event change;

always (a or b)
startchange;

Designingf or Speed and Cost 213



F-

Continued
6.4.4 A c1(

always @change The reason we
begin : change-block

chines that 
# are

DELAY s=a+b;
end with PERIOD

module cl(
task start-change; param

begin
s = 'bx; outpu
disable change-block; reg c
#0; initi
-> change; clk

end alway
endtask beg

endmodule

The task startchange can be called many times from the first end
always block

without alway
$ time advancing. This way, every change in the inputs will be noticed by the if

Verilog scheduler. The only # control in startchange is #0. This is required so the endmodule
disable statement can take effect. After change block has been disabled, the
change event is retriggered. This, in turn, causes the full # DELAY before the output
changes from bx. Note that if PE

the situation in
The #DELAY is in the block (change_ block) which can be disabled. There is no
way that changes that occur in the middle of a #DELAY will be missed. Therefore,
instantiating a series of these adders will produce a correct model of the propagation 6.4.5 Prop
delay. For example, here is the simulation using the same test code as section 6.4. 1: Suppose the pr

parator and 10
4.4.5, simply in

$time= 0 t=x
module sloi

$time= 0 s=x
$time= 8 t= 0

input ali
$time= 18 s= 0

output r:
$time= 30 t=x

wire [5:(
$time= 30 s=x

wire mux
$time= 38 t= 120

wire [11
$time= 48 s= 123

wire [11

Note that s is bx from $time 30 until $time 48, as is predicted by worst case enabled

timing analysis. mux2
alul81

comparatc
not

214 Verilog Digital Computer Design: Algorithms into Hardware



6.4.4 A clock with a PERIOD parameter
The reason we wish to simulate propagation delays is ultimately to design faster ma-
chines that are clocked at higher frequencies. Therefore, it is desirable to have a clock
with PERIOD as a parameter:

module cl(clk);
parameter TIME_LIMIT = 110000,

PERIOD = 100;
output clk;
reg clk;
initial
clk = 0;

always
begin

#(PERIOD/2) clk = clk;
#(PERIOD-PERIOD/2) clk = -clk;

end
always block

always (posedge clk)
e noticed by the if ($time > TIMELIMIT) #(PERIOD-1) $stop;
; required so the endmodule
en disabled, the
efore the output

Note that if PERIOD is omitted in the instantiation, it will default to 100, as has been
the situation in all earlier simulations.

led. There is no
ised. Therefore,
the propagation 6.4.5 Propagation delay in the division machine
section 6.4. 1: Suppose the propagation delays are 70 for the ALU, 25 for the mux, 20 for the com-

parator and 10 for the inverter. To backannotate this in the original code of section
4.4.5, simply include the propagation delay parameter with the instantiation:
module slow divarch(aluctrl,muxctrl,ldrl,clrr2,

incr2,ldr3,rlgey,x,y,r3bus,sysclk);
input aluctrl,muxctrl,ldrl,clrr2,incr2,ldr3,x,y,sysclk;
output rgey,r3bus;
wire [5:0] aluctrl;
wire muxctrl,ldrl,clrr2,incr2,ldr3,rlgey,sysclk;
wire [11:0] x,y,r3bus;
wire [11:0] muxbus,alubus,rlbus,r2bus;

ab y worst caseI enabled-register #12 r(alubus,rlbus,ldrl,sysclk);
mux2 #(12,25) mx(x,y,muxctrl,muxbus);
alul8l #(12,70) alu(rlbus,muxbus,aluctrl[5:2],

aluctrl[l],aluctrl[0],,alubus,);
comparator #(12,20) cmp(rllty, , ,rlbus,y);
not #10 inv(rlgey,rllty);

are
Designingf or Speed and Cost 215



cl #(2000
counterregister #12 r2(,r2bus,,1'bO,incr2,clrr2,sysclk);

slow div_
enabled-register #12 r3(r2bus, r3bus,ldr3,sysclk);

x, y, qu

endmodule

The test code
When this is simulated with a clock period of 100, it works:

cl #(20000,100) clock(sysclk); 6365
slowdivsystem slowdiv machine(pb,ready,xy,

quotient,reset,sysclk);
error x=

as is illustrated by the following timing diagram:
because the A
of the clock.

rlbus[11:0] 13  14 7 0
r2bus[11:0] 0 1 2
r3bus[11:0] 1 6.5 Sing

pb The solution t
ready large amounts

.Idrl of doing com]
Incr2 computation c
clrr2 graphics (suci
Idr3 formulae at m

matter. You wi
muxbus[11:0 Ix 14 x 7 of the screen
alubus[11:0 I x I x | 141 x 117 x 0 screen, or if yc

muxctrl k141 that have cor
aluctrl[5:0] 101010 011001 such hardware

r gey U L I LI Ix result. These f
sysclk If cost were n

present-state[0:0] 0 1 solved by bui.
cessed. Each 

Figure 6-3. Timing diagramf or division machine with abstractp ropagationd elay. chines. Althotu
practical in m'

Because pract
A designer might want to experiment to see if the clock can be speeded up to have a cost is as or mr
period of, say, 90: that allow the

techniques are
these three te(
produced per 

216 Verilog Digital Computer Design: Algorithms into Hardware

L



ci #(20000,90) clock(sysclk);
5ysclk) 

slowdivsystem slow divmachine(pb,ready,
x,y,quotient,resetsysclk);

The test code will detect an error:

6365 rl=x r2= 2 r3= 1 pb=O ready=l
1 10 0 muxbus=x alubus=x x= 14 rlgey=x

muxctrl=O aluctrl=101010
error x= 14 y= 7 x/y= 2 quotient= 1

because the ALU will not have had a chance to stabilize by the time of the rising edge
of the clock.

7 0o

6.5 Single cycle, multi-cycle and pipeline
The solution to many problems involves performing the same kind of computation on
large amounts of independent data values. The term independent means that the result
of doing computation on one data value does not affect nor is affected by doing the
computation on any of the other data values. For example, three-dimensional computer
graphics (such as occur in virtual reality systems) usually require evaluating the same
formulae at millions of points. The order in which such points are processed does not
matter. You will get the same answer if you start processing on the lower-left-hand side

7 of the screen as you will get if you start processing on the upper-right-hand of the
I 'l screen, or if you process in any other order that you might choose. In problems like this

that have complete data independence, many possible hardware solutions exist. All
)11001 such hardware solutions are correct in that they all eventually arrive at the desired

result. These hardware solutions differ in terms of their speed and cost.

If cost were not a constraint, problems with totally independent data values could be
1 solved by building one combinational logic machine for each data value to be pro-

cessed. Each such machine could compute its answer in parallel to all the other ma-
gation delay. chines. Although this kind of massively parallel approach is sometimes used, it is not

practical in many situations due to cost constraints.

Because practical problems with perfectly independent data are commonplace where
I up to have a cost is as or more important than speed, three standard techniques have been developed

that allow the designer to choose the trade-off between speed and cost. These three
techniques are known as the single-cycle, pipelined, and multi-cycle approaches. What
these three techniques share in common is that no more than one complete result is
produced per clock cycle.

Designingf or Speed and Cost 217



At one extreme is the single-cycle approach. With the single-cycle approach, the result
for one of the independent values is completely (see section 

computed 8
(start to finish) in a single

clock cycle. The single-cycle approach is dress where 
perhaps es

the most natural approach to think
about, but it is usually which 

not the the con
most efficient.

At the opposite extreme is the Suppose 
multi-cycle a is 1

approach. With the multi-cycle approach, the
result for one of the independent when the mad

values requires several clock cycles to be computed.
Thinking about the multi-cycle approach is quite analogous to thinking about the soft-
ware paradigm (section 2.2.2). The multi-cycle approach is usually the slowest, but it xl
often requires minimum hardware because it can be implemented with a central ALU
(section 2.3.4). xl

In between the single-cycle approach and the multi-cycle approach is the pipelined
approach. The pipelined approach usually requires more hardware than the other ap-
proaches but often is the fastest and most efficient. In order to understand the pipelined
approach, it is necessary to investigate the two other approaches first. Figure6 -4.

As discussed earlier in this chapter, the total time required by a machine is the number
of clock cycles multiplied by the clock period. The three approaches discussed in this For example, 
section differ both in terms of the number of clock cycles required and the clock period.
We can understand the The 

algorithmic machine 
distinctions among these three approaches at the

behavioral stage and even predict the number 2.2.1. The mac
of clock cycles required at the behavioral

stage; however, we cannot state 
predict IDLE, it 1,

which approach will be fastest at the behavioral
stage. This is because the clock period IDLE 

is determined it will be
by the propagation delay in the

architecture, which we cannot predict until the mixed stage, or when the hardware has The following
been synthesized. be implemente

incorrect versic
solution 

6.5.1 is shot
Quadratic polynomial evaluator example

The quadratic polynomial a*x*x + b*x + c is a simple example of a formula that
a machine might evaluate many times with different values of x, but the same values of 6.5.2 Beha
a, b and c (which remain unchanged for a suitable period before, during and after the The ASM chart
quadratic evaluations). For each unique x value, the computation of the quadratic for- only needs to N
mula is independent of the computation for other values of x. Although the formulae approach provi
used for practical problems, such as computer graphics, are more complex than this each clock cycl
familiar old quadratic, the nature of the formulae in such practical problems is very the quadratic is
similar to this quadratic. stored into y at

Although a practical machine would probably store the x values in a synchronous Suppose the ma
memory, for the sake of simplicity in this example, assume the values of x are con- lowing two ASb
tained in a ROM. The goal of the machine is to evaluate the quadratic polynomial for possible fashior
each of these x values and store the corresponding y values into a synchronous memory cations and addi

218 Verilog Digital Computer Design: Algorithms into Hardware



oach, the result (see section 8.2.2.3.1 for how a synchronous 
ish) memory 

in a single can be implemented). The ad-
dress where each y value is stored should be the same 

proach as 
to the 

think address in the ROM from
which the corresponding x value was fetched.

Suppose a is 1, b is 2 and c is 3. If the contents 
e approach, of x are 

the as shown on the left in decimal,
when the machine is done, the contents of the y memory 

D be computed. will be as shown on the right:

about the soft-
slowest, but it x[O] Y[O]
a central ALU

x[1 ] Y[1]
x[2]

s the pipelined y[2]
In the other ap-
idt he pipelined

Figure 6-4. Example contents of x and yfor quadraticm achine.

e is the number
pscussed in this Forexample,y[2] = a*x[2]*x[2] + b*x[2] + c = 25+10+3 = 38.
e clock period. The machine will use a push button interface, similar to 
proaches the one described 

at the in section
2.2. 1. The machine will wait in state IDLE until pb is pressed. While 

t the behavioral the machine is in
state IDLE, it leaves the contents of y alone. 

the Some 
behavioral time after the machine leaves state

IDLE it will begin to fill y with the correct 
on results.

delay in the
ie hardware has The following sections will look at behavioral ASMs to illustrate how this machine can
i be implemented with the single-cycle, multi-cycle and pipelined approaches. Several

incorrect versions of pipelining will be presented before the final correct pipelined
solution is shown in section 6.5.7.

f' a formula that
same values of 6.5.2 Behavioral single cycle

11g and after the The ASM chart for the single-cycle approach is quite simple and obvious. The machine
e quadratic for- only needs to have a memory address (ma) register. The ma register in the single- cycle
Kthe  formulae approach provides the address used by both the x and y during each clock cycle. In

rnplex than this each clock cycle, the content of the ROM is fetched from the address indicated by ma,
roblems is very the quadratic is evaluated using the value of x fetched from the ROM and the result is

stored into y at the same address indicated by ma.

a synchronous Suppose the maximum memory address is the constant MAXMA. The first of the fol-
s of x are con- lowing two ASM charts (figure 6-5) describes the single-cycle approach in the simplest
polynomial for possible fashion. The computation of the quadratic actually involves several multipli-
ronous memory cations and additions. The second (equivalent) ASM chart (figure 6-6) makes this clearer:

Designingf or Speed and Cost 219



Since we do n
period is 00i
tions. Also, fc
initialized to
output, the $t
following line

349 ps=Ci
z

449 ps=OW
z

Figure 6-5. Behavioral single cycle ASM with only 549 ps=OC
-.

66

1149 ps=O(
66

1249 ps=O(
66

In state COMI
ROM. After g(
computes the!
cycle, the mac
but before the 
sum (ax2+bx
value appears

The number (
MAXMA+1, t

Figure 6-6. Equivalent single cycle ASM with = for combinational logic.
Here is the bet

Note the use of = rather than *- for the intermediate results (xl, x2, bx, ax2 and 'define N
bxc). As discussed in chapter 2, the = means that combinational logic computes all of 'define I
these values in one clock cycle. Note that x2 and bx are dependent on xl; ax2 is 'define C

dependent on x2; and bxc is dependent on bx. This means that the minimum clock module po

period for the single-cycle approach must allow enough time for the computations of input pb
output r

all of these intermediate results to stabilize. The amount of time it takes for the combi- wire pb,
national logic to finish computing these intermediate values is not something we can wire [11
predict at the behavioral stage. Up until this chapter, we have neglected such propaga- reg [11:
tion delays, but later in this chapter, we will estimate what these delays will be. reg read

reg [11:

220 Verilog Digital Computer Design: Algorithms into Hardware

L



Since we do not know how fast the machine can be clocked, let us assume that the clock
period is 100 units of Verilog $ time for the purpose of the following and later simula-
tions. Also, for reasons to be explained later, we will assume that each word in y is
initialized to bz prior to execution of this ASM. In the following partial simulation
output, the $time and registers are printed on one line with the contents of y on the
following line:

r7EI 349 ps=000 ma= 0 xl=x x2=x bx=x ax2=x bxc=x
z z z z z 

*X z z z
449 ps=001 ma= 0 xl= 7 x2=49 bx=14 ax2=49 bxc=17

z z z z z z z z
549 ps=001 ma= 1 xl= 6 x2=36 bx=12 ax2=36 bxc=15

66 z z z z z z z

1149 ps=001 ma= 7 xl= 0 x2= 0 bx= 0 ax2= 0 bxc= 3
66 51 38 27 18 11 6 z

1249 ps=000 ma= 8 xl=x x2=x bx=x ax2=x bxc=x
66 51 38 27 18 11 6 3

In state COMPUTEl at $ time 449, the machine obtains the value (7) of x1 from the
ROM. After getting this from the ROM, but during the same clock cycle, the machine

II computes the square (49), and the product (49) of a and the square. Also in this clock
cycle, the machine computes the product (bx= 14) of b and x1. After computing bx,
but before the end of the clock cycle, the machine computes the sum (bxc = 17) and the
sum (ax2 +bxc). This final result (66) is scheduled to be stored in the memory. This
value appears at the correct place (y [ 0 ] ) by $ time 549.
The number of clock periods required for this single cycle ASM to complete is
MAXMA+1, because one result is produced each clock cycle.

2Vgi;cC..
Here is the behavioral Verilog code used to produce the above simulation:

, bIx, aaxx2 and 'define NUMSTATEBITS 3
Vomaputes all of 'define IDLE 3'bOOO
Dn xi;; ax2  is 'define COMPUTEl 3'bOO1

inimnium clock module poly-system(pb,a,b,c,ready,sysclk);

)mTYmpuuttaattiions  of input pb,a,b,c,sysclk;

for the combi- output ready;
c

Jet wire pb,sysclk;
tetfhiing we can wire [11:0] a,b,c;
sSutch propaga- reg [11:0] x['MAXMA:0],y['MAXMA:0];
wiill be. re rd9N7

reg [11:0] ma;

re Designingf or Speed and Cost 221



-

Continued
reg [11:0] xl,x2,bx,ax2,bxc; ma <= '

reg ['NUMSTATEBITS-1:0] present_state;
integer i; y[ma] <=
initial
begin
for (i=0;i<='MAXMA;i=i+l) However, @( j
begin Verilog simul
x[i]='MAXMA-i; in Verilog: se
y[il='bz; new value to I
end save the right.

end specified cloc
always the behavior (
begin memory (y [rr
@(posedge sysclk) enternew-state('IDLE); memory until
ma <= @(posedge sysclk) 0; and y[ma] is
ready = 1; vendors, for r(
if (pb)
begin To overcome 
while (ma != 'MAXMA) statements in
begin The falling ed1
@(posedge sysclk) enternew state('COMPUTEl); non-blocking
ma <= (posedge sysclk) ma + 1; have the corre
xl = x[ma]; dependent con
x2 = xl*xl;
bx = b*xl; This is anothei
ax2 = a*x2; C. 1). In the pu
bxc = bx + c; memories at tl
y[ma] <= @(negedge sysclk) ax2 + bxc; lates the value:

end simulator arrai
end explores differ

end
endmodule chronous mem

ordinary regist
significant to d

Note that the order of the intermediate computations (=) matters in Verilog. all <=, there iP
The non-blocking assignment to the memory location, y [ma], uses @( negedge about clock fre
sysclk) rather than the @( posedge sysclk) typical for non-blocking assign-
ment to ordinary registers (see section 3.8.2). The problem here arises because new
values are stored into distinct elements of y during every clock cycle. Some simulators
will do the proper thing in a situation like this even if you were to use:

1There are no depe

222 Verilog Digital Computer Design: Algorithms into Hardware



ma <= (posedge sysclk) ma + 1;

y[mal <= (posedge sysclk) ax2 + bxc; // not portable
I

However, @( negedge sysclk) is necessary to produce the correct result on other
Verilog simulators. To understand why, remember that there are two separate concepts
in Verilog: sequence and $time. A non-blocking assignment by itself will cause the
new value to be stored as the last event at the specified $ time. All Verilog simulators
save the right-hand expressions (ax2 + bxc and ma + 1 in this example) until the
specified clock edge. For left-hand values that are not arrays, this is sufficient to model
the behavior of synchronous registers. But when you are dealing with a synchronous
memory (y [ma]), aVerilog simulator must also save the address (ma) for the left-hand
memory until the next clock edge. The sequence in which a simulator will update ma
and y [ma] is not defined. The Verilog standard is ambiguous on this issue, and some
vendors, for reasons of efficiency, have chosen not to save the address.
To overcome this problem at the pure behavioral stage, we need to remember that the
statements in a particular state will execute one unit of $time after the rising edge.
The falling edge of the system clock will occur prior to the next rising edge, but after all
non-blocking assignments of this state have been scheduled. Therefore, ma will still
have the correct value, but changing y [ma] at the falling edge will not disturb some
dependent computations' within this state.
This is another illustration of choosing an appropriate level of abstraction (see section
C. 1). In the pure behavioral stage, we are only interested in the values of registers and
memories at the moment of the rising edge. The negedge memory approach simu-
lates the values at the rising edge properly on all Verilog simulators. How a particular
simulator arranges to simulate between the rising edges is irrelevant as the designer
explores different algorithmic possibilities. Of course, in the actual architecture, a syn-
chronous memory will change its values only at the rising edge, synchronously to the
ordinary registers in the design. At the mixed or later stages of design, such details are
significant to determine the proper clock frequency, but since the mixed stage removes

irillogg.. all <=, there is no problem. Before the mixed stage, the designer should not worry
about clock frequency; thus the negedge memory 

s approach is perfectly acceptable.
,s  @ ((negedge
blocking assign-

es because newv
Soonmi e simulators

l There are no dependent computations in this example.

Designingf or Speed and Cost 223



6.5.3 Behavioral multi-cycle 349 ps=OO(
The single-cycle approach discussed in the previous section does all of the intermedi- z
ate computations in one clock cycle. The multi-cycle approach, ol. the other hand, does 449 ps=OCI
each intermediate computation in a separate clock cycle. This of course means it takes z
several clock cycles to produce one result. In the multi-cycle approach, each intermedi- 549 ps=O1(
ate result is stored in a register, thus the ASM uses the - notation. The multi-cycle z

approach is like the software paradigm (section 2.2.2), where each intermediate com- 649 ps=O11

putation occurs in a separate rectangle by itself. Here is an ASM z
chart for the multi-

749 ps=10C
cycle version of the quadratic evaluator:

_ ._
5249 ps=OOC

66

In state COMPI
x[ma]=x[0]='
around $time 5
which shows up 
(14) of x1 and b
state COMPUTE
loaded into ax2,
849, the sum of b
by $time 949. F
bxc is scheduled

The number of,
6*(MAXMA+I).

Figure 6-7. Behavioral multi-cycle ASM. cycle approach o1
to predict the prol

This machine has six registers (ma, x1, x2, bx, ax2 and bxc), and has six determines the m;
states inside the loop. Here is a partial simulation, again assuming a clock period of 100 in each clock cyc
(which may be much longer than is actually required): the single-cycle 

thing we can onl3

Here is the behav

224 Verilog Digital Computer Design: Algorithms into Hardware



349 ps=000 ma= 0 xl=x x2=x bx=x ax2=x bxc=x
)f the intermedi- z z z z z z z z
other hand, does 449 ps=001 ma= 0 xl=x x2=x bx=x ax2=x bxc=x
,e means it takes z z z z z z z z

each intermedi- 549 ps=010 ma= 0 xl= 7 x2=x bx=x ax2=x bxc=x
The multi-cycle z z z z z z z z

termediate corn- 649 ps=011 ma= 0 xl= 7 x2=49 bx=x ax2=x bxc=x

t for the multi- z z z z z z z z
749 ps=100 ma= 0 xl= 7 x2=49 bx=14 ax2=x bxc=x

z z z z z z z z
849 ps=101 ma= 0 xl= 7 x2=49 bx=14 ax2=49 bxc=x

z z z z z z z z
949 ps=110 ma= 0 xl= 7 x2=49 bx=14 ax2=49 bxc=17

z z z z z z z z
1049 ps=001 ma= 1 xl= 7 x2=49 bx=14 ax2=49 bxc=17

66 z z z z z z z

52.4.9. ps=000 ma= 8 xl= 0 x2= 0 bx= 0 ax2= 0 bxc= 3
66 51 38 27 18 11 6 3

In state COMPUTE1 around $time 449, x is scheduled to be loaded with
x[ma]=x[0]=7. This change in x1 shows up by $time 549. In state COMPUTE2
around $ time 549, the square (49) of this value is scheduled to be loaded into x2,
which shows up by $ time 649. In state COMPUTE3 around $ time 649, the product
(14) of x1 and b is scheduled to be loaded into bx, which shows up by $time 749. In
state COMPUTE4 around $ time 749, the product (49) of a and x2 is scheduled to be
loaded into ax2, which shows up by $ time 849. In state COMPUTE5 around $ time
849, the sum of bx and c (17) is scheduled to be loaded into bxc, which also shows up
by $ time 949. Finally, in state COMPUTE6 around $ time 949, the sum of ax2 and
bxc is scheduled to be loaded into y, and this shows up by $ time 1049.
The number of clock periods required for this multi-cycle ASM to complete is
6*(MAXMA+1). Although at first glance, this appears much slower than the single-
cycle approach of section 6.5.2, it need not be that much slower. Later we will be able
to predict the propagation delay of the architecture for the multi-cycle approach (which

,c), and has six determines the maximum clock frequency). Since there is less computation being done
:k period of 100 in each clock cycle, it should be possible to clock the multi-cycle machine faster than

the single-cycle machine. The relative performance of these two machines is some-
thing we can only predict given a structural architecture.
Here is the behavioral Verilog code used to produce the above simulation:

Designingf or Speed and Cost 225



- P-

The pipelined
'define NUM_STATEBITS 3
'define IDLE 3'bOOO (correspondin
'define COMPUTEl 3'bOOl two approach
'define COMPUTE2 3'bOlO parallel to the
'define COMPUTE3 3'bOll computations
'define COMPUTE4 3'blOO amount of ind
'define COMPUTE5 3'blOl
'define COMPUTE6 3'bllO A pipelined ir

because they
always each worker ii
begin tion line. For
@(posedge sysclk) enternew-state('IDLE);
ma <= (posedge sysclk) 0;

item
ready = 1; untig
if (pb) unwE
begin unpa
while (ma != 'MAXMA)
begin
P(posedge sysclk) enternewstate('COMPUTEl);
xl <= P(posedge sysclk) x[ma];
@(posedge sysclk) enternewstate('COMPUTE2);
x2 <= (posedge sysclk) xl*xl;
P(posedge sysclk) enternewstate('COMPUTE3); /
bx <= (posedge sysclk) b*xl; w
@(posedge sysclk) enternewstate('COMPUTE4);
ax2 <= (posedge sysclk) a*x2; Figure 6-8.
@(posedge sysclk) enternewstate('COMPUTE5);
bxc <= P(posedge sysclk) bx + c;
@(posedge sysclk) enternewstate('COMPUTE6); Worker #1 mi
ma <= (posedge sysclk) ma + 1; paint the item
y[ma] <= (negedge sysclk) ax2 + bxc; worker #1 is t

end item #2 (whic
end (which has it

end the correct se,
welding and p

6.5.4 First attempt at pipelining With this anal

The single-cycle approach puts all the computation steps into one clock cycle but uses tions ( <- ) in
= (corresponding only to combinational logic) for the intermediate results. The multi- from a differ
cycle approach spreads the computation steps across separate clock cycles, but uses - factory-like ol
(corresponding to registers) for the intermediate results. The pipelined approach is half-
way between these two approaches.

226 Verilog Digital Computer Design: Algorithms into Hardware



The pipelined approach puts all the computation steps into one clock cycle and uses <-
(corresponding to registers) for the intermediate results. This means, unlike the other
two approaches, each intermediate computation in the pipelined approach occurs in
parallel to the other intermediate computations. The only reason that the intermediate
computations can occur in parallel is that a machine like this is processing a large
amount of independent data in an identical fashion.

A pipelined machine is very much like a factory assembly line. Factories are efficient
because they mass produce many copies of an identical item. At each point in time,
each worker in the factory does one thing to a partially assembled item on the produc-
tion line. For example:

worker #1 worker #2 worker #3

Figure 6-8. Analogy to factory.

Worker #1 might tighten a bolt, worker #2 might weld a seam and worker #3 might
paint the item. Each worker acts in parallel to the other workers. In the above picture,
worker #1 is tightening the bolt on item #3 at the same time that worker #2 is welding
item #2 (which already has its bolt tightened) and that worker #3 is painting item #1
(which has it bolt tightened and which has been welded). Each item has experienced
the correct sequence in order (tightening, welding and painting), but the tightening,
welding and painting that happens at any given instance occurs to independent items.
With this analogy in mind, we can understand that each of the intermediate computa-

k cycle but uses tions ( - ) in the pipelined quadratic evaluator produces an intermediate result derived
;ults. The multi- from a different x value. Here is a first (somewhat flawed) attempt to describe the
cles, but uses - factory-like operation of this pipelined system:
Ipproach is half-

are Designingf or Speed and Cost 227



There are sever
sider what is air
be loaded with:
$time 549, th
shows up by $t
loaded into bx,
(49) of a and x
In parallel, the
shows up by $
scheduled to be

The problem at
wrong address:
the clock cycles
Instead it stores

Figure 6-9. Incorrectp ipelined ASM. the machine coI
is stored into y.

Here is a simulation showing how this ASM malfunctions: In addition to sl
another flaw. It
results needed t

349 ps=000 ma= 0 xl=x x2=x bx=x ax2=x bxc=x returns to state:
z z z z z z z z

Another, less ot
449 ps=001 ma= 0 xl=x x2=x bx=x ax2=x bxc=x

z z z z z z z z memory during
549 ps=001 ma= 1 xl= 7 x2=X bx=4094 ax2=4095 bxc=x than bx to hig

x z z z z z z z
649 ps=001 ma= 2 xl= 6 x2=49 bx= 14 ax2= 1 bxc= 1

x x z z z z z z 6.5.5 Pipel
749 ps=001 ma= 3 xl= 5 x2=36 bx= 12 ax2= 49 bxc=17 The major prof

x x 2 z z z z z used to store in
849 ps=001 ma= 4 xl= 4 x2=25 bx= 10 ax2= 36 bxc=15 problem, we ca

x x 2 66 z z z z save the memor
949 ps=001 ma= 5 xl= 3 x2=16 bx= 8 ax2= 25 bxc=13 mal is the valu

x x 2 66 51 z z z ago, and ma3 is
1049 ps=001 ma= 6 xl= 2 x2= 9 bx= 6 ax2= 16 bxc=11

x x 2 66 51 38 z z
1149 ps=001 ma= 7 xl= 1 x2= 4 bx= 4 ax2= 9 bxc= 9

x x 2 66 51 38 27 z
1249 ps=000 ma= 8 xl= 0 x2= 1 bx= 2 ax2= 4 bxc= 7

x x 2 66 51 38 27 18

228 Verilog Digital Computer Design: Algorithms into Hardware



There are several problems with this, but before discussing what is wrong, let us con-
sider what is almost right. In state COMPUTE1 around $ time 449, xi is scheduled to
be loaded with x [ma] =x [ 0] = 7. This change in x1 shows up by $ time 549. Around
$time 549, the square (49) of this value is scheduled to be loaded into x2, which
shows up by $ time 649. In parallel, the product (14) of x1 and b is scheduled to be
loaded into bx, which also shows up by $ time 649. Around $ time 649, the product

:11 (49) of a and x2 is scheduled to be loaded into ax2, which shows up by $time 749.
In parallel, the sum of bx and c (17) is scheduled to be loaded into bxc, which also
shows up by $time 749. Finally, around $time 749, the sum of ax2 and bxc is
scheduled to be loaded into y, and this shows up by $ time 849.
The problem at $ time 849 is that although 66 is the correct value, it shows up at the
wrong address for y. This is because ma has necessarily been incremented in each of
the clock cycles. This machine has forgotten that the 66 is supposed to stored at y[0.
Instead it stores it at y[3]. Aside from the fact that the addresses to y are offset by three,
the machine continues to compute a correct result each clock cycle. By $ time 949, 51
is stored into y. By $ time 1049, 38 is stored into y, and so forth.
In addition to storing the correct results at the wrong addresses, this machine also has
another flaw. It does not finish the complete job (storing 11, 6 and 3). The intermediate
results needed to produce 11, 6 and 3 are left frozen in the pipeline when the machine

C=x returns to state IDLE.

Another, less obvious, flaw is that garbage values ( ' bx, 
C'= 'bx and 2) are stored 

=X into the
memory during the first clock cycles (449, 549 and 649). Initializing yto bz rather

C'='=X than bx to highlights this flaw.

r-= 1
6.5.5 Pipelining the ma

cC-=1717 The major problem with the ASM chart of section 6.5.4 is that the memory address
used to store into y does not correspond to the value being stored. To overcome this

c-=1515 problem, we can introduce three additional registers, mal, ma2 and ma3, that will
save the memory addresses from the previous three clock cycles. In a given clock cycle,

p-==113133 mal is the value of ma one clock cycle ago, ma2 is the value of ma two clock cycles
ago, and ma3 is the value of ma three 

C-1=111
clock cycles ago.

cC-= 9

c-= 7

v,areree Designingf or Speed and Cost 229



Continued.

1049 ps=OC

66
1149 ps=OC

66
1249 ps=OC

66

Although the;
vised ASM sti]
in the ASM of
left frozen in tf
('bx, bx ai

Figure 6-10. PipelinedA 
though 

SM with now th,
multiple addresses but withoutflush.

Here is a simulation that shows how addresses flow through the ma pipeline: 6.5.6 Flus
In order to pre
some addition,

349 ps=000 ma= 0 xl=x x2=x bx=x ing to the facto
mal= 0 ax2=x bxc=x ma2= 0 ma3= 0 model item, w

z z z z z z z z tasks on the las
449 ps=001 ma= 0 xl=x x2=x bx=x #3. So it is wit

mal= 0 ax2=x bxc=x ma2= 0 ma3= 0
z z z z z z z z The ASM nee(

549 ps=001 ma= 1 xl= 7 x2=X bx=4094 quired comput
mal= 0 ax2=4095 bxc=x ma2= 0 ma3= 0 data, the comp

x z z z z z z z flushing state,
649 ps=001 ma= 2 xl= 6 x2= 49 bx= 14 successive stat

mal= 1 ax2= 1 bxc= 1 ma2= 0 ma3= 0
x z z z z z z z

749 ps=001 ma= 3 xl= 5 x2= 36 bx= 12
mal= 2 ax2= 49 bxc= 17 ma2= lma3= 0

2 z z z z z z z
849 ps=001 ma= 4 xl= 4 x2= 25 bx= 10 6.5.7 Filli

mal= 3 ax2= 36 bxc= 15 ma2= 2 ma3= 1
66 Z Z z z z z z The reason thai

949 ps=001 ma= 5 xl= 3 x2= 16 bx= 8 because of the
mal= 4 ax2= 25 bxc= 13 ma2= 3 ma3= 2 cycles when st

66 51 z z z z z z values. Therefc

230 Verilog Digital Computer Design: Algorithms into Hardware



Continued.

1049 ps=001 ma= 6 xl= 2 x2= 9 bx= 6
mal= 5 ax2= 16 bxc= 11 ma2= 4 ma3= 3

66 51 38 z z z z z
1149 ps=001 ma= 7 xl= 1 x2= 4 bx= 4

mal= 6 ax2= 9 bxc= 9 ma2= 5 ma3= 4
66 51 38 27 z z z z

1249 ps=000 ma= 8 xl= 0 x2= 1 bx= 2
mal= 7 ax2= 4 bxc= 7 ma2= 6 ma3= 5

66 51 38 27 18 z z z

Although the addition of mal, ma2 and ma3 solves the addressing problem, the re-
vised ASM still does not finish the complete job (storing 11, 6, and 3). As was the case
in the ASM of section 6.5.4, the intermediate results needed to produce 11, 6 and 3 are
left frozen in the pipeline when the machine returns to state IDLE. Also, garbage values
( bx, bx and 2) are still stored into the memory during the first clock cycles, al-

uIsh.. though now they are stored in y [ 0 ] each time.

ippifpeeellilininee: 6.5.6 Flushing the pipeline
In order to prevent the final values from being frozen in the pipeline, there need to be
some additional clock cycles spent "flushing" those values out of the pipeline. Return-
ing to the factory analogy, when the factory is about to cease production of a particular
model item, worker #1 can stop work earliest, but the other workers must finish their
tasks on the last item worker #1 tightened. Similarly, worker #2 can stop before worker
#3. So it is with flushing the pipeline.

The ASM needs three states, FLUSH1, FLUSH2 and FLUSH3, that perform the re-
quired computations on the valid data in the pipeline. For those registers that have valid
data, the computations are identical to those in state COMPUTE . At each successive
flushing state, there are fewer registers in the pipeline that contain valid data; thus each
successive state has fewer computations to perform.

* 0

6.5.7 Filling the pipeline
1

The reason that garbage values have been stored by all the previous pipeline attempts is
because of the assignment to y [ma3] in state COMPUTEI. During the first clock

2 cycles when state COMPUTE1 executes, ma3, ax2 and bxc do not have legitimate
values. Therefore, to store ax2 +bxc at address ma3 is illegitimate. The situation is the

vare Designingf or Speed and Cost 231



opposite problem from flushing the pipeline. In this case, the pipeline must be filled 349 ps=OOO
prior to storing the first result in y. The following is a completely correct pipelined
ASM that accomplishes this operation by introducing states FILL 1, FILL2 and FILL3: z

449 ps=O10

z
RE

FILL1 549 ps=Oll

0 1 ma ma+1
p mal-ma z

xl-x[ma] 649 ps=100

FILL2 ma-ma + 1 z
mal-ma 749 ps=OOl
ma2- mal
x1 - x[ma]
x2-xl*xl z
bx- b*xl 849 ps=OOl

FILL3 -ma- ma + 1 66
mal - ma

. . .
Ma2- mal
ma3- ma2
x1- x[ma] The rest of the
x2-xl*xl Verilog code u
bx-b*xl
ax2-a*x2 'define N
bxc-bx + c 'define I

I-
'define C

maF=MASH 1 'define F

FLUSH1 I ma-ma~ +~C1O MPUTE1 'define E
FL- - 'define F

ma2- mal mal-ma 'define E
ma3- ma2 ma2-mal
x2- xl*x1 'define E

ma3- ma2
bx- b*xl x1" -x[ma] 'define I
ax2- a*x2 x2 x1*x1
bxc- bx + c bx - b*xl always
y[ma3]-- ax2 + bxc ax2- a*x2 begin

bxc- bx + c @ (pose(
ma3- ma2 y[ma] - ax2 + bxc ma <=
ax2- a*x2 4. ready
bxc- bx + c if (pI
y[ma3]-ax2 + bxc begii

FLUSH3 (c
|y[ma3]--ax2 + bxc ma

ma:

Figure 6-11. Correctp ipelinedA SM thatfills andf lushes. xl
8( p(

Here ma
is a simulation that shows the proper values filling the pipeline:

232 Verilog Digital Computer Design: Algorithms into Hardware



line must be filled 349 ps=000 ma= O xl=x x2=x bx=x
correct pipelined mal= O ax2=x bxc=x ma2= 0 ma3= 0

FILL2 and FILL3: z z z z z z z z
449 ps=O10 ma= O xl=x x2=x bx=x

mal= O ax2=x bxc=x ma2= 0 ma3= 0
z z z z z z z z

549 ps=Oll ma= 1 xl= 7 x2=x bx=x
mal= O ax2=x bxc=x ma2= 0 ma3= 0

z z z z z z z z
649 ps=100 ma= 2 xl= 6 x2=49 bx=14

mal= 1 ax2=x bxc=x ma2= 0 ma3= 0
z z z z z z z z

749 ps=00l ma= 3 xl= 5 x2= 36 bx= 12
mal= 2 ax2=49 bxc=17 ma2= 1 ma3= 0

z z z z z z z z
849 ps=00l ma= 4 xl= 4 x2= 25 bx= 10

mal= 3 ax2=36 bxc=15 ma2= 2 ma3= 1
66 z z z z z z z

The rest of the simulation is similar to the previous example. Here is the behavioral
Verilog code used to produce the simulation of the correct pipelined machine:

'define NUMSTATEBITS 3
'define IDLE 3'bOOO
'define COMPUTE1 3'bOOl
'define FLUSH1 3'blOl

UTE1I 'define FLUSH2 3'bllO
'define FLUSH3 3'blll
'define FILL1 3'bOlO
'define FILL2 3'bOll
'define FILL3 3'blOO

always
begin
@(posedge sysclk) enter newstate('IDLE);
ma <= @(posedge sysclk) 0;
ready = 1;
if (pb)
begin
@(posedge sysclk) enternew state('FILLl);
ma <= @(posedge sysclk) ma + 1;
mal <= @(posedge sysclk) ma;
xl <= @(posedge sysclk) x[ma];
@(posedge sysclk) enternew state('FILL2);
ma <= @(posedge sysclk) ma + 1;

iawaairee DesigningforS peed and Cost 233



Continued. As described i
mal <= @(posedge sysclk) ma; with many Ver
ma2 <= @(posedge sysclk) mal;
xl <= @(posedge sysclk) x[ma];
x2 <= @(posedge sysclk) xl*xl; 6.5.8 Arc
bx <= (posedge sysclk) b*xl; Only by procei
@(posedge sysclk) enter_new state('FILL3); mum speed of
ma <= @(posedge sysclk) ma + 1; and pipelined
mal <= @(posedge sysclk) ma; tecture approp
ma2 <= @(posedge sysclk) mal; combinational
ma3 <= @(posedge sysclk) ma2;
xl (adders 

<= @(posedge and m
sysclk) x[ma];

x2 <= @(posedge sysclk) xl*xl; differ only wit
bx <= @(posedge sysclk) b*xl; registers. The 
ax2 <= @(posedge sysclk) a*x2;
bxc <= @(posedge sysclk) bx + c;
while (ma != 'MAXMA) 6.5.8.1 Si1
begin The behavioral
@(posedge sysclk) enternewstate('COMPUTEl); tions that must
ma <= @(posedge sysclk) ma + 1; lowing architect
mal <= @(posedge sysclk) ma;
ma2 <= @(posedge sysclk) mal;
ma3 <= @(posedge sysclk) ma2;
xl <= @(posedge sysclk) x[ma]; cj
x2 <= @(posedge sysclk) xl*xl;
bx <= @(posedge sysclk) b*xl;
ax2 <= @(posedge sysclk) a*x2;
bxc <= @(posedge sysclk) bx + c;
y[ma3l <= @(negedge sysclk) ax2 + bxc;

end
@(posedge sysclk) enter_new state('FLUSHl);
ma2 <= @(posedge sysclk) mal;
ma3 <= @(posedge sysclk) ma2;
x2 <= @(posedge sysclk) xl*xl;
bx <= @(posedge sysclk) b*xl;
ax2 <= @(posedge sysclk) a*x2; Figure 6-12
bxc <= @(posedge sysclk) bx + c;
y[ma3] <= @(negedge sysclk) ax2 + bxc; The ma registe
@(posedge sysclk) enternew-state('FLUSH2);

against MAXN
ma3 <= @(posedge sysclk) ma2;
ax2 <= @(posedge sysclk) a*x2; There are three
bxc <= @(posedge sysclk) bx + c; from the ROM
y[ma3l <= @(negedge sysclk) ax2 + bxc; produces the sc
@(posedge sysclk) enter new state('FLUSH3); that multiplies
y[ma3] <= @(negedge sysclk) ax2 + bxc;

end

234 Verilog Digital Computer Design: Algorithms into Hardware

j



w

As described in section 6.5.2, the use of negedge memory modeling is necessary
with many Verilog simulators.

6.5.8 Architectures for the quadratic evaluator
Only by proceeding to the mixed stage of the top-down design process can the maxi-
mum speed of the quadratic evaluator be estimated for the single-cycle, multi-cycle
and pipelined versions. The mixed stage for each version requires choosing an archi-
tecture appropriate for each algorithm. Since the computations (to be performed by
combinational logic) in each version are identical, the combinational logic devices
(adders and multipliers) in these three versions will be identical. The three versions
differ only with respect to whether and when intermediate computations are saved in
registers. The following sections describe the architectures for these three versions.

6.5.8.1 Single-cycle architecture
The behavioral single-cycle ASM charts in section 6.5.2 describe all of the computa-
tions that must occur in one clock cycle before a result can be loaded into y. The fol-
lowing architecture implements these computations:

MAXMA maeqmax
incma

cI

ma 12

>~ ~ * * + y
ROM 1 a 12

12 

b2C  1 Idy

Figure 6-12. Single-cycle architecture.

The ma register provides the same address to x and y. The mabus is also compared
against MAXMA to produce the status signal maeqmax.

There are three multipliers in the architecture. The ma register selects a particular word
from the ROM. This value is fed to the first two multipliers. One of these multipliers
produces the square, and the other multiplies this value by b. There is a third multiplier
that multiplies the square by a.

are DesigningforS peed and Cost 235



There are also two adders in the architecture. The first adder produces the sum of bx
and Continued

c. The other adder produces the final result. The final result is loaded into y [ma ]
when the dy signal is asserted. counter_

The comparat
following Verilog code shows the definition of this single-cycle architecture, along rom

with the corresponding mixed controller:
multipli

module poly ctrl(pb,maeqmax,ldy,incma,clrma,ready,sysclk); multipli
input pb,maeqmax,sysclk; multipli
output ldy,incma,clrma,ready; adder
wire pb,maeqmax,sysclk; adder
reg ldy,incma,cirma,ready;
reg ['NUMSTATE_BITS-l:0] present_state; ram
always endmodule
begin
@(posedge sysclk) enternew state('IDLE); In the above,
//ma <= (posedge sysclk) 0; adders are 2
ready = 1;

which is just
clrma = 1;
if (pb) result is clod
begin Verilog simul
while (-maeqmax)
begin
@(posedge sysclk) enternewstate('COMPUTEl);
//ma <= @(posedge sysclk) ma + 1; present-state[
//x2 = x[ma]*x[ma];
//bx = b*x[ma];
//ax2 = a*x2; mabus[1
//bxc = bx + c;
//y[ma] <= (negedge sysclk) ax2 + bxc; xbus[l
incma = 1;
ldy = 1; x2[1.

end
end bx[V

end
. . . ax2[1 
endmodule

bxc[ 1
module polyarch(maeqmax,ldy,incma,clrma,a,b,c,sysclk);
output maeqmax; s[1 1
input ldy,incma,clrma,a,b,c,sysclk;
wire maeqmax,ldy,incma,clrma,sysclk;
wire [11:0] SYS

a,b,c;
wire [11:0] x2,bx,ax2,bxc,xbus,ydibus,mabus;

Figure 6-1

236 Verilog Digital Computer Design: Algorithms into Hardware



- F_

the sum of bx Continued
ed into y [ma ]

counter-register #12 ma(,mabus,,l'bO,incma,clrma,sysclk);
comparator #12 cmp(,maeqmax,,mabus,'MAXMA);

Litecture, along rom #(12,23) x(mabus,xbus);

multiplier #(12,24) ml(x2,xbus,xbus);
ysclk); multiplier #(12,24) m2(bx,b,xbus);

multiplier #(12,24) m3(ax2,a,x2);
adder #(12,25) al(bxc,bx,c);
adder #(12,25) a2(ydibus,ax2,bxc);

ram #12 y(ldy,mabus,ydibus,,sysclk);
endmodule

In the above, it is assumed that the propagation delays of the ROM, multipliers and
adders are 23, 24 and 25 units of $time, respectively. 'CLOCKPERIOD is 100,
which is just barely long enough for all the combinational logic to stabilize before a
result is clocked into y, as illustrated by the following timing diagram produced by a
Verilog simulator:

646 662 678 694 710 728 742
,,1,i1 1 1 ,,,,,, ,,,,,,,,,1I I ,,,, ,,,,l1111,,,,,,I11111,,,,,,l,,,,,,,,,l11

present state[2:01M 001

mabus[1 1:0] 21 3 l

xbus[1 1:0] 51 x 1 4 l

x2[11:0] 251 x | 16 l

bx[11:0] 10| x | 8 |

ax2[11:0] 251 x | 16 l

bxc[11:0] 131 x I 11

s[11:0] W 38 x 27 

sysclk I F-
-

Figure 6-13. Timing diagramf or single-cycle ASM.

Designingf or Speed and Cost 237



6.5.8.2 Multi-cycle architecture always
The behavioral multi-cycle ASM chart in section 6.5.3 can be implemented by many begin
different possible architectures. Some of these possible architectures could be consid- @(posedg

erably cheaper than the architecture presented in this section; however, the architecture //ma <=

in this section was chosen for its consistency with the architecture in the previous sec- clrma =

tion: ready =
if (pb)
begin
while
begi
(P

l-
id
(P
/-
id

//
(P
id

@(P
//
id

Figure 6-14. Multi-cycle architecture.

id
The only difference between this architecture and the previous architecture is the inser-
tion of registers for xl, x2, bx, ax2 and bxc. As indicated by the ASM chart, it
takes six clock cycles for each computation to travel through this architecture. In the
first cycle, only ldxl is asserted. In the second cycle, only ldx2 is asserted. In the in
third cycle, only ldbx is asserted. In the fourth cycle, only dax2 is asserted. In the
fifth cycle, only ldbxc is asserted. In the sixth cycle, finally dy and incma are end

asserted. end
end

As mentioned above, this is not a particularly efficient architecture for the multi-cycle
approach because in any given clock cycle, five-sixths of the architecture is not per- counter-i

forming any useful computation. Nevertheless, the insertion of the registers allows this comparatc

architecture to be clocked considerably faster than the architecture in section 6.5.8.1. rom
enabledz

The following Verilog code shows the definition of this multi-cycle architecture, along multipliE
with the corresponding mixed controller: enabledz

multipliE
enabledz
multipliE
enabledz

adder

238 Verilog Digital Computer Design: Algorithms into Hardware



always
,d by many begin
I be consid- @(posedge sysclk) enternew-state('IDLE);
irchitecture //ma <= @(posedge sysclk) 0;

evious sec- clrma = 1;
ready = 1;
if (pb)
begin
while (maeqmax)

begin
@(posedge sysclk) enternewstate('COMPUTEl);
//xl <= @(posedge sysclk) x[ma];
ldxl = 1;
@(posedge sysclk) enter_newstate('COMPUTE2);
//x2 <= @(posedge sysclk) xl*xl;
ldx2 = 1;
@(posedge sysclk) enternewstate('COMPUTE3);
//bx <= @(posedge sysclk) b*xl;

Idy ldbx = 1;
@(posedge sysclk) enternewstate('COMPUTE4);
//ax2 <= @(posedge sysclk) a*x2;
ldax2 = 1;

@(posedge sysclk) enternewstate('COMPUTE5);
//bxc <= @(posedge sysclk) bx + c;
ldbxc = 1;

s the inser- @(posedge sysclk) enter_newstate('COMPUTE6);
M chart, it //ma <= @(posedge sysclk) ma + 1;
ture. In the //y[ma] <= @(negedge sysclk) ax2 + bxc;
rted. In the incma = 1;
rted. In the ldy = 1;
incma are end

end
end

nulti-cycle
is not per- counterregister #12 ma(,mabus,,lbO,incma,clrma,sysclk);
allows this comparator #12 cmp(,maeqmax,,mabus, 'MAXMA);

)n 6.5.8.1. rom #(12,23) x(mabus,xbus);
enabledregister #12 x1(xbus,xlbus,ldxl,sysclk);

ture, along multiplier #(12,24) ml(x2dibus,xlbus,xlbus);
enabled_register #12 x2(x2dibus,x2dobus,ldx2,sysclk);
multiplier #(12,24) m2(bxdibus,b,xlbus);
enabledregister #12 bx(bxdibus,bxdobus,ldbx,sysclk);
multiplier #(12,24) m3(ax2dibus,a,x2dobus);
enabledregister #12 ax2(ax2dibus,ax2dobus

ldax2,sysclk);
adder #(12,25) al(bxcdibus,bxdobus,c);

Designingf or Speed and Cost 239



-

Continued
6.5.8.3 

enabledregister #12 bxc(bxcdibus,bxcdobus The correct
ldbxc,sysclk); three additic

adder #(12,25) a2(ydibus,ax2dobus,bxcdobus); ters inserted
ram #12 y(ldy,mabus,ydibus,,sysclk); referred to 

pipeline regi
In the above, it is assumed that the propagation delays are the same as in the single-
cycle approach of section 6.5.8.1. With the multi-cycle approach, 'CLOCKPERIOD MAXMA-
can now be 26 in this example, which is nearly four times faster than the single-cycle
approach. incmar_1

The faster clock is possible because there is less logic that has to stabilize crma
before each intermediate result is clocked into one of the registers. The following tim-
ing diagram illustrates this:

ma 12

870 895 920 945 970 995 1020
1 1 1 1 1 1 1 1 11  1 1II I III II IIII  l IlIlI I Il  I  Il Ili I I1  1 IIIIIIII

present state[2:0] I 001 010 011l 100 I 101 110 001 _J
xbus[11:0] xl I x I

x1 bus[11:0] 4 3
x2dibus[11:0] 16 x

x2dobus[11:0] 16 9
ax2dibus[1 Figure 

1:0] 6-1
16

ax2dobus[11:0] 16 9
Notice that th

bxdibus[1 1:0] 8 x drawn in the
bxdobus[11:0] 8 6 the next pipe
bxcdibus[11:0] 11 pipeline regis

X
binational lot

bxcdobus[11:0] 11 9 register is kn(
ydibus[1 1:0] 27 x x The second p
mabus[11 :0] third stage ini

4
(This architec

sysclk though it just

Figure 6-15. Timing diagramf or multi-cycle. The followin1
with the corre

240 Verilog Digital Computer Design: Algorithms into Hardware

I k



6.5.8.3 Pipelineda rchitecture
The correct behavioral ASM for the pipelined method given in section 6.5.7 requires
three additional registers: mal, ma2 and ma3. In a pipelined design, all of the regis-

us) ters inserted in the single cycle architecture to make it a pipelined architecture are
referred to as pipeline registers. In this architecture, every register, except ma, is a
pipeline register.

i the single-
K_PERIOD
single-cycle
to stabilize

[lowing tim-

D20

I|001
'1 x

4
Figure 6-16. Pipelined architecture.

Notice that the pipeline registers are drawn in columns. The mal and xi registers are
drawn in the leftmost pipeline register column. The ma2, x2 and bx registers are in
the next pipeline 

6 register column. The ma3, ax2 and bxc registers are in the third
pipeline register column. In between each pipeline register column are buses and com-
binational logic only. Such a column of combinational logic to the left of a pipeline

9 register is known as a pipeline stage. For example, the first pipeline stage is the ROM.
The second pipeline stage involves two multipliers and a bus (that passes mal). The
third stage involves an adder and a multiplier. The fourth stage involves just an adder.

IL (This architecture assumes that a value can be clocked into the appropriate word of y as
KL though it just a clocked register. See section 8.2.2.3.1 for details.)

The following Verilog code shows the definition of this pipelined architecture, along
with the corresponding mixed controller:

Designingf or Speed and Cost 241



w14MEOp

always Continued
begin
@(posedge sysclk) enternewstate('IDLE); while

//ma <= @(posedge sysclk) 0; begi
ready = 1; (P
clrma = 1; /
if (pb) //
begin //
@(posedge sysclk) enter new state('FILLl);

//ma <= @(posedge sysclk) ma + 1;
//mal <= @(posedge sysclk) ma; l
//xl <= @(posedge sysclk) x[ma];

/l/
ldxl = 1;

//
incma = 1; ld
ldmal = 1; l/-/
@(posedge sysclk) enter-new state('FILL2); ld
//ma <= (posedge sysclk) ma + 1; ld
//mal <= @(posedge sysclk) ma; ld

ld
//ma2 <= @(posedge sysclk) mal;
//xl <= @(posedge sysclk) x[ma]; ld
//x2 <= @(posedge sysclk) xl*xl; in
//bx <= @(posedge sysclk) b*xl; ld
ldxl = 1; /a'1 d
ldx2 = 1; 1d
ldbx = 1; 1d
incma = 1; end
ldmal = 1; @( pos
ldma2 = 1; //ma

@(posedge sysclk) enternew state('FILL3); //ma
//ma <= (posedge sysclk) ma + 1; // x2
//mal <= @(posedge sysclk) ma; // by
//ma2 <= @(posedge sysclk) mal; //ax

//ma3 <= @(posedge sysclk) ma2; // by
//xl <= @(posedge sysclk) x[ma]; //y[
//x2 <= @(posedge sysclk) xl*xl; ldx2
//bx <= @(posedge sysclk) b*xl; ldby
//ax2 <= @(posedge sysclk) a*x2; lday
//bxc <= @(posedge sysclk) bx + c; ldby
ldxl = 1; ldma
ldx2 = 1; ldma
ldbx = 1; ldy
ldax2 = 1; @( poE
ldbxc = 1; //ma
incma = 1; //a>
ldmal = 1; // b>
ldma2 = 1;
ldma3 = 1;

242 Verilog Digital ComputerD esign: Algorithms into Hardware



Continued

while (-maeqmax)
begin
@(posedge sysclk) enternewstate('COMPUTEl);

//ma <= @(posedge sysclk) ma + 1;
//mal <= @(posedge sysclk) ma;
//ma2 <= @(posedge sysclk) mal;
//ma3 <= @(posedge sysclk) ma2;
//xl <= @(posedge sysclk) x[ma];
//x2 <= @(posedge sysclk) xl*xl;
//bx <= @(posedge sysclk) b*xl;
//ax2 <= @(posedge sysclk) a*x2;
//bxc <= @(posedge sysclk) bx + c;
//y[ma3] <= (negedge sysclk) ax2 + bxc;
ldxl = 1;
ldx2 = 1;
ldbx = 1;
ldax2 = 1;
ldbxc = 1;
incma = 1;
ldmal = 1;
ldma2 = 1;
ldma3 = 1;
ldy = 1;

end
@(posedge sysclk) enternewstate('FLUSHl);
//ma2 <= @(posedge sysclk) mal;
//ma3 <= @(posedge sysclk) ma2;
//x2 <= @(posedge sysclk) xl*xl;
//bx <= @(posedge sysclk) b*xl;
//ax2 <= @(posedge sysclk) a*x2;
//bxc <= @(posedge sysclk) bx + c;
//y[ma3] <= (negedge sysclk) ax2 + bxc;
ldx2 = 1;
ldbx = 1;
ldax2 = 1;
ldbxc = 1;
ldma2 = 1;
ldma3 = 1;
ldy = 1;

@(posedge sysclk) enternewstate('FLUSH2);
//ma3 <= @(posedge sysclk) ma2;
//ax2 <= @(posedge sysclk) a*x2;
//bxc <= @(posedge sysclk) bx + c;

re Designingf or Speed and Cost 243



Continued

//y[ma3] <= (negedge sysclk) ax2 + bxc;
ldax2 = 1; presentstat
ldbxc = 1; xbus[
ldma3 = 1; x2dibus[
ldy = 1;

x2dobus[
@(posedge sysclk) enternewstate('FLUSH3);
//y[ma3] <= (negedge sysclk) ax2 + bxc; ax2dibus[
ldy = 1; ax2dobus[

end bxdibus[
end

bxdobus[,

counter-register #12 ma(,mabus,,l'bO,incma,clrma,sysclk); bxcdibus[1
enabled-register #12 mal(mabus,malbus,ldmal,sysclk); bxcdobus[l
enabled-register #12 ma2(malbus,ma2bus,ldma2,sysclk); ydibus[1
enabled-register #12 ma3(ma2bus,ma3bus,ldma3,sysclk); mabus[1
comparator #12 cmp(,maeqmax,,mabus,'MAXMA);
rom #(12,23) mal bus[1

x(mabus,xbus);
enabled-register #12 xl(xbus,xlbus,ldxl,sysclk); ma2bus[1
multiplier # (12,24) ml(x2dibus,xlbus,xlbus); ma3bus[1
enabled-register #12 x2(x2dibus,x2dobus,ldx2,sysclk); sy
multiplier # (12, 24) m2(bxdibus,b,xlbus);
enabled-register #12 bx(bxdibus,bxdobus,ldbx,sysclk); Figure 6-1
multiplier #(12,24) m3(ax2dibus,a,x2dobus);
enabled register #12 ax2(ax2dibus,ax2dobus

ldax2,sysclk);
adder #(12,25) al(bxcdibus,bxdobus,c); 6.6 Con
enabled register #12 bxc(bxcdibus,bxcdobus The first duty 

ldbxc,sysclk); explained in e
adder #(12,25) a2(ydibus,ax2dobus,bxcdobus); Often, in addi
ram #12 y(ldy,ma3bus,ydibus,,sysclk); criteria of spec

mine if a desig
natives that all

In the above, it is assumed that the propagation delays are the same as in the single- and The speed of a
multi-cycle approaches. With the pipelined approach, 'CLOCKPERIOD can usually period and the
be about as fast as in the multi-cycle approach (26 in this example), but the number of clock cycles ai
such clock cycles is nearly the same as in the single-cycle approach. Unlike the multi- gate-level pror
cycle approach, where five sixths of the combinational logic is unproductive during once a design ]
each clock cycle, when the pipeline is full, all of the combinational logic is doing propagation d(
productive work. The following timing diagram illustrates how the pipelined approach post-synthesis
gets the complete job done faster than the single-cycle or multi-cycle approach: outputs, knowi

244 Verilog Digital Computer Design: Algorithms into Hardware



_- P_

347 .1..3..5..8. .I...3..6.9.. l .. 38I402  391 402 413 424 44335 446
presentLstate [2:0] _ _ .............................................................................................

001
xbus[1 1:0] x x a x 1 x

x2dibus[1 1:0] l 1125 x 1116 x x 114 x 1
x2dobus[1 1:0] 361 25 1 16 1 9 1 4 11

ax2dibus[1 1:0] lKI *-36 x I 1 25 x 11 6 x I19- x
ax2dobus[1 1:0] l91 36 1 25 1 16 1 9

bxdibus[1 1:0] lO1K0  X I 1 8 x I I*Q x I1 4 x
bxdobus[1 1:0] l12 10 1 8 1 6 1 4
bxcdibus[1 1:0] x * x 113 x 11 

sysclk); x klg) x 7
bxcdobus[1 1:0] 171 15 1 13 1 11 1 9

:1k); ydibus[1 1: 0] x166 x 1I51 x 1138 x 1127 x 
:1k); mabus[1 1 ::0 31 4 1 5 1 8 1 7 18
:1k); mal bus[1 1 ::0 21 3 1 4 1 5 1 6 17

ma2bus[1
slk); 1: 0] 11 2 1 3 1 4 1 5 Ib

ma3bus[1 1: 0] 0 1 1 1 2 1 3 1 4 15
!,  sysclk) ; sy, Ak

i,sysclk); Figure 6-17. Timing diagramf or pipelined ASM.

6.6 Conclusion
The first duty of a designer is to produce a correct design. The top-down design process
explained in earlier chapters helps organize a designer's thinking to achieve this goal.

lobus ); Often, in addition to being algorithmically correct, a practical design must meet the
I criteria of speed and cost. This chapter explains how Verilog can help a designer deter-

mine if a design meets its speed goals. This chapter also explains different design alter-
natives that allow a designer to trade off speed and cost.

n the single- and The speed of an algorithm implemented in hardware depends on two factors: the clock
[OD can usually period and the number of clock cycles. The algorithm itself determines how many
it the number of clock cycles are required, but the limiting factor on how fast the clock period can be is
Unlike the multi- gate-level propagation delay. Synthesizable Verilog cannot have propagation delay, but
oductive during once a design is synthesized, it is easy to annotate the built-in gates of the netlist with
1 logic is doing propagation delays. (Some synthesis tools automatically backannotate the netlist for
elined approach post-synthesis simulation.) Gates with delays create the possibility of spurious wrong
approach: outputs, known as hazards.

,are Designingf or Speed and Cost 245



There are many ways that a building block, such as an adder, can be synthesized into a signs. One doc
gate level netlist. Each such unique netlist may give rise to unique patterns of hazards because modei
that can only be simulated in detail after synthesis. Despite the fact that we cannot cepts much ea!
know the details of a hazard prior to synthesis, it is possible to abstractly model a
hazardous period of a signal using Verilog events, the disable statement and bx.
Such models are not synthesizable but instead provide more accurate timing simulation
prior to synthesis. Instantiations of combinational building blocks defined this way 6.7 Furt
provide an accurate worst case model of the propagation delay for bus-width devices. GAJSKI, DANIEL
From the $ t ime the inputs to any of the instantiated devices change until such changes NJ, 1997. Chaf
propagate through all of the instantiated devices, the final output of the collection is the architecture
'bx.

PALNITKAR, S.,
Many problems require that the same computation be performed on large amounts of PTR,Upper Sa
independent data. There are three common algorithmic alternatives to solve such prob- gate-level dela
lems, known as single-cycle, multi-cycle, and pipelined. In the single-cycle approach,
the computation on each independent piece of data is begun and finished in one clock PATrERSON, DA)

cycle. In the multi-cycle approach, the computation on each independent piece of data Hardware/Soft
requires several clock cycles to complete before another piece of data can be processed. and 6 discuss td
The pipelined approach, like an assembly line in a factory, does different aspects of the
computation with different pieces of independent data at the same time. Although it
still takes several clock cycles to complete the computation for a particular piece of
data, once the pipeline is filled, it produces 6.8 

one result Exer
per clock cycle.

6-1. A complex
What the multi-cycle and pipelined approaches have in common is that they both can real part, xr, a
be clocked by "faster" clocks, determined by the worst case delay of a single building where i is the 
block. The single-cycle approach demands a "slower" clock, determined by the delay instead of i.) 
path through several devices. The single-cycle approach produces exactly one result and imaginary I
per clock cycle, and the pipelined approach usually produces almost one result per computing xr
clock cycle (because the time to fill the pipeline is usually negligible compared to how ROMs: xr [ma
much independent data is to be processed). The multi-cycle approach needs several ASM suitable f(
clock cycles to produce each result. Therefore, the pipelined approach is usually fastest the complex val
and most efficient because it can be clocked fast and it produces nearly one result per tions in the fielc
clock cycle. telephone convc
Although in recent years pipelining has become important in the design (and market- cause the desire
ing) of personal computers, pipelining is not a new concept. It has been used since the may assume the
1960s to design general-purpose computers (chapter 9), but its use with special-pur- a single cycle.
pose computers has a much longer history. Pipelining is one of those algorithmic con-
cepts that endure. It was first applied to computer design by Babbage in the 1820s. On
Babbage's machine, the clock cycle was generated when one turned a crank. To avoid 6-2. Implement
muscle strain, Babbage designed for speed and cost and chose a pipelined design. De- design in proble
spite almost unimaginable technological change in two centuries, many designers since
then have followed in Babbage's algorithmic footsteps and have chosen pipelined de-

246 Verilog Digital ComputerD esign: Algorithms into Hardware



- -

ynthesized into a signs. One does not have to be a genius like Babbage to understand pipelining today,
tterns of hazards because modem tools like Verilog simulators make these intricate $ time related con-
t that we cannot cepts much easier to understand.
stractly model a
tement and bx.
iming simulation
defined this way 6.7 Further reading
Is-width devices. GAJSKI, DANIEL D., Principles of Digital Design, Prentice Hall, Upper Saddle River,
ntil such changes NJ, 1997. Chapter 8 discusses how pipelining can be applied to both the controller and
the collection is the architecture (datapath).

PALNITKAR, S., Verilog HDL: A Guide to Digital Design and Synthesis, Prentice Hall,
large amounts of PTR,Upper Saddle River, NJ, 1996. Chapters 5 and 10 explain about sophisticated
solve such prob- gate-level delay modeling in Verilog.
b-cycle approach,

hed in one clock PATrERSON, DAVID A. and JOHN L. HENNESSY, Computer Organizationa nd Design: The
lent piece of data Hardware/SoftwareI nterface, Morgan Kaufmann, San Mateo, CA, 1994. Chapters 5
van be processed. and 6 discuss the trade-offs of the single-cycle, multi-cycle and pipelined approaches.
nt aspects of the

time. Although it
particular piece of 6.8 Exercises

6-1. A complex number, X, can be represented inside a machine as two integers: the
hat they both can real part, xr, and the imaginary part, xi. Mathematicians say that X = xr+i*xi,
a single building where i is the square root of minus one. (Some electrical engineers use the symbol j
fined by the delay instead of i.) To add two complex numbers, X and Y, simply requires adding the real

exactly one result and imaginary parts separately. To multiply two complex numbers, X and Y requires
fit one result per computing xr*yr-xi*yi and xr*yi+xi*yr. Suppose that a machine has four
cmoamrep ared to how ROMs: xr [ma], xi [ma],D y r g[ ma] andS  yi d[m a]. CDesign a multi-cycle behavioral
ch needs several ASM suitable for a central ALU architecture that computes the sum of the products of
is usually fastest the complex values in X and Y ROMs. This computation has many practical applica-

rly one result per tions in the field of digital signal processing, such as filtering out unwanted noise in a
telephone conversation. Note that there is no need for a memory in this problem be-

ign (and market- cause the desired answer is a single complex sum composed of sumr and sumi. You
en used since the may assume the ALU can do either an integer addition, subtraction or multiplication in
with special-pur- a single cycle.
algorithmic con-
in the 1820s. On
a crank. To avoid 6-2. Implement a pure behavioral Verilog simulation and test code that verifies your
lined design. De- design in problem 6-1.
.yd esigners since
sen pipelined de-

Ware Designingf or Speed and Cost 247



6-3. Draw a block diagram for the architecture of problem 6-1. Assume the propagation
delays (in nanoseconds) of building blocks are the same as in section 6.5.8.1. How
many seconds will it take for your machine to compute the sum assuming there are ten 7. I
million words in each ROM? The manual pro
6-4. Implement a mixed Verilog simulation that verifies your architecture for problem quite involved.
6-3. Assume the propagation delays of building blocks are the same as in section 6.5.8.1. have to determi

to create a struc
6-5. Design a single-cycle behavioral ASM for problem 6-1. The architecture that will ASM without th
eventually implement the register transfers of this single-cycle machine may have as final hardware,,
many integer adders, subtractors and multipliers as necessary. pensive than wl
6-6. Implement a pure behavioral Verilog simulation and test code that verifies your to understand.
design in problem 6-5. This approach i
6-7. Draw a block diagram for the architecture of problem 6-5. Assume the propagation flops as there ar
delays (in nanoseconds) of building blocks are the same as in section 6.5.8.1. How one-bit register,
many seconds will it take for your machine to compute the sum assuming there are ten The reason the
million words in each ROM? structure is muc
6-8. Implement a mixed Verilog simulation that verifies your architecture for problem a behavioral AS
6-7. Assume the propagation delays of building blocks are the same as in section 6.5.8.1. to the circuit di,

F that automate:
6-9. Design a pipelined behavioral ASM for problem 6-1. The architecture that will
eventually implement the register transfers of this pipelined machine may have as many
pipeline stages and as many integer adders, subtractors and multipliers as necessary.

6-10. Implement a pure behavioral Verilog simulation and test code that verifies your 7.1 Moo
design in problem 6-9. As explained in

describing state
6-11. Draw a block diagram for the architecture of problem 6-9. Assume the propaga- With the one h(
tion delays (in nanoseconds) of building blocks are the same as in section 6.5.8.1. How Verilog) translal
many seconds will it take for your machine to compute the sum assuming there are ten
million words in each ROM?

7.1.1 RectU
6-12. Implement a mixed Verilog simulation that verifies your architecture for problem
6-11. Assume the propagation A rectangle 

delays in a
of building blocks are the same as in section

6.5.8.1. lates into a flip f
one of the flip f
flops will be cc
assumption is tr
this one hot pro

248 Verilog Digital Computer Design: Algorithms into Hardware



the propagation
on 6.5.8.1. How
iing there are ten 7. ONE HOT DESIGNS

The manual process of translating an ASM (or the equivalent Verilog) into hardware is
ture for problem quite involved. The final step of creating a structural controller is tedious because we
n section 6.5.8. 1. have to determine what the next state is in every situation. There is an alternative way

to create a structural controller directly from the behavioral Verilog or from the mixed
itecture that will ASM without the need to consider the next state logic and the present state register. The
ine may have as final hardware structure that is created by this alternative method is slightly more ex-

pensive than what is created by the process described in chapter 4, but it is much easier
hat verifies your to understand.

This approach is known as a one hot method. The one hot controller uses as many flip
-the propagation flops as there are states in the ASM. As described in appendix D, a D-type flip flop is a
on 6.5.8.1. How one-bit register, whose output Q is simply its input D, delayed by one clock cycle.

rung there are ten The reason the one hot method is preferred is that the translation from behavior to
structure is much more straightforward than the process described in chapter 4. Given

ture for problem a behavioral ASM or the equivalent behavioral Verilog, there is a one-to-one mapping
n section 6.5.8.1. to the circuit diagram for the one hot controller. (There is a tool described in appendix

F that automates this process.)
itecture that will
hay have as many
rs as necessary.

that verifies your 7.1 Moore ASM to one hot
As explained in chapter 2, a Moore ASM is composed of three symbols: rectangles
describing states, diamonds describing decisions and arrows describing control flow.

ime the propaga- With the one hot technique, each of these behavioral symbols (or the corresponding
tion 6.5.8.1. How Verilog) translates directly into a physical piece of hardware.
ning there are ten

7.1.1 Rectangle/flip flop
cture for problem A rectangle in an ASM [or the equivalent @( posedge syscik) 
me as in in Verilog] 

section trans-
lates into a flip flop. This technique is known as one hot because it is assumed that only
one of the flip flops is hot (i.e., contains a one) in any clock cycle. The rest of the flip
flops will be cold (contain 0). The rules of the one hot technique ensure that if this
assumption is true shortly after $ time 0, the one hot interconnections will guarantee
this one hot property will remain in effect from then on.

ware One Hot Designs 249



7.1.2 Arrow/wire
An arrow in an ASM (or the implicit flow of control in Verilog) corresponds to a physi-
cal wire in a one hot controller. When that wire is hot it means that the corresponding
statement in Verilog is active during the current clock cycle. Several statements (that
execute in parallel) might be hot in a particular clock cycle, but only one flip flop
(corresponding to a state) is hot in that clock cycle.

7.1.3 Joining together/OR gate
It is common for two or more arrows to join together in an ASM. This joining together
occurs because in different clock cycles there are different paths to arrive at the same
next state. Because they could fight (and produce a 1 ' bx in Verilog simulation), it is
illegal to tie together two wires that are each connected to an output. Therefore, when
arrows in an ASM join together, the corresponding physical wires in the one hot design
must be ORed together.

7.1.4 Decision/demux
A decision (diamond in an ASM or an equivalent if or while in Verilog) translates
into a one bit wide demux. Recall from appendix C that the combinational logic for a
demux is very different from that of a mux. The following truth table describes the
outputs (outO and out1) of the demux, given its two inputs (in and cond):

in cond outl outO

o 0 0 0
o 1 0 0
1 0 0 1
1 1 1 0

Notice when in is cold (i.e., 0), both outputs are cold. When in is hot (i.e., 1), only
one of its two outputs is hot; hence it preserves the one hot property.

7.1.5 Summary of the one hot method Figure 7-1.
The following diagram illustrates the above four rules for translating a Moore ASM controllers.
into a one hot design:

The one hot m
number of flip I
two logarithm 
are required in

250 Verilog Digital Computer Design: Algorithms into Hardware



ids to a physi-
orresponding

STATE
ttements (that
one flip flop

STATE

Ining together
re at the same
nulation), it is
erefore, when I1
ne hot design I
og) translates
nal logic for a
describes the cond 1
ond):

40

I
(i.e., 1), only

Figure 7-1. Moore ASMs and correspondingc omponents of one hot
WM oore ASM controllers.

The one hot method uses more flip flops than the method shown in chapter 4. The
number of flip flops of the present state register in chapter 4 is approximately the base
two logarithm of the number of states. The following table shows how many flip flops
are required in each method:

One Hot Designs 251



number Ch 4 one one hot +
of states hot power on

2 1 2 3
3 2 3 4
4 2 4 5 reset-F R
5 3 5 6
6 3 6 7
7 3 7 8 pb*
8 3 8 9

The need for the extra flip flop for "power on" will be explained in the next section.

7.1.6 First example
Consider the first ASM given in section 2.2.2 (and the mixed ASM in section 2.3.3),
which has five states. The diagram below shows how to translate the ASM from section
2.2.2 into one hot hardware. There are five states in this ASM; therefore there are five
flip flops in the corresponding one hot controller. For clarity, the wires connected to the
Q outputs of these five flip flops are labeled with states that correspond to them. Later
we will use a numeric labeling scheme, but for now using the state names as wire
names will emphasize how the one hot method works.

Coming out of state IDLE, there is a decision based on pb. If pb is false, there is a path
that eventually leads back to state IDLE. If pb is true, there is a path that leads to state
INIT. In the one hot controller, this decision corresponds to a demux whose input is the
Q output of the flip flop for IDLE. The out output of the demux goes to OR gates
that in turn provide the D input for the flip flop for IDLE. The out1 output of the Figure 7-2.
demux connects to the D input for the flip flop for INIT. In other words, the ASM chart
and the circuit diagram have an identical structure.

In order to guan
In the ASM, there are two paths that lead to state TEST. One comes from state INIT and connected to an
the other comes from state COMPUTE2. In the one hot controller, this corresponds to 0 is when this 
another OR gate. In state TEST there is a decision based on rigey (which tells if rl
>= y). If this condition is true, the ASM proceeds to state COMPUTE1; otherwise the By itself, just rc
ASM proceeds to state IDLE. This decision corresponds to a demux whose input is the would have the
Q output of the flip flop for state TEST. The cond input for this demux is rigey. The these flip flops (
out 1 output of this demux connects to the D input of the flip flop for state COM- rising edge of td
PUTEL. The outO output of this demux connects to the OR gate that leads back to the path to the flip f
flip flop for state IDLE. This extra wire

$ time 0 until tl
this power on de

252 Verilog Digital Computer Design: Algorithms into Hardware



- next section.

i section 23.3),
o'M from section
re there are five
-onnected to the
d to them. Later
names as wire

e, there is a path
iat leads to state
hose input is the
Des to OR gates
1 output of the Figure 72. One hot controllerforASMs of sections 22.2 and 23.3.
;, the ASM chart

In order to guarantee that the one hot property holds at $ t ime 0, all of the 
n state flip flops 

INIT are
and connected to an asynchronous rese t signal. In physical hardware, shortly 

sc orresponds after $ t ime
to 0 is when this reset signal ceases to be active. It is never 

which used 
tells again.

if rl
1; otherwise the By itself, just reseting the flip flops that correspond to the states in a particular ASM
hose input is the would have the effect of making all those flip flops cold at $ time 0. Exactly one of
(is rlgey. The these flip flops (the one for state IDLE in this example) needs to become hot at the first
for state COM- rising edge of the clock. To accomplish this, we need to OR an additional wire on the
.eads back to the path to the flip flop for state IDLE.

This extra wire will be the output of a power-on device that will be hot only between
$ time 0 until the first rising edge of the clock. After the first rising edge of the clock,
this power on device will will be cold thereafter.

One Hot Designs 253



This power-on device is constructed as a D flip flop with its D input tied to a one. The
Q output of this flip flop is complemented 7.2 

to form Veri
the signal that "ignites" the first flip

flop of the actual controller. It usually take!
so why is this
not only is the

II-P--O---W---E--R-_O-__N-_ -_
1 similar corresl

I DEVICE I hot circuit. Be
i reset D software that 

designer to go

i…---- ___j VITO is an at
style behavion

Figure 7-3. Power-on device for one hot controllers. dix F. In order
the one-to-one

The next diagram shows the translation of the ASM from sections 2.2.7 and 2.3.1 (or is best develop
the corresponding Verilog from section 4.1.5) into a one hot controller. Like any other scribe manual 
controller, this also needs to generate the command outputs required for the architec- than instantiati
ture. This is very similar to the netlist given in section 4.4.2, except instead of tinuous assign
present_state [ 0 ] and -present_state [ 0 ], we have IDLE and COMPUTE
as wires.

7.2.1 Coni
1.

Continuous as!
equivalent to d
would otherwis

module
reg f:

wire
assigi

endmodu:

There also is at
declaration to o

I

Figure 7-4. One hotcontrollerforASMs of sections 2.2.7and 2.3.1. Note that contin
not a reg. Clea
to the "hidder

254 Verilog Digital Computer Design: Algorithms into Hardware



ad to a one. The
,es" the 7.2 

first flip Verilog to one hot
It usually takes a little more hardware to implement a machine with the one hot method,
so why is this method worthwhile? The one hot method has a tremendous advantage:
not only is there a one-to-one mapping of ASMs into one hot designs-there is also a
similar correspondence between an implicit style behavioral Verilog block and the one
hot circuit. Because of this direct translation process, it is relatively simple to write
software that translates such Verilog into a one hot design without the need for the
designer to go through the lengthy process described in chapter 4.
VITO is an automated preprocessor tool that performs the translation from implicit
style behavioral Verilog into a one hot design. How to use VITO is described in appen-
dix F. In order to understand the approach used in VITO, it is necessary to appreciate
the one-to-one mapping between Verilog and the one hot circuit. Such an appreciation

'.7 and 2.3.1 (or is best developed by working through a few examples. The following examples de-
Like any other scribe manual translation of implicit style Verilog directly into a one hot circuit. Rather

For the architec- than instantiating built-in gates, the following examples will use what is called con-
cept instead of tinuous assignment.
and COMPUTE

7.2.1 Continuous assignment
- Idrl
- aluctrl [3] Continuous assignment is a shorthand way of describing combinational logic. It is
- aluctrl [2] equivalent to defining a module without having to declare the ports and so forth that

-incr2 would otherwise be required. Let's consider an example of a continuous assignment:
- Idr3
- muxctrl
- aluctrl [4]

-aluctrl [0] module test;
dcl rr2 reg ffl,ff_2;
-aluctrl [5] ... /code that deals with ff_1 and f_2

-aluctrl [1]
-ready wire s_3;

assign s3 = ff_l ff_2;
endmodule

There also is an additional shorthand for continuous assignment that allows the wire
declaration to occur on the same line. For example, the above is equivalent to:

I wire s_3 = ff-1 I ff-2; l
*COMPUTE

Note that continuous assign is not a behavioral statement. The left-hand side is a wire,
not a reg. Clearly, using continuous assign shortens the code considerably compared
to the "hidden-module" shown below:

are One Hot Designs 255



Continued
module test;

reg ffl,ff_2;
wirE

... /code that deals with ff_1 and ff_2

hidd
wire s_3; endmodu
hiddenmodule hl(s_3, ff_1, ff_2); module

endmodule input
outpu

This "hiddenmodule" defines combinational logic in the usual way with a reg wire

for the output port and a sensitivity list for the input wires: reg [
alway

sum
endmodu

module hiddenmodule(s_3, ff1, ff_2);
output s_3;
input ff_1, ff_2; An advantage o
reg s_3; of sum, a and 
wire ff_1, ff_2; with the idder
always (ffl or ff_2) inside the decla

s_3 = ff_1 ff_2;
endmodule Also, continuot

ample, the folla

The computation, f f_1 I f _2, is the same as given in the continuous assign. The
power of the continuous assign is that it allows arbitrarily complicated expressions (of

module
arbitrary width) to be evaluated. For example, the following: reg [

reg s
. . .

module test;
reg [11:0] a,b; wire
... /code that deals with a and b

assig
wire [11:0] sum; endmodu

assign sum = a + b;
endmodule is equivalent to

section 4.2.1.5.

is equivalent to instantiating a hiddenadder:

module test;
reg [11:0] a,b;
... /code that deals with a and b

256 Verilog Digital Computer Design: Algorithms into Hardware



Continued

wire [11:0] sum;

hidden-adder h2(sum, a, b);
endmodule
module hiddenadder(sum, a, b);

input a,b;
output sum;

y with a reg wire [11:0] a,b;
reg [11:0] sum;
always @(a or b)

sum = a + b;
endmodule

An advantage of the continuous assignment is that you do not have to specify the widths
of sum, a and b multiple times-their previous declarations are sufficient. In contrast,
with the hidden adder approach you have to duplicate the declaration of their widths
inside the declaration of hiddenadder.

Also, continuous assignment allows the use of the conditional operator (? :). For ex-
ample, the following:

is assign. The
:pressions (of

module test;
reg [11:0] a,b;
reg sel;
... /code that deals with a,b,sel I

wire [11:0] muxout;

assign muxout = sel ? : a;
endmodul e

is equivalent to instantiating a hidden instance of a mux2, whose portlist is given in
section 4.2.1.5.

mux2 #(12) h3(a, b, sel, muxout);

One Hot Designs 257

A



7.2.2 One hot using continuous assignment FIFTH for the f
The wires that implement the combinational logic of a one hot circuit can be described by Verilog. [Th(
with continuous assignment. This is done as a notational convenience because continu- and chapter 4] ti
ous assignments are equivalent to structural instances but are much more concise. For tasks.) The exar
example, the adder and mux in the last section could have been of any width, but the the state names
syntax of the actual continuous assignment would have been the same. Synthesis tools illustrating the 
available from many different vendors are able to translate continuous assignments mated, the nam
into the structural instances (netlist) required to fabricate hardware. Each flip flop re- notice what nan
quired by the one hot circuit will be described by a separate one-bit reg. Such regs Every statement
are also synthesizable. The names of these wires and regs will relate to the statement ing statement e
numbers of the lines in the Verilog always block from which they derive.

ASM state narn
appropriate for

7.2.2.1 One hot with if else through s_19)1
The following example Verilog (taken from section 3.8.2.3.3) illustrates implicit style Of these wires
behavioral Verilog with an if else statement. Inthis example @( posedge sysclk)
#1 occurs on lines 3, 5, 9, 14 and 17, so the names of the five flip flops for the one hot
controller will be f f_3, f f _5, ff_9, f f 14 and f f_17: wire

s_4
s_6
s_10

1: always
s_15

2: begin
s_18

3: @(posedge sysclk) #1; //FIRST is ff_3
4: a <= @(posedge sysclk) 1;
5: @(posedge sysclk) #1; //SECOND is f_5 The other wires
6: b <= @(posedge sysclk) a; s_16, s17 ani
7: if (a == 1) those wires are
8: begin is synonymous v
9: @(posedge sysclk) #1;//THIRD is f_9

10: a <= (posedge sysclk) b; Although there a
11: end are sent to the ax
12: else and 8.4.1) for de
13: begin hand side of the
14: @(posedge sysclk) #1;//FOURTH is ff_14
15: b <= (posedge sysclk) 4;
16: end
17: @(posedge sysclk) #1; //FIFTH is ff_17 s_4
18: a <= (posedge sysclk) 5; s1 0
19: end s_18

s_6
It is easier to give each flip flop a name that relates to what statement number the s_15
@( posedge sysclk) #1 occurs on than to use the name from the original ASM.
The reason that we do not use the names FIRST, SECOND, THIRD, FOURTH and

258 Verilog Digital Computer Design: Algorithms into Hardware

L



FIFTH for the flip flops is that those names were inside comments, which are ignored
m be described by Verilog. [The reason we do not use the enternew_state task (sections 3.9.1.2
cause continu- and chapter 4] to give each state a name is that the VITO preprocessor does not support
re concise. For tasks.) The example in section 7.1 of translating from an ASM to a one hot circuit used
width, but the the state names given in the ASMs as the names of the flip flops only for the purpose of

Synthesis tools illustrating the nature of the one hot method. Since this translation will now be auto-
is assignments mated, the names do not matter. In the automated process, the designer will seldom
ch flip flop re- notice what name is given to each wire.
sg. Such regs Every statement also has a wire associated with it that is active when 
o the statement the correspond-

ing statement executes. (In the earlier example, these names 
five. were also the original

ASM state names. In general this need not be the case, and so separate names are
appropriate for an automated tool.) In this example, there are nineteen wires (s_1
through s_1 9) that correspond to statements in the original implicit style Verilog code.

s implicit style Of these wires, five act as command signals to the architecture:
Ige sysclk)
for the one hot

wire action in architecture when wire is active
s_4 a <= @(posedge sysclk) 1;
s_6 b <= @(posedge sysclk) a;
s_10 a <= @(posedge sysclk) b;
s_15 b <= @(posedge sysclk) 4;
s_18 a <= @(posedge sysclk) 5;

The otherwires (s_1, s2, s_3, s_5, s7, s_8, s_9, s_11, s_12, s_13, s_14,
s_16, s_17 and s_19) are used to define the rest of the one hot controller. Some of
those wires are synonymous with each other. For example s_11 (an end statement)
is synonymous with the s_10 wire that precedes it.
Although there are nineteen wire names in the one-hot controller, only the above five
are sent to the architecture. Using the methodical approach (such as in sections 2.3.1
and 8.4.1) for designing the architecture, we sort the above list according to the left-
hand side of the <=, and separate them according to these destinations:

s_4 a <= @(posedge sysclk) 1;
s_10 a <= @(posedge sysclk) b;
s_18 a <= @(posedge sysclk) 5;

s_6 b <= @(posedge sysclk) a;
ent number the( s_15 b <= @(posedge sysclk) 4;
, original ASM.
,, F OURTH and(

One Hot Designs 259



Of course, there are many architectures that could implement the above register trans- The combinati(
fers. In earlier chapters we have focused on using standard building blocks, such as assignments:
enabled registers. In the approach of this chapter, we instead choose an architecture
that is easier to describe using continuous assignment. For this reason, we will use
simple (non-enabled) D-type registers that have no command inputs whatsoever. In
other words, such registers can be described simply as:

reg [11:0] a,b;
wire [11:0] new a,new-b;
always (posedge sysclk)

a = new a;
always (posedge sysclk)

b = new-b;

All of the actions normally encapsulated inside a register building block (of the kind
described in appendix D) now have to be given with the combinational logic that com- Because of the n.
putes newa and newb. From the sorted list above, one approach would be to use <= 1 and s_6
three muxes for computing newa and two muxes for computing new-b: same destinatioi

any clock cycle.
also suffice, suc]

Notice that the 
Verilog. The bloc
the Verilog conti
by just rearrangii

Having defined t
ing circuit diagra
hardware:

Figure 7-5. Architecture generatedfrom implicit Verilog of sections 7.2.2.1 and
3.8.2.3.3.

260 Verilog Digital Computer Design: Algorithms into Hardware



ereggiisstter trans- The combinational logic in the above diagram can be expressed as two continuous
)ckkss, ssuuch as assignments:
i architecture
,,  we will use
hwahtastosoeevveerr.  In assign newa =

(s_18) ? 5 :
(s_10) ? b :
(s_4) ? 1 :

__7 a;

assign newb =
(s_1S) ? 4 :
(s_6) ? a :

b;

k (of the kincd
))ggiicc  that cormn-. Because of the nature of correct one hot designs, it is guaranteed that s_18 + s_10 +s _4
Duld be to us(e <= 1 and s_6+s_15 <= 1. In other words, within each group (dealing with the
_b: same destination register), no more than one of the command signals will be active in

any clock cycle. This means there are several permutations of the muxes that would
also suffice, such as:

assign newa =
(s_4) ? 1
(s_10) ? b
(s_18) ? 5

a; I
4e 4*+ a

12 assign new_b =
B (s_6) ? a

(s_15) ? 4
b;

Notice that the architecture was created by a textual transformation of the original
Verilog. The block diagram given above was shown only as an aid to understand how
the Verilog continuous assignment works. The preprocessor produces similar Verilog

Ae by just rearranging the original text of the Verilog.
- + bb

'ee  1212 Having defined the architecture, all that remains is to define the controller. The follow-
ing circuit diagram shows how each implicit style behavioral statement translates into
hardware:

7.2.2.1 and

One Hot Designs 261



-

Again, VITO
only to help e:
ing from the o
ments require(

7.2.2.2 0
The following
illustrates a sli
nal Verilog us(

1:a
2 : :
3:
4:
5:
6:
7:
8 :
9 :

10:
1 1:
12 :

reset- 13 :
14 :
15:
16: 

The if statem
parator for state
corresponds to
s_7 correspon(

The preprocess
some of the wi

s-18, s_19

Figure 7-6. Controllerg eneratedfrom implicit Verilog of sections 7.2.2.1 and
3.8.2.3.3.

262 Verilog Digital Computer Design: Algorithms into Hardware



Again, VITO does not draw such a circuit diagram. The above diagram is provided
only to help explain the textual transformations that the preprocessor performs. Start-
ing from the original Verilog, the preprocessor generates the many continuous assign-
ments required to describe the above circuit.

7.2.2.2 One hot with if
The following example is taken from the implicit style example in section 3.8.2.3.4. It
illustrates a slightly different one hot controller than the last example because the origi-
nal Verilog uses an if without an else:

1: always
2: begin
3: @(posedge sysclk) #1; //FIRST is ff_3
4: a <= (posedge sysclk) 1;
5: @(posedge sysclk) #1; //SECOND is ff_5
6: b <= @(posedge sysclk) a; 10s

0
7: if (a == 1)
8: begin
9: @(posedge sysclk) #1;//THIRD is ff_9 4

10: a <= (posedge sysclk) b;
101

11: @(posedge sysclk) #1;//FOURTH is ff_11
12: b <= (posedge sysclk) 4;
13: end 0
14: @(posedge sysclk) #1; //FIFTH is ff_14
15: a <= @(posedge sysclk) 5; i)

16: end
S_11

The if statement translates to a demux whose input, qual 7, comes from the com-
parator for statement 7 that implements the condition a == 1. The 1 output, sT_7,
corresponds to when this condition is true at the $ time the i f executes. The 0 output,
s_7 corresponds to when this condition is false at the $ time the if executes.
The preprocessor generates the following one hot controller. In the following, only
some of the wire names are shown:

7.2.2.1 Iaand

are OOnnee  HHoott  DDeessiiggnnss  226633



Continued

10:
11:
12:
13:
14:
15:
16:

The preproces

Figure 7-7. Controllerg eneratedfrom implicit Verilog of sections 7.2.2.2 and
3.8.2.3.4.

S_
7.2.2.3 One hot with whil e
The following example is taken from the implicit style example in section 3.8.2.3.5. It
is similar to the last example, except it uses a while loop (and a corresponding OR
gate in the one hot controller to indicate the two paths that lead to the top of the while):

1: always
2: begin
3: @(posedge sysclk) #1; //FIRST is ff_3
4: a <= (posedge sysclk) 1;
5: @(posedge sysclk) #1; //SECOND is ff_5
6: b <= (posedge sysclk) a; Figure 7-8.
7: while (a == 1) 3.8.2.3.5.
8: begin
9: @(posedge sysclk) #1;//THIRD is ff_9

264 Verilog Digital Computer Design: Algorithms into Hardware



"q

Continued

10: a <= (posedge sysclk) b;
11: @(posedge sysclk) #1;//FOURTH is ff_11
12: b <= @(posedge sysclk) 4;
13: end
14: @(posedge sysclk) #1; //FIFTH -is ff_14
15: a <= @(posedge sysclk) 5;
16: end

The preprocessor generates the following one hot controller:

resetH DEVICON
HS_999

reset-s DQ

ts4

s-6
.2.2 and

qua17 < A
s_7 - sT_7

3.8.2.3.5. It r
ponding OR s10
thewhile): h : D

Figure 7-8. Controllerg eneratedfrom implicit Verilog of sections 7.2.2.3 and
3.8.2.3.5.

One Hot Designs 265



--q F__

7.3 Mealy commands in a one hot machine This can be d
Chapter 5 describes Mealy machines, where a command can be conditional. Condi- always
tional commands, shown as ovals in ASM charts, are not guaranteed to execute simply begi
because the machine is in a particular state. In order for a Mealy command to execute,
some specified condition must also be true. In a one hot controller, this condition cor-
responds to an output wire from the proper demux. In a Mealy one hot controller,
some of the wires associated with the statements that compose a state may not neces-
sarily be active when the machine is in that state. This is why the preprocessor creates
a wire for every statement: any statement in a Mealy machine might be conditional.

end

7.4 Moore command signals with Mealy <= As explained
The VITO preprocessor only permits <= . At first glance, this might appear to prevent enternew

implementation of mixed ASMs or of ASMs that have external command outputs, such always
as ready in the ASM of section 2.2.7. In fact, as long as such command signals are begii
unconditional (Moore), they can be described using Mealy <=. By doing so, the cost of
the architecture will increase by some extra flip flop(s); however this is usually a small
fraction of the total cost.

In addition, using the technique described below ensures that the command signal is
hazard-free,' which is necessary in certain situations, such as interfacing to asynchro-
nous memories (section 8.2.2.3.2). end

task eni
7.4.1 Example to illustrate the technique input

As an example to explain this technique, consider the following machine that asserts an begin

external command signal, comm, when the machine is in state BOT: prep
#1 

end
endtask

Since the VIT
using = whose

One of the ess
blocking assig
next rising ed
mand is synoi

Figure 7-9. Example with Moore command signal. sections 2.4 an
that is part of 

l The physical cause for hazards is explained in section 6.3.3.

266 Verilog Digital Computer Design: Algorithms into Hardware

M



ppear to prevent

Trhis  can be described wiitth  the following implicit style behavioral Verilog:

ditional. Condi- adatllawlwaayynssdis
execute simply bbeeggiinn

nand to execute, @((p(poosseeddgge e  ssyyssccllukkt))e   ##11;;  simply///T/TOOPP
is condition cor- iCCsommc m od to==  )0;;r

if (pb)
ehgso o t,  cthoen tcrolslte ro,f b

begin
may not neces-@(posedge (posedge ssyyssccllkk))  ##11;;///B/BOOTT

'rocessor creates Coomm
be conditional. ennddcodtinl

nand signals are end

As explained in section 3.99..1.2, the cornn m =  statement can been hidden inside tthe
nnpnr tn nr~~~vtnt eentetrt-enrre w -nsteatwe  staattee  ttaass k  so   tthattt  00  iis  tttehed  edefffaaullttt   vallue  offo rr  comm::

nd outputs, such always
nmand signal is begin

@(posedge sysclk) enternewstate('TOP);

s usually a small if (pb)
begin

@(posedge sysclk) enternewstate('BOT);
comm = 1;

ing to asynchro- end
end

task enternewstate;
input ['NUM _STATE_BITS-l:0] this_state;

ne begin
that asserts an

presentstate = thisstate;
#1 comm =0;

end
endtask

Since the VITO preprocessor only allows <=, we need to describe a machiine  without
using = whose behavior will be identical to the above after the first clock cycle.

One of the essential ideas used throughout this entire book is the meaning of tthe  non-
bllocking assignment..  Itt  computes a vallue  now but assigns that value to a register at the
next rising edge of the clock. Since the above Verilog is a Moore machine, the com-
mand is synonymous with the machine being in a particular state. As described in
sections 2.4  and 4.4..5, such Moore commands can be generated by combinational logic
tthat is part of the next state logic:

vvarree Onee  Hott  Dessiignss  267



In the implicit
next

Moore assign 
stateprsn values 

Ma state always
combinational begin

pb -- logic + current @( pos
command if

Figure 7-10. Currentc ommand approach suitablef or Moore or Mealy b

controller

e
Although Mealy machines must be defined using the above, we can look at a Moore
machine such as this example in a different way. We know end

what the next state is going
to be, and we know that there is a command synonymous with being in that next state.
Instead of using combinational logic for the current command as we have done in Except for the
previous chapters, we can instead use a register that will contain the next command: 1 'bx), the abo

= Note that the
so the assign

next comm when the
Moore ate PPs S present In other words,
only state that the next sto

combinational next
logic comm in state TOP wl

pb l COMMcurrent
> -- ] C-- command Likewise, the n

is already on th(
0 only when wi

Figure 7-11. Next command approachs uitable only for Moore controller ways that we c(
when pb ==
corm <= O. i
ment.

By rearranging
loop, the follow
cycle:

always
begin

COmrfT
@( pose

if (
be

Figure 7-12. Behavioral ASM with - for next command approach. en
end

268 Verilog Digital Computer Design: Algorithms into Hardware



In the implicit style behavioral Verilog corresponding to figure 7-12, we use <= to
assign values to the next command (comm) register:

always
begin

@(posedge sysclk) #1; //TOP
if (pb)
begin

aly comm <= (posedge sysclk) 1;
@(posedge sysclk) #;//BOT

end
lk at a Moore end comm <= (posedge sysclk) 0;

ok at a Moore end
t state is going
that next state.
have done in Except for the time prior to the second full clock cycle (during which time comm is

xt command: 1 bx), the above machine has the same behavior as the original Verilog code that used
=. Note that the non-blocking assignments are pure behavioral Mealy commands, and
so the assignment is conditional. The machine only schedules the assignment of 1 to
comm when the machine is already on the path where the next state will be state BOT.
In other words, we only know that the next command will be 1 when we already know
that the next state will be state BOT. The only way to get to state BOT is conditionally
in state TOP when pb == 1.

d Likewise, the machine only schedules the assignment of 0 to comm when the machine
is already on the path where the next state will be state TOP. The next command will be
O only when we know that the next state will be state TOP. There are of course two

roller. ways that we could know that the next state is state TOP: conditionally in state TOP
when pb == 0, and unconditionally in state BOT. The non-blocking assignment,
comm <= 0, only has to be described once because it was given after the if state-
ment.

By rearranging the comm <= @ (posedge sysclk) 0 to the top of the always
loop, the following is identical to the original Moore ASM, including the firstfll clock
cycle:

always
begin

comm <= (posedge sysclk) 0;
@(posedge sysclk) #1; //TOP

if (pb)
begin

comm <= (posedge sysclk) 1;
@(posedge sysclk) #1;//BOT

end
end

ire One Hot Designs 269



This works on the assumption2 that the power on circuit can reliably provide s_999 Continued
as the command signal that clears comnm prior to that first full clock cycle. 3 When this if (pb)
assumption holds, the above example illustrates a simple rule for converting a Moore begin
machine with external commands into a Mealy machine using <=: put the <= for the while
next commands just prior to the @( posedge sysclk) that marks the beginning of begi
the corresponding next state. All commands must be described, including those to take re
on default values. @ (P

rl
r2

7.4.2 Pure behavioral two-state division example r3
Section 4.1.5 shows how to translate the two-state ASM chart for the childish division end
algorithm (section 2.2.7) into implicit style behavioral Verilog in a way that is suitable end

for simulation only (using the end
enternew-state task). With the technique illus-

trated in the // 
last task 

section, e
it is very easy to modify this source code so that you can endmodule

synthesize physical hardware directly from the implicit style (pure behavioral) Verilog
without having to go through the tedious "mixed" and "pure structural" stages (sec-
tions 7.4.3 

4.2 and 4.3). Mixei
The boldface in the following shows the changes to the code from

section 4.1.5: Although the co
appropriate synt

odule slowdiv-system(pb,ready,x,y,r3,sysclk); in appendix F), 
input pb,x,y,sysclk; want to create tl
output ready,r3; reader of chapte
wire pb; must also create
wire [11:0] x,y;
reg ready; machine, and th
reg [11:0] rl,r2,r3; it is possible to
//reg ['NUNSTATE_BITS-l:0] presentstate; through the tedi,
wire sysclk; Section 4.2.4 sh
always
begin machine, (whic]

ready <= (posedge sysclk) 1; signer has select
@(posedge sysclk) #1; //IDLE ing sections, hei
rl <= (posedge sysclk) x; processor (bold
r2 <= (posedge sysclk) 0;
//ready = 1;

module slow

input pb,r
output rea

2 Some synthesis tools might not produce a reliable circuit under these circumstances, and so the former //reg ['NU
method (assigning 0 to comm at the bottom of the always) might be preferred. The latter Verilog code is wire pb;
logically correct, but its physical implementation may be unreliable, depending on the clock frequency and reg ready;
the physical properties of the technology.

reg [5:0]
3Actually, the signal that clears the register is s_3, which is the OR of s999 and the wire from the reg muxctr
bottom of the always loop. wire rlgey

270 Verilog Digital Computer Design: Algorithms into Hardware



provide s999 Continued
ycle.3 When this if (pb)
averting a Moore begin
ut the <= for the while (rl >= y pb)
the beginning of begin

ing those to take ready <= (posedge sysclk) 0;
@(posedge sysclk) #1; //COMPUTE
rl <= (posedge sysclk) rl - y;
r2 <= (posedge sysclk) r2 + 1;
r3 <= (posedge sysclk) r2;

childish division end
end

.y that is suitable
end

technique illus- // task enternew state; ...
so that you can endmodule

iavioral) Verilog
ral" stages (sec- 7.4.3 Mixed two-state division example
t the code from Although the code in section 7.4.2 alone is enough to create physical hardware using

appropriate synthesis tools (perhaps with the help of the VITO preprocessor described
in appendix F), sometimes (for reasons of availability, speed or cost), the designer may
want to create the architecture manually, as described in sections 2.3.1 and 4.2.3. The
reader of chapter 4 may be left with the impression that in such a case, the designer
must also create the controller manually. In fact, as long as the controller is a Moore
machine, and the designer is willing to expend a few extra flip flops for the controller,
it is possible to go straight from the mixed stage to physical hardware, without going
through the tedious details of the "pure" structural stage.

Section 4.2.4 shows how to translate the mixed Moore ASM of the two-state division
machine, (which generates command signals for a specific architecture that the de-
signer has selected) into mixed Verilog. Using the techniques described in the preced-
ing sections, here is equivalent implicit style Verilog acceptable to the synthesis pre-
processor (bold indicates differences from section 4.2.4):

module slowdivctrl(pb,ready,aluctrl,muxctrl,ldrl,
clrr2,incr2,ldr3,rlgey,sysclk);

input pb,rlgey,sysclk;
output ready,aluctrl,muxctrl,ldrl,clrr2,incr2,ldr3;

;,a nd so the former //reg ['NUMSTATE_BITS-l:0] present_state;
atter Verilog code is wire pb;
,lock frequency and reg ready;

reg [5:0] aluctrl;

the wire from the reg muxctrl,ldrl,clrr2,incr2,ldr3;
wire rlgey,sysclk;

,are One Hot Designs 271



Continued
7.5 Bott

always Although whi
begin for many 

ready <= matt
(posedge sysclk) 1;

aluctrl <= (posedge more 
sysclk) conveniel

PASSB;
muxctrl <= (posedge sysclk) 0; approach allov
ldrl <= (posedge sysclk) 1; nique used in c
clrr2 <= @(posedge sysclk) 1; cessor. There i
incr2 <= @(posedge sysclk) 0; statement insid
ldr3 <= @(posedge sysclk) 0;
@(posedge sysclk) #1; //IDLE The disable
//rl <= @(posedge sysclk) x; lel block in a s
//r2 <= @(posedge sysclk) 0; loops for synth
//ready = 1;
//aluctrl As 

= an example
PASSB;

//muxctrl = 0; go through the
//ldrl = 1; before returnin
//clrr2 = 1;
if (pb)
begin
while (rlgey I pb)
begin

ready <= (posedge sysclk) 0;
aluctrl <=@(posedge sysclk) 'DIFFERENCE;
muxctrl <= (posedge sysclk) 1;
ldrl <= (posedge sysclk) 1;
clrr2 <= (posedge sysclk) 0;
incr2 <= @(posedge sysclk) 1;
ldr3 <= (posedge sysclk) 1;
@(posedge sysclk) #1; //COMPUTE
//ready = 0;
//rl <= @(posedge sysclk) rl - y;
//r2 <= @(posedge sysclk) r2 + 1;
//r3 <= @(posedge sysclk) r2;
//aluctrl = 'DIFFERENCE;
//muxctrl = 1;
//ldrl = 1;
//incr2 = 1;
//ldr3 = 1; Figure 7-13

end
end

end Using the simu
endmodule follows:

272 Verilog Digital Computer Design: Algorithms into Hardware



7.5 Bottom testing loops with disable inside forever
Although while loops are sufficient to implement any algorithm, and are preferable
for many mathematical problems, there are situations when a bottom testing loop is
more convenient than awhile loop. Chapter 5 describes how the enternew state
approach allows bottom testing loops to be simulated. The problem is that the tech-
nique used in chapter 5 is not acceptable to synthesis tools including the VITO prepro-
cessor. There is another approach for bottom testing loops, involving the disable
statement inside a forever loop that the preprocessor accepts.

The disable statement in Verilog has two main uses: stopping execution of a paral-
lel block in a simulator (explained in section 6.4.3) and implementing bottom testing
loops for synthesis (explained below).

As an example of a bottom testing loop, consider the following ASM. It is supposed to
go through the bottom testing loop (consisting of states TOP and BOT) five times
before returning to state OUTSIDE:

Figure 7-13. Example bottom testing loop.

Using the simulation technique of section 5.4.1, this could be translated to Verilog as
follows:

One Hot Designs 273

I



always quite differen
begin avoided usinj
@(posedge sysclk) enternew state('OUTSIDE); agree with sy
count <= (posedge sysclk) 0; testing loops.
while (count!=4 & present-state !== BOT);
begin
@(posedge sysclk) enter newstate('TOP);
@(posedge sysclk) enternew_state('BOT); 7.6 
count Con

<= (posedge sysclk) count + 1;
end One hot enco(

end hardware thar
this, a prepro,
implicit style

The above simulates correctly. However, the above cannot be synthesized into a one between the N
hot machine using the VITO preprocessor.

There are gral
An alternative way to implement a bottom testing loop is to use a forever statement Verilog, but tt
with a disable statement inside. Using a disable statement requires an extrablock designer into,
that has a label to surround the forever. The forever by itself would never exit, ful to a design
and so the disable statement causes a goto the end that matches the labeled be- to hide the de
gin. For example, the above ASM could be translated into: ASM charts c
-

always textual form
begin synthesis tooh
@(posedge sysclk) #1; //OUTSIDE (that uses the (
count <= (posedge sysclk) 0; often enough t
begin : looplab
forever The central coi
begin ioral ASM cha
@(posedge sysclk) #1; //TOP style whiles
@(posedge sysclk) #1; //BOT different than 
count <= @(posedge sysclk) count + 1; because of the
if(count==4)

hardware beca
begin
disable looplab; behavioral Ver
end fashion the ope

end 4 and 5 show I
end Verilog to one I

end manual transla

The above works correctly with the VITO preprocessor. However, this will not simu-
late properly on most Verilog simulators because the disable statement will also 7.7 Furt]
disable the non-blocking assignment. Putting # 1 in front of the disable may help on ARNOLD, MARK
some simulators, but on many simulators there seems to be no way to use disable in Verilog into On
this way properly. Therefore, the Verilog you choose for a bottom testing loop will be CA, March 31-

processor.

274 Verilog Digital Computer Design: Algorithms into Hardware



quite different if you want to simulate than if you want to synthesize. This book has
avoided using bottom testing loops in most examples in order that simulation may
agree with synthesis, but there are situations where hardware designers prefer bottom
testing loops.

7.6 Conclusion
One hot encoding provides a more natural way of translating complex algorithms into
hardware than the binary encoded approach described in earlier chapters. Because of
this, a preprocessor tool is available that directly translates an algorithm written in
implicit style behavioral Verilog into a one hot circuit. There is a one to one mapping

esized into a one between the Verilog (or the equivalent ASM) and the one hot controller.

There are graphicals oftware tools that can automatically translate an ASM chart into
,ever statement Verilog, but the use of such tools is often ill advised. The use of such tools locks the
res an extra block designer into a proprietary file format. Although manually drawn ASM charts are use-
would never exit, ful to a designer in the early stages of design, they lack the expressive power of Verilog
;t he labeled be- to hide the details of a design with good notation. Instead, this book uses graphical

ASM charts only as the master plan for the design. The details of the design occur in
textual form as implicit style behavioral Verilog. With one of several commercial
synthesis tools and perhaps the VITO synthesis preprocessor described in appendix F
(that uses the one-hot techniques given in this chapter), implicit style Verilog alone is
often enough to create operational hardware.

The central concept of this book is that algorithms can be described using pure behav-
ioral ASM charts (with RTN) or the equivalent pure behavioral Verilog (with implicit
style whiles and if s together with the non-blocking assignment). This approach is
different than traditional software because of the potential for parallel processing and
because of the idea of the system clock. This approach is different than traditional
hardware because of the emphasis on algorithms and behavior. Such implicit style
behavioral Verilog algorithms (or their equivalent ASM charts) describe in an abstract
fashion the operations carried out by some specific synchronous architecture. Chapters
4 and 5 show how you can manually design such architectures using Verilog, but the
Verilog to one hot preprocessor (explained in this chapter) eliminates the need for such
manual translation.

is will not simu-
itement will also 7.7 Further reading
ble may help on ARNOLD, MARK G. and JAMES D. SHULER, "A Preprocessor that Converts Implicit Style
use disable in Verilog into One-hot Designs," 6th InternationalV erilog HDL Conference, Santa Clara,
ting loop will be CA, March 31-April 3, 1997, pp. 38-45. Gives more information about the VITO pre-

processor.

vare One Hot Designs 275



PROSSER, FRANKLIN P. and DAVID E. WINKEL, The Art of DigitalD esign: An Introduction
to Top Down Design, Prentice Hall PTR, Englewood Cliffs, NJ, 2nd ed., 1987. Chapter 8.
5 gives examples of the one hot technique.

7.8 Exercises
7-1. Draw a circuit diagram for a one hot controller corresponding to the Moore ASM
given in section 2.2.4. Label the output of each flip flop with the name of the state. 8.1 Intr
Assume the command and status signals of the architecture are the same as in sections The machines
2.3.1 and 4.2.3. that solves a s

2. We use the
7-2. Draw a circuit diagram for a one hot controller corresponding to the Mealy ASM designed to sc
given in section 5.2.4. Label the output of each flip flop with the name of the state. forms the algc
Assume the command and status signals of the architecture are the same as in sections directly perfo
2.3.1 and 4.2.3. automation is
7-3. Draw a block diagram using muxes and combinational logic which is equivalent to Pascal's 1642
the following continuous assignment (assume that the 12-bit a and b are defined else- ence engine, ]
where): tabulated the

chess playing
wire [11:0] new a; early twentiet
assign new a =

(s_10) ? a+b It is not surpt
(s_20) ? 2*a-b : a; tube) technoli

binary counte
7-4. Rewrite the pure behavioral Verilog of section 4.1.3 into the implicit style form computer (lat(
suitable for the VITO preprocessor. (Eliminate the enternew_state task and con- taneous equat
vert ready to <= as described in section 7.4.2.) Use the preprocessor to produce the German codei
continuous assignments that are equivalent to the one hot design. Draw a circuit dia- tions of specie
gram for the one hot controller labeled with the names used in the output of the prepro-
cessor. Also draw a block diagram for the architecture constructed only with combina- In contrast to
tional logic, muxes and simple (non-enabled) D-type registers corresponding to the ? solve any pro
: in the output of the preprocessor. purpose comp

Lovelace) ens
7-5. Rewrite the pure behavioral Verilog of section 5.4.2 into the implicit style form lished a theon
suitable for the VITO preprocessor. (Eliminate the enternew_state task and con- cannot be con
vert ready to <= as described in section 7.4.2. Also, use the disable statement in a cient but plau
different way than was described in this chapter.) Use the preprocessor to produce the written. The td
continuous assignments that are equivalent to the one hot design. Draw a circuit dia- because they,
gram for the one hot controller labeled with the names used in the output of the prepro-
cessor. Also draw a block diagram for the architecture constructed only with combina-
tional logic, muxes and simple (non-enabled) D-type registers corresponding to the ? l Hollerith started
: in the output of the preprocessor. 2 The term "comp

1950s. Previousl

276 Verilog Digital Computer Design: Algorithms into Hardware



In Introduction
,1987. Chapter 8. GENERAL-PURPOSE

COMPUTERS
ie Moore ASM
ne of the state. 8.1 Introduction and history
e as in sections The machines described earlier in this book have each implemented a single algorithm

that solves a specific problem, such as the childish division algorithm given in chapter
2. We use the term special-purpose computer to describe such machines, which are

he Mealy ASM designed to solve only one problem. The designer of a special-purpose computer trans-
ne of the state. forms the algorithm which solves just that one problem into the hardware structure that
e as in sections directly performs the computations required by that specific algorithm. The history of

automation is filled with examples of such machines. Prior to the electronic age, Blaise
is equivalent to Pascal's 1642 calculator, Jacquard's automated loom, Charles Babbage's 1823 differ-
re defined else- ence engine, Herman Hollerith's' 1887 electromechanical punch card counter (which

tabulated the 1890 U.S. census), Leonardo Torres y Quevedo's 1911 electromechanical
chess playing machine as well as all of the calculators and business equipment of the
early twentieth century are illustrations of special-purpose computers.
It is not surprising that the first "computers"2 implemented with electronic (vacuum
tube) technologies were also special-purpose machines. C. E. Wynn-Williams' 1932
binary counter (for nuclear particles), John V. Atanasoff and Clifford Berry's 1938

licit style form computer (later dubbed the ABC machine) at Iowa State University for solving simul-
e task and con- taneous equations and the British Colossus machines of World War II (that cracked
to produce the German coded messages) are all illustrations of successful vacuum tube implementa-
w a circuit dia- tions of special-purpose machines that followed specific algorithms.
t of the prepro-
with combina- In contrast to such specialized machines, a general-purpose computer is designed to
nding to the ? solve any problem, limited only by the size of the machine. The idea of a general-

purpose computer is independent of any technology. Babbage and Augusta Ada (Lady
Lovelace) envisioned a machine that could create its own programs. Alan Turing pub-

licit style form lished a theoretical paper in 1936 which proved there are mathematical functions that
e task and con- cannot be computed mechanically. To do this, he envisioned a (technologically ineffi-

statement in a cient but plausible) machine programmed via a "tape" that could be both read and
to produce the written. The theoretical machines envisioned by Babbage and Turing were "universal"

w a circuit dia- because they would have the capability of self-modification.
t of the prepro-
with combina-
,nding to the ? l Hollerith started a company that later became IBM.

2 The term "computer" did not develop its current meaning as a machine that processes information until the
1950s. Previously, a "computer" was a person hired by a scientist to carry out an algorithm manually.

General-PurposeC omputers 277



Governments on both sides during World War II focused more resources on the design hardware impli
of computers than had ever occurred before. Although at first many such machines until 1951, in
were justified because they solved some important special-purpose problem, such as Institute for Ac
ballistics, the huge expense required to build and maintain such machines motivated
several independent groups t design machines that could be reused to solve different The first gener
problems. These wartime machines were not fully general-purpose in the modern sense, "Baby Mark I'
but were programmable via punched tape. The tape moved in one direction past a Manchester in
reader, and the holes told the machine what to do. Although on most such machines limited (only 3
looping was not possible (because the tape moved in only one direction) and self- software progi
modification was not possible (because once a tape was punched, it could not be June 21, 1948.
repunched), such machines made it easy to change the program by changing the tape. tional in 1949

produced in Bi
Konrad Zuse filed a patent in Germany in 1936 on such a tape-controlled machine and Wilkes and ot
built several versions of this machine, the first of which became operational in 1941. memory.
Colossus, in fact, was tape-controlled due to the flexibility required by British math-
ematicians (including Turing) who sought to break ever-changing German codes. George In the U.S., the
R. Stibitz and others at Bell Labs built several tape-controlled relay computers, some of memory, bu
of which remained in use for over a decade after the war. In 1943 Howard Aiken and start their own
others at Harvard, with the help of engineers from IBM, built the tape-controlled Harvard first general-p
Mark I, which was used by U.S. Navy personnel (including the later to become famous than 20 were s
Admiral Grace Hopper). Near the end of the war, IBM started to build the SSEC, which Since the earl)
was unique among the tape-controlled computers of the war because it had some lim- pose computer
ited ability for the type of self-modification alluded to by Babbage and Turing (and was in the details, 
therefore almost a true general-purpose computer). execute, whicl
John P. Eckert, John W. Mauchly and others in the Moore School at the University of
Pennsylvania built ENIAC from 1943 to 1945 for ballistic computations required by
the U. S. Army. It was the largest computer built during the war, constructed with an
order of magnitude more vacuum tubes (nearly 20,000) than 8.2 

any of the other Stru
machines.

Unlike other machines of the era, it was not programmed via a tape, but instead it had Since the Man
to be rewired (via a plugboard) to solve a different problem. (Designing a "program" overall top-lei
for the ENIAC was similar to designing the controller and architecture as illustrated in
chapter 2). This made ENIAC far more specialized and inconvenient than the tape-
controlled machines. Recognizing this inconvenience, people at the Moore School (no-
tably John von Neumann) proposed building EDVAC, which would represent pro-
grams in the same memory as data, rather than on tape or with a plugboard.

Although EDVAC was not the first general-purpose computer to become operational,
von Neumann's 1945 poposal was profoundly influential. To this day, his name is
synonymous with general-purpose computers that store their programs in the same
memory as their data and that use what we now call the fetch/execute algorithm. The

Figure 8-1

278 Verilog Digital Computer Design: Algorithms into Hardware



on the design hardware implementation of the actual EDVAC machine did not become operational
uch machines until 1951, in part because von Neumann left the Moore School to join Princeton's
blem, such as Institute for Advanced Studies where he designed the IAS machine.
nes motivated
solve different The first general-purpose computer to become operational was a prototype (known as
modem sense, "Baby Mark I") built by Frederic C. Williams and Tom Kilbum at the University of
rection past a Manchester in England. Although small (less than one thousand vacuum tubes) and
uch machines limited (only 32 words of memory and no hardware support for division), it ran its first
ion) and self- software program (division using the childish algorithm described in chapter 2) on
could not be June 21, 1948. A later version of this machine, the Manchester Mark I, became opera-

iging the tape. tional in 1949 with 128 words of memory. A commercial version of the Mark I was
produced in Britain a few years later by Ferranti. Also in Britain during 1949, Maurice

I machine and Wilkes and others at Cambridge completed the EDSAC, which had 512 words of
ional in 1941. memory.
British math-
codes. George In the U.S., the first operational general-purpose computer was BINAC with 512 words
nputers, some of memory, built in 1949 by Eckert and Mauchly after they left the Moore School to
ard Aiken and start their own company. Their company later produced the UNIVAC, which was the
rolled Harvard first general-purpose computer that was commercially successful in the U.S. (more
,come famous than 20 were sold).
SSEC, which Since the early 1950s, thousands of slightly different implementations of general-pur-

had some lim- pose computers have proliferated worldwide. Although they differ quite significantly
iring (and was in the details, all of them implement essentially the same algorithm in hardware: fetch/

execute, which is the subject of this chapter.
University of
is required by
ucted with an
her machines. 8.2 Structure of the machine
instead it had Since the Manchester Mark I, almost all general-purpose machines have had the same
a "program" overall top-level structure, illustrated by the following diagram:
si llustrated in

than the tape-
re School (no-
epresent pro-
ard.

e operational,
r, his name is
si n the same

lgorithm. The

Figure 8-1. Block diagram of typical general-purpose computer

General-PurposeC omputers 279



- -

8.2.1 CPU, peripheral and memory means the a(
There are typically three components of a general-purpose machine: 1001011101

1. The Central Processing Unit (CPU) is composed of a controller and an architec- 2423. We A
ture. As discussed in chapter 2, for special-purpose computers, the architecture is There are fit
where the ALU(s), register(s) and other computational elements reside. tional versus

2. The peripheral(s) are distinct special-purpose computer(s) that interface the CPU cess time (se
to outside actors, such as a keyboard. Each interface typically has its own control- versus dynar
ler and architecture, including synchronizers as required.

3. Memory is a special kind of device that stores the bits that can represent both 8.2.2.1 
programs and data. There are tw(

Sections 8.3 and 8.4 of this chapter will illustrate how system. 
the One

same techniques used for
special-purpose computers in chapter 2 can implement the CPU and the 

of other
a general-purpose

computer. The next section describes memory. bus.

The simplest

8.2.2 Memory: data and the stored of 
program memory 

type of mem(
The one component that has not been discussed in detail previously is memory.3 From bit-wide dou
a behavioral standpoint, a memory is simply an array of words. The subscript to this is another inp
array is known as an address. We will refer to the number of bits required for the device, which
address as a. The designer can choose how many bits (d) are in each word, and also
how many words (2 a) are in the memory. For example, Williams and Kilburn's first
machine had a word size of 32 bits, and there were 32 such words in the memory (five
address bits). Therefore, their memory had 32*25 = 1024 bits total. Later in this chapter
we will design a machine with 4096 words (12-bit address), and a wordsize of 12-bits.
This machine will require a memory with 12*212 = 49,152 bits. Most machines typi-
cally have memories that hold billions of bits, but that is a detail that is irrelevant to
learning the essential ideas of this chapter.
In this chapter and in appendices A and B, we will indicate both address and contents of Figure 8-2.
memory in octal. As an abbreviation, the address will be shown on the left, and the
contents will be shown on the right, with a slash separating the address from the con-
tents. For example, A bidirection6

diagram, a bid
bidirectionalit
illustrated in t]

I 0123/4567 1

4
3T he A 

memory different 
we issue

are talking about can be used both to store and retreive bits. It is refered to as "RAM" by
some Multi-ported 

people. mem
read port and one

280 Verilog Digital Computer Design: Algorithms into Hardware



means the address is 01238 == 0000010100112 == 83 and the contents is 45678 ==
1001011101112 == 2423, or more succinctly in array notation, memory 83] ==

I an architec- 2423. We will sometimes abbreviate even further to say m [83] = = 2423.
irchitecture is There are five independent issues that can be used to categorize memory: unidirec-
side. tional versus bidirectional (section 8.2.2.1), deterministic versus non-deterministic ac-
face the CPU cess time (section 8.2.2.2), synchronous versus asynchronous (section 8.2.2.3), static
own control- versus dynamic (section 8.2.2.4) and volatile versus non-volatile (section 8.2.2.5).4

-esentb oth 8.2.2.1 Unidirectionalb uses versus a bidirectionalb us
There are two common variations on how a memory device connects to the rest of the
system. One approach uses simple unidirectional buses of the type seen 

ques used in chapter 
for 2,

and the other combines two data buses together into what is known 
neral-purpose as a bidirectional

bus.

The simplest form of memory has two input buses and one output bus. This simple type
of memory with only unidirectional buses is what we will use in this chapter. In this
type of memory, the d-bit-wide din bus is an input to the memory device, 

emory. 3 and the d-
From bit-wide dout bus is the output of the memory device. Also, the a-bit wide addr bus

bscript to this is another input to the memory device. There must be additional input(s) to the memory
luired for the device, which are described in later sections.
tord, and also 4'

Kilburn's first mlI

memory (five
in this chapter din memory dout

dd
ize of 12-bits.
machines typi- addr I
si rrelevant to other a

input(s)

nd contents of Figure 8-2. Symbol for memory with unidirectional data buses.
left, and the

from the con- A bidirectionalb us is one that is used to send information two ways. In the following
diagram, a bidirectional bus is indicated by an arrow that points both ways. In this case,
bidirectionality allows combining the din and dout buses, into a single data bus as
illustrated in the following:

4 A different issue related to memory (not discussed in this chapter) is how many ports the memory has.
I to as "RAM" by Multi-ported memory is discussed in section 9.8, but in this chapter all memory is assumed to have only one

read port and one write port, as illustrated in the following sections.

re General-PurposeC omputers 281



In addition to
addr_ memory data

tells the memc
other the machine, it
input(s) > with separate

Figure 8-3. Symbolfor memory with bidirectionald ata bus.

The advantage of bidirectionality is that there are fewer wires connecting the memory
device to the rest of the system, however, interfacing to such a device is more compli-
cated. This requires the use of tri-state buffers. Except for such tri-state buffers, the
internal structure of this memory is identical to that of a memory with separate din
and dout buses. We will not consider memory devices with bidirectional buses in this Figure 8-4.
chapter.

There are two
8.2.2.2 Deterministic versus non-deterministic access time reflects the coi
Like all other physical devices, the actual memory hardware is not instantaneous. Al- words, neglect
though at the early behavioral stages of the design we prefer to ignore the time it takes
to use the memory (known as the access time), ultimately, the speed of the memory will
have a major influence on the speed of a general-purpose computer (since both the
program and the data have to be obtained from the same memory). In the final stages of
design, the designer must consider memory timing.

The second thi
When the access time is deterministic, the time to obtain an arbitrary bit from memory the next rising
does not vary significantly as a function of the address. address bus ch;

Almost all primary memories used today have deterministic access times. Almost all
secondary memories (e.g., disk drives) have non-deterministic access times.

8.2.2.3 Synchronous versus asynchronous memory
There are two different ways in which the memory timing can occur: synchronous and Note that almc
asynchronous. The difference is whether or not the memory uses the system clock. most one word

ported.5 If 1drn

8.2.2.3.1 Synchronous memory A synchronous
This kind of memory is the fastest, most expensive and simplest for the designer to not usually the
incorporate. This kind of memory is commonly used where speed is important, such as structure that as
in pipelined systems (section 6.5.8.3) or RISC computers (chapter 10). Because of its
cost, it has not generally been used for the primary memory of a stored program com-
puter, although recently, as clock speeds have increased, synchronous primary memo-
ries have become more commonplace.

5Chapters 9 and IC
cycle.

282 Verilog Digital Computer Design: Algorithms into Hardware



In addition to the address and data buses, there must be a command input, ldmem, that
tells the memory what to do. In order for the memory to be synchronous with the rest of
the machine, it also needs a clock input. The top-level structure of a synchronous memory
with separate din and dout is shown below:

dout
g the memory
more compli- Idn
e buffers, the

so
separate din
I buses in this Figure8 -4. Symbolfor synchronous memory.

There are two things that the device does. Given enough time, the output of the device
te reflects the contents of the memory at the word indicated by the address bus. In other
intaneous. Al- words, neglecting the propagation delay (i.e., neglecting the access time),
e time it takes
em emory will
;ince both the I dout = memory[addr]
final stages of

The second thing that the memory can do is based on the ldmem command signal. On
from memory the next rising edge after ldmem becomes true, the word in memory indicated by the

address bus changes to become the value of the data input bus,
es. Almost all
mes. I memory[addr] - din

ichronous and Note that almost instantly after this change takes effect, dout will also change. At
item clock. most one word in memory can be changed in one clock cycle when a memory is single-

ported.5 If ldmnem is not true, memory remains unchanged.

A synchronous memory device can be thought of as a bank of registers. Although it is
ie designer to not usually the most efficient way to build a memory, the following diagram shows a
Drtant, such as structure that achieves this goal:
Because of its
program com-
imary memo-

5Chapters 9 and 10 describe multi-ported memories that allow more than one memory operation per clock
cycle.

General-PurposeC omputers 283

k



w

8.2.2.3.2
A significant
being provide
been asynchr(
cope with a r

The block dia
ports) is:

dout

I N I V I
Figure 8-6.

L…
L ---------------------------------- ,

Here the writ
Figure 8-5. Implementation of synchronous memory. nal. Asynchror

directional bus
This diagram uses 2a enabled registers, each containing d bits. It also has a 1* 2a demux In general, 
and as)

a d*2a mux.
expert designe

Let's ignore the left-hand side of this diagram (the demux that connects to the ldmem (electronic) de
signal) for the moment. For example, assume the proper data has already been placed HDLs, the vast
in each register, and the user wishes to obtain the contents of one of the memory loca- synchronous d(
tions. The user provides the address of the desired memory cell on the addr bus. The design is beyot
mux selects the output of the corresponding register, and outputs that on the dout bus. ture that implei

8.2.2.3.1).
To understand how a user is able to write new data into memory, you need to recall
what the combinational logic of a demux does. When ldmem is 0, the demux will Fortunately, sir
produce Os on all of its 2a outputs, so none of the registers would change. When 1 dmem hidden most of
is 1, the demux will output a 1 on exactly one of its outputs and Os on the others. The To cope safely 
output that is 1 will be determined by the value of the addr bus. Therefore if ldmem to do:
is 1, only the contents of the register corresponding to the current addr bus will change 1. Choose a 
at the next rising edge of the clock.

time of th(
Notice that the above implementation has a deterministic access time (essentially the small fraci
propagation delay of the mux). It is possible to build a synchronous clocked memory and write,
based on shift registers, where the access time varies depending on how many clock 2. 
cycles Hold 

are add:
required to shift the desired bit out. However, there is seldom any advantage cycle 

to wri
such a memory.

registers ir

284 Verilog Digital Computer Design: Algorithms into Hardware



8.2.2.3.2 Asynchronous memory
A significant portion of the cost of the memory shown in 8.2.2.3.1 is due to the clock
being provided to each register. All of the cheaper memory technologies invented have
been asynchronous, which means they do not use the system clock. If the designer can
cope with a memory that is asynchronous, the cost of memory can be reduced.
The block diagram for such an asynchronous memory (with separate din and dout
ports) is:

-7"* dout
d

dout

Figure 8-6. Symbol for asynchronous memory.

Here the write signal combines the roles of the ldmem signal and the sysclk sig-
nal. Asynchronous memory may also have a bidirectional data bus instead of two uni-
directional buses.

a 1*2a demux In general, asynchronous design is highly unsafe, and should only be attempted by
expert designers. Proper asynchronous design involves consideration of much lower

to the ldmem (electronic) details than is the case for synchronous design. With the introduction of
dy been placed HDLs, the vast majority of design (such as CPUs) in industry is synchronous because
bm emory loca- synchronous designs are much more likely to be synthesized correctly. Asynchronous
addr bus. The design is beyond the scope of this text, and so we will not consider the internal struc-
the dout bus. ture that implements this memory (although it is similar in concept to the diagram in

8.2.2.3.1).
need to recall

he demux will Fortunately, since memory is such an important commodity, electronic experts have
. When ldmem hidden most of the asynchronous ugliness inside commonly available memory chips.
the others. The To cope safely with such devices, there are only three extra things that the designer has
-fore if ldmem to do:
)us will change 1. Choose a conservative clock speed for the rest of the system relative to the access

time of the memory. In other words, the access time of the memory should be a
(essentially the small fraction of the clock period. Some memories have a different time for read
ocked memory and write, and so you should choose the larger of these.
w many clock 2. Hold addr and din constant for at least one clock cycle before and during the
any advantage cycle write is active. This means both addr and din should come from

registers in the architecture that are not changed during this time.

7re General-PurposeC omputers 285



3. Make sure there are no hazards in write (see section 6.3.3). As long as the con- the fetch/exect
troller is a Moore machine, this is easy to guarantee (section 7.4). makes your ca

Sometime after the memory receives the write pulse but before the access time has From the histo
elapsed, the asynchronous memory will latch the new value into memory. In this way, the general-pui
the asynchronous write pulse combines the role of the system clock and the dmem phrase above:
signal. enough so the

mentation of g
8.2.2.4 Static versus dynamic memory components of

Static memory retains its contents regardless of whether it is used or not. The only As the ABC, C
limitation on using static memory is that the clock speed can be no faster than the the start of Woi
access time. (More precisely, the maximum clock speed needs to consider all propaga- lern from the la
tion delays, including access time. Examples of calculating the maximum possible clock aware of techni
speed are given in chapter 6.) access, the cost

ries 
Dynamic of this kind

memory places an additional requirement on the designer. Not only is there a
maximum possible computers. 

clock It t,
speed, but there is also a minimum clock speed. This is be- whatever 

cause every techn
word in dynamic memory needs to be refreshed. Dynamic memory tech- 6 *d*2a switch

nology is usually based on very cheap electrical devices known as capacitors, which ing 
store devices 

charge. to 
Over c

time, the charge leaks away. Unless the capacitors are refreshed, the makes the total;
information will disappear.

memory unit al
Dynamic memory is the cheapest kind of fast memory that is currently available. For For 
problems Williams an

where the machine will continually use all memory addresses over and over, small 
there for 

is no practic,
extra inconvenience to use dynamic memory. For most other problems, tubes, 

where which 
this is 

cannot be guaranteed, it is best to use a dynamic memory controllerb etween entire CPU. 
the (Th,

dynamic memory and the rest of the system. in vacuum tubes
tic.)

8.2.2.5 Volatile versus non-volatile In order to builc
A memory device is volatile if it loses its contents when the power is turned off. A that were more e
memory device is non-volatile if it can retain its contents without consuming any power. mechanical men
A memory technology that is inherently non-volatile would be desirable because it conceptually sin
allows a program to remain in memory when the power is turned off; however with creative, neither
most technologies, it is more cost-effective to provide a backup battery to preserve pose computer ii
memory contents when the power to the rest of the system is removed.

The breakthroug
bits in the Mark I

8.2.3 History of memory technology tional, asynchroi
One of the recurring themes of this book is that technology changes, but algorithms the first affordal
endure. This means the time you spend honing your problem solving skills will benefit
you throughout your career because such skills do not become outdated. Learning about

6For example, mode
general-purpose corn

286 Verilog Digital Computer Design: Algorithms into Hardware



ing as the con- the fetch/execute algorithm in particular is important because it is the algorithm which
makes your career possible.6

ccess time has From the historical account in section 8. 1, you might wonder why it took so long for
ry. In this way, the general-purpose computer to be realized. The reason is a corollary to the italicized
nd the ldmem phrase above: some algorithms have to wait to be implemented until technology changes

enough so the hardware is affordable and practical. To see how this postponed imple-
mentation of general-purpose computers until after World War II, consider the three
components of a general-purpose machine: CPU, peripherals and memory.

not. The only As the ABC, Colossus and ENIAC illustrate, vacuum tube technology was available by
faster than the the start of World War II to implement CPUs and peripherals. The technological prob-
er all propaga- lem from the late 1930s until the early 1950s was memory. Although the pioneers were
possible clock aware of techniques like section 8.2.2.1.1 and used small memories of this sort for data

access, the cost of storing programs in such memory was prohibitive. Currently, memo-
ries of this kind are commonly used, but not as the primary memory for stored program

only is there a computers. It takes about six switching devices (relays, vacuum tubes, transistors or
bed. This is be- whatever technology is in vogue) to construct an enabled flip flop, so it would take
memory tech- 6 * d* 2 a switching devices to build the registers. It takes approximately a * 2 a switch-

)acitors, which ing devices to construct the demux, and d*a*2a switching devices for the mux. This
Dr efreshed, the makes the total about ( (a+ 6) * d + a) * 2 a switching devices to construct a working

memory unit along the lines shown in section 8.2.2.3.1.
available. For For Williams and Kilburn's 32 word memory (which, even in 1948, was considered too

;o ver and over, small for practical programming), this would require ((5+6)*32 + 5)*32 = 11,424 vacuum
ither problems, tubes, which is more than an order of magnitude more tubes than was required for their
troller between entire CPU. (The ENIAC used about 20,000 vacuum tubes because it stored all its data

in vacuum tubes. Also, storing a program in vacuum tubes would have been unrealis-
tic.)

In order to build their machines, the pioneers had to invent technologies for memory
is turned off. A that were more efficient and reliable than simple vacuum tubes. Zuse invented a binary
ning any power. mechanical memory. Atanasoff invented a rotating drum using capacitors (which is
able because it conceptually similar to the dynamic memory chips in widespread use today). Although
; however with creative, neither of these technologies would have been reasonable for a general-pur-
ery to preserve pose computer in the 1940s.

The breakthrough came when Williams and Kilburn invented a TV-like tube for storing
bits in the Mark I. Using the terminology defined above, the Williams tube was bidirec-
tional, asynchronous, dynamic and volatile. Most importantly, the Williams tube was
the first affordable technology 

but algorithms that had the same kind of deterministic access time
dills will benefit
Learning about

6For example, modem Verilog simulators and synthesis tools are possible only because of large and fast
general-purpose computers.

7are General-PurposeC omputers 287



provided by the mux in section 8.2.2.3.1. The Williams tube also had the desirable side Almost all inte
effect that a programmer could actually see every bit in memory (since they were actu- research occun
ally stored as glowing dots of electric charge on the phosphor screen). however these
The only other cost-effective memory technology available before 1953 was the delay Some integrate
line, which had been used during the war for (analog) radar signals. These were also Larger memori,
bidirectional, asynchronous, dynamic and volatile. The problem with delay lines is that packed onto a c
they do not have deterministic access times. A delay line memory recirculates the same devices per bit
data over and over again. One has to wait until the desired data comes out of the delay
line before it can be used. Therefore, there is a range of possible access times, the Many integrate
longest of which is quite slow. Wilkes as well as Eckert and Mauchly used such delay operate slowly
lines for the memory on their first general-purpose machines. Most computers of the computer desigi
early 950s used delay lines, including IBM's first general-purpose machine, the model memories. Desl
701. ference is betw

capacitor per bi
In 1953, Jay W. Forrester at MIT invented a new memory technology that stores each
bit on a small doughnut-shaped magnetic core. Wires were woven through the cores to Almost all exisi
interface them to the system. By selecting which wire electric current flows through, ferrous semicon
the system could selectively magnetize or demagnetize each core (corresponding to the early 1990s.
storing a I or a 0). Core memory is fast compared to earlier technologies. It is also to be seen at the
nearly ideal from a designer's viewpoint. It is unidirectional, deterministic, asynchro- One principal lii
nous, static and non-volatile. It is far less expensive to construct a core memory of a nect the memor
given size than to construct a comparable memory (of the kind outlined in sections and others to ovi
8.2.2.3.1 and 8.2.2.3.2) using vacuum tubes or transistors. Core memory dominated the as memory. Wh(
computer industry until the late 970s so much so that the term "core" became synony- mains to be seen
mous with the primary memory of a general-purpose computer. The first practical ap-
plication of core memory was in Forrester's general-purpose Whirlwind computers, For the first quari
used by the U. S. Air Force for strategic defense for decades. Although it is not as cheap devices changed
as the technology that replaced it, the military continues to use core memory because it memory looked
is non-volatile, and it can retain its contents better than any other technologies when in ing changed to 
close proximity to a nuclear explosion. have remained e

ules (SIMMs) an
The final technological change for memory occurred at the end of the 1960s when your hand and t]
Robert Noyce, Gordon Moore and others at Intel developed semiconductor integrated several dynamic
circuit memories that had all of the hardware for a memory similar to the one described
in 8.2.2.3.1 on a single chip of silicon. What the preferrc

of course, unclea
Integrated circuit memories come in many varieties. Today there are many competing of the phosphor ii
manufacturers worldwide of interchangeable memory chips. A designer is able to choose gone away. In the
from many different chips in a trade-off between speed, cost and ease of design. cessed using lasei
Some chips are unidirectional, but others are bidirectional. Since the number of pins on nitude more bits
an integrated circuit tends to be more of a constraint than the number of devices that perhaps some nai
can fit on the chip, larger integrated circuit memories tend to be bidirectional. sue Zuse's memo

288 Verilog Digital Computer Design: Algorithms into Hardware



ied esirable side Almost all integrated circuit memories have deterministic access times. In the 1970s,
they were actu- research occurred in magnetic "bubble" memories with non-deterministic access times,

however these memories did not succeed in the marketplace.
53 was the delay Some integrated circuit memories are synchronous, but many others are asynchronous.
These were also Larger memories have tended to be asynchronous because that enables more bits to be
lelay lines is that packed onto a chip of comparable area. The difference is between about six switching
culates the same devices per bit versus only two switching devices per bit.
out of the delay

Many integrated 
ccess times, circuit 

the memories are static, which allows designers to observe them
operate 

used slowly 
such enough 

delay for the details to be intelligible. Such memories are ideal for a
:omputers computer 

of the design lab. Also, static memories tend to be faster than comparable dynamic
chine, the memories. 

model Despite these desirable properties, larger memories are dynamic. The dif-
ference is between two switching devices per bit versus one switching device and a
capacitor per bit. Synchronous dynamic memories offer high speed at low cost.

that stores each
Almost 

)ugh the all 
cores existing 

to integrated circuit memories are volatile. Successful research into
ferrous 

it flows semiconductors 
through, that would in essence put core memory on a chip occurred in

orresponding the 
to early 1990s. Whether such memories will be successfully commercialized remains

logies. to be 
It seen 

is also at the time of this writing.
nistic, asynchro- One principal limitation of integrated circuit memories is the number of pins that con-
re memory of a nect the memory to the CPU. In the mid 1990s, attempts were made by Cray Computer

lined in sections and others to overcome this restriction by fabricating multiple CPUs on the same chip
ry dominated the as memory. Whether such "smart memories" will be successfully commercialized re-
became synony- mains to be seen at the time of this writing.
irst practical ap-

For 
wvind the 

computers, first quarter of a century of the computer age, the physical appearance of memory
it devices 

is not changed 
as cheap radically as technology improved. For the second quarter of a century,

memory 
-mory looked 

because basically 
it the same: a silicon chip. As bit densities increased, packag-

ing changed 
ologies to hold 

when more 
in bits, but the semiconductor electronics that store each bit

have remained essentially the same. By the mid 1990s, Single In-line Memory Mod-
ules (SIMMs) and Dual In-line Memory Modules (DIMMs) that can fit in the palm of

the 1960s when your hand and that can contain billions of bits became a common way to package
iuctor integrated several dynamic memory chips.
he one described

What the preferred memory technology will look like by the end of the 21 st century is,
of course, unclear. Although visibility of bits was simply a side effect of the properties

many competing of the phosphor in the Williams tube, the idea of using light to store information has not
is able to choose gone away. In the late 1990s, prototype photochemical and holographic memories ac-
of design. cessed using lasers were demonstrated that have the potential of storing orders of mag-

nitude 
umber more 

of pins bits than 
on semiconductor memories. Daydreaming farther into the future,

r of devices perhaps 
that some nanomechanical computer designer in the 21st century might even pur-

sue Zuse's 
ectional. memory designs at the atomic scale!

ware General-PurposeC omputers 289

iI



What is certain is that the cost, speed and capacity of integrated circuit memory has For readers wit]
improved radically in the last quarter century. It is likely these improvements will con- a short introdui
tinue well into the 21 st century. That these technological factors have improved expo- level language,
nentially is in large part responsible for the success of the general-purpose computer, used in later se
which needs to store both its programs and its data in memory.

8.3.1 Limi
Although the fe

8.3 Behavioral fetch/execute machine-specif

The three components of a general-purpose computer described in section 8.2 (CPU, tion set is the so

peripherals and memory) act together as a unified system that implements the fetch/ software on a p;

execute algorithm. This section describes how to model the behavior of this unified ware is only c;

system with an ASM chart, without regard to the structural interconnection of the hard- Although conc

ware. This section explains what is referred to in chapter 2 as the "pure" behavioral different instru

stage of the top-down design process. Later, in section 8.4, the "mixed" stage of the
top-down design process shows some of the structural interconnections for the CPU 8.3.1.1 The
and memory. We need a sim;
This section focuses on the algorithm that makes the general-purpose possible: fetch/ the stages of th
execute. Although the details of the fetch/execute algorithm vary widely among the (which has reir
thousands of general-purpose machines designed and built since 1948, the fundamen- unique hardwai
tal operations of the fetch/execute algorithm have remained essentially the same: we will use as a

PDP-8 is a cla
1. Fetch the current instruction from memory struction set. (a
2. If needed, fetch data from memory had this simple
3. Prepare for fetching the next instruction
4. Decode and execute the current instruction

a) Interpret what the current instruction means 8.3.1.2 His
b) Carry out the operation asked for by the current instruction, possibly The PDP-8, wh

modifying memory is pivotal in th(
cost only a few

Steps 2 and 4 have details that are machine specific. It may be possible to rearrange the
achieve this wil

order in which steps 2, 3 and 4 occur, depending on these machine-specific details.
simple and the

A general-purpose computer can modify its instructions without programmer interven- proved technol
tion because it uses the same memory to store instructions as it uses to store data. In tion set. These;
other words, it can treat instructions as though they were data. This characteristic of
universal machines, known as self-modification, is difficult for programmers to use
effectively. However, this capability is the key to the success of the general-purpose 8.3.1.3 Instr
computer. The ability for self-modification allows software (known as compilers and The complete P
assemblers) to translate programs automatically from an easy to understand high-level instructions. E)
language (C, Java, Pascal, Verilog, etc.) to the much more tedious machine language sets ever design
that is specific to the hardware. would distract I

290 Verilog Digital Computer Design: Algorithms into Hardware

-



jit memory has For readers without intimate experience with low-level programming, appendix A gives
ments will con- a short introduction to machine and assembly language (and how they relate to high-
mproved expo- level language) using an example of adding three numbers. This example will also be
pose computer, used in later sections of this chapter.

8.3.1 Limited instruction set
Although the fetch/execute algorithm is similar on all general-purpose computers, the
machine-specific details depend on the instruction set being implemented. The instruc-

-tion 8.2 (CPU, tion set is the set of machine language bit patterns that the hardware can interpret. All
nents the fetch/ software on a particular machine is eventually translated to such instructions. The hard-

of this unified ware is only capable of executing instructions that are in its unique instruction set.
tion of the hard- Although conceptually similar, a different model computer probably has an entirely
ure" behavioral different instruction set.
ed" stage of the
ns for the CPU 8.3.1.1 The PDP-8

We need a simple yet concrete example of an instruction set so that we can go through
possible: fetch/ the stages of the top-down process, starting at the abstract algorithm for fetch/execute
dely among the (which has remained essentially unchanged for half a century) and concluding with a
the fundamen- unique hardware structure that implements those instructions. The instruction set that
yth e same: we will use as an example in this chapter is a subset of the PDP-8's instruction set. The

PDP-8 is a classic example of what is called a single-accumulator, one-address in-
struction set. (All early stored program machines, including the Manchester Mark I,
had this simple kind of instruction set.)

8.3.1.2 History of the PDP-8
iction, possibly The PDP-8, which was designed by C. Gordon Bell and Ed DeCastro at DEC in 1965,

is pivotal in the history of general-purpose computers. It was the first computer that
to rearrange the cost only a few thousand rather than hundreds of thousands of dollars. Bell was able to
-cific details. achieve this with core memory and transistor technology by keeping the instruction set

simple and the memory small. The PDP-8 continued to be manufactured (with im-
ummer interven- proved technologies) into the 1990s due to the simplicity and elegance of its instruc-
to store data. In tion set. These attributes also make it an ideal example of the fetch/execute algorithm.
characteristic of
rammers to use
general-purpose 8.3.1.3 Instruction subset
s compilers and The complete PDP-8 instruction set, which is described in appendix B, has about thirty
stand high-level instructions. Even though the PDP-8 has one of the simplest and smallest instruction
chine language sets ever designed, attempting to concentrate on all thirty of these instructions at once

would distract from our primary goal: understanding the enduring fetch/execute algo-

,are General-PurposeC omputers 291



rithm. Therefore, for the example in this section, we will implement a machine that Some of the
executes only the following four PDP-8 instructions (that are also used in the example registers are
of summing three numbers in appendix A): is the primar

other registel
dix A, we wi]

octal
mnemonic machines, su

machine what the mnemonic stands for
nipulate. 

language We 
model. Some

TAD lxxx add memory to accumulator (Twos this term sinc
complement ADd) the internal a

DCA 3xxx Deposit accumulator in memory and In addition t(
Clear Accumulator

CLA 7200 CLear Accumulator fetch/execute
HLT 7402 HaLT pc, and the 

of the next in
about to exec

This subset does not contain enough of the PDP-8's instruction set for practical pro- simply loop f
gramming, but it provides a good introduction to fetch/execute. The capitalized letters
explain what the mnemonic stands for. The first two instructions (TAD and DCA) are 1. fetch the
memory reference instructions, which require the machine to calculate an effective 2. calculau
address (the address of the data in memory that the instruction is going to reference). 3. incremei
Although, like most other instruction sets, the PDP-8 has several variations (known as 4. decode E
addressingm odes) on how to calculate the effective address, we will only consider the where m refen
simplest one of these, known as direct page zero addressing. (Two bits in the instruc- of HLT instru
tion register determine which addressing mode the machine uses.) With direct page there needs to
zero addressing mode, the effective address is simply the low-order seven bits of the ecuted an HL
instruction, denoted as xxx in the octal machine language above. The reason the PDP- instruction, hi
8 is known as a one-address machine is because each instruction uses at most a single is O.
effective address.

The machine
The next instruction (CLA) manipulates the accumulator register without referencing manipulated b
memory; therefore it does not need an effective address. The final instruction (HLT) different time,
causes the machine to stop executing a program and instead proceed to a special state have an additi
where the machine waits until an external signal tells it to run another program. data that was i

tion.
8.3.1.4 Registers neededforfetch/execute In later stages
The pure behavioral ASM for a general-purpose computer uses register transfer nota- sole source pr(
tion, similar to that of a special-purpose computer, as explained in chapter 2. Therefore, stage, we can
we need to determine what registers will be manipulated in the behavioral fetch/ex- references to r
ecute ASM. ences, m[pc]

din input to t
store somethin
behavioral AS]

292 Verilog Digital Computer Design: Algorithms into Hardware



- F_

a machine that Some of the registers are specified by the specific instruction set. The details of these
I in the example registers are machine dependent. In the case of the PDP-8, the 12-bit accumulator, ac,

is the primary register that the machine language programmer uses. (There are a few
other registers, such as the l ink, that are specific to the PDP-8. As was done in appen-
dix A, we will ignore these for the moment in order to keep this example simple.) Other
machines, such as the Pentium, have different registers that the programmer can ma-
nipulate. We refer to the registers that are visible to the programmer as the programmer's
model. Some people refer to these as the computer architecture;h owever we do not use
this term since the registers in the programmer's model are not everything contained in
the internal architecture of the CPU.

ry and In addition to the registers required to implement a specific machine language, the
fetch/execute algorithm requires the hardware to have two registers: the program counter,
pc, and the instruction register, ir. Typically, the pc contains the address in memory
of the next instruction to execute, and the ir contains the current instruction which is
about to execute. If the machine did not have an HLT instruction, the machine would

)r practical pro- simply loop forever doing the four phases of the algorithm:
ipitalized letters
) and DCA) are 1. fetch the instruction from m [pcI into ir
,ate an effective 2. calculate the effective address
ig to reference). 3. increment the pc (prepare for fetch of next instruction)
tions (known as 4. decode and execute the instruction in the i r
nly consider the where m refers to memory array. Most machines, including the PDP-8, have some form
s in the instruc- of HLT instruction. In order to keep track of whether the machine has halted or not,
Vith direct page there needs to be an additional one-bit register, halt. When the machine has not ex-
even bits of the ecuted an HLT instruction, halt is 0. When the machine has just executed an HLT
season the PDP- instruction, halt becomes 1. The fetch/execute algorithm proceeds only when halt
at most a single is 0.

The machine needs a register to hold the effective address of data in memory to be
lout referencing manipulated by an instruction. This register, which may be used for other purposes at
struction (HLT) different times, is known as the memory address register, ma. It will be convenient to
o a special state have an additional register, known as the memory buffer register, mb, to contain the
program. data that was in memory at the effective address prior to the execution of the instruc-

tion.

In later stages of the top-down design process, it will be convenient to have ma as the
,r transfer nota- sole source providing the addr input to the memory device. At the "pure" behavioral
ter 2. Therefore, stage, we can ensure this is possible by restricting the use of the memory array. All
vioral fetch/ex- references to memory must be m [ma], rather than the somewhat more natural refer-

ences, m [pc . Also it will be convenient to have mb as the sole source providing the
din input to the memory device. In the restricted behavioral ASM, the only way to
store something into memory is by saying m[ma] - mb. This will require that the
behavioral ASM have states that initialize mb properly.

'are General-PurposeC omputers 293



-

8.3.1.5 ASMforfetch/execute For ease of n(
The following is an ASM that implements the fetch/execute algorithm for the tiny are in octal. S
instruction set described in section 8.3.1.3: the first letter

the fetch/exe
have to do wi
letter "E" has
names begin 
the fetch/exec

When the ma
halt is initi.
example) whe
the program n
starts at 0100.

When halt i!
IDLE state, it,
that tells it to
proceeds to th
Fl. Since state
IDLE until the
instruction.

State Fl is nec
end of section 
that should be (
algorithm, or I
natural to say
tioned restricti,
information, ai
used by a later
register.

State F also n
finished execut
(the machine ju
IDLE as explai

If halt is not 
for executing ti

Figure 8-7. ASM implementing four instructions of PDP-8. counter. The pli
program countc
(For example,:
match the desci

294 Verilog Digital Computer Design: Algorithms into Hardware



For ease of notation, the four-digit constants in the above ASM (0100, 7200 and 7402)
ithm- 4mf ortr the- tiny are in octal. Smaller constants are shown in decimal. Although the names are arbitrary,

the first letter in the names chosen for most of the states indicates the role of the state in
the fetch/execute algorithm. States whose names begin with the letter "F" primarily
have to do with the fetch aspect of the algorithm. States whose names begin with the
letter "E" have to do with execution of machine language instructions. States whose
names begin with other letters (e.g., "I") have to do with aspects of the machine besides
the fetch/execute algorithm, such as interfacing to the programmer.
When the machine is first powered on, it goes through the INIT state once, where
halt is initially set to 1, and pc is set to an arbitrary address (0100 octal in this
example) where we assume the program resides. (Later we will make the location of
the program more flexible, but for this limited example, assume the program always
starts at 0100.)

-4I When halt is 1, the machine proceeds to the IDLE state. When the machine is in the
IDLE state, it waits for an external signal, known on the PDP-8 as cont ("continue"),
that tells it to run another program. When cont is true in state IDLE, the machine

-- proceeds to the beginning of the actual fetch/execute algorithm, which starts at state
Fl. Since state IDLE clears the halt register, the machine will not return to state
IDLE until the fetch/execute algorithm (Fl, F2, F3A, F3B, ...) has executed an HLT
instruction.

State F1 is necessary because of the restriction on the use of memory described at the
end of section 8.3.1.4. Since pc was set up to contain the address of the next instruction
that should be executed (either by state INIT for the first time through the fetch/execute

-4
algorithm, or by some state inside the algorithm for later instructions), it would be
natural to say something like ir - m [pc]; however this violates the aforemen-
tioned restriction. At the time the machine enters state Fl, the ma contains no useful
information, and so it is possible to copy the program counter into ma. This will be
used by a later state (F3A) to actually fetch the current instruction into the instruction
register.

State F1 also needs to check the halt register to see if the previous instruction that just
finished executing was an HLT instruction or if the machine has just been powered up
(the machine just came from state INIT). If halt is true, the machine proceeds to state
IDLE as explained above.

If halt is not true, the machine proceeds to state F2. This state prepares the machine
for executing the next instruction after the current one by incrementing the program
counter. The placement of state F2 is somewhat arbitrary since a copy of the original
program counter has been preserved for the moment in the memory address register.
(For example, state F2 could be placed after state F3B, which would more closely
match the description given in appendix A.)

wvare General-PurposeC omputers 295



- -

The next state after state F2 is state F3A. State F3A fetches the instruction stored in ma at the nex
memory pointed to by the original program counter, which is now in the memory ad- that next clo
dress register. In the behavioral ASM, we use the same register transfer notation for become 0107
dealing with memory, i r<-m [ma] , as is used for dealing with other registers. In later loaded into n
stages of the design, the timing of memory may be somewhat more difficult than that F4B), mb bec
of the internal CPU registers, but at this early stage, we will ignore these details. State F4B is r
The next state after state F3A is state F3B. State F3B calculates the effective address the ASM to i
using the information in the instruction register. This calculation is denoted by a func- not described
tion referred to as ea (ir) . For example, if the ir is 11078, ea (ir) is 01078. If the
ir is 31118, ea (ir) is 01118. In the The 

later bottom 
stages o

of the top-down design process, the
ea function will be realized using combinational currently in tf

logic. Appendix A assumes there is
an additional register for the effective address, but this is not necessary here since state This series of
F3B uses the existing ma register to hold the effective address. (To implement the rithm. For MI
complete instruction set of the PDP-8 described in appendix B, more complicated com- ing decisions I
binational logic is required for ea. This is because the ea function for some of the this instructio
addressing modes not implemented in this chapter needs an additional argument.) tions. The mc
State F3B has a decision to determine Most 

what machine
state occurs next. If the instruction is a

Memory Reference Instruction ment 
(MRI), decoding

the next state after F3B will be F4A. If the
instruction is not an MRI, the next state else 

after if ..
F3A will be one that implements the

operation requested by the instruction ("E"xecute machine langu
it). Even though in this section the

only MRIs in our PDP-8 subset start with 1 and 3, we will describe how to test for any The remaining
MRI. In the complete PDP-8 instruction set (given in appendix B), an instruction is tion of each sp
MRI if the high order octal digit (three bits) of the instruction is between 0 through 5
inclusive. There are several ways If ir 

one [11 
could : 9]

write this test. It could be written as i r <
6 0 0 0, however, this does not emphasize complement 

that only A
the high-order three bits of the in-

struction register determine the machine 
outcome. adds

The test could be written as i r / 10008 < 6
or i r>> 9 < 6 to emphasize that complete 

the outcome imph
is based on the high-order three bits, but

neither one of these tests is the most succinct we will ignore
way to express this. We need a notation

that clearly says "just look at these bits." Although EOTAD, 
the the 

material m
in this section does not

depend on any knowledge of Verilog, fetch another 
Verilog ii

does indeed have such a bit selection
notation: i r [1 1: 9] says form a three-bit value using bits 11 through 9 of i r, which If ir[11:9]i
is roughly equivalent to (ir >> 9) & 7, which in this case is equivalent to ir >> and Clear Acci
9 since ir is 12-bits. For example, if ir is 11078, ir [11 :9] is 1. If ir is 31118, though TAD ar
ir [11: 9] is 3. We will use this aspect of Verilog notation in our ASM because it complex becau!
clearly documents what the hardware will do, which of course is the goal of a behav- the accumulato
ioral ASM. the DCA instru
If the instruction in the i r is MRI, The 

the machine restriction
proceeds to state F4A. State F4B loads

mb with the data that anything 
the machine that is

may need to use to execute the memory reference
instruction. For example, in the program EODCA 

of schedu
appendix A, when the memory reference

instruction 1107 is fetched by the 
state accumulator

F3A, the machine schedules 0107 to be loaded into next state, whic

296 Verilog Digital Computer Design: Algorithms into Hardware



-

ruction stored in ma at the next rising edge of the clock. Since ir [ 11: 9 ] is 1 (which is less than 6), at
the memory ad- that next clock edge the machine proceeds to state F4A. In state F4A, ma has just
sfer notation for become 0107, and so the contents of memory at that effective address, m [ma] , can be
registers. In later loaded into mb. In this example, one clock cycle later (when the machine is in state
lifficult than that F4B), mb becomes 0152.
iese details. State F4B is not necessary. It is included here as a placeholder for operations needed in
effective address the ASM to implement the complete instruction set of the PDP-8, including features
noted by a func- not described yet.

is 01078. If the The bottom of the ASM has a series of decisions that determines which instruction is
sign process, the currently in the instruction register.
assumes there is
y here since state This series of decisions is known as the decoding portion of the fetch/execute algo-
D implement the rithm. For MRI, the decoding decisions happen in state F4B. For non-MRI, the decod-
omplicated com- ing decisions happen in state F3B. Since we are implementing only four instructions in
for some of the this instruction subset, there are only four decisions required to decode these instruc-

d argument.) tions. The more complex the instruction set, the more difficult it is to do decoding.
Most machines, including the complete PDP-8 have a long string of decisions to imple-

^in struction is a ment decoding. Notice, from a high-level view, decoding occurs as a series of i f ...
I be F4A. If the else if ... else if ... style decisions, since each instruction has a unique
implements the machine language code.

rit his section the
w to test for any The remaining states of the machine perform certain actions required during the execu-
an instruction is tion of each specific instruction.
veen 0 through 5 If ir [ 11: 9 ] is 1 in state F4B, the instruction is what the programmer calls a "Twos
written as i r < complement ADd," and so the machine proceeds to state EOTAD. In this state, the
-ee bits of the in- machine adds the data from memory at the effective address to the accumulator. In a
Lr/1000 < 6 complete implementation of the PDP-8, other operations are involved with a TAD, but
der three bits, but we will ignore those details for the moment. After performing the addition in state
>n eed a notation EOTAD, the machine has completely executed the TAD instruction and is ready to
section does not fetch another instruction. Therefore, the next state after state EOTAD is state Fl.
h a bit selection
,h 9 of i r, which If ir [ 11: 9 ] is 3 in state F4B, the instruction is what the programmer calls a "Deposit
valent to i r > > and Clear Accumulator" (DCA) and so the machine proceeds to state EODCA. Al-

If ir is 31118, though TAD and DCA are both MRIs, the operations involved for the DCA are more
ASM because it complex because the DCA instruction stores the accumulator in memory and then clears
goal of a behav- the accumulator. It takes three clock cycles to accomplish all the operations required by

the DCA instruction. State EODCA occurs during the first of these three clock cycles.
The restrictions on the use of memory described at the end of section 8.3.1.4 require

State F4B loads anything that is to be stored in memory be placed in the memory buffer register. State
memory reference EODCA schedules that the memory buffer register be assigned a copy of the value in
memory reference the accumulator at the next rising edge of the clock. This is done in preparation for the
to be loaded into next state, which is state ElADCA.

ware General-PurposeC omputers 297



State El ADCA stores mb (which is now the same as the value of the accumulator) into is present in m
memory at the effective address. After state EIADCA, the next state is state ElBDCA. nation of this 
State ElBDCA schedules that zero be assigned to the accumulator at the next rising when the extei
edge of the clock. After scheduling the accumulator to be cleared in state EIBDCA, the
machine has completely executed the DCA instruction and is ready to fetch another
instruction. Therefore, the next state after state EODCA is state Fl. INIT

F1
If ir is 7200 in state F3B, the instruction is what the programmer calls a "CLear IDLE
Accumulator"(CLA) and so the machine proceeds to state EOCLA. Note that since
7200 is not MRI, the decoding occurs earlier (in state F3B) than for the MRI examples The question r
above. Also note that for non-MRI-like 7200, all twelve bits of the instruction register on.7 State INI
must be tested, since there is no effective address. In state EOCLA, the machine sched- IDLE. State I!
ules that zero be assigned to the accumulator at the next rising edge of the clock. After machine stays
this, the machine is ready to fetch another instruction, and so the next state after state the following I
EOCLA is state Fl.

If i r is 7402 in state F3B, the instruction is what the programmer calls a "HaLT," and
so the machine proceeds to state EOHLT. Again all twelve bits of the instruction regis- IDLE

ter must be tested in state F3B to decode this instruction. In state EOHLT, the machine F1

schedules that one be assigned to the halt register at the F2
next rising edge of the clock.

F3A
The next state after state EOHLT is state Fl, not because the machine is going to fetch F3B
another instruction, but instead because state F1 is where the test of the halt register EOCLA
occurs. (As mentioned above, when halt is one in state Fl, the machine proceeds to F1
state IDLE.) The final sequence of states through which the machine goes near the end
of a program will be F1, F2, F3A, F3B, EOHLT, F1, IDLE, IDLE, IDLE ....

In state F1, the
F2, the progra

8.3.1.6 Example machine language program seen in state F
Assume that the following machine language program: later. In state 

address 0100. ]
register, and s

0100/7200 EOCLA schedu
0101/ 1106
0102/1107 ing and execut
0103/1110 fetch the secor
0104/3 111 following shoN
0105/ 7402
0106/ 0112
0107/ 0152
0 110/0224
0111/ 0510

7Ino ther chapters,

298 Verilog Digital Computer Design: Algorithms into Hardware



umulator) into is present in memory starting at address 0100 when power is turned on. (For an expla-
ate EIBDCA. nation of this program, see appendix A.) The following shows how the ASM proceeds

the next rising when the external input cont is not asserted:
ElBDCA, the
fetch another

INIT ma=???? mb=???? pc=???? ir=???? halt=? a=????
Fl ma=???? mb=???? pc=O100 ir=???? halt=l ac=????

alls a "CLear IDLE ma=0100 mb=???? pc=0100 ir=???? halt=O a=????

lote that since
qRI examples The question marks indicate an unknown value in registers when power is first turned
uction register on.7 State INIT initializes the halt flag so that the machine goes straight from Fl to
machine sched- IDLE. State INIT is also initialized to the starting address of our sample program. The
ie clock. After machine stays in IDLE until the external input cont is asserted. When it is asserted,
tate after state the following happens:

a "HaLT," and
itruction regis- IDLE ma=O100 mb=???? pc=O100 ir=???? halt=O ac=????

T, the machine Fl ma=O100 mb=???? pc=O100 ir=???? halt=O ac=????
F2 ma=O100 

,e of the clock. mb=???? pc=O100 ir=???? halt=O ac=????
F3A ma=O100 mb=???? pc=O101 ir=???? halt=O ac=????

going to fetch F3B ma=O100 mb=???? pc=O101 ir=7200 halt=O ac=????
halt register EOCLA ma=OOOO mb=???? pc=O101 ir=7200 halt=O ac=????
ne proceeds to F1 ma=OOOO mb=???? pc=O101 ir=7200 halt=O ac=OOOO
es near the end
E....

In state Fl, the program counter (0100) is saved in the memory address register. In state
F2, the program counter is scheduled to be incremented to become 0101 (as can be
seen in state F3A) in preparation for fetching the next instruction four clock cycles
later. In state F3A, the instruction register is scheduled to be loaded from memory
address 0100. In state F3B, this instruction (7200) becomes available in the instruction
register, and since ir [ 11: 9 ] >= 6, the instruction decoding takes place. State
EOCLA schedules zero to be loaded into the accumulator. Having completed the fetch-
ing and execution of the CLA instruction, the machine performs similar operations to
fetch the second instruction. This time, the program counter is 0101 in state Fl. The
following shows how the fetching and execution of the second instruction proceeds:

7 In other chapters, a similar idea is denoted with the "x" value in Verilog.

General-PurposeC omputers 299



F2 ma=0101 mb=???? pc=0101 ir=7200 halt=O ac=0000
F3A ma=0101 mb=???? pc=0102 ir=7200 halt=O F2

ac=0000
F3B ma=0101 mb=???? pc=0102 ir=1106 halt=O ac=0000 F3A

F4A ma=0106 mb=???? pc=0102 ir=1106 halt=O ac=0000 F3B

F4B ma=0106 mb=0112 pc=0 1 0 2 ir=1106 halt=O F4A
ac=0000

EOTAD ma=0106 mb=0112 pc=0102 ir=1106 halt=O ac=0000 F4B

F1 ma=0106 mb=0112 pc=0102 ir=1106 halt=O ac=0112 EODCA
ElADCA

In state F2 the saved program counter (0101) is visible in the memory address register E1BDCA

at the same time the program counter F1
is scheduled to be incremented to become 0102

(as can be seen in state F3A). In state F3A, the instruction register is scheduled to be
loaded from memory address 0101. In state F3B, this instruction (1106) becomes avail- In state F2 the
able in the instruction register, but unlike the above non-MRI, instruction decoding at the same tim
does not take place in state F3B. Instead, state F3B schedules the memory address (as can be seen
register to be loaded with the effective address (0106), derived from the instruction loaded from m(
register. Since ir [ 11: 9 ] < 6 in state F3B, the machine proceeds to state F4A, able in the inst
where the memory buffer register is scheduled to be loaded with the contents of memory loaded with th(
(0112) at that effective address, as can be seen in state F4B. In state F4B, instruction ir[11:9] <
decoding takes place. Since, ir [11: 9] == 1, the machine proceeds to state EOTAD, buffer register
where the 0112 in the memory buffer register is added to the zero in the accumulator. effective addre;
The remaining two TAD instructions execute in a similar fashion: place. Since, i

memory buffer
(0510).8 In stat

F2 ma=0102 mb=0112 pc=0102 ir=1106 halt=O ac=0112 the accumulato
F3A ma=0102 mb=0112 pc=0103 ir=1106 halt=O ac=0112
F3B ma=0102 mb=0112 pc=0103 ir=1107 halt=O ac=0112
F4A ma=0107 mb=0112 pc=0103 ir=1107 halt=O ac=0112 F3A

F4B ma=0107 mb=0152 pc=0103 ir=1107 halt=O ac=0112 F3B

EOTAD ma=0107 mb=0152 pc=0103 ir=1107 halt=O ac=0112 EOHLT

F1 ma=0107 mb=0152 pc=0103 ir=1107 halt=O ac=0264 F1

F2 ma=0103 mb=0152 pc=0103 ir=1107 halt=O ac=0264 IDLE

F3A ma=0103 mb=0152 pc=0104 ir=1107 halt=O ac=0264 IDLE

F3B ma=0103 mb=0152 pc=0104 ir=1110 halt=O ac=0264
F4A ma=0110 mb=0152 pc=0104 ir=1110 halt=O ac=0264 The value in th
F4B ma=OllO mb=0224 pc=0104 ir=1110 halt=O ac=0264 becomes visible
EOTAD ma=0110 mb=0224 pc=0104 ir=1110 halt=O ac=0264
F1 ma=0l10 less 

mb=0224 computatic
pc=0104 ir=1ll0 halt=O ac=0510

tation when it i
load these bits 

The accumulator now contains the sum of the three numbers (0510). The following
shows the execution of the DCA instruction:

8 Having the ASM I
use the value loade,
less but slower thar

9 As the last footnot
or not. Here there,,

300 Verilog Digital Computer Design: Algorithms into Hardware



)D ac=01012
) a 104 
)c =0101020

F2 ma=0 mb=0224 pc=0104 ir=1110 halt=0 ac=0510

) F3A ma=0104 
a c =0101020 mb=0224 pc=0105 ir=1110 halt=0 ac=0510

 
2a) c=01

 ma=0104
0102

F3B
0 mb=0224 pc=0105 ir=3111 halt=0 ac=0510

F4A 0224 pc=0105 
Dac =0000 ma=0111 mb= ir=3111 halt=0 ac=0510

F4B ma=0111 pc=0105 ir=3111 
Dac mb=0000 

 =0000 halt=0 ac=0510

ac=0112 EODCA ma=0111 mb=0000 pc=0105 ir=3111 halt=0 ac=0510
ElADCA ma=0111 mb=0510 pc=0105 ir=3111 halt=0 ac=0510
E1BDCA ma=0111 

2)a ddarecs=s 0r2e6gi4ster mb=0510 pc=0105 ir=3111 halt=0 ac=0510
F1 ma=0111 mb=0510 pc=0105 ir=3111 halt=0 ac=OOCO

o become 0102
;cheduled to be
b)e caocm=e0s2 a6v4ail- In state F2 the saved program counter (0104) is visible in the memory address register
ction decoding at the same time the program counter is scheduled to be incremented to become 0105
memory address (as can be seen in state F3A). In state F3A, the instruction register is scheduled to be
the instruction loaded from memory address 0105. In state F3B, this instruction (3111) becomes avail-
s to state F4A, able in the instruction register. State F3B schedules the memory address register to be
) ac=0112

en m oaded 
)ts a cof l

= 01e1m2ory with the effective address (0111), derived from the instruction register. Since
4B2 ,a cin=s0tr2u6c4tion i r [ 11: 9 ] < 6 in state F3B, the machine proceeds to state F4A, where the memory
:os tate EOTAD, buffer register is scheduled to be loaded with the contents of memory (0000) at that
ie accumulator effective address, as can be seen in state F4B. In state F4B, instruction decoding takes

place. Since, ir [ 11: 9 ] == 3, the machine proceeds to state EODCA, where the
memory buffer register is scheduled to be assigned the value from the accumulator
(0510).A In state EIADCA, this value is stored in memory. State EIBDCA schedules
the accumulator to be cleared. Finally, the HLT instruction executes:

ac=0510
F2 ma=0105 mb=0510 pc=0105 ir=3111 halt=0 ac=0000

The folluon F3A ma=0105 mb=0510 pc=0106 ir=3111 halt=0 ac=0000
Theo statewing F3B ma=0105 mb=0510 pc=0106 ir=7402 halt=0 ac=0000

EOHLT ma=0002 mb=0510 pc=0106 ir=7402 halt=0 ac=0000
F1 ma=0002 mb=0510 pc=0106 ir=7402 halt=l ac=0000
IDLE ma=0106 mb=0510 pc=0106 ir=7402 halt=l ac=0000
IDLE ma=0106 mb=0510 pc=0106 ir=7402 halt=0 ac=0000

The value in the memory address register calculated by state F3B (this value, 0002,
ac=0264 becomes visible in state EOHLT) is irrelevant. In hardware, unnecessarily doing a harm-
ac=0264

less computation sometimes is more efficient than having a decision avoid the compu-
tation when it is unwanted.9 It does not slow the machine, and it is simpler always to
load these bits from the instruction register into the memory address register, even, as

The following

8H aving the ASM proceed through F4A and F4B was unnecessary in this case since state EODCA does not
use the value loaded into memory buffer register by state F4A in the same way EOTAD does. This is harm-
less but slower than required and was done to simplify the explanation of state F3B.

9 As the last footnote indicates, whether it is efficient depends on whether extra states, like F4A, are involved
or not. Here there are no extra states involved.

General-PurposeC omputers 301



i7
Ii i

in this case, when they are not needed. State EOHLT schedules the halt flag to be- These instruc
come zero, which causes the machine to go to F1 and then back to IDLE, where the (AND, TAD,
machine will stay (unless cont is pressed again). we will only 

The next eig]
8.3.2 Including more in the instruction set describe insti
The machine described by the ASM in section 8.3.1.5 is rather useless. It was presented referencing ir
only to introduce the essential aspects of the fetch/execute algorithm. Rather than imple- requires some
ment a useless subset of instructions in hardware, let's include more of the PDP-8's instruction se
instructions in our instruction set. For the extended example in this section, we will the eight liste
implement a machine that executes the following PDP-8 instructions: The skip insti

condition is ry
skip acts like

octal
mnemonic machine what the mnemonic stands for The HLT inst

language ceed to states
ample in secti

AND Oxxx AND memory with accumulator
TAD lxxx add memory to accumulator (Two's HLT instructi4

Complement Add)
DCA 3xxx Deposit accumulator in memory and Clear time the progi

Accumulator using an exte
JMP 5xxx goto a new instruction (JuMP) known as the
CLA 7200 CLear Accumulator bus, very mui
CLL 7100 CLear Link physical reali:
CMA 7040 CoMplement Accumulator each bit).
CML 7020 CoMplement Link
IAC 7001 Increment ACcumulator The OSR instj
RAL 7004 Rotate Accumulator and link Left is ideal for ou
RAR 7010 Rotate Accumulator and link Right the external s
CLACLL 7300 CLear Accumulator and CLear Link

of software in
SZA 7440 Skip next instruction if Zero is in Accumulator
SNA 7450 Skip next instruction if Even 

Non-zero though 
value is in

Accumulator have still cho
SMA 7500 Skip next instruction if Minus (negative) value about whether

is in Accumulator design will co
SPA 7510 Skip next instruction if Positive (non-negative)

value is in Accumulator
SZL 7430 Skip next instruction if Zero is in Link
SNL 7420 Skip next instruction if one (Non-zero) is in 8.3.2.1 A'

Link Here is the A
above:

HLT 7402 HaLT
OSR 7404 Or Switch "Register" with accumulator

302 Verilog Digital Computer Design: Algorithms into Hardware



P_

,alt flag to be- These instructions are explained more fully in appendix B. The first four instructions
DLE, where the (AND, TAD, DCA and JMP) are memory reference instructions. As in section 8.3.1,

we will only consider direct page zero addressing.

The next eight mnemonics (CLA, CLL, CMA, CML, IAC, RAL, RAR, CLACLL)
describe instructions that manipulate the accumulator and the link registers without

It was presented referencing memory. (The link register was not considered in section 8.3.1.5 because it

tther than imple- requires some details that are discussed in section 8.3.2.2.) Although the full PDP-8

of the PDP-8's instruction set allows for 256 combinations of these operations, we will only consider

section, we will the eight listed here.

The skip instructions allow conditional execution of the following instruction. If the
condition is met, the following instruction does not execute. If the condition is met, the
skip acts like a NOP.

The HLT instruction causes the machine to stop executing a program and instead pro-
ceed to states that allow the machine to interface with its programmer. Unlike the ex-
ample in section 8.3.1.5, the ASM in this section will include interface states after the
HLT instruction that allow an arbitrary program to be loaded at an arbitrary address any

nplement Add)
lear time the programmer wishes. The programmer communicates with the halted machine

using an external 12-bit input, sr. In the original PDP-8 documentation, the sr is
known as the switch "register"; however sr is not a register. sr is an external input
bus, very much like the buses x and y in the division machine of chapter 2. In the
physical realization of the PDP-8, the sr is simply a set of twelve switches (one for
each bit).

The OSR instruction is an unusual kind of input instruction unique to the PDP-8, which
is ideal for our purposes in this section. The OSR instruction ORs input coming from
the external sr bus with the contents of the accumulator. This allows a discussion here
of software input without the need for machine language instructions 6xxx.

Accumulator Even though the PDP-8 is one of the simplest instruction sets ever designed, and we
alue is in

have still chosen to implement only about half of it, you may have a feeling of panic
native) value about whether you will ever be able to design such a machine. Have faith-top-down

design will come to the rescue.
non-negative)

Link 8.3.2.1 ASM implementing additionali nstructions
ero) is in

Here is the ASM for the improved machine that implements the instructions listed
above:

or

va re General-PurposeC omputers 303



Section 8.3.2.
Section 8.3.2.
interface whei

8.3.2.2 St,
Many of the e
improved ASP
useless ASM i

Also, the fetcl
tion 8.3.2.1 ai
section 8.3.1.5
instruction (31
illustrates, it is
buffer register
Therefore, in t
addressing, on
F4A. Since JN
section (JMS a
< 3. If the full
condition wou]

8.3.2.2.1 L
One place who
improved AS
instruction trea
this is to say ti
performs such;
out of the ac a]
a 13-bit bus. W
concatenation.,
of Verilog, Veri
13-bit value. T
most significan
As a different
fir [11], ir

State EOTAD o
and is affected 1:
side of a register

Figure 8-8. ASM implementing more instructions of the PDP-8. that the 12-bit n

304 Verilog Digital Computer Design: Algorithms into Hardware



Section 8.3.2.2 describes the states required to execute these additional instructions.
Section 8.3.2.3 describes the additional states that allow the programmer a manual
interface when the machine is halted.

8.3.2.2 States for additional instructions
Many of the execute states (EOCLA, EOHLT, EODCA, EIADCA and EIBDCA) of the
improved ASM in section 8.3.2.1 are identical to the states with the same names of the
useless ASM in section 8.3.1.5. Therefore, these states will not be discussed here.

Also, the fetch states (Fl, F2, F3A, F3B, F4A and F4B) of the improved ASM in sec-
tion 8.3.2.1 are identical to the states with the same names in the useless ASM of
section 8.3.1.5, except the decision whether to go to state F4A is different. As the DCA
instruction (3111) used in the example machine language program of section 8.3.1.6
illustrates, it is not necessary for some memory reference instructions to have the memory
buffer register initialized. Although it is harmless to do so, it slows the machine down.
Therefore, in this section, we will only perform state F4A if it is required. For direct
addressing, only AND(Oxxx), TAD (lxxx), ISZ (2xxx) and JMS (4xxx) require state
F4A. Since JMS and ISZ are not part of the instruction subset implemented in this
section (JMS and ISZ are left as exercises), the condition can be restated as i r [ 11: 9 ]
< 3. If the full PDP-8 instruction set with all addressing modes were implemented, this
condition would be more complicated.

8.3.2.2.1 Instruction described with concatenation
One place where there is a noticeable difference between the useless ASM and the
improved ASM is in state EOTAD. This difference is due to the fact that the TAD
instruction treats the link and the ac together as a 13-bit entity. One way to describe
this is to say that value inside the CPU is 4 0 9 6 l ink + ac, but the CPU never
performs such a wasteful computation. Instead, inside the CPU the 12-bit bus coming
out of the ac and the one-bit bus coming out of the link are joined together to form
a 13-bit bus. We need a notation to describe this joining together, technically known as
concatenation. Although the material in this section does not depend on any knowledge
of Verilog, Verilog does indeed have such a concatenation notation: { link, ac } is a
13-bit value. The most significant bit (bit 12) of { link, ac } is link, the next to
most significant bit (bit 11) is ac [ 11 , ... and the least significant bit (bit 0) is ac [ 0 ] .
As a different illustration of concatenation, note that i r [ 11: 9 ] is the same as
{ir[11],ir[10],ir[9]1}.

State EOTAD of the improved ASM properly shows that the TAD instruction affects
and is affected by the link. It is perfectly legal for a concatenation to be on the left-hand
side of a register transfer. The operation { l ink, ac } - { l ink, ac + mb means
that the 12-bit mb is extended to have 13 bits (by implicitly concatenating a 0 on the

4vare General-PurposeC omputers 305



left). This is added to the 13-bit { link, ac}. The respective portions of the 13-bit is a more suc
sum are stored back into link and ac. The following table shows four examples of :

before and after state EOTAD:

before after
link ac mb link ac mb

0 0040 4001 0 4041 4001
0 4040 4002 1 0042 4002
1 0040 4003 1 4043 4003
1 4040 4004 0 0044 4004

For instance, the last line shows 1,40408)+40048 == 11000001000002 +
01000000001002 == 100000001001002 == 200448, which is too big to fit in 13 bits, Observe that,
and so the result is 0 in the link and 00448 in the accumulator. value of the ]

following tab
There are four other instructions (IAC, CLACLL, RAL and RAR) that are most easily after state EO
described using concatenation. If the instruction register contains 7001 in state F3B,
the instruction is what the programmer calls "Increment ACcumulator," and so the
machine proceeds to state EOIAC, which is similar to EOTAD, except one rather than
mb is added to { 1 ink, ac). If the instruction register is 7300 in state F3B, the instruc-
tion is what the programmer calls a "CLear Accumulator, CLear Link," and so the
machine proceeds to state EOCLACLL, where a 13-bit zero is assigned to {l  ink, ac}.
If the instruction register is 7010 in state F3B, the instruction is what the programmer
calls a "Rotate Accumulator and link Right," and so the machine proceeds to state
EORAR, where the 13-bit {link, ac) is rotated right. Similarly, if the instruction
register is 7004 in state F3B, the instruction is what the programmer calls a "Rotate
Accumulator and link Left," and so the machine proceeds to state EORAL, where the
13-bit {l ink, ac} is rotated left. Although 

Concatenation the
is the simplest way to describe rota-

tion. Recall that: instruction m
The first thre

{link,ac}== ously cleared
{link,ac[ll] ,ac[10] ,ac[9] ,ac[8] ,ac[7] ,ac[6] ,ac[5] ,ac[4] ,ac[3] ,ac[2] ,ac[l], The remainir
3c[O] I losing any in
and

{ac,link} == I RAR is the it
{ac[ll] ,ac[10] ,ac[9] ,ac[8] ,ac[7] ,ac[6] ,ac[5] ,ac[4] ,ac[3] ,ac[2] ,ac[1l] ,ac[0] ,link LI
The single 13-bit wide register transfer:

{link,ac} v- {ac,link}

306 Verilog Digital Computer Design: Algorithms into Hardware



p.

so f the 13-bit is a more succinct way to describe 13 separate register transfers, each one bit wide:
ir examples of

link <- ac[11]

ac[11] *- ac[10]

ac[10] <-- ac[9]

ac[9] *- ac[8]

ac[2] *- ac[l]

ac[l] *- ac[0]

ac[0] *- link

)01000002 +
)f it in 13 bits, Observe that, except for the link, the bits are shifted over one place to the left. The old

value of the link "rotates" around to the least significant bit of the accumulator. The
following table illustrates examples what is in the link and the accumulator before and

ire most easily after state EORAL:
in state F3B,

r," and so the
me rather than before after
B, the instruc- link ac link ac
k," and so the 0 1001 0 2002
{link,ac}. 0 2002 0 4004

0 4004 1 0010
e programmer 1 1001 0 2003
Ceeds to state 1 2002 0 4005
he instruction 1 4004 1 0011
,alls a "Rotate
AL, where the

Although the software uses of the previous instructions 
describe rota- were fairly obvious, the RAL

instruction may seem a bit strange. In fact, RAL has two uses: arithmetic and logical.
The first three lines above illustrate the arithmetic use: if the programmer has previ-
ously cleared the link, RAL is like multiplication by two (with overflow in the link).

IaII The remaining examples above illustrate the logical use: to rearrange bits without
losing any information.

RAR is the inverse of RAL, and the concatenation notation makes this clear:

{ac,link} <- {link,ac}

I'll
General-PurposeC omputers 307



-
-

In the following, the second, third and last three lines use data from the previous (RAL) Assume the r
table to illustrate that RAR is the inverse of RAL (the rotates do not lose information, discussion. MA
they simply rearrange it): instruction, 7

remains at 00
is desired on

before after algorithm prc
link ac link ac This is done ti
0 1001 1 0400 next instructi(
0 2002 0 1001 accumulator 
0 4004 0 2002
1 1001 1 4400 identity for 0
1 2002 0 5001 the accumulal
1 4004 0 6002 OSR instructi(
0 2003 1 1001 user interface
0 4005 1 2002
1 0011 1 4004

The first three examples above illustrate the arithmetic use of RAR: if the programmer 8.3.2.2.3 
clears the link, RAR is like unsigned division by two (with the remainder in the link). There are six 

these (TAD an
exercises. The

If ir[11:9]
8.3.2.2.2 Additional non-memory reference instructions "AND," and s(
If the instruction register is 7100 in state F3B, the instruction is what the programmer except the AN]
calls a "CLear Link," and so the machine proceeds to state EOCLL, where zero is ter alone.) Rec
assigned only to the link (the accumulator is left alone). If the instruction register is
7040 in state F3B, the instruction is what the programmer calls a "CoMplement Accu-
mulator," and so the machine proceeds to state EOCMA, where -ac is assigned only to
the accumulator (the link is left alone). If the instruction register is 7020 in state F3B, is equivalent tc
the instruction is what the programmer calls a "CoMplement Link," and so the ma-
chine proceeds to state EOCML, where -link is assigned only to the link (the accu-
mulator is left alone).

If the instruction register is 7404 in state F3B, the instruction is what the programmer
calls "Or Switch Register," and so the machine proceeds to state EOOSR, where the
external sr input is ORed with the current value of the accumulator. Here is a typical
use of this instruction:

If ir[11:9] i
and so the mach
kind of jump (sc

308 Verilog Digital Computer Design: Algorithms into Hardware



*evious (RAL) Assume the machine executed instructions, prior to 0002, which are irrelevant to this
Di nformation, discussion. When the program wants input from the user, it halts (by executing the HLT

instruction, 7402). The machine will proceed to state IDLE, but the program counter
remains at 0003. While the machine is halted, the user is free to enter in whatever value
is desired on the switches. When the user pushes the cont button, the fetch/execute
algorithm proceeds with the instruction at 0003, which is a CLA instruction (7200).
This is done to get rid of any extraneous value in the accumulator in preparation for the
next instruction. The next instruction in fact is the OSR (7404), which ORs zero in the
accumulator with the desired value from the external sr input. Because zero is the
identity for OR (i.e., 0 sr == sr), the input value from the switches is loaded into
the accumulator. Finally, a DCA instruction stores the input value into memory. The
OSR instruction, in conjunction with IDLE state and the cont input, provides a simple
user interface that will work nicely for the software in this chapter.\

8.3.2.2.3 
iep rogrammer Additional memory reference instructions
er in the link). There are six memory reference instructions in the instruction set of the PDP-8. Two of

these (TAD and DCA) were described earlier. Two of these (JMS and ISZ) are left as
exercises. The other two (AND and JMP) are described in this section.
If i r [ 11: 9 ] is 0 in state F4B, the instruction is what the programmer refers to as
"AND," and so the machine proceeds to state EOAND. This state is similar to EOTAD,

e programmer except the AND instruction only changes the accumulator. (AND leaves the link regis-
where zero is ter alone.) Recall that & is the bitwise AND operator, and so the register transfer:
don register is
plement Accu- I ac - ac & mb

;signed only to
0 in state F3B, is equivalent to:
md so the ma-
link (the accu- ac[11] *- ac[11] & mb[11]

ac[10] <- ac[10] & mb[10]

[e programmer ac[9] <- ac[9] & mb[9]

MR, where the
ere is a typical ac[2] <- ac[2] & mb[2]

ac[1] *- ac[1] & mb[l]

ac[0] <- ac[0] & mnb[0]

If ir [11: 9] is 5 in state F4B, the instruction is what the programmer calls a "JuMP,"
and so the machine proceeds to state EOJMP. All general-purpose computers have some
kind of jump (sometimes known as branch) instruction. The purpose of ajump instruc-

General-PurposeC omputers 309



tion is to modify the program counter. The jump instruction allows high-level language tively, are the
features (such as loops and decisions) to be translated into machine language. is 1 for SZA
Although the jump instruction of the PDP-8 is categorized as a memory reference in- decides whet]
struction, it does not actually reference memory. It simply takes the effective address
(from the memory address register) and uses this as the new value of the program
counter.

8.3.2.2.4 Skip instructions where Ai s the

High-level sion 
language when ir

programs are composed of statements like if and while. The
JMP instruction that indicates

by itself is not enough to translate such programs. For this reason, the
PDP-8 instruction set includes several "skip" instructions. These instructions test to As an illustrat
see whether the value in the accumulator (or link) meets certain conditions. If it does, the other insti
the next instruction will be skipped. If the condition is not met, the next instruction will rl (stored at
execute normally. The following table illustrates several skip instructions, and how unsigned num
they are encoded in machine language. an i f or a wh

equivalent wa
complement a

mnemonic octal ir ir[6] ir[5] ir[4] i3U _

SMA 7500 1 0 0 0 Skip if Minus
(negative) Accumulator

SZA 7440 0 1 0 0 Skip if Zero
Accumulator

SNL 7420 0 0 1 0 Skip if Non-zero Link

SPA 7510 1 0 0 1 Skip if Positive
Accumulator

SNA 7450 0 1 0 1 Skip if Non-zero The last of the
Accumulator signed 13-bit r

SZL 7430 0 0 1 1 Skip if Zero Link below:

If ir [ 11: 8 ] is 15 in state F3B, the instruction is one of the 0014/7200
above skip instructions. If

the condition is met, 0015/7100
the machine proceeds to state EOASKIP, where the program counter 0016/1101

is scheduled to be incremented an extra time. If the condition is not met, the machine 0017/7040
proceeds to state EOBSKIP, where the machine leaves the program counter the way it 0020/7020
was. 0021/7001

The condition is determined 0022/1032
by ir [6 3]. ir [3] is a bit that reverses the meaning of 0023/7430

the instruction; hence ir [ 3 ] is 0 for SMA, SZA and SNL, but ir [ 3 ] is 1 for SPA, 0024/5xxx
SNA and SZL. (If you think about it, you will realize SMA, SZA and SNL, respec-

310 Verilog Digital Computer Design: Algorithms into Hardware



- P_

-level language tively, are the opposites of SPA, SNA and SZL.) i r [ 6 ] is 1 for SMA and SPA. i r [ 5 ]
iguage. is 1 for SZA and SNA. i r [ 4 ] is 1 for SNL and SZL. Therefore, the condition that
y reference in- decides whether to proceed to state EOASKIP is:
fective address
f the program

ir[3] (ir[6]&ac[11]Iir[5]&(ac==O)Iir[4]&link)

where A is the exclusive OR, which reverses the meaning of the parenthesized expres-
sion when ir [ 3 ] is one. Note: ac [ 11 ] is the "sign" bit of the accumulator (the bit

idwhile. The that indicates 12-bit negative twos complement values).
this reason, the
ructions test to As an illustration of how a programmer uses the skip instructions in conjunction with
Lions. If it does, the other instructions, consider the unsigned greater than or equal decision. Suppose
instruction will ri (stored at 0032) and y (stored at 0101) are software variables that contain 12-bit
tions, and how unsigned numbers. Should the high-level language programmer wish to test (in either

an if or a while) to see whether rl is greater than or equal to y, there are several
equivalent ways to write this (given that the following is performed in 13-bit twos
complement arithmetic):

nus
Accumulator rl >= y

ro rl >= {,y1
r

-{O,y} 
n-zero + rl 

Link >= 0
{-O,-yl+l + rl >= 0

sitive
r
n-zero The last of these can be performed with the instructions described earlier. The final
r signed 13-bit result in { 1 ink, ac } can be tested with the SZL instruction, as shown
ro Link below:

0014/7200 CLA
p instructions. If 0015/7100 CLL /{link,ac} = {0,0}
program counter 0016/1101 TAD y /{link,ac} = {O,y}
iet, the machine 0017/7040 CMA /{link,ac} = {O,-y}
hunter the way it 0020/7020 CML /{link,ac} = {-O,-y}

0021/7001 IAC /{link,ac} = {-O,-y}+l
0022/1032 TAD rl /{link,ac} = {-O,-y}+l + rl

s the meaning of 0023/7430 SZL /test whether {O,-y}+l + rl >= 0
3 ] is 1 for SPA, 0024/5xxx JMP xxx /if {O,-y}+l + rl < 0, goto xxx
id SNL, respec- ... /if {O,-y}+l + rl >=0, execute here

vare General-PurposeC omputers 311



- P_

8.3.2.3 Extra states for interface The present st
TheASM shown in section 8.3.2.1 has three additional states (EOMA, EOPC and EODEP) address registe
that allow the programmer to interface with the machine using the sr input when the from the mach
machine is not performing the fetch/execute algorithm. These states only occur when of the machine
the programmer pushes buttons (but MA, butPC and but_DEP, respectively)
during the time that the machine is in state IDLE.

8.3.2.4.1 7
State EOPC allows the programmer to load the the program counter with a value previ- In fact, the ma(
ously placed on the switches. This allows a program to reside anywhere in memory, the CPU, the 
unlike the nearly useless ASM given in section 8.3.1. For this reason, state INIT no peripherals, thz
longer initializes the program counter, and instead the programmer is responsible for the system: the
pushing but-PC appropriately prior to pushing cont. another compol
The programmer uses butMA and butDEP together to load a program into memory in section 8.2, i
at an arbitrary address. First, the programmer enters the address on the switches to ogy to impleme
indicate where in memory the programmer desires to place the program or data. Then Therefore, we ;
the programmer pushes but MA, which causes state EOMA to occur, where the sr the CPU indept
input is assigned to the memory address register. Next, the programmer enters the first actor, as illustra
word to go into memory onto the switches, and pushes but_DEP, which causes state
EODEP to occur. State EODEP assigns the sr input to the memory buffer register, and
then the machine proceeds to state ElADEP. In state ElADEP the machine deposits
the memory buffer (containing the programmer's desired word) into memory at the
memory address. Finally, state ElBDEP increments the memory address (in case the
programmer has more words to deposit). The programmer may enter as many succes-
sive words as desired with this technique. Finally, the programmer uses butPC and
cont as described above.

8.3.2.4 Memory as a separatea ctor
At this point, we have described the behavior of the complete general-purpose com- Figure 8-10.
puter system. Now, we need to consider what the external inputs and outputs of this memory as a
system are:

Let's assume th,
12 link static, determine

butPC -> pdp8-machine choice of this kir
12 ac

butMA A this memory is s
- presentstate

but_DEP P- known, proper ft
- other outputs... Third, since this

cont > need to introduce

The one design c
Figure 8-9. Block diagramf or the PDP-8 system. chronous. The re

ability. The prob

312 Verilog Digital Computer Design: Algorithms into Hardware



The present state and the other outputs (such as the memory buffer register, memory
and EODEP) address register, program counter, instruction register and the halt register) are sent out
put when the from the machine primarily to allow the programmer to observe the internal operation
occur when of the machine.

respectively)

8.3.2.4.1 Top-level structure of the machine
value previ- In fact, the machine hidden inside the last diagram is composed of three components:
in memory, the CPU, the peripherals and the memory. Since in this chapter we are ignoring the

;tate INIT no peripherals, that leaves two separate components that must be interconnected to form
sponsible for the system: the CPU and the memory. Although one could consider the memory as just

another component of the CPU's architecture, this is normally not done. As described
into memory in section 8.2, there are many different technologies for memory, and often the technol-
e switches to ogy to implement memory is different than the technology used to implement the CPU.
or data. Then Therefore, we would like to physically separate 

here the 
the memory 

s r from the CPU 
the CPU and 

independently design
from the memory. This means that memory is an independent

nters the first actor, as illustrated in the following diagram:
h causes state
r register, and
hine deposits Cpu peripheral
memory at the I I
;s (in case the I controller architecture: addr
many succes- I I a
butPC and I- - - - - - J - - - - - - - <d ata out

data in d mMemmrory

writer

purpose com- Figure 8-10. System composed of processor (controller and architecture)w ith
)utputs of this memory as a separate actor

Let's assume that we will implement this machine using an asynchronous, volatile,
static, deterministic access time memory with separate data input and data output. The
choice of this kind of memory device simplifies the design in several ways. First, since
this memory is static, there is no need to refresh it. Second, since the access time is

te known, proper functioning is easily guaranteed by choosing a sufficiently slow clock.
its... Third, since this memory has separate buses for data input and data output, there is no

need to introduce the complexity of tri-state buffers.
The one design complexity that must be dealt with is the fact that this memory is asyn-
chronous. The reason for choosing an asynchronous memory device is cost and avail-
ability. The problem with doing so is that extra care must be taken in providing the

tre reGeneral-PurposeC omputers31 313



INIIThE alt
inputs to the memory device. In particular, the register transfer m [ma] - mb must
be implemented by asserting a hazard-free external (to the CPU) command output, F1 Zja
write, as described in section 8.2.2.1. The memory address and memory buffer out-
puts of the CPU provide the addr and din inputs to the memory device. The dout of
the memory device provides the membus input to the CPU. F2j

F3Af;;
8.3.2.4.2 Pure behavioralA SM with memory as a separate actor
The ASM of section 8.3.2.1 can be rewritten to reflect that memory is a separate actor.
Every place (states F3A and F4A) where m [ma] is used on the right-hand side of a
register transfer in section 8.3.2.1, the revised ASM will use membus instead. All other
places (states ElADEP and E1ADCA) that mention m [ma] are of the form m [ma]

- mb. These can be replaced with an assertion of the write signal, as illustrated in
figure 8-11.

8.3.2.5 Our old friend: division
This book uses the childish division algorithm (first described in section 2.2) in most
chapters to illustrate various ways that hardware can be designed. This algorithm is
ideal as a learning example because it is simple. Although the operations used to imple-
ment this algorithm are typical of the most sophisticated algorithms, it is so elementary
that any child can perform it. Unlike faster division algorithms, why it works is obvi-
ous.

There is another reason why division is the centerpiece of this book. Division has played
an interesting role in the history of general-purpose computers. As mentioned previ-
ously, the very first program ever run on a general-purpose computer was the childish
division algorithm. Much faster algorithms than the childish algorithm exist for divi-
sion, but they are very complex and hard to understand. Many general-purpose com-
puters throughout history (from the BINAC in 1949 up to the Pentium half a century
later) have provided "divide" instructions that implement much more sophisticated
division algorithms in hardware than our old friend, the childish algorithm. Despite
this, many computers, including many PDP-8s,11 have shunned division in hardware in
favor of division in software. The irony of this is that a flaw in the hardware divide
instruction of the Pentium general-purpose computer caused Intel great embarrassment
in the mid 1990s.

'(Some models of the PDP-8 had an optional hardware feature, known as EAE, that assisted in performing
division. Figure 8-11.,v

314 Verilog Digital Computer Design: Algorithms into Hardware



<- mb must
mmand output,
iory buffer out-
e. The dout of

Ite actor
l separate actor.
t-hand side of a
stead. All other
le form m [ma ]
as illustrated in

ion 2.2) in most
his algorithm is
is used to imple-
is so elementary
it works is obvi-

tision has played
Mentioned previ-
was the childish
m exist for divi-
al-purpose corn-
m half a century
)re sophisticated
,orithm. Despite
n in hardware in
hardware divide
It embarrassment

ssisted in performing
Figure 8-11. ASM with memory as a separate actor

ware General-PurposeC omputers 315



A major theme of this book is that speed is not the primary concern of the designer- 8.3.2.5.2
correctness is. An algorithm implemented in software might be slower than the same The purely ha
algorithm implemented in hardware, but you should not worry about speed. The most avoided these
important thing is to implement the algorithm properly, whether in hardware or soft-
ware. (Sometimes speed is part of the specification of a correct design, but even then, a) two sepa
as the Pentium incident indicates, the rest of the design must be correct before the so that the "fr
speed matters.) And so, with an appreciation of the important role division has played hardware.
in the history of computer design, let us consider how to implement our old friend, the b) an exten
childish division algorithm, in software with PDP-8 machine language. "friendly" use

input buses.

8.3.2.5.1 Complete childish division program in C c) anextern
A complete software program written in a high-level language typically has some in- user can obser
put/output formatting statements, such as scanf and printf in C or READ and is fast enough,
WRITE in Pascal (or $readmemb and $display in Verilog). For instance, a com- d) an extem
plete C program to implement the the childish division algorithm from section 2.2 "friendly" uset
might appear as follows:

This approach:
main ()

"friendly," so0
{
unsigned x,y,rl,r2; how to use the

button were de
while (1) machine in dec

{ as a physical o0
scanf('%04o,&x); binary number
scanf("%04o",&y);
rl = x; To translate the
r2 = 0; ing to assume 
while (rl >= y) nary values int

{ 8.3.2.2.2) and
rl = rl - y; tween the "amii
r2 = r2 + 1; and the "friendl

2 is how the us,
printf("%04o\n",r2);

two HLT instruct
} press the cont

(x and y) so thE
Since octal is a convenient notation that is used frequently in this chapter, the input and The following s
output are shown formatted as four-digit octal numbers by scanf andprintf. Trans- and output by tf
lating statements like scanf and printf into the PDP-8 instruction set requires
using 6xxx machine language instructions. We have avoided implementing the 6xxx a) one extern
instructions of the PDP-8 because their implementation requires concepts not covered user can toggle
in this chapter. b) an external

user can push c,

316 Verilog Digital Computer Design: Algorithms into Hardware



)f the designer- 8..3..2..5..2  Uasseerr  Intterfface  for the software
er than the same The  purrelly  harrdwarre  iimpllementtattiions  off  tthe  chiilldiish  diiviisiion  allgoriitthm  iin  chaptter  2
speed. The most i a~vaoviodideed  tthese  input/output formatting problems with:
hardware or soft- , a)~ ~ttwwaoo)  sseeppaarraattee  eexxtteerrnnaall  ddaattaa  iinnppuutt  bbuusseess  ((xx  aanndd  yy)),,  pprreessuumaabbllyy  ccoonnnneecctteedd  to switches,
n, but even to switches,

then, : so~ ~tthhsaaott   tthhee  ""ffrriieennddllyy""  uusseerr  ccaann  ttooggggllee  in the binary values desired to be input into the
Drrect in 

before the 
the binary values desired to be input 

h into the
haarrddwwaarree..

iision has played
ur old friend, the bb))  aann  eexxtteerrnnaall  ssttaattuuss  iinnppuutt  ((ppbb)),,  prreessumaablly  connectted  tto  a  push  butttton,,  so  the
Ye. ""ffrriieennddllyy""  userr  can  iindiicatte  tthe  proper  ttiime  for  tthe  hardware  tto  llook  at the external

input buses.

c))  an  extternall  datta  outtputt  bus  (r2 ),,  presumably connectted  to lliighttss,,  so the "friendly"
ally has some in- uusseerr  ccaann  oobbsseerrvvee  tthhee  ccoomppuuttaattiioonn  ooff  tthhee  qquuoottiieenntt  iinn  bbiinnaarryy  aass  iitt  pprrooggrreesssseess..  ((IIff  tthhee  cclloocckk
C or READ and iiss  ffaasstt  eennoouugghh,,  tthhee  uusseerr  wwiillll  nnoott  nnoottiiccee  aannyytthhiinngg  eexxcceepptt  tthhee  rreessuulltt..))
instance, a corn- d) an  extternall  command  outtputt  ((READY)),,  prressumablly  connectted  tto  aa  lliightt,,  sso  tthee
from section f2ro.2m   section "f~r~i"efrniedndlyly"  user can know when r2 has become the correct quotient.

This approach requires that the person who uses the hardware described in chapter 2 be
"friendly," someone who is willing and able to adhere to several rules that describe
how to use the machine properly. Some of these rules relating toe teim ing of the push
button were described in chapter 2. Although chapter 2 explained the operation of this
machine in decimal notation, the use of switches as a physical input medium and lights
as a physical output medium additionally demands a user who is comfortable with the
binary number system.
To translate the childish division algorithm into PDP-8 machine language, we e go-
ing to assume a similar "amicable" user. This "amicable" user is willing to toggle bi-
nary values into the sr to provide inputs to the algorithm (as described in section
8.3.2.2.2) and observe the binary result in the accumulator. The main difference be-
tween the "amicable" user of the algorithm implemented in PDP-8 machine language
and the "friendly" user of the algorithm implemented in the hardware given in chapter
2an ids  hoouwtp utth be yu stheer  msouftswt aorpee riamtep ltehme emntaacthioinne .o fT thhee  PchDilPd-i8sh s odfitvwisairoen  vaelrgsoiorinth m(w:hich has

s~ ~~  ~~~~~ig two HasLsTm eientr satsrlu ctions) raei-bulsee s the sisngrl.e  nsrti isn put buws slov  thawt "ttahmes i" caambliec"aubhsrl eiw" liunstoeor gmebu-st
1 pusree~ss~ ~tah~lene r  cantin b utthteo n tswreidcoe .p rTohidee rh aridnwpaurtes ti n cthaplete.rg 2r utsmes (taw o seepciaerdait e input ebtouses

(x and y) so that the "friendly" user only presses the noinb  nce.
pter, the input and pter,1the input and TThhee  ffoolllloowwiinngg  ssuummmmaarriizzeess  tthhee  hhaarrddwwaarree  ooff  tthhee  PPDDPP--88  tthhaatt  ii s uuttiilliizzeedd  ffoorr  ccrruuddee  iinnppuutt
Iprintf .Trans- atnwdo  oautnpuett beyn thlsein asstuotuofs t warep eimutphleemne) ntatioonnn  oftp etthdoea  pcsh ildbisuhtsat  nd ivsois ionth ael g"oamritihcmab:le"mt
menting the 6xxx a) one external data input bus (sr), connected to twelve switches, so the "amicable"
cepts not covered uasnedrr  ccaann ptuogsbhgy l e in tthateh fdeeess fitraeedg mbilneanry  aintpiuot pvaaluaeesn.a ouh l ithhdev snaritm

b) an external status input (cont), connected to a push button, so the "amicable"
user can push cont after toggling each separate value in on the sr.

Iware Geeneerrall--PurrposseeC  oomppuutteerrss  331177



-

c) an external data output bus (ac), connected to twelve lights, so the "amicable" Continued
user can observe the computation of the quotient (and other things) in binary as it
progresses. (If the clock is fast enough, the user will not notice anything except the 0011/1100

result.) 0012/3032
0013/3033

d) an external command output (present-state), connected to lights, so the /

"amicable" user can know when ac has become the correct quotient (i.e., when / Th,
/ wI

present_state becomes IDLE).
0014/7200
0015/7100
0016/1101
0017/7040

8.3.2.5.3 Childish division program in machine language 0020/7020

On the left side of the following is the PDP-8 machine language code for the childish 0021/7001
0022/1032

division algorithm. On the right side is the corresponding assembly language mnemon- 0023/7430
ics and symbolic operands, in the style explained in appendix A, with comments fol- 0024/5000
lowing the slash. Only the machine language resides in memory. The commented as-
sembly language is shown only to clarify how the program operates:

/The

/ Childish division algorithm in PDP-8 machine language 0025/3032

/ 0026/1033
/ The following 2 instructions allow the user to observe 0027/7001
/ the previous result (r2) in the ac 0030/3033

0031/5014
0000/7300 LO, CLACLL /(link,ac = {0,0} /
0001/1033 TAD r2 /{link,ac = O,r2} / ThE

/ / thE
/ The following 4 instructions wait for the user to toggle in /
/ the first value on sr (while still displaying r2 on ac) 0032/0000 rl,
/ When the user presses cont, this first value toggled 0033/0000 r2,
/ in on sr is stored into x /

/ The
0002/7402 HLT /wait for user to toggle first value /
0003/7200 CLA / {link,ac} = {0,0} 0100/0000 x,
0004/7404 OSR / {link,ac} = {O,Olsr) )00/0000 y,
0005/3100 DCA x /x = sr; {link,ac} = {0,0}

/ The following 3 instructions wait for the user to toggle in
/ the second value on sr (ac is now cleared)
/ When the user presses cont, this second value toggled 8.3.2.5.4 An
/ in on sr is stored into y The following ta

0006/7402 HLT / wait for user to toggle second value childish division
0007/7404 OSR / {link,ac = {O,Olsr}
0010/3101 DCA y / = sr; {link,ac} = {0,0}

/ The following 3 instructions initialize rl and r2
/ prior to the while loop

318 Verilog Digital Computer Design: Algorithms into Hardware



I
"amicable" Continued
binarv as it C ti e

I ontinued

g except the 0011/1100 TAD x / {link,ac} = {0,0+x}
0012/3032 DCA rl /rl = x; {link,ac} = 0
0013/3033 DCA r2 /r2 = 0;

ights, so the /
/ The 

(i.e., following 
when 9 instructions implement

/ while (rl>=y)

0014/7200 CLA
0015/7100 CLL / {link,ac} = {0,0)
0016/1101 TAD y / {link,ac) = {O,y}
0017/7040 CMA / link,ac} = {0,-y}
0020/7020 CML / {link,ac} = {-0,-y)

the childish 0021/7001 IAC / {link,ac} = (-O,-y}+l
0022/1032 

ge mnemon- TAD rl / {link,ac} = {-0,-y}+l + rl
0023/7430 SZL / test whether {-0,-y}+l + rl >= 0

mments fol- 0024/5000 JMP LO / if {-0,-y}+l + rl < 0, exit while (goto L)
mmented as- / if {-O,-y}+l + rl >=0, stay in while loop

/The following 5 instructions implement body of the while loop
A

0025/3032 DCA rl /rl = rl - y; i.e. rl=-y+l+rl; ac=0
0026/1033 TAD r2 / {link,ac} = {OO+r2}
0027/7001 IAC / {link,ac} = {OO+r2}+1 (
0030/3033 DCA r2 /r2 = r2+1
0031/5014 JMP L1 /continue while loop

/ N

/ The following 2 words store date manipulated by
/ the childish division algorithm r
/

0032/0000 rl, 0000
0033/0000 r2, 0000

/
/ The following 2 words store data input from the sr
/

0100/0000 x, 0000
0101/0000 y, 0000

8.3.2.5.4 Analysis of childish division software
The following table summarizes how many clock cycles it takes for each part of the
childish division program given in section 8.3.2.5.3 to execute:

,e I General-PurposeC  omputers  319

I I



High-level Operations Before During After The "section" cc
while while while also the machine

takes to comput,
rl = x; 14 inputs. The "12-
r2 = 0; 7

required (in the 
while (rl >= y) 44 44

address register,
rl = rl - y; 7 isters such as ha
r2 = r2 + 1 24 cost of the coml

} 5 (since this is the
display r2 in accumulator and halt 18 many words the

cial-purpose imr
Total Clock Cycles 21 75 67 ware registers cc

The "ctrl states"
The times are listed in three columns. The left column indicates operations that execute Any way you lo
just once, before the while loop begins. The right column indicates operations that the fastest speci
execute just once, upon exiting from the while loop. The middle column indicates approaches beinj
operations that occur each time through the loop. The while statement itself involves
formation of the 13-bit twos complement (32 cycles) and testing (12 cycles). The entry
44 (32+12) occurs both in the middle and right columns because this machine code Lim
occurs each time through the loop as well as the final time when the condition rl>=y quotient
becomes false. Just as in chapter 2, the number of times the loop executes is propor-
tionate to the quotient. Neglecting how long it takes for the user to toggle in the inputs,
from the time the program actually starts computing the quotient (when the program For the particula
counter was 0011) until the machine returns to state IDLE is 21 + 67 + 75 *quo- 238/5, or about 4
tient clock cycles. tion 2.2.7 makes

of three high-lev(
ing each clock cy

8.3.2.5.5 Comparison with special-purpose implementation ism, and so we oi
This table compares different implementations of the childish division algorithm:

On the other han
12-bit more sporting, th

section clock cycles 12-bit memory ctrl because it only d(
registers words states

software approac
2.2.7 3+quotient 3 0 2

special 2.2.3 2+2*quotient 2 0 4
purpose 2.2.2 3+3*quotient 2 0 5
hardware 2.2.5 2+3*quotient 3 0 5 Lim

quotient --
PDP-8 software 8.3.2 88+75*quotient 5 30 31

For the particular
238/9, or about 

320 Verilog Digital Computer Design: Algorithms into Hardware

L



ng Atter The "section" column indicates where the ASM (and in the case of the PDP-8 software,
ile whilE also the machine language) is defined. The "clock cycle" column indicates how long it

takes to compute the quotient, neglecting the time for the user to toggle in the binary
inputs. The "12-bit registers" indicates how many hardware registers of this size are
required (in the case of the PDP-8, this is the accumulator, instruction register, memory

44 44 address register, memory buffer register and program counter). We neglect one bit reg-
isters such as halt and link as being insignificant in the total cost. We 

7 also neglect the
cost of the 

24 combinational logic that interconnects the registers within the architecture
5 (since this is the subject of section 8.4). The "12-bit memory words" indicates how

18 many words the machine language version requires for both program and data. Spe-
cial-purpose implementations of this algorithm do not need memory because the hard-

75 67 ware registers continually hold the data, and the controller implements the algorithm.
The ctrl states" indicates how many states are required by the hardware ASM.

ons that execute Any way you look at the above table, software appears to be a real loser. Compared to
operations that the fastest special-purpose implementation listed above (section 2.2.7), the software

olumn indicates approaches being about seventy-five times slower for a large quotient:
It itself involves
tcles). The entry d
is machine code Lim (8 8 +75*quotient)/(3+quotient) = 75
Dndition rl>=y quotient -
,cutes is propor- I
gle in the inputs, 4

hen the program For the particular case traced above and in chapter two (quotient=14/7), the ratio is
7 + 75*quo- 238/5, or about 47 times slower. One reason why the hardware implementation in sec-

tion 2.2.7 makes the software look so bad is because the hardware does the equivalent
of three high-level operations (test rl >=y, rl=rl -y and r2 =r2 +1) in parallel dur-
ing each clock cycle. The childish division algorithm has the potential for this parallel-

)n ism, and so we ought to exploit this.

On the other hand, if we wanted to handicap the hardware to make the contest seem
more sporting, the ASM of section 2.2.2 is the closest to the software implementation
because it only does one high-level operation at a time. For very large quotient, the
software approaches being about 25 times slower than section 2.2.2:

Lim (8 8+75*quotient)/(3+3*quotient) = 25
quotient - 00

For the particular case traced above and in chapter two (quotient=14/7), the ratio is
238/9, or about 26 times slower.

General-PurposeC omputers 321



-

Even when the hardware only does one thing at a time (as in section 2.2.2), the soft- (a very mode
ware appears much slower. There are two reasons for this. First, it takes several PDP-8 will only see
instructions to do the equivalent of one high-level language statement (which is most cation of a pr,
noticeable in implementing the while). Second, the way we have implemented the user, the inpul
ASM for the PDP-8, it takes several clock cycles (either five or seven) for each instruc- per second, oi
tion to execute.

In most instar
Software requires general-purpose hardware in order to run. The PDP-8 is about as is design spee
simple as a general-purpose computer can be, but even so, it requires five registers. cost for the de
Software also requires memory for programs and data. Because of technological dif- ware which is
ferences explained in section 8.1, the cost to store a bit in memory is usually several necessary bec
times lower than to store a bit in a register. For the sake of argument, say that the cost designer finds
for a 12-bit word in memory is five times cheaper than for a 12-bit register. The storage purpose comp
costs are then 2*5 for section 2.2.2 hardware, 3*5 for section 2.2.7 hardware, and puter. Also, m;
5*5+30 for the PDP-8 implementation (assuming we only pay for the memory actually are required dt
used to implement the childish division program). Therefore, section 2.2.2 storage cost puters, such as
is about one fifth that of the PDP-8 implementation, and section 2.2.7 storage cost is ware designer
about one-quarter that of the PDP-8 implementation. the above mac

The situation t
8.3.2.5.6 Trade-off between hardware and software between using
One cannot draw sweeping conclusions having examined only a single algorithm in the market prim
hardware and software, and having examined the software on a single implementation within budget
of a single instruction set. The difference between hardware and software may be less meets physical
pronounced when the algorithm is more complicated or when the instruction set is tended applica
more capable. In particular, algorithms that require memory for storage of data struc- cause of the ads
tures, such as arrays, may show software performance closer to that of special-purpose on general-pur
hardware. However, for the childish division algorithm, we can conclude the software ated two differ,
solution gives lower performance and costs more.

First is the emc
Would you pay more to buy something slower? Paradoxically, in most instances, you handful of corn
probably would because hardware speed and cost are often not the primary concern. nies employ on
Certainly in this case, speed is unimportant when you consider the problem that the of this book wi
childish division algorithm solves. It interactively obtains two 12-bit inputs, divides signers face a d
them in a very inefficient way,"1 and displays the answer. It is going to take the user no one has yet c
several seconds to toggle in the inputs, and several more for the user to comprehend the the general-pufl
output. Since the largest 12-bit quotient is 4095, the maximum total time for the PDP- how the machir
8 implementation is 88+75*4095 = 307213 clock cycles. Although this seems awful in a designer solv
comparison to the 4098 clock cycles required by the hardware implementation of sec- chine is fast en
tion 2.2.7, it is less than the blink of an eye when the clock period is 100 nanoseconds puter in existen

General-purpos,
1 Regardless of the underling implementation (hardware or software), there are much better algorithms than
the childish division algorithm if you really want to divide fast. 12 Here "technologi

dollars.

322 Verilog Digital Computer Design: Algorithms into Hardware



_-R P-

2.2), the soft- (a very moderate clock speed using current integrated circuit technology). The user
everal PDP-8 will only see a brief flash before the correct answer appears. Occasionally, the specifi-
which is most cation of a problem has a real-time aspect to it. For example, if instead of our friendly
lemented the user, the input came from another machine that needed to divide two thousand numbers
r each instruc- per second, only the hardware of section 2.2.7 would be able to keep up.

In most instances however, the factor that matters more than hardware speed and cost
-8 is about as is design speed and cost. In other words, how long does it take and how much does it
five registers. cost for the designer to produce a correct design? Designers are willing to use hard-
biological dif- ware which is, in a technological"2 sense, more costly and slower than is theoretically
sually several necessary because in doing so they obtain the benefit of rapid debugging. When a
y that the cost designer finds an error, it is easier to change a few bits in the memory of a general-
XrT. he storage purpose computer than it is to fabricate a corrected version of a special-purpose com-
hardware, and puter. Also, many design changes occur not because of a designer's mistake but instead
Emory actually are required due to changing specifications. Productivity tools for general-purpose com-
.2 storage cost puters, such as compilers, assemblers, linkers, editors, debuggers, etc., make the soft-
storage cost is ware designer's task of coping with bugs and changing specifications much easier than

the above machine language examples.

The situation that has existed for the last half century is designers have had the choice
between using a general-purpose computer or building a special-purpose computer. If

e algorithm in the market price (in dollars, rather than in gates) of the general-purpose computer is
nplementation within budget and its speed is adequate (not the fastest, just adequate) and otherwise f
Lre may be less meets physical constraints (size, weight, power consumption, ruggedness) for the in-
itruction set is tended application, the designer typically chooses the general-purpose computer be-
,o f data struc- cause of the advantages of rapid debugging. Although most algorithms work adequately

pecial-purpose on general-purpose computers, some demand special-purpose hardware. This has cre-
le the software ated two different economic phenomena.

First is the emergence of the general-purpose computer industry, composed of only a
instances, you handful of companies worldwide that actually design CPUs. All together, these compa-

imary concern. nies employ only a few hundred computer designers at best, and so few of the readers
-oblem that the of this book will ever be employed as general-purpose computer designers. These de-
inputs, divides signers face a daunting challenge: they design machines that will be used for tasks that
to take the user no one has yet conceived. Programmers in the future will think of new things to do with
Comprehend the the general-purpose machines that designers are working on today. Why does knowing
ie for the PDP- how the machine will be used assist the designer? Speed is not the primary concern of
seems awful in a designer solving a specific problem because the designer can easily tell if the ma-
entation of sec- chine is fast enough. A special-purpose computer does not have to be the fastest com-
)On anoseconds puter in existence-it just has to be fast enough, and, of course, do its job correctly.

General-purpose computer designers do not have the luxury of knowing what is fast

tter algorithms than 12 Here "technological" means measuring cost in in terms of registers, gates, chip area, etc., rather than in
dollars.

,are General-PurposeC omputers 323



enough. Because of the market pressures created by this uncertainty, they hav b) register
oped more efficient (but intricate) variations on the fetch/execute algorithm tt c) register
software to approach the speed of a special-purpose computer. This has con d) register
cost of increased hardware by using sophisticated techniques, such as pipelinin e) register
ters 6 and 9), and is why there is such variety among the instruction sets (cha: f) register
Second, a more recent phenomenon is the emergence of hardware description la It is wise to wr
(chapter 3) running on general-purpose computers that allow the debugging back to the AS]
tion) and synthesizing of efficient special-purpose computers to be almost as register transfe
the programming of software. It is the theme of this book that the worlds of The following
and software are converging. You will need to be aware of both of these to pi
the next half century of the computer age.

RTI
ac

8.4 Mixed fetch/execute ac

In order to illustrate that there is nothing mysterious about the design of a ac
purpose computer once the details of the fetch/execute algorithm are specif ac
translate the pure behavioral ASM (section 8.3.2.4.2) for the PDP-8 instruction li
into the mixed stage of the top-down design process. Recall from section 2.1 iI:
mixed stage consists of two hardware structures: a controller and an architec

{a,
There are many possible architectures that can implement a given pure behavior {1
The more complicated the ASM, the more room there is for creativity in the (

{ 1
the architecture. Once the designer decides upon an architecture, the desil
controller is a relatively mechanical process. {1

{1

8.4.1 A methodical approach for designing the architectur ha
When an ASM uses more than a handful of registers and/or states, it becomes

ha
to keep track of all of the details in your head. In such an instance, it is wise
methodical approach to designing the architecture. To begin with, note all of 
ter transfers that occur in each state. Write down this information grouped tol ir

destination. Since in section 8.3.2.4.2 there are six possible destinations (left-h
of A-, excluding the memory, which in section 8.3.2.4.2 is a separate actor), ma

six groups to note: ma
ma
ma

a) register transfers to the accumulator and/or lind. (These are together in c
since { link, ac } often acts as a 13-bit register, and so modificatic mb
accumulator by itself or to the link by itself should be considered as mb
tions to {link, ac});

mb

324 Verilog Digital Computer Design: Algorithms into Hardware



they have devel- b) register transfers to the halt flag;
rithm that allow c) register transfers to the instruction register;
has come at the d) register transfers to the memory address register;
)ipelining (chap- e) register transfers to the memory buffer register; and
ets (chapter 10). f) register transfers to the program counter.
-ption languages It is wise to write down the state(s) in which each transfer occurs so that you can refer
)ugging (simula- back to the ASM as necessary. (When both the right-hand sides and left-hand sides of
Llmost as easy as register transfers in two or more states are identical, note the names of all such states.)
rlds of hardware The following table illustrates this for the ASM in section 8.3.2.4.2:
ese to prosper in

RTN State () 
ac - 0 EOCLA, E1BDCA

ac - ac & mb EOAND

ign of a general- ac - ac sr EOOSR

^e specified, let's ac - ac EOCMA
nstruction subset link - 0 EOCLL
ction 2.1.5.2, the

link - -link EOCML
architecture.

{ac,link} - {link, ac} EORAR
behavioral ASM. {link,ac} - {ac, link} EORAL
y in the design of

{link,ac} -
he design of the 0 EOCLACLL

{link,ac} <- {link,ac + 1 EOIAC

{link,ac} <- {link,ac} + mb EOTAD

tecture
halt <- 0 IDLE

becomes difficult
halt - 1

t is wise to take a EOHLT,INIT

te all of the regis-
)uped together by ir - membus F3A

as (left-hand sides
e actor), there are ma <- ea(ir) F3B

ma <- ma + 1 EOBDEP

ma p-P c Fl

ma <- sr EOMA
ether in one group
difications to the mb <- ac EODCA

lered as modifica-
mb (- membus F4A

mb *- sr EODEP

General-PurposeC omputers 325



Ir-

Continued
The first deci

RTN State(s) ment each ret
PC <- ma EOJMP in the ASM (I
PC <- PC + 1 be more com

F2, EOASKIP
look at 

PC each 
- g

sr EOPC note those reg:
the variable (a

Note that implicitly, the { 1 ink, ac } group should be thought of as implementing the
following register For the 

transfers: link an

{link,ac} <- {link,O} EOCLA, E1BDCA
{link,ac} *- {link,ac & mb} EAND

{link,ac} - {link,ac sr} EOOSR

{link,ac} <- {link,-ac} EOCMA

{link,ac} <- {Oac} EOCLL

{link,ac} A- {Vlink,ac} EOCML

{ac,link} <- {link,ac} EORAR

{link,ac} *- {ac,link} EORAL For the halt flag,
{link,ac} - 0 EOCLACLL

{link,ac} - {link,ac} + 1 EOIAC

{link,ac} - {link,ac} + mb EOTAD alt

halt
These two ways of describing link and accumulator register transfers are equivalent.
The former is easier for the designer to comprehend. The latter is important in the next For the memory a
step the designer takes.

8.4.2 Choosing register types | ~m*a- 
Here is where the creative part occurs. Whatever hardware structure the designer chooses
must be capable of implementing each of the above register transfers during the state(s) Similarly, for the I
indicated. The controller will take care of making sure the states happen at the proper both sides:
times, so we do not have to worry about that. Our concern now is that the architecture
can manipulate the data as listed above.

For the instruction 
fers.

326 Verilog Digital Computer Design: Algorithms into Hardware

a
U



The first decision the designer must make is what kind of structural device will imple-
ment each register. One possibility would be to use enabled registers for every variable
in the ASM (other than memory); however, this will typically cause the architecture to
be more complex than if other types of registers are selected. A better approach is to
look at each group (corresponding to transfers to a particular register) individually and
note those register transfers where the right-hand side consists only of constants and/or
the variable (or concatenated variables) on the left-hand side.

implementing the For the link and accumulator group, there are several such register transfers:

{link,ac} <- {link,O} EOCLA, ElBDCA
{link,acl -- {link,-ac} EOCMA

DCA {link,ac} *- {O,ac} EOCLL

{link,ac} <- {-link,ac} EOCML

{link,ac} *- 0 EOCLACLL

{ac,link} <- {link,ac} EORAR

{link,ac} - {ac,link} EORAL

{link,ac} <- {link,ac} + 1 EOIAC

For the halt flag, both of the possible register transfers are of this kind:

halt <- 0 IDLE

halt - 1 EOHLT,INIT

rs are equivalent.
?ortant in the next For the memory address register, only one of the register transfers meet this criteria:

ma - ma + 1 EOBDEP

designer chooses
during the state(s) Similarly, for the program counter, there is only one register transfer that uses pc on
pen at the proper both sides:

at the architecture

| pc *- pC + 1 F2, EOASKIP

For the instruction register and memory buffer register, there are no such register trans-
fers.

ware General-PurposeC omputers 327



The reason for identifying such register transfers is that, in theory, such transfers can be signer 
implemented internally within a register device without the need for any external data nterna
interconnection. Although such devices may be slightly more expensive, the intellec-
tual simplification they provide to the architecture is usually worth the added cost.

For registers where no such transfers occur, it is clear that the designer should use
enabled registers. Therefore, to implement an architecture for the ASM of section
8.3.2.4.2, the instruction register and the memory buffer register should be enabled
registers. For these registers, whatever new data is loaded always comes from outside )mpleti
the enabled register. menteo
In the case of the memory address register and the program counter, it is obvious from
the above that an up counter register is the most appropriate choice. For the halt flag, a
clearable enabled register (or its equivalent) is a reasonable choice because this allows {1:
the halt <- 0 transfer to occur internally (leaving only the halt - 1 to be {1:
provided externally). {1:

The choice of the register type for { link, ac } is less clear. In theory, one could {1:
imagine a device that is capable internally of doing all the operations listed for the link {1
and accumulator. The problem is that such a contrived device is not one of the standard
register building blocks discussed in appendix D. The intellectual simplification of
register building blocks occurs not only because they hide details internally (hierarchi- way t
cal design) but also that their behavior is widely understood in industry and they can be block i
concisely explained in a single cohesive sentence. (An up counter can hold, load, clear Lpable
and increment its data. These operations are no more and no less than what is required numb(
to "count up.") It would not be wrong to build a device that does everything for the link accum
and accumulator. (An automated synthesis tool, such as the one described in chapter 7, gical (t
might take such an approach.) As a matter of good style for a manually synthesized EOOS'
design and out of consideration to others who attempt to understand the architecture, Is (as r
we will instead choose standard register building blocks of the kind described in ap- shed a
pendix D. ac) E

-nentin
Of the building blocks described in appendix D, there are two possible choices for the use a
link and accumulator: the up counter and the shift register. If the designer chooses an
up counter, the following register transfers can be implemented internally by the de- the reg
vice:

{
{link,ac} - link,O} EOCLA, EBDCA m.

{link,ac} - {,ac} EOCLL i

{link,ac} <- EOCLACLL PI
hi

{link,ac} - {link,ac} + 1 EOIAC

328 Verilog Digital Computer Design: Algorithms into Hardware



transfers can be If the designer chooses a shift register, a different set of register transfers can be imple-
.y external data mented internally by the device:
ve, the intellec-

added cost.
{ac,link} <- {link,ac} EORAR

Yner should use
6SM of section | {link,ac} - {ac,link} EORAL

)uld be enabled
ies from outside Of the complete group of link and accumulator register transfers, the ones that cannot

be implemented by either of these building blocks include:
is obvious from
irt he halt flag, a
ause this allows {link,ac} - {link,-ac} EOCMA

t - 1 to be {link,ac} - {-link,ac} EOCML

{link,ac} - {link,ac & mb} EOAND

eory, one could {link,ac} - {link,ac sr} EOOSR

isted for the link {link,ac} - {link,ac} + mb EOTAD

e of the standard
implification of

The best way to implement 
nally such 

(hierarchi- computations that must occur outside the register
building block is with a combinational 

and ALU, 
they such 

can be as the one described in section 2.3.4,
that is capable of doing addition and logical operations. 

hold, load, Since 
clear the ALU can add an

arbitrary number to the accumulator (as required 
what in state 

is required EOTAD), it can also incre-
ment the accumulator (as required 

thing in state 
for the EOIAC). 

link The ALU can perform sixteen dif-
ferent logical (bitwise) operations, including 

bed AND, 
in chapter 7, OR and NOT (as required in states

EOAND, EOOSR, EOCMA and EOCML). The ALU 
ally can 

synthesized output zero, and so the clearing
operations (as required in states EOCLA, ElBDCA, EOCLL and EOCLACLL) 

the architecture, can be
accomplished at no added cost. Since the 

described ALU is suitable 
in ap- for either design alternative

({ link, ac } as an up counter or { link, ac as a shift register) but the ALU can do
the incrementing that would otherwise require a counter, an appropriate design deci-

e choices for the sion is to use a shift register for {link, ad}.
igner chooses an Here are the register types 
rnally chosen 

by the above:
de-

{link,ac} 13-bit shift register
mb 12-bit enabled register
ma 12-bit up counter register
ir 12-bit enabled register
PC 12-bit up counter register
halt 1-bit clearable enabled register

ware General-PurposeC omputers 329



8.4.3 Remaining register transfers that selects be
Having decided on each register type, we can eliminate those register transfers that that although t
occur internally within the register device, which leaves the following: mulator portio

accumulator, j
ac - 0 EOCLA, ElBDCA follows:
ac <- ac & mb EAND

ac - ac sr EOOSR

ac - ac EOCMA

link - 0 EOCLL

link - -link EOCML

{link,ac} - EOCLACLL

{link,ac} <- {link,ac} + 1 EOIAC

{link,ac} - {link,ac} + mb EOTAD

halt - 1 EOHLT,EOINIT

ir - membus F3A
The default (wi
the accumulate

ma <- ea(ir) F3B

ma <- pc Fl The ea(ir) I
this as a separa

ma sr EOMA
that are describ

mb E- ac EODCA There is only ot
mb <- membus F4A Similarly, there

is the memory e
mb <- sr EODEP

device).

pc <- ma EOJMP The remaining
pc <- sr EOPC the appropriate

selects among 
register is a 12-

The remaining { 1 ink, ac } transfers are listed above in their original form to provide input to the prol
documentation that more closely matches the original ASM. For example, ac <- 0 is address register
moreconcise than {link, ac} <- {link, 0}. Here is the bloc

8:
8.4.4 Putting the architecture together
In choosing the shift register, we also determined that every one of the remaining
{1  ink, ac transfers (listed in section 8.4.3) can be implemented by the ALU. One
of the inputs to theALU will be the 13-bit {l ink, ac }. The other will be a 13-bit mux

330 Verilog Digital Computer Design: Algorithms into Hardware



that selects between { 0, sr }, { 0, mb } and the constant one. It is important to note
ter transfers that that although the { link, ac } is a unified thirteen-bit shift register, the link and accu-
D.:i mulator portions are controlled separately. Therefore, it is possible to load just the

accumulator, just the link or both of them. The controls for the { link, ac } are as
)CA follows:

linkctrl linkctrl acctrl acctrl action
bits symbol bits symbol

00 'HOLD 00 'HOLD do nothing

00 'HOLD 11 'LOAD ac <-alubus[ll:0]

11 'LOAD 00 'HOLD link - alubus[12]

11 'LOAD 11 'LOAD {link,ac} - alubus

10 'LEFT 10 'LEFT {link,ac} - {ac,linkl

01 'RIGHT 01 'RIGHT {ac,link} - {link,ac}

The default (when l inkc trl and acctrl are not mentioned in a state) is to hold
the accumulator and link as they are.

The ea (ir) function can be implemented by trivial combinational logic. We leave
this as a separate device since there are other addressing modes not implemented here
that are described in appendix B and that are left as exercises.

There is only one register transfer left for the halt flag, and so its input is a constant one.
Similarly, there is only one register transfer for the instruction register, and so its input
is the memory bus (which provides m [m a ] to the architecture from the external memory
device).

The remaining register transfers can be provided for by placing muxes on the inputs of
the appropriate registers. The input to the memory buffer register is a 12-bit mux that
selects among sr, the accumulator and memory bus. The input to the memory address
register is a 12-bit mux that selects among s r, ea (i r) and the program counter. The

il form to provide input to the program counter is a 12-bit mux that selects between the sr and the memory
nple, ac 4- 0 is address register.

Here is the block diagram of the architecture that was just derived for the subset PDP-
8:

of the remaining
by the ALU. One
ill be a 13-bit mux

ware General-PurposeC omputers 331



11

Figure 8-1.

The fourth inj
and therefore
help to impler

8.4.5 Imp
The ASM of s
inputs (cont,
architecture. I
tecture (link
these decision
exists.

Recall from se
against constai
bits of the stat
simply link,
particular, sin(
make it an inp

8.4.6 Mix
Here is the mi,
ter transfers of

Figure 8-12. Architecture for PDP-8 subset.

332 Verilog Digital Computer Design: Algorithms into Hardware



ldhalt crhl

,`I[ H
haltbus

Figure8 -12. Architecturef or PDP-8s ubset (continued).

The fourth inputs to the memory address and memory buffer muxes are not required
and therefore tied to zero. It is left as an exercise to show that these fourth inputs will
help to implement more of the instructions given in appendix B.

8.4.5 Implementing the decisions
The ASM of section 8.3.2.4.2 has several decisions. Some of these test external status

12  mbbus
12 inputs (cont, butPC, butMA and butDEP) that have nothing to do with the

architecture. The remaining decisions test data contained in the registers of the archi-
tecture (link, ac, ir and halt). Although it would be possible to implement each of
these decisions using a comparator, another easier way to implement these decisions
exists.

Recall from section 2.1.3.1.2 that a multi-bit external status signal which is only tested
against constants can be rewritten as a nested series of decisions that test the individual
bits of the status. Using this approach, the internal status inputs to the controller are
simply link, ac, ir and halt with no need for comparators 

12 ' mabus in the architecture. In
particular, since the instruction register is used in so many decisions, it is prudent to
make it an input to the controller.

8.4.6 Mixed ASM
Here is the mixed ASM for the architecture of section 8.4.4 that implements the regis-
ter transfers of section 8.3.2.4.2:

ware General-PurposeC omputers 333



INIT[I Idhalt As discussed
the controller

F1 mamuxcr IDLE means using:
that the contr(
tools can tranw

F2r incpc l Damuxctrl=mOl REOOMA ler.
F3AJ Ir ma =01DE

F3B| I~~~~mdaamuulxlc trl=2 1 rtje1  8.4.7 
ADEP Bo

0~~~~~~ Idmb ||nm 1BE The following

< °1 |~~actr LOA;;linkc =; OA 1-
mbmuxctrl=1; IdmbI EODCA

O g write ;;=ElADCA
, |~aIuctrI='ZERO;acctrI=l~A sElBDCA

r 00 aluctrl='ZERO;acctrl=LOA-D EOCA 

~ E , - I alumuxctr=2;1inkctrlLAD

ir 1==1o: 1aluctri=AN actrI=A ECN
r==1 1=

r== cont 
47 butPC-t---

but_MA-- -
butDEP$.

r == 7 40QEEIP p
70i3i6&clj5&a=0 EOIIr] ln 

- 1 alu~~~pmuxctrl=1 OII

1 + | ~EOBSKIP EOASKIP incpc L_ .

Figure 8-14
Figure8 -13. Mixed ASMfor PDP-8 subset.

334 Verilog Digital ComputerD esign: Algorithms into Hardware



emented entirely in
,tandable way. This
vidual bit decisions
(, modem synthesis
uired in the control-

^ together:

- I
I

ac

nbus I
, 121 memory

'12 
77L

i
iI

I
is* present

ware General-PurposeC omputers 335



It is a simple, but tedious, matter to use hierarchical design to fill in the details of the The memory 
controller h

from the ASM of section 8.4.6. Happily, synthesis tools can also aid the accesses 
designer occui

with this process. few words tha
of the hierarch
levels, we obs(

8.5. Memory hierarchy than if it were
As described in section 8.2.3, the design of large and fast memories has been a chal- not significant
lenge since the time of the earliest electronic computers. By the end of the twentieth sence, we alm
century, these issues became of increasing concern because improving silicon tech- mance occurs
nologies 3 allowed general-purpose processors to run at ever-higher clock frequencies. execute almosi
Large low-cost memory, such as dynamic memory chips, was unable to keep up with ested in may a,
increasing processor speeds. that program a,
If general-purpose computers details 

accessed of the n
memory in a completely random and haphaz-

ard fashion such that we could not make any kind of accurate prediction for which There are two
word in memory the processor would access next, this mismatch of processor and cache memory.
memory speed would be unsolvable. Happily, because of the nature of the fetch/ex- what Kilburn u
ecute algorithm and the nature of most machine language programs interpreted by the less frequently
fetch/execute algorithm, we can predict, with reasonably good odds, what word the many orders o
processor might fetch next. This solution to the mismatch between processor and memory very non-deter
speed has been recognized since 1962, when Kilburn and others at the University of be positioned 
Manchester designed the Atlas computer to take advantage of the fact that not all words similar to cach(
in memory are accessed with the same frequency. ware. Hardware
Kilburn's solution, which management 

has endured o
with minor variations for more than a third of a

century, is to design a operating 
hierarchy syste

of memories of different speeds, sizes and costs. The
hierarchy might have several beyond the 

different sco]
levels, each containing a different memory tech-

nology. The lowest level has a memory technology that costs the least per bit. This 8.5.1 Cach
memory will have the largest number of words since we can afford to buy quite a lot of Cache memory
such cheap memory. Such inexpensive memory necessarily has a slow access time. components. TI
Each higher level in the hierarchy has a kind of memory which is faster than lower Of course, the 
levels in the hierarchy. Because the faster memories are more expensive per bit than the but the cache alt
memories in the lower levels in the hierarchy, we can only afford smaller memory sizes portion of the c
in the upper levels of the heriarchy. expensive high-

clock cycle. WI
still allows data

13P rimarily smaller chip dimensions which mean lower propagation delays. 14Also, there is the

336 Verilog Digital Computer Design: Algorithms into Hardware



ie details of the The memory hierarchy is usually effective because, statistically speaking, most memory
an also aid the accesses occur to words that have already been accessed before. If the system keeps the

few words that are more likely to be accessed in the fast but small-sized higher levels
of the hierarchy, and all the other words that are less likely to be accessed in the lower
levels, we observe two benefits. First, the cost of the system is not significantly higher
than if it were built entirely of slow cheap memory. Second, the speed of the system is

ias been a chal- not significantly slower than if it were 1-u ilt entirely of fast expensive memory. In es-
f the twentieth sence, we almost get the best of both alternatives. However, this good cost and perfor-

ng silicon tech- mance occurs only in a statistical sense: the "average" program will on "average"
)ck frequencies. execute almost as fast as if the system used a fast memory. The program you are inter-
to keep up with ested in may actually execute considerably slower, depending on the pattern in which

that program accesses memory for the particular data you give it and depending on the
details of the memory hierarchy you use.

)m and haphaz-
ction for which There are two common kinds of memory hierarchy. The first of these is known as
f processor and cache memory, which is discussed in the next section. The second of these, which is
of the fetch/ex- what Kilburn used, is known as virtual memory. The idea of virtual memory is to keep
terpreted by the less frequently used parts of memory on disk. The access time for the data on disk is
what word the many orders of magnitude slower than for data in semiconductor memory. It is also

sor and memory very non-deterministic because of the unpredictable distance the disk has to rotate to
e University of be positioned on the proper data.'4 Although conceptually, virtual memory is very
iat not all words similar to cache memory, its implementation requires conplicated hardware and soft-

ware. Hardware implementation of virtual memory requires a disk controller, and the
management of virtual memory is usually intertwined with the software details of an

than a third of a operating system. Since hardware disk controllers and software operating systems are
s and costs. The beyond the scope of this book, we will not consider virtual memory.
at memory tech-
ast per bit. This 8.5.1 Cache memory
uy quite a lot of Cache memory is the fastest part of the memory hierarchy. It is built out of several

ow access time. components. The cache needs its own controller, which we will ignore for the moment.
aster than lower Of course, the cache needs high-speed memory for the data to be stored in the cache,
ep er bit than the but the cache also needs a tag memory which indicates the address associated with each

er memory sizes portion of the cache. The data and tag memories of the cache are usually composed of
expensive high-speed static memory that can be accessed in significantly less than one
clock cycle. When the propagation delay of the rest of the system is considered, this
still allows data to be fetched from the cache in one clock cycle.

'4 Also, there is the chance the disk head has to move, which can take a significant fraction of a second.

vare General-PurposeC omputers 337



-I P

The tag memory is needed because a particular part of the cache may be associated
with more than one address at different times during the operation of the cache. In 0000/7
contrast, a particular part of an ordinary (main) memory will always be associated with 0001/1

one particular constant address. As explained in section 8.2.2.3.1, such a main memory 0002/li

can be thought of as a mux which selects one of 0003 
several /7!

register values. Each cell in a
main memory is always associated with its particular address because that address 0004/5<

0 005/7'
specifies the port of the mux to which the corresponding register is wired. 0006/7'

There are two common approaches to designing a cache. In the direct mapped ap-
proach, there is only one tag memory and one data memory. 0011/0(

In the multi-way set asso-
ciative approach, there are several parallel tag and corresponding data memories. The
direct mapped approach is simpler and therefore allows a faster access time. On the Assuming the
other hand, the direct approach is often not as successful in keeping the appropriate listed above, a
words in the cache as the multi-way approach, and so even though the access time of
the multi-way approach is slower, it may be faster overall for some programs than the
direct approach. This section, however, will concentrate on the direct mapped approach,
which is easier to comprehend.

The typical cache memory uses the low-order bits of the address bus to select informa-
tion out of both the data and tag portions of the cache. In c

order for a memory access to
be fast, the information fetched from the tag memory must match the address bus.'5 If
it does not, the cache must be updated from some lower level of the memory hierarchy.
Commercial computer systems often have more than one level of cache. In such sys-
tems, the first level is often on the same chip as the processor to maintain the highest
(single clock) speed. The second level (referred to as L2) is contained on separate chips The words shc
that allow access in a small number of cycles. The main memory is composed of dy- When the proc
namic memory, with an access time of many clock cycles. In this section, however, cause address 
there will only be two levels in the memory hierarchy: the direct mapped cache and the cache has to bi
main memory. looks like:
In this chapter, we will assume each element of the cache content memory is a single
word. Often, in commercial systems, each element of the cache content memory is a tag
group of several contiguous words, known as a line. Using a line composed of several
words may improve the performance of the cache, but including such details here would 1/001

obscure the idea being discussed in this section: how a cache is a cost-effective way to 2/000.
improve the performance of a general-purpose computer. 3/000:

For example, assume a cache size of four words'6 with the following simple program
that goes through a loop eight times producing nine values'7 (7760, 7762, ... 7776 and
0000) in the accumulator:
15 In an actual implementation, only the high-order Fetching 

bits need the 
to ne

be stored in the tag memory and checked
against the high-order bits of the address bus, but we will ignore this detail for now.
16 This is too small for practical use but will illustrate how a cache works.
17These are the nine decimal values -16, -14, ... -2 and 0.

338 Verilog Digital Computer Design: Algorithms into Hardware



Ly be associated
0000/7300 CLACLL // ac = -16

of the cache. In
0001/1006 TAD A

associated with 0002/1011 L, TAD B // ac = ac + 2
a main memory 0003/7510 SPA // if ac>=0, halt
;s.E ach cell in a 0004/5002 JMP L // if ac<0, stay in loop
ise that address 0005/7402 HLT
tired. 0006/7760 A, 7760 // equivalent to decimal -16

*0011
ect mapped ap- 0011/0002 B, 0002 // +2
Iti-way set asso-
i memories. The

-ss time. On the Assuming the instructions of this program are loaded into memory in the same order as
the appropriate listed above, at the time the fetch/execute cycle begins, the cache will contain:

e access time of
-ograms than the cache main memory
Lapped approach, tag data 0000/7300

0/0004 0/5002 0001/1006
1/0011 1/0002 0002/1011

D select informa- 2/0006 2/7760 0003/7510
iemory access to 3/0003 3/7510 0004/5002
address bus. If 0005/7402
emory hierarchy. 0006/7760
che. In such sys- 0011/0002

ntain the highest
on separate chips The words shown in bold for the main memory are the ones currently in the cache.
composed of dy- When the processor fetches the first instruction, the memory access will be slow be-
ection, however, cause address 0000 is not currently in the cache. This is known as a cache miss. The
)ed cache and the cache has to bring in this word (7300) from the main memory, and so the cache now

looks like:

emory is a single cache main memory

tent memory is a tag data 0000/7300
0/0000 0/7300

posed of several 0001/1006
1/0011 1/0002 0002/1011

Details here would 2/0006 2/7760 0003/7510
t-effective way to 3/0003 3/7510 0004/5002

0005/7402
0006/7760

X simple program
0011/0002

1762, ... 7776 and

Fetching the next instruction (1006) causes another cache miss:
memory and checked

(ware General-PurposeC omputers 339



cache main memory From this poih
tag data 0000/7300 SPA; JMP), a,
0/0000 0/7300 0001/1006 occurs when 
1/0001 1/1006 0002/1011
2/0006 2/7760 0003/7510
3/0003 3/7510 0004/5002

0005/7402
0006/7760
0011/0 002

)

However, when this TAD instruction is executed, the cache already has the data 7760
required by the processor. This is known as a cache hit. The second memory access
during this instruction is fast because it is a cache hit.

Fetching and executing the next instruction (1011) causes two cache misses:
In total, there.
value of A, th

cache main memory increase for v/
tag data 0000/7300

0/0000 0/7300 0001/1006 The good perf
1/0011 1/0002 0002/1011 heavily on hot
2/0002 2/1011 0003/7510 at address 000'
3/0003 3/7510 0004/5002 miss rate and,

0005/7402 program with
0006/7760

rate becomes
0011/0002

program with
rate is 94% (tv

Fetching and executing the SPA instruction (7510) causes a cache hit, and so this memory and 0011 cann
access is fast. Since the accumulator is negative, the skip does not occur, and the pro-
cessor needs to fetch the next (5002) instruction. This causes another cache miss:

8.5.2 Men
Regardless of
memory hierar

cache main memory we expect the
tag data 0000/7300

0/0004 will take additi
0/5002 0001/1006

1/0011 1/0002 0002/1011 assumes that e
2/0002 2/1011 0003/7510 memory hierar
3/0003 3/7510 0004/5002

0005/7402
0006/7760
0011/0002

18T he number of n
times the loop execs
19 The number of h

340 Verilog Digital Computer Design: Algorithms into Hardware



From this point on, as long as the program stays inside this three-instruction loop (TAD;
SPA; JMP), all of the instruction and data accesses are cache hits. The final cache miss
occurs when the program halts:

cache main memory
tag data 0000/7300
0/0004 0/5002 0001/1006
1/0005 1/7402 0002/1011
2/0002 2/1011 

has 0003/7510
the data 7760 3/0003 3/7510 0004/5002

id memory access 0005/7402
0006/7760

e misses: 0011/0002

In total, there are six cache misses'8 and 29-cache hits in this example. With the given
value of A, this is a 17% miss rate and an 83% hit rate, although the hit rate would
increase for values of A that are more negative.19

The good performance that the above program exhibits using this little cache depends
heavily on how the instructions and data are arranged. For example, if B were located
at address 0007, there would be 20 cache misses and only 15 cache hits, which is a 57%
miss rate and 43% hit rate. A larger cache size will often improve performance. If 
program the

with B at address 0007 runs on a machine with a cache size of eight, the hit
rate becomes 100% because this entire tiny program can reside in the cache. If the
program with B at address 0011 runs on a machine with a cache size of eight, the 
rate hit

is 94% (two misses) because the program cannot 
nd so all 

this fit in 
memory the cache at once (0001

and 0011 cannot reside in a direct mapped cache of 
wccur, size eight 

and the at 
pro- the same time).

er cache miss:
8.5.2 Memory handshaking
Regardless of whether a machine uses cache memory, virtual memory or both in its
memory hierarchy, one thing is clear: the access time is non-deterministic. Although
we expect the majority of memory accesses to occur in a single cycle, some accesses
will take additional cycles. The ASM chart for fetch/execute given in section 8.3.2.4.2
assumes that every memory access can occur in one cycle, which is not the case 
memory for a

hierarchy. A more sophisticated ASM is required that waits for the memory

18 The number of misses is the same in this program regardless of the value of A and therefore of how 
times many

the loop executes.
9The number of hits depends on how many times the loop executes.

General-PurposeC omputers 341



-

hierarchy to provide the requested instruction or data. To coordinate the operation of As explained
the memory hierarchy with the CPU requires using what is called a partialh andshak- such as TAD
ing protocol. cycle. In state
In the partial handshake protocol, there is an extra command signal, memreq, that the address of the
CPU sends to the memory when the CPU requests a particular word of the memory rising edge o
hierarchy. Unlike the simple memory described in section 8.2.2.3.1, the memory hier- F4A when th
archy might ignore the address bus when memreq is not asserted. Only when memreq scheduled to I
is asserted does the memory take notice of the address bus and respond accordingly. memory bus.

give the corre
In the partial handshake protocol, there is also an extra status signal, the memory read
acknowledge (memrack), that the memory sends back to the CPU to acknowledge In contrast, tt
that the memory hierarchy has obtained the word desired by the CPU. The CPU must speed of eaci
continue to assert its memory request until the memory responds with its acknowledge F4WAIT, and
signal. If the desired word is already in the cache, the memory hierarchy will instantly 20 sion involving
assert memrack. Having the memory hierarchy assert memrack within the same cycle access is fast,
that the CPU first asserts memreq means that only one cycle is spent on the memory left ASM are
access. If the desired word is not already in the cache, the memory hierarchy will wait the memory a
however long is necessary before asserting memrack. The ASM for the CPU must the memory I
stay in a wait state prior to when the memory hierarchy asserts the memrack status provides on m
signal. For example, consider the portion of the ASM from section 8.3.2.4.2 (consist- A similar han
ing of states F3B, F4A and F4B) shown on the left: hierarchy resp

Figure 8-16

Figure8 -15. ASMs without and with memory read handshaking.

20 Ignoring a trivial aount of propagation delay, as was done in earlier portions of this chapter.

342 Verilog Digital Computer Design: Algorithms into Hardware



ieo peration of As explained in section 8.3.1.5, these states fetch the operand for PDP-8 instructions,
lial handshak- such as TAD, on the assumption that every memory access can occur in one clock

cycle. In state F3B, the memory address register is scheduled to change to the effective
address of the instruction. 

mreq, As 
that the with all -, the change does not take effect until the next

rising edge of the clock. Assuming 
of the memory the instruction is a TAD, the CPU will be in state

F4A when that next rising edge occurs. 
memory In state 

hier- F4A, the memory buffer register is
scheduled to be loaded with the corresponding 

when memreq contents of memory that comes via the
memory bus. In this ASM, 

I accordingly. there is never more than one clock cycle for the memory to
give the correct data to the CPU.

e memory read
In contrast, 

o acknowledge the more complicated ASM on the right uses handshaking to adapt to the
speed of 

The each 
CPU particular 

must memory access. This requires introducing an extra state,
F4WAIT, and asserting memreq 

ts acknowledge in both states F4A and F4WAIT. Also, there is a deci-
sion involving memrack 

will instantly20 that occurs in both states F4A and F4WAIT. If the memory
access is fast, 

the same the CPU 
cycle never goes to state F4WAIT, and so the state transitions of the

left ASM are identical to the 
on the state 

memory transitions of the right ASM. On the other hand, if
the memory access 

rarchy will is slow, 
wait the machine goes to state F4WAIT where it will loop until

the memory hierarchy 
the CPU asserts 

must memrack. Note the data that the memory hierarchy
provides on membus 

emrack must 
status be valid before the hierarchy can assert memrack.

1.2.4.2 (consist- A similar handshaking approach is required for memory writes, except the memory
hierarchy responds back with a memory write acknowledge (memwack):

- membus
<

F4WAIT
nreq

Figure 8-16. ASM with memory write handshaking.

chapter.

vare General-PurposeC omputers 343



8.5.3 Architecture for a simple memory hierarchy cache slower 
The memory hierarchy is a separate actor from the CPU, and so the memory hierarchy caches are evc
needs its own controller and architecture. Assuming we keep the names the same as in but have distit
the earlier sections of this chapter, the memory hierarchy and the CPU communicate
address and data using mabus, mbbus and membus. More importantly, the CPU tells In contrast, wt
the memory hierarchy what it needs done to memory with write and memreq, and one can be des
the memory responds back when the requested operation is complete using either the equivalent
memrack or memwack. Both the CPU and the memory hierarchy are fed the system when the CP
clock.2' Here is a diagram that illustrates this interconnection: hierarchy will

cache is guara

We are going t
CpU peripheral to the mixed st

This architectu
mabus, tag memory. TI

a
membus by a known nu

mbbus d MEMORY in section 8.4.

memreq T HIERARCHY mbbus and its
memory of the

write I hierarchy rece
memrack than from the (
memwack connect directl

the data input (

The cache cor
Figure 8-17. Connection of processor to memory hierarchy. accessed withi

cache tag mem
We are going to design a memory hierarchy consisting of a main memory and a cache. We will use '(
There are many choices available to the designer of a cache. Although the cache could cache, which
be either set associative or direct mapped, we will use the direct mapped technique (cacheconi

since it is easier to understand. Also, there is a choice about how the cache treats writes: that goes ba
either a write-through cache or a write-back cache . (cache-tag

input of the coi
A write-back cache waits until it is necessary to write data back into the main memory. comparator is t
This has the advantage that operations on values such as loop counters do not have to
wait for the slower access time of the main memory. The problem with the write-back
approach is that the main memory and the cache can become inconsistent with each
other. Because cache consistency is not guaranteed at all times with the write-back
approach, a request from the CPU for a memory read may also cause a write to the 22 Whether write-tl

main memory (that restores cache consistency). This makes a write-back cache consid- the particular progi
23 

erably harder A write-back cat
to design than a write-through cache. It may even make the write-back 24 We are also avoid

pure behavioral At
notation because tf

21 This is a requirement of the partial handshake protocol. 25 Many implement

344 Verilog Digital Computer Design: Algorithms into Hardware

-



cache slower than a comparable write-through cache.22 The complexity of write-back
mory hierarchy caches are even more pronounced when multiple CPUs share the same main memory
st he same as in but have distinct caches.

J communicate
y, the CPU tells In contrast, write-through caches are simple enough23 that the design of an elementary
Jmemreq, and one can be described using only the mixed Moore ASM notation (section 2.3) or using
ate using either the equivalent Verilog (section 4.2). The essential idea of a write-through cache is that
fed the system when the CPU requests the memory hierarchy to do a write operation, the memory

hierarchy will store the data into both the main memory and the cache. A write-through
cache is guaranteed to be consistent with the main memory.
We are going to skip over the pure behavioral stage of the design, and proceed straight
to the mixed stage so that we may focus on the architecture of the memory hierarchy. 24

This architecture consists of the main memory, the cache content memory and the cache
tag memory. The main memory is asynchronous with a deterministic access time bounded
by a known number of clock cycles. Like the one and only memory shown previously
in section 8.4.7, the main memory of the hierarchy has its data input connected to
mbbus and its address input connected to mabus. The distinctions between the main
memory of the hierarchy and the memory of section 8.4.7 are the main memory of the
hierarchy receives its mainwrite signal from the internal cache controller (rather
than from the CPU) and the data output of the main memory of the hierarchy does not
connect directly to the CPU. Instead, the data output of the main memory connects to
the data input of the cache content memory.
The cache content and cache tag memories are synchronous memories that can be
accessed within one clock cycle. The address inputs to both the cache content and
cache tag memories come from the low order j bits of the CPU's memory address bus.

try and a cache. We will use 'CACHESIZE to indicate the number of words that can reside in the
the cache could cache, which is the same as 2. The data output of the cache content register
.pped technique (cachecontent[mabus % CACHE_SIZE] ) is connected to the memory bus
he treats writes: that goes back to the CPU. The data output of the cache tag register

(cache-tag[mabus % CACHE SIZE] ) is connected to a comparator. The other
input of the comparator is the memory address bus from the CPU.25 The output of the

main memory. comparator is the memory read acknowledge signal (memrack). This signal is sent to
s do not have to
i the write-back
istent with each
the write-back

Bea write to the 22Whether write-through or write-back is faster depends on several factors, including the pattern in which
k cache consid- the particular program accesses memory.

23 A write-back 
the write-back cache requires the Mealy notation of chapter 5.

2 4We are also avoiding the pure behavioral stage now because, even on this simple write-through cache, the
pure behavioral ASM requires the Mealy notation of chapter 5. The mixed ASM does not need the Mealy
notation because the memrack signal is generated by the architecture, and not the controller.
2 5 Many implementations would only use the high order a- j bits, but for simplicity, we use all a bits.

ware General-PurposeC omputers 345



both the CPU (where it controls the duration of the wait loops described in section
8.5.2) and to the cache controller. The cache controller generates the ldcont and
ldtag commands for the cache content and cache tag memories. When asserted, these
commands indicate that the cache content and cache tag memories will be loaded with
new information at the next rising edge of the clock.

The cache controller also generates the memory write acknowledge (memwack) signal
after the main memory, the cache tag memory and the cache content memory have
been updated as a result of a write signal from the CPU. The following shows the
architecture for the memory hierarchy (using the write-through direct mapped cache
described above) and the corresponding mixed Moore ASM for the cache controller:

MEMORY HIERARCHY
mabus a ,- - - addr

1 a
I ~MAIN

l MEMORY
mbbus din dout

dl d I
i | mainwrite mainbus I

l cachecontent
I + addr dout | r *membusFigure 8-1

tagbus l The ASM stay
l 7 addr dout / _+  I 0 memrack

lae ta a == possibilities 
l ft

cacheag cmp I request is for 

I a n C : cache or the re
Idtag 72 l request from 

a The first possi
this case, mem

mainwrite I Because the m
memreq CACHE Idcont tor, both the A
write CONTROLLER Idtag | o memwack delay states. T

L… - - - - - - - - - - - - - - - - - - - - - - - - - . and the ASM :
that same state

Figure 8-18. Memory hierarchy architecture with direct mapped write-through
cache.

346 Verilog Digital Computer Design: Algorithms into Hardware



escribed in section
s the ldcont and
/hen asserted, these
will be loaded with

(memwack) signal
itent memory have
Allowing shows the
irect mapped cache
e cache controller:

-F--L /-membus
Figure 8-19. ASMfor direct mapped write-through cache memory controller

-+ memrack The ASM stays in state CACHEIDLE unless a memory request occurs. There are three
possibilities for a memory request. Two of these possibilities are when the memory
request is for a read operation (i.e., write is zero): either the requested data is in the
cache or the requested data is not in the cache. The third possibility is a memory write
request from the CPU (regardless of whether it is in the cache).
The first possibility is when the data being read by the CPU is already in the cache. In
this case, memrack will be true during the first clock cycle that memreq is asserted.
Because the mrnemrack signal comes straight from the combinational logic compara-

e c tor, both the ASM for the CPU and the ASM for the cache controller proceed without
_+ memwack delay states. The ASM for the CPU makes a transition such as from state F4A to F4B,

and the ASM for the cache controller makes a transition from CACHEIDLE back to
that same state.

d write-through

irdware General-PurposeC omputers 347



.

The second possibility is when the data being read by the CPU is not in the cache CPU
during the first clock cycle that memreq is asserted. During this clock cycle memrack state
will be false. It will stay false for as long as the output of the cache tag memory does
not equal the memory address bus from the CPU. In a case like this, when memrack is
false, the ASM for the CPU makes a transition such as from state F4A to F4WAIT, and
the ASM for the cache controller makes a transition from CACHEIDLE to state RI.
The ASM has an appropriate number of empty delay states (not shown) to allow for the
read access time of the asynchronous main memory. Then, in state RL, the cache con- F1
troller issues the ldcont command. This causes the cache content memory to be F2
loaded at the next rising edge of the clock with the data obtained from the slow main F3A
memory. Also in state RL, the cache controller issues the ldtag command. This causes F3B
the cache tag memory to be loaded at the next rising edge of the clock with the address EOCLACLL

being provided by the CPU. Because of this change to the tag memory, when the cache F1

controller proceeds to the empty state, RA, the architecture will for the first time assert F2

memrack. The one empty state, RA, is all that is necessary to allow the CPU to make F3A I

a transition such as from state F4WAIT to F4B. F3B
Of course, the cache controller makes I

F4A
a transition during that I

same clock cycle from state RA back to CACHEIDLE.
F4B

The third possibility is when the CPU makes a memory write request. The ASM for the EOTAD

cache controller proceeds from state CACHEIDLE to state WI :PI
during the same clock _ 

cycle that the ASM for the CPU proceeds from a state such as E l ADCA to E 1D CAWAIT.
The ASM has an appropriate number of delay states (not shown) that each assert As execution 
mainwri te. This allows for the write access time of the asynchronous main memory.2 6

memory contrc
Finally, in state WLA, the cache controller asserts ldcont, ldtag and memwack. (shown in italic
The assertion of ldcont and ldtag is not necessary for this write operation but is
required for any future read operations to be fast. Therefore, a separate empty state for
write acknowledgement is not F2 

necessary here as 0
was the case for read acknowledgement.

F3A 0
Because memwack is asserted in state WLA, at the same time that the ASM for the F3WAIT G
cache controller makes a transition from state WLA to state CACHEIDLE, the ASM F3WAIT 0
for the CPU makes a transition such as from state ElDCAWAIT to ElBDCA. F3WAIT 0

The following example is a program that adds F3WAIT 
two numbers together 0

and stores the sum
F3WAIT 0

in memory. Both state machines (CPU and memory controllers) cooperate to fetch F3B 0
instructions and data and to store results back in memory. This example illustrates each
of the three possibilities explained above. The first two instructions, as well as the first Fetching the op
word of data fetched, are already in the cache. In such an instance (shown in bold) the instruction caus
cache state remains in CACHEIDLE and the CPU does not need a wait state. This
situation is signaled by memreq and memrack both being one during the same clock
cycle.

26 The read and write access times need not be the same.

348 Verilog Digital Computer Design: Algorithms into Hardware

U



t in the cache CPU CACHE m m m
'cle memrack state ma mb PC ir h ac state e e e

memory does
nmemrackis r r w
i F4WAIT, and e a a

E to state R1. q c c
k 

:o allow for the k

the cache con- F1 0002 1006 0000 xxxx 0 xxxx CACHEIDLE 0 0 0
memory to be F2 0000 1006 0000 xxxx 0 xxxx CACHEIDLE 0 1 0
the slow main F3A 0000 1006 0001 xxxx 0 xxxx CACHEIDLE 1 1 0

nd. This causes F3B 0000 1006 0001 7300 0 xxxx CACHEIDLE 0 1 0

rith the address EOCLACLL 0100 1006 0001 7300 0 xxxx CACHEIDLE 0 0 0

xhen the cache F1 0100 1006 0001 7300 0 0000 CACHEIDLE 0 0 0
F2 

rirst time 0001 
assert 1006 0001 7300 0 0000 CACHEIDLE 0 1 0

F3A 0001 1006 0002 7300 0 
eC PU 0000 

to make CACHEIDLE 1 1 0
F3B 0001 1006 0002 1006 0 0000 CACHEIDLE 0 1 0

)ntroller makes F4A 0006 1006 0002 1006 0 0000 CACHEIDLE 1 1 0
EIDLE. F4B 0006 1000 0002 1006 0 0000 CACHEIDLE 0 1 0

EOTAD 
he ASM for 0006 

the 1000 0002 1006 0 0000 CACHEIDLE 0 1 0
F1 0006 1000 0002 1006 0 1000 CACHEIDLE 

the same clock 0 1 0

ElDCAWAIT.
hat each assert As execution proceeds, the next instruction causes a cache miss, which causes the
main memory.26 memory controller to leave CACHEIDLE and causes the CPU to enter a wait state
and memwack. (shown in italic):
operation but is
empty state for

F2 0002 1000 0002 1006 0 1000 CACHEIDLE 0 0 0
nowledgement. F3A 0002 1000 0003 1006 0 1000 CACHEIDLE 1 0 0
ie ASM for the F3WAIT 0002 1000 0003 1000 0 1000 R1 1 0 0
[DLE, the ASM F3WAIT 0002 1000 0003 1000 0 1000 R2 1 0 0
BDCA. F3WAIT 0002 1000 0003 1000 0 1000 R3 1 0 0

F3WAIT 0002 1000 0003 1000 0 1000 RL 1 0 0
d stores the sum F3WAIT 0002 1000 0003 1000 0 1000 RA 1 1 0
)perate to fetch F3B 0002 1000 0003 1007 0 1000 CACHEIDLE 0 1 0
illustrates each
well as the first Fetching the operand of this instruction causes a cache hit, but fetching the following
)wn in bold) the instruction causes a cache miss:
wait state. This
the same clock

vare General-PurposeC omputers 349



F4A 0007 1000 0003 1007 0 1000 CACHEIDLE 1 1 0 8.5.4 Effi
P4B 0007 2000 0003 1007 0 1000 CACHEIDLE 0 1 0 There are ma
EOTAD 0007 2000 0003 1007 0 1000 CACHEIDLE 0 1 0

cache. It is ol
F1 0007 2000 0003 1007 0 3000 CACHEIDLE 0 1 0
F2 0003 2000 0003 1007 0 3000 CACHEIDLE 0 0 0 speed of the s'
F3A 0003 2000 0004 1007 0 3000 CACHEIDLE 1 0 0 lation is essen
F3WAIT 0003 2000 0004 2000 0 3000 R1 1 0 0 will have on t
F3WAIT 0003 2000 0004 2000 0 3000 R2 1 0 0 to observe th,
F3WAIT 0003 2000 0004 2000 0 3000 R3 1 0 0 become popul
F3WAIT 0003 2000 0004 2000 0 3000 RL 1 0 0 their machine
F3WAIT 0003 2000 0004 2000 0 3000 RA 1 1 0
F3B 0003 2000 0004 3005 0 3000 CACHEIDLE 0 1 0 The ASMs fo

were translate
Because this example uses a write-through cache, executing the DCA instruction causes tion 8.3.2.5.3)
the memory controller to leave state CACHEIDLE and causes the CPU to enter a wait are 53 read ac(
state: any cache mi,

ratios for read
EODCA 0005 2000 0004 3005 0 3000 CACHEIDLE 0 0 0
ElADCA 0005 3000 0004 3005 0 3000 CACHEIDLE 1 0 0
ElDCAWAIT 0005 3000 0004 3005 0 3000 W1 1 0 0
ElDCAWAIT 0005 3000 0004 3005 0 3000 W2 1 0 0 ca
ElDCAWAIT 0005 3000 0004 3005 0 3000 W3 1 0 0 8
ElDCAWAIT 0005 3000 0004 3005 0 3000 W4 1 0 0 16
ElDCAWAIT 0005 3000 0004 3005 0 3000 WLA 1 0 1 32
ElBDCA 0005 3000 0004 3005 0 3000 CACHEIDLE 0 1 0
F1 0005 3000 0004 3005 0 0000 CACHEIDLE 0 1 0

8.6 Con
Fetching the final instruction causes another cache miss:

General-purpc
lows the hard
in memory. M

F2 0004 3000 0004 3005 0 0000 CACHEIDLE 0 0 0
F3A 0004 3000 0005 3005 0 0000 CACHEIDLE 1 0 0 useful, and vai
F3WAIT 0004 3000 0005 7300 0 0000 R1 1 0 0 half century. S
F3WAIT 0004 3000 0005 7300 0 0000 R2 1 0 0 hierarchies thz
F3WAIT 0004 3000 0005 7300 0 0000 R3 1 0 0 From an abstn
F3WAIT 0004 3000 0005 7300 0 0000 RL 1 0 0 arrays of binar
F3WAIT 0004 3000 0005 7300 0 0000 RA 1 1 0 erate in paralle
F3B 0004 3000 0005 7402 0 0000 CACHEIDLE 0 1 0 handshaking b
EOHLT 0002 3000 0005 7402 0 0000 CACHEIDLE 0 1 0 that of the met

The design pri
hardware. The
behavioral anc
presented, and
were benchma

350 Verilog Digital Computer Design: Algorithms into Hardware



1 10 8.5.4 Effect of cache size on the childish division program
0 10 There are many alternatives that a designer must choose from when implementing a
0 10 cache. It is often hard to predict manually what effect these 
0 10 choices will have on the

speed of the 
0 system 

00 when it is running a particular program. This is a case where simu-
1 00 lation is essential to allow the designer to estimate the effects different design decisions
1 00 will have on the overall performance of the system. For example, one could simulate
1 00 to observe the effect of cache size. One of the reasons HDLs such as Verilog have
1 00 become popular is because designers need to conduct such simulations before building
1 00 their machines.
1 10
0 10 The ASMs for the PDP-8 (section 8.3.2.4.2) and the cache controller (section 8.5.3)

were translated into Verilog code (not shown), and the childish division program (sec-
iinsstrtruuccttiion causesd tion 8.3.2.5.3) was run for x=14 and y=7 with various cache sizes. In each case, there
ULJt o  enter a wait are 53 read accesses and seven write accesses. In this simulation, all write accesses and

any cache misses cause the CPU to wait for five clock cycles. Here are hit and miss
ratios for reads in this simulation:

0 0 0 0
1  00 0
1  00 0
1  00 0 cache size clocks #miss miss ratio hit ratio
1  00 0 8 541 5 1 96% 4%
1  00 0 6 396 22 58% 41%
1  0 1 1 32 296 2 4% 96%
0  10 0
0 10 0

8.6 Conclusion
General-purpose computers implement the fetch/execute algorithm, which in turn al-
lows the hardware to interpret other algorithms coded in machine language that is stored
in memory. Memory is 

 the 
0 critical component for 

0 00 a general-purpose computer to be
useful, and various 

1  00 0 technologies have been used to implement memory during the last
1  00 0 half century. Static memories are fast, but dynamic memories are cheaper. Memory
1  00 0 hierarchies that include a cache offer the best compromise between speed and cost.
1  00 0 From an abstract behavioral viewpoint, all memory technologies can be thought of as
1  00 0 arrays of binary words, but in reality, memory devices are independent actors that op-
1 1 0 0 erate in parallel to the CPU. When the access time is non-deterministic, there must be
0 10 0 handshaking between the memory and the CPU so that the CPU can adjust its speed to
0 10 0 that of the memory.

The design process for a general-purpose CPU is similar to that of special-purpose
hardware. The example used in this chapter of the PDP-8 was implemented at the
behavioral and mixed stages of the design process. A methodical architecture was
presented, and a variation using a direct mapped cache was considered. These designs
were benchmarked using the childish division program to show that software running

wvare General-PurposeC omputers 351



r-

on the CPU designed in this chapter is slower and less efficient than when the childish 8-3. Revise the
division algorithm is implemented in special-purpose hardware. The next chapter will
look at how this performance discrepancy can be diminished. 8-4. Revise the

appendix B.

8-5. Revise the

8.7 1 urther reading appendix B.

BELL, C. GORDON and A. NEWELL, Computer 8-6. Revise 
Structucz..: the

Readings and Examples,
McGraw-Hill, New York, NY, 1971. Chapter 5 is the defi tive description of the PDP- and associated
8 from the man who also invented the first HDL (a language known as ISP). 8-7. Revise the
BELL, C. GORDON, J. C. MUDGE and JOHN E. MCNAMARA, CoM puter Engineering: A 8-8. Revise the
DEC View of HardwareS ystems Design, Digital Press, Bedford, MA, 1978. Chapter 8.

8-9. Suppose a,
LAvINGTON, S., Early British Computers: The Stor of Vintage Computers and the People addresses 0004
Who Built Them, Digital Press/Manchester University Press, Bedford, MA, 1980. De- gram:
scribes the work of Kilburn, Williams, Turing, Wilkes and other British pioneers.
The Origins of Digital Computers: Selected apers, 2nd ed., Edited by B. Randell,
Springer-Verlan, Berlin, 1982. Reprints of original papers by computer pioneers.
PATTERSON, DAVID A. and JOHN L. HENNESSY, Computer Organization and Design: The
Hardware/Software Interface, Morgan Kaufmann, San Mateo, CA, 1994. Chapter 7
explains virtual memory and multi-way set associative caches.

PROSSER, FRANKLIN P. and DAVID E. WINKEL, The Art of DigitalD esign: An Introduction a) How man)
to Top down Design, 2nd ed., Prentice Hall PTR, Englewood Cliffs, NJ, 1987. Chapter b) How man)
7 describes an elegant central ALU architecture for the complete PDP-8 instruction set. c) What will
SLATER, ROBERT, Portraitsi n Silicon, MIT Press, Cambridge, MA, 1987. Gives biogra- 8-10. Translate 
phies of several important pioneers including Babbage, Zuse, Atanasoff, Turing, Aiken, and runs the chi
Eckert, Mauchly, von Neumann, Forrester, Bell and Noyce.

8-11. Translate t
WAYNER, P., "Smart Memory," BYTE, June 1995, p. 190. 8-13 into Veriloq
WOLF, WAYNE, Modern VLSI Design: A Systems Approach, 2nd ed., Prentice Hall PTR, 8-12. Modify prD
Englewood Cliffs, NJ, 2nd ed., 1994, p. 356-370. Shows how to layout a VLSI chip Assume it takes
that imple.nents a PDP-8 architecture. Verilog test cod(

8.8 Exercises
8-1. Revise the ASM of section 8.3.2.1 to include the ISZ instruction described in
appendix B.

8-2. Revise the architecture of section 8.4.7 to correspond to problem 8-1.

352 Verilog Digital Computer Design: Algorithms into Hardware

A



,vhen the childish 8-3. Revise the mixed ASM of 8.4.6 to correspond to problem 8-2.
next chapter will 8-4. Revise the ASM of section 8.3.2.1 to include the JMS instruction described in

appendix B.

8-5. Revise the ASM of problem 8-4 to include all the addressing modes described in
appendix B.

,s and 8-6. 
Examples, Revise the ASM of problem 8-5 to include the interrupt instructions ION and IOF

ption and 
of the associated 

PDP- hardware described in appendix B.
as ISP). 8-7. Revise the architecture of section 8.4.7 to correspond to problem 8-6.
r Engineering: A 8-8. Revise the mixed ASM of 8.4.6 to correspond to problem 8-7.

,1978. Chapter 8.
8-9. Suppose a direct mapped write-through cache of size four contains the contents of

frs and the People addresses 0004, 0001, 0002 and 0003 when starting to run the following PDP-8 pro-
1, MA, 1980. De- gram:
ish pioneers.

,d by B. Randell,
ter pioneers. 0000/7200

0001/1004
and Design: The 0002/3006
1994. Chapter 7 0003/7402

0004/1000

l: An Introduction a) How many cache read hits occur?
{J, 1987. Chapter b) How many cache read misses occur?
'-8 instruction set. c) What will be in the cache-tag and cachecontents when the program halts?
87. Gives biogra- 8-10. Translate the ASM of figure 8-8 into behavioral Verilog. Use test code that loads
ff, Turing, Aiken, and runs the childish division program of section 8.3.2.5.3 using the sr.

8-11. Translate the architecture of figure 8-12 together with the mixed ASM of figure
8-13 into Verilog. Use the same test code as problem 8-10.

'rentice Hall PTR, 8-12. Modify problem 8-11 to include the direct mapped cache designed in section 8.5.
yout a VLSI chip Assume it takes five clock cycles to read or write to the main memory. Use similar

Verilog test code.

:tion described in

]ware General-PurposeC omputers 353



_- ppp---

90 PIPELINED GENERAL- algorithm rur
same softwar
the efficiency

PURPOSE PROCESSOR hardware rat}

The fetch/execute algorithm described in section 8.3.1.5 typically requires five clock
cycles to execute each instruction. In the terminology of chapter 6, that ASM uses a
multi-cycle approach. The clock is fast because its frequency is determined by the INIT K
maximum propagation delay of a single combinational unit, most likely the ALU. On
the other hand, the effective speed is approximately one-fifth of what could be achieved
if pipelining were used instead. F1 [
In order to pipeline an algorithm that makes decisions (as fetch/execute must do in
order to decode instructions), we need to use a Mealy ASM with ovals. (See chapter 5
for details about Mealy ASMs.) A Mealy approach is required because the pipeline will
process different stages of independent instructions at the same time. Later stages de-
pend upon the completion within one clock cycle of the earlier stages. In a Mealy
ASM, a conditional computation begins instantly and is ready one clock cycle after the
decision. In a Moore ASM, a conditional computation cannot begin until one clock
cycle after the decision, and the result is not ready until two clock cycles after the irl
decision. This would be too late for a pipelined fetch/execute, and so a Mealy ASM is ir2
required to describe the overall behavior of a pipelined general-purpose computer. Mt

The existence of the NOP instruction (7000) is important to the design of the pipelined
fetch/execute. By putting a NOP in the pipeline when none existed in the original pro-
gram, it will be possible to cope with several special situations. The essential goal of
the pipelined machine is to end up with the same answer in memory and the accumula-
tor as would be obtained from a non-pipelined version. Since a NOP leaves both the
accumulator and memory alone, NOP provides for a safe way to stall later stages of the
pipeline while earlier stages of the pipeline are being filled. This is quite advantageous,
since it can eliminate the need for "FILL" and "FLUSH" states of the kind described in
chapter 6.

9.1 First attempt to pipeline
The following is a somewhat flawed attempt to design a pipelined ASM that is equiva-
lent to the multi-cycle ASM of 8.3.1.5. This ASM is for a three-stage pipeline consist-
ing of instruction fetch, operand fetch and instruction execution. Ideally, in each clock
cycle independent instructions are being fetched, having an operand fetched and being Figure 9-1.
executed. It is important to understand that what is being pipelined is the fetch/execute
algorithm itself and not the software algorithm implemented by the machine language
program (which may not even be possible to pipeline). The efficiency of a software

Here is a portion

354 Verilog Digital Computer Design: Algorithms into Hardware



algorithm running on a pipelined general-purpose computer will be better than tthe
LL- same software running on a multi-cycle general-purpose computer, but not as good  as
* V-A- 4 the the efficiency of a special-purpose computer that implements the t

A1\ same algorithmn  iin
ha^rd ware rather than in software.

pluuiirreess  ffiivvee  cclloocckk
hat ASM uses a IN il
termined by the

Aly the ALU. On
)uld be achieved

cute must do in
s. (See chapter 5
the pipeline will
Later stages de-
ges. In a Mealy
-k cycle after the
i until one clock
cycles after the
a Mealy ASM is
)se computer.

i of the pipelined
the original pro-
essential goal of
nd the accumula-
P leaves both the
later stages of the
[te advantageous,
kind described in

;M that is equiva-
pipeline consist-

tily, in each clock
fetched and being Figure
the fetch/execute
nachine language
[wiccyy  ooff  aa  ssooffttwaarree Heeia fl Here is a portion of the implicit style Verilog corresponding to this ASM:

Ware PipelinedG eneral-PurposeP rocessor 355



forever State INIT is
begin hal t equal to
@(posedge sysclk) enter-new-state('Fl); IDLE, where il

if (halt) unconditionall

else In state IDLE,
begin was not presen
pc <= (posedge sysclk) pc + 1; ized to NOPs. i
irl <= (posedge sysclk) m[pc]; fill with actual
ir2 <= (posedge sysclk) irl; By putting NO]
mb2 <= a(posedge sysclk) m[ea(irl)]; lessly while tht
if (ir2[11:9] == 1) "FILL" states c

ac <= (posedge sysclk) ac + mb2;
else if (ir2[11:9] == 3) When the mach
begin parallel:

m[ea(ir2)] <= (negedge sysclk) ac;
ac <= @(posedge sysclk) 0; a) The you

end ir --
else if (ir2 == 12'o7200) b) The opei

ac <= @(posedge sysclk) 0; moves d
else if (ir2 == 12'o7402) parallel)
halt <= @(posedge sysclk) 1; c) The olde

else if (ir2 == 12'o7000) 8.3.1.5 b
end

end The execution c
tains a TAD insi
operand fetched

In this ASM, the operations of states F2, F3A, F3B, F4A, F4B, EOCLA, EOTAD, EODCA, cumulator is scl
ElADCA, E1BDCA and EOHLT from the ASM of 8.3.1.5 have been merged into state that the accumu
F1 using the Mealy notation. The most noticeable change is that the set of registers
used is somewhat different than before. The memory address register has been elimi-
nated altogether so that three separate things can be done in parallel to memory during
the same clock cycle: an instruction can be fetched, an operand can be fetched and the 9.2 Exam
accumulator can be stored. A single memory address register would not allow all of The ASM of sec
these to happen in parallel. "correctly," we
The instruction register of section 8.3.1.5 is now replaced by two registers, same 

irl result 
and that I

ir2, so that the machine can distinguish the instructions as they travel through Since the 
the multi-,

pipeline. The memory buffer register is no longer used for writing to until 
the both 

memory, machi
and

instead is used only to hold an operand fetched from memory in kind 
the previous of machine

clock
cycle. The memory buffer register has been renamed as mb2, reminding instruction 

us that is 
it ind

is the
operand for the instruction (ir2) in the final stage of the pipeline. (This is the onl!

program is the o
section 8.3.1.6:

356 Verilog Digital Computer Design: Algorithms into Hardware



State INIT is identical to the one in the multi-cycle ASM. Since state INIT makes
halt equal to one, when state F 1 executes for the first time, the machine goes to state
IDLE, where it waits for cant to become true. Note that state Fl does not do anything
unconditionally, thus the program counter remains the way state INIT initialized it.
In state IDLE, halt becomes zero. There is an additional detail in state IDLE which
was not present in section 8.3.1.5. The instruction pipeline (irl and ir2) gets initial-
ized to NOPs. After cant becomes true, it will take two clock cycles for the pipeline to
fill with actual instructions from the program before the first instruction can execute.
By putting NOPs in iri and i r2, the machine can execute the imaginary NOPs harm-
lessly while the pipeline is filling with actual instructions. This eliminates the need for
"FILL" states of the kind discussed in chapter 6.
When the machine is not halted in state Fl, there are three separate things that occur in
parallel:

a) The youngest instruction is fetched into irl (pc pc + 1 and
ir - m [pc] occur in parallel),

b) The operand for the middle aged instruction is fetched as that instruction I
moves down the pipeline (ir2 - i r andmb2 <- m[ea(irl) I occur in
parallel)

c) The oldest instruction is decoded and executed (decisions similar to section
8.3.1.5 but involving ir2)

The execution of each instruction must be described in a Mealy oval. When i r2 con-
tains a TAD instruction, the accumulator is scheduled to be updated by adding it to the
operand fetched in the previous stage. When i r2 contains a DCA instruction, the ac-

)TAD, EODCA, cumulator is scheduled to be stored (m[  ea (ir2) <- ac) in parallel to scheduling
merged into state that the accumulator be cleared.
set of registers
has been elimi-
memory during
fetched and the 9.2 Example of independent instructions
not allow all of The ASM of section 9.1 is only able to execute certain PDP-8 programs correctly. By

"correctly," we mean that the pipelined version produces (in fewer clock cycles) the
same result that the multi-cycle version (section 8.3.1.5) produces in more clock cycles.

isters, irl and Since the multi-cycle and the pipelined versions proceed differently, we have to wait
vel through the until both machines are halted to check if the results are the same. The limitation on 
he the

memory, and kind of machine language program that figure 9-1 will execute properly is that 
previous each

clock instruction is independent of the others. In other words, there are no data dependencies.
g us that it is the (This is the only kind of pipelining discussed in chapter 6.) An example of such a

program is the one given in appendix A, which is used with the multi-cycle ASM in
section 8.3.1.6:

Pipelined General-PurposeP rocessor 357



_. F11-

0100/7200 9.3 Dat;
0101/ 1106

What happens
0102/1107
0103/1110 practical thing
0104/ 3111 instructions. T
0105 /7402 program from
0106/0112
0107/0152
0110/0224 0100
0111/00 00 0101

0102
0103

Here is what happens when the first pipelined ASM executes this program: 0104
0105

INIT pc=xxxx irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=x 59 0106
F1 pc=0100 irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=1 159 0107
IDLE pc=0100 irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=1 259 0110
F1 pc=0100 irl=7000 mb2=xxxx ir2=7000 ac=xxxx h=0 359 0111
F1 pc=0101 irl=7200 mb2=xxxx ir2=7000 ac=xxxx h=0 459
F1 pc=0102 irl=1106 mb2=xxxx ir2=7200 ac=xxxx h=0 559 illustrates the r
F1 pc=0103 irl=1107 mb2=0112 ir2=1106 ac=0000 h=0 659
F1 pc=0104 irl=11l0 mb2=0152 ir2=1107 dent. In this pr

ac=0112 h=0 759
F1 pc=0105 irl=3111 mb2=0224 ir2=1110 ac=0264 h=0 859 This is followe
F1 pc=0106 irl=7402 mb2=0000 ir2=3111 ac=0510 h=0 959 is dependent oi
F1 pc=0107 irl=0112 mb2=xxxx ir2=7402 ac=0000 h=0 1059 produces:
F1 pc=0110 irl=0152 mb2=xxxx ir2=0112 ac=0000 h=1 1159

INIT 
IDLE pc=:

pc=0110 irl=0152 mb2=xxxx ir2=0112 ac=0000 h=1 1259
F1 pc=

IDLE pc=0110 irl=7000 mb2=xxxx ir2=7000 ac=0000 h=0 1359
IDLE pc=1
F1 pc=1

In the above, bold shows how the first and third TAD instructions travel through the F1 pc=(

pipeline, and italics show how the CLA, the second TAD, and the DCA instructions F1 pC=(

travel through the pipeline. In the first clock cycle after leaving IDLE ($time 359), F1 pc=(

irl and ir2 contain NOPs, F1 
so nothing pc=z

happens to the accumulator. In the next clock F1 pc=(
cycle, irl contains the first instruction (7200), but ir2 still contains a NOP. Only in F1 pc=(
the third clock cycle after leaving IDLE ($ time 559) does an actual instruction from F1 pC=(
the program execute-in this case the accumulator is scheduled to be cleared. This F1 pC=(
action becomes visible at $time 659. At that same time the first TAD instruction is IDLE pc=(
ready to execute. In the previous clock cycle, the operand (0112) needed for this TAD IDLE pc=C
instruction was scheduled to be loaded into mb2. Therefore, at $ time 659 the ac -
ac + mb2 can be scheduled. The sum (0000+0112) becomes visible at $time 759. In the above, it
The remaining TAD instructions have filled the pipeline, so they can execute one per Everything look
clock cycle. This is possible because the operands (0152 available at $time 759 and contain the ope
0224 available at $ time 859) have also been fetched. At $ time 959, the correct sum Unfortunately, E
(0510) is stored into memory at address 0111. dress 0111 still 

358 Verilog Digital Computer Design: Algorithms into Hardware

i



9.3 Data dependencies
What happens if the instructions are not independent of each other? For software to do
practical things, often one instruction needs to depend on results computed by previous
instructions. This is known as a data dependency. For example, a slight variation of the
program from appendix A:

0100/7200
0101/1106
0102/1107
0103/3111 - this is different from appendix A

program: 0104/1111 <- this is also different
0105/ 74 02
0106/ 0112

K h=x 59
0107/0152

K h=1 159
0110/022 4

K h=1 259
0111/0000

x h=0 359
x h=0 459
x h=0 559 illustrates the problem that the above ASM has with instructions that are not indepen-
0 h=0 659 dent. In this program, instead of doing a third TAD at 0103, the DCA (3111) occurs.
2 h=0 759 This is followed by a TAD (1 111) from this same location. The TAD instruction at 0104
4 h=0 859 is dependent on the DCA instruction at 0103. Here is the 
0 h=0 959 wrong result that figure 9-1
0 h=0 1059 produces:
0 h=1 1159 INIT pc=xxxx irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=x 59
0 h=1 1259 F1 pc=0100 irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=1 159
0 h=0 1359 IDLE pc=0100 irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=1 259

F1 pc=0100 irl=7000 mb2=xxxx ir2=7000 ac=xxxx h=0 359

s travel through F1 
the pc=0101 irl=7200 mb2=xxxx ir2=7000 ac=xxxx h=0 459

F1 pc=0102 irl=1106 mb2=xxxx ir2=7200 
[e DCA ac=xxxx 

instructions h=0 559
F1 pc=0103 irl=1107 mb2=0112 ir2=1106 ac=0000 h=0 659

DLE ($time 359), F1 pc=0104 irl=3111 mb2=0152 ir2=1107 ac=0112 h=0 759
or. In the next clock F1 pc=0105 irl=1111 mb2=0000 ir2=3111 ac=0264 h=0 859
ains a NOP. Only in F1 pc=0106 irl=7402 mb2=0000 ir2=1111 ac=0000 h=0 959
ual instruction from F1 pc=0107 irl=0112 mb2=xxxx ir2=7402 ac=O00 h=0 1059
to be cleared. This F1 pc=0110 irl=0152 mb2=xxxx ir2=0112 ac=0000 h=1 1159
t TAD instruction is IDLE pc=0110 irl=0152 mb2=xxxx ir2=0112 ac=0000 h=1 1259

needed for this TAD IDLE pc=0110 irl=7000 mb2=xxxx ir2=7000 ac=0000 h=0 1359

:ime 659 the ac *-

;ible at $time 759. In the above, italics show how the instruction at 0104 travels through the pipeline.
can execute one per Everything looks fine until $ time 959. The mb2 register (shown in bold italics) should
e at $time 759 and contain the operand needed in the next clock cycle for the TAD (1111) instruction.
959, the correct sum Unfortunately, at $time 859 when mb2 was scheduled to be loaded, memory at ad-

dress 0111 still contains the zero put there originally. The DCA (3111) instruction that

ardware PipelinedG eneral-PurposeP rocessor 359



I
is going to put the correct value (0264) into memory has not yet finished executing. By
$time 1059, this error in the accumulator (also shown in bold italics) becomes obvi-
ous. The accumulator is supposed to contain 0264, but instead it contains 0000.

9.4 Data forwarding
The problem illustrated in the last section is known as data dependency. Data depen-
dency means that the machine needs an operand that has not yet been stored in memory
because a previously fetched instruction has not yet finished executing. To overcome
this data dependency, we can introduce the idea of dataf orwarding into the following
improved version of the pipelined ASM. This ASM is nearly identical to the earlier
one, except how mb2 is computed depends on what is in the pipeline. Under most
situations, mb2 comes from memory as it did earlier (mb2 - m [ea (irl) ). In one
special situation, the current value of the accumulator is "forwarded" to the mb2 regis-
ter. This situation occurs when the oldest instruction (ir2, the one currently execut-
ing) is a DCA and the effective address of that instruction is the same as the effective X
address of the instruction (ir) that will execute in the next clock cycle. The ASM in
figure 9-2 uses data forwarding. ,
The following shows in bold how the Verilog must be changed to implement the data
forwarding given in the ASM:

if (halt)

else
begin

pc <= (posedge sysclk) pc + 1;
irl <= @(posedge sysclk) mpc];
ir2 <= (posedge sysclk) irl;
if ((ir2[ll:9] == 3)&&(ea(irl)==ea(ir2)))

nib2 <= (posedge sysclk) ac;
else

mb2 <= @(posedge sysclk) m[ea(irl)];

The following shows how data forwarding solves this problem:

Figure 9-2.

360 Verilog Digital Computer Design: Algorithms into Hardware



Fr

shed executing. By
lics) becomes obvi-
)ntains 0000.

Jency. Data depen-
n stored in memory
uting. To overcome
¢ into the following
ntical to the earlier
peline. Under most
~a (irl) ] ). In one
d"t o the mb2 regis-
iec urrently execut-
ume as the effective
cycle. The ASM in

implement the data

Figure 9-2. Pipelinedfetch/execute with data forwarding.

rdware PipelinedG eneral-PurposeP rocessor 361



r

INIT pc=xxxx irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=x 59
Fl pc=0100 irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=l 159
IDLE pc=0100 irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=1 259
F1 pc=0100 irl=7000 mb2=xxxx ir2=7000 ac=xxxx h=0 359
Fl pc=0101 irl=7200 mb2=xxxx ir2=7000 ac=xxxx h=0 459
F1 pc=0102 irl=1106 mb2=xxxx ir2=7200 ac=xxxx h=0 559
Fl pc=0103 irl=1107 mb2=0112 ir2=1106 ac=0000 h=0 659
F1 pc=0104 irl=3111 mb2=0152 ir2=1107 ac=0112 h=0 759
Fl pc=0105 irl=111 mb2=0000 ir2=3111 ac=0264 h=0 859
F1 pc=0106 irl=7402 mb2=0264 ir2=1111 ac=0000 h=0 959
F1 pc=0107 irl=0112 mb2=xxxx ir2=7402 ac=0264 h=0 1059
Fl pc=0110 irl=0152 mb2=xxxx ir2=0112 ac=0264 h=l 1159
IDLE pc=0110 irl=0152 mb2=xxxx ir2=0112 ac=0264 h=1 1259 ir1
IDLE pc=0110 irl=7000 mb2=xxxx ir2=7000 ac=0264 h=0 1359

As in the last example, italics show how the instruction at 0104 travels through 0
the

pipeline. In this case, data forwarding only occurs at $time 859, because
ea(llll)==ea(3111)&ir2 tmb2-.-m[

[11:9]==3. The underlining emphasizes theparts
of i r 1 and i r2 that must be identical for data forwarding to occur. During that clock
cycle, the accumulator (shown in non-italic bold) contains 0264. The effect of the data
forwarding becomes visible at $ time 959, when mb2 (shown in italic bold) becomes
0264, which is correct. At $time 1059, we see that the accumulator (shown in italic
bold) has the correct value because of this data forwarding.

9.5 Control dependencies: implementing JMP
The multi-cycle ASM of section 8.3.2.1 implemented several additional instructions.
Of these, the JMP (5xxx) instruction presents a problem to implement with a pipelined
ASM. If we do not do something special, two of the instructions that follow the JMP Figure 9-3.
will execute prior to executing the instruction being jumped to. To avoid this error, the
following ASM does not fetch these instructions after the JMP, but instead it puts two The following
NOPs in the instruction pipeline: properly for th

if (h

else
beg

i

362 Verilog Digital Computer Design: Algorithms into Hardware

I



x 59
1 159
1 259
0 359
0 459
0 559
0 659
0 759
0 859
0 959
0 1059
1 1159
1 1259
0 1359

Is through the
859, because
isizes the parts
ring that clock
Sect of the data
bold) becomes
,hown in italic

al instructions.
rith a pipelined Figure 9-3. Pipelinedfetch/execute with JMP
ollow the JMP
J this error, the The following shows in bold how the Verilog must be changed to implement JMP
ead it puts two properly for the pipelined ASM:

if (halt)
. . .

else
begin

if (irl[11:9] == 5)
begin

Pc <= (posedge sysclk) ea(irl);

PipelinedG eneral-PurposeP rocessor 363



-

Continued
At $time5

irl <= (posedge sysclk) 12'o7000; first value (0
ir2 <= (posedge sysclk) 12'o7000; for the first']

end
else tains a JMP
begin done in the

pc <= @(posedge sysclk) pc + 1; (0105) of thc
irl <= @(posedge sysclk) m[pc]; $time 759. TI
ir2 <= @(posedge sysclk) irl; must also scE

end accumulator
if ((ir2[11:9] == 3)&&(ea(irl)==ea(ir2))) but it will tal

ecute. At $t:

This occurs when the instruction in irl is a JMP (rather than waiting until ir2 con-
tains the JMP). To illustrate how this works, consider the following variation of the
program in appendix A:

0100/ 72 00 9.6 Ski1
0101/1106 The conditio
0102/5105 <- This is different from appendix A mulator, 751
0103/1110 incrementing
0104/3111 8. To implem
0105 /74 02 proach becau
0106/0112 execution.
0107/ 0152
0110/ 0224 One of the im]
0111/0000 Regardless of

only one non-
Instead of a TAD instruction at address 0102, there is a JMP (5105) instruction that ues to be store
avoids executing the TAD (1110) instruction at address 0103 and the DCA instruction describe a skij
at 0104. The following shows how figure 9-3 executes this program correctly: counter yet ag

tion after the
INIT pc=xxxx irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=x 59 too late to inc
F1 pc=0100 irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=l 159 instruction 
IDLE is

pc=0100 irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=1 259
F1 pc=0100 irl=7000 fetched into 

mb2=xxxx i
ir2=7000 ac=xxxx h=0 359

Fl pc=0101 irl=7200 mb2=xxxx ir2=7000 counter by 
ac=xxxx tw

h=0 459
F1 pc=0102 irl=1106 mb2=xxxx ir2=7200 ac=xxxx h=0 negative. 

559 We 
F1 pc=0103 irl=5105 mb2=0112 ir2=1106 ac=0000 h=0 659 The overall 
F1 el

pc=0105 irl=7000 mb2=7402 ir2=7000 ac=0112 h=0 759
Fl pc=0106 irl=7402 implementatic

mb2=xxxx ir2=7000 ac=0112 h=0 859
Fl pc=0107 irl=0112 mb2=xxxx ir2=7402 mentation, 

ac=0112 we
h=0 959

F1 pc=0110 irl=0152 mb2=xxxx ir2=0112 ac=0112 h=1 1059 fled with a NC
IDLE pc=0110 irl=0152 mb2=xxxx ir2=0112 ac=0112 h=l 1159
IDLE pc=0110 irl=7000 mb2=xxxx ir2=7000 ac=0112 h=0 1259

364 Verilog Digital Computer Design: Algorithms into Hardware



At $time 559, the pipeline is filled with instructions as before. At $tiime 659, the
first value (0000) becomes visible in the accumulator, and the operand (0112) is in mb2
for the first TAD instruction (1106). What is different at $tiime 659 is that irl con-
tains a JMP (5105) instruction. Instead of incrementing the program counter as was
done in the earlier ASMs, the program counter is loaded with the effective address
(0105) of the JMP instruction. The pipeline cannot contain any fetched instruction at
$time 759. Therefore, the same decision at $time 659 that changes the program counter
must also schedule the instruction pipeline to be loaded with NOPs. At $ time 759, the
accumulator (0000+0112) contains the correct sum from the previous TAD instruction,
but it will take two clock cycles before another instruction from the program can ex-
ecute. At $ time 959, the HLT instruction is ready to execute.

ng until i r2 con-
,gv ariation of the

9.6 Skip instructions in a pipeline
The conditional skip instructions of the PDP-8, such as SPA (Skip on Positive Accu-

lix A mulator, 7510) and SMA (Skip on Minus Accumulator, 7500), were described as
incrementing the program counter of the multi-cycle implementation given in chapter
8. To implement these instructions with a pipelined machine requires a different ap-
proach because the program counter changes during every clock cycle of pipelined
execution.

One of the important ideas of this book is the meaning of the non-blocking assignment.
Regardless of what kind of machine you are building, in any clock cycle there can be
only one non-blocking assignment to a particular register. It is impossible for two val-
ues to be stored in the same register during the same clock cycle. Therefore, 

5) instruction we 
that cannot

describe a skip instruction in a pipelined implementation 
e DCA instruction as incrementing the program

counter yet again. The program counter at that stage is 
correctly: preparing to fetch the instruc-

tion after the one to be skipped, which will execute regardless of the skip. It is already
:h=x 59 too late to increment the program counter by two at the time we realize that the next
:h=i 159 instruction is to be skipped because the instruction to be skipped has already been
:h=1 259 fetched into i r 1. At the time it would have been appropriate to increment the program
:h=O 359 counter by two, we would not yet know whether the accumulator will be positive 
:h=O 459 or

negative. We need a different way to think about 
:h=O the 

559 skip instruction.
h=O 659 The overall effect of incrementing the program counter yet again in the multi-cycle
h=0 759 implementation is to nullify the instruction that follows the skip. In a pipelined imple-
h=O 859 mentation, we can accomplish the same thing by replacing the instruction to be nulli-
h=O 959 fied with a NOP (7000):
h=i 1059
!h=i 1159
!h=O 1259

dware Pipelined General-PurposeP rocessor 365



always Continued
begin
@(posedge sysclk) enter new state('INIT);
pc <= @(posedge sysclk) 12'oOlOO;
halt <= (posedge sysclk) 1;
forever
begin
@(posedge sysclk) enternewstate('Fl);
if (halt)
begin
$stop;
while (-cont)
begin
@(posedge sysclk) enternew-state('IDLE);
halt <= (posedge sysclk) 0;
irl <= @(posedge sysclk) 12'o7000;
ir2 <= @(posedge sysclk) 12'o7000;

end
end

else
begin
if ((ir2 == 12'o7510) && (-aclll)

(ir2 == 12'o7500) && (ac[11))
begin
pc <= (posedge sysclk) pc + 1;
irl <= (posedge sysclk) mpcl;
ir2 <= (posedge sysclk) 12'o7000; end

end
end

else
if (irl[ll:9] == 5)
begin
pc <= @(posedge sysclk) ea(irl);
irl <= @(posedge sysclk) 12'o7000; The decision v
ir2 <= @(posedge sysclk) 12'o7000; top of the alg(
end value stored in

else ferring irl in
begin
pc <= larly, if that 

(posedge ni
sysclk) pc + 1;

irl <= @(posedge sysclk) m[pc]; precedence ov
ir2 <= @(posedge sysclk) irl; algorithm is:

end
a) a s

if ((ir2[11:91 == 3)&&(ea(irl)==ea(ir2)))
mb2 <= @(posedge b) a J

sysclk) ac;
else c) noi
mb2 <= @(posedge sysclk) m[ea(irl)];

366 Verilog Digital Computer Design: Algorithms into Hardware



Continued

if (ir2[11:9] == 1)
ac <= (posedge sysclk) ac + mb2;
else if (ir2[11:9] == 3)
begin
m[ea(ir2)] <= (negedge sysclk) ac;
ac <= (posedge sysclk) 0;

end
else if (ir2 == 12'o7200)
ac <= (posedge sysclk) 0;
else if (ir2 == 12'o7402)
halt <= (posedge sysclk) 1;
else if (ir2 == 12'o7041)
ac <= (posedge sysclk) -ac;
else if (ir2 == 12'o7001)
ac <= @(posedge sysclk) ac + 1;

else if (ir2 == 12'o7000)

else if (ir2 == 12'o7510)

else if (ir2 == 12'o7500)

else
$display("other instructions...");

end
end

end

The decision whether to nullify the instruction that follows the skip must occur at the
top of the algorithm. This is because each register, such as ir2, can only have one
value stored into it during each clock cycle. The normal behavior of the pipeline (trans-
ferring irl into ir2) cannot occur when the next instruction is to be nullified. Simi-
larly, if that next instruction (in irl) is a JMP (as is likely), the skip needs to take
precedence over the JMP. Therefore the precedence of the decisions at the top of the
algorithm is:

a) a skip instruction in ir2 that is to be taken
b) a JMP instruction in i r 1
c) normal pipelined behavior

ware I PPiippeelliinneedd G eenneerraall--PPuurrppoosseePP  rroocceessssoorr  336677

.1



-

Any other precedence would be incorrect. At the time the algorithm makes this deci-
sion, ir2 already contains For 

the skip simplicii
instruction. Therefore, the bottom of the algorithm

(which executes in parallel) needs that these 
to treat va

the 7500 or 7510 as a NOP, regardless of
whether or not the following instruction will be nullified. As has been
The above also includes the roles: 

IAC it 
(Increment avoi

ACcumulator, 7001) and CIA (Comple-
ment and Increment Accumulator, stops 

7041) the loo
instructions. These non-memory reference

instructions are similar to the implemented
CLA (7200) instruction in that the pipeline follows its

normal behavior. To achieve JMP 
simple at the 

pipelined behavior here with the CIA instruction,
we assume that the ALU can form guage, 

the but 
twos it I

complement negation of the accumulator in
a single clock cycle. the loop. We

we can. Sucl
machine. Th,
entered the fi

9.7 Our old friend: division
The recurring example in this book is the childish division algorithm, introduced in 0100/ 72 00
section 2.2. It is used in chapter 2 to illustrate Moore ASMs, used in chapter 3 to illus- 0101/ 112 6
trate Verilog test code, used in chapter 4 to illustrate behavioral, mixed 0102 

and /3 124
structural

Verilog, used in chapter 5 to illustrate Mealy ASMs, 0103 
used /3 125

in chapter 6 to illustrate
propagation delay and used in chapter 0104/ 

8 72 
to 00

benchmark the multi-cycle general-purpose
PDP-8 against the 0105/ 

special-purpose 1127
hardware of earlier chapters. The conclusion in chap- 0106/ 

ter 7041
8 is that special-purpose hardware implementations of the childish division algo- 0107/1124

rithm were considerably faster and cheaper than the same algorithm running as soft- 0110 /7510
ware on the multi-cycle implementation of the general-purpose PDP-8. Yet most algo- 0111/5123
rithms are implemented in software rather than hardware because software is easier to 0112 /3 124
design and maintain. Pipelining allows a designer to create a more expensive general-
purpose computer where the speed of its software comes closer to that of special-pur-
pose hardware. 0113/112 5

0114 /7 001
To illustrate what we have achieved by pipelining the PDP-8 as described in the previ- 0115 /3 12 5
ous sections, recall the description of the childish division algorithm in C: 0116/ 1127

0117/ 7041
012 0/1124
0 121/7500
0122/5112
0123/7402

0124/0000 
0125/0000 
0126/0016 )
0127/0007 

l Since we have
of x and could

368 Verilog Digital Computer Design: Algorithms into Hardware



makes this deci- For simplicity, we will assume x and y already have their values stored in memory, and
n of the algorithm that these values are less than 2048.'
FOP, regardless of

As has been illustrated many times in earlier chapters, the while loop serves two
roles: it avoids entering the loop and thus keeps r2 zero when x<y, or otherwise it

nd CIA (Comple- stops the loop when it has repeated the proper number of times. In chapter 8, this was
nemory reference implemented as a skip and JMP at the top of the software loop and an unconditional
peline follows its JMP at the bottom. Such an approach is the easiest way to translate to machine lan-
e CIA instruction, guage, but it has the cost of requiring additional instructions to execute each time through
he accumulator in the loop. We need to find as good a machine language translation of this algorithm as

we can. Such a machine language program will make the best use of the pipelined
machine. The following uses an SPA instruction at the top to cause the loop to be
entered the first time, and an SMA instruction at the bottom to cause the loop to exit:

*0100

hm, 0100/72 
introduced 00

in CLA
0101/1126 TAD X

chapter // 
3 ac 

to illus- = +x
0102/3124 DCA Ri // rl = x

xed and structural 0103/3125 DCA R2 // r2 = 0
Aer 6 to illustrate 0104/ 72 0 0 CLA
.eg eneral-purpose 0105/1127 TAD Y // ac = O+y
onclusion in chap- 0106/ 7041 CIA // ac = -y
lish division algo- 0107 /1124 TAD R1 // ac = rl-y

n running as soft- 0L10/7510 SPA // if (rl-y >= 0) goto Li

'-8. Yet most algo- 0 111/5123 JMP L2 // else goto L2
0112/3124 

ftware is Li,
easier DCA 

to Ri // rl = rl-y
// 

Expensive depends 
general- on ac containing r-y

// on both paths to this 
hat inst.

of special-pur- 0113/112 5 TAD R2 // ac = O+r2
0114/7001 IAC // ac = r2+1
0115 /3 125

ribed in the previ- DCA R2 // r2 = r2+1
0116/1127 TAD Y

ninC: // ac =0+y
0117/ 7041 CIA // ac = -Y
0120/1124 TAD R1 // ac = rl-y
0121/7500 SMA // if (rl-y < 0) goto L2
0122 /5112 JMP Li // else goto Li
0123/7402 L2, HLT // done

//
0124/0000 RI, 0000
012 5/0000 R2, 0000
012 6/0016 X, 0016 // These must be < 2048 (3777 octal)
0127/0007 Y. 0007

| Since we have not implemented the link register of the PDP-8 in this pipelined version, larger values
of x and y could cause the program to malfunction.

ware PipelinedG eneral-PurposeP rocessor 369



The execution of the above software on the pipelined PDP-8 illustrates how the skip (7510).2 
instructions As d

work:
whether the n.
In this case, a
1459, ir2 ha

INIT pc=xxxx irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=x 59
F1 Pc=0100 the 

irl=xxxx algorithm
mb2=xxxx ir2=xxxx ac=xxxx h=1 159

IDLE Pc=0100 irl=xxxx mb2=xxxx ir2=xxxx ac=xxxx h=1 259 A different sit
F1 pc=0100 irl=7000 mb2=xxxx ir2=7000 ac=xxxx h=O 359 JMP instructi(
F1 pc=0101 irl=7200 mb2=xxxx ir2=7000 ac=xxxx h=O 459 scribed in sec
F1 pc=0102 irl=1126 mb2=xxxx ir2=7200 ac=xxxx h=O 559
F1 pc=0103 visible at 

irl=3124 $ti
mb2=0016 ir2=1126 ac=0000 h=O 659

F1 pc=0104 irl=3125 mb2=0000 ir2=3124 the 
ac=0016 JMP until

h=O 759
F1 pc=0105 irl=7200 mb2=0000 ir2=3125 ac=0000 h=O 859 Finally, at $ t
F1 pc=0106 irl=1127 mb2=xxxx ir2=7200 ac=0000 h=O 959 cause the accu
F1 pc=0107 irl=7041 mb2=0007 ir2=1127 ac=0000 h=O 1059
F1 pc=0110 allows 

irl=1124 sequen
mb2=xxxx ir2=7041 ac=0007 h=O 1159

F1 pc=0111 irl=7510 mb2=0016 ir2=1124 ac=7771 h=O 1259 Between $ti:
F1 pc=0112 irl=5123 mb2=7510 ir2=7510 ac=0007 h=O 1359 tient >= 1,
F1 pc=0113 irl=3124 mb2=7402 ir2-7000 ac=0007 h=O 1459 summarizes ir
F1 pc=0114 irl=1125 mb2=0016 ir2=3124 ac=0007 h=O 1559
F1 lier 

pc=0115 irl=7001 chapters:
mb2=0000 ir2=1125 ac=0000 h=O 1659

F1 pc=0116 irl=3125 mb2=xxxx ir2=7001 ac=0000 h=O 1759
F1 pc=0117 irl=1127 mb2=0000 ir2=3125 ac=0001 h=O 1859
F1 pc=0120 irl=7041 mb2=0007 ir2=1127 ac=0000 h=O 1959 max
F1 pc=0121 irl=1124 mb2=xxxx ir2=7041 ac=0007 h=O 2059 int
F1 pc=0122 irl=7500 mb2=0007 ir2=1124 ac=7771 h=O 2159
F1 pc=0123 irl=5112 mb2=7200 ir2=7500 ac=0000 h=O 2259 4095
F1 pc=0112 irl=7000 mb2=3124 ir2=7000 ac=0000 h=O 2359 4095
F1 pc=0113 irl=3124 mb2=xxxx ir2=7000 ac=0000 h=O 2459 4095
F1 pc=0114 irl=1125 mb2=0007 ir2=3124 ac=0000 h=O 2559 4095
F1 pc=0115 irl=7001 mb2=0001 ir2=1125 ac=0000 h=O 2659 4095
F1 pc=0116 irl=3125 mb2=xxxx ir2=7001 ac=0001 h=O 2759 4095
F1 pc=0117 irl=1127 mb2=0001 ir2=3125 ac=0002 h=O 2859 4095
F1 pc=0120 irl=7041 mb2=0007 ir2=1127 ac=0000 h=O 2959 4095
F1 pc=0121 irl=1124 mb2=xxxx ir2=7041 ac=0007 h=O 3059 2047
F1 pc=0122 irl=7500 mb2=0000 ir2=1124 ac=7771 h=O 3159 2047
F1 pc=0123 irl=5112 mb2=7200 ir2=7500 ac=7771 h=O 3259
F1 pc=0124 irl=7402 mb2=3124 ir2=7000 ac=7771 h=O 3359
F1 pc=0125 irl=0000 The first seven

mb2=xxxx ir2=7402 ac=7771 h=O 3459
the childish di%
(whose ASMs i
ment division.

At $ time 1259, when irl gets loaded with the first skip instruction (7510), we do which is 2047 fi
not yet know whether the accumulator will be positive or negative, so the pipeline the hardware is
continues filling normally. At $ time 1359, there is a decision that must be made be-
cause irl contains the JMP instruction (5123) and ir2 contains the SPA instruction

2 The 7510 in mb2

370 Verilog Digital Computer Design: Algorithms into Hardware



P_

ites how the skip (75 10).2 As described above, the skip is given precedence over the JMP. Therefore,
whether the next instruction (currently in irl) will be nullified is based on ac [11] .
In this case, ac [1 1] = = 0, so the SPA will nullify the following instruction. At $ time
1459, ir2 has become NOP (7000), but 3124 was fetched normally into irl so that

h=x 59 the algorithm can proceed sequentially.
h=1 159
h=1 259 A different situation occurs at $ time 2259. Here the SMA (7500) does not nullify the
h=O 359 JMP instruction (5112) because the accumulator is not negative, so the behavior de-
h=O 459 scribed in section 9.5 occurs. Both irl and ir2 are loaded with NOPs (7000), as is
h=O 559 visible at $ time 2359. The machine does not start executing useful instructions after
h=O 659 the JMP until $ time 2559 because of the time required to fill the pipeline.
h=O 759
h=O 859 Finally, at $time 3259, the SMA (7500) does nullify the JMP instruction (5112) be-
h=O 959 cause the accumulatoris negative, so only ir2 has aNOP(7000) at $time 3359. This
h=O 1059 allows sequential execution of the HLT (7402) at $ time 3459.
h=O 1159
h=O 1259 Between $time 359 and $time 3459 are 32 clock cycles. In general, if the quo-
h=O 1359 tient >= 1, the number of clock cycles is 12 +10 *quo tient. The following table
h=O 1459 summarizes implementations of the childish division algorithm given in this and ear-
h=O 1559 lier chapters:
h=O 1659
h=O 1759
h=O 1859

max pipe kind hardware 
h=O 1959 software

int of 
h=O 2059 ASM section section clock cycles

h=O 2159
4095 n Moore 2.2.7 

h=O 2259 n/a 3 + quotient
4095 n Moore 2.2.3 

h=O 2359 n/a 2 + 2*quotient
4095 n Moore 2.2.2 

h=O 2459 n/a 3 + 3*quotient
4095 n Moore 

h=0 2.2.5 
2559 n/a 2 + 3*quotient

4095 n Mealy 5.2.1 
h=O 2659 n/a 2 + 2*quotient

4095 n Mealy 5.2.3 
h=O 2759 n/a 3 + quotient

4095 n Mealy 5.2.4 
h=O 2859 n/a 2 + quotient

4095 n Moore 8.3.2.1 
h=O 2959 8.3.2.5.3 88+75*quotient

2047 n Moore 8.3.2.1 
h=O 3059 9.7 55+55*quotient

2047 y Mealy 9.6 
h=O 3159 9.7 12+10*quotient

h=O 3259
h=O 3359 The first seven lines above are for special-purpose computers whose ASMs implement
h=O 3459 the childish division algorithm. The last three lines are for general-purpose computers

(whose ASMs implement fetch/execute) that need a machine language program to imple-
ment division. The "max int" column shows the maximum allowable integer input,

ion (7510), we do which is 2047 for the software given in this section. The "pipe" column indicates whether
e, so the pipeline the hardware is pipelined. The "kind of ASM" indicates whether the ASM uses condi-
must be made be-
ieS PA instruction 2 The 7510 in mb2 is sheer coincidence.

aware PipelinedG eneral-PurposeP rocessor 371



tional commands (Mealy) or not (Moore). The "hardware section" column indicates The reason foi
where the ASM is described. The "software section" applies only to general-purpose memory acts 1
computer implementations and describes the machine language for a version of the contents of me
childish division algorithm. The "clock cycle" column indicates how long it takes to
compute the quotient, neglecting input/output time, if possible. [The "friendly user"
assumptions cause the special purpose machines to do useful work (clearing r2) dur- always
ing this time that cannot be neglected. On the other hand, the software results ignore dout

these times.]
always

The next to the bottom line shows how long the software given in this section takes to dout
run on the multi-cycle hardware designed in section 8.3.2.1. This is shown to make a
fair comparison of the effects of pipelining given on the bottom line. As quotient always

gets large, the speedup of the software running on the pipelined PDP-8 versus the same begi

software running on the multi-cycle machine of section 8.3.2.1 approaches if
55/10=5.5.

But still, the speed of the special-purpose hardware in chapter 2 can be up to ten times end
faster than the speed of the pipelined PDP-8. As is discussed in the next section, the
speed of the pipelined PDP-8 comes at the cost of a special kind of memory, known as
multi-port memory, which is several times more expensive than the single-ported so that the arcl
memory described in section 8.2.2. memory in par

9.8 Multi-port memory din2
In order to realize the pipelined fetch/execute ASM in hardware, it must be possible to
do three things simultaneously with memory: fetch an instruction, fetch data and store
data. The memory devices discussed in section 8.2.2 would not allow this to happen,
because they are restricted to at most one read or write per clock cycle. To allow mul-
tiple operations per clock cycle in memory, we need a multi-port memory, which is
shown as a letter "E" on its side. Idm2- 714<

1

doutO Idm2
-*mal doutl m

ma2

MULTI-PORT MEMORY

Figure 9-4. Symbol for multi-port memory.

Figure 9-5.

372 Verilog Digital Computer Design: Algorithms into Hardware



na2
umn indicates The reason for this unconventional figure is to illustrate the fact that the multi-port
mneral-purpose memory acts like several independent devices that share a common foundation (the
version of the contents of memory). In each clock cycle, three separate operations occur in parallel:
ong it takes to
'friendly user"
aring r2) dur- always @(m[maO])

results ignore doutO = m[maO];

always @(m[mal])
ection takes to doutl = m[mal];
)wn to make a
is quotient always (posedge sysclk)

ersus the same begin
if (ldm2)

hes 55/10=5.5.
m[ma2] = din2;

up to ten times end
xt section, the
iory, known as
single-ported so that the architecture that instantiates the multi-port memory may do three things to

memory in parallel.

tb e possible to
data and store

this to happen,
To allow mul-

mory, which is

Idm2

in2

Figure 9-5. Implementation of multi-portedm emory.

are PipelinedG eneral-PurposeP rocessor 373



Figure 9-5 shows a block diagram for a synchronous multi-port memory using a demux,
two muxes and enabled registers. This block diagram is a generalization of the single- 9.10 Coi
port memory shown in section 8.2.2.3.1. The distinction with the multi-port memory is The pipelined I
that there are two muxes, each of which can access the memory cells independently. five times fast.

propagation de
cycle versions;
First is the num

9.9 Pipelined PDP-8 architecture five clock cycle
Figure 9-6 shows an architecture for the pipelined PDP-8 that uses the multi-port Second is the t
memory. The program counter, pc, is a counter with clrpc, incpc and ldpc com- occur. (The exa
mand signals. The other registers (ir, ir2, mb2 and the accumulator) are enabled representative
registers with load signals (1dirl, ldir2, ldmb2, dac). There are two muxes The major 
that cost

allow irl and ir2 to be loaded with NOPs (7000). There is another mux that which 
allows allows 

for si
data forwarding from the accumulator to mb2. Also, there is a comparator that even with 

that r
detects when ea (irl) equals ea (ir2). hardware for th

When you cons
software runnin
performance of
techniques beyc
going to approa
of these techniq

9.11 Furl
PATTERSON, DAV
Hardware/Softi
gives more deta
complicated tha

STERNHEIM, ELIE,
Automata Publi
modeling a pipe

9.12 Exei
9-1. Modify the
PDP-8 (describe
only increase its

Figure 9-6. Architecturef or pipelined PDP-8. Simulate the mo

374 Verilog Digital Computer Design: Algorithms into Hardware



using a demux, 9.10 Conclusion
an of the single-
-portm emory is The pipelined PDP-8 designed in this chapter can run software in some situations about
ndependently. five times faster than the multi-cycle PDP-8 given in the last chapter. Because the

propagation delays (which determine the clock frequency) in the pipelined and multi-
cycle versions are nearly identical, there are two other factors that determine the speed.
First is the number of clock cycles per instruction. (In chapter 8, most instructions take
five clock cycles, but in this chapter instructions other than JMP take only one cycle.)

the multi-port Second is the the mix of instructions in the program, such as how frequently JMPs
and ldpc com- occur. (The example here is the childish division algorithm, which may or may not be
tor) are enabled representative of how the algorithm you want to implement will perform.)
are two muxes The major cost of the pipelined approach in this chapter is the multi-port memory,

other mux that which allows simultaneous access to memory for instructions and data. The problem is
is a comparator that even with pipelining, this approach provides one-tenth the speed of the specialized

hardware for the childish division algorithm.

When you consider both cost and speed, special-purpose hardware is much better than
software running on a pipelined PDP-8, at least for this example. Although the relative
performance of other algorithms might be different, this example points out that other
techniques beyond pipelining of the PDP-8 are going to be required if software speed is
going to approach that of special purpose hardware. The next chapter illustrates some
of these techniques.

9.11 Further reading
PATTERSON, DAVID A. and JOHN L. HENNESSY, Computer Organizationa nd Design: The
Hardware/SoftwareI nterface, Morgan Kaufmann, San Mateo, CA, 1994. Chapter 6
gives more details about implementing data forwarding with an instruction set more
complicated than the PDP-8.

STERNHEIM, ELIEZER, RAJVIR SINGH and YATIN TRIVEDI, DigitalD esign with Verilog HDL,
Automata Publishing, San Jose, CA, 1990. Chapter 3 gives a different approach to
modeling a pipelined general-purpose computer in Verilog.

9.12 Exercises
9-1. Modify the behavioral design in section 9.6 to include the ISZ instruction of the
PDP-8 (described in appendix B). Including an ISZ instruction in a program should
only increase its execution time by one clock cycle for each time the ISZ is executed.
Simulate the modified design with the following programs:

Mare Pipelined General-PurposeP rocessor 375



0000/7200 10.
0001/2007
0002/2007 All general-pi
0003/1007 ware: fetch/e)
0004/2007 in chapter 8 us
0005/5003 8 has a simple
0006/7402 it often takes 
0007/7774

illustrated in s
chapter 9, so

9-2. Using the ISZ instruction, it is possible to implement a version of the childish single-accumu
division program that is about twice as fast as the one given in section 9.7. Implement level language
such a program and use test code with the behavioral Verilog for problem 9-1 to mea- several times 
sure how long it takes to divide x by seven, as the test code varies x from 0 through 28. division exam]
Derive a mathematical formula for clock cycles comparable to those listed in section
9.7 which generalizes the data observed by the Verilog test code. In the beginnii

Hints: The machine
language program needs to precompute -y, and rl should reside adhered to this

in the accumulator
rather than in memory. The skipping action of the ISZ is irrelevant is one of the 

to bi
this program.

introducing it
9-3. Draw a modified architecture for problem 9-1. The only extra devices needed are used for speci
two input muxes, a comparator and an incrementor. simplicity of ti
9-4. Modify the behavioral design in section 9.6 to include the design 

JMS instruction process
of the

PDP-8 (described in appendix B). Simulate your modified design. other instructic

9-5. Draw a modified architecture for problem 9-4. The problem is
performance fr

9-6. Modify the behavioral design in problem 9-4 to include the indirect page zero ware closer to t
addressing mode of the PDP-8 (described in appendix B). You may assume there is an kind of machin
additional port to memory. How many stages will be in your pipeline? the way the ma
9-7. Draw a modified architecture for problem 9-6.

9-8. Modify the behavioral design in problem 9-4 to include interrupts.
10.1 Hisi

9-9. The behavioral design of section 9.4 does not execute self-modifying programs
properly. Modify the design One 

to process attempt 
properly to

the two kinds of dependencies that are
possible in such programs. lar in the 1970s

the idea is to ml
9-10. Draw a modified architecture for problem 9-9. (and special rej

this would give
computers). To
tion in the instr
described in ap
distinct instruct
register require!

376 Verilog Digital Computer Design: Algorithms into Hardware



10. RISC PROCESSORS
All general-purpose computers implement fundamentally the same algorithm in hard-
ware: fetch/execute. A multi-cycle implementation of fetch/execute, which is described
in chapter 8 using the PDP-8, takes several clock cycles per instruction. Since the PDP-
8 has a simple instruction set with a single-accumulator and a single memory address,
it often takes several instructions to execute a single high-level language statement, as
illustrated in section 8.3.2.5.3. It is possible to pipeline fetch/execute, as was shown in
chapter 9, so that most instructions appear to execute in a single clock cycle, but a

i of the childish single-accumulator machine still requires several instructions to perform typical high-
i9 .7. Implement level language statements. The speed of a pipelined single-accumulator machine is

)lem 9-1 to mea- several times slower than the special-purpose hardware of chapter 2, at least for the
)m0  through 28. division example used throughout this book.
listed in section In the beginning, most general-purpose 

its: The machine computers, such as the Manchester Mark I,
adhered to this single-accumulator, 

the accumulator single-address style of instruction set. The PDP-8
is one of the best and purest illustrations 

this program. of this very simple approach. The reason for
introducing it in the preceding chapters is to illustrate how the same design process

vices needed are used for special-purpose computers also works for general-purpose computers. The
simplicity of the PDP-8 allows us to focus on using ASM charts and Verilog in the
design process without 

instruction having 
of the to worry about excessive complications that exist in

other instruction sets.

The problem is that, after pipelining the PDP-8, we have about reached the limits of
performance from a single-accumulator, single-address instruction set. To make soft-

direct page zero ware closer to the speed of special-purpose hardware will require specifying a different
ssume there is an kind of machine language. The central concept of fetch/execute remains the same, but

the way the machine uses the bits in the instruction register will have to be different.

ts.
10.1 History of CISC versus RISC

lifying programs One attempt to increase performance of general-purpose 
ndencies that processors 

are that became popu-
lar in the 1970s is the idea of a Complex Instruction Set Computer (CISC). In essence,
the idea is to merge a simple general-purpose machine together with special hardware
(and special registers) that solve certain specific computations. The thought was that
this would give the user the best of both worlds (special-purpose and general-purpose
computers). To activate each special hardware unit requires including a new instruc-
tion in the instruction set. Rather than the handful of machine language instructions
described in appendix B for the PDP-8, a CISC machine might have thousands of
distinct instructions. Fitting all these instructions into a reasonable sized instruction
register requires that some instructions occupy multiple words, which is known as a

ware RISC Processors 377



variable length instructions et. Such machines are aptly named CISC because the fetch/
execute algorithm, although fundamentally the same, has much more 10.3 

complex details Pi
with a variable length instruction set. This is especially true if the machine is to be Like all othei
pipelined. the ARM us(

This approac
Two factors led to the popularity of CISC processors. First, improved fabrication tech- other popular
nologies allowed ever-increasing amounts of hardware to fit on a chip. Second, in- to those of tf
struction set designers had a mistaken belief that programmers and compilers would be mnemonics c
able to utilize all this special-purpose hardware effectively. STM and SM
By the early 1980s, several empirical studies had shown that CISC processors did not and instead a
make effective use of all of their special-purpose hardware. As a result of these studies, reside in a me
several groups designed Reduced Instruction Set Computers (RISC). Like the PDP-8, ture.2 Althou,
RISC machines have fixed length instruction sets. This simplifies pipelined implemen- sion if we ass
tation. RISC instruction sets are chosen with pipelining of fetch/execute in mind, while
CISC instruction sets make pipelining fetch/execute difficult. Unlike the PDP-8, RISC
processors have several features that allow higher performance than is possible on a 10.4 
single-accumulator Th

machine. Although CISC processors remained popular through the
end of the twentieth century (the Pentium II is a CISC processor), the momentum in If, at least for
computer design shifted to the RISC philosophy. where is it g

special-purpo
registers. In c
the ARM nee(

10.2 The ARM When you des
In the early 1980s, Acorn Computers, Ltd. designed an inexpensive computer for teaching clear how to h
computer literacy in conjunction with a BBC television program in Great Britain. The rithm. The des
machine was originally dubbed the "Acorn RISC Microprocessor" (ARM). Several ing how regist
years later, Acorn entered into a consortium with more than a dozen manufacturers, determined by
including DEC' (the company that manufactured the PDP-8) and Apple (which uses together into 
the ARM in its Newton PDA), to promote the ARM worldwide. The ARM acronym synchronous n
was redefined to mean "Advanced RISC Microprocessor." The ARM is probably the ter file in user
most elegant RISC processor ever marketed. Its instruction set is simpler than most of notation r [ 0 ]
the other RISC processors with which it can be compared. Although, as explained as RO through
below, it does not have the performance bottlenecks of a single-accumulator machine,
its superb simplicity is in some respects reminiscent of the PDP-8. This chapter will The program
use only a small subset of ARM instructions to introduce some key ideas in choosing prove the clari
an instruction set for maximal performance. Appendix G explains how to access the
official ARM documentation for the complete instruction set. In particular, the ARM
supports several different modes of operation. We will only be concerned with what is
called user mode. 2 Harvard architec

sions of the ARM
simplification to ti

l DEC sold its rights to the StrongARM to Intel in late 1997, but the other members of the ARM consortium 3There are severa
were not part of that agreement and continue to produce various versions of the ARM. simplicity.

378 Verilog Digital Computer Design: Algorithms into Hardware



ecause the fetch/ 10.3 Princeton versus Harvard architecture
complex details Like all other general-purpose ("stored program") computers, commercial versions of

machine is to be the ARM use the same memory to store both machine language programs and data.
This approach is sometimes referred to as a Princetona rchitecture. The ARM, like all

fabrication tech- other popular general-purpose computers, requires memory reference instructions, akin
,hip. Second, in- to those of the PDP-8, to bring data into and out of the central processing unit. (The
mpilers would be mnemonics of these ARM instructions, given in appendix G, are LDR, STR, LDM,

STM and SWP.) For the moment let us ignore these memory reference instructions,
and instead assume that only programs reside in memory. A machine where programs

rocessors did not reside in a memory exclusively for programs is sometimes called a Harvarda rchitec-
.t of these studies, ture.2 Although the ARM is not actually a Harvard machine, it will simplify the discus-
. Like the PDP-8, sion if we assume it is.
elined implemen-
ate in mind, while
the PDP-8, RISC
n is possible on a 10.4 The register file
)pular through the If, at least for the moment, data is not going to reside in the same memory as programs,
the momentum in where is it going to be? To achieve software performance that approaches that of

special-purpose hardware, there is only one plausible answer: put the data in hardware
registers. In contrast to the PDP-8, with its single accumulator, a RISC processor like
the ARM needs many registers for storing data.

When you design a special-purpose machine, like those in chapter 2, it is usually fairly
nputer for teaching clear how to interconnect the registers to implement the transfers required by the algo-
Great Britain. The rithm. The designer of a general-purpose computer does not have the luxury of know-
" (ARM). Several ing how registers might need to be interconnected because the register transfers will be
:en manufacturers, determined by software. Therefore, the registers of a RISC processor need to be lumped
Apple (which uses together into what is called a registerf ile. The register file is really a small and fast
he ARM acronym synchronous multi-port memory. The ARM has sixteen registers available in its regis-
{M is probably the ter file in user mode.3 We will refer to these sixteen registers using the Verilog array
mpler than most of notation r [ 0 ] through r [ 15 ] . In assembly language, the programmer refers to these
)ugh, as explained as RO through R15. Each one of these registers contains a 32-bit value.
umulator machine, The program counter on the ARM is actually synonymous with r [ 15] . We can im-
,.T his chapter will prove the clarity of our Verilog description of the ARM using:

y ideas in choosing
how to access the

articular, the ARM
cered with what is

2 Harvard architectures usually have a separate memory for data, which we will ignore. Commercial ver-
sions of the ARM actually have Princeton architectures that share the same memory for data. It is an over-
simplification to think of the ARM with a Harvard architecture.

of the ARM consortium 3There are several other registers available for so-called supervisor modes, but we will ignore these for
simplicity.

irdware RISC Processors 379



In contrast to
'define PC r[15]

corresponding
register specif

10.5 Three operands are faster than one above.

The most common operations in typical algorithms are things like addition and sub- Assuming yot
traction. For example, in the childish division algorithm implemented in section 9.7, clock speed, t
we need to compute a difference, d = r - y. On the PDP-8, ri and y are data that single-accumu
residesin memory. The PDP-8's accumulator contains partial results as the following erands as well
four instructions execute: quires this app

the memory a(

RISC machine
insist that valu
the register file
it only takes a
ands and a sep;
instruction.

As with the examples in chapters 8 and 9, the above shows the address and correspond-
ing machine language in octal. Upon completion of the second TAD instruction, the RISC instructi
PDP-8's accumulator contains d. typically faster

cally reduces t]
To perform a similar computation with the ARM requires that all data reside in regis- tor machine, w
ters. Let us assume that the ARM's r [ 0 ] register takes on the role served by the PDP- tion set allows
8's accumulator (to contain the difference, d), that the ARM's r [ 1 ] register serves cated than sim
the same role as the R1 location in the PDP-8's memory and that the ARM's r [ 4] allows a genen
register contains the value of y. comes much c]
Since there are only sixteen registers to choose from, the ARM makes it possible to There are som
specify both operands of the subtraction (r [ 1 ] and r [ 4 ] ) as well as the destination RISC instructi
register (r [ 0 ] ) within a single 32-bit instruction. For example, given the above as- cause of the sii
sumptions, the following single ARM instruction is equivalent to the four PDP-8 in- tion set usuall)
structions shown earlier: CISC instructi(

a RISC, the ni
program is typi

OOOOOOc/e0510004 SUBS RO,R1,R4 accumulator m

With the advei
11 I variable length
|| +- specifies r[4] size. Examples
|+ specifies r[O] Interestingly, s
+ specifies r] set used for cc

execution. Als
like) instruction

380 Verilog Digital Computer Design: Algorithms into Hardware



In contrast to the PDP-8 examples, the above ARM example shows the address and
corresponding machine language in hexadecimal. This is convenient since the four-bit
register specifications appear as hexadecimal digits in the machine language, as shown
above.

dition and sub- Assuming you have pipelined versions of the ARM and PDP-8 running at the same
in section 9.7, clock speed, the ARM can do four times as many subtractions as the PDP-8. On a

I y are data that single-accumulator machine, like the PDP-8, the accumulator serves as one of the op-
s the following erands as well as the destination. The single-accumulator, single-address machine re-

quires this approach because most of the bits of the instruction register are devoted to
the memory address of the other operand.
RISC machines prohibit computation on values from memory. Instead, RISC machines
insist that values to be added or subtracted already reside inside the register file. Since
the register file is small compared to memory (sixteen registers in the case of the ARM),
it only takes a few bits (twelve in the case of the ARM) to describe two separate oper-
ands and a separate destination. Therefore, the complete subtraction can be done in one
instruction.

md correspond-
instruction, the RISC instruction sets have three advantages. First, the access time of the register file is

typically faster than that of a full-sized memory. Second, the RISC instruction set typi-
cally reduces the number of instructions in a program compared 

reside in regis- to a single-accumula-
tor machine, which often means the software will run 

red by faster. 
the Finally, 

PDP- the RISC instruc-
tion set allows the designer to exploit fetch/execute techniques 

register that 
serves are more sophisti-

cated than simple pipelining, such as superscalar design. 
ARM's The 

r[4] superscalar approach
allows a general-purpose computer designer to create a machine whose software speed
comes much closer to that of special-purpose hardware.

,s it possible to There are some disadvantages to RISC instruction 
the sets. 

destination First, making good use of a
RISC instruction set requires a sophisticated programmer 

n the or 
above compiler. 

as- Second, be-
cause of the simplicity of operations on a RISC compared 

four to 
PDP-8 a 

in- CISC, a RISC instruc-
tion set usually requires more instructions to accomplish the same computation than a
CISC instruction set. Third, because of the large fixed-sized instruction register used in
a RISC, the number of bits (as opposed to the number of instructions) to encode a
program is typically larger than any variable length CISC, or even a fixed length, single-
accumulator machine like the PDP-8.
With the advent of large multimedia applications at the end of the 1990s, interest in
variable length CISC instruction sets reemerged because of concerns about program
size. Examples of such CISC designs include Sun's Java machine and ARM's Thumb.
Interestingly, such machines internally translate the variable length CISC instruction
set used for compact encoding of programs into fixed length RISC instructions for
execution. Also, AMD's K6 has hardware that translates its extremely CISC (Pentium
like) instruction set into internal RISC instructions for execution.

are RISC Processors 381

'are~~~~ 

RI CPoesri8



10.6 ARM subset
There are eleven different categories of ARM instructions described in appendix G. It Si
is possible to do very useful things in software using only a few of these instructions,
and so we can select a handful of these instructions to illustrate the design of a RISC e 0
processor. Of the eleven categories of instructions in appendix G, we will only imple- /..\ /....\

ment the "data processing" and "branch" categories. The data processing L110 
category 00 0 0

is
subdivided into sixteen different mnemonics, and the branch category is subdivided
into two different mnemonics. We will only implement four of the eighteen possible II  I II
mnemonics in these two categories. I I1

I I
I I I

10.6.1 Data processing instructions I I I 
There are zeros in instruction register bits 27 and 26 to indicate the data processing
category. Instruction register bits 24 down to 21 determine which one of the sixteen I Il+
data processing mnemonics is associated with that particular instruction. For simplic- I + 
ity, we will only implement the following three of the sixteen possible mnemonics:

decoding memonic

ir[27:26]==2'bOO&&ir[24:21]==4'bOlOO ADD RD,OPA,OPB 10.6.2 Br
ir[27:26]==2'bOO&&ir[24:21]==4'bOO10 SUB RD,OPA,OPB The second m
ir[27:26]==2'bOO&&ir[24:21]==4'bllOl MOV RD,OPB tion set is the

3'blO1, theAl
this category:

To use one of the above three instructions in a program, the assembly language pro- guishes betwe
grammer would replace the RD, OPA and OPB with specific registers, such as RO, RI simple branch
and R4 in the SUBS instruction of section 10.5. Instruction register bits 15 down to 12 is straightforv
describe the destination, RD, and instruction register bits 19 through 16 describe the way the JMS
first operand, OPA. When instruction register bit 25 is zero, instruction register bits 3 dress.)
down to 0 indicate the register for the second operand OPB. The leftmost four bits of
every ARM instruction determines whether the instruction executes. Typically, these The branch in'
four bits contain 4'bl l 10. Finally bit 20 has a special meaning. When this bit is a one, 8, with three 
the mnemonic has an "S" on the end to indicate this special meaning. For example, the dressing mode
instruction in section 10.5 has the mnemonic SUBS rather than simply SUB, as illus- In a relative a
trated by the following: signed twos cc

program coun
refers to the of
to eight-bit b3
four, and so th
add to the pros
sign extended

382 Verilog Digital Computer Design: Algorithms into Hardware



in appendix G. It SUBS RO,Rl,R4 mnemonic
hese instructions,
design of a RISC e 0 5 1 0 0 0 4 hexadecimal

will only imple-
bssing category is .110 00 0 0010 1 0001 0000 00000000 0100 binary

Dry is subdivided
eighteen possible

lI l l l l | +- ir[3:0]==4 so 'OPB is r[4]
l l l | | + ir[15:12] == 0 so 'RD is r[0]

l l l l | + ir[19:16] == 1 so OPA is r]
| | | | + ir[20] == 1 so mnemonic ends with S"

+ ir[24:211==2 so mnemonic starts with SlDIU"B 
e data processing i.e., 'RD <- 'OPA - 'OPB
ne of the sixteen + ir[25] == 0 so 'OPB is a register
tion. For simplic- + ir[27:26] == 0 so it is data processing

+ 
ile mnemonics: ir[31:28] == 4'bl1lO so it executes

nic

),OPAO, PB 10.6.2 Branch instruction
),OPAO, PB The second major instruction category we will use for our subset of the ARM instruc-
),OPB tion set is the branch instruction. When instruction register bits 27 down to 25 are

3'blO1, the ARM categorizes the instruction as a branch. There are two mnemonics for
this category: 

bly B 
language (branch) 

pro- and BL (branch and link). Instruction register bit 24 distin-
guishes 

rs, such between 
as RO, Ri the simple branch instruction and the branch and link (zero means

simple branch). We 
)its 15 will 

down not 
to implement 

12 the branch and link instruction here, although it
is straightforward. (It 

;h 16 utilizes 
describe R14 

the to save a return address, quite analogously to the
way the JMS 

-ion instruction 
register bits on 

3 the PDP-8 uses a memory location to save a return ad-
dress.)

most four bits of
s. Typically, these The branch instruction on the ARM is very similar to the JMP instruction of the PDP-
,n this bit is a one, 8, with three differences. First, the branch instruction of the ARM uses a relative ad-
.For example, the dressing mode, rather than the direct addressing mode of the PDP-8's JMP instruction.
ply SUB, as illus- In a relative addressing mode, the offset field of the branch instruction is added (as a

signed twos complement value) to the program counter (rather than being moved to the
program counter as occurs on the PDP-8). Second, the branch instruction of the ARM
refers to the offset in terms of 32-bit words, but the program counter of the ARM refers
to eight-bit bytes. (The value in the ARM's program counter is always divisible by
four, and so the offset field of the branch instruction is one-quarter the value needed to
add to the program counter.) Third, since the offset field is only 24 bits wide, it must be
sign extended before it is added to the program counter.

dware RISC Processors 383



- F__

The following example branch instruction forms an infinite loop by branching back to
itself. Because of the relative addressing mode, this same machine For example, 

language instruc-
tion will work identically regardless of the location where it occurs in a program: prior to the ex

10.6.1. Becaus
the instruction

L2 L2 mnemonic (L2 is a label) As a different
32 'hOOcOOC

e a f f f f f e hexadecimal
tion (eO5 000'

110 101 0 111111111111111111111110 binary and bit 20 of ti

If bit 20 of a
l+  | two's complement -2 offset example, supp,

+ ir[24] ignored here prior to the exe
+ ir[27:25] == 5 so it branches except that bit

+ ir[31:28] == 4'blllO so it executes tive(r[O] ==
20 of the instru

There are sever;
It may seem a little strange, but the -2 indicates branching back to the same instruction. bit 30 of the PS
In other words, the new value of the program counter is the value data processing

of the program
counter at the time the instruction is fetched plus 4 * off s et+ 8, where the of the 

f set PSR 
is is the

a sign extended version of instruction register bits 23 down to 0. The reason the ARM processing insti
designers chose to make -2 mean branching back to itself will become clear later the 

in LINK 
this of the

chapter. result (of the m
caused a signed
versa).

10.6.3 Program status register
Another detail in which the ARM is different than the PDP-8 is the way in which the
ARM 10.6.4 

tests for Con,
conditions, such as testing for negative numbers. On the PDP-8, since

the accumulator is the only place where a number to be tested can One 
reside, of the most

the hardware
simply uses the most significant bit of the accumulator to determine be conditional, 

whether that num-
ber is negative or not. On the ARM, there are sixteen different registers instruction 

that is tre
a program-

mer might choose to test, and normally. 
so there are sixteen The 

different c(
sign bits that the hardware

might need to use, which would not be economical. Although 
Instead, there

the ARM allows the pro-
grammer to specify a one as bit 20 of the instruction register shown 

for in 
a data appenc

processing
instruction ("S" suffix on the mnemonic). When bit mented 

20 is a one, here:
certain critical infor-

mation about the result of the data processing instruction is saved in the program status
register. (The "S" suffix means set the PSR.) In this chapter, we will consider bit 31 of
the program status register (PSR), which is known as the "N" (negative) flag. The N
flag stores the sign bit of the result of the most recent data processing instruction with
an "S" suffix mnemonic.

384 Verilog Digital Computer Design: Algorithms into Hardware



anching back to Forexample,supposer[1] == 32'hO0000007andr[4] == 32'h00000007
nguage instruc- prior to the execution of the SUBS R0,R1,R4 instruction (e0510004) given in section
a program: 10.6.1. Becausetheresultis notnegative(r[O] == 32 'hO0000000) andbit20of

the instruction register is set, the N flag becomes zero.

As a different example, suppose r [1] == 32 h0000000 and r [4] = =
32 hO 0000007 prior to the second execution of the same SUBS RO,R1,R4 instruc-
tion (e0510004). Because the result is negative seven (r [ 0 ] == 32 hf f f f f f f 9)
and bit 20 of the instruction register is set, the N flag becomes one.
If bit 20 of a data processing instruction is zero, the PSR remains unchanged. For
example, suppose r[1] == 32'hOO000007andr[4] 32'h00000007

'fset prior to the execution of a SUB RO,R1,R4 instruction (e0410004) similar to the SUBS
except that bit 20 of the instruction register is 

)ranches zero. Even though the result is not nega-
so it executes tive (r [O] == 32 'hO 0000000), the N flag remains what it was (one) because bit

20 of the instruction register is zero.

There are several other bits in the PSR which we will not implement here. For example,
bit 30 of the PSR is the "Z" flag, which indicates whether the result (of the most recent

same instruction. data processing instruction with an "" suffix mnemonic) was equal to zero. Bit 29 of
of the program the PSR is the "C" flag, which indicates whether the result (of the most recent data

rethe offset is processing instruction with an "" suffix mnemonic) produced a carry (analogous to
reason the ARM the LINK of the PDP-8). Bit 28 of the PSR is the "V" flag, which indicates whether the
bc lear later in this result (of the most recent data processing instruction with an "" suffix mnemonic)

caused a signed overflow (what should be a negative number appears positive or vice
versa).

way in which the 10.6.4 Conditional execution
the PDP-8, since One of the most interesting and useful features of the ARM is that every instruction can

side, the hardware be conditional, that is, if a certain condition recorded in the PSR is not satisfied, the
whether that num- instruction is treated as a NOP. If that condition is satisfied, the instruction executes
rrs that a program- normally. The condition is indicated by bits 31 through 28 of the instruction register.
that the hardware Although there are sixteen different conditions that the actual ARM recognizes (as
M allows the pro- shown in appendix G), we will only consider the following four in the subset imple-
a data processing mented here:
rtain critical infor-
the program status
[consider bit 31 of
native) flag. The N
ng instruction with

rdware RISC Processors 385



decoding cond mnem instruction acts like
name suffix executes if NOP if

ir[31:28]==4'bO100 minus MI psr[31]==l psr[31]==0
ir[31:28]==4'bO101 plus PL psr[31]==0 psr[31]==l 10.6.5 Im
ir[31:28]==4'blllO always none 1 0 The only praci
ir[31:28]==4'bllll never NV 0 1 memory referc

the one that cc
As illustrated in earlier sections, most instructions have 4 bl 110 for instruction reg- Although the,
ister bits 31 down to 28 so that execution does not depend on the psr. Although the ignoring for n(
ARM documentation discourages it, for our subset, we will treat f0000000 as a NOP. known as imni
(There are many other ways to form a NOP on this machine.) because the cc
Using a condition suffix like PL or MI for an instruction on the ARM is very analogous instruction reg
to preceding an instruction on the PDP-8 with an SMA or SPA, respectively. The only of a register. A
difference on the ARM is that since the condition is part of each instruction, only one the immediate
instruction needs to be fetched, rather than two. For example, the childish division the rotation thz
program given in section 9.7 uses an SPA prior to a JMP for the special case when the are non-zero.)
quotient is zero: the R2 register

0110/7510 SPA AD.
0111/5123 JMP L2

e 2
/..\ / .... \/

These two PDP-8 instructions are analogous to the BMI instruction (it branches when L110 00 1 01(
the PSR indicates minus, so it nullifies (treats like a NOP) the instruction when the
PSR indicates plus): I I I

I I I
I I I I
lI I I I

00000010/4a00003 BMI L2 I I I I

I I I -
As another example, the PDP-8 program in section 9.7 also uses an SMA prior to a I I I
JMP for deciding whether to go through the loop another time: I II  I -

+ -

0121/7500 SMA
0122/5112 JMP LI

As another exaj
the decimal cot

The analogous ARM instruction is BPL:

386 Verilog Digital Computer Design: Algorithms into Hardware



Lke | 00000020/5afffffb BPL Li

10.6.5 Immediate operands
The only practical way to put a constant value into the PDP-8's accumulator is to use a
memory reference instruction. This means that two memory locations must be accessed:
the one that contains the instruction and the one that contains the data.

instruction reg- Although the ARM does actually have memory reference instructions (which we are
r. Although the ignoring for now), the ARM provides a different way of working with constant values,
0000 as a NOP. known as immediate operands, that only requires one memory access. This is possible

because the constant is part of the instruction. In a data processing instruction, when
very analogous instruction register bit 25 is a one, OPB is an immediate constant, rather than the value
tively. The only of a register. Assuming that instruction register bits 11 down to 8 are zeros, the value of
iction, only one the immediate constant is given by instruction register bits 7 down to 0. (We will ignore
hildish division the rotation that the full-fledged ARM does when instruction register bits 11 down to 8
d case when the are non-zero.) For example, consider the ARM instruction that adds the constant one to

the R2 register without setting the PSR:

ADD R2,R2,1 mnemonic

e 2 8 2 2 0 0 1 hexadecimal
/. . \/ .. \ / \ /. \ /.

t branches when 1110 00 1 0100 0 0010 0010 00 00 00000001 binary
uction when the

I I I I I I
+- ir[7:0]==l so 'OPB is 1

I I I I I I + ir[l1:8] ignored here
I I I I I + ir[15:12] == 2 so 'RD is r[2]
I I I I + - ir[19:16] == 2 so 'OPA is r2]
I I I + - ir[20] == 0 so don't set psr

II  II +- ir[24:21]==4 so mnemonic is ADD'
SMA prior to a i.e., 'RD -- 'OPA + 'OPB

I I i.e., r[2] - r[2] + 1
l+ ir[25] == 1 so 'OPB is immediate
+ ir[27:26] 0 so it is data processing

ir[31:28] == 4'blllO so it executes

As another example, consider the ARM instruction that initializes the RI register with
the decimal constant fourteen:

aware RISC Processors 387



Ma  RRO1X,e0 
mnemonic -

MOV x~e mnemonic I
INI

e 3 a 0 1 0 0 e hexadecimal

1110 00 1 1101 0 0000 0001 0000 00001110 binary

l l l l l l l l +- ir[7:0]==14 so'OPB is 14 F
l l l l l I| l + ir[11:8] ignored here
l l lIl | | + ir[15:12] == 1 so 'RD is rl]
l l l l | + ir[19:16] ignored: not used byMOV
l | | | + ir[20] == 0 so don't set psr
l | | + ir[24:21] == 13 so mnemonic is MOV"
I F

l l i.e., 'RD - 'OPB
l l l i.e., r[l] - 14
+ ir[25] == 1 so 'OPB is immediate F3

+ ir[27:26] == 0 so it is data processing
+ ir[31:28] == 4'blllO so it executes

C.^W
F 17I

1(1-7 Miilti-evelp imnlpmpntatin nf thp ARXQilihcpt O." 
The multi-cycle ASM in figure 10-1, which follows the basic outline of the PDP-8's
ASM given in section 8.3.1.5, implements the fetch/execute algorithm for the ARM
instruction set described in section 10.6.

The state names are the same as the ones in the PDP-8's ASM, except for the execute
states. In the ASM for the ARM, state EODP occurs when a data processing instruction
(such as ADD or SUB) executes, and state EOB occurs when a branch instruction (B)
executes.

10.7.1 Fake SWI as a halt
The actual ARM does not have a halt instruction. Instead, it has a software interrupt
(SWI) instruction (efOOOOOO) which changes the mode from user mode to a supervisor
mode. Since we are ignoring the issue of modes, and since it is helpful to keep this
ASM as similar as possible to the ASM in chapter 8 for the purpose of Verilog test
code, we will treat the SWI as a halt. The operation of the SWI on the actual ARM is
much more complicated, as explained in appendix G.

I Figure 10-.

388 Verilog Digital Computer Design: Algorithms into Hardware



?B is 14
lere
'RD is rl]
iot used by MOV
2n't set psr
smonic is MOV"

Lmmediate
ata processing
executes

4 subset
ne of the PDP-8's
thm for the ARM

-pt for the execute
-essing instruction
ich instruction (B)

software interrupt
)de to a supervisor
elpful to keep this
)se of Verilog test
the actual ARM is

Figure 10-1 Multi-cycle ASMforARM subset.

-dware
RISC Processors 389



10.7.2 Fetch states 10.7.4 Da
State INIT initializes the program counter, halt and program status registers. The ma- State EODP h
chine will then proceed to state FI and to state IDLE. quested data 

into the destit
When a program executes, the normal sequence is to proceed through states Fl, F2, register.
F3A, F3B and one of the execute states. State F2 increments the program counter by
four (rather than by one) because the program counter refers to an address in terms of
eight-bit bytes but each 32-bit instruction is actually four bytes long. In a related way, 10.7.4.1 
when state F3A fetches an instruction from memory, the memory address is shifted Which kind o
over two bits to the right because the program counter is four times the required memory bits 24 down t
address.4 ing operations

tails in a fund

10.7.3 The condx function other 13-data-
tion is that the

The decoding (F3B) and executing (EODP, EOB or EOHLT) states for the ARM are tion register b
quite different than the analogous states for the PDP-8. First of all, every instruction on
the ARM has the potential of being conditional, which is why instruction register bits
31 down to 28 are reserved for this purpose. The first decision that occurs in state F3B 10.7.4.2 C
is whether the instruction should be nullified or not. On the actual ARM, this decision Using instruct
involves sixteen possibilities. Even though we are only going to implement four of processing ins
these (4, 5, e and f), it is prudent to isolate this detail in a function which we will refer 20 is zero, sta
to as condx(ir[31:28] ,psr). hand, if instru,

In the actual hardware, there will be some combinational logic that implements this state EODP he

function. The important observation is that whether an instruction is executed or is register. This 

nullified depends only on two things: instruction register bits 31 down to 28 and the data processin

current information in the program status register (which, in this implementation, only isolating detai

contains the N flag). Because these details have been isolated inside the condx func- the ARM, shoi

tion, the other twelve conditions (0-3, 6-d) not considered here could be implemented result to recor

fairly easily without having to change this ASM. conditional in
register proper

After recognizing that the condition for the instruction has been satisfied, state F3B register as '01
proceeds to decode the instruction. If it is a data processing instruction (instruction
register bits 27 and 26 equal zero), the ASM proceeds to state EODP. If it is a branch
instruction (instruction register bits 27 down to 25 equal 5), the ASM proceeds to EOB. 10.7.4.3 
If it is a SWI instruction, the machine proceeds to the PDP-8 like state EOHLT for the The use of m,
purpose of communicating with the Verilog top-level module that will test this ma- details require
chine. (As mentioned above, the actual ARM would do something more complicated
for SWI.)

allows us to de
4 The reason for this inconsistency only becomes apparent with some of the instructions we are ignoring, having to meni
such as LDR and STR, that use byte-sized data in memory.

390 Verilog Digital Computer Design: Algorithms into Hardware



10.7.4 Data processing
sisters. The ma- State EODP has two actions that it must perform. First, it needs to perform the re-

quested data processing using the operands ('OPA and 'OPB) and to store this result
into the destination register ('RD). Second, it needs to deal with the program 

,h states status
Fl, F2, register.

,ram counter by
Iress in terms of
[n a related way, 10.7.4.1 The dpfunction
Idress is shifted Which kind of data processing occurs in state EODP depends upon instruction register
equired memory bits 24 down to 21. In this implementation, we are only considering three data process-

ing operations (ADD, SUB and MOV). Once again, it is advisable to isolate such de-
tails in a function, which we will refer to here as dp, so that the implementation of the
other 13-data-processing operations will be straightforward. The important observa-
tion is that the result of the data processing only depends on 'OPA, 'OPB and 

or instruc-
the ARM are tion register bits 24 down to 21.

ry instruction on
tion register bits
-urs in state F3B 10.7.4.2 Conditionala ssignment of par
AM, this decision Using instruction register bit 20, the programmer can choose whether or not a data
kplement four of processing instruction will modify the program status register. If instruction register bit
ich we will refer 20 is zero, state EODP leaves the program status register the way it is. On the other

hand, if instruction register bit 20 is a one (meaning the mnemonic has an "" suffix),
implements state EODP 

this has a conditional oval which assigns a new value to the program status
is executed register. This 

or new 
is program status register value is a function (f) of the unconditional

wn data 
to 28 processing 

and the that occurs in this state (dp (i r [ 2 4: 211 , ' OPA, ' OPB) ). Again,
isolating 

ementation, details in 
only a function will make it easier to implement the full capabilities of

the ARM, 
the should 

condx you 
func- choose to do so. For now, f simply masks off the sign bit of the

result to 
[b e record 

implemented the N flag. This assignment to the program status register must be
conditional in state 'EODP because the information to compute the new program status
register properly might not exist after that clock cycle (i.e., 'RD might refer to the same

tisfied, state F3B register as 'OPA or 'OPB).
:tion (instruction
'. If it is a branch
proceeds to EOB. 10.7.4.3 Use of macros
te EOHLT for the The use of macros ('PC, 'RD, 'OPA and 'OPB) helps conceal many of the tedious
will test this ma- details required to implement the ARM. For example:
nore complicated

'define RD r[ir[15:12]]

allows us to describe the destination register for a data processing instruction without
ions we are ignoring, having to mention the instruction register bits.

Iware RISC Processors 391



More importantly, macro definitions allow simple descriptions of the operands of the 10.7.5.1 A
data processing instructions. For example, from the short explanation in section 10.6. 1, The reason fo
one might think that 'OPA would simply be defined as r [ i r [ 19: 16 ] ], but there are reside at byte
some other details to consider. For example, when 'OPA is supposed to be what the corded in the I
programmer refers to as R15, this is in fact the program counter. According to the can choose to
specification of the ARM instruction set (appendix G), when R15 is the first operand of
a data processing instruction, the value of R15 used in the computation will be eight
larger than the value the program counter contained when 10. 7.5.2 

the instruction A
was fetched.

At the time 'OPA is evaluated, the program counter has already been incremented by The reason for
four in state F2. Therefore, if the programmer wants to use R15 as 'OPA, the value used fications refen
in state EODP should be r [ 15 + 4. On the other hand, if the programmer wants to use -2 in a branch
a different register, its value should not be incremented. -2 will be mu]

incremented b
To distinguish between R15 or another register inside a macro requires using the Verilog instruction (ea,
conditional operator ( ? : ). This feature of Verilog, which acts like the similar feature (-8 + 4 + 4 ==
of C, works with three values: the first value occurs before the question mark, the
second value occurs between the question mark and the colon, and the third value
occurs after the colon. If the first value is equal to one, the result is the second value; 10.7.5.3 Si
otherwise the result is the third value. From a hardware standpoint, the Verilog condi- The offset tim
tional operator is like a mux, where the select is the first value. In this particular situa- instruction reg
tion, the expression ir [ 19: 16 ] ! =15 chooses between two different results: (ir[23]) mu

ferred to as sig
the multiplicat

'define OPA (ir[19:16]!=15?r[ir[19:16]]:r[ir[19:16]]+4)

l'define OFFSE
As in C, parentheses are a good idea to avoid creating precedence problems when
Verilog substitutes such a complicated macro.

The definition of 'OPB is even more involved because instruction register bit 25 al- 10.7.6 Ver
lows the programmer to choose between an immediate value or a register value. The Throughout thi
same problem with R15 mentioned above also must be considered: For simple mac

Verilog are equ
the hardware. II

'define OPB (ir[25]?ir[7:0]:(ir[3:0]!=15? r[ir[3:0]]:r[ir[3:0]]+4)) to understand,;

The last section
In fact, there are other issues about 'OPB that we are ignoring here. (The actual ARM documentation
allows rotation of 'OPB, which would require a more complicated expression for 'OPB.) a bit of Verilog

that Verilog im
that should be c

10.7.5 Branch textual langual
State EOB performs the relative branch by adding four plus four times the signed offset
(from the low-order 24 bits of the instruction register) to the program counter.

392 Verilog Digital Computer Design: Algorithms into Hardware



)erands of the 10.7.5.1 Multiplying by four
ection 10.6.1, The reason for multiplying by four is that instructions on the ARM are required to
, but there are reside at byte addresses that are divisible by four. The low-order two bits are not re-
o be what the corded in the branch instruction in order to maximize the distance that a programmer
:ording to the can choose to branch with the available bits of the instruction register.
rst operand of
l will be eight 10.7.5.2 Adding four in the 
iw as multi-cycle 

fetched. implementation
The reason 

icremented for adding 
by four in this multi-cycle implementation is to adhere to the speci-

fications referred 
the value to 

used in appendix G. The ARM documentation specifies that an offset of
~r -2 in a branch 

w ants instruction 
to use (eafffffe) means branching back to itself. Remember that the

-2 will be multiplied by 4 to yield -8. By state EOB, the program counter has been
incremented by 4. To leave the program counter the same as it was when the branch

[ng the Verilog instruction (eafffffe) was fetched, an additional 4 must be added to the program counter
similar feature (-8 + 4 + 4 == 0).
[ion mark, the
he third value
second value; 10.7.5.3 Sign extension macro
Verilog condi- The offset times four needs to be treated as a signed 32-bit value. The offset in the
articular situa- instruction register is only 24-bits wide (bits 23 down to 0). This means the sign bit
results: (ir [ 23 ] ) must be duplicated several times on the left, in a process commonly re-

ferred to as sign extension. The following macro performs both the sign extension and
the multiplication by four using the Verilog concatenation operator:

]+4) 

'define OFFSET4 {ir[23],ir[23],ir[23],ir[23],ir[23], ir[23],ir[23:0],2'bOO)
roblems when

ister bit 25 al- 10.7.6 Verilog for the multi-cycle implementation
ster value. The Throughout this book, algorithms have been described using ASM charts and Verilog.

For simple machines, like the childish division examples of chapter 2, the ASM and the
Verilog are equivalent, and either notation gives a completely accurate description of
the hardware. It is a theme of this book that both ASM charts and Verilog are important
to understand, and that each notation offers the designer useful insights.
The last section illustrates the proper use of an ASM in a complex design: to provide

he actual ARM documentation so people can see the "big picture." The last section actually uses quite
sion for 'OPB.) a bit of Verilog notation to achieve the proper level of abstraction. This section shows

that Verilog implements not only what the ASM describes but also fills in the details
that should be omitted from the ASM. Verilog can do all this reasonably because it is a
textual language.

ies igned offset
Counter.

are RISC Processors 393



The previous sections use many paragraphs to describe the data processing function, In a similar wa
dp. Such a description is informal and therefore cannot be synthesized into hardware. tion for a parti
Although such details could have been put formally into the ASM, they would have
made the ASM considerably more complicated. Ultimately, such a complex ASM would
lead us down the wrong path for the performance issues (such as pipelined and/or function

superscalar design) described later in this chapter. In Verilog, we can be precise but still input [
input [

set aside such details because they can occur in a different part of the source code (the
begin

function definition). Although such thinking is commonplace in modem software de- if (c
sign, hardware designers are only beginning to realize the power of the notation avail- con
able in Verilog. else

con
In the case of the dp function, we are only implementing three of the sixteen possible

else
operations: con

else
con

function [31:0] dp; end
input [3:0] opcode; endfuncti
input [31:0] opa,opb;
begin

if (opcode == 4'bOO10) Again, isolatin
dp = opa - opb; ing operations.

else if (opcode == 4'bO100) helpful as we 
dp = opa + opb;

else if (opcode == 4'bllOl) For our subset
dp = opb; ter. The functi

else
begin

dp = 0; function
$display("other DP instructions..."); input [

end begin
end f = d

endfunction end
endfuncti

This function formally describes the SUB, ADD and MOV instructions. Except for the Generating all
$display statement, this function could be synthesized into the combinational ALU isolating it her
required in the actual hardware. (The $ display statement wams us if we attempt to
execute a data processing instruction that is one of the 13 not implemented here.) This A great deal o
function can be reused as we improve the performance of the design. Because these mentioned in t
details have been isolated into a function, it is easy for a designer to know where to
modify the Verilog code in order to implement the remaining 13 operations.

394 Verilog Digital Computer Design: Algorithms into Hardware



mssiinng function, In a similar way, we can define the Verilog function that determines whether the condi-
 into hardware. tion for a particular instruction to execute is true:
[ey would have
lex ASM would
ippiepleilniende and/or function condx;

precise but still input [3:0] condtype;

ource code (the input [31:0] psr;
begin

rmn  software de- if (condtype == 4'blllO)
 notation avail- condx = 1;

else if (condtype == 4'bOl00)

s;iixteen possible condx = psr[31];
else if (condtype == 4'bO101)

condx = psr[31];
else

condx = 0;

__7 end
endfunction

Again, isolating this in a function makes it easy to know how to implement the remain-
ing operations. Also, as will be shown later, defining this function will prove extremely
helpful as we use more sophisticated techniques to improve performance.

For our subset of the ARM, we only implement the N flag in the program status regis-
ter. The function which creates this information from the result of the ALU is trivial:

function [31:0] f;
input [31:0] dpres;
begin

f = dpres & 32'h80000000;
end

endfunction

.s.E xcept for the Generating all bits of the program status register is considerably more complicated, but
ibinational ALU isolating it here helps some future designer whose job might be to do so.
if we attempt to

-nted here.) This A great deal of the abstraction needed for this design comes from the Verilog macros
i Because these mentioned in the last section. For this multi-cycle implementation, these are:

know where to
ations.

wvare RISC Processors 395



'define PC r[15] three stages a
'define RD r[ir[15:12] ]
'define OPA (ir[19:16]!=15?r[ir[19:16?:r[ir[19:16]]+4) considers ins
'define OPB (ir[25] ?ir[7:0O]:(ir[3:0O]!=15?r[ir[3:0O] ]:r[ir[3:0O] ]+4) ) trivial and ha
'define OFFSET4 {ir [23], ir [23], ir [23], ir [23], ir[23], ir [23], ir [23:0O], 2 bOO} set includes e

sidering the n
For example, the definition of 'OPA says if the register number given in instruction will impleme
register bits 19 down to 16 is not the program counter ( ! =15), use the value of that this chapter, t
register; otherwise (= = 1 5) use the program counter + 4. This decision is required here As in chaptei
because of the definition of the ARM instruction set. The Verilog conditional operator ir2). The yc
allows for compact, if somewhat cryptic, code for the decision. Recall that 'OPA will and the oldest
be substituted back where required in the code automatically by Verilog, and so the with the fillin
designer using Verilog can usually ignore these details. A designer using only an ASM scribe a NOI
would have been required to put all this detail in the ASM. pipelined ASI
Another advantage of using Verilog here is that as we proceed to a more sophisticated
technique for higher performance (such as pipelining), we can change the definition of
the macros to match the more sophisticated technique, but keep the macro name the
same. This is good, because the concept behind the macro is the same, even though its
implementation will be different in later sections of this chapter. Given the above mac-
ros and functions, the actual translation of the ASM to implicit style Verilog is simple
and is left as an exercise.

0
10.8 Pipelined implementation
The problem with the multi-cycle implementation is that it requires five cycles per
instruction. To improve this performance, we can use a pipelined approach. There are ir1 r
several reasons why a pipelined implementation of our ARM instruction subset will be 0 PCir2 ---
easier than the pipelined PDP-8 discussed in chapter 9. First, the ARM has a RISC
instruction set which was designed to be pipelined. Second, we are neglecting memory
reference instructions, and so the issues 0~ IIIX

of operand fetch and data forwarding may be
ignored here. Third, we can reuse the functions defined above without modification.
Fourth, the Verilog macros given earlier can easily be redefined to match the needs of
the pipelined implementation.

10.8.1 ASM for three-stage pipeline
The original versions of the ARM (referred to as the ARM 1 -ARM6) use a three-stage
pipeline, but some of the more recent versions of the ARM use a five-stage pipeline.
We will implement a three-stage pipeline because it is easier, and is similar to the three-
stage examples in chapter 9. Also, Figure 

since 10-
the original ARM instruction set was designed

for a three-stage pipeline, implementing a pipeline of that size is most natural. The 5Although the Al
other than NOP, f

396 Verilog Digital Computer Design: Algorithms into Hardware



three stages are referred to as fetch, decode and execute. For our subset, decoding only
considers instruction register bits 27 down to 24. The logic for decoding our subset is

f4) trivial and hardly warrants its own separate pipeline stage. The full ARM instruction
i[ir[3:0 +4) )
3:01 ,2'bOO} set includes eleven categories, and so full decoding is rather involved, especially con-

sidering the memory reference instructions. Therefore, for our simple ARM subset, we
will implement a three-stage pipeline but with the middle stage doing nothing. Later in

en in instruction this chapter, the middle pipeline stage will take on an important role.
the value of that
a is required here As in chapter 9, it will be necessary to have multiple instruction registers (irl and
additional operator ir2). The youngest instruction is in memory, the middle-aged instruction is in irl
dl that 'OPA will and the oldest instruction is in ir2. Also, as in chapter 9, we need to use NOPs to deal
brilog, and so the with the filling of the pipeline after a branch instruction. There are many ways to de-
ing only an ASM scribe a NOP in ARM machine language. The simplest5 is f00000. Here is the

pipelined ASM for our ARM subset:

lore sophisticated
e the definition of
,m acro name the
e, even though its
En the above mac-
Verilog is simple

0 condx(ir2[31:25],psr) II 1
&&((ir2[27:26]==O&&r2[15:12]== 5) i

I I ir2[27:25]==5) I

es five cycles per
)proach. There are ir- m['PC> .fOOOOOO0O0ir2 

vIr, ii
tion subset will be
ARM has a RISC
eglecting memory
orwarding may be
hout modification.
match the needs of

i) use a three-stage
[ive-stage pipeline.
similar to the three- Figure 10-2. PipelinedA SMforARM subset.
)n set was designed
most natural. The 5 Although the ARM's designers may someday redefine the meaning of this machine code to be something

other than NOP, f000000 is convenient since it is easy to recognize

rdware RISC Processors 397



Rather than translate this ASM as is into Verilog, the following sections discuss some struction). Th
interesting issues that it raises. These issues, such as Mealy ASMs and the non-block- given in sectii
ing assignment, have been touched upon in earlier chapters, but with an example of this until it reach
size these issues become more important. execution of t

on the PDP-8

10.8.2 the program!
Mealy ASM general, the V

There are several reasons why the pipelined ARM needs to be designed using a Mealy that instructi(
ASM. As in the examples in chapter 9, a decision has to be made and an assignment has status register
to be scheduled in a single cycle because the result of the assignment must be available pleted its exe
in the next clock cycle. With the PDP-8, this typically arises with assigning a value to ecutes, the in!
the accumulator having decided already that a TAD instruction is supposed to execute.
On the ARM, this same issue arises with assigning a value to the 'RD macro (which The "normal'
could be any of the sixteen user registers), having decided a data processing instruction gram counter
is supposed to execute. The decision (that recognizes the instruction) and the resulting program cour
assignment occur in the same clock cycle. Besides the p;
The ARM's conditional execution feature offers an additional reason why a Mealy and the progi
approach is required. Often, a data processing instruction that assigns a new value to instruction in
the program status register (such as SUBS) will execute just before a subsequent in- cases:
struction that depends on this result in the program status register (such as BMI). The
decision whether to execute the subsequent instruction cannot occur earlier than the
clock cycle when that instruction is in the final stage of the pipeline because, until that
stage, the program status register does not reflect the result of the preceding instruc-
tion. If the condition is satisfied, the subsequent instruction must schedule whatever
assignment(s) are associated with its execution in this same clock cycle; therefore a
Mealy approach is mandatory.

10.8.3 Two parallel activities Except for th
There are two parallel activities that occur in state F1. The first determines what will be section 10.7.
in the instruction registers and the program counter in the next clock cycle. The second, added to the
which is similar to the corresponding part of the ASM in section 10.7, deals with de- work with a t
coding and executing the instruction in the final stage of the pipeline. itself is that 
The first parallel activity in state Ft (determination of what will be in the instruction line, the pros
registers and the program counter) has two cases. Let's refer to these as the "B/R15" greater than 
case (for branch or modifying the program counter) and the "normal" case (increment so adding it t(
program counter). The "B/R15" case is when the instruction in the final the same brat
stage of the pipeline is an instruction that will execute (as indicated by
condx (ir2 [ 31: 2 8 , psr) ) and that is either a branch instruction (bits 27 down to
25 equal to 5) or a data processing instruction that modifies r [ 15] (since r [ 15 ] is
the same as the program counter, such an instruction is effectively like a branch in-

398 Verilog Digital Computer Design: Algorithms into Hardware



ns discuss some struction). The "B/R15" case is sim-ilar to the JMP instruction on the pipelined PDP-8
I the non-block- given in section 9.5, except that on the ARM the branch instruction cannot be executed
ie xample of this until it reaches the last stage of the pipeline. On the PDP-8, it is possible to begin

execution of the JMP when it reaches the middle stage of the pipeline because the JMP
on the PDP-8 is unconditional. Since the branch on the ARM is conditional, the bits in
the program status register must be valid before the decision to branch can occur. In
general, the program status register will not be valid for a particular instruction until

d using a Mealy that instruction reaches the final stage of the pipeline. This is because the program
Xa ssignment has status register might have been changed by the preceding instruction, which only com-
iust be available pleted its execution after the preceding clock cycle. If the "B/R15" instruction ex-
gning a value to ecutes, the instruction registers are filled with NOPs.
osed to execute.
D macro (which The "normal" case decides what will be stored in the instruction registers and the pro-
ssing instruction gram counter for situations other than the "B/R15" case. In the "normal" case the
ind the resulting program counter is incremented by four, and the instructions move down the pipeline.

Besides the part of the ASM that decides what will be stored in the instruction registers
n why a Mealy and the program counter, there is the part of the ASM that decodes and executes the
s a new value to instruction in the final stage of the pipeline. In this part of the ASM there are five
a subsequent in- cases:
ch as BMI). The
earlier than the

-cause, until that ,nullify" psr prevents this instruction from executing
"dp set" execute data processing instruction that modifies psr

-eceding instruc- "dp no set" execute data processing instruction that leaves psr alone
hedule whatever 'ir2 is B" modify R15
ycle; therefore a "SWI set halt flag

Except for the "ir2 is B" case, these are identical to the multi-cycle ASM given in
ines what will be section 10.7. In the "ir2 is B" case, four times the sign extended offset ('OFFSET4) is
(cle. The second, added to the program counter. Here is where we see that the ARM was designed to
7, deals with de- work with a three-stage pipeline. The reason that an offset of -2 means branch back to

itself is that by the time the branch instruction has reached the final stage of the pipe-
n the instruction line, the program counter will already have been incremented twice, i.e., it is eight
- as the "B/R15" greater than when the branch was fetched. When the offset is -2, 'OFFSET4 is -8 and
' case (increment so adding it to the program counter in this case puts the program counter back to where
Dn in the final the same branch instruction will be fetched again.
s indicated by
(bits 27 down to

(since r [ 15 ] is
like a branch in-

ware RISC Processors 399



10.8.4 Proper use of <= Continued
One of the main themes of this book is the proper use of the non-blocking assignment el
statement. A common mistake with non-blocking assignment is to attempt to assign b
more than one value to a register during one clock cycle. To avoid making this mistake,
a designer needs to check all possible paths through the ASM. Since there are two paths
through one-half of the ASM and there are five paths through the other half that ex-
ecutes in parallel, there are, in theory, ten paths for the designer to check, but of these, ei

two are contradictory. It is impossible for ir2 to contain a branch or data processing if

instruction that modifies R15 in the same clock cycle that it contains an SWI instruc- bs

tion. Also, when "ir2 is B," the "normal" case cannot occur. When these cases are
eliminated, we are left with eight cases to consider. The "B/R15" case might occur in
parallel with either the "nullify," "dp set," "dp no set" or "ir2 is B" case. Alternatively,
the "normal" case might occur together with either the "nullify," "dp set," "dp no set"
or "SWI" case.

The "B/R 15" and "normal" cases are the only places where the instruction registers are
scheduled to be assigned, and so there is no problem with them. The "dp set" case is the
only place where the program status register is scheduled to be assigned a value, and so
it is fine. Also, the "SWI" case is the only place where the halt flag is scheduled to be
assigned a value; thus we do not need to be concerned with it. The danger arises with
the program counter and 'RD, since 'RD could be r [ 15 ], which is the program counter.
To avoid this danger, we must leave the program counter alone in the "B/R15" case,
because the program counter is modified in parallel by the "dp no set," "dp set" or "ir is
B" cases of this Mealy ASM. end

end

10.8.5 Verilog for the pipelined implementation Some of the m
Here is a partial listing of the Verilog translation for the ASM from section 10.8. 1: of this pipelin

'define RD
forever 'define OPA

begin 'define OPB

@(posedge sysclk) enter_new state('Fl); 'define OEFSE

else
begin Interestingly, I
if (condx(ir2[3l:28],psr) && mind, the defii
((ir2[27:25]==3'blOl)
|| (ir2[27:261==2'bOO&&ir2[15:12]==4'bllll))) tation. This si
begin // B/R15" tioned. The va
irl <= (posedge sysclk) 32'hfOOOOOO; line is, by defi
ir2 <= (posedge sysclk) 32'hfOOOOOO;

end

400 Verilog Digital Computer Design: Algorithms into Hardware



P.-

I
Continued

ing assignment else
:-emptt  to assign begin // "normal"
n.ig  this mistake, 'PC <= @(posedge sysclk) 'PC + 4;
re are two paths irl <= (posedge sysclk) m['PC>>2];

er half that ex- ir2 <= (posedge sysclk) irl;

1k, but of these, end

Jata processing if (condx(ir2[31:28],psr))
begin

LnI nS WI instruc-
if (ir2[27:26] == 2'bOO)

these cases are begin // "dp set" or dp no set"
might occur in 'RD <= @(negedge sysclk)
Alternatively, dp(ir2[24:21]'OPA'OPB);

et," "11ddpp no set" if (ir2[20]) //"dp set"
psr <= @(posedge sysclk)

f(dp(ir2[24:21],'OPA,'OPB));
ionn  registers are end
) sete"' case is the else if (ir2[27:25] == 3'blOl) //"ir2 is B"
I a value, and so 'PC <= @(posedge sysclk) 'PC + 'OFFSET4;
scheduled to be else if (ir2[27:24] == 4'bllll)//"SWI"
iger arises with halt <= @(posedge sysclk) 1;

rporoggrraam countterr.. else

 "B/R1I5" case, $display("other instructions...");
end

"'dp set" or "ir iiss
end

end

Some of the macros need to be redefined to take into account that i r 22 is the fiinall  stage
catiion 10.8.1: of this pipeline:

',define  RD r[ir2[15:12]]
',define OPA r[ir2[19::161]]1
',define  OPB (ir2[25] ? ir2[7:0] : r[ir2[ 3[3:0:0111])
'define OFFSEETN4 {iir2 [233]] ,,  ir2 [23]] ,,  ir2 [231] ,,  ir2 [231] ,,  iir2  [231] ,,  ir2 [231] , , ir2 [23 :001 ],  2  ''bOO)}

Interestingly,,  because the original ARM was designed with a three-stage pipeline in
mind, the definition of ''OPA and 'OPB  are simpler than for the multi-cycle implemen-
tation. This simplification occurs since r [ 1 5 ] does not have to be explicitly men-
tioned.  The value of r [ 1 5 ] at the time the instruction is in the fiinall  stage of the pipe-
line is, by definition, the correct value to use.

vare I RISC Processors 401

i



Execution of a data processing instruction involves non-blocking assignment to 'RD, 10.9.1 M
which is a macro that substitutes the subscripted Verilog array, r [ ir2 [ 15 :12] ]. From a struci
This non-blocking assignment therefore uses negedge rather than posedge to be guished from
portable for the reasons explained in section 6.5.2. (Remember that, in this pipelined and pipelined
implementation, ir2 changes every clock cycle.) multiple instr

to have two 
execute per c

10.9 Superscalar implementation A consequent
The pipelined implementation given in the last section has a speed that approaches (but cated. If then
never quite reaches) one clock cycle per instruction. Because ARM data processing operands in c
instructions have three register operands ('RD, 'OPA and 'OPB), one basic computa- behavioral sta
tion, such as incrementing r [ 2 , can be performed per clock cycle. Although this can way we did ii
be up to three times faster than the pipelined single-accumulator design described in tion will be e:
chapter 9, it still is certain to be no better than the slowest special-purpose designs in ferred to as i
chapter 2 (such as section 2.2.2). Even for a simple algorithm like childish division, it
is often possible for more The two resu

than one computation to occur in parallel (e.g., incrementing
r [ 2 ] in parallel with subtracting behavioral 

from r [ 1 ] ). A sta
pipelined general-purpose processor

only works because of quite a bit of parallel activity in the implementation of fetch/ A register file
execute. Even so, a pipelined general-purpose computer cannot exploit the parallelism sive than the
in an algorithm. Such parallelism can be exploited by special-purpose hardware (such tional comple
as section 2.2.7). will see later 

Since the designer things.
of a general-purpose computer can never be certain how fast is "fast

enough," it would be desirable if the general-purpose computer could execute more
than one instruction in parallel. Such an approach, known as a superscalari mplemen- 10.9.2 Ini
tation, is an extension to the pipelined approach. Superscalar implementation is con- In order to kec
siderably more complex than the pipelined approach because the hardware itself must with as many
take seemingly sequential instructions and recognize when it is permissible for them to ample, if our
execute in parallel. In essence, some of the intelligence and skill of the hardware de- sary to load b
signer (as illustrated by the design alternatives of chapter 2) must be placed inside the 'PC, respectix
hardware itself. Because the hardware of a superscalar general-purpose computer will
never have as much information about the software algorithm as the designer of a The single-po
special-purpose computer has about the ASM, a superscalar general-purpose machine and pipelined
will not be as fast as the best special-purpose hardware. Also, the complexities of per clock cyc]
superscalar design means its hardware cost may be many times the cost of the equiva-
lent but faster special-purpose machine. However, the economies of scale for general-
purpose computers have made superscalar processors viable.

402 Verilog Digital Computer Design: Algorithms into Hardware

-



ignment to 'RD, 10.9.1 
ir2 [15:12] Multiple-port 

]. register file
From 

posedge a structural 
to be standpoint, a superscalar general-purpose processor can be distin-

in this guished 
pipelined from the slower design alternatives given earlier in this chapter (multi-cycle

and pipelined) because the superscalar machine needs multiple ALUs for executing
multiple instructions per clock cycle. The simplest case is to imagine that we can afford
to have two ALUs, and therefore, under the best circumstances, two instructions can
execute per clock cycle.

A consequence of having multiple ALUs is that the register file must be more 
ta pproaches sophisti-

(but cated. If there are two ALUs, each of which might have to be fed two independent
data processing operands in each clock cycle, we need a register file with four read ports. 
basic computa- From a

behavioral standpoint, we will refer to the operands of the final stage of the pipeline 
lthough the

this can way we did in the last section ('OPA and 'OPB). However, sometimes another 
;ign described instruc-

in tion will be executing in parallel. The operands of this parallel instruction will 
irpose be 

designs re-
in ferred to as 'POPA and 'POPB.

ildish division, it
.g., incrementing The two results of the two ALUs need two write ports into the register file. From a
urpose processor behavioral standpoint, we will refer to these as 'RD and 'PRD.
bntation of fetch/ A register file that has four read ports and two write ports is considerably 
it the more 

parallelism expen-
sive than the register file used in the pipelined implementation. There 

hardware will be addi-
(such tional complexities with r [ 15 ] because it serves the role of the program counter. We

will see later that the program counter in a superscalar design does some non-intuitive
how fast is "fast things.
Id execute more
calari mplemen- 10.9.2 Interleaved memory
nentation is con- In order to keep a superscalar processor going 
iware at 

itself full 
must speed, it is necessary to provide it

with as many new instructions as it is capable 
;sible for of 

them executing 
to per clock cycle. For ex-

ample, if our machine is to execute 
he hardware two instructions 

de- per clock cycle, it will be neces-
sary to load both irl and ir2 with instructions 

placed inside from 
the memory addresses 'PC+4 and

'PC, respectively.
se computer will
ie designer of a The single-port memory shown in figure 10-3, which can be used for the multi-cycle
)urpose machine and pipelined implementations, does not allow more than one instruction to be fetched
complexities of per clock cycle:

ist of the equiva-
cale for general-

vare RISC Processors 403



-

Unfortunatel)
m[O] first instruction example:
m[4] second instruction

m[8] third instruction

m[1 2] fourth instruction
It might appe'
approach wol

Figure 10-3. Non-interleaved memory.
tions execute
time for both

Although a dual-ported memory for instructions would allow fetching of two instruc-
tions per clock cycle, such a memory is expensive. A cheaper alternative is to use an
interleavedm emory. A simple interleaved memory stores half of the instructions in one
bank and the adjacent instructions in another:

m[O] first instruction second instruction m[4]

m[8] third instruction fourth instruction m[12]

Figure 10-

Figure 10-4. Interleaved memory.
Instead of dat
only one instr

In other words, two separate memories act as one. This approach is sufficient only other words, i
because when the superscalar fetch/execute algorithm wants two instructions, they will that after exe(
always reside in separate banks. One of the instructions comes from an address divis- independent i
ible by eight; the other instruction will be plus or minus four of that address. From a
behavioral standpoint, we will simply use the same kind of Verilog array notation for Some prograr

the two instructions that are fetched in parallel: m [m PC+4) >>2 ] and m parallel:
[ PC>>2]

10.9.3 Examples of dependencies
If all instructions in a program were independent of each other, such as:

SUB R1,R1,R4 The machine
ADD R2,R2,1 executes. In st

(simple pipeli
designing a superscalar machine would be fairly easy. For example, the above two the order the ]
instructions could be fetched from the interleaved memory in parallel, presented to the (unlike our su
two separate ALUs (for subtraction and addition, respectively) in parallel and their
results could be written back to the register file in parallel.

404 Verilog Digital Computer Design: Algorithms into Hardware



Unfortunately, in real programs, instructions are often dependent on each other. For
example:

SUB R2,R1,R4
ADD R2,R2,1

It might appear that data forwarding (of RI minus R4) could be helpful here. Such an
approach would be algorithmically correct but would be slow. To make these instruc-
tions execute in parallel, the clock period would have to be slow enough allow enough
time for both the ADD and the SUB:

of two instruc-
ive is to use an forwarded

value
tructions in one

R1 ALU ALU
doing doing new R2

R4 SUB ADD

slower clock period

Figure 10-5. Forwardingr esults of dependent instructions slows clock.

Instead of data forwarding in a situation like this, it is better for the machine to execute
only one instruction per clock cycle. At least this way, the clock cycle remains fast. In

, sufficient only other words, it behaves like the simple pipeline approach of section 10.8. The hope is
ctions, they will that after executing these two instructions sequentially, the machine will fetch some
n address divis- independent instructions (like the ones shown earlier) that it can execute in parallel.
address. From a Some programs have combinations of instructions that simply cannot be executed in
-ray notation for parallel:
im['PC>>2].

SWI
ADD R2,R2,1

The machine is supposed to halt (in our subset, at least) before the ADD instruction
executes. In such a situation, we have to revert back to a one instruction per clock cycle
(simple pipeline) approach, which allows the machine to process the SWI in exactly

~t,h e above two the order the programmer intends. On a machine that actually implements interrupts
,p resented to the (unlike our subset), exact processing of interrupts and similar issues are significant.
parallel and their

ware RISC Processors 405



A very common problem that occurs with superscalar design is that we cannot be cer- warding of a
tain, at the time when we have the hardware resources for doing so, whether we are process could
supposed to execute an instruction (such as ADDPL): been renamed

renamed in ar
SUBS R1,R1,R4 To implement
ADDPL R2,R2,1

regval, w.
The SUBS instruction will modify the program status register, speculative 

but ex
the ADDPL instruc-

tion needs to know that new program status information to which 
decide indicat

whether to execute.
If these instructions only executed one per clock cycle, there Verilog, 

would these
be no difficulty.

Also, if it were not for the "S" and "PL" suffixes on the mnemonics, there would be no
problem with executing them in parallel during the same clock cycle. Although we
could revert back to a simple pipeline approach (one instruction per clock cycle), the
point of superscalar design is to maximize speed.

It might be tempting to try "program status forwarding" in a case like this. Such an It is interestin
approach would be algorithmically correct, but would have the undesirable side effect quired becaus,
of doubling the propagation delay (the ADD cannot start until the SUB completes). renamed regis
This would mean the clock cycle of the machine would be twice as long, which would
more than negate any advantage of our attempt at superscalar design. El
10.9.4 Speculative execution
In contrast to such a flawed approach, the typical superscalar implementation uses a When an insti
technique, known as speculative execution, to solve the problem of not knowing whether section 10.9.3
an instruction that could execute in parallel is supposed to execute. For most instruc- this will cause
tions on a RISC machine, the only irreversible consequence of executing that instruc- On 
tion the other 

is the I
storage of its result back in the register file. Speculative execution means we assigns the de

compute the result of an instruction at a time when it is uncertain whether or not that assignment 
instruction su

will execute, but at that time we do not store the result back in the register renval.
file.

10.9.5 Register renaming
Instead, we put the result of an instruction that is being executed speculatively 10.9.5.1 F

in a
rename register. Such a register has the ability, at a later time, to take on the role of any Even though
of the user registers in the machine. In a later clock cycle, if the machine discovers that understand at f
the instruction that executed speculatively in the previous clock cycle was not sup- which has beei
posed to execute, the contents of the rename register can simply be discarded, and it be scheduled
will be as though the instruction never executed. If the machine discovers that the assignments di
instruction was supposed to execute, the rename register takes on the role of the desti- renaming and
nation register. For our simple implementation, this will be very much like data for- aside our goal

some simple s

406 Verilog Digital Computer Design: Algorithms into Hardware



we cannot be cer- warding of a single value. In 
, whether a more 

we complicated 
are superscalar design, the renaming

process could be much more sophisticated because every register in the file might have
been renamed. Our simple implementation guarantees that at most one register will be
renamed in any given cycle.

To implement this, there will have to be three components of the renameable register:
regval, which indicates its 32-bit value, regtag, which indicates its identity if
speculative 

zA DDPL instruc- execution succeeds (since it could be any of the registers) and regcond,
hether to execute. which indicates the condition upon which the instruction is supposed to execute. In
I be no difficulty. Verilog, these are declared as:
there would be no
cle. Although we reg [31:0] regval;
clock cycle), the reg [4:0] ren tag;

reg [3:0] ren-cond;

like this. Such an It is interesting to note that ren-tag is five, 
sirable rather 

side than 
effect four, bits wide. This is re-

quired because, in addition to the sixteen user registers, 
SUB completes). we need to indicate when the

renamed register is not valid. To do so, the following 
Dng, constant 

which would is defined:

1.

I define INVALID 16

Imentation uses a When an instruction cannot be executed speculatively (as in the SWI example from
knowing whether section 10.9.3), the machine assigns 'INVALID to rentag. In the next clock cycle,
For most instruc- this will cause ren_val to be ignored.
ating that instruc-
ecution On the 

means other 
we hand, when an instruction can be executed speculatively, the machine

assigns the destination 
hether or not register 

that number to rentag, the condition upon which that
assignment 

ack in succeeds 
the register to rencond and the potential new value of that register to

renval.

Speculatively in a 10.9.5.1 Firsts pecial-purposer enaming example
on the role of any Even though register renaming and speculative execution may appear difficult to
ine discovers that understand at first, they are simple extensions to the idea of the non-blocking assignment
tcle was not sup- which has been discussed in earlier chapters. It is still true that only one assignment can
discarded, and it be scheduled for a particular register during a particular clock cycle and that such

liscovers that the assignments do not take effect until the next clock cycle. In order to see how register
role of the desti- renaming and speculative execution relate to concepts in earlier chapters, let us set

uch like data for- aside our goal of implementing the general-purpose ARM for a moment and consider
some simple special-purpose machines that illustrate these same concepts. In other

ware
RISC Processors 407



2
words, we are going to describe a special-purpose machine that only executes one
(nonsensical) algorithm, which we will state in terms of ARM mnemonics:

SUBS R2,R1,R4 ;sets psr
ADDPL R3,R3,R3 ;speculative
ADD R3,R3,1 ;R3 same as last inst
NOP ;NOP to simplify discussion

Designing such a special-purpose machine is easy if all we wanted to do is to carry out
the same register transfers as would occur when the above instructions execute on the
pipelined implementation of the general-purpose ARM given in section 10.8. 1:

@(posedge sysclk) #1;
r[2] <= @(posedge sysclk) r[1] - r[4];
psr <= f(r[1] - r[4]);

@(posedge sysclk) #1; In parallel to th
if (psr[31]==O) before the mac

r[3] <= @(posedge sysclk) r[3] + r[3]; machine saves
@(posedge sysclk) #1; rencondof

r[3] <= @(posedge sysclk) r[3] + 1; renamed as r [:
@(posedge sysclk) #1;

subtraction is v,
does not, increr

In the first clock cycle, the sign bit of the difference is scheduled to be stored in the from two or mo
psr. In the next clock cycle, after this assignment has taken effect, the psr determines of ren val ft
whether or not the doubling of r [ 3 ] will occur (which makes this a Mealy machine). the second cloc
In any event, incrementation of r [ 3 ] does not occur until the third clock cycle, at renaming in the
which $ t ime the appropriate value (either doubled or not) will be available. The fourth
clock cycle does nothing because of the NOP in the algorithm. 10.9.5.2 Se

Let's consider 
It is possible to cut the number of states in half by combining two actions per state; third instruction
however, there is a difficulty. SUBS sets the psr, but the ADDPL that we desire to instruction that
execute in parallel depends on that psr. Here is where speculative execution and register
renaming come into play. The register transfers of the special-purpose machine described SUBS
by the Verilog below are similar to those carried out when the equivalent instructions ADDPL

execute on the general-purpose superscalar ARM given in section 10.9.6; however, the ADD R

following is much simpler because it only considers actions that occur related to the NOP

specific instructions:

Again, there is
transfers as w(
implementation

408 Verilog Digital Computer Design: Algorithms into Hardware

l



executes one
@(posedge sysclk) #1;

s:
r[2] <= @(posedge sysclk) r[1] - r[4];
psr <= f(r[1] - r[4]);
ren val <= @(posedge sysclk) r[3] + r[3];
ren tag <= (posedge sysclk) 3;
rencond <= @(posedge sysclk) 'PL;

@(posedge sysclk) #1;
rencond <= @(posedge sysclk) 'NV;

s to carry out if ((rencond == 'L)&&(psr[3l]==O) 
tcecute on tth(e
.0.8.1: I (ren-cond == 'MI)&&(psr[31]==l) ||

(ren_cond == 'AL))
r[3] <= @(posedge sysclk) renval+l; //renamed

else
r[3] <= @(posedge sysclk) r[3]+1; //not renamed

In parallel to the subtraction during the first clock cycle, the doubling of r [ 3 ] occurrss
b)efforre  the machine can know whether the difference will be positive. Therefore, the
mmaacchhiine saves the doubled vallue  in ren -vvaa l1,, and at the same $time makes note in -00
r-een ccoonndd  of the condition ('PL) under which this speculative doublled  result is to be
renaammede daas sr r[ren tag]l. l.nItnh tehsee sceocnonddc lcolocckkc ycyccllea, fatfeterrt htheep psrsrre srueslutilntigngfr ofrmomth teh e aNo
susubbtrtraaccttiioon  is valid, the machine makes a decision whether or not renaming occurs. If it
dloes not, incrementation of r [ 3 ] occurs based on the value already iin  tthe  register file

ssttoorreedd  iinn  tthh(ee  frormn  ttwo  or  more  cllock  cycles  ago. If renaming does occur,,,   there is a   literal substitution
rr  ddeetteerrmiinnees:s r determis o)ff  ren -vva l1  for r  [ 3  ]1  in  this clock cycle. Regardless of whether renamiiing   occurs  in
iiilllyy  mmaacchhiinnee)).. the second clock cycle, ren -cccooonndd   is set to ''NV   because the NOP   will not cause any -00
oDDcckk  ccyyccllee,,  aatt ock cycle t rrnenaammiiing  iin  tthe  tthiirrd  cyclle  ((nott  sshown))..
tte...   TThhee  ffoouurrttdhh 

110.9.5.2 Second special-purposer 100..99..5..2 Second special-purposer eennaammiinngg  eexxaammppllee
L,et's consider a second example, similar to the last one, except the destination of the

)))nss   perr  sttatte;; rns per sta; thiird instruction (shown in bold) is not the same as the destination of the ADDPL
we  desiirre  tto( : we desire to ininsstrtruuccttiion that executes speculatively:
n and register
ine described SUBS R2,R1,R4 ;//sets psr
ti nstructions ADDPL R3,R3,R3 ;//speculative
however, the ADD R6,R3,1 ;//R3 same but not dest
related to the NOP ;//NOP to simplify discussion

Again, there is no problem when all we want to do is to carry out the same register
transfers as would occur when the above instructions execute on the pipelined
implementation of the general-purpose ARM given in section 10.8. 1:

RISC Processors 409

I
 l



INIT
@(posedge sysclk) #1; halt-i

r[2] <= @(posedge sysclk) r[l] - r[4]; psr+-O
psr <= f(r[l] - r[4]);

@(posedge sysclk) #1;
if (psr[31]==0)

r[3] <= (posedge sysclk) r[3] + r[3]; ir2[27:26]=
@(posedge sysclk) #1; &&conc

r[6] <= (posedge sysclk) r[3] + 1;
@(posedge sysclk) #1;

0

Of course, things get more interesting when we use speculative execution and register
renaming. The register transfers of the special-purpose machine below are similar to
those carried out when the equivalent instructions execute on the general-purpose
superscalar ARM given in section 10.9.6: ir1+-I

ir2-

@(posedge sysclk) #1;
r[2] <= (posedge sysclk) rl] - r[4]; 'Pi
psr <= f(r[l] - r[4]); irl-r
renval <= @(posedge sysclk) r[3] + r[3]; ir2-
ren tag <= @(posedge sysclk) 3; en_val- dr

renI
ren cond <= @(posedge sysclk) 'PL;

@(posedge sysclk) #1;
rencond <= @(posedge sysclk) 'NV;
if ((ren-cond == 'PL)&&(psr[31]==0) |

(rencond 'MI)&&(psr[31]==1) |
(ren-cond == 'AL))

begin
r[ren tag] <= @(posedge sysclk) ren val; //renamed
r[6] <= @(posedge sysclk) renval+1;
end
else

r[6] <= @(posedge sysclk) r[3]+1; //not renamed

The first clock cycle is identical to the speculative example in section 10.9.5.1; thus the
speculative doubling of r [3] occurs before the machine knows whether the difference U 

_,~I 11U VI
of r [1] and r [4] will be positive. Again, ren val will contain the doubled value
and ren cond will indicate the condition ('PL) when renval is to be renamed as
r [ren-tag] . In the second clock cycle, after the ps r resulting from the subtraction
is valid, the machine makes a decision whether or not renaming occurs. If it does not,
the assignment to r [6] occurs based on the value of r [3] already in the register file
from two or more clock cycles ago. If renaming does occur, the situation is quite different
than in the example of section 10.9.5.1. In this example, the destination of the third
instruction (r [6] ) is different than the destination of the speculative instruction (r [3]).
There is still a literal substitution of ren val for r [3], but there must also be storage .

Figure1 0-6.
410 Verilog Digital Computer Design: Algorithms into Hardware



ion and register
v are similar to
ieneral-purpose

0.9.5.1; thus the
-r the difference
e doubled value
) be renamed as
the subtraction

s. If it does not,
the register file

is quite different
Lion of the third
suction (r [ 3 ] ).
t also be storage

Figure 10-6. SuperscalarASMfor ARM subset.
are RISC Processors 411



of renval in r [ren tag] so that r [3] will contain the doubled value for future 1. ir2
clock cycles (not shown). 2. The]

3. irl
10.9.6 ASM for the superscalar implementation 4. irl
The preceding examples only considered speculative execution in the very limited con- 5. irl
text of a single algorithm. We want to use this in the general context of the fetch/ 6. irl
execute algorithm for a superscalar processor. Figure 10-6 is the ASM for the superscalar 7. irl
implementation of the same subset of ARM instructions used earlier in this chapter.

Each one of t
Although the reader may not realize it at first, much of the motivation for the ARM it is guarantee
subset used throughout this chapter was to keep this intricate ASM as simple as pos- the ASM). TI
sible. Also, this ASM deals with the simplest case of superscalar design (two instruc- upon whether
tions per clock cycle). Common commercial superscalar processors are much more how much to
complicated than this trivial example.6 Even so, this ASM is something to behold! The for the next
observation is that superscalar design is significantly more complicated than multi- new instructs
cycle or pipelined design, even for a tiny subset of instructions.

Cases 1 and 2
with ir2. Ca

10.9.7 Three parallel activities in parallel to
The ASM in section 10.9.6 shows three parallel activities that occur in each clock cycle

Case 1 is sim
when the machine is in state Fl. The first parallel activity (arbitrarily shown at the top

NOPs in the i
of this Mealy ASM only to be consistent with earlier ASMs in this chapter) deals with

register invali
the instruction registers in the pipeline and the program counter. This first parallel
activity also deals with speculative execution. Case 2 is simi

mal"-instruc
The second parallel activity (arbitrarily show in the middle) deals with register renam-

named registe
ing. The final parallel activity (arbitrarily shown at the bottom) deals with executing

decision that
instructions sequentially in the final stage of the pipeline. This portion of the ASM is

details until 
identical to the pipelined ASM given in section 10.8.1.

fully even mc
their place in t

10.9.7.1 Pipeline, parallel and speculative execution and it decides
The first parallel activity deals with several different interacting components of the tion in irl, i
superscalar machine. This portion of this ASM is doing analogous work to what the Of the remain
first portion of the ASM of section 10.8.1 does. The essential goal is to decide what will the instruction
be in the instruction register pipeline (irl and ir2) for the next clock cycle. In the tion in ir w
pipelined implementation, this was easy: either put NOPs into the pipeline or move the definition of tl
instructions down the pipe. In this superscalar implementation, there are seven distinct 2 or 5, the mai
cases, only one of which will occur in any clock cycle. For ease of discussion, let's tion in i M
number these cases 1-7: property holds

6 As of 1997, despite its suitability for superscalar implementation, ARM had not yet introduced such a
version of its processor, instead focusing on low-cost, low-power versions that use only pipelining.

412 Verilog Digital Computer Design: Algorithms into Hardware



alue for future 1. ir2 has a branch or data processing instruction that changes R15.
2. There is a dependency between irl and ir2.
3. irl has a branch that changes R15.
4. irl has a branch that is nullified.

ry limited con- 5. irl has a data processing instruction that does not affect psr.
t of the fetch/ 6. irl has a data processing instruction that does affect psr.
the superscalar 7. irl has a data processing instruction that is nullified.
this chapter.

Each one of these cases corresponds to an oval in the Mealy ASM. In all of these cases,
i for the ARM it is guaranteed that an instruction in i r2 will execute (as described later at the bottom
simple as pos- the ASM). The determination of which of the above seven cases applies here is based
n (two instruc- upon whether irl can be executed in parallel to ir2. We must know that to decide
re much more how much to increment the program counter and how to load the instruction registers
Lob ehold! The for the next clock cycle. The more instructions we can execute in parallel, the more
:ed than multi- new instructions have to be fetched.

Cases 1 and 2 describe situations when it is not possible for irI to execute in parallel
with ir2. Cases 3-7 describe situations when it is possible to do something with irl
in parallel to ir2

ach clock cycle Case 1 is similar to the analogous case of the ASM of section 
iown 10.8.1 

at the ("B/R15"-put
top NOPs in the instruction register pipeline), except case 1 must also make 

?ter) deals the renamed
with register invalid. There is no result being computed in parallel by this case.

is first parallel
Case 2 is similar to the only other analogous case of the ASM of section 10.8.1 ("nor-
mal"-instructions travel down the pipeline), except case 2 must also 

register make the 
renam- re-

named register invalid. There is no result being computed in parallel by this 
with case. 

executing The
decision that causes case 2 to occur is extremely intricate; thus we will defer 

l of the those
ASM is details until we get to the Verilog function. (The motivation here is similar but hope-

fully even more persuasive than earlier in this chapter: both ASMs and Verilog have
their place in the toolset of the designer.) The name of this Verilog function is depend,
and it decides whether there is a dependency (i.e., case 2) based only on the informa-

.iponents of the tion in irl, ir2 and the program status register.
ork to what the Of the remaining cases, the only one in which truly speculative execution occurs for
lecide what will the instruction in ir is case 5. In cases 3, 4, 6 and 7, it is known whether the instruc-
ck cycle. In the tion in irl will execute. The reason this is known is because of some details in the
line or move the definition of the depend function for case 2. In other words, if you are not in case 1,
re seven distinct 2 or 5, the machine has enough information to say with certainty whether the instruc-
discussion, let's tion in irl will execute. (It is the responsibility of the designer to make sure this

property holds, but let's ignore the details of that for a moment.)

t introduced such a
y pipelining.

vare RISC Processors 413

L



Case 5 is interesting because it is the reason for using a renamed register. The value Cases 5, 6 and
scheduled to be assigned to the renamed register is the result from the parallel ALU. instructions ex
The function computed by this ALU is based on irl [24: 21] . The other ALU uses eight rather th
i r2 [24: 21] . The condition that says whether the value in the renamed register will interleaved me
actually be used in the next clock cycle comes from ir [31 28] in this clock cycle. ally be used lai
The tag for the renamed register is scheduled to become the register specified as the (and harmless)
destination in this instruction (irl [15 12]). At the next rising edge of the clock
after case 5 occurs, ren-tag will be the register number that will be modified if this Cases 3 and 4,
speculatively executed instruction actually executes; ren_cond will indicate whether (because of the
the register indicated by ren tag should change based on the program status register gram status reE
in this next clock cycle and ren_val will be that new value. to take the bran

gous to the dec
There is a hidden detail in the depend function that relates to case 5. The depend program count
function prevents parallel execution if both the instructions in irl and r2 set the 6 and 7). If the
program status register. Because of this, distinguishing between case 5 versus cases 6 with NOPs an(
and 7 is simply a matter of looking at irl [20] . If irl [20] and ir2 [20] indicate the 'OFFSET+
both instructions will modify the program status register, case 2 applies, and the in- instruction doe
structions will execute sequentially. The reason for this is that both instructions cannot comes 'INVAL
modify the program status register in the same clock cycle, but it is acceptable for each
of them to modify the program status register in sequence.

10.9.7.2 D
If by the point of the decision ir [20] indicates that this instruction will modify the The second par
program status register, we know that r2 will not. This means the program status register set up 
register in the current clock cycle (rather than in the next clock cycle as was the situa- tion of an instr
tion for case 5) accurately reflects the information needed to decide whether irI will the register file
execute. Therefore, the decision to choose between cases 6 and 7 is
condx (irl [31: 28] ,psr). Note once again the advantage of being able to reuse There are three
this Verilog function. If it is known in this clock cycle (case 6) that the instruction will without being 
execute, rencond will become 4'blllO (always) in the next clock cycle, rather
than whatever condition was present in ir [31 28]. If it is known in this clock
cycle (case 7) that the instruction will not execute, ren_condwill become 4 'blli a. ir2 has 
(never) in the next clock cycle. This way we can use the same hardware that imple- register th
ments speculative execution also to handle cases 6 and 7. b. ren tag

c. evaluation
The reason we cannot use speculative execution here (i.e., making ren cond be clock cycl
irl [31 28]) is that case 6 changes the program status register. If a conditional in-
struction that changes the program status register (such as ADDPLS) executes due to
the current program status information, it is possible register renaming will fail to hap- If none of these
pen in the next clock cycle because the condition is no longer true. That would prevent (case 8). The pa
an instruction that is supposed to execute from actually executing. Therefore, cases 6 Verilog as:
and 7 evaluate condx with the current program status register and communicate this
unambiguously into the next clock cycle with the 4'blllO or 4 'b1ll. IZ
414 Verilog Digital Computer Design: Algorithms into Hardware

j



P-

gister. The value Cases 5, 6 and 7 have quite a few things in common. In each case, two data processing
he parallel ALU. instructions execute in parallel. This means the program counter needs to increment by
other ALU uses eight rather than four. Also two instructions need to be fetched in parallel from the

med register will interleaved memory. In each case, renval is computed, whether or not it will actu-
this clock cycle. ally be used later. In theory, for case 7, ren-val need not be computed, but it is easier
specified as the (and harmless) to do so.

dge of the clock
modified if this Cases 3 and 4 deal with a branch instruction in i r 1. If we reach case 3 or 4, we know

indicate whether (because of the depend function) that the instruction in r2 will not affect the pro-
im status register gram status register. (If it does, case 2 applies instead.) Therefore, the decision whether

to take the branch can be based on condx (irl [31:281 , psr) . The reason is analo-
gous to the decision for cases 6 and 7. If the branch instruction is nullified (case 4), the

5. The depend program counter is incremented by eight and two instruction are fetched (as in cases 5,
and ir2 set the 6 and 7). If the branch instruction in i r occurs (case 3), the instruction pipeline fills
5 versus cases 6 with NOPs and the program counter changes (by adding 'POFFSET4 + 4, similar to

r2 [201 indicate the 'OFFSET+4 in multi-cycle implementation). In either case 3 or case 4, the branch
?lies, and the in- instruction does not modify a user register; thus the tag for the renamed register be-
structions cannot comes 'INVALID.
ceptable for each

10.9.7.2 Dealing with register renaming
n will modify the The second parallel activity of this ASM is to decide whether the value in the 
e program renamed

status register set up in the previous clock cycle (perhaps as the result of speculative execu-
as was the situa- tion of an instruction by case 5 of that clock cycle) should take effect permanently 
vhether in

irl will the register file.
es 6 and 7 is
zing able to reuse There are three conditions that cause the value in the renamed register to be discarded
e instruction will without being written back into the register file:
lock cycle, rather
wn in this clock

,come 4 b111 a. ir2 has a data processing instruction that stores a newer value into that user
[ware that imple- register than what is in renval (refered to as case 10).

b. rentag indicates 'INVALID.
c. evaluation of ren cond in this clock cycle fails (refered to as case 9 of this

ren cond be clock cycle which relates to cases 5 and 7 of the previous clock cycle).
a conditional in-

) executes due to
g will fail to hap- If none of these apply, renval is written back into the register indicated by ren tag
tat would prevent (case 8). The parallel write port through which this occurs can be defined in behavioral
herefore, cases 6 Verilog as:

tohmismunicate 
A1111.

I 'define PRD r[rentag] l

Ware RISC Processors 415



It will also be necessary to define the macros for the read ports so that they forward The fourth con
renval during this clock cycle: This is a situati(

have two non-E
explained in se

'define OPA ((condx(rencond,psr)&&ir2[19:16]==rentag)?ren-val:r[ir219:16]])
'define OPB (ir2[25]?ir2[7:01:((condx(rencond,psr)&&ir2[3:0]==rentag)?ren-val:r[ir2[3:0]])) situation will n
'define POPA (( condx(rencond psr)&&irl[19:16]==ren-tag)?ren-val:r[irl[19:16]]) handle such siti
'define POPB (irl[25]?irl[7:0]:((condx(ren cond,psr)&&irl[3:0]==ren tag)?renva1:r ir1[3:0]]))

The final three,
execute in paral

Here the only conditions that must be satisfied are that the operand comes from the cause the ASM
register described by ren tag (which is guaranteed not to be 'INVALID if ren tag
matches the register number) and rencond evaluates to true in this clock cycle.
Even though the renamed register might be discarded after this clock cycle, if the above function de

conditions are satisfied, the renamed register input 
should [31:

be forwarded in this clock cycle.
begin
depend=(ij

10.9.8 Verilog for the superscalar ARM && ir
&& co

This example illustrates the many advantages of using ASMs together with Verilog. It
(ir2[1

is simply not possible to put all the details of the superscalar design into a one-page && ir
ASM. Some of these details need to be placed into Verilog functions or macros. Most && co
of the functions required, such as condx, were defined earlier for the multi-cycle (ir2[2
implementation, and the fact that we can reuse them is very helpful. && ir

&& co
&& ir

10.9.8.1 The dependfunction && ir
There is one function that is unique to this superscalar implementation: depend. This | (irl[2

function recognizes those situations where it is not possible to execute two instructions && ir:

in parallel: && co]
J| ((irl[:

a. irl operand (' POPA) same as ir2 destination ('RD). &&(ir:
b. irl operand ('POPB) same as ir2 destination ('RD). | ((ir2[V

c. irl is conditional non-dp and ir2 sets psr. &&(ir

d. irl and i2 both set psr. | (irl[2,

e. irl is not branch or dp. && ((i

f. ir2 is not branch or dp.
g. irl has R15 as operand. end

endfunction
The first three of these are a form of hazard known as Read After Write (RAW). If these
instructions executed sequentially, the older instruction (i r2) would write a value into Since the goal is
a register ('RD or psr) which the next instruction (irl) must read. To attempt to rectly, it is useful
execute these instructions in parallel would mean ir2 would read the wrong value. with certainty wl

register), cond

416 Verilog Digital Computer Design: Algorithms into Hardware

k



iat they forward The fourth condition above is a form of hazard known as Write After Write (WAW).
This is a situation that has been warned against throughout this entire book: you cannot
have two non-blocking assignments to the same register in the same clock cycle. As
explained in section 10.9.7.1, the ASM is designed with the understanding that this
situation will never occur in 

r[ir2[3:0]])) case 5; thus the depend function must cause the ASM to
handle such situations in case 2 (i.e., ir2 and irl will execute sequentially).

r[irl[3:01]))
The final three situations deal with instructions for which the ASM was not designed to
execute in parallel. Here is the Verilog function that detects these seven conditions that

comes from the cause the ASM to proceed to case 2:
ID if rentag
[his clock cycle.

function 
ycle, if the above depend;

input [31:0] irl,ir2,psr;
this clock cycle. begin

depend=(ir2[15:12] == irl[19:16]
&& ir2[27:26] == 2'bOO && irl[27:26] == 2'bOO
&& condx(ir2[31:28],psr))//POPA bad 

r with (RAW)
Verilog. It (ir2[15:12] == irl[3:0] && irl[25]==0

into a one-page && ir2[27:26] == 2'bOO && irl[27:26] == 2'bOO
or macros. Most && condx(ir2[31:28],psr))//POPB bad (RAW)
the multi-cycle (ir2[20]

&& ir2[27:26] == 2'bOO
&& condx(ir2[31:28],psr)
&& irl[31:28] 4'billO
&& irl[27:26] 2'bOO) //psr bad(RAW)non-dp

i:d epend. This (irl[20] && irl[27:26] == 2'bOO
two instructions && ir2[20] && ir2[27:26] == 2'bOO

&& condx(ir2[31:281,psr))//psr bad(WAW) dp
| ((irl[27:26] != 2'bOO)

&&(irl[27:25] != 3'blOl))//irl not dp or branch
((ir2[27:26] != 2'bOO)
&&(ir2[27:25] != 3'blOl))//ir2 not dp or branch

| (irl[27:26] == 2'bOO //irl has PC as ALUop
&& ((irl[3:0] == 4'blll && irl[25]==1'bO)

lirl[15:12] == 4'bllll
Hlirl[19:16] == 4'bllll));

end
endfunction

(RAW). If these
write a value into Since the goal is to execute as many instructions in parallel as can be executed cor-
id. To attempt to rectly, it is useful to ignore instructions that are known will be nullified. Since we know
te wrong value. with certainty whether ir2 will be nullified (based on the current program status

register), conditions a-d (which mention ir2) can be ANDed with

!ware RISC Processors 417

L
l 1



condx (ir2 [31: 28 , psr). This means the depend function only slows the ma- by careless des
chine to one instruction per clock cycle when it is actually necessary. For example, the exercises the 5
following two instructions possible case.

test code exam
ADDPL Rl,Rl,l

| chine, it is iml
ADD R2,Rl,l I

pends on how
can be processed in parallel if the ADDPL is nullified but must execute sequentially if the Verilog tesi
the ADDPL is not nullified. a million time

Verilog is that 
the Verilog co(

The superscala
10.9.8.2 Translatingt he ASM to Verilog of the earlier d(
Once all the macros and functions are defined, it is easy to translate the ASM to Verilog. if it works con
For example, the following is the beginning portion of the Verilog code corresponding whether all of 
to the first parallel activity of state F1 (parallel and speculative execution): is that the desi

moderately coi
counterintuitiv
what is being t

begin
if (condx(ir2[31:28],psr) &&

((ir2[27:25] == 3'blOl) 10.9.8.4 U
(ir2[27:26] == 2'bOO &&
ir2[15:12] == 4'bllll))) The Verilog co

begin ments that con
irl <= @(posedge sysclk) 32'hfOOOOOOO;
ir2 <= @(posedge sysclk) 32'hfOOOOOOO;
ren-tag <= (posedge sysclk) 'INVALID; 'ifdef DEB
'ifdef DEBUG $display
$display( " 1. ir

' 1. ir2 branch or R15 prevents | ,$time); cover(l)
cover(l); 'endif

'endif
end What this meai
else ...

10.9.8.3 Code coverage
The power of Verilog is twofold. First, Verilog allows the designer to express the be-
havior of the hardware abstractly, without having to consider too many details. Second, the call to the s

Verilog allows a designer to test the design using simulation. It would be an compiled with

underutilization of Verilog to synthesize a design without having ever simulated it. So, the file, it wou

the designer has two responsibilities. The first responsibility, of course, is to design the reason for usin

hardware. The second responsibility, which is more important but sometimes fined, and the I
neglected

418 Verilog Digital Computer Design: Algorithms into Hardware

A



ly slows the ma- by careless designers, is the test code. This code, sometimes referred to as the testbench,
For example, the exercises the Verilog that simulates the hardware. Ideally, we would like to try every

possible case. For tiny special-purpose machines, such as the 12-bit childish division
test code example in section 3.7.3, this is barely possible. For a general-purpose ma-
chine, it is impossible to test everything. The usefulness of simulation, however, de-
pends on how completely the Verilog code that simulates hardware has been tested by

te sequentially if the Verilog test code. It does not do any good to test the same correct Verilog statement
a million times but ignore another statement that has a bug in it. The advantage of
Verilog is that its software-like statements can be used to warn the designer that parts of
the Verilog code that simulates hardware has not been tested.
The superscalar implementation given in the last section is far more complex than any
of the earlier designs in this book. It is not feasible to test every possible program to see

ASM to Verilog. if it works correctly. We will create several programs, but then Verilog will inform us
le corresponding whether all of the cases we are interested in have been tested. The reason for doing this
tion): is that the designer will more than likely make a mistake in guessing what cases a

moderately complex program will test. The operation of the superscalar machine is so
counterintuitive (even on a small program) that it is better for Verilog to keep track of
what is being tested.

10.9.8.4 Using 'lifdeff or the cover task
The Verilog code, of which a portion was shown in section 10.9.8.2, has several state-
ments that compile conditionally, such as:

'ifdef DEBUG
$display(
" 1. ir2 branch or R15 prevents Il",$time);

cover(l);
'endif

What this means is that if the macro is defined:

'define DEBUG

express the be-
details. Second, the call to the system task, $display, and the cover task (described below) will be

It would be an compiled with the rest of the Verilog. If this ' define were omitted from the top of
simulated it. So, the file, it would be as though the $display and cover tasks were not there. The
,, is to design the reason for using i fde f is that once simulation is correct, the macro can be unde-
etimes neglected fined, and the Verilog will no longer exhibit these test actions.

vare RISC Processors 419

A



- -

Note that ' ifdef is different than an if statement (where the tasks would be com-
piled, but might not execute). In particular, Notice 

' i fde f how 
can be ti

used to alter which control
statements are compiled into inside 

the code. a behai
For example, cases 9 and 10 of the renaming

parallel activity do nothing: block. If 'DE]
will not be de

'ifdef Each 
DEBUG case of

else which is used
begin cover does i
$display("10. dp overwrites renamed r%d', After the prol
rentag,$time);

cases 
cover(10); of the Vc

end in the coverage
'endif (In reality, we

this design, bu

If 'DEBUG is not defined, there is no need for the else begin ... end to be
compiled. The above shows how the scope of statements that are conditionally com- 10.9.9 Tee
piled can cross begin end boundaries. This is possible because the substitution oc- The special-pi
curs at compile time. purpose machi
In addition to calling on these tasks, the being 

cover tested. 
task has to be defined. We only want to

define it if the 'DEBUG macro is defined. manipulates 
Therefore, th

the task and everything associ-
ated with it will be enclosed in pose 

the machine
' ifdef:

turn interprets
purpose machi

'ifdef DEBUG
reg ['MAX_CASENO:O] coverage-set; 10.9.9.1 A
task cover;

One of the detx
input caseno;
integer caseno; implementation
begin Verilog macros

coverage-set = coverageset tionally, on the
((1 << 'MAXCASENO) >> caseno); fill with NOPs

end tion, there are 
endtask

Therefore, we 
initial involving r [1
begin

coverageset = 0;
wait(halt l'bO); 'ifdef PRO(
wait(halt === l'bl); arm7_mach:
$display("coverage=%b", arm7_mach.
coverageset['MAX-CASENO-1:0]); arm7_mach:

end arm7_mach:
'endif arm7_mach:

420 Verilog Digital Computer Design: Algorithms into Hardware



woulld  be  corn- Notice how this is completely different from an if statement. An if can only exist
r which control inside a behavioral block or task. This ' i fdef is outside the task and the initial
If the renaming block. If 'DEBUG is not defined, the reg, the cover task and the initial block

will not be defined.

Each case of interest in the code has a number between 1 and 'MAXCASENO,
___7 which is used to identify that case in the call to cover. (There is no case 0.) What

cover does is to OR the corresponding bit of the coverage set with one.
After the program has halted, the initial block prints out the coverage set. The more
cases of the Verilog code that were covered by the program, the more ones there will be
in the coverage set. We will run several programs in order to obtain complete coverage.
(In reality, we have not considered enough test cases here to have total confidence in
this design, but this task can be expanded to cover an arbitrary number of cases.)

.. end to be
ditionally com- 10.9.9 Test programs
substitution oc- The special-purpose machines in chapters 4 and 5 are easier to test than a general-

purpose machine because the test code simply has to supply test data to the machine
being tested. A special-purpose machine is supposed to follow some algorithm that

We only want to manipulates the data, and it is often easy to tell if the result is correct. A general-pur-
erything associ- pose machine implements a (sometimes intricate) variation of fetch/execute which in

turn interprets a program that manipulates the data. It is much harder to tell if a general-
purpose machine is correct.

10.9.9.1 A test of R15
One of the details of the ARM instruction set that takes special consideration in all the
implementations is RI5. R15 is, in fact, just another name for the program counter. The
Verilog macros for all the above implementations have to take this into account. Addi-
tionally, on the pipelined implementation, R15 as a destination causes the pipeline to
fill with NOPs just as though a branch had occurred. On the superscalar implementa-
tion, there are many places where special consideration is given to R15.
Therefore, we need an ARM program that exercises at least some of this Verilog code
involving r [15] . Here is such a program:

'ifdef PROGRAM1 //test R15 source and destination
arm7_machine.m[0]=32'he3bOOOOO; //MOVS RO,O
arm7_machine.m[1]=32'heO8flOOO; //ADD Rl,R15,RO
arm7_machine.m[2]=32'heO80200f; //ADD R2,RO,R15
arm7_machine.m[3]=32'heO8f3000; //ADD R3,R15,RO
arm7_machine.m[4]=32'heO80400f; //ADD R4,RO,R15

ware RISC Processors 421



Continued Continued
arm7_machine.m[5]=32'he3bOeOff; //MOVS R14,Oxff cond=e, 
arm7_machine.m[6]=32'he2400008; //SUB RO,RO,8 rO=ffffffl
arm7_machine.m[7]=32'hela~fOOl; //MOV R15,R1 2.depend 
'endif 8.writeba(

A Verilog macro, 'PROGRAM 1, is defined when this is the program we want to use to Notice the va]
test the machine with. This test code can be used with any of the implementations. For $time 1151..
example, the pipelined implementation produces the following: to what was vi

This program 
PC=00000024 IR1=eafffffe IR2=elaOfOOl N=O 1251 the pipelined i
rO=fffffffs rl=0000000c r2=00000010 r3=00000014 r4=00000018 vents executio
PC=OOOOOOOc IR1=f0000000 IR2=fOOOOOOO N=O 1351 This program i
rO=fffffff8 rl=OOOOOOOc r2=00000010 r3=00000014 r4=00000018 that case 2 hap
PC=00000010 IR1=eO8f3000 IR2=fOOOOOOO N=O 1451
rO=fffffff8 rl=OOOOOOOc r2=00000010 r3=00000014 r4=00000018
PC=00000014 IR1=eO80400f IR2=eO8f3000 N=O 1551
rO=fffffff8 rl=OOOOOOOc r2=00000010 r3=00000014 r4=00000018 || (irl[27
PC=00000018 && ((irl

IR1=e3bOeOff IR2=eO80400f N=O 1651
rO=fffffff8 r=OOOOOOOc I rl [

r2=00000010 r3=0000000c r4=00000018
| |irif

Notice the contents of the registers at $time 1251 and the NOPs in the pipeline at The coverage s'
$time 1351. Also notice the contents of the registers at $time 1651. On the other 10 
hand, are covered,

the superscalar implementation produces equivalent results in an entirely differ- why these case;
ent way:

10.9.9.2 Oi
PC=00000024 IR1=eafffffe IR2=ela0f001 N=O 1051 The last progral
rO=fffffff8 r1=0000000c r2=00000010 r3=00000014 r4=00000018 tain ARM instn
1.ir2 branch or R15 prevents | 1051 the childish divi
other DP instructions... not have a divi(
5.use || ALU noS irl=fOOOOOOO A=fffffff8 B=fffffff8 1151 ware. Although
PC=0000000c IR1=fOOOOOOO IR2=fOOOOOOO N=O 1151 sion than the ch
rO=fffffff8 rl=0000000c r2=00000010 r3=00000014 r4=00000018 ties that more s
PC=00000014 IR1=eO80400f IR2=eO8f3000 N=O
cond=f,renR 0 implemented 

=00000000 ms,
1251

rO=fffffff8 rl=OOOOOOOc r2=00000010 r3=00000014 childish 
r4=00000018 division

2.depend prevents || 1251
9.nullify renamed r 0 Idp 1251
6.use || ALU S irl=e3bOeOff A=fffffff8 B=OOOOOOff 1351
PC=00000018 IRl=e3bOeOff IR2=eO80400f N=O 1351
rO=fffffff8 rl=OOOOOOOc r2=00000010 r3=OOOOOOOc r4=00000018
PC=00000020 IRl=elaOfOOl IR2=e2400008 N=O

422 Verilog Digital Computer Design: Algorithms into Hardware



Continued

cond=e,renR14 =0000OOff 1451
rO=fffffff8 rl=OOOOOOOc r2=00000010 r3=OOOOOOOc r4=00000010
2.depend prevents || 1451
8.writeback renamed r4 |ldp 1451

we want to use to Notice the values of the registers at $time 1051 and the NOPs in the pipeline at
lamentations. For $time 1151. Also notice the value of the registers at $time 1451. These correspond

to what was visible in the pipelined implementation at $ time 1251, 1351 and 1651.
This program does not execute much faster on the superscalar implementation than on

1251 the pipelined implementation because the superscalar implementation properly pre-
r4=00000018 vents execution of more than one instruction per clock cycle when R15 is involved.
L351 This program is important as a means of testing the Verilog code because it illustrates
r4=00 0000 18 that case 2 happens due to the following portion of the depend function:
1451
r4=00000018
1551 (irl[27:26] == 2'bOO
r4=00000018

&& ((irl[3:0] == 4'bllll && irl[251==1'bO)
1651 Ilirl[15:12] == 4'bllll
r4=00000018 Ilirl[19:161 == 4'bllll));//irl has PC as ALUop

in the pipeline at The coverage set for this program is 1100110101; in other words, 
551. On cases 

the 1,2,5,6, 
other 8 and

10 are covered. Notice how helpful the output from the $displays 
an entirely is 

differ- in annotating
why these cases occur.

10.9.9.2 Our oldfriend: division
1051 The last program has no practical value other than that of testing the operation of cer-

1=00000018 tain ARM instructions. The remaining programs that we will consider will be based on
1051 the childish division algorithm used in earlier chapters. Like the PDP-8, the ARM does

not have a divide instruction in the hardware; thus to do division requires some soft-
f8 1151 ware. Although if speed were essential one would choose a faster algorithm for divi-

1151 sion than the childish algorithm, this simple algorithm illustrates many of the proper-
1=00000018 ties that more sophisticated algorithms also have. This is the reason why it has been

implemented many times in this book, in both hardware 
1251 and software. Here again is the

childish 
1=00000018 division algorithm in C:

1251
1251
1351
1351

1=00000018

Iware RISC Processors 423



_- r

rl=x; is greater than
r2=0; negative, at wl
while (rl>=y) flag that woulc

{
rl = rl - y; By defining 'P
r2 = r2 + 1; (not shown) w,

} program can b.
pipelined impli

Since we have not implemented the memory reference instructions of the ARM, the
values of x and y must be constants. We will use immediate addressing with x and y.
For example, let us assume that x is 14 and y is 7, which is a typical test case used with PC= 0000001
this algorithm in chapters 2, 4, 5, 8 and 9. It is natural for the ri and r2 high-level rO=000000
variables to reside in RI and R2, respectively. Ri and R2 are the registers that the PC=0000001

assembly language programmer refers to, but these are r [ 1 ] and r [ 2 ] in Verilog. rO=ffffff

Also, it will be convenient for y to reside in R4. The implementations PC=0000002
of this algorithm

rO=ffffff
given in chapters 8 and 9 made use of the accumulator of the PDP-8 to contain the PC=0000002
difference. We need to have a similar register on the ARM. In the following program, rO=ffffff
let us use RO to serve the same role as as the accumulator. This illustrates an important PC=0000002
property of all RISC machines (notjust the ARM): there is nothing special about RO- rO=ffffff
we could have chosen any other available register to hold the difference. The following
is an ARM program that implements this algorithm in the most straightforward way
possible: The loop exect

duces a negativ
branch. Not she
GRAM5 on the

OOOOOOOO/e3aOlOOe MOV Rl,OxOe
00000004/e3aO4007 MOV different 

R4,0x07 way:
00000008/e3aO2000 MOV R2,QxOO
OOOOOc/eO510004 Li SUBS RO,Rl,R4 2.depend pi
00000010/4a00002 BMI L2 lO.dp over
00000014/elaO000 MOV Rl,RO PC=00000014
00000018/e2822001 ADD R2,R2,OxOl cond=f,r(
OOOOlc/eafffffa B Li rO=0000000(
00000020/efOOOQO L2 SWI PC=oooooo1A

rO=ffffffft

The above is analogous to the PDP-8 l.ir2 
program bran(

given in section 8.3.2.5.3. The first three
other DP it

MOV instructions set up RI, R4 and R2 to their initial values of x (14), y (7) and zero, 5.use | AI
respectively. The SUBS is the only instruction that sets the program status register. The PC=0000002(
purpose of the SUBS instruction is twofold: to compute the difference and to see if rO=ffffffft
R1>=R4. The BMI makes use of this program status information. As long as Rl >= R4, PC=00000021
the BMI is nullified and the loop continues. The difference would then be moved from cond=f,r(
RO to RI, and R2 is incremented. The unconditional branch to the label LI causes the rO=fffffff5
test at the top of the loop to happen again. This loop repeats while the difference (in RO) 2.depend pi

9.nullifl

424 Verilog Digital Computer Design: Algorithms into Hardware



____7 is greater than zero. The BMI branches to the label L2 when the difference in RO is
negative, at which point the SWI causes the Verilog test code to finish (using the halt
flag that would not exist on a an actual ARM).

By defining 'PROGRAM5 in the test code, appropriate Verilog assignment statements
(not shown) would place the above machine language instructions into memory. This
program can be used with any of the implementations of the ARM. For example, the
pipelined implementation produces the following:

he ARM, the
with x and y.
ase used with PC=00000014 IR1=4aO00002 IR2=e0510004 N=O 2251

r2 high-level rO=00000000 rl=00000000 r2=00000002 r3=xxxxxxxx r4=00000007
PC=00000018 IR1=elaO1000 IR2=4a000002 N=1

isters that the 2351
rO=fffffff9 rl=00000000 r2=00000002 r3=xxxxxxxx r4=00000007

' ] in Verilog. PC=00000020 IRl=fOOOOOOO IR2=fOOOOOOO N=1 2451
this algorithm rO=fffffff9 rl=00000000 r2=00000002 r3=xxxxxxxx r4=00000007
to contain the PC=00000024 IRl=efOOOOOO IR2=fOOOOOOO N=1 2551
ving program, rO=fffffff9 rl=00000000 r2=00000002 r3=xxxxxxxx r4=00000007
s an important PC=00000028 IR1=xxxxxxxx IR2=efOO0000 N=1 2651
al about RO- rO=fffffff9 rl=00000000 r2=00000002 r3=xxxxxxxx r4=00000007

The following U4
itforward way The loop executes two times. The third execution of the SUBS ($time 2251) pro-

duces a negative number (fffffff9), which sets the N flag. This in turn causes the BMI to
branch. Not show earlier, the BMI had been nullified. On the other hand, running 'PRO-
GRAM5 on the superscalar implementation produces equivalent results in an entirely
different way:

2.depend prevents 1351
10.dp overwrites renamed r 0 1351
PC=00000014 IR1=4a00002 R2=e0510004 N=O
cond=f,renR 0 =00000000 1351

rO=00000000 r1=00000000 r2=00000002 r3=xxxxxxxx r4=00000007
PC=00000018 IR1=elaO1000 IR2=4a00002 N=1 1451
rO=fffffff9 rl=O0000000 r2=00000002 r3=xxxxxxxx r4=00000007
1.ir2 branch or R15 prevents 1451

i. The first three other DP instructions...
y (7) and zero, 5.use || ALU noS irl=fOOOOOOO A=fffffff9 B=fffffff9 1551

tus register. The PC=00000020 IRI=fOOOOOOO R2=fOOOOOOO N=1 1551
ce and to see if rO=fffffff9 rl=00000000 r2=00000002 r3=xxxxxxxx r4=00000007

ngasRI >=R4, PC=00000028 IR1=xxxxxxxx IR2=efOO0000 N=1

be moved from cond=f,renR 0 =00000000 1651
rO=fffffff9 

el LI causes the r1=00000000 r2=00000002 r3=xxxxxxxx r4=00000007
2.depend prevents || 1651

ifference (in RO) 9.nullify renamed r 0 I dp 1651

vare RISC Processors 425



The contents of the registers in the superscalar implementation at $ time 1651 are the 10.9.9.4 
same as the registers in the pipelined implementation at $ t ime 2651. The output from One of the bi
the $ di spl ay statements explain the intricate way in which the superscalar machine made to exec
was able to produce the correct answer in less time. The depend function only slows executed cons
the machine down (case 2) three times. For example, at $time 1351, depend detects instruction, st
the conditional branch (BMI in this example) following the data processing instruction condition is tj
that sets the program status register (SUBS in this case). At $time 1641, depend any branch pi
detects SWI. The Verilog coverage set for the superscalar run of 'PROGRAM5 is
1110110111. This means all but cases 4 and 7 were exercised. One technique

running on a 
using for loc

10.9.9.3 Fasterc hildish division
In section 9.7, a variation of the childish division algorithm was given that illustrates a
different way of implementing a while loop in software (testing at both the top and
bottom of the loop). The effect of this is to reduce the number of times the branch
penalty is incurred and to reduce the number of nullified branch instructions. The fol-
lowing ARM program implements this approach by using both the BPL and BMI in-
structions:

the compiler k
OOOOOOOO/e3aOlOOe MOV Rl,OxOe code looks lik(
00000004/e3aO2000 MOV R2,OxOO
00000008/e3aO4007 MOV R4,0x07
OOOOOOOc/e0510004 SUBS R0,R1,R4
00000010/4a00003 BMI L2
00000014/elaOlOOO Li MOV Rl,RO
00000018/e2822001 ADD R2,R2,0xOi
OOOOOOlc/e0510004 SUBS RO,R1,R4
00000020/5afffffb BPL Li
00000024/efOOOOOO L2 SWI

which can be i]

Running on the pipelined implementation, this program (let's refer to it as 'PROGRAM4)
produces at $ time 2051 the same results that 'PROGRAM5 produces (also running
on the pipelined implementation) at $time 2651. This illustrates that to make good
use of a pipelined machine, a good compiler is essential. Manually created assembly
language programs are often not as effective as the automatically created machine lan-
guage from compilers. Running on this superscalar implementation, this program pro-
duces at $time 1451 the same results that 'PROGRAM5 (also running on the super-
scalar implementation) produces at $ time 1651.

The Verilog coverage set for the superscalar run of 'PROGRAM4 is 1100110110. 'PRO- If the program I
GRAM4 does not add to the coverage of the Verilog code provided by 'PROGRAM5 the loop compl
(1110110111); thus we need an additional test program to cover cases 4 and 7.

426 Verilog Digital Computer Design: Algorithms into Hardware



ne 1651 are the 10.9.9.4 Childish division with conditionali nstructions
Fhe output from One of the big advantages of the ARM instruction set is that any instruction can be
rscalar machine made to execute conditionally. In the previous program, only the branch instructions
tion only slows executed conditionally, but with the ARM, the programmer is free to specify that any
ldeepend detects instruction, such as a data processing instruction, should execute only when a certain
sing instruction condition is true. The importance of this is that conditional execution does not incur
1641,  depend any branch penalty.
')ROGRAM55  is

One technique that compilers use to improve the performance of high-level software
running on a pipelined and/or superscalar processor is loop unrolling. In C programs
using f or loops, such as:

that illustrates a
)oth the top and for(i=O;i<3;i++)

mes the branch {
actions. The fol- rl = rl - y;

PL and BMI in- r2 = r2 + 1;
}

the compiler knows a priori how many times the loop will execute; thus the unrolled
code looks like:

rl = rl - y;
r2 = r2 + 1;
rl = rl - y;
r2 = r2 + 1;
rl = rl - y;
r2 = r2 + 1;

which can be implemented without branch penalty:

s 'PROGRAM4)
:es (also running SUB R1,R1,R4
at to make good ADD R2,R2,0x0l
,reated assembly SUB R1,R1,R4
lted machine lan- ADD R2,R2,0xOl
his program pro- SUB R1,R1,R4

ing on the super- ADD R2,R2,0xOl

)0110110. 'PRO- If the program has a f or loop that repeats too many times for it to be practical to unroll
)y 'PROGRAM5 the loop completely, it can be partially unrolled. For example:
s4 and 7.

ware RISC Processors 427



for(i=O;i<3000;i++) Each time thrn
{ version of the

rl = rl - y; incurs the brat
r2 = r2 + 1;

lated into con(
}

is the same as:

for(i=O;i<1000;i++)
{

rl = rl - y;
r2 = r2 + 1;
rl = rl - y;
r2 = r2 + 1;
rl = rl - y;
r2 = r2 + 1;

} The reason th,
(bit 20 equal t(

which would incur the branch penalty one-third as often. so that severa
The difficulty with the childish division algorithm (and with many practical programs) program, the S
is that we do not know before we run the program how many times the loop will ex- and SUBPLS
ecute. (In the case of childish division, the number of times the loop will execute is the execute. Since
answer we are trying to compute.) ditional data p

ten speed up a
Here is where conditional data processing instructions come in handy. Assuming we
do not care about the result in rl, the childish division algorithm can be partially The Verilog co
unrolled as the following C code: GRAM3 does

(1110110111);
is identical to

rl=x; x.
r2=0;
do

{
rl = rl - y;
if (rl>=0) r2 = r2 + 1;
if (rl>=0) rl = rl - y; The coverage
if (rl>=0) r2 = r2 +1; covers cases 4

} while (rl>=0) been tested at I
we know we h
Verilog has he

428 Verilog Digital Computer Design: Algorithms into Hardware



Each time through this loop is equivalent to two times through the loop in the original
version of the childish division program. This program (refered to as 'PROGRAM3)
incurs the branch penalty half as often provided that the three i f statements are trans-
lated into conditional data processing instructions:

OOOOOOOO/e3aOlOOe MOV R1,Ox~e
00000004/e3aO4007 MOV R4,0x07
00000008/e3a02000 MOV R2,OxOO
OOOO000c/e0511004 Li SUBS R1,R1,R4
00000010/52822001 ADDPL R2,R2,0x0j
00000014/50511004 SUBPLS R1,R1,R4
00000018/52822001 ADDPL R2,R2,0xOi
0000001c/5afffffa BPL LI
00000020/efOOOOOO L2 SWI

The reason that the ARM provides the ability to either set the program status register
(bit 20 equal to one) or leave the program status register alone (bit 20 equal to zero) is
so that several instructions can be made conditional on the same condition. In this

bctical programs) program, the SUBS (andpossibly the SUBPLS) determine whetherRI >= 0. TheADDPL
the loop will ex- and SUBPLS instructions use this program status information to decide whether to
(ill execute is the execute. Since the pipelined and superscalar implementations allow execution of con-

ditional data processing instructions without branch penalties, such techniques can of-
ten speed up a program.

ly. Assuming we
can be partially The Verilog coverage set for the superscalar run of 'PROGRAM3 is 0110110110. 'PRO-

GRAM3 does not add to the coverage of the Verilog code provided by 'PROGRAM5
(1110110111); thus we need to do a different test to cover cases 4 and 7. One such test
is identical to 'PROGRAM3, except R is loaded with 6 rather than 14 as the value of
x.

OOOOOOOO/e3a01006 MOV R1,0x06

The coverage set for the superscalar run of this modified program is 0101111110, which
covers cases 4 and 7. Therefore, all of the ten cases identified in the source code have
been tested at least once. This is not to say that the overall design is correct, but at least
we know we have checked all the Verilog statements translated from the original ASM.
Verilog has helped us make sure that all the code has been covered.

ware RISC Processors 429



10.10 Comparison of childish division implementations spe
run 

Determining f
how long it takes for each of the above division programs ('PROGRAM3, 0

'PROGRAM4 and 'PROGRAM5) to execute is tedious, especially on the pipelined
and superscalar versions of the ARM. A better approach is to let Verilog measure the M 5 33
time for a range of input values: M 4 33

M 3 44

'ifdef DIVTEST P 5 13
cont = 0; P 4 13
t = O; P 3 14
for (x=O; x<=42; x = x + 1)
begin S5 9

arm7 machine.m[O] = S 4 10
(arm7_machine.m[0] & 32'hffffffOO) + x; S3 9

arm7_machine.r[15] = 0;
#200 cont = 1; The column o
#100 cont = 0; machine ("M'
#400 wait(arm7 machine.halt); "S 3" indicate
if (arm7_machine.r[2] != x/7) on the right is

$display("error"); look back at tl
$display("x=%d cl=%d r2=%d %d",x, division algor

($time-t)/100,arm7_machine.r[2], $time);
t = $time; division algor

end
$finish; register

'endif f/e data
0 2
0 2

The above Verilog modifies the MOV immediate at address 0 to initialize different 0 3
values of x, that range from 0 to 42 and causes the arm7_machine to run the modi-
fied program. If the quotient (in r [ 2 ] ) is not erroneous, the Verilog code simply prints 0 2
the number of clock cycles (of period 100) elapsed since the machine language pro- 0 2
gram started running for the given value of x. To use the above code, 'DIVTEST, as 4 15
well as the macro for the desired machine language program ('PROGRAM3, 'PRO-
GRAM4 or 'PROGRAM5), must be defined. When each of these 0 

three 3
programs is

run on each of the three 0 
implementations 2

(multi-cycle, pipelined and superscalar), we
obtain the following data: 3 15

4 15
4 15

3 15
3 15
4 1

430 Verilog Digital Computer Design: Algorithms into Hardware



nentations specific clock cycles, upper bound
run for given quotient for quotient > 0

('PROGRAM3, 0 1 2 3 4 5 ...
on the pipelined
ilog measure the M 5 33 57 81 105 129 153 ... 24*quotient + 33

M 4 33 51 71 91 111 131 ... 20*quotient + 31
M 3 44 46 69 71 94 96 ... 12.5*quotient + 44

P 5 13 20 27 34 41 48 ... 7*quotient + 13
P 4 13 15 21 27 33 39 ... 6*quotient + 9
P 3 14 14 21 21 35 35 ... 3.5*quotient + 14

S 5 9 13 17 21 25 29 ... 4*quotient + 9
S 4 10 11 15 19 23 27 ... 4*quotient + 7
S 3 9 9 13 13 17 17 ... 2*quotient + 9

The column on the left ("run") indicates which program (3, 4 or 5) was run on which
machine ("M" for multi-cycle, "P" for pipelined, or "" for superscalar). For example,
"S 3" indicates 'PROGRAM3 was run on the superscalar implementation. The column
on the right is an equation of an upper bound on this data for quotient > 0. Let us
look back at the interesting journey we have traveled with our old friend, the childish
division algorithm. The following table summarizes implementations of the childish
division algorithm given in this and earlier chapters:

register bit P S kind hard soft upper bound on
f/e data sect sect clock cycles
0 2 12 n n Mealy 5.2.4 n/a 2 + quotient
0 2 12 n n Mealy 5.2.3 n/a 3 + quotient

iitialize different 0 3 12 n n Moore 2.2.7 n/a 3 + quotient
to run the modi-
de simply prints 0 2 12 n n Moore 2.2.3 n/a 2 + 2*quotient
ie language pro- 0 2 12 n n Mealy 5.2.1 n/a 2 + 2*quotient
:, 'DIVTEST, as 4 15 31 y y Mealy 10.9.6 10.9.9.4 9 + 2*quotient

GRAM3, PRO-
hree 0 

programs 3 12 
is n n Moore 2.2.5 n/a 2 + 3*quotient

0 2 12 n n Moore 2.2.2 n/a
superscalar), we 3 + 3*quotient

3 15 31 y n Mealy 10.8.1 10.9.9.4 14+ 3.5*quotient

4 15 31 y y Mealy 10.9.6 10.9.9.2 9 + 4*quotient
4 15 31 y y Mealy 10.9.6 10.9.9.3 7 + 4*quotient

3 15 31 y n Mealy 10.8.1 10.9.9.3 9 + 6*quotient
3 15 31 y n Mealy 10.8.1 10.9.9.2 13+ 7*quotient
4 1 11 y n Mealy 9.6 9.7 12+ 10*quotient

ware RISC Processors 431



Continued multi-cycle A
3 15 31 n n Mealy 10.7 10.9.9.4 44+12.5*quotient on the multi-(
3 15 31 n n Mealy 10.7 10.9.9.3 31+ 20*quotient gram on the E
3 15 31 n n Mealy 10.7 10.9.9.2 33+ 24*quotient
4 1 11 n n Moore 8.3.2.1 9.7 55+ 55*quotient
4 1 12 n n Moore 8.3.2.1 8.3.2.5.3 88+ 75*quotient

10.11 C
The "register" columns indicate how many "data" registers and how many "fle" (fetch/ This chapter I
execute) registers are used. (The number of 'f/e" registers is 0 for special-purpose using a small
hardware; the number of "data" registers is 1 for a single-accumulator machine like the algorithm as ti
PDP-8 and much larger (e.g., 15) for a RISC machine like the ARM.) The "bit" column to execute an
shows maximum number of bits the implementation allows for x or y. (For software instruction, e
implementations that use the sign bit (the PDP-8's SPA/SMA or the ARM's N flag), attempts to e)
this is one less than the register size.) The S" column indicates whether the hardware A RISC mace
is superscalar. The "P" column indicates whether the hardware is pipelined. (Remem- instruction sei
ber a superscalar implementation also uses pipelining.) The "kind" column indicates In comparison
whether the ASM uses conditional commands (Mealy) or not (Moore). The "hard sect" the number c
column indicates where the ASM is described. (The ASM implements the childish chance that ac
division algorithm for special-purpose hardware but the ASM implements fetch/ex- makes the de,
ecute for general-purpose hardware.) The "soft sect" applies only to general-purpose
computer implementations and describes the machine language for the childish divi- Superscalar ii
sion algorithm. The "upper bound on clock cycles" column indicates how long it takes instruction is
to compute the quotient. This table is sorted by the linear coefficient of the upper bound; ecute. Rather
thus for large quotient, the order in this table indicates the relative speed of the the physical ri
machines, assuming that the clock frequency of each machine is the same. (The clock destination if 
frequencies may be different due to different propagation delays in each architecture, example in tf
as described in chapter 6, but we will assume the clock frequency is the same here.) often much mi

prediction, w
There are several interesting things to note in the above table. First, special-purpose branch to thos
hardware is cheaper (number of registers) than general-purpose hardware, especially instructions a
for the faster kinds of general-purpose hardware (pipelined and superscalar). Second, clock cycle. I
special-purpose hardware is faster than software running on general-purpose machines illustrate the 
except that the superscalar ARM running 'PROGRAM3 is faster than the special-pur-
pose hardware described in sections 2.2.2 and 2.2.5. Third, the expensive superscalar The design of
implementation is competitive with cheap special-purpose hardware only for 'PRO- a pipelined o
GRAM3 (with its loop unrolling). This illustrates that to capitalize on sophisticated language suct
general-purpose hardware requires a good compiler. Fourth, all things being equal, source code a]
Mealy machines tend to take fewer clock cycles than Moore machines. Fifth, a single- yet have those
accumulator multi-cycle general-purpose machine (PDP-8) is slower than a RISC multi- the Verilog di
cycle general-purpose machine (ARM) because the latter needs fewer instructions to considers imp
carry out the algorithm. Sixth, pipelining improves the speed of a general-purpose
machine. Seventh, pipelining the single-accumulator PDP-8 makes it faster than the

432 Verilog Digital Computer Design: Algorithms into Hardware



multi-cycle ARM but slower than the pipelined ARM. The equivalent of 'PROGRAM4
uotient on the multi-cycle PDP-8 takes 55+55* quotient clock cycles while the same pro-
uotient gram on the pipelined PDP-8 takes 12+10* quotient clock cycles.
uotient
uotient
uotient

10.11 Conclusions
iany "fle" (fetch/ This chapter has compared three different implementations for a RISC instruction set,
special-purpose using a small subset of the ARM as the example hardware and the childish division
machine like the algorithm as the example software. A multi-cycle implementation requires several cycles
rhe "bit" column to execute an instruction. A pipelined implementation requires one cycle to execute an
y. (For software instruction, except for an instruction such as branch. A superscalar implementation

ARM's N flag), attempts to execute more than one instruction per clock cycle whenever possible.
her the hardware A RISC machine provides a large set of registers available to the programmer, and an
elined. (Remem- instruction set that allows three register operands to be specified in a single instruction.
column indicates In comparison to a single-accumulator machine (like the PDP-8), this tends to reduc-
1T.h e "hard sect" the number of instructions required to implement a algorithm and to enhance the
ents the childish chance that adjacent instructions will be independent of each other. This latter property
ements fetch/ex- makes the design of superscalar general-purpose machines feasible.
general-purpose

the childish divi- Superscalar implementations often use speculative execution, where the result of an
how long it takes instruction is computed before it is known whether that instruction will actually ex-

the upper bound; ecute. Rather than storing the result in the actual register specified by the instruction,
tive speed of the the physical register where this speculative result resides will be renamed to act as the
same. (The clock destination if and only if the corresponding instruction actually executes. The superscalar
,ach architecture, example in this chapter is highly simplified. Commercial superscalar machines are
the same here.) often much more aggressive with speculative execution, using techniques such as branch

prediction, where the machine executes instructions before it is known whether the
special-purpose branch to those instructions will actually occur, and out of order execution, where more

dware, especially instructions are issued (fetched into the pipeline) than can be retired (executed) per
,rscalar). Second, clock cycle. The beauty of the ARM's conditional instructions is that they allow us to
urpose machines illustrate the same principles of speculative execution with much simpler hardware.

n the special-pur-
nsive superscalar The design of a superscalar processor is considerably more complex than the design of
e only for 'PRO- a pipelined or multi-cycle processor. Because of this, use of a hardware description
on sophisticated language such as Verilog is helpful. Through the use of macros and functions, Verilog

ings being equal, source code allows the designer to hide unnecessary details early in the design process,

-s. Fifth, a single- yet have those details fully specified in the final source code. Through the use of tasks,
han a RISC multi- the Verilog designer can make sure that the test code covers all cases the designer

ier instructions to considers important.

general-purpose
it faster than the

ware RISC Processors 433



10.12 Further reading 10-5. The regi
VLSI TECHNOLOGY, INC., Acorn RISC Machine (ARM) Family Data Manual, Prentice with two read
Hall, Englewood Chiffs, NJ, 1990. Provides documentation on an early version known the program o
as the ARM2, which had a three-stage pipeline. How to access documentation about r[15] plus a
more current versions is given in appendix G. tions that occu

address to men
to deal with th

10.13 Exercises
10-1. The following Verilog code for a special-purpose machine describes the register
transfers carried out by four ARM instructions followed by two NOPs run on the
superscalar general-purpose ARM. What are these four instructions?

@(posedge sysclk) #1;
r[2] <= (posedge sysclk) rl] + r[4]; The external in
psr <= f(r[l] + r[4]); cycle version.
renval <= (posedge sysclk) r[3] - r[4]; 10-6. Using a 
ren-tag <= (posedge sysclk) 3;
rencond <= (posedge the multi-cycl(

sysclk) 'PL;
@(posedge sysclk) #1; ASM.
renval <= (posedge sysclk) r[5] + 5; 10-7. Using a 
ren-tag <= @(posedge sysclk) 5; the pipelined )
if ((ren-cond == 'PL)&&(psr[31]==0)

(ren-cond ASM.
== 'MI)&&(psr[31]==l)

(ren-cond == 'AL)) 10-8. The regi:
begin ports and two N
r[6] <= @(posedge sysclk) renval; (by 4 or 8) or 1
r[ren-tag] <= @(posedge sysclk) ren-val;

either 
end 0 or 4) it

else the register fili
r[6] <= @(posedge sysclk) r[3]; special operati

@(posedge sysclk) #1;
if ((ren cond == 'PL)&&(psr[31]==0) || ldl

(ren-cond == 'MI)&&(psr[31]==l) ||
(ren-cond == 'AL))

r[5] <= @(posedge sysclk) renval;
I

10-2. In problem 10-1, which registers are involved with renaming? I

10-3. In problem 10-1, which of the seven cases described in section 10.9.7.1 applies to
each state of the special-purpose machine? Draw a block 

10-4. In problem 10-1, which of the instructions is executed speculatively? 10-9. The inter
ries. For this 
replace these 

434 Verilog Digital Computer Design: Algorithms into Hardware



10-5. The register file for the multi-cycle and pipelined ARM is a multi-port memory
fanual, Prentice with two read ports and one write port (similar to that described in section 9.8), except
y version known the program counter (r [ 15 ] ) must be able to be incremented (by 4) or loaded (with
mentation about r [ 15 ] plus an externally supplied 26-bit signed value) independently of the opera-

tions that occur on the other ports. Also, there must be a port supplying r [ 151 as the
address to memory. Assume that the register file has command inputs ldPC and incPC
to deal with these special operations:

ldPC incPC action
0 0 r[15] depends on write port

ribes the register o 1 r[15]*-r[15]+4
rOPs run on the 1 0 r[15 -r[151+external

1 1 impossible

The external input is 'OFFSET4 in the pipelined version and 'OFFSET4+4 in the multi-
cycle version. Draw a block diagram that implements this synchronous register file.
10-6. Using a register file of the kind given in problem 10-5, design an architecture for
the multi-cycle ARM subset given in section 10.7, and give the corresponding mixed
ASM.

10-7. Using a register file of the kind given in problem 10-5, design an architecture for
the pipelined ARM subset given in section 10.8.1, and give the corresponding mixed
ASM.

10-8. The register file for the superscalar ARM is a multi-port memory with four read
ports and two write ports. The program counter (r [ 15] ) must be able to be incremented
(by 4 or 8) or loaded (with r [ 15 ] plus an externally supplied 26-bit signed value plus
either 0 or 4) independently of the operations that occur on the other ports. Assume that
the register file has command inputs ldPC, incPC and plus4PC to deal with these
special operations:

ldPC incPC plus4PC action
o a 0 r[15] depends on write ports
0 1 0 r[15]<-r[15]+4
0 1 1 r[15]<-r[15]+4+4
1 0 0 r[15]*-r[15]+'OFFSET4
1 0 1 r[15]<-r[15]-+'OFFSET4+4
1 1 - impossible

0.9.7.1 applies to
Draw a block diagram that implements this synchronous register file.

ively? 10-9. The interleaved memory described in section 10.9.2 has two conventional memo-
ries. For this problem, since the program does not change during execution, we will
replace these memories with ROMs (oddjm and evenm). One of the ROMs is for

ware RISC Processors 435

I



_- rI_

words whose addr/4 is odd. The other ROM is for words whose addr/4 is even. 10-15. Draw;
The problem is we cannot predict whether the CPU will need the odd and even instruc- In the event 
tions fetched into irI and ir2 or vice versa. Give a block diagram for the interleaved pipeline to sta
memory that overcomes this problem using three muxes and an incrementor in addi- operand is no
tion to the ROMs. STR instructi
10-10. Using a register file of the kind given address 

in problem and 
10-8 c

and an interleaved memory
of the kind described in problem structions 

10-9, design wil
an architecture for the superscalar ARM

subset given in section 10.9.6, hierarchy. 
and give the Be(

corresponding mixed ASM. dress creates 
10-11. As explained in appendix G, the ARM is actually a Princeton machine, which
stores its program and data in the 10-16. 

same memory. Assun
Like many other RISC machines, the

ARM does not allow computation superscalar 
on values in be

memory. Rather, it only allows load and
store instructions. The two most important instructions de

instructions of this kind are LDR
(ir[ 2 7:26] ==1&ir[20]==1)andSTR(ir[27:26]=1&ir[20]==0). There 10-17. Modifb
are several addressing modes available, but for this problem only consider the simple remaining dat
indexed addressing mode (ir [ 2 4: 21 ] can be ignored in this problem) that accesses
m [ 'OPA+ 'OPB] . Assuming 10-18. 

a Modif,
single-port memory of the kind described in section

8.2.2.3.2, give multi-cycle behavioral remaining 
Verilog dat

to implement such LDR and STR in-
structions along with the other instructions described in 10.7. Create appropriate test 10-19. Modify
code. remaining dat,
10-12. Assuming a multi-port memory of the kind described in section 9.6, modify the 10-20. The A
pipelined behavioral Verilog of section 10.8.7 to implement the LDR and STR instruc- ir [27:22 ] =
tions described in problem 10-11. Create appropriate test code. Unlike chapter 9, oper-
and fetch does not MUL

occur until the execution stage of the pipeline, because the ARM has
a load instruction (LDR), rather than the addition instruction (TAD) of the PDP-8 which MLA
required an extra stage to complete. This is important because 'OPA or 'OPB may not Assume that th
be available until that final clock cycle. For the same reason, a STR followed by a LDR multi-cycle be]
from the same address will not require forwarding . structions usin
10-13. Rework problem 10-7 to support the instructions of problem 10-12. Note that Test with code
for the STR instruction there will need to be a mux that provides i r2 [ 15 : 12 ] to one 10-21. Modify
of the read ports of the register file. MUL and ML}
10-14. Using a multi-port memory like that in section 9.6 for problem 10-12 may be uct per clock c
too expensive. Design a memory hierarchy, consisting of two direct mapped caches 10-22. Modify
(section 8.5) and a main memory (that takes five cycles per access). One cache is for MUL and ML)
data manipulated by LDR and STR instructions, and uses the read, write, memreq,
memrack and memwack signals described in section 8.5.3. The other cache is only 10-23. Modify
for instructions being fetched, and uses ireq (which combines the roles of read and bit input to dete
memreq for this cache) and imemack. You may assume that no machine language 10-24. Modify
instruction will be modified during the execution of the program so that there is no
need for write-through with the instruction cache.

436 Verilog Digital Computer Design: Algorithms into Hardware

I



ddr/4 is even. 10-15. Draw a pure behavioral ASM chart which combines problems 10- 12 and 10- 14.
nd even instruc- In the event that an instruction is not in the instruction cache, let NOP(s) enter the
r the interleaved pipeline to stall until imemack is asserted. In the event that an LDR executes when the
mentor in addi- operand is not in the data cache, use a wait loop similar to those in section 8.5.2. For

STR instructions, use a write buffer, which consists of registers that hold the memory
address and contents while it is being written. The second of two successive STR in-

rleaved memory structions will go to a wait state only if the first is still being processed by the memory
aperscalar ARM hierarchy. Because of the write buffer an STR followed by a LDR from the same ad-
A. dress creates a dependency that will require forwarding.
machine, which 10-16. Assuming a powerful multi-port memory of some kind exists, modify the
C machines, the superscalar behavioral Verilog of section 10.9.8.2 to implement the LDR and STR
allows load and instructions described in problem 10- 11. Create appropriate test code.
kind are LDR

20] ==0). There 10-17. Modify the multi-cycle behavioral Verilog of section 10.7.6 to implement the
isider the simple remaining data-processing instructions described by appendix G. Give test code.
m) that accesses 10-18. Modify the pipelined behavioral Verilog of section 10.8.7 to implement the
ribed in section remaining data-processing instructions described by appendix G. Give test code.

)R and STR in-
appropriate test 10-19. Modify the superscalar behavioral Verilog of section 10.9.8.2 to implement the

remaining data processing instructions described by appendix G. Give test code.

i 9.6, modify the 10-20. The ARM has two multiplication instructions which are identified by
and STR instruc- ir[27 :22]==0 && irl[7:4]==9,MLJL(ir[21]==0)andMLA(ir[21] ==1):
chapter 9, oper- MUL r[ir[19:16]]<-r[ir[3:0]]*r[ir[11:8]]

use the ARM has
the PDP-8 which MLA r[ir[l9:16]]<-r[ir[3:0]]*r[ir[11:8]]+r[ir[15:12]

)r 'OPB may not Assume that the ALU does not include a combinational multiply operation. Modify the
[lowed by a LDR multi-cycle behavioral Verilog of section 10.7.6 to implement the MUL and MLA in-

structions using a shift and add algorithm such as the one explained in problem 2-7.
10-12. Note that Test with code that computes a quadratic polynomial, a*x*x+b*x+c.
[15:12] to one 10-21. Modify the pipelined behavioral Verilog of section 10.8.7 to implement the

MUL and MLA instructions assuming a combinational multiplier can produce one prod-
Em 10-12 may be uct per clock cycle. Use the same test code as problem 10-20.
t mapped caches 10-22. Modify the superscalar behavioral Verilog of section 10.9.8.2 to implement the
One cache is for MUL and MLA instructions. Use the same test code as problem 10-20.
rite, memreq,
her cache is only 10-23. Modify condx and f to allow for all sixteen conditions. Hint: f will need a 33-
DIes of read and bit input to detect overflow. Give a written justification why your test code is adequate.
.achine language 10-24. Modify 'OPB to include shift and rotate.
o that there is no

!ware RISC Processors 437



Regardless 
11. SYNTHESIS o

mable logic, I
programmabl

There are two common uses of Verilog: simulation and synthesis. Chapters 3, 5 and 6 circuits.' This
describe various features of Verilog that are useful for simulation, which is the inter- should be acc
pretation of Verilog source code on a general-purpose computer. This chapter gives
examples of synthesis, which is the automated process of transforming a subset of
Verilog statements into a netlist of gates whose interconnnections perform the algo- 11.1.1 DE
rithm specified by the Verilog source code. Figure 11-1 g

with one ano
design starts,
programmabl

11.1 Overview of synthesis ure 11-1 illus
There are two main vehicles for the implementation of synthesized designs: custom ous tools (sh(
integrated circuits (sometimes called Application-Specific Integrated Circuits orASICs) tools. The toc
and programmable logic. Custom integrated circuits are created by transforming the main synthesi
synthesized netlist for a particular design (i.e., the equivalent of gate-level structural and a downlo;
Verilog) into a specific geometric arrangement of metal, semiconductor and insulator standard Veri]
materials on an integrated circuit. To manufacture such circuits, an automated tool
draws the physical layout of the The 

circuit designer
on what is called a mask. The mask is then used

with photolithography or similar processes test 
to code and

mass-produce the circuit on chips.
ing files of fit

Programmable logic is fabricated in a similar way, but the masks used by the manufac- used with the
turer do not represent some specific design. Instead, a programmable logic chip con- or the results
sists of many building block devices together with a programmable interconnection tool (or possil
network. After the programmmable logic chip is manufactured and sold to the designer, havioral and/
bits are transferred into the chip which customize the programmable logic for a specific only one modi
design. Thus, the same physical hardware might be used by two different designers to synthesis, thei
implement two completely different designs. Because by itself programmable logic inside the hig]
lacks the ability for self-modification, it is not quite general purpose in the same sense
as a stored program machine (such as the Manchester Mark I, the PDP-8 Only the portl

or the Pentium
II). Historically, the concept of rewiring a synthesized 

fixed set cl
of building block units to solve

different problems can be traced back to the ENIAC in the early with the inten
1940s. Modern tech-

nology now allows interconnections inside a programmable physical pins
logic chip to be reconfigured

by simply changing the bits, rather than having module shouh
to pull out and plug in wires as was the

situation with the ENIAC's plugboards. As but all synthe!
a further convienence, Verilog synthesis

tools allow the modem designer (who may be ignorant of the wiring bit port 
patterns) of the 

to hit

reconfigure the programmmable logic by simply changing source code. Thus, in many
instances, using programmable logic with a synthesis tool provides a viable alternative
to software.

Assuming the dc
2 Some tools, suc
a case, the partitic

438 Verilog Digital Computer Design: Algorithms into Hardware



Regardless of whether the designer is targeting custom integrated circuits or program-
mable logic, the Verilog used for synthesis is similar, except the cost of synthesizing to
programmable logic is considerably cheaper than synthesizing to custom integrated

iapters 3, 5 and 6 circuits.' This chapter concentrates on programmable logic because the necessary tools
hich is the inter- should be accessible to interested readers.
is chapter gives
ning a subset of
erform the algo- 11.1.1 Design flow

Figure 11-1 gives the design flow, which shows how various automated tools interact
with one another. The design flow shows how to synthesize and test a design. The
design starts as Verilog source code. It gets translated and downloaded into a kind of
programmable logic, known as a Complex Programmable Logic Device (CPLD). Fig-
ure 11-1 illustrates the files (shown as rectangles) that are produced as output of vari-

designs: custom ous tools (shown as circles), and how, in turn, these files are used as input to other
'ircuits orASICs) tools. The tools shown in figure 11-1 include an optional synthesis preprocessor, the
transforming the main synthesis tool, a post-synthesis place and route tool targeting programmable logic
e-level structural and a download tool that transfers the design into the programmable logic chip. Also, a
~tor and insulator standard Verilog simulator plays an important part in the design flow.
i automated tool

The designer 
nask only 

is creates 
then used two or three files: one file to be synthesized, one file for the

test code and one optional 
lit on chips. file for the physical (pin number) information. The remain-

ing files of figure 11-1 are created automatically. The file containing test code can be
Ib y the manufac- used with the Verilog simulator to verify the operation of the file to be synthesized and!
e logic chip con- or the results of synthesis. The file to be synthesized, which is input to the synthesis

interconnection tool (or possibly the preprocessor), contains one or more Verilog module(s) using be-
Idt o the designer, havioral and/or structural features of Verilog. For pure behavioral synthesis, there is
)gic for a specific only one module, which, of course, is the highest level module of the file. For structural
-rent designers to synthesis, there could be multiple modules defined that are instantiated hierarchically
grammable logic inside the highest level module of the file.
in the same sense

Only 
'-8 the 

or portlist 
the Pentium of this highest level module determines how the physical pins of the

synthesized 
ck units to chip 

solve will be used. The portlists of lower level modules, if any, only deal
with the internal 

Os. connections 
Modem tech- within the chip and therefore have no influence on the

physical pins of the chip.2.ob e reconfigured . The input and output definitions for the highest level
module should 

wires include 
as was the the width of each port, since some synthesis tools require this,

but all synthesis 
Verilog synthesis tools and simulators accept this syntactic variation. Each bit of each

port 
ig of 

bit the 
patterns) highest 

to level module corresponds to a distinct physical pin of the synthe-
le. Thus, in many
viable alternative

Assuming the design will be manufactured only in small quanities.
2Some tools, such as PLDesigner-XL, allow a design to be partitioned onto multiple chips, but even in such
a case, the partitioning is automatic and not influenced by the Verilog ports of lower level modules.

ware Synthesis 439



supplied 11.1.2 T
optional by designer automated

The file to b
unsynthesiza
tial for using
a module wii
neous results
thesis of a Ve
'include

There are sev

What is not r
saving time 
far easier to d
mented in a p

The most thoi
support some
tools. This ou
netlist produc
the designer 
unsynthesizec
tor that allows
physical chip.

I l Although som

Figure 11-1 Designflowfor sense when th
CPLD synthesis. VITO, VerilogEASY MACHPRO

and PLDesigner-XL are specific natives 
tools discussed to finc

in section 11.1.3.
discover whic
makes a smal.

sized chip. The easiest and often most efficient approach is to let the synthesis tool that the correl
choose how to connect these bits to the physical pins. In some cases, such as using a algorithm thai
circuit board where the programmable logic chip already has its sysclk and similar signer use sim
signals soldered to specific pins, it is necessary for the synthesis tool to use specific is much harde
pins. There is no standard syntax in Verilog to indicate pin numbers in the file (. v) that when it is give
contains the highest level module, but many synthesis tools allow the designer to force of the design I
the tool to connect specific bits to specific pins with the physical information file (sec-
tion 11.3.6) or a similar approach.

440 Verilog Digital Computer Design: Algorithms into Hardware



-

11.1.2 Testing approaches
The file to be synthesized does not contain test code, since test code usually contains
unsynthesizable statements such as $display. On the other hand, test code is essen-
tial for using a synthesis tool properly. Since the Verilog file used for synthesis contains
a module with a portlist, running that file by itself on a simulator would produce erro-
neous results since the ports would be disconnected ( bz). When a designer does syn-

Nn thesis 
oa of a Verilog file, there needs to be another Verilog file with test code that does an

ool ' include of the synthesizable Verilog.
CHPR

There are several reasonable strategies for using a simulator to test synthesizable Verilog:
a) before synthesis
b) after synthesis but before place and route
c) after place and route

,3PLD, d) all of the above.

What is not reasonable is to neglect testing altogether. Designers who think they are
saving time by not writing test code for use in simulation are fooling themselves. It is

emulator far easier to detect bugs in simulation than after the synthesized design has been imple-
mented in a physical chip.

The most thorough strategy is to simulate at each step in the design flow. Most vendors
0)
0 support some kind of backannotated output from 

ao the synthesis and/or place and route
tools. This output is typically some kind of structural Verilog that gives the gate-level
netlist produced by the synthesis tool. By using this output together with the test code,
the designer may verify that the synthesized result behaves 

° E' similarly to the original
unsynthesized Verilog. The backannotationp rovides timing information to the simula-
tor that allows the designer to predict the speed of the design without having to test the
physical chip.

Although somewhat less desirable, the strategy of simulating only after synthesis makes
sense when the designer needs to explore many different algorithms and design alter-

IACHPRO natives to find an acceptable solution to a problem. In such a case, the first issue is to
discover which algorithms fit within the available hardware resources. If the designer
makes a small mistake with an algorithm that fits within the desired chip, it is likely

synthesis tool that the corrected version of the algorithm will also fit. After having discovered an
uch as using a algorithm that fits within the constraints of the hardware, it is important that the de-
1k and similar signer use simulation to determine whether there are any such bugs in the algorithm. It
to use specific is much harder to debug the algorithm after it is embodied in physical hardware than
te file (. v) that when it is given only as Verilog code for simulation, and so simulation should be part
-signer to force of the design process.
ation file (sec-

Synthesis 441



When the physical chip will not be operated near its maximum frequency, there often is 64 contains 12
no need to simulate the back annotated Verilog resulting from synthesis.3 In such a and a single 1
case, simulating only before synthesis may be reasonable. For example, the clock used directly availat
in this chapter is slow enough that propagation delay is not a concern with the designs OR gate receii
discussed below. We will do post-placement simulation only to illustrate the logical macrocell, m, 
correctness of the process, and not out of concern for speed. In commercial design,
speed is often an important issue, but correctness is always the first concern.

11.1.3 Tools used in this chapter
There are five specific software packages that are used as example tools in the design
flow of this chapter. The details would differ slightly if other vendors' tools were used
instead, but the basic principles of the design flow would be similar. The first software or alternatively
package, which is used only with the later examples in this chapter, is the Verilog
Implicit To One hot (VITO) synthesis preprocessor described in chapter 7 and appen-
dix F. The second software package is a synthesis tool, known as PLSynthesizer, which
is available from a company called MINC Incorporated. 4 The output of PLSynthesizer
is in a proprietary HDL known as DSL. PLSynthesizer also outputs structural Verilog
which is logically equivalent to the DSL for post-synthesis simulation. The third soft-
ware package is a place and route tool, known as PLDesigner, also from MINC, that where the (opti
converts the output of PLSynthesizer into what is called JEDECf ormat, which is a from the 1/0 pi
standard file format (. j 1) used by several different vendors for downloading to pro- signer does not
grammable devices. PLDesigner may optionally use a physical information (. pi) file constraints on I
to indicate pin numbers. PLDesigner outputs the equivalent of the JEDEC file as a cause of the int
structural Verilog netlist for post-placement simulation. In addition, PLDesigner cre- tool. This is true
ates a documentation file (. doc) which indicates pin numbers and logic equations (in and route tool 
DSL syntax). The fourth software package is a download tool known as MACHPRO, constraints of tl
from a CPLD manufacturer known as Vantis,5 that reads the JEDEC file and sends the
desired configuration to the programmable logic chip. The fifth software package is a Each 1/0 pin of
simulator, such as VeriWell. choose to disco

macrocells (641
flip flops that tf

11.1.4 The M4-128/64 CPLD the M4-128/64
The M4-128/64 is a CPLD chip manufactured by Vantis that comes in a 100-pin pack-
age, of which 64 pins are available for the designer to use.6 Vantis makes a 

Each of these 64 I/O pins
may be used as one bit of an input, output or inout mounted on it t(

port. Internally, the M4-128/
produces the sy

3Provided that the subset of Verilog used means the same thing in both synthesis and simulation.
7When the inputs t(

4 MINC has made a restricted version of this technology known as VerilogEASY available to readers of this up to 125 MHz. W
book. See appendix F for details. mum frequency is 1
5Vantis is a spinoff from Advanced Micro Devices (AMD), and the M4-128/64 used to be known as the 8 Of which the Field
AMD Mach445. rather than the ANI
6 The restricted version of VerilogEASY only allows 40 of these pins to be used. synthesis tool. In tl

442 Verilog Digital Computer Design: Algorithms into Hardware



, there often is 64 contains 128 units, known as macrocells. Each macrocell contains a single OR gate,
is.3 In such a and a single optional flip flop. The output of the OR gate either feeds the flip flop or is
the clock used directly available to other macrocells or 1/0 pins as combinational logic. The macrocell's
th the designs OR gate receives its inputs from a series of AND gates. Put another way, a particular
tte the logical macrocell, m, can either implement sequential logic:
iercial design,
cern. reg m;

always (posedge sysclk)
m= tl & t_2 &t1_3 & ...

t2_1 & t2_2 & t2_3 & ...
in the design

ols were used
first software or alternatively, that macrocell can implement combinational logic:

is the Verilog
7 and appen-

hesizer, which wire m = tll & tl12 & t1_3 &...
'LSynthesizer t2_1 & t2_2 & t2_3 &
ctural Verilog
[he third soft-
n MINC, that where the (optionally complemented) terns ti1, t1_2, etc. are either input wires
at, which is a from the I/O pins or are the outputs 11

of macrocells. In a particular macrocell, the de-
)ading to pro- signer does not have to use all the terms possible, but there are fairly complex internal
ion (. pi) file constraints on how many and which terms may be used in particular macrocells. Be-
DEC file as a cause of the internal complexity of the CPLD, it is necessary for the designer to use a
.Designer cre- tool. This is true even if the designer were to create a netlist manually because theplace
equations (in and route tool must transform the original netlist into one that fits within the complex
;MACHPRO, constraints of the CPLD.
and sends the

e package is a Each I/O pin of the M4-128/64 has an optional flip flop, which the synthesis tool may
choose to disconnect (for a combinational logic function of the input). Considering the
macrocells (64 bonded to 1/0 pins and 64 hidden) and the I/O pins, the total number of
flip flops that the M4-128/64 contains is 192. When all its macrocells are fully in use,
the M4-128/64 is the equivalent of about 5000 gates.

100-pin pack-
Vantis makes a printed 

se 64 I/O circuit 
pins board, known as a demo board, that has one M4- 128/64

~ mounted on it together 
t,h e M4-128/ with additional hardware, such as a 1.8432MHz oscillator 7 that

produces the sysc 1k signal. Although many similar types of devices exists the reason

ulation.
7 When the inputs to every macrocell only come from the internal flip flops, the M4-128/64 may be 

to clocked
readers of this up to 125 MHz. When macrocells are cascaded together to form complex combinational logic, the maxi-

mum frequency is lower. The 1.8432 MHz is slow enough to be safe for most designs.
be known as the 8Of which the Field Programmable Gate Array (FPGA) is perhaps the most common. The FPGA uses a table

rather than the AND/OR structure of a CPLD, but such details are seldom important to a designer using a
synthesis tool. In the 1990s, companies such as Xilinx and Altera were leading suppliers of FPGAs.

Synthesis 443



-

for describing the M4-128/64 demo board here is that it is well suited for small synthe- 11.2.3 Be
sis experiments. The M4-128/64 demo board connects to a personal computer via the One of the m
parallel (printer) port of that computer. This personal computer runs the synthesis tools level possible
(such as PLSynthesizer and PLDesigner) and also the MACHPRO software, which signing hardy
downloads the configuration of hardware determined by the synthesis tools into the ioral ASM" (5
M4-128/64. The downloading process changes which terms are connected to which tion 3.8.2.3). 2
macrocells. If a designer makes a mistake, it is a simple matter to download a corrected goes back for
version of the design because the internal technology of the CPLD is similar to an recently begu
EEPROM. designers havi

designs in les
there are somc

11.2 Verilog synthesis styles described in a]
the implicit st,

Regardless of whether the designer wants programmable logic or custom integrated plicit style cot
circuits, and regardless of which vendors' tools are involved, there are five basic styles few additional
of Verilog code used in synthesis: behavioral registers, behavioral combinational logic, are given in se
behavioral implicit style state machines, behavioral explicit style state machines and
structural instantiation. Often a particular design contains a combination of these styles.

11.2.4 Bet
In contrast 

11.2.1 to t
Behavioral synthesis of registers present state re,

As described in sections 3.7.2.2 and 4.4.4, the synthesizable model for a register is an synthesis vend
instantaneous assignment statement inside a block with a single time control syntax,
suchas @ (posedge sysclk), (posedge sysclk or posedge reset)
or @( posedge sysclk or negedge reset) time control. All synthesis ven- 11.2.5 Stri
dors support this Verilog construct. Registers synthesize to a group of flip flops, typi- The most prim
cally D-type flip flops. Often there is combinational logic associated with a register. An stances. If all r
example of synthesizing a register is given in section 11.3. thesis is simply

straints of the c]
of the kind(s) 

11.2.2 o
Behavioral synthesis of combinational logic synthesized app

There are two ways to describe combinational logic using behavioral Verilog that all 11.8.
synthesis tools accept: the continuous assign statement (section 7.2.1) and an al-
ways block with a sensitivity list composed of all the variables in the block that are
not on the left of any of the =s inside the block (section 3.7.2.1).9 All synthesis vendors
support both of these constructs. Combinational logic synthesizes to the primitive com- 11.3 Synt
binational units of the target hardware which are AND/OR gates for CPLDs, lookup As described in
tables for FPGAs and ROMs and arbitrary combinational gates for custom logic. An tial building blo(
example of synthesizing combinational logic is given in section 11.4. wide enabled re

except that we s
synthesis tools d
the size is menti

9 With the additional requirement that none of the variables on the left of the =s occur on the right of the =s.

444 Verilog Digital Computer Design: Algorithms into Hardware



small synthe- 11.2.3 Behavioral synthesis of implicit style state machines
nputer via the One of the main themes of this book is the advantage of solving problems at the highest
ynthesis tools level possible. Implicit style state machines provide this high-level approach for de-
1tware, which signing hardware. Most of the examples in this book only consider the "pure behav-
tools into the ioral ASM" (section 2.1.5.1) or its equivalent coding with implicit style Verilog (sec-
zted to which tion 3.8.2.3). Although, as noted in chapter 1, this high level of design has a history that
ad a corrected goes back for decades before the introduction of Verilog, the implicit style has only
similar to an recently begun to capture the attention of many Verilog designers. The reason that

designers have become interested in this style is that it allows them to produce correct
designs in less time. Unfortunately, not all synthesis vendors support this style, and
there are some restrictions on the support provided by those that do. The preprocessor
described in appendix F and chapter 7 allows a designer to use a reasonable subset of
the implicit style even when the synthesis tool does not support it. Synthesizable im-

om integrated plicit style consists of multiple @( posedge sysclk) inside an always, with a
ve basic styles few additional syntax restrictions that were not considered in earlier chapters. Examples
national logic, are given in sections 11.5, 11.6 and 11.9.
machines and
of these styles. 11.2.4 Behavioral synthesis of explicit style state machines

In contrast to the implicit style, the explicit style requires the designer to specify the
present state register and next state combinational logic, as explained in section 4.3. All

a register is an synthesis vendors support this style. An example is given in section 11.7.
ontsryonl tax,

dge reset)
synthesis ven- 11.2.5 Structural synthesis
lip flops, typi- The most primitive form of synthesis, which all tools accept, involves structural in-
h a register. An stances. If all modules being synthesized use only structural Verilog, the result of syn-

thesis is simply to flatten the netlists (section 2.5) and fit the design within the con-
straints of the chip. More typically, some of the modules being instantiated have some
of the kind(s) of behavioral code described above. In this case, the behavioral code is
synthesized appropriately before the netlist is flattened. An example is given in section

Verilog that all 11.8.
.1) and an al-
block that are

thesis vendors
primitive corn- 11.3 Synthesizing enabledregister
IPLDs, lookup As described in section D.6, the enabled register is one of the most important sequen-
istom logic. An tial building blocks used in computer design. Suppose we wish to synthesize a two-bit-

wide enabled register. The behavioral Verilog for this is identical to section 4.2.1.1,
except that we substitute the literal [1 : 0 ] to indicate the two-bit width since many
synthesis tools do not work properly with parameters and do not work properly unless
the size is mentioned in the input and output declarations:

he right of the =s.

are Synthesis 445



module enabled register(di,do,enable,clk); 11.3.1 Ii
input [1:0] di; There are tw
input enable,clk;

kind is insta
output [1:0] do;
reg [1:0] do; position beei
wire [1:0] di;
wire enable, clk;
always (posedge clk)
begin
if (enable)

do = di; There is no o
end kind of synt;

endmodule above in boli
because the r
of instantiatic

The above Verilog should work with any synthesis tool. If we synthesize the above ing is the san
with PLSynthesizer targeting the Vantis M4-128/64 chip mentioned above, we get the
following preplacement structural Verilog netlist:

LPM_

module LPMDFF_2_x(Ck,CkEn,D,Q);
input Clk,ClkEn,D; output Q; LPM_
wire netO, netl, net2, net3, net4;
NAN2 I_2_NAN2(.IO(netO),.Il(netl),.O(net2));
NAN2 I_3_NAN2(.IO(Q),.Il(net3),.O(netl));
NAN2 I_4_NAN2(.IO(ClkEn),.Il(D),.O(netO)); are among th
INV I_l_INV(.IO(ClkEn),.O(net3));
DFF IO(.CLK(Clk),.D(net2),.Q(Q),.QBAR(net4));
endmodule
module LPMDFFl x(Cik,CikEn,D,Q); 11.3.2 
input Clk,ClkEn; Mi

input[l:O]D; output[l:O]Q;
LPM_DF_2_x IO(.Clk(Clk),.ClkEn(ClkEn), The modules

.D(D[l]),.Q(Q[l])); gate-level tim
LPM_DFF_2_x Il(.Clk(Clk),.ClkEn(ClkEn), inside the M4

.D(D[O]),.Q(Q[0])); one in section
endmodule logical correc
module enabled register(di,do,enable,clk); this transform
input [1:0] di; output [1:0] do;
input enable,clk;
LPM_DFF lx dox x(.Clk(clk),.ClkEn(enable),

moduli
.D(di), .Q(do));

endmodule inpul
endmo
modul

inpi
endmo(

446 Verilog Digital Computer Design: Algorithms into Hardware



11.3.1 Instantiation by name
There are two kinds of structural instantiation syntax that are legal in Verilog. The first
kind is instantiation by position, as described in section 3.10. Had instantiation by
position been used above, the Verilog shown in bold would have been written as:

LPMDFF-l-x dox x(clk,enable,dido);

There is no other way to write this with the positional syntax of section 3.10. The other
kind of syntax that is legal in Verilog is instantiation by name, which is illustrated
above in bold. Like many synthesis tools, PLSynthesizer uses this alternative syntax
because the modules generated by the tool may have lengthy portlists. The advantage
of instantiation by name is that 

ize the 
the above ports may be rearranged in any order and the mean-

ing is the same. For example, 
ve, the 

we following:
get the

LPMDFF_1_x dox_x(.D(di), Q(do),
.Clk(clk),.ClkEn(enable));

LPMDFF_1_x dox_x(.Q(do), D(di),
.ClkEn(enable),.Clk(clk));

are among the twenty-four permutations that mean the same thing.

I
11.3.2 Modules supplied by PLSynthesizer
The modules in section 11.3.1 (such as NAN2, INV and DFF) could contain detailed
gate-level timing information, but this netlist has not yet been placed. After placement
inside the M4-128/64 CPLD, the netlist is likely to be considerably different than the
one in section 11.3.1. Rather, the netlist in section 11.3.1 is primarily of use to show the
logical correctness of the transformation carried out by the synthesis tool. To illustrate
this transformation, we will define idealized versions of the modules it instantiates:

module NAN2(IO,Il,o);
input IO,Il;output O;nand gl(O,IO,Il);

endmodule
module INV(IO,O);

input IO;output O;not g2(0,IO);
endmodule

re Synthesis 447



-9

Continued Continued

module DFF(CLK,D,Q,QBAR);
input CLK,D;output Q,QBAR; out]
assign QBAR = -Q; inp
always @(posedge CLK)Q = D; inp

endmodule enabled

endmodu.
11.3.3 Technology specific mapping with PLDesigner
In addition to structural Verilog, PLSynthesizer produces the same netlist in a propri- Although much
etary form, known as DSL. The place and route tool, PLDesigner, uses the DSL to there are a few f
generate a netlist that is fitted within the constraints of the M4-128/64 CPLD. The mentioned prev
output of PLDesigner includes the JEDEC netlist and an equivalent post-placement proper meaning
Verilog netlist. Such post-placement structural Verilog more accurately reflects the re- the supply d
sult of place and route than the netlist produced by PLSynthesizer. For this example, 7.2.1) of the on(
the resulting structural Verilog'" of the enabled register is: inside the M4-

mbuf and df f
//Model automatically generated by Modgen Version 3.8 model hardware
'timescale lns/lOOps ated by PLDesi1
enabledoOO(dolOr,dollr,dillr,enable,dilOr,clk); ioral module nai
output dolOr, dollr; may differ from
input dillr, enable, dilOr, lk; supplyO GND; name is done.
wire pin-8,pin-1l,pin_12,pin_13,pin_93,pin_94,tmpl2,
tmpl4,tmpl5,tmpl6,tmpl7,tmpl8,tmpl9,tmp2O,tmp2l,tmp22; In addition to thi
portin PIl(pin-8,dillr); portin PI2(pin ll,enable); tation file (. do(
portin PI3(pin-12,dilOr); portin PI4(pin_13,clk);
portout Pl(dolOr,pin-93); portout P02(dollr,pin_94);
mbuf Bl(tmpl2,pin-13); and A(tmpl5,pin_12,pin_11);
not Il(tmpl7,pin_11); and A2(tmpl6,pin-93,tmpl7);
or 0l(tmpl4,tmpl5,tmpl6);
dffarap DFFl(pin_93, tmpl2, tmpl4, GND, GND);
mbuf B2(tmpl8,pin_13); and A3(tmp2O,pin_8,pinll);
not I2(tmp22,pin_11); and A4(tmp2l,pin-94,tmp22);
or 02(tmpl9,tmp2O,tmp2l); This is a much
dffarap DFF2(pin-94, tmpl8, tmpl9, GND, GND); indicate the mac
endmodule more understanc

must be rewrittei
manual translati4

always @
begin
do[1]<:
do[O]<:

10 This Verilog was edited slightly for brevity. end

448 Verilog Digital Computer Design: Algorithms into Hardware



Continued

module enabledo(do, di, enable, lk);
output [1:0] do;
input [1:0] di;
input enable, clk;

enabledoOO Ul(.dol0r(do[O]), .dollr(do[l]),
.dillr(di[l]), .enable(enable),
.dil0r(di[O]), .clk(clk));

endmodule
ner
.en etlist in a propri- Although much of the syntax used in the above code should be familiar from chapter 3,
er, uses the DSL to there are a few features of Verilog used in the above code (shown in bold) that were not
*128/64 CPLD. The mentioned previously. First is timescale which allows the simulator to attach the
lent post-placement proper meaning to $ time that corresponds to the actual physical hardware. Second is
-ately reflects the re- the supplyO declaration, which is a shorthand for a continuous assignment (section
br.F or this example, 7.2.1) of the one-bit wire GND to 0, which models the connection to electrical ground

inside the M4-128/64. Third are some user-defined modules (portin, portout,
mbuf and dffarap) supplied by PLDesigner and explained in section 11.3.4 that

Dn 3 .8 model hardware resources of the M4- 128/64. The name of the top level module gener-
ated by PLDesigner derives from the file name (enabledo. v) rather than the behav-
ioral module name (enabled-register), and the order of the ports of this module
may differ from that of the original behavioral Verilog which is why instantiation by
name is done.

tmpl2,
,tmp22; In addition to the post-placement structural Verilog, PLDesigner produces a documen-
].e); tation file 
L) ; (. doc) which summarizes the logic equations implemented by the netlist:
i_94);

11);
do[1].D=do[l]*/enable+di[l]*enable;
do[l].CLK=clk;
do[O].D=do[O]*/enable+di[O]*enable;
do[O].CLK=clk;

This is a much more primitive language than Verilog. The . D and . CLK notations
indicate the macrocells are being used as D-type flip flops. To put the above in the
more understandable Verilog form, the notation for Boolean operations ('*', '+', '/')
must be rewritten into the corresponding Verilog notation ('&', " '-'). The following
manual translation is the equivalent behavioral Verilog:

always @(posedge clk)
begin
do[l]<= #((di[l]&enable)l(-enable&do[l]));
do[0><= #((di[o]&enable)l(enable&do[OJ));
end

ardware Synthesis 449

A



The assignment statements must be non-blocking (with time control of #0) and must be different hard
listed inside an always block with a single @( posedge clk) as the time control. nal from an I/
This non-blocking assignment is somewhat different than the one used in earlier chap- portoutco
ters. It is used above so that the order in which the Verilog statements occur will not 1/0 pin to be
effect the result. Since the non-blocking assignments use #0, the effect is almost the macrocells. L
same as plain =, except all of the right-hand values will be evaluated before any of the be timing, wh
left-hand values are changed. Because of the single @( posedge clk) at the begin-
ning of the always block, do will only change at the rising edge of the clock. The Although Ver
only reason to manually rewrite these logic equations back into Verilog is to describe not, Verilog
the meaning of the . doc file. This file explains the transformation that PLSynthesizer and route too
has performed on the original behavioral Verilog more succinctly than the netlist. technology, ir

flip flop, which

11.3.4 Modules supplied by PLDesigner
Like most other place and route tools, PLDesigner allows for backannotation of timing
information in the netlist after the place and route phase. Such post-placement infor-
mation is more accurate than post-synthesis preplacement information because the place
and route tool knows how signals will be routed through the actual chip. The details of
how such information gets inserted into the structural Verilog output from a place and
route tool varies among different vendors. In the case of PLDesigner, the modules used
in section 11.3.3, such as portin, portout and mbuf, can contain detailed gate-
level timing information, such as specify blocks, to model the interconnect delays
that occur between macrocells in the M4-128/64. PLDesigner also generates an . sdf
file which includes actual min/typ/max timing information for the routed circuit. For
our purposes, we are not concerned about such detailed timing information but are
rather only interested in the logical correctness of the transformation carried out by the
place and route tool. To illustrate these transformations, we will define idealized ver-
sions of these modules. The first three of these are simply buffers that pass the input (i)
through unchanged as the output (o): The above mo

preset (AP). Su
when it is first

module portout(o,i); chronous signt
input i; output ; buf b(o,i);

endmodule
module portin(o,i); 11.3.5 Th
input i; output ; buf b(o,i); As explained ii

endmodule consisting of a
module mbuf(o,i); synthesized int
input i; output ; buf b(o,i);

endmodule

The reason PLDesigner uses all three of these is that, in the actual backannotated Verilog, 1 For a CPLD, the
with the macrocell

these might have different delays associated with them because they correspond to route tools for FP(

450 Verilog Digital Computer Design: Algorithms into Hardware



and must be different hardware units within the M4-128/64. port in corresponds to routing a sig-
ime control. nal from an 1/0 pin used as an input on a wire that connects to an internal macrocell.
earlier chap- portout corresponds to taking the output of an internal macrocell and routing it to an
,cur will not 1/0 pin to be used an output. mbuf corresponds to an internal connection between
s almost the macrocells. Logically, all three of the above are equivalent. The only difference would
re any of the be timing, which we are ignoring in this example.

cloec k. The Although Verilog provides built-in gates for combinational logic, such as and, or and
to describe not, Verilog does not provide built-in gates for 

Synthesizer sequential logic." Therefore a place
and route tool must supply modules for the sequential logic resources of the target

netlist. technology, in this case the M4-128/64. Recall that each macrocell contains a D-type
flip flop, which can be modeled as:

module dffarap(Q,CLK,D,AR,AP);
on of timing output Q;
ement infor- input CLK,D,ARAP;
use the place reg Q; 

always (posedge -
'he details of CLK or

posedge AP or posedge AR)
a place and begin

nodules used if (AP)
etailed gate- Q = 1;
nnect delays else if (AR)
Ltes an . sdf Q = 0; 
I circuit. For else
ation but are Q D;
ed out by the end
dealized ver- endmodule

the input (i) The above models a flip flop with an asynchronous reset (AR) and an asynchronous
preset (AP). Such asynchronous signals are typically only used to initialize a controller
when it is first powered up (see sections 4.4.4 and 7.1.6). In this example, these asyn-
chronous signals are not used, and so they are instantiated with a connection to GND.

11.3.5 The synthesized design
As explained in figure D-17, an enabled register can be described with a block diagram
consisting of a mux and a simple D-type register. Since figure D-17 is going to be
synthesized into a physical component, either the designer or the synthesis tool must

11 For a CPLD, there 
tated is no 

Verilog, delay attributed to a particular AND or OR gate. Rather the delay is associated
with the macrocell. For this reason, PLDesigner-XL uses built-in delayless and, or and not. Place and

:orrespond to route tools for FPGAs or custom logic may take a different approach.

Synthesis45 451



choose which signals will go in and out of the pins of the chip. In this instance, there are
four bits of information being input and two bits of information being output, as illus- pin-
trated in figure 11-2.

pin-
I- ---.-. --.--I ------------------------------------------- -- I

die | 4dO
2' "2* 

enableI
pin.

nlk 

I
Figure1 1-:

Figure 11-2. Physical pins of M4-128/64 usedfor two-bit enabled register.
slices.

The structural Verilog refers to the internal wires that connect to the 1/0 pins with the 11.3.6 Ma
prefix pin_. This could be a little confusing since, for example, pin13 is not actu- The physical I
ally the physical pin 13 but rather is the signal from that pin after it has been buffered designer wish
internally by the M4-128/64. In this design, pin_13 is logically the same as the clk For example,
port, which presumably would connect to the global sysclk signal. The instance U1 ware soldered
of enabledoOO separates the individual one-bit nets from the multi-bit ports. There
are buses (which are oversimplified in this diagram) that connect the I/O pins to the
macrocells. The actual implementation of the synthesized design occurs in the
macrocells.

The synthesis tool has bit blasted the design into individual one-bit-wide bit slices,
each one of which fits into a single macrocell, as shown in figure 11-3.

The circuit in figure 11-3 is a literal transcription of the Verilog produced by the syn-
thesis tool. Notice how each bit slice of the mux has turned into an AND/OR gate l

arrangement. When enable (pin_11) is asserted, the outputs of theA2 andA4AND
gates will be zero. Thus, di [0] (pin_12) and di [] (pin_8) will pass through The wires wl
their respective OR gates (01 and 02) to become the new values of their respective flip Diodes (LEDs:
flops (DFFI and DFF2) at the next rising edge of clk (pin_ 13). When enable is signals control
not asserted, the old values (pin_93 and pin_94) will be reloaded into their respec- at the top and c
tive flip flops (DFFI and DFF2) at the next rising edge of clk. should be 1 to

452 Verilog Digital Computer Design: Algorithms into Hardware



aanncce", tdh.eerree  are
lOuutptpluit,,  a s illus-

- pin_93
------ I

II
il0rj ir +ddOO

>22 
____L

illlr r: i
. I pin_8-' MACROCELL !

i tm 2 I pin_94

tmnp22 
~ tmpl8 DFF2

Ji  r~ ~ ~  N p in 13 B

I I Figure 11-3. Macrocells in M4-128/64 implementing enabled register bit
,'iYsmitmerK slices.

/((O  pIpinins with the 11.3.6 Mapping to specific pins
_-11 3-. 3iis n.ioott  actu- The physical pin numbers shown in figure 11-2 were chosen by PLDesigner. Often a
iiss b ee,een buffered designer wishes to override the choices automatically made by the place and route tool.
iarmne, e as the c1lk For example, on the M4-128/64 demoboard, certain pins are attached to other hard-
The instLaanncce U 1I ware soldered on the board:
,.---bit sppIoolrrts..  There
- 1M/0O) pR inUss to the
n oc-Iccuurrss   in the al:93 a2: 5 a3:19 a4:31 sysclk:13

bl:94 b2: 6 b3:20 b4:32 reset: 4
c1:95 c2: 7 c3:21 c4:33 sw3:18

tL--wWiidiIdeCe   b,fit slices, dl:96 d2: 8 d3:22 d4:34 sw2:54
3.. el:97 e2: 9 e3:23 e4:35 swl:63

fl:98 f2:10 f3:24 f4:36 swO:68
l[uceedXI bd,y i  the syn- gl:99 g2:11 g3:25 g4:37
Linn A NED /OR gate
bbA  22 an(dI AM4 AND
wKwiilll pwsass  through The wires whose names above begin with "a" through "g" are for Light Emitting
eir riersepspse-eccttiive  flip Diodes (LEDs) in seven-segment displays. For example, the active low al . . . gi
Wheena ne naabbllle iis signals control the leftmost digit. These seven segments are labeled clockwise, with al
into(ti  thheiei,irr  respec- at the top and gl at the center; thus bl, cl, f 1 and gl should be 0 and al, dl and el

should be to display the digit "4." The 1.8432MHz clock is available as sysclk,

Il1wajrree Synthesis 453

i



and a debounced push button provides the active low reset, which is also activated module adz
when the demoboard is powered up. There are four input DIP switches (swO 0 sw3) output [3
available on the demoboard. wire [3:0

assign s[(
These input pins can be named anything the designer wishes. For example, in the en- assign s[:
abled register of section 11.3, it might be reasonable to take the enable from the (a[ll&a[(
switch on pin 54, and the di bus from the switches on pins 63 and 68. The two do bits (-a [ ]&-E

might directly drive the al and bl LED segments' 2 on pins 93 and 94. Note that be- assign c2

cause of the active low nature of the LEDs, the light will not illuminate when the bit is &b[21&b[1]

a one, but it will light up when the bit is a zero. The following file, whose name must be |(a[2]&a[1
assign s2

similar to the name of the file that contains the module to be synthesized but with the |(a[2]&-a[
extension .pi, is required to indicate the pin numbers to PLDesigner: (a[2]&-a[

(a[2]&a[1
(a[2]&a[0

{MAXSYMBOLS 0,MAX-PTERMS ,POLARITYCONTROL TRUE, |(-a[2]&a[
MAXXORPTERMS ,XORPOLARITYCONTROL FALSE}; |(-a[2]&-a
device target 'partnumber amd MACH445-12YC'; |(a[2]&-a[
OUTPUT do[l]:93;OUTPUT do[0]:94;INPUT clk:13; (-a[2]&a[
INPUT enable:54;INPUT di[l]:63;INPUT di[0]:68; assign s[3

end device; |(-a[3&-b
endmodule

11.4 Synthesizing a combinational adder Of course, the d
As described in section C.3, the adder is one of the most important combinational This lengthy ot
building blocks used in computer design. There are many ways (sections 3.10.5 through omitted for bre,
3.10.7) to code an adder in Verilog, both behaviorally and structurally. Of these, the depending on I
behavioral description is the easiest for the designer: LPMADD_SUI

module addpar(s,a,b); This result from
output [3:0 s; solving the sam
input [3:0] a,b; the place and ro
reg [3:0] s; the M4-128/64.
wire [3:0] a,b; distinct carry sil
always @(a or b) all but the most

s = a + b; together in a pr.
endmodule propagation deL

As in the last example, the input and output definitions need a size (four bits in
this case). When the above is synthesized similarly to the last example, PLDesigner 11.4.1 Test
produces a . doc file that describes a series of logic equations for each bit of s. The In any event, the
following is a manual translation of this back into Verilog: 6.3.2) that does,

12 Which just happen to be the same as the last example.

454 Verilog Digital Computer Design: Algorithms into Hardware



also activated module addpar(s,a,b);
(swO 0 sw3) output [3:0] s; input [3:0] a,b;

wire [3:0] s,a,b; wire [3:3] c;
assign s[0] = ((a[0]&-b[0])j(-a[0]&b[0]));

nple, in the en- assign s[l] = ((a[l]&-b[l]&-b[O])|(a[l]&-a[0]&-b[l])
ible from the l(a[l]&a[0]&b[l]&b[0 )1(-a[l]&a[0]&-b[l]&b[0])
.he two do bits 1(-a[l]&-a[0]&b[l])1(-a[l]&b[l]&-b[0]));

1.N ote that be- assign c[3]=((a[l]&a[0]&b[2]&b[0])1(a[2]&b[2l)1(a[O]
&b[2]&b[l]&b[0])1(a[2]&a[1]&b[l]) 

when the bit is (a[l]&b[2]&b[l]))
I(a[2&a[l]&a[0&b[0)1(a[2&a[0]&b[l]&b[0]);

e name must be assign s[2] = ((a[2]&-b[2]&-b[1&-b[0])
ed but with the l(a[2]&-a[l]&-b[2]&-b[1])1(a[2]&-a[l]&-a[0]&-b[2])

l(a[2]&-a[l]&-b[2]&-b[0])1(-a[2]&-a[l]&b[2]&-b[l])
l(a[2]&a[l]&a[0]&b[2]&b[0])1(-a[2]&a[l]&-b[2]&b[l])
|(a[2]&a[0]&b[2]&b[l]&b[0])1(-a[2]&b[2]&-b[l]&-b[0])
1(-a[2]&a[l]&a[0]&-b[2]&b[0])1(a[2]&a[1l]&b[2]&b[])
1(-a[2]&-a[l]&-a[0]&b[2])1(-a[2]&-a[l]&b[2]&-b[0])
l(a[2]&-a[0]&-b[2]&-b[1])1(-a[2]&-a[0]&b[2]&-b[l])
(-a[2]&a[0]&-b[2]1&b[1]&b[0]));

assign s[3] = ((a[3]&-b[3]&-c[3])1(a[3]&b[31&c[3l)
1(-a[3]&-b[3]&c[3])1(-a[3]&b[3]&-c[3]));
endmodule

Of course, the designer would probably use the backannotated output from PLDesigner.
combinational This lengthy output, which is equivalent to the above assign statements, has been

i 3.10.5 through omitted for brevity. In this output, the internal name for the one-bit carry wire varies
y. Of these, the depending on how the module is synthesized. The name might be something like

LPMADDSUBl_x__nO02.I tmightalsobejustc[3] asshownabove.

This result from synthesis is quite a bit more complicated than one might expect when
solving the same problem manually using full-adders. The above is complex because
the place and route tool utilizes the wide AND/OR gates that exist in each macrocell of
the M4-128/64. In the classical ripple carry adder (section 2.5), there needs to be a
distinct carry signal input to each full-adder. Here the tool has eliminated the carry for
all but the most significant bit by merging the logic equations for several full-adders
together in a process known as node collapsing. This has the effect of lowering the
propagation delay.

ize (four bits in
)le, PLDesigner 11.4.1 Test code
ch bit of s. The In any event, the designer needs to test the adder. Here is test code (sections 3.10.5 and

6.3.2) that does an exhaustive test:

Synthesis 455



Continued.

enm
endmoc

The original 1:
s[1 ] all produce th

inputs were r

As in the last 
modules for I
used, the #1 M
propagation d

11.4.2 All
An alternate v
mathematics 

module ad(
output

1 input [:

Figure 11-4. Macrocells in the M4-128/64 for low-order two-bit slices of adder reg [3:1
wire [3

module test; reg [3:1
integer ia,ib,numerr;
reg [3:0] a,b; wire [3:0] sum;
addpar al(sum,a,b); function
initial input 
begin begin
numerr = 0; case
for (ia=O; ia<=15; ia=ia+l) 3']
for (ib=O; ib<=15; ib=ib+l) 3']
begin 3']
a=ia; b=ib; 3']
#1 $display("%b %b %b",a,b,sum); 3']
if ((ia+ib)%16 !== sum) 3']
begin 3']
$display( "error");numerr=numerr+l; 3']

endci

456 Verilog Digital Computer Design: Algorithms into Hardware



_ 9

Continued.

end
end

$display("numerr=",numerr);
end

endmodule

iI- The original behavioral adder, the preplacement netlist and the post-placement netlist
-_s[1] all produce the correct results for the 256 combinations of inputs. If the width of the

inputs were much larger, such an exhaustive test would be impossible.
As in the last example, we are ignoring the back annotated delay by supplying delayless
modules for portin, portout and mbuf. If the backannotation capability were
used, the #1 would have to be changed to an appropriate delay longer than the longest
propagation delay of the synthesized design.

11.4.2 Alternate coding with case
An alternate way to describe this adder is to use behavioral statements that express the
mathematics behind the ripple carry approach:

I
module addpar(s,a,b);

output [3:0] s;
input [3:0] a,b;

ces of adder reg [3:0] s;
-j f _ t) i a,-
reg [3:0] c;

function car;
input a,b,c;
begin

case ({a,b,c})
3'bOOO: car = 0;
3'bOOl: car = 0;
3'bO10: car = 0;
3'bOll: car = 1;
3'blOO: car = 0;
3'bll: car = 1;
3'bllO: car = 1;
3'blli: car = 1;

endcase

dware Synthesis 457



Continued

end
endfunction

function sum;
input a,b,c;
begin

case ({a,b,c})
3'bOOO: sum = 0;
3'bOOl: sum = 1; Either the ca
3'bOlO: sum = 1; of input, all 2
3'bOll: sum = 0; problem is th
3'blOO: sum = 1;
3'blOl: end of the 

sum = neC
0;

3'bllO: sum = 0; erly except fo
3'blll: sum = 1; of the functio

endcase
end

endfunction

always @(a or b)
begin

c[O] = 0;
s[0] = sum(a[0],b[O],c[O]);
c[l] = car(a[O],b[O],c[O]); A case like t
s[l] = sum(a[l],b[l],c[l]); asynchronous
c[2] = car(a[l],b[l],c[l]); the case full:
s[2] = sum(a[2],b[2],c[2]); synthesis dire
c[3] = car(a[2],b[2],c[2]);

simulator, 
s[3] = but

sum(a[3],b[3],c[3]);
end directives suc]

endmodule synthesis to di
supplying the
simulation. Ai

Here car is a function that models the carry required for the next higher bit position changes how s
when adding three bits, and sum is the corresponding result in the current bit position.
These functions may be coded several ways. An alternative

inside the func
The case statement approach used above is a direct expression of the truth table for a
full-adder. For synthesis, we do not consider bx and bz values in the cases the way In any event, t
that might be necessary for simulation. This is because the synthesis tool implements same sensitivit
the case statement using = = rather than ===, which is all that is physically possible in other way this
hardware: statements rath

458 Verilog Digital Computer Design: Algorithms into Hardware



2
if ({a,b,c}==3'bOOO) car = 0;
else if ({a,b,c}==3'bOOl) car = 0;
else if ({a,b,c}==3'bOlO) car = 0;
else if ({a,b,c}==3'bOll) car = 1;
else if ({a,b,c}==3'blOO) car = 0;
else if ({a,b,c}==3'blOl) car = 1;
else if ({a,b,c}==3'bllO) car = 1;
else if ({a,b,c}==3'blll) car = 1;

Either the case or the i f statement approach is acceptable because for the three bits
of input, all 2 possible cases are listed. Such a situation is known as a full case. The
problem is that without a default clause in the case or an equivalent else at the
end of the nested i fs, the synthesis tool will not synthesize combinational logic prop-
erly except for a full case. For example, the following case, which only lists the ones
of the function, is not full:

case ({a,b,cl)
3'bOO1: sum = ;
3'bOlO: sum = 1;
3'blOO: sum = 1;
3'blll: sum = 1;

endcase

A case like this that is not full will synthesize to what is known as a latch, which is an
asynchronous sequential circuit, rather than the desired combinational logic. To make
the case fullrequires using default:sum=O; intheabove orusing a full case
synthesis directive. A synthesis directive is a comment which would be ignored by a
simulator, but which causes the synthesis tool to alter its operation. Use of synthesis
directives such as full case is common, but is dangerous because it may cause
synthesis to disagree with simulation. It is better to make the case statement be full by
supplying the appropriate default since that acts the same in both synthesis and
simulation. Another common but dangerous directive is parallel case, which

higher bit position changes how synthesis interprets the case to be like ifs without elses.
irrent bit position.

An alternative approach to the case statement would have been to use logic equations
inside the functions, such as sum=a^b~c.

he truth table for a
[t he cases the way In any event, the combinational logic is defined using an always block having the
s tool implements same sensitivity list as the example in the last section that invokes the functions. An-
tsically possible in other way this could have been defined is with eight separate continuous assignment

statements rather than the one always block:

aware Synthesis 459



I assign c[O] = 0; I
assign s[0] = sum(a[0],b[O],c[O]); cycle appro;
assign c[1] = car(a[0],b[O1,c[O]); proach take
assign s[1] = sum(a[l],b[1],c[1]); single-cycle
assign c[2] = car(a[l],b[1],c[1]);
assign s[2] = sum(a[2],b[2],c[2]); .1 F
assign c[3] = car(a[2],b[2],c[2]); .5.1 F
assign s[3] = sum(a[3],b[3],c[3]); In order for

easily, the sy
described in

Regardless of which of these variations we choose, the result is isomorphic to the origi- dsurt thei  
nal. This is because the wire [3 :0] c is internal, and the synthesis tool can optimize le during a i
it away, just as it did when synthesizing directly from a+b. The only distinction is the man @ ao 
name chosen for c [ 3] , but otherwise the result is an identical netlist. In this example, many @( po
all the extra coding of the sum and car functions did not change the actual structure of chalgorith
the synthesized circuit. The details of the synthesized logic equations were dictated of the sum al
more by the capabilities of the CPLD exploited by the place and route tool than by the designer
anything that the designer codes. The main responsibility of the designer is to write always blo
correct Verilog. Usually, the designer should choose the modeling style which is easi-
est to understand (a+b in this example) and trust the synthesis tool to choose the logic
equations that fit into the target device.

11.5 Synthesizing an implicit style bit serial adder
Rather than worrying about gate-level details, the designer should consider algorith-
mic alternatives. Although addition of two binary numbers usually is implemented as
combinational logic, there are other approaches. The dependent sequence of calls to
the sum and car functions inside the module addpar of section 11.4.2 makes it clear
that the conventional ripple carry adder is the combinational logic required to imple-
ment one of the algorithmic variations explained in chapter 6: the single-cycle ap-
proach. Assuming we have a single register to load the sum at the next rising edge of
the clock, the ripple carry adder computes in a single clock cycle all the information
needed to form the next sum. In earlier chapters, we have assumed such a building
block whenever we need to add. This approach for the module addpar is sometimes
known as a bitp arallela dder because all of the bits of the sum are available in parallel
by the end of a single clock cycle.

Chapter 6 also describes other algorithmic alternatives besides the single-cycle ap-
nrnnch. One f thee is the ti-cvele a- -- Jrach in tIeI -I li-.r-yv ------ L., V-1LA1

step in the dependent sequence is scheduled to occur in a different clock cycle. It is
often possible to clock a multi-cycle machine faster than is possible with the single-

460 Verilog Digital Computer Design: Algorithms into Hardware I 



PI-

cycle approach because less computation occurs per clock cycle. The multi-cycle ap-
proach takes several of these faster clock cycles to achieve the same result that the
single-cycle approach achieves in one slower clock cycle.

11.5.1 First attempt at a bit serial adder
In order for the designer to have the freedom to explore such algorithmic variations
easily, the synthesis tool should support the implicit style of Verilog. (The preprocessor
described in chapter 7 and 

rphic appendix 
to the F is 

origi- available for those synthesis tools that do not
support the implicit style.) With the implicit 

tool can style, 
optimize whether something occurs in paral-

lel during a single cycle or in series 
distinction during multiple 

is the cycles is simply a question of how
many @( posedge sysclk)s the designer 

In this example, uses. In the case of the bit parallel addi-
tion algorithm given in section 11.4.2, 

ctual it is 
structure a trivial matter 

of with implicit style Verilog to
change it to what is called a bit serial addition 

)ns were algorithm, 
dictated which produces only one bit

of the sum at a time. To do this, the assigns 
Dute tool become 

than by non-blocking assignments, and
the designer inserts @( posedge sysclk) 

signer at 
is appropriate 

to write places inside the implicit
always block:

yle which is easi-
)c hoose the logic 'define CLK (posedge sysclk)

'define ENS #1

always
begin

adder
:onsider algorith- @(posedge sysclk) 'ENS;

si mplemented as C[O] <= 'CLK 0;

iuence of calls to @(posedge sysclk) 'ENS;
s[O] <= 'CLK sum(a[O],b[O],c[O]);

4.2 makes it clear c[lJ <= 'CLK car(a[O],b[O],c[O]);
equired to imple- @(posedge sysclk) 'ENS;
single-cycle ap- s[l] <= 'CLK sum(a[l],b[l],c[l]);

-xt rising edge of c[2] <= 'CLK car(a[l1,b[1],c[1]);
I the information @(posedge sysclk) 'ENS;
I such a building s[2] <= 'CLK sum(a[2],b[2],c[2]);
)ar is sometimes c[3] <= 'CLK car(a[2],b[2],c[2]);

ailable in parallel @(posedge sysclk) 'ENS;
s[3] <= 'CLK sum(a[3],b[3],c[3]);

single-cycle ap- end

e approach, each
clock cycle. It is
with the single-

ware
Synthesis 461



11.5.2 Macros needed for implicit style synthesis A synthesis
In order for the implicit style to be practical, the result of simulation of implicit style earlier exar
Verilog before synthesis must agree with the result of simulation after synthesis (and, r2[0], c
of course, the behavior of the physical hardware). Some synthesis tools are restricted can now occ
as to the use of time control, but as discussed in section 3.8.2.1, simulators need # time bit wire fo
control to simulate non-blocking assignment properly inside implicit style blocks. There- suffices here
fore, in order that simulation agree with synthesis, it is recommended that all of the
time control required for simulation be coded With this 

as macros. sh:
Only the time control needed

by the synthesis tool (the @( posedge sysclk) cycle, r2 
that is

denotes a state boundary out-
side a non-blocking assignment) is written cycle, 

without r2 
a [ 0

macro. The other two forms of
time control [the #1 and the third 

@( posedge clock c
sysclk) inside the non-blocking assign-

ment] are written using macros ( ENS cessed 
and ' first,;

CLK). This way, they can simulate prop-
erly when the macros are defined bit serial 

as shown ted
above, but they can be synthesized properly

when the macros are defined as empty. The role of 
rl is reused

11.5.3 result. 
Using As a 14

a shift register approach become the 
A disadvantage of the code in section 11.5.1 is that it performs similar computations on such bits are
different bits of the data. The synthesis tool will either have to duplicate the hardware result bits wi
to implement the sum and car functions multiple times, or use muxes to allow re-
source sharing, in a way analogous to the central ALU approach. To avoid this prob-
lem, we can use a shift register approach: 11.5.4 Ui

There is still
reg c;
reg [3:0] rl,r2; states (and tl

Although the
~(posedge sysclk) 'ENS; ate to the nur
r2 <= 'CLK ; rl <= 'CLK x; be proportion
c <= 'CLK 0;
@(posedge sysclk) 'ENS; Here is when
rl <= CLK sum(r1[0],r2[03,c),r1[3:1]}; designer can 
c <= CLK car(rl[O],r2[0],c); inside a whi-
r2 <= 'CLK r2 >> 1; the loop unro]
Q(posedge sysclk) 'ENS; RISC achin
rl <= 'CLK {sum(rl[O],r2[0],c),rl[3:1]); increase the s
c <= CLK car(rl[O],r2[0],c); to implement
r2 <= 'CLK r2 >> 1; a loop counte
@(posedge sysclk) 'ENS;

state.
rl <= 'CLK {sum(rl[O],r210],c),rl[3:1]};
c <= 'CLK car(rl[O],r2[0],c); In previous cl
r2 <= 'CLK r2 >> 1; we will use a
@(posedge sysclk) 'ENS; easier to unde
rl <= 'CLK {sum(rlC0],r2E0],c),rl[3:1]};
c <= CLK car(rl[O],r2[0],c);
r2 <= 'CLK r2 >> 1;

462 Verilog Digital Computer Design: Algorithms into Hardware



A synthesis tool can produce a more efficient netlist from the above than from the
f implicit style earlier example in section 11.5.1 because the same computations, sum (rl [01,
synthesis (and, r2 [0], c) and car(rl [0], r2 [0], c), occurin each state. Resource sharing
s are restricted can now occur at no added cost. Also, in the above code there is no need to use a four-
)rs need # time bit wire for c since a single-bit c can be reused in each state. A single-bit c variable
blocks. There- suffices here because we are going to discard the carries in the end, anyway.
that all of the With this shift register approach, r2 starts out with the value of y. During 

control each 
needed clock

cycle, r2 is shifted over one position to the right. Therefore, during the first 
boundary clock

out- cycle, r2 [0] is y[0]. During the second clock cycle, r2 [0] is y[1]. 
r two During 

forms of the
third clock cycle, r2 [0] is y [2], etc. In other words, the least significant bit is pro-

ocking assign- cessed first, and greater significant bits are processed later. This order is essential to 
simulate the

prop- bit serial technique.
-sized properly

The role of rl is somewhat more complicated: rl starts out with the value of x, but
ri is reused not just for holding the original bits of x but also for holding bits of the
result. As a low-order bit of x shifts out of r2, the high-order bit of r2 is scheduled to
become the corresponding sum (rl [0] , r2 [0] , c) bit. Although in the beginning,

)mputations on such bits are to the left of where they need to be, by the completion of the process, the
e the hardware result bits will have been shifted over to the proper position.
es to allow re-
void this prob-

11.5.4 Using a loop
There is still room to improve the code given in section 11.5.3 because it takes many
states (and therefore many flip flops in a one hot controller) to produce the answer.
Although the bit serial approach necessarily takes a number of clock cycles proportion-
ate to the number of bits in the word, the size of the controller should not also have to
be proportional to the word size.

Here is where the flexibility of the implicit style is useful. With the implicit style, the
designer can roll up the related computations that occur in separate states into one state
inside a while loop. (Rolling up identical computations into a loop is the opposite of
the loop unrolling explained in section 10.9.9.4 used by some optimizing compilers for
RISC machines.) Although rolling all of these states into a single-loop state does not
increase the speed of the machine, it usually will reduce the number of gates required
to implement the machine. There is however, an added complication. There needs to be
a loop counter that determines how many times the machine should repeat the loop
state.

In previous chapters, it would have been natural to use a binary counter. Instead, here
we will use a shift register (r3) to count in a unary code because with this it will be
easier to understand the resulting logic equations after synthesis:

Synthesis 463



l: always
2: begin module v

3: ready <= CLK 1; input

4: @(posedge sysclk) 'ENS; //ff_4 output

5: r2 <= 'CLK y; wire r(

6: r3 <= 'CL 1; wire [:

7: c <= 'CLK 0;
8: if (pb) endmodulE

9: begin
10: ready <= @(posedge sysclk) 0; Prior to synt
11: @(posedge sysclk)'ENS; //ff 11
12: test, we 

rl <= use t
'CLK x;

13: while (r3[3J) the module ti
14: begin tion 11.4.1, tl
15: @(posedge sysclk) 'ENS; //ff-15 adapt to the 
16: rl <= 'CLK{sum(rl[0],r2[0],c),rl[3:1};

nodule tor
17: c <= 'CLK car(rl[O],r2[0],c);

reg [3:0]
18: r2 <= CLK r2 >> 1;

wire reac
19: r3 <= 'CLK r3 << 1; integer r
20: end

cl #5200C
21: end

vsyaddl s
22: end

initial

When the most significant bit of r3 becomes one, the loop stops. In other begin
words, r3

contains the unary values 0001, 0010, 0100 numerr
and 1000 in successive clock cycles. The

effect is similar to #30 
what res

would happen by counting 0, 1, 2 and 3. Since the computation #210; @
only depends on the number of times the loop repeats, and not on the value of r3, the for (x=
above unary code is just as reasonable as a binary code. A binary code might produce a for (y
somewhat smaller synthesized netlist, but the unary code will produce a synthesized begin
circuit that typically runs faster and is easier to understand. @(po

The above Verilog includes the friendly user interface described @ 
in (po

sections 2.2.1 and
7.4.2. The signal ready is asserted @ (pa

when the machine is able to accept inputs. The
user @ (p0

pulses pb for exactly one clock cycle to cause the machine to compute the sum, if(
which will be available in rl when the machine exits from the while loop. $di

else

11.5.5 Test code beg

The implicit style block of section 11.5.4 together with the function definitions from x
section 11.4.2 can be placed inside the module to be synthesized: end

end
$di spla
$finish

end

464 Verilog Digital Computer Design: Algorithms into Hardware



module vsyaddl(pb,ready,x,y,rl,r2,reset,sysclk);
input [3:0] x,y; input pb,reset,sysclk;
output ready; output [3:0] rl,r2;
wire reset,sysclk,pb; reg ready,c;
wire [3:0] x,y; reg [3:0] rl,r2,r3;

endmodule

Prior to synthesis, it is prudent to test whether the algorithm is correct. To do such a
test, we use the following test code in a different file. The test code has an instance of
the module to be synthesized. Unlike the test code for the combinational logic of sec-
tion 11.4.1, there needs to be a wai t statement (section 3.7.3) so that the test code can
adapt to the speed of the bit serial addition.

nodule top;
reg [3:0] x,y; wire [3:0] sum,r2;
wire ready,sysclk; reg reset,pb;
integer numerr; time tl,t2;
cl #52000 clock(sysclk);
vsyaddl slow add machine(pb,ready,

xy,sum,r2,reset,sysclk);
initial

-r words, r 3 ~~begin
nru mweorrrd s=,r 3  0; pb= 0; x = 0; y = 0; reset = 1;

cycles. The #30 reset = 0; #10 reset = 1;
computation #210; @(posedge sysclk);
iieofr3, the for (x=0; x<=7; x = x+l)

,ht produce a for (y=0; y<=7; y = y+l)
synthesized begin

@(poedge sysclk) pb = 1;
@(posedge sysclk) pb = 0; tl = $time;

)ns2.2.1 and @(posedge sysclk) wait(ready); t2 = $time;
t inputs. The @( posedge sysclk);
)ute the sum, if (x + y === sum)

o $display(ok %d",t2-tl);
else
begin
$display("error x=%d y=%d x+y=%d sum=%b",

initions from x,y,x+y,sum); numerr = numerr + 1;
end

end
$display("number of errors=",numerr);
$finish;

end

Synthesis 465



Continued If ft_999,
always (posedge PLSynthesiz

sysclk) #20
$display("%d rl=%d r2=%d the 

pb=%b conditior
ready=%b",

$time, sum,r2, pb, ready); a transition t
andmodule true. There;

machine is p
The active low reset signal is necessary for the VITO preprocessor described in false, or whe
chapter 7 and appendix F. The test code detects no errors, so it is reasonable to synthe- f f_15 or st,
size vsyaddl. significant bi

TransitioninE
loop for the f

11.5.6 Synthesizing remaining in
Since PLSynthesizer does not support the implicit style, the first step in synthesizing
vsyaddl is to use the VITO preprocessor.' 3 VITO passes through the module defini- In addition to
tions and functions unchanged, which allows use of these names in the code generated ture compose
by VITO. VITO generates a one hot controller using continuous assignment and one described in 5
bit regs according to the principles described in chapter 7. VITO uses the line number to r2:
in the names of the wires and regs generated. In this particular machine, the states
correspond to f f4, f _11 and f f_15. When the code generated by VITO is run
through PLSynthesizer, logic equations are formed that describe the inputs to these ass.
macrocell flip flops. PLSynthesizer and PLDesigner will eliminate most of the redun- alw.

dant wire names created by VITO. The following is the manual translation of the
.doc file into Verilog for the logic equations of the one hot controller:

always (posedge sysclk or negedge reset)
begin
if (-reset)
{ff_999,ff_4,ffll,ffl5y = 0;

else
begin
ff_999 <= #0 1; Figure 11-.
ff_4 <= #0(-ff_9991(-pb&fft4)

I(r3[31&ffl5)j(r3[3]&ffll));
ff_11 <= #0 (pb&ff_4); The above Ve
ff_15 <= #0((-r3[3]&ff_11)1(-r3[3]&ff-15)); register that is

end right (in state
end

given in the .
ing is the man

13 The preprocessor is not necessary with synthesis tools, such as Synopsys, that support the implicit style.

466 Verilog Digital Computer Design: Algorithms into Hardware



If f f_999, f f-4, f f_11 and f f_15 are not listed in the portlist of VITO's output,
PLSynthesizer will choose cryptic names for them. The above logic equations describe
the conditions under which state transitions occur to the particular states. For example,
a transition to state f f_ 1 1 only occurs when the machine is in state f f ..4 and pb is
true. There are several ways in which a transition to state f f_4 occurs: when the
machine is powered up, when the machine loops back to state f f_4 because pb is

;or described in false, or when the most significant bit of r3 is one and the machine is in either state
nable to synthe- f f_15 or state f f_11. The machine makes a transition to state f f_15 when the most

significant bit of r3 is zero and the machine is in either state f f_15 or state f f_11.
Transitioning to state f f_15 from state f f_11 corresponds to entering the while
loop for the first time. Transitioning to state f f_15 from state f f_15 corresponds to
remaining in the whi le loop for an additional cycle.

in synthesizing
- module In 

defini- addition to the one hot controller, the VITO preprocessor also generates an architec-
-code generated ture composed of combinational logic, muxes and simple D-type registers in the style

described in section 
gnment 7.2.2. 

and one 1. For example, here is what VITO generates corresponding
the line number to r2:

chine, the states
by VITO is run

assign newr2 = 
inputs s_5 

to ? 
these y : s18 ? r2>>l : r2;

always (posedge sysclk) r2 = newr2;
ost of the redun-
ranslation of the
Ir:

Figure 11-5. Block diagramforr 2 portion of architecture.

The above Verilog is equivalent to figure 11-5, which is a kind of specialized shift
register that is loadable (in state f f_4 which includes statement s5) and only shifts
right (in state f f_15 which includes statement s1 8). Again, logic equations are
given in the . doc file that describe the inputs to each macrocell flip flop. The follow-
ing is the manually translated Verilog for the logic equations that correspond to r2:

ort the implicit style.

!ware Synthesis 467



always t(posedge syscik)
begin cII
r2[0] <= #0 ((r2[0]&-ff_15&-ff_4) _

,

j(y[0]&ff_4)j(r2[1]&ff 15&-ff 4))
r2[1] <= #0 ((r2[1]&-ff15&-ff 4)
j(y[1]&ff_4)j(r2[2]&ff 15&-ff 4))

r2[2] <= #0 ((r2[2]&-ff15&-ff_4)
(y[2]&ff_4)j(r2[3]&ff 15&-ff 4))

r2[3] <= #0 ((r2[3]&-ff_15&-ff_4)| (y[3]&ff_4));
end

Although it might have appeared from figure 11-5 that there would be two macrocells
of delay (for each mux), the synthesis tool merged the logic equations of the two muxes
together into a single macrocell per bit slice. Except for r2 [ 3 ] , each bit slice is similar
to the others. For example, there are three cases to consider for r2 [ 0 ] . First, when
ff_4 is active, two terms of the logic equation, r2 [0] &-ff_15&-ff_4 and
r2 [1] &ff_15&-ff_4, are guaranteed to be zero. This leaves only y[O] &ff_4,
which passes through the proper bit of y into the input of the r2 [0  ] flip flop. Second,
when f f_15 is active, we know (because of the nature of one hot controllers) that
f f_4 could not be active, but the synthesis tool did not know this. Therefore, the tool
generates r2 [ 1 ] &f f_15&-ff_4. The - ff_4 is not necessary considering the total
one hot system but is necessary to achieve the mux behavior shown in figure 11-5.
Because the other two terms of the logic equation, r2 [0] &-ff_15&-ff_4 and
y [0] &ff_4, are guaranteed to be zero in this case (ff_15 active and ff_4 inac-
tive), the remaining term, r2 [1] &ff_15&-ff_4, passes through the right-shifted
bit (r2 [ 1] ) into the input of the r2 [0 1 flip flop. Third, the last possibility is that
neither ff_4 nor ff_15 is active. In this case, r2 [0] &-ff_ 15&-ff_4 holds the
former value of the r2 [ 0 ] flip flop. Figure 11-i

Of course, as mentioned earlier, it is tedious to have to manually translate the non-
standard . doc file back into Verilog. The designer would probably prefer to use the
structural Verilog automatically generated by PLDesigner. The instance and wire names 11.6 Sw
shown in figure 11-6 and in the following may vary slightly, depending on tool- spe- To have a usei
cific details: from a person
mbuf B5(tmp85,pin_13);and A17(tmp90,tmp91,tmp92,pin_12); is to use mech
and A16(tmp87,ff-15,tmp88,pin-46);not I19(tmp88,ff_4); existence of 
not I20(tmp91,ff_15);and A18(tmp93,ff_4,pin_25); push button w
not I21(tmp92,ff_4);or 05(tmp86,tmp87,tmp9O,tmp93); problem is tha
dffarap DFF5(pin_12,tmp85,tmp86,GND,GND); chronous nor i
mbuf B6(tmp94,pin_13);and A20(tmp98,tmp99,tmplOO,pin_46); of times per se
and A19(tmp96,ff-15,tmp97,pin_44);not I22(tmp97,ff_4); erty, known as
not I24(tmplOO,ff_4);and A21(tmplOl,ff_4,pin_23);
not I23(tmp99,ff_15);or 06(tmp95,tmp96,tmp98,tmplOi);
dffarap DFF6(pin 46,tmp94,tmp95,GND,GND);

468 Verilog Digital Computer Design: Algorithms into Hardware



wo macrocells
the two muxes
slice is similar
]. First, when
&-- _f4f _4 and
Y [ O] &ff4 ,
flop. Second,
ntrollers) that

*efore, the tool
lering the total
n figure 11-5.
i&-ff_4 and
id f f_4 inac-
e right-shifted
sibility is that
f_4 holds the

Figure 11-6. Macrocells implementing low-order bit slices of r2.

islate the non-
e)rflesr  to use ththae
dwire names 11.6 Switch debouncing and single pulsing
3, on tool- spe- To have a useful machine, it is often necessary for the machine to receive information
.nfrere-5 from a person. In many situations, the most economical way to design such a machine

is to use mechanical switches and buttons. In previous chapters, we have assumed the
existence of ideal switches and buttons. For example, in section 2.2.1, we assumed a
push button would assert its output for exactly one clock cycle when it is pushed. The
problem is that mechanical switches and buttons are not perfect. They are neither syn-
chronous nor is their output reasonable for use with a machine being clocked millions
of times per second. This is because mechanical switches exhibit an undesirable prop-
erty, known as bounce.

reSytei46 Synthesis 469

A



Ideally, when a person flips a switch on, we would hope that the output of the switch In addition t,
would become and remain one until the person flips the switch off. Unfortunately, real debounce m;
switches do not behave this way, as is illustrated by the following timing diagram: the user is mE

just one requ
i'ln.zl Iwtc I single pulsin

module d(

actual switch input
output

irst tbounc s c n tb 
firsbtou nce output

second bounce
wire s,

Figure 11-7. Ideal versus actual switch behavior shows needfor debouncing. reg pb;
reg [1S

Happily, real switches bounce for less than a constant time t seconds. For example, always

even the very awkward DIP switches'4 soldered onto the M4-128/64 demoboard bounce begin

for less than a quarter @ 
of a second. (poE

pb <=
One solution to the bounce problem is to design a debounce machine' whose input is if (S
the actual switch, and whose output is the idealized pb signal needed by many of the cnt

designs in this book. Most of the time, the actual switch is quiet; thus the debounce else

machine whi1
continually reassigns 0 to pb. The debounce machine does something differ- beg

ent when the actual switch makes its first transition to a one. During this first t second
period when bounce occurs, we assume that the output of the actual switch will eventu- i
ally stabilize to 1. Therefore, the number of clock cycles when the actual switch could
be zero during this first bounce period is less than t times the clock frequency. After i
the first bounce period but before the second bounce period, the actual switch continu-
ally reads as a one. A second bounce period occurs when the switch is released. end

end
The total number of clock cycles during which the actual switch reads as a zero from endmodule
the time of the first transition to one until the final transition to zero is less than twice t
times the clock frequency. The designer precomputes this constant, which will be loaded Assuming cr
into a counter when the machine first detects that the actual switch has become a one. alone and the:
For example, with the M4-128/64, two times 0.25 seconds times 1.8432 MHz is ap- that sw3 is o
proximately one million. Since 0.25 is an overestimation of t, the exact number of zero again du
clock cycles is not too important, as long it is near one million. A convenient number machine ente
around this size is 22- 1. when sw3 is

significant ar
cnt might oi

14 People often use pencils to move these tiny switches, which aggravates the bounce problem. The constant the least signi
t tends to be smaller for switches that are easier for people to manipulate, but the underlying cause of bounce single cycle. 
is always electrical.

machine retur
15 The design here assumes that a single-pole single-throw switch is used and that the debounce machine
must be completely digital. Much more economical solutions are possible that either use a few analog primitive DIP
components, such as a capacitor and a resistor, or that use a single-pole double-throw switch. In the case of
the M4-128/64 demoboard, neither alternative is possible without external components.

470 Verilog Digital Computer Design: Algorithms into Hardware



Fr

put of the switch In addition to debouncing the switch, we need to make 
nfortunately, sure that the 

real pb output of the
debounce machine lasts for exactly one clock cycle. Otherwise, it would 

ing diagram: be as though
the user is making millions of requests for computation, when in fact the user makes
just one request. The following implicit style module solves both the debouncing and
single pulsing aspects of this problem:
module debounce(sw3,pb,cnt,sysclk,reset);

-L1 input sw3,sysclk,reset;
output pb;

ice output [19:0] cnt;
wire sw3,sysclk,reset;

bouncing. reg pb;
reg [19:0] cnt;

Is. For example, always

moboard bounce begin
@(posedge sysclk) 'ENS;
pb <= 'CLK 0;

15 whose input is if (sw3 == 1)

I by many of the cnt <= 'CLK 20'hfffff;

us the debounce else
while 

omething (cnt[19:1] 
differ- != 0)

begin
lis first t second @(posedge sysclk) 'ENS;
Fitch will eventu- if (sw3 == 0)
ual switch could cnt <= 'CLK nt - 1;
frequency. After if (cnt[19:1] == 0)
I switch continu- pb <= 'CLK 1;

released. end
end

Isa s a zero from endmodule
less than twice t
ch will be loaded Assuming cnt is zero and the actual switch, sw3, is zero, the machine leaves cnt
s become a one. alone and therefore does not enter the while loop. The first time the machine detects
432 MHz is ap- that sw3 is one, the machine assigns the constant to cnt. Eventually, sw3 becomes
,xact number of zero again during the first bounce period. Since cnt now contains the constant, the
ivenient number machine enters the while loop. Inside the while loop, cnt is decremented only

when sw3 is zero. The while loop exits when all bits of cnt other than the least
significant are zero (i.e., cnt is 1). During this last clock cycle in the while loop,
cnt might or might not be decremented one last time (hence the reason for ignoring

blem. The constant the least signifcant bit). In that same clock cycle, pb is scheduled to become one 
fing for 

cause a
of bounce single cycle. (pb will be scheduled to return to zero in the next clock cycle when the

machine returns to the top state.) Therefore, the 
debounce above 

machine code allows us to use the rather
,r use a few analog primitive DIP switch, sw3, as an ideal push button, pb.
witch. In the case of

Pare Synthesis 471



-7 -

11.7 Explicit style switch debouncer Continued
As explained in chapter 4, a pure behavioral design can be broken down manually into
an architecture and a controller. For example, the controller can be written in the ex-
plicit style, where each state transition must be given explictly, using a case state-
ment:

endc
'define TOP 0 end
'define BOT 1 endmodul
module deboun control(sw3,cnteqO-1,clrpb,

ldpb,ldcnt,deccnt,sysclk,reset); The above c
input sw3,cnteqO_l,sysclk,reset; but for brev
output clrpb,ldpb,ldcnt,deccnt; and next sta
wire sw3,cnteqO-l,sysclk,reset; though simi]
reg clrpb,ldpb,ldcnt,deccnt,ps,ns; plicit style d
always @(posedge sysclk or negedge reset) Verilog arch
begin

if (-reset) deccnt) ar
Ps = 0; signer must i

else cal to sectior
ps = ns;

end module 
always @(ps or sw3 or cnteqO_l) input
begin output

clrpb = ;ldcnt = ;deccnt = O;ldpb = 0; output
case (ps) wire E
'TOP: begin wire [

clrpb = 1; wire E
if (sw3 == 1) debour
begin c lr

ldcnt = 1; deboun
ns = 'TOP; clr;

end endmodul
else

if (cnteqO_l)
In this case, t

ns = 'TOP;
else pared to the o
ns = 'BOT; the macrocell

end gardless of w
'BOT: begin manual codin

if (sw3 == 0)
deccnt = 1;

if (cnteqO_l)
begin

ldpb = 1;
ns = 'TOP;

472 Verilog Digital Computer Design: Algorithms into Hardware



Continued
n manually into end
ritten in the ex- else

a case state- ns = 'BOT;
end

endcase
end

endmodule

The above code corresponds to what was called the pure structural stage in chapter 4,
but for brevity, the above uses only behavioral statements. (The present state register
and next state logic are not given in separate modules as was done in chapter 4.) Al-
though similar in operation to the implicit style design given in section 11.6, the ex-
plicit style design is much more tedious to understand. Also, the designer must give a
Verilog architecture (not shown) consisting of a counter (controlled by ldcnt and
deccnt) and an enabled register (controlled by ldpb and clrpb). Finally, the de-
signer must instantiate the controller and architecture to make a module that is identi-
cal to section 11.6:

module debounce(sw3,pb,cnt,sysclk,reset);
input sw3,sysclk,reset;
output pb;
output [19:0] cnt;
wire sw3,sysclk,reset;
wire [19:0] nt;
wire pb,cnteqO_l,clrpb,ldpb,ldcnt,deccnt;
deboun arch architec(pb,cnteqO_1,cnt,

clrpb,ldpb,ldcnt,deccnt,sysclk);
debouncontrol controller(sw3,cnteq0_1,

clrpb,ldpb,ldcnt,deccnt,sysclk,reset);
endmodule

In this case, the binary encoding makes only a slight savings in macrocells (3%) com-
pared to the one hot encoding used by VITO. As in many other designs, the majority of
the macrocells are devoted to the architecture. Those macrocells must be present, re-
gardless of whether the original Verilog was implicit or explicit style. All of the extra
manual coding required for the explicit style was not worth the effort.

vare Synthesis 473

S y t e i

vir  



11.8 Putting it all together: structural synthesis 11.9 A 
A typical b

design often uses a combination of the above techniques. For example, con-
sider a machine activated All the design

by the debounced sw3 DIP switch that takes a three bit
binary number from the other about general-

DIP switches (sw2, swi, swO }) and does bit serial
addition of this to a four-bit including the

accumulator, rl, whose output is displayed in hexadeci-
mal on the LEDs al .. gl. In order to reuse hardware. 

the code given Mos
above, the designer needs

structural metic 
instances because

of vsyaddl and debounce:
us build a bit s(

module mach445(sw3,sw2,swl,swO,sysclk,reset, it simplifies thi
al,bl,cl,dl,el,fl,gl); ally to the dem

input sw3,sw2,swl,swO,sysclk,reset;
output The PDP-8 

al,bl,cl,dl,el,fl,gl; sul
wire sw3,sw2,swl,swO,sysclk,reset; DCA, HLT, JM
reg a,bl,cl,dl,el,fi,gl; IAC instructior
function [7:0] sevenseg; are not implem

input [3:0] i; program given i
and so the mult

endfunction design, but then
wire pb,ready; M4-128/64.
wire [3:0] rl,r2;
reg [3:0] y; First, bit serial
wire [19:0] cnt; states F3A and
vsyaddl vl(pb,ready,rl,y,rl,r2,reset,sysclk); EOTAD). Secon
debounce debl(sw3,pb,cnt,sysclk,reset); to be replaced is
always (sw2 or swl or swO) & ir[8]==

y = {sw2,swl,swO};
(but unlike chap

always @(rl)
{al,bl,cl,dl,el,fl,gl} = sevenseg(rl); are allowed at nm

endmodule vidually. Fourth,
ister wired to the

The vsyaddl and debounce module definitions are given in the same file as the the data out pin o
above module. In the above, y is simply another name for { sw2, swl, swO }. Note must be a separai
that rI connects both to the vI. rl output as well as the v . x input for the instance write signal is
of vsyaddl. In other words, rl plus y will eventually replace the old value of rl. figure 8-11. Seve

the number of bi
The function sevenseg (whose case statement definition is not shown) takes a proach is 
four-bit to disn

binary input, i, and outputs the seven bits required to drive one LED digit in chip. In other woi
hexadecimal. This combinational logic output is complemented to accommodate the andbitmem[16
active low requirements of the LEDs. address register,
The pi file must be defined using the pin numbers given in section 11.3.6. When provides the low-
synthesized and downloaded to the M4- 128/64 demoboard, the above design will oper- the bit from th
ate properly. bitmem[ {ma,1

metic loops, rathc
cause this subset,

474 Verilog Digital Computer Design: Algorithms into Hardware

I



esis 11.9 A bit serial PDP-8
or example, con- All the designs in chapters 8 through 10 use bit parallel arithmetic 
takes to 

a three illustrate 
bit concepts

about general-purpose computers. In contrast, many early general-purpose 
id does bit computers,

serial including the Manchester Mark I, used bit serial arithmetic because 
yed in hexadeci- it required less

hardware. Most modem general-purpose computers are designed 
.e designer with bit 

needs parallel arith-
metic because it is faster and easier. As a concluding synthesis example, however, let
us build a bit serial PDP-8. This allows the CPU to fit within one M4-128/64 chip, and
it simplifies the connections to an external memory chip, which must be wired manu-
ally to the demoboard.

The PDP-8 subset chosen for this example is the same as section 9.6 (CLA, TAD,
DCA, HLT, MP, SPA, SMA and CIA), with the addition of the SNA, SZA, CMA and
JAC instructions described in appendix B. The link as well as additional instructions
are not implemented in this example. This subset is sufficient for the childish division
program given in section 9.7. Bit serial arithmetic is necessarily a multi-cycle approach,
and so the multi-cycle PDP-8 ASM of section 8.3.1.3 is a good starting point for the
design, but there are several algorithmic variations required for the CPU to fit into the
M4- 128/64.

First, bit serial addition loops are used for incrementing pc (the user interface and
states F3A and EIASKIP), incrementing ac (state EOIAC) and adding to ac (state
EOTAD). Second, bit parallel comparisons, such as ir==12 o7200 for CLA, need
to be replaced with comparisons of only the appropriate bits, such as ir [1 9]== 7
& ir 8] ==0 & ir [7] ==1 for CLA. Third, like the original PDP-8
(but unlike chapters 8 and 9), combined instructions (e.g., CMA and IAC to form CIA)
are allowed at no extra cost because the bits of the instruction register are tested indi-
vidually. Fourth, memory accesses occur one bit at a time with a one-bit-wide mb reg-
ister wired to the data in pin of the memory chip and a one-bit-wide membus wired to

same file as the the data out pin of the memory chip. Fifth, like section 8.3.2.4 and figure 8-11, memory
:wl, swO }. Note must be a separate actor so that it can be physically wired to the M4-128/64. Sixth, the
it for the instance write signal is active low for the memory chip used here, which is the opposite of
)Id value of r 1. figure 8-11. Seventh, since the number of bits in a memory chip is a power of two but

the number of bits in the PDP-8's memory is a multiple of twelve, the simplest ap-
t shown) takes a proach is to disregard four out of every sixteen bits from the one-bit-wide memory
one LED digit in chip. In other words, bitmem [0] through bitmem [11] form the twelve- bit m [0],
accommodate the and bitmem[16] through bitmem[27] form m[1]. Eighth, in addition to the memory

address register, ma, the bit serial approach needs a bit address register, a, which
ion 11.3.6. When provides the low-order four bits of the address going to the memory chip. At any time,
design will oper- the bit from the memory chip currently being processed by the CPU is

bi tmem [ {m a, ha]I. Ninth, ha also serves as a binary counter for bit serial arith-
metic loops, rather than the unary r3 counter described in section 11.5.4. Tenth, be-
cause this subset only implements the direct page zero addressing mode (and not the

Synthesis 475



r

full set of addressing modes described in appendix B), the memory address register Continued
only needs to be seven bits wide (a reduction which saves several macrocells). Elev-
enth, the user interface of chapter 8 (but_DEP, but_PC, but MA, cont and the
twelve-bit switch register) has been replaced with a simpler but workable scheme us-
ing four undebounced switches and a push button, cont, that must be externally
debounced. Twelfth, swin, which is the concatenation of the four switches, deter-
mines the user interface action taken when cant is pressed:

swin action
0000 ba - 0
001- ba - 0; pc <- {swin[0],pc[ll:ll}
010- bitmem[{pc,ba}] -- swin[O]; Advance {pc,ba}
011- Advance {pc,ba}
1000 Execute

where advancing {pc, ba} means incrementing just ba, except in the case when
ba==4'blOll. In that special case, pc is incremented and ba becomes zero.

11.9.1 Verilog for the bit serial CPU
In the following implicit style Verilog, the comments indicate names of states similar
(but not identical) to those of figure 8-11. Many of the states, especially those for the
user interface, have no direct correspondence to figure 8-11 :

always
begin
@(posedge sysclk) 'ENS; //INIT
halt <= 'CLK 1; write <= 'CLK 1;
forever
begin
@(posedge sysclk) 'ENS; /Fl en(
ma <= CLK pc; ba <= 'CLK 0; end
c <= 'CLK 1; else
if (halt) begii
begin @ (p(
while ((cont&swin[3]))

wh:
begin be
@(posedge sysclk) 'ENS; //IDLE
halt <= 'CLK 0; ma <= 'CLK c;
mb <= 'CLK swin[0]; c <= 'CLK 1;
if (cont&(swin[3:2] == 2'bOO))
begin
@(posedge sysclk) 'ENS; er

476 Verilog Digital Computer Design: Algorithms into Hardware



p-

ddress register Continued
zrocells). Elev-
cont and the ba <= 'CLK 0;
ble scheme us- if (swin[l])

t be externally begin

witches, deter- @(posedge sysclk) 'ENS;
pc <= 'CLK {swin[O],pc[ll:l]};

end
end
else if (cont&(swin[3:2] == 2'bOl))
begin
@(posedge sysclk) 'ENS;
write <= 'CLK swin[l];
@(posedge sysclk) 'ENS;
write <= 'CLK 1;
@(posedge sysclk) 'ENS;
ba <= 'CLK ba + 1;
if (ba == 11)

the case  when begin
nes zero. @(posedge sysclk) 'ENS;

ba <= 'CLK 0;
while (ba 11)
begin

Af  states similar @(posedge sysclk) 'ENS;
l[ly those for the pc <= 'CLK

{sum(pc[O],0,c),pc[ll:l]};
c <= 'CLK car(pc[O],O,c);

-- 7 ba <= 'CLK ba + 1;
end

@(posedge sysclk) 'ENS;
ba <= 'CLK 0;

end
end

end
end

else
begin
@(posedge sysclk) 'ENS; //F2
while (ba != 11)
begin
@(posedge sysclk) 'ENS; //F3A
ir <= 'CLK {membus,ir[ll:l]};
pc <= 'CLK {sum(pc[O],O,c),pc[ll:l]};
c <= 'CLK car(pc[O],O,c);
ba <= 'CLK ba + 1;

end

vare Synthesis 477



Continued Continued

@(posedge sysclk) 'ENS; //F3B
ma <= 'CLK ea(ir); ba <= 'CLK 0;
mb <= 'CLK ac[O]; c <= 'CLK ir[11];
if (ir[11:9] == 1)
begin
while (ba != 11)
begin
@(posedge sysclk) 'ENS; //EOTAD
ac <= 'CLK {sum(ac[O],membus,c),ac[ll:1]};
c <= 'CLK car(ac[O],membus,c);
ba <= 'CLK ba + 1;

end
end

else if (ir[11:9] == 3)
begin
while (ba = 11)
begin
@(posedge sysclk) 'ENS;//EODCA
ac <= 'CLK {l'bO,ac[ll:l]};
write <= 'CLK 0;
@(posedge sysclk) 'ENS;//ElADCA
write <= 'CLK 1;
@(posedge sysclk) 'ENS;//ElBDCA
ba <= 'CLK ba + 1; mb <='CLK ac[O];

end
end
else if (ir[11:9] == 5)
begin
@(posedge sysclk) 'ENS; //EOJMP
pc <= 'CLK ma;

end
else if (ir[11:9] == 7) end

begin end

if (ir[8]) end

begin
if (ir[1])
begin
@(posedge sysclk) 'ENS; //EOHLT 11.9.2 Tes
halt <= 'CLK 1; For a design a,

end tiny bug could
if (ir[3]^(ir[6]&ac[ll]ir[5]&(ac==O))) as to the cause
begin //SPA,SZA,SMA,SNA the memory cl
while (ba != 11)
begin

478 Verilog Digital Computer Design: Algorithms into Hardware



Continued

@(posedge sysclk) 'ENS; //EOASKIP
PC <= 'CLK {sum(pc[O],O,c),pc[ll:l]1;
c <= 'CLK car(pc[O],O,c);
ba <= 'CLK ba + 1;

end
end

end
else

:1]); begin
if (ir[7])
begin
@(posedge sysclk) 'ENS; //EOCLA
ac <= CLK 0;

end
if (ir[5])
begin
@(posedge sysclk) 'ENS; //EOCMA
ac <= 'CLK -ac;

end
if (ir[O])
begin
while (ba != 11)
begin
@(posedge sysclk) 'ENS; //EOIAC
ac <= 'CLK {sum(ac[O],O,c),ac[ll:1]y;
c <= 'CLK car(ac[O],O,c);
ba <= 'CLK ba + 1;

end
end

end
end

end
end

end

11.9.2 Test code
For a design as complicated as this, it is important to simulate before synthesis. Even a
tiny bug could prevent the fabricated hardware from operating at all and give no trace
as to the cause. In order to simulate the above, we need a non-synthesizable model of
the memory chip that will be connected to the fabricated CPU:

Ire Synthesis 479



P..

module mem(mabus,babus,mbbus,membus,write);
7taskps

input mabus,babusmbbus,write; input I
output membus;

begin
wire [11:0] mabus;

swin
wire [3:0] babus;

#100
wire mbbus, write;

case
reg membus;

0:
reg [11:0] m[0:127];

1:
reg [11:0] temp;

2, -
always @(mabus or babus)

endcE
begin

#300;
temp = m[mabus]; membus = temp[babus];

end
end

endtask
always @(negedge write)
begin
#50 membus = mbbus; temp = m[mabus]; The time cont
temp[babus] = membus; m[mabus] = temp; example, for t]

end program, the t,
endmodule and then waits

The above models memory as twelve-bit words but interfaces to the CPU one bit at a push
time. An attempt to access one of the four unused bits will result in 1 'bx because of push
the way Verilog treats bit selects that are out of bounds. The above must be instantiated push
together with the CPU: push

push

module pdp8-system(swin,cont,halt,sysclk,reset);
input swin,cont,sysclk,reset; 11.9.3 Ou
output halt;
wire cont,sysclk,reset,halt,mb, membus, write; In running thi
wire [3:0] swin,ba; serve that this
wire [11:0] ma; cycles when 2
pdp8_cpu cpu(swin,write,membus,cont, perspective wi

ba,ma,mb,halt,reset,sysclk); tations discuss
mem memory(ma,ba,mb,membus,write);
endmodule

sect
11.9

Assuming pdp8_system is instantiated as pdp8_machine, the test code can ini- 8.3.
tialize a memory location using a twelve-bit word refered to with hierarchical refer- 9.6
ence to the array pdp8_ machine.memory.m[ ... ].I n order to simulate the
pushing of cont, a task is helpful:

480 Verilog Digital Computer Design: Algorithms into Hardware



task push;
input [3:0] sw;
begin

swin = sw; #200 cont = 1;
#100 cont = 0; #300;
case (swin[3:2])

0: #200;
1: #2000;
2,3: #100 wait(halt);

endcase
#300;

end
endtask

The time control in the task depends upon what swin selection was requested. For
example, for the test code to set the program counter to 12 ' o 010 0 and then execute a
program, the task waits 200 units of $ time for each bit shifted into the program counter
and then waits until the CPU halts:

PU one bit at a push(4'bOOlO);push(4'bOOlO);push(4'bOO10);//O
bx because ofl push(4'bOOlO);push(4'bOOlO);push(4'bOO10);//O
be instantiated push(4'bOOll);push(4'bOOlO);push(4'bOO10);//l

push(4'bOOlO);push(4'bOOlO);push(4'bOOlO);//0
push(4'blOOO);//Execute until HLT

11.9.3 Our old friend: division
In running this simulation with the childish division program of section 9.7, we ob-
serve that this bit serial implementation takes 558 cycles when 1 is the quotient, 827
cycles when 2 is the quotient and 1096 cycles when 3 is the quotient. Let us put this in
perspective with running the childish division software on the other PDP-8 implemen-
tations discussed earlier:

section kind arithmetic clock cycles
11.9.1 multi serial 2 8 9+269*quotient

it code can ini- 8.3.2.1 multi parallel 5 5+55*quotient
rarchical refer- 9.6 pipe parallel 12+10*quotient
to simulate the

I I

Synthesis 481



7

Assuming the same clock period, the bit serial approach is about five times slower than PDE
the multi-cycle bit parallel approach of chapter 8, which in turn is about five times sic

slower than the pipelined bit parallel approach of chapter 9. To execute one instruction, ba[

it takes on average about one cycle for the pipelined bit parallel machine of section 9.6, ba[

five cycles for the multi-cycle bit parallel machine of section 8.3.2.1 and twenty-seven wri

cycles for the multi-cycle bit serial machine of section ba[
11.9.1. In the latter case, it takes

ba[
twelve cycles to fetch the instruction, twelve cycles to fetch the data and three cycles ma 
for the other typical states (i.e., Fl, F2 and F3B). ma 

ma 

11.9.4 Synthesizing and fabricating the PDP-8
This design will occupy the majority of the macrocells in the M4-128/64. After synthe- It is desirable
sis with VITO and PLSynthesizer, it is necessary to let PLDesigner choose the pins feedback to 
where the signals are routed. If the designer provides complete . pi information at limitations of
first, it is likely that PLDesigner would be unable to fit this design into a single M4- must be solde
128/64. Instead, the designer should only constrain critical pins. This design does not nal switches n
make use of any of the hardware on the demoboard, other than sysclk and reset. to JP4-6, s1
The only other critical pins are 18, 54, 63 and 68, which should not be used since these
are tied to the DIP switches. Instead, swin will come from external switches. Once the
design does get placed in a single chip, the pins selected by PLDesigner should be put
in a . pi file so that future minor modifications of the design will not require physical 11.10 C
rewiring of the memory chip to the demoboard: Five kinds of

ters, behavior
ioral explicit

membus:10 sysclk:13 contin:19 ma[5]:22 style is the bes
ma[4]:23 ma[6]:24 swin[l]:37 swin[3]:38 discussed in e
mb:43 reset:4 ba[3]:56 ba[2]:58 Verilog, such
ba[1]:59 ba[0]:60 ma[O]:62 swin[0]:70 should be the:
swin[2]:73 halt:74 write:84 ma[3]:93
ma[1]:96 ma[2]:98 This chapter i

Although the 
vendors may 

Each 1/0 pin of the M4-128/64 is attached to a pin on one of two headers (JP4 or JP5) synthesis is sir
soldered to the demoboard. A small, low-cost static memory chip that can be used is the lation takes so:
2102, which is arranged as 1 x 1024 bits. Using wirewrap wire and a sixteen-pin dual lation will be 
in-line wirewrap socket, the memory can be attached to the demoboard as follows: ware is fabrica

netlists, which
design.

482 Verilog Digital Computer Design: Algorithms into Hardware

J

I



mes slower than PDP-8 M4 2102 PDP-8 M4 2102

about five times signal header pin signal header pin

one instruction, ba[0] JP5-27 1 GND JP4-2 9
ba[l] 

ie JP5-25 
of section 2 

9.6, Vcc solder 10
write JP5-12 3 mb JP5-1 

nd 11
twenty-seven ba[2] JP5-23 4 membus JP4-27 12

tter case, it takes ba[3] JP5-19 5 GND JP4-2 13
and three cycles ma[0] JP5-31 6 ma[3] JP4-1 14

ma[l] JP4-7 7 ma[41 JP4-26 15
ma[2] JP4-11 8 ma[5] JP4-28 16

64. After synthe- It is desirable that the ma and ba signals also be attached to external LEDs to provide
choose the pins feedback to the user. (The onboard LEDs cannot be used because of the place and route

i information at limitations of the M4-128/64.) The five-volt power supply (Vcc) to the memory chip
nto a single M4- must be soldered on the demoboard power connection. In addition, the following exter-
;d esign does not nal switches mustbe connected: contin (externally debounced) toJP4-34, swin [1]
-lk and reset. toJP4-6,swin[3] toJP4-4,swin[0] toJP5-32andswin[2] toJP5-26.
used since these

pitches. Once the
ner should be put 11.10 Conclusions
require physical

Five kinds of synthesizable Verilog were considered in this chapter: behavioral regis-
ters, behavioral combinational logic, behavioral implicit style state machines, behav-
ioral explicit style state machines and structural instantiation. Of these, the implicit
style is the best choice because it has such a close relationship to the behavioral ASMs
discussed in earlier chapters. Often a designer must use some of the other kinds of
Verilog, such as combinational logic, to create a complete design, but implicit style
should be the first choice for synthesizing hardware.

This chapter has used the M4- 128/64 CPLD with VITO, PLSynthesizer and PLDesigner.
Although the details of performing synthesis using chips and software from different
vendors may vary somewhat from those described here, the design flow for Verilog

iders (JP4 or JP5) synthesis is similar. Simulation is a critical part of this design flow. Even though simu-
can be used is the lation takes some effort by the designer, in most cases, a bug discovered during simu-
a sixteen-pin dual lation will be much less expensive than one that remains hidden until after the hard-
ard as follows: ware is fabricated. Synthesis as well as place and route tools output structural Verilog

netlists, which can be used with test code to verify the operation of the synthesized
design.

aware Synthesis 483

M



r

11.11 Further reading
PALNITKAR, S., Verilog HDL: A Guide to Digital Design and Synthesis, Prentice Hall A.
PTR,Upper Saddle River, NJ, 1996. Chapter 14.

A
Most people

11.12 Exercises hardware-inc
11-1. Give the synthesizable sevenseg function used in section 11.8. independent

any general-p
11-2. Synthesize a 3-bit childish division machine based on the Verilog given in section and C.
7.4.2 that will work with the hardware resources of the M4-128/64 demoboard. The
code should be modified so that x is a register (rather than a bus) that is loaded with In contrast, s
y= (sw2, swi, swO } when the debounced sw3 generates the first pb pulse. The sec- ally operate.'
ond pb pulse starts the computation of x/y, which will be displayed in hexadecimal on are hardware
the seven-segment display. Use the debounce module of section 11.6 and a top-level pendent meai
module similar to section 11.8 with the function from problem 11-1. Use test code that ware. Each st;
verifies the design after each step in the design flow. that represei

programmer':
11-3. Synthesize a factorial machine based on problem 2-4 that will work with the operations in
hardware resources of the M4-128/64 demoboard. { sw2, swl, swO } is the 3-bit value
of n which is used when the debounced sw3 generates the pb pulse. The 13-bit facto- Low level an
rial of n will be displayed in hexadecimal on the LEDs. Use the debounce module of guage is mad
section 11.6 and a top-level module similar to section 11.8 with the function from sists of the im
problem 11-1. Use test code that verifies the design after each step in the design flow. 1. labels
11-4. Modify the design of section 11.9 to include the link and the CLL, CML, RAR 2. mnerr
and RAL instructions (appendix B) in a way that allows the design to fit in the M4- 128/ 3. opera
64. Make appropriate changes to other instructions. Use test code based on the ma- 4. comrf
chine language program in section 8.3.2.5.3. Hint: because of the restrictions on <= in One statemen
VITO, you need to define a 13-bit lac register, rather than separate link and ac language and
registers. of a program)
11-5. Modify the design of section 11.9 to include the ISZ instruction (appendix B) in assembly lang
a way that allows the design to fit in a single M4-128/64. Use appropriate test code, longer than th
such as the machine language code from problem 9-2.

11-6. Give Verilog for the architecture of the debounce module in section 11.7.

l This appendix w

484 Verilog Digital Computer Design: Algorithms into Hardware

j



is, Prentice Hall A. MACHINE AND
ASSEMBLY LANGUAGE'

Most people use programs written in high-level languages. High-level languages are
hardware-independent, complex languages that are relatively easy to use. Hardware

1.8. independent means that programs written in high-level languages will run on nearly
any general-purpose computer. Examples of 

given high-level 
in section languages include Pascal, Verilog

and C.
demoboard. The
at is loaded with In contrast, low-level languages are simple in form and closer to how computers actu-
o pulse. The sec- ally operate. This makes them harder for the programmer to use. Low-level languages
ih exadecimal on are hardware dependent and have one statement per machine operation. Hardware de-
6 and a top-level pendent means that low-level languages are designed for a specific computer's hard-
Jse test code that ware. Each statement is called a mnemonic. Mnemonics are easily memorized symbols

that represent each fundamental computer operation in a textual form for the
programmer's use. An instruction is a binary 

11w ork word 
with that 

the represents these fundamental
operations in a form the computer can 

is process.
the 3-bit value

The 13-bit facto- Low level languages include machine language and assembly language. Assembly lan-
unce module of guage is made up of instructions represented by mnemonics. Machine language con-
ie function from sists of the instructions represented in binary. Assembly language has four major parts:
the design flow. 1. labels - symbolic names for places in memory (where variables are stored).
LL, CML, RAR 2. mnemonics - indications of what the computer will do.
iti n the M4- 128/ 3. operand - the data operated on by the instruction.
)ased on the ma- 4. comments - a guide to the program that are ignored by the computer.
trictions on <= in One statement in a high-level language program often 
te link corresponds 

and ac to many assembly
language and machine language instructions. For example, the machine language file
of a program written in C and the machine language file of the same program written in

i (appendix B) in assembly language are basically equivalent. But, the assembly language version is much
opriate test code, longer than the C program. Consider the following very simple program:

section 11.7.
/* Total tuition for three classes*/
int tuit,engl=74,cosc=106,math=148;
maino{tuit = engl + cosc + math;}

l This appendix was written by Susan Taylor McClendon and Mark G. Arnold.

Ware
Appendix A 485



-q

This is equivalent to the following assembly language program written for the PDP-8,
a simple general-purpose computer used as an example in chapters 8, 9 and 11: B.

label mnemonic operand comment The comman
*0100 /starting addr non-memory

CLA /put zero in AC in little endia
TAD ENGL /add ENGL to 0
TAD COSC /add COSC to ENGL
TAD MATH /add MATH to COSC+ENGL
DCA TUIT /store in TUIT, clear AC
HLT Memory

/halt
ENGL, 0112 /74 dollars 1. TAD(I
COSC, 0152 /106 dollars link
MATH, 0224 /148 dollars
TUIT, 0000 2. DCA(

ac.

3. AND(O
The *0100 indicates the starting address of the program in octal. The mnemonics indi- 4. JMP(5x
cate what each instruction does. The operand refers to a label defined later in the pro- process
gram. The following shows this example program translated to PDP-8 machine lan- The PC
guage code:

5. ISZ(2xi
0100/7200 Skip nex
0101/1106
0102/1107 6. JMS (4x
0103/1110 instructi(
0104/3 111 becomes
010 5/7402 which in
0106/ 0112
0107/0152 The "xxx8" in t]
0110/ 0224 There are four
0111/ 00 00 direct current 

addressing mo(

The four digits on the right of the "" indicate a memory address in octal. The four Why do we nee
digits on the left indicate the contents which show the octal values of the bit patterns we can represei
representing the machine language equivalent of each mnemonic. Starting at address of the ir. Only
01068 the contents are data values, not instructions. these seven bits

bit address bus
TAD performs a Two's complement ADdition of the operand to the contents held in the (starting at page
AC. DCA, Deposit and Clear the AC, deposits the value held in the AC into memory

a particular pag
and then clears the AC. CLA and HLT are non-memory reference instructions. The CLA Bit eight indice
instruction CLears the AC and the HLT instruction causes the fetch/execute algorithm
to stop. The machine language code for CLA is 72008 and for HLT is 74028. More
details about these and other instructions of the PDP-8 are given in appendix B. 1This appendix was

486 Verilog Digital Computer Design: Algorithms into Hardware

I



['or the PDP-8,
and 11: B. PDP-8 COMMANDS'

The commands listed below are the Memory Reference Instructions (MRI) and the
non-memory reference instructions of the PDP-8. The bits referred to below are given
in little endian notation.

Memory reference instructions
1. TAD (xxx,) - Two's complement ADd contents of memory address xxx8 to the

link and ac.

2. DCA (3xxx5) - Deposit contents of ac at memory address xxx8 and then Clear
ac.

3. AND (Oxxx 8) - Logical AND of ac with contents of memory address xxx8 .
nemonics mdi- 4. JMP (5xxx8 ) - JuMP to memory address xxx8 so that the fetch/execute cycle will
ater in the pro- process the instruction stored there instead of the next sequential instruction.
B machine lan- The PC is simply loaded with xxx .

5. ISZ (2xxx8 ) - Increment (add 00018) to contents of memory address xxx8 and
Skip next instruction if contents become Zero.

6. JMS (4xxx5 ) - JuMp to Subroutine located at memory address xxx . The JMS
instruction saves the return address at memory addess xxx8 and then the PC
becomes xxx8 + 0001 . (The return address is the value of the PC indicating
which instruction would have otherwise executed next.)

The "xxx," in the MRI instructions indicates a memory address used by the instruction.
There are four addressing modes of the PDP-8: direct page zero, indirect page zero,
direct current page and indirect current page. There is also a variation of the indirect
addressing mode known as autoincrement.

octal. The four Why do we need other addressing modes? One reason lies in the number of addresses
the bit patterns we can represent using the page addressing bits. The page addressing bits are bits 6-0

xrting at address of the ir. Only 2 or 12810 addresses (starting at address 0,o) can be represented by
these seven bits. To represent the other 39680 memory locations possible with the 12-
bit address bus, the PDP-8 subdivides the 409610 memory locations into 3210 pages

[tents held in the (starting at page zero) of 12810 memory locations (409610 DIV 12810 = 321). To access
LCin to memory a particular page, the PDP-8 uses two types of addressing modes: direct and indirect.
-tions. The CLA Bit eight indicates either direct or indirect addressing mode and bit seven indicates
ecute algorithm
is 74028. More
pendix B. l This appendix was written by Susan T. McClendon and Mark G. Arnold.

pare Appendix B 487

A



either page zero or current page. Page zero is normally used for global variables and Non-mei
constants and the current page (018-378) is normally used for local data and corre-
sponding code. The following lists the combinations of bits seven and eight for each Group 111
possible addressing mode:

1. CLA(,
ir[8] ir[7] Addressing Mode Effective Address 00008.

o O Direct Page Zero ir[6:0]
o 1 Direct Current Page {pc[11:7],ir[6:0]J 2. CLL (7
1 0 Indirect Page Zero m[ir[6:0]] 3. CMA(
1 1 Indirect Current Page m[{pc[11:71,ir[6:0]}]

ments

Direct page zero computes the Effective Address (EA) as simply the low-order seven 4. CML('

bits of the instruction register. This is the only addressing mode used in appendix A. the ii

Direct current page computes EA as the high-order five bits of the program counter 5. RAR (
concatenated to the low-order seven bits of the instruction register. This is useful for tion shi
programs that do not fit in the 128 words of page zero. Indirect page zero computes EA and bit
as the contents of memory pointed to by the low-order seven bits of the instruction
register. Similarly, indirect current page computes EA as the contents of memory pointed 6. RTR -(

to by the concatenation of the high-order five bits of the program counter and low- Bit 0 sh

order seven bits of the instruction register. These indirect addressing modes are useful other bi

when the address of data varies during runtime, and also in conjunction with the JMP 7. RAL(7
instruction to return from a subroutine (called by a JMS instruction) or from an inter- shifts bi
rupt service routine. shifts tc

The indirect addressing modes are slower, but more powerful, than the direct address- 8. RTL (7(
ing modes since the EA comes from memory. First, the machine obtains the address of 11 shift!
the EA from the instruction register (and possibly the program counter). Next, it ac- bits shil
cesses memory to obtain the EA. Finally, it accesses memory to obtain the data.

9. IAC - ('
Autoincrement occurs on the PDP-8 with indirect addressing when the address of the the ac.
EA (not the EA itself) is between 00108 and 0017 In these eight cases, the EA in instructs
memory is incremented prior to execution of the instruction. For example, the instruc- register.
tion 14178 increments the word atm[0017 8 ], and then adds m[m[0017 8 ] to the
accumulator. 10. NOP(

The Group 1
73008

488 Verilog Digital Computer Design: Algorithms into Hardware



I variables and Non-memory reference instructions
ata and corre-
eight for each Group 1 microinstructions

1. CLA (72008) - CLear the Accumulator, bit 7 on. This instruction sets the ac to
00008.

2. CLL (71008) - CLear the link, bit 6 on. This instruction sets the link to 0.
3. CMA (70408) - CoMplement the Accumulator, bit 5 on. This instruction comple-

ments (sets all l's to 0's and 0's to l's) the ac.

4. CML (70208) - CoMplement 
Dw-order seven the link, bit 4 on. This instruction complements

the link.
in appendix A.
rogram counter 5. RAR (70108) - Rotate the Accumulator and 1 ink Right, bit 3 on. This instruc-
is is useful for tion shifts bit 11 through bit 0 one position to the right. The link shifts to bit 11
o computes EA and bit 0 shifts to the link. All other bits shift one position to the right.
the instruction

6. RTR - (70128) - Rotate 
nemory the accumulator 

pointed and link Twice Right, bit 3 and 1 on.
Bit 0 shifts to bit 11, the link shifts to bit 10 and bit I shifts to the link. All

unter and low- other bits shift two positions to the right.
iodes are useful
Inw ith the JMP 7. RAL (70048) - Rotate the Accumulator and 1 ink Left, bit 2 on. This instruction
r from an inter- shifts bit 10 through 0 one position to the left. The 1 ink shifts to bit 0 and bit 11

shifts to the l ink. All other bits shift one position to the left.

direct address- 8. RTL (70068) - Rotate the accumulator and link Twice Left, bit 2 and 1 on. Bit
is the address of 11 shifts to bit 0, the 1 ink shifts to bit 1 and bit 10 shifts to the 1 ink. All other
er). Next, it ac- bits shift two positions to the left.
i the data.

9. IAC - (70018) - Increment the ACcumulator, bit 0 on. Adds 1 to the contents of
e address of the the ac. If the ac is 77778 the link will be complemented (as in the CML
ases, the EA in instruction). This allows the link and ac to act together as a 13- bit counter
iple, the instruc- register.
)0178] to the 10. NOP (70008) - No OPeration, bits 0-7 off.

The Group 1 Microinstructions can be combined together. For example CLA CLL is
73008.

vare Appendix B 489

M



Group 2 microinstructions C. C
1. SMA (75008) - Skip on Minus Accumulator, bit 6 is 12 and bit 3 is 02- Normally

used with signed data. Skips the next instruction if the value in the ac is nega-
tive. Combinatio,

2. SPA (75108) - Skip on Positive Accumulator, bit 6 is 12 and bit 3 is 12. Normally the kind of d
used with signed data. Skips the next instruction if the value in the ac is posi- logic is criti,
tive. logic has no

previous rest
3. SZA (74408) - Skip on Zero Accumulator, bit 5 is 12 and bit 3 is 02. Skips the next algorithms. (

instruction if the value in the ac is equal to zero. pendix D) to
4. SNA (74508) - Skip on Non-zero Accumulator, bit 5 is 18 and bit 3 is 12. Skips the design proce

next instruction if the value in the ac is not equal to zero. mixture of cc
combination;

5. SZL (74308) - Skip on Zero link, bit 4 is 12 and bit 3 is 12 Skips the next to describe ti
instruction if the link is 02.

This appendi
6. SNL (74208) - Skip on Non-zero link, bit 4 is 12 and bit 3 is 02. Skips the next at a higher le

instruction if the 1 ink is not equal to zero. design (the r
7. SKP (74108) - SKiP unconditionally, bit 3 is 12. Skips the next instruction. look at a des'

sible level, v
8. HLT (74028) - HaLTs the computer. Implemented by setting the HALT bit. possible. Lov
9. OSR (74048) - Inclusive Or of the Switch Register with the ac. The result is left must be dealt

in the ac and the original content of the ac is destroyed. have largely 
manually. Th

Note that all the memory reference instructions begin with 08 to 58 and that all the non- course (dealii
memory reference instructions (group 1 and group 2 microinstructions) begin with 78 days are carri
The I/O (Input/Output) instructions are not given here, but they all begin with 68. exposure to s
Interrupts are external signals that cause temporary suspension of the fetch/execute cally. Instead
cycle. On the PDP-8, there are two instructions, ION (60018) and IOF (60028) that binational lol
control whether interrupts are ignored. ION sets the interrupt enable flag, and IOF want to be wl
clears it. On the PDP-8, an interrupt is ignored unless the last instruction was not 60018
and interrupt enable flag is 1. If these conditions are met, the interrupt causes the same
action as executing the instruction 40008 without fetching such a machine code from C.1 Mc
memory. The interrupt also causes the interrupt enable flag to become 0. At that point,
the fetch/execute cycle resumes. At the All 

end of scientific
the interrupt service routine, the pro-

grammer must put that 
an ION are easie

instruction followed by a JMP indirect instruction.
puter scientist
a designer do
model of real
sary details, 
model of reali

490 Verilog Digital Computer Design: Algorithms into Hardware



C. COMBINATIONAL LOGIC
s 02- Normally
ie ac is nega- BUILDING BLOCKS

Combinational logic (also known as combinatoriall ogic) is the term used to describe
the kind of digital hardware whose output depends 

is only on its inputs. 
12. Normally Combinational

he ac is posi- logic is critical to the operation of all computers; however, by itself, combinational
logic has no memory. Because of this inability for combinational logic to "remember"
previous results, combinational logic, by itself, is insufficient to implement non-trivial

Skips the next algorithms. Combinational logic needs to be combined with sequential logic (see ap-
pendix D) to implement such algorithms. The early chapters of this book explain the
design process 

is 1 Skips the by which an algorithm is transformed into a structure composed of a
mixture of combinational and sequential logic. This appendix provides a review of the
combinational logic building blocks used throughout this book, and the notations used

Skips the next to describe them.

This appendix does not focus on circuit diagrams or netlists. Instead it describes things
Skips the next at a higher level, known as block diagrams. As described in section 2.5, hierarchical

design (the relationship between circuit diagrams and block diagrams) allows us to
struction. look at a design at several levels of detail. Designers should work at the highest pos-

sible level, which means the notation used should conceal as much of the detail as
HALT bit. possible. Lower levels of detail (such as the gate level, circuit diagram or netlist levels)
'he result is left must be dealt with at some point. Modem approaches, such as Verilog synthesis tools,

have largely eliminated the need for designers to manipulate these lower level details
manually. The bottom-up skills traditionally taught in an introductory digital design

that all the non- course (dealing with optimization of gates) are precisely those manipulations that nowa-
) begin with 7 8 days are carried out automatically. This appendix assumes the reader has had enough
sin with 68. exposure to such details previously to believe that they can be carried out automati-
e cally. 

fetch/execute Instead, sections C.2 through C. 11 focus on a top-down approach, based on com-
)F binational 

(60028) logic 
that building blocks. First, section C. 1 discusses how detailed we might

flag, and IOF want to be when describing these devices.

n was not 60018
,auses the same
hine code from C.1 Models of reality
0. At that point, All scientific and engineering disciplines use simplified and 
outine, idealized 

the pro- models of reality
that are easier to describe with mathematics than 

ruction. the reality itself. The role of the com-
puter scientist or engineer is to create a useful product and get it to market rapidly. Such
a designer does this by applying a model of reality to a practical problem. By using a
model of reality that is too complicated, the designer will be burdened with unneces-
sary details, and the product will be late to market. The designer needs to choose a
model of reality that is appropriate, as illustrated by the following planetary analogy. A

are Appendix C 491

j



planetary model that says that the sun orbits around the earth in a perfect circle every
twenty-four hours is an acceptable the gates 

model th,
of reality for everyday problems. The math-

ematical simplicity of a circle to 
is compelling, try out 

but there are problems where the highly
simplified model is insufficient. combination

A more accurate model would say that the earth orbits
the sun in an elliptical path as the earth itself rotates. Although not as simple as a circle,
an ellipse is still fairly straightforward to describe with simple mathematics. For some C.1.4 PI
problems the elliptical model would also be insufficient, and a very complex model, The most a(
considering lunar interaction, etc., might be required.' factors that

analog elect
C.1.1 Ideal combinational logic model tance, etc. A
Speed and cost are not the first realities, 

concerns the
of the designer. Producing a design that imple-

ments a correct algorithm is the cal 
top reality 

priority. t(
For this reason, it will be convenient to

think of combinational logic as detail.
being instantaneous. Such idealized combinational logic

cannot exist in the physical world and is analogous to saying the sun orbits around the
earth. Although an idealized model may seem too simple, it is the proper model for
automatic Verilog synthesis, which helps ensure that the designer gets the product to C.2 Bu
market on time. Most of this book (with the primary exception of chapter 6) assumes The fundamc
idealized combinational logic. that transmit

with a slash
C.1.2 Worst case delay model ber of bits th
Just as in the planetary analogy, sometimes the problem will demand something more
accurate. As illustrated in chapter 6, there are problems where the computer designer C.2.1 Ui
must meet certain speed and cost constraints. Rather than jumping from no detail to A bus is eith,
every detail, it would be nice to have a simple, but reasonably accurate, model, analo- unidirectiona
gous to the elliptical model of planetary motion. In computer design, the worst case direction. Th
propagation delay model satisfies this need. Worst case propagation indicates the maxi- bus. For exar
mum number of gates through which a signal change must pass in the worst case. An
assumption commonly used in this model is that each gate has a delay of one unit of
$ time in a Verilog simulation.

C.1.3 Actual gate-level delay model
The delay in a combinational logic device depends on the values being processed by Figure C-1
that device. Sometimes, the delay may be shorter than predicted by the worst case
model. As described in chapter 6, it is difficult to consider all the possible paths through Being four bii

All but a few
technologies
implement the
are oriented to

l In fact, such complex planetary models are only practical because of electronic computers that can simulate
these complex interactions.

492 Verilog Digital Computer Design: Algorithms into Hardware

I L



:t circle every the gates that compose the device. A Verilog simulator is a tool that allows the designer
ns. The math- to try out many combinations of values to see how long it takes for the simulated
ere the highly combinational device to process the information under different circumstances.
he earth orbits
ple as a circle,
tics. For some C.1.4 Physical delay model
mplex model, The most accurate but cumbersome model considers all the physical and geometric

factors that compose the machine. Such a model considers physical laws that govern
analog electronics, including factors such as the speed of light, capacitance, induc-
tance, etc. Although there are times when computer designers must confront these harsh
realities, the goal of a good top-down technique is to insulate the designer from physi-

ign that imple- cal reality to as great an extent as possible. This book never considers this level of
convenient to detail.
inational logic
)its around the
iper model for
the product to C.2 Bus
ter 6) assumes The fundamental building block of all combinational logic is the bus. A bus is a device

that transmits information from a source to a destination. The symbol for a bus is a line
with a slash drawn through it. Next to the slash is a number, which indicates the num-
ber of bits that the bus transmits at any instant.

)mething more
iputer designer C.2.1 Unidirectional
m no detail to A bus is either unidirectional or bidirectional. Most of the buses used in this book are
model, analo- unidirectional. A unidirectional bus is drawn as a line with an arrow pointing in one

the worst case direction. The arrow indicates the direction in which information flows through the
cates the maxi- bus. For example, the following is a four-bit unidirectional bus:
worst case. An
of one unit of

I~~~~

4

Figure C-l. Symbolfor 
g processed a four-bit 

by unidirectionalb us.

the worst case
Being four bits wide, this 

e paths bus 
through can only transmit numbers that range from 0 to 15.

All but a few experimental computers have been built with electronics. Although other
technologies besides electronics (such as the relatively new field of photonics) can
implement these abstractions, modern synthesis tools and the entire computer industry
are oriented toward the following electronic approach. In this electronic approach, the

rs that can simulate

;are Appendix C 493

A



abstraction of an n-bit-wide bus is physically implemented as n "wires" running con-
ceptually in parallel to each other. For example, the above four-bit bus would actually
be four "wires":

- milte
-L-J I

a[2] I

a[1] >

a[O]
Figure C

Figure C-2. Implementation of a four-bit bus.

is equivalent
Each "wire" transmits one bit of binary information from the source. For example, to (known as p.
send the number a=1 5 from the source to the destination, all four transmit a one:

l C.2.3 A(
1 At any instat

physical valt
1 

Voltage by it
1 machines tha

Figure C-3. Transmitting 15 on a four-bit bus. late physical
each wire, oi
rather than ti

On the other hand, to send the number a=7, the most significant "wire" instead trans- lates into bin
mits a zero:

In the active I
0 the active lox
1 wires are acti

sion. Beware
1 

1 

Figure C-4. Transmitting 7 on a four-bit bus.

C.2.2 Place and route 2 The numeric v

Whether or not the physical implementations of these voltage, 
four the 

"wires" aste
(composed perhaps is five volts, and

of a connection between insulated wire dangling in the air, copper plating on a circuit voltages, such as
board and traces within an integrated circuit) actually run geometrically parallel to
each other is irrelevant. For example the following: 3When all the si,

low, the system it
(not to be confut
described in char

494 Verilog Digital ComputerD esign: Algorithms into Hardware

I



P.-

' running con- I
would actually

Figure C-S. One possible routing of a four-bit bus.

is equivalent to figure C-4. Such geometric details need not concern us because tools
or example, to (known as place and route) determine this automatically.
mit a one:

C.2.3 Active high versus active low
At any instant, each "wire" will be at one of two voltages, known as high and low. The
physical values of these voltages seldom concern the designer.'
Voltage by itself is not information. The goal of this book is to describe how to design
machines that process binary information. Additional abstractions are necessary to re-
late physical voltages to the binary information being processed by an algorithm. On
each wire, one of two possible abstractions is chosen (perhaps by the synthesis tool
rather than the human designer) to forever describe how a voltage on that wire trans-

'instead trans- lates into binary information. These two abstractions are active high and active low.
In the active high abstraction, the high voltage means 1 and the low voltage means 0. In
the active low abstraction, the opposite holds.3 The easiest approach is to assume all
wires are active high, which is the approach used in this book in order to avoid confu-
sion. Beware that with actual physical chips it is common that some wires will be

2 The numeric values of these voltages vary depending on the technology used. Typically, the lower the
voltage, the faster the machine. For the rugged TTL logic families commonly 

iposed perhaps used in educational labs, high
is five volts, and low is zero volts. Faster, more modem but less rugged chips based on CMOS use lower

ng on a circuit voltages, such as 3.3 volts. Slow vacuum tube machines of the 950s used around +50 volts and -25 volts.
ally parallel to

3When all the signals are active high, the system is know as positive logic. When all the signals are active
low, the system is known as negative logic. When the system is a mixture of both, it is known as mixed logic
(not to be confused with the very different concept in Verilog of mixed behavioral structural design, as
described in chapter 4).

are Appendix C 495



active low while other are active high. If you use test equipment to observe the opera-
tion of an actual physical chip, you must understand the active low abstraction; how-
ever, during the design process, you can ignore this confusing issue. a -

2

C.2.4 Speed and cost
In this book, we assume an ideal bus, even if other combinational devices in the design Figure C
are not ideal. Such an ideal bus, which would transmit a signal change from the source
to the destination in zero seconds, cannot exist in the physical world. This miscor

software rec
Unlike the other devices described later in this appendix, the speed of a unidirectional
hus dne not din-nd onn aitP-1pvel nrrnnqaqtr, (1A Th.r-f-r inI  the - w A- -P -- A-

the speed of a bus is also instantaneous. As described in chapter 6, Verilog allows a
designer to simulate propagation delay on other devices, but buses in Verilog typically
have no delay.

The physical speed of a unidirectional bus can be determined by dividing its geometric
length by a constant which describes how fast a change in a signal travels along the Accomplish
bus. For most electronic buses, this constant is approximately the speed of light, which two differen
is roughly one third of a meter (one foot) per nanosecond. locations:
The reason unidirectional buses have been preferred is that they are extremely cheap
and fast compared to the other combinational devices described later that are built out
of gates. Bidirectional buses (appendix E) have gate-level propagation delay, like any
other combinational device. a-

Cost is usually related to how much area a device takes on a chip. The area of a bus is
at least the width of a wire times its geometric length times the number of bits in the
bus. The area of a bus may be larger when problems occur in place and route. Figure C-

As technology has improved, the relative speed and cost advantage of buses have di-
minished. In modem "deep submicron" silicon fabrication, interconnection delay, par- One of man)
ticularly between chips, is a significant factor.

C.2.5 Broadcasting with a bus
Another advantage of unidirectional buses is that they allow broadcasting of informa-
tion from a single source to a reasonably large number of destinations4 a[1]-

at little addi-
tional cost. It is a common misconception among novice hardware designers that to a[F]  -
send the same information to two places in a design requires some special device:

Figure C-

4How many destinations is determined by the fanout of the logic family.

496 Verilog Digital Computer Design: Algorithms into Hardware

j



r

serve the opera-
straction; how- b

a

C

es in the design Figure C-6. Unnecessary device.
from the source

This misconception is understandable since to make b and c synonymous with a in
a unidirectional software requires two explicit (and possibly expensive) steps:
Drst case model,
'erilog allows a
'erilog typically

ig its geometric
avels along the
of light, Accomplishing 

which the same thing in hardware is essentially free. You simply run the bus
two different places, and refer to the same physical bus by different names at these 
locations: new

Ktremely cheap
iat are built out
delay, like any

1__ _ _ 
a _ _2  _ b

2
area of a bus is
,r of bits in the 2 C

I route. Figure C-7. Transmitting on one bus to multiple destinationsforfree.
buses have di-
tion delay, par- One of many geometric arrangements of "wires" that can accomplish this is:

b[1]

ng of informa- b[0]
a[1] 

4 at little addi- I

signers that to -rn1
C[Uj i 10 0 C[0]

vial device:
-r-4 i

Figure C-8. Implementation offigure C-7.

2re
Appendix C 497

MMMM



Note there is no connection between a [ 1 ] and a [0 , although there are connections
between a[O, b[0] and c [O] and between a[3]

a[1], b[1] and c [1]. Within the
time it takes light to travel the physical distance of the bus, the voltages at b [ 1 ] and a[2]
c [ 1] will be the same as a [ 1], which means that bit of information has been trans-
mitted to those two locations. a[1]

a[O]
It is common for a designer to use different names for the same bus, but doing so can be
confusing. It would be better whenever possible to use the same name at both the
source and destinations: Figure C-

This subset t
a to form a sul

2
a which separa

2 the bus b car
oa

2 tinuous groul
bit select, thz

Figure C-9. Using the same name at every node.

since this more accurately reflects physical reality. Nevertheless, there will be times If the destina
when it is advantageous to re-label the same bus with different names. A rose by any
other name is just as sweet, and a bus by any other name is just as cheap.

C.2.6 Subbus
There are certain operations in the binary number system that are trivial to implement. Figure C--
For example, unsigned division by two, b=a/2 (also known as shift right, b=a>>1)
appears to require some special device: b [ 3 ] would

a G o d - b
4 3

Figure C-10. Combinationald evice to divide by two (three-bit output).

but in fact can be implemented at no cost simply by rearranging how a subset of the
wires of the bus a is connected to b:

Figure C-J

In concatena
{O,a[3:1]

5 In correct Veri

498 Verilog Digital Computer Design: Algorithms into Hardware



onnections a[3]
Within the
b[l] and a[2] b[2]

been trans- a[1] b[ ]

a[O] - no I b[O]
ig so can be connection
at both the Figure C-li. Implementation offigure C-10.

This subset bus is known as a subbus. A designer can select any bits of the source bus
to form a subbus. The notation we use for this is the concatenation syntax of Verilog,
which separates the name of the individual wires with commas inside { . For example,
the bus b can be described as {a  [ 3 , a [2] a [ 1 }. Since subbuses that take a con-
tinuous group of bits from the source are common, there is another notation, known as
bit select, that can be used: a [ 3: 1 ] means the same as {a [ 3 ]a [ 2 ,a[1] }.

ill be times If the destination was also supposed to be four bits:

rose by any
a >>1 b

4 4

implement. Figure C-12. Combinationald evice to divide by two (four-bit output).
.t,b =a>>l)

b [3 ] would have to be tied to a constant 0:

a[3] 0 b[3]

a[2] b[2]

a[1] | > b[1]
ubset of the a[O] - no b[O]

connection
Figure C-13. Implementation offigure C-12.

In concatenation notation, this5 would be { 0, a [ 3 , a [ 2 , a [1]} or simply
{0,a[3:1] }

In correct Verilog notation, the constant 0 would have to be described as 1 bO.

e Appendix C 499

MOMEMEMOMWO10



__

C.3 Adder
Many algorithms, even those that are not primarily mathematical, often need to do
addition of binary numbers. One way to accomplish this is to provide a combinational
logic unit that performs this computation: a-

a
sum

b Figure C-.

Figure C-14. Combinationald evice to add where 
two n-bit values the n-I

(n+1 bit output).
b only when
The physical

The block diagram symbol for an adder is simply a rectangle with a "+" or the word adder. The a(
"adder" inside it. The number of bits in the output bus is one more than the number of simplifies the
bits in the larger of the input buses to allow for the largest possible sum. Note that a, b served while 
and sum are typically unsigned. (The low-order n bits of sum are also valid when they however, the 
are signed twos complement; however there are complications with signed values be- be ignored.
yond the scope of the discussion here.)

a-
C.3.1 Carry out
It is common for the extra bit in the sum to be broken into a separate carry out (cout)
signal, with wordsum being a subbus:

FigureC -l

a
C.3.2 Sp(

b There are ma
common tech

Figure C-15. Treating about 3 *n 
the high-order 01

bit as carry out.
inputs). Anott
in sections 2.5

where sum= cout, wordsum}. The above is often drawn as: proportional t

Faster techniq
dude carry lo,

500 Verilog Digital Computer Design: Algorithms into Hardware



PI-

cout

rten need to do
combinational

a
wordsum

b

Figure C-16. Alternate symbolforfigure C-15.

where the n-bit 
ito utput). wordsum is a valid result that fits within the same sized word as a and

b only when cout is 0. When cout is 1, an overflow error is said to have occurred.
The physical implementation of this approach is identical to the earlier view of the

' or the word adder. The advantage of this view is that all buses are the same width, which often
i the number of simplifies the design of a larger system. The disadvantage is that cout must be ob-
[. Note that a, b served while the system is in operation to detect the possibility of an error. Sometimes,
valid when they however, the designer has a priori knowledge that wordsum is small, and so cout can
aned values be- be ignored.

a
wordsum

wry out (cout) b

Figure C-17. Adder without carry out.

C.3.2 Speed and cost
There are many ways that adders can be implemented physically. One of the most
common techniques is the ripple carry approach, which requires a circuit composed of
about 3 * n OR gates (each having two inputs) and 6 n AND gates (each having two
inputs). Another way to state this is that it requires n full-adder modules (as described
in sections 2.5 and 3.10.6). The worst case propagation delay for a ripple carry adder is
proportional to n (as illustrated in section 6.3).
Faster techniques exist that require more gates. Some commonly used techniques in-
clude carry lookahead and carry skip.

vare Appendix C 501



C.4 Multiplexer needs only 
The multiplexer (commonly referred to as a mux) is the most important combinational down to tw(
logic building block next to the bus. Its purpose is to select one of its inputs to be its mented this
output and to ignore its other inputs. This "out of many, choose one" behavior is sym-
bolized in this book as a triangle, whose tip is the one chosen output:

C.5 01
Although ad
tional buildi

ioi / 
n scribes sever

combination
ii i/ 1

n

2 out C.5.1 In
n One of the n

k
imax - -

n a
n

slk

Figure C-
select

Figure C-18. Symbolfor multiplexer Although cot

Some people draw muxes as a rectangle with the word "mux" written inside. The mux a
has a select input, which is k bits wide. The mux also has (at most) 2 other buses that n
are data inputs (i 0, i 1, i 2, . . . imax), each n bits wide. The mux has one data
output which is n bits wide. If any input bus has fewer bits, assume zeros are concat- n
enated on the left.

Figure C-=

C.4.1 Speed and cost
There are several ways a mux can be implemented physically. In the most common it is better to
approach, the mux shown above would be implemented using n OR gates (each hav- adder is ineffi
ing 2k inputs), n*2kAND gates (each having k inputs) and k inverters. This approach

6 The need for in,
both active high;
such as flip flops,
cost.

502 Verilog Digital ComputerD esign: Algorithms into Hardware

I



needs only three stages of propagation delay. Sometimes it is possible to reduce this
~ombinational down to two stages (by eliminating the need for the inverters') and so muxes imple-
.puts to be its mented this way are quite fast.
savior is sym-

C.5 Other arithmetic units
Although addition is the arithmetic operation for which we typically use a combina-
tional building block, other operations can be implemented similarly. This section de-
scribes several arithmetic operations for which it is reasonable to fabricate specialized
combinational logic.

C.5.1 Incrementor
One of the most common operations is adding one to a number:

a +1 a+1
n n

Figure C-19. Symbol for incrementor

Although conceptually this could be implemented as:

iside. The mux a
ther buses that a+1

ix has one data 1
ros are concat-

Figure C-20. Inefficient implementation of incrementor

most common it is better to specify an incrementor if that is all the problem needs. Using a general
ates (each hav- adder is inefficient both in terms of speed and cost.
.This approach

6 The need for inverters can be eliminated in so-called dual rail designs, where every signal is provided in
both active high and active low form. The reason the inverters are not needed is because certain devices,
such as flip flops, naturally provide both active high and active low versions of the same signal at no extra
cost.

Appendix C 503



C.5.1.1 Speed and cost C.5.4 Si
Although ripple carry addition of two arbitrary numbers requires n stages of worst case The buildin
propagation delay, incrementation can be done in only two stages of propagation delay
using n-1 OR gates (each with two inputs), 2 *n-2 AND gates (each with two in-
puts), n- 1 AND gates (of various sizes) and some inverters. a /

n

C.5.2 Ones complementor b -
n

The ones complement, -a-1 (also known as bitwise not, -a):
Figure C

a o -a-1
n n Although a

The additior

Figure C-21. Symbolfor ones complementor. One approa
complement

is often part of a larger computation. ized logic fo

C.5.2.1 Speed and cost C.5.5 S
The ones complement only takes n inverters, and one unit of propagation delay. Multiplicatic

tially no cosi
(shifting left

C.5.3 Twos complementor
Forming the negative of a signed number is necessary in many algorithms:

a -

1 

a - -a
n n Figure C-

Figure C-22. Symbol for twos complementor. simply concz
cost anything

This can be implemented as Sometimes l
designer to sl

a - +1 -a
n n n a -

Figure C-23. Possible implementation of twos complementor
Si-

Figure C-,

504 Verilog Digital Computer Design: Algorithms into Hardware

I
WM



r

C.5.4 Subtractor
:so f worst case The building block for a combinational logic subtractor is analogous to 
pagation addition.

delay
h with two in-

a

n+1
b

n

Figure C-24. Symbol for subtractor

Although a and b are unsigned, di f f erence is a signed twos complement value.
The additional bit in the output indicates whether the difference is positive or negative.
One approach to implement a subtractor would be to use an adder and a twos
complementor. A more efficient but less common approach would be to derive special-
ized logic for subtraction ("full subtractors").

C.5.5 Shifters
Multiplication 

ion delay. and division by constant powers of two can be accomplished at essen-
tially no cost through subbusing and concatenation. For example, multiplication by 4
(shifting left two places):

ims:
a <2 4*a

12 14

Figure C-25. Symbol for shifter.

simply concatenates a to two bits that are zero on the right. The reason this does not
cost anything is because the power of two is a constant.
Sometimes the shifter has another input, known as the shift in (si), that allows the
designer to specify what the least significant bits are:

a 4*a+si

Si

Figure C-26. Symbolfor shifter with shift input.

vare Appendix C 505



-

Again, such a device is essentially free because it is implemented as the concatenation
of a to si. C.5.6 M

The left barr
A barrel shifter allows a variable number of places for the shift. The number of places Many algori
to shift is given by a k-bit shift count (sc) bus: multiplier is

multiplied:

a
n a

n+2k1 n

b -
n

Sc

Figure C-27. Symbol for barrel shifter with shift count input. Figure C-=

This can be implemented in two (or three) levels of worst case Note 
propagation that the

delay as
constant shifters and a mux: assume that a

multiply sign(

C.5.6.1 Si
a There are mar

niques require
delay of additi
compared to 

.a*2sc involving sequ
generate a pro(

C.5.7 Divi
Division (by n(
mented as a co

Sc combinational!
sion can be imr

Figure C-28. Possible implementation of barrel shifter

An alternative implementation which is slower but less costly uses k muxes, each with
two inputs. C.6 Ariti
A similar right shifter can be implemented for division by variable powers of two. In many problei
Barrel shifters can be arranged to allow for both multiplication or division by arbitrary functions under
powers of two, and to allow for arbitrary shift input (rather than concatenation with tions needed for
zeros).

506 Verilog Digital Computer Design: Algorithms into Hardware

a



r

[e concatenation C.5.6 Multiplier
The left barrel shifter in the last section only allows multiplication by a power of two.

umber of places Many algorithms need multiplication by variables that are not powers of two. The
multiplier is a fairly costly hardware device that allows two arbitrary numbers to be
multiplied:

a
product

b

Figure C-29. Symbolfor multiplier

Note that the product has twice as 
agation many 

delay bits 
as as the input buses. We will normally

assume that a, b and product are unsigned. It takes a physically different device to
multiply signed numbers.

C.5.6.1 Speed and cost
There are many ways to do multiplication; however the most commonly used tech-
niques require on the order of n gates, and at least twice the worst case propagation
delay of addition. Because the cost and speed of a combinational multiplier is so high
compared to the devices discussed in this appendix, a slower but cheaper approach
involving sequential logic (appendix D) and ASM charts (chapter 2) is often used to
generate a product.

C.5.7 Division
Division (by non-powers of two) is even more costly than multiplication when imple-
mented as a combinational logic building block. Division is seldom implemented as
combinational logic. Most of this book uses an example of one simple way that divi-
sion can be implemented using sequential logic and ASM charts.

nuxes, each with
C.6 Arithmetic logic unit

powers of two. In many problems, the same building block needs to compute different mathematical
vision by arbitrary functions under different circumstances. A single unit that can handle most of the func-
ncatenation with tions needed for a system is known as an Arithmetic Logic Unit (ALU). A designer can

ware Appendix C 507



I

I

choose to put whatever functionality in an ALU as is appropriate for a particular prob- Note that Al
lem, however it may be convenient7 to use an ALU that has already been designed, ALU can al!
such as the 74xx1 81. ALU might I

above.
Regardless of what details are inside the ALU that a designer chooses, the basic prin-
ciple of how a combinational logic ALU operates is the same. There is a k-bit bus,
aluctrl, that customizes the ALU for the particular function that needs to be com- C.6.1 Li
puted. As its name i

cal operation
a and also p(

a d of a four-bit.
n

b

k

aluctrl

Figure C-30. SymbolforArithmetic Logic Unit (ALU).
In other worc
and f [0] =a

Conceptually, an ALU could be implemented as a mux which selects from the various puting 'AND
combinational functions which that particular ALU is capable of performing: b [0]. Break

equations as
trivial but ted
with because
signer needs t.
separate AND
stand the won
of how many

Mathematical
n no more than

and involving
fied by the laa
a table of the!

Figure C-31. Possible implementation of ALU.

8 This quite descri
7Especially in an educational lab setting. early 1990s.

508 Verilog Digital Computer Design: Algorithms into Hardware



articular prob- Note that ALUs typically allow the passing through of a or b unmodified, and so an
)een designed, ALU can also serve the role of a mux. In physical reality, the implementation of an

ALU might be quite different than a mux, but conceptually an ALU is equivalent to the
above.

the basic prin-
is a k-bit bus,
-ds to be com- C.6.1 Logical operations

As its name implies, an ALU can perform both arithmetic and logical operations. Logi-
cal operations are those in which each bit of f depends only on the corresponding bit in
a and also possibly on the corresponding bit in b. For example, consider the operation
of a four-bit ALU doing the bitwise 'AND operation, f =a&b:

Inotherwords, f [3]=a[3]&b[3], f [2]=a[2]&b[2], f [1]=a[1]&b[1]
and f [ 0 ] =a [ 0 ] &b [ ] . These bitwise operations are the only dependencies in com-

om the various puting 'AND. For example, in computing f [ 1 ], there is no dependence on a [ 0 ] or
rmning: b [ 0] . Breaking a bitwise operation such as a&b apart into separate single-bit logic

equations as shown above is known as bit blasting.' Bit blasting is one of the many
trivial but tedious details of hardware design that designers seldom need be concerned
with because Verilog synthesis tools do such things automatically. Of course, the de-
signer needs to understand that an n-bit-wide operation like a&b eventually becomes n
separate AND gates operating independently. From this knowledge, it is easy to under-
stand the worst case propagation delay of a&b is only one unit of gate delay, regardless
of how many bits are in a and b.
Mathematically, there are only sixteen primitive bitwise logical operations involving
no more than two variables. All other formulas involving no more than two variables
and involving only combinations of these sixteen primitive operations can be simpli-
fied by the laws of Boolean algebra to one of these sixteen operations. The following is
a table of the sixteen primitive logical operations:

8 This quite descriptive term was coined by Synopsys, the pioneering vendor of Verilog synthesis tools in the
early 1990s.

vare Appendix C 509



alternative
mnemonic aluctrl aluctrl operation

'NOT 000010 f = -a;
'NOR 000110 f = -(alb);
'ANDNA 001010 f = (-a)&b;
'ZERO 001110 f = 0; The fact thal
'NAND 010010 f = -(a&b); f [l] andf
'NOTB 010110 f = -b; proportional
'XOR 011010 f = a'b;
'ANDNB 011110 f = a&(-b); The followir
'ORNA 100010 f = (-a)Ib; the 74xx181
'EQU 100110 f = -(a^b);
'PASSB 101010 f = b;
'AND 101110 101101 f = a&b; 'IN
'ONES 110010 f = -1; 'DE
'ORNB 110110 f = a|(-b); 'PL
'OR 111010 000100 f = ajb; 'DI
'PASS 111110 000000 f = a; 'DO

'DO

The mnemonic column gives arbitrary names to these sixteen operations which will be
used throughout this book. Because the
When designing an ALU for a particular problem, it may not be necessary to include all laboratory ex]
of the sixteen mathematically possible operations inside the ALU. Omitting some of shows how t(
these operations may economize the total area required for the ALU and also may algorithm.
reduce the number of bits required for aluctri.

The 74xx 181 is an ALU that implements all sixteen of the possible logical operations. C.6.3 Sta
Since it also implements many arithmetic operations, it needs a six-bit aluctrl. In An ALU com
the above table, the aluctrl and alternative aluctrl columns indicate the six-bit example, the'
pattern that must be input to the 74xx181 in order to perform the desired operation. For putation curre
certain operations, such as 'AND, 'OR and 'PASS, more than one bit pattern can be the ALU's inti
used to produce the desired result. is being perfo

The second su
C.6.2 Arithmetic operations a==b when ']
In contrast to logical operations, arithmetic operations are those where a change in one
bit position of a or b potentially affects several bit positions of f. For example, con-
sider addition ('PLUS) with the same ALU as the last example using the same values C.7 Con
for a and b:

There are six r
vast majority
determine hom

510 Verilog Digital Computer Design: Algorithms into Hardware

II



r

The fact that a [ 0 ] and b [ 0 ] are both one in this example ultimately affects f [ 0 ],
f [ 1 ] and f [ 2 . This ripple effect is why addition has a worst case propagation delay
proportional to n.

The following table shows some of the most useful arithmetic operations available in
the 74xx181 ALU:

'INCREMENT 000001 f = a+1
'DECREMENT 111100 f = a-l
'PLUS 100100 f = a+b
'DIFFERENCE 011001 f = a-b
'DOUB 110000 f = 2*a
'DOUBINCR 110001 f = 2*a+1

is which will be
Because the 74xx 181 is a low-cost ALU which is readily available for educational
laboratory experiments, it does not 

ry to implement 
include all multiplication or division. Section 2.3.1

shows 
hitting some how 

of to use one of these ALUs to implement division using a slow but simple
J and also algorithm.

may

yical operations. C.6.3 Status
it aluctrl. In An ALU commonly outputs extra information besides just the n-bit-wide result, f . For
licate the six-bit example, the 74xx 181 has two status outputs that provide information about the com-
d operation. For putation currently being performed by the ALU. The first of these, cout, comes from
it pattern can be the ALU's internal adder. It may be used to detect overflow (a+b>=2n) when 'PLUS

is being performed, and to detect a<b when 'DIFFERENCE is being performed.
The second status output, zero, detects whether f==0. It may be used to detect whether
a==b when 'DIFFERENCE is being performed.

a change in one
r example, con-
the same values C.7 Comparator

There are six mathematical relational operators (==, =, <, >, <= and >=). The
vast majority of useful algorithms use one or more of these to make decisions that
determine how the algorithm proceeds. Although the status outputs of an ALU may be

(ware Appendix C 511



able to answer such questions, it is often not efficient to use an ALU to do so. Instead, C.8 De]
a specialized combinational building block, known as a comparator, is used instead. A
comparator has two n-bit-wide input buses, a and b. At most, a comparator has three The demultir

bits of output: used in the 
concepts foui

As the name i
altb for a demux r

a to the tip of 
aeqb side:

b agtb

Figure C-32. Symbol for comparator

From these three outputs, the other three conditions can be derived, for example
ageb=agtb aeqb. Many problems only need an equality test: in-

a
aeqb

b

Figure C-33. Symbol for equality comparator
FigureC -:

C.7.1 Speed and cost Like the mux,
draw the dem

A comparator that only provides the equality output is much cheaper than one that also lected output
provides inequalities, such as atb. Such an equality only comparator needs 2 n
inverters, 2 n AND gates (each having two inputs), n OR gates (each having two
inputs) and one AND gate (having n inputs). The propagation delay for an equality C.8.1 Sp(
only comparator is four units of gate delay under these assumptions. The cost is even Demuxes are
lower when one input is a constant. demux shown

A comparator that also provides inequality outputs will have a worst case propagation ers. Such an i

delay proportional to n. It will also use considerably more area than an equality gates. 
only Sometii

comparator. is only one ga

512 Verilog Digital Computer Design: Algorithms into Hardware

k



o do so. Instead,
used instead. A r C.8 Demux
)arator has three The demultiplexor (demux) is a specialized combinational building block 

used which 
in the early is not

chapters of this book. It plays an important role 
concepts in implementing

found in later chapters.
As the name implies, the demux is the opposite of a mux. The symbol 
for a used 

demux in this 
reflects book

this. It is a triangle where the only input to the demux 
to the is connected

tip of the triangle. The many outputs of the demux are drawn 
side: on the opposite

outo

outl
-d, for example

out2
n

outmax

Figure C-34. Symbolfor demux.

Like the mux, the demux has a k-bit input bus known as select. Some 
draw people 

the demux may
ian one that also as a box. All but one of the n-bit output buses will 

lected be zero. 
ator needs output The 

bus se-
2 *n will pass through unchanged the value on the input bus.

ach having two
for an equality C.8.1 Speed and cost

rhe cost is even Demuxes are simply a large collection of AND gates that operate 
demux independently. 

shown above The
requires n * 2 k AND gates (each having k+ 1 inputs) 

ers. Such and 
an k 

implementation invert-
ase propagation would have a worst case propagation delay 

gates. of 
Sometimes, only two

in equality only the inverters can be eliminated, in which case the 
is propagation 

only one gate. delay

vare
Appendix C 513



r

C.8.2 Misuse of demuxes There is no
Novice hardware designers often use demuxes where they are unnecessary. For ex- In hardwai
ample, suppose part of the time a machine needs to increment a number, a, and part of and ignore
the time the machine needs to multiply it by two, but the machine never needs to incre- Therefore, c
ment and double the number at the same time. Novice designers often put a demux in important ir
such a design: memory sys

(chapter 7).

result
a

C.9 De
1 _ ~ ~r~e~s~u lts A decoder is

some other c
unary code.'

select
Figure C-35. Misuse of demux.

In the above, resultO is a+1 if select==O but is 0 otherwise. Also, resultl is
a* 2 if select==1 but is 0 otherwise. Since it was assumed that a+1 and 2 *a do
not need to be simultaneously available, the above might work, but it would be consid-
ered a bad design for three reasons. First, the demux is an unnecessary and expensive
(both in terms of speed and cost). Second, if the problem changes so that resultl is
supposed to be 2 *a simultaneously with resultO being a+1, the above design would
be completely wrong. Third, even if 2 *a and a+ 1 are never needed simultaneously,
the designer is burdened with providing the proper select. Such a decod

block that sin
It is understandable that novice designers make this mistake. In software, the program-
mer only specifies the operation required (either a+ 1 or 2 * a) based on select. But
in hardware, as was discussed in section C.2.5, it is easier to route a bus to every place binar
where it is needed. The cost of doing this is usually quite low, and certainly less than
using a demux:

Figure C-3

Second, a bins
a

2 k comparator
code. The sec
comparator is

Figure C-36. Properd esign omits demux.

514 Verilog Digital Computer Design: Algorithms into Hardware

I



There is no harm in result being 2 *a simultaneously with resultO being a+l.
sary. For ex- In hardware, it is often more economical to compute everything you might need
a, and part of and ignore those results that are not pertinent under particular circumstances.
eeds to incre- Therefore, demuxes are not needed in the early chapters of this book. Demuxes are
ita  demux in important in more advanced design topics. Demuxes are important in the design of

memory systems (section 8.2.2.3.1) and in the implementation of one-hot controllers
(chapter 7).

C.9 Decoders
A decoder is a specialized combinational device that converts from a binary code to
some other code. The most common decoder converts from binary to what is called a
unary code. The following table lists these codes for the numbers between 0 and 7

value binary unary out

0 000 00000001
1 001 00000010

,resultl is 2 010 00000100
l and 2 *a do 3 011 00001000
uld be consid- 4 100 00010000
md expensive 5 101 00100000
tr esult is 6 110 01000000
design would 7 111 10000000

multaneously,
Such a decoder can be thought of in two ways. First, it can be thought of as a building
block that simply takes k bits of binary input, and produces 2 bits of unary output:

, the program-
select. But
to every place binary dr unary
ainly less than

2

Figure C-37. Symbolfor binary to unary decoder

Second, a binary to unary decoder can be thought of as a building block composed of
2 k comparators. The output of each comparator provides one of the bits of the unary
code. The second input of each comparator is connected to a binary constant. Each
comparator is comparing against a different k-bit binary constant (from 0 to 2 k- 1):

are Appendix C 515



binary ---- i
== / s unary[O] C.9.1 Sr

The speed al
k

C.9.2 01
- cMP== 0 unary[1] Decoders exi

1 1 displays. Suc
k

c2 _ unary[2]
2 t 1 C.10 E.

k Sometimes, 
building bloc

j could be sure
n,-l one), the enc(

kk 1 1]unary[2K 
valid unary o
might appear

Figure C-38. Possible implementation of decoder
Instead, design

Finally, an alternative way of looking at a binary to unary decoder is as a demux whose
one-bit-wide input bus is tied to 1:

unary[o]
1 possibly -
/i unary

1 unary[1]
, 

Figure C-4

1 ~~~~ o unary[2]
12 It outputs the

leading zero.

unary[2 -1] 
1

binary
Figure C-39. Alternate implementation of decoder.

516 Verilog Digital Computer Design: Algorithms into Hardware



C.9.1 Speed and cost
The speed and cost of a binary to unary decoder is similar to a demux.

C.9.2 Other kinds of decoders
Decoders exist that involve other codes besides unary, such as those for seven segment
displays. t

Such decoders are more specialized, and not widely used in computer design.

C.10 Encoders
Sometimes, a designer needs to convert from a unary code to binary. A combinational
building I

block that performs this conversion is known as an encoder. If the designer
could r

be sure the input were always a proper unary code (with exactly one bit that 
one), is

the encoder could be implemented simply with k OR gates. But there are only 2 k
valid unary codes out of the very large number (two raised to the k) of bit patterns that
might appear t

on the input.

Instead, designers use a priority encoder.
demux whose

priority
encoder

possibly / -
unary -4-- 

.k binary
2"1

Figure C-40. Symbol for priority encoder

It outputs the binary code corresponding to the bit position of the least significant
leading zero.

zIree 517
AAppppeennddiixx  C 517



quested by tI
design altern

The priority encoder is useful for counting how many leading bits of a number are zero. derive the lo
This is a computation that is necessary to implement floating-point arithmetic. Priority the most pra,
encoders are also often used so that a general -purpose computer can select which one

This is becau
of several external interrupts has the highest priority. rather than fi

sis tool that 1

There are sea
C.11 Programmable devices that the RONv
Almost any imaginable mathematical function can be realized as a combinational build-
ing block if it involves a small enough number of bits of input. With Verilog synthesis
tools available since the mid 1990s, functions involving around sixteen or fewer bits of address
input are routinely converted into combinational logic without the designer having to
worry about their technological or gate-level implementation. The synthesis tool pro-
duces a file that can be downloaded into one of many kinds of programmable devices. Figure C-
The process of transferring the design into a programmable device is known as pro-
gramming it. Such programming is a mechanical process, which does not require hu-
man intervention or creativity. The term burning is sometimes used to mean the same The number 

k==n. The in
thing as programming. This use of the term programming should not be confused with
its use in software (chapter 8), where the term programming means the same thing as is known as

memory syst(
design, which, of course, requires lots of creativity.

because once
There are many kinds of programmable devices available, including Programmable

Normally, the
Logic Arrays (PLAs), simple and Complex Programmable Logic Devices (CPLDs),

since the RO
Field Programmable Gate Arrays (FPGAs) and Read Only Memories (ROMs). CPLDs

designer migl
and FPGAs also have provision for sequential logic (see appendix D), but ROMs are

responsible f(
pure combinational logic. The combinational logic implemented by all ROMs and by

ticular ROM.
many FPGAs are based on truth tables without the need for expressing logic equations.
In contrast, PLAs and CPLDs are based on logic equations (sum of products) rather Another view
than truth tables. Synthesis tools automatically produce truth tables or logic equations, it implements
depending on the target technology the designer selects. the constants

ROM.

C.11.1 Read only memory
Automatic synthesis of combinational logic for functions involving more than about
sixteen bits depends on the complexity of the function. A simple function like addition
can be implemented for an arbitrarily large number of input bits with combinational
logic because the function decomposes into smaller combinational logic units, e.g., full 9 So-called Electi

which they are us
adders in the case of addition. The synthesis tool is well aware of the properties of puters. In the tet
commonly used functions like addition. The decomposition of more complicated func- EEPROMs are he
tions (whose properties are not built into the synthesis tool) is often less obvious. Syn- under the control

thesis tools explore many possible implementations for the combinational logic re- not use an EEPRI
ROM, which is t(

518 Verilog Digital Computer Design: Algorithms into Hardware



I

quested by the designer, however; as the number of input bits increases, the number of
design alternatives grows exponentially. 

nber It becomes 
are zero. difficult for the synthesis tool to

derive the logic equations needed 
netic. for 

Priority technologies such as CPLDs. ROMs tend to be
the most practical approach for complex 

ect which functions 
one as the number of input bits grow.

This is because with ROMs, all the designer has to do is tabulate the desired behavior,
rather than find logic equations that produce that behavior. This avoids using a synthe-
sis tool that has to explore exponential possibilities.
There are several ways of describing a ROM. The usual viewpoint of the designer is
that the ROM is a black box, specialized for computing some particular function:

iational build-
ilog synthesis
r fewer bits of address R 
Yner having to contents

k n
iesis tool pro-
nable devices. Figure C-41. Symbolfor a Read Only Memory (ROM).

nown as pro-
[ot require hu-

The number 
nean the same of input bits, k, and output bits, n, need not be the same, although often

k==n. 
confused The input 

with bus to the ROM is known as the address. The output bus of the ROM
is known 

same as 
thing the contents. 

as This address and contents terminology is borrowed from
memory systems (section 8.2.2.3.1). However, such a ROM is not truly a "memory"
because once a value is burned into a ROM, it cannot be changed.'

programmable
Normally, 

ices the 
(CPLDs), designer will indicate more than just the word "ROM" inside the box,

since 
OMs).CPLDs the ROM could be programmed to implement any function. For instance, the

designer 
but might 

ROMs need 
are a "square root ROM," or something like that. The designer is then

responsible for providing 
ROMs and by a table of the contents that need to be burned into that par-

ticular ROM.
)gic equations.
:oducts) rather Another viewpoint of the ROM is to describe it in terms of the combinational logic that
)gic equations, it implements. A ROM is simply a mux whose data inputs are connected internally to

the constants (cO, c , c2, . . cmax) that the designer has burned into the
ROM.

ore than about
Inl ike addition
combinational

9 So-called Electrically 
units, Erasable 

e.g., full Programmable ROMs (EEPROMs) are not truly ROMs when the system in
which they are used controls their erasure, such as when they are 

e properties used as memory 
of in general-purpose com-

puters. In the terminology of chapter 8, such EEPROMs are non-volatile memory with slow access time.
nplicated func- EEPROMs are however truly ROMs when their erasure is activated only by a separate development system
obvious. Syn- under the control of the designer and not the hardware being designed. Put another way, if the designer does
ional logic re- not use an EEPROM's erasure property in the design of the system itself, then the EEPROM is acting like a

ROM, which is to say, the EEPROM implements some combinational logic function.

are Appendix C 519



Read Only A
ROM ability to for

menting con
cO / 0 logic with V

n logic relative

cl / 1
n

c2 / ** contents
> 2 C.13 F

n
GAJsKI, DANI
NJ, 1997. Ch

k
cmax 0 2-1

n
PROSSER, FRA
to Top Down

O9,A-_
---- --o- 3.

k

Figure C-42. Possible implementation of a ROM.
C.14 Ed
Using the coi

C.11.2 Complex PLDs problems, giv
An alternative to using a ROM is to use a CPLD. The internal structure of a CPLD is ing block des,
too complex to describe here. A designer is seldom concerned with such details. In- preted as unsi
stead, a synthesis tool takes care of the details for the logic equations required inside C-1. Coni
the CPLD. Data

Data
Devi

C.12 Conclusions
Combinational logic is an important building block for computer design. The distin-
guishing characteristic of combinational logic is that it lacks memory: its output is a
function of its input. Common combinational building blocks include muxes, demuxes,
incrementors, shifters, adders, ALUs, comparators, encoders and decoders. Some de-
vices, such as buses and fixed position shifters, can be implemented at zero cost. Oth-
ers, such as multipliers, are quite expensive. Ideally, we model combinational logic as
a pure mathematical function having no propagation delay, but in reality, different
approaches to implementing combinational building blocks have different propagation
delays and costs.

520 Verilog Digital Computer Design: Algorithms into Hardware

A L



I

Read Only Memories (ROMs) are not actually memory because they do not have the
ability to forget. ROMs are simply a different, more convenient, approach for imple-
menting combinational logic. The use of ROMs as well as the use of programmable
logic with Verilog synthesis tools has made the design of specialized combinational
logic relatively easy.

C.13 Further reading
GAJSKI, DANIEL D., Principles of Digital Design, Prentice Hall, Upper Saddle River,
NJ, 1997. Chapter 5.

PROSSER, FRANKLIN P. and DAVID E. WINKEL, The Art of Digital Design: An Introduction
to Top Down Design, 2nd ed., Prentice Hall PTR, Englewood Cliffs, NJ, 1987. Chapter
3.

C.14 Exercises
Using the combinational logic building block devices listed in each of the following
problems, give a block diagram that implements the more complex combinational build-
ing 

re block 
of a CPLD described 

is by the data output(s). The buses in these problems should be inter-
such details. preted 

In- as unsigned binary integers.
required inside C-1. Control Inputs: CTRL (3 bits)

Data Inputs: A (32 bits), B (32 bits), C (32 bits), D (32 bits), E (32 bits)
Data Output: F (32 bits)
Devices: one 32-bit adder, one 32-bit 2-input mux, one 32-bit 4 input mux

sign. The distin- CTRL Data outputs
r: its output is a 000 F=A
nuxes, demuxes, 001 F=B

oders. Some de- 010 F=C

.t zero cost. Oth- 011 F=D

national logic as 100 F=A+E

reality, different 101 F=B+E

rent propagation 110 F=C+E
111 F=D+E

ware Appendix C 521



r

C-2. Control Inputs: CTRL (3 bits) Hii
Data Inputs: A (32 bits), B (32 bits), C (32 bits), D (32 bits), E (32 bits)

Data Output: C-7. 
F (32 Co

bits)
Devices: Da

one 32-bit adder, four 32-bit 2-input muxes
Da

CTRL Data outputs De
000 F=A
001 F=B

011 F=D
100 F=A+E
101 F=B+E
110 F=C+E
111 F=D+E

C-3. Control Inputs: CTRL (3 bits)
Data Inputs: A (32 bits), B (32 bits), C (32 bits), D (32 bits), E (32 bits) C-8. Cot

Data Output: F (32 bits) Dat
Devices: one 32-bit 8 input mux, four 32-bit incrementors. Dat

CTRL Data outouts Del
000 F=A
001 F=B
010 F=C
011 F=D
100 F=A+1
101 F=B+1
110 F=C+1
111 F=D+1

C-4. Control Inputs: none Hin
Data Inputs: A (8 bits), B (8 bits), C (8 bits) C-9. Con
Data Output: A+B+C+2 (10 bits)
Devices: Data

one 8-bit adder, one 9-bit adder
Dau

C-5. Control Inputs: none Dev
Data Inputs: A (32 bits), B (32 bits)
Data Output: max(A,B), min(A,B)
Devices: one 32-bit comparator, two 32-bit 2-input muxes

C-6. Control Inputs: none
Data Inputs: array of four unsorted 32-bit integers
Data Output: same integers in sorted order
Devices: five of the devices from problem C-5

522 Verilog Digital Computer Design: Algorithms into Hardware



Hint: This is hierarchical design. Do not draw any muxes or comparators.
, E (32 bits)

C-7. Control Inputs: CTRL (3 bits)
Data 

uxes Inputs: A (32 bits), B (32 bits), C (32 bits)
Data Outputs: D (32 bits), E (32 bits)
Devices: three 32-bit adders, one 32-bit 2 input mux, one 32-bit 8-input mux

CTRL Data outputs
000 D=A; E=A
001 D=B; E=B
010 D=C; E=O
011 D=C; E=o
100 D=A+C; E=A+C
101 D=B+C; E=B+C
110 D=A+B; E=o
111 D=A+B; E=0

, E (32 bits) C-8. Control Inputs: ALUCTRL (6 bits), CTRL(1 bit),
Data Inputs: H 

rementors. (8 bits), L (8 bits), M(8 bits)
Data Outputs: F (8 bits), G (8 bits)
Devices: two 8-bit integer ALUs (74LS 181),

one 8-bit 2 input mux
ALUCTRL CTRL Data output
100100 0 F=H+L; G=H+2*L
100100 1 F=H+M; G=H+L+M
101101 0 F=H&L; G=H&L
101101 1 F=H&M; G=H&L&M
000100 0 F=HIL; G=HIL
000100 1 F=HIM; G=HILIM

Hint: It is a theorem of Boolean algebra that L&L==L.
C-9. Control Inputs: CTRL(2 bits)

Data Inputs: X (4 bits), Y (4 bits), Z (8 bits),
Data Output: W (9 bits)
Devices: one 8-bit adder, one 4-bit multiplier, any number of 8-bit 2-input

muxes

CTRL Data output
00 w=x
01 W=X+Z
10 W=X*Y
11 w=x*Y+z

vare Appendix C 523



C-10. Control Inputs: CTRL(2 bits)
Data Inputs: X (4 bits), Y (4 bits), Z (8 bits) D. 
Data 0

Output: W (9 bits) Same as in problem C-9.
Devices: any number of adders of any width (specify), any number of shifters,
any number of 2-input muxes of any width (specify)

Although cc
Hint: With these building blocks, you need to implement the 4-bit multiplier functions in
using the shift and add algorithm for multiplication, which is analogous to the puted previc
pencil and paper algorithm for decimal multiplication: ones. Therel

algorithms.:
six times thirteen

must include
0110

* 1101 allow the ha
1

synchronous
0110 do (1) select 6

don't (0) select 18=12+6, instead pass 6
011000 do (1) select 30=24+6

+ 0110000 do (1) select 78=48+30 D.1 Sy
The term syn

01001110 product is 78 a single sign;
system clock
chronous bui

sysc

Figure D

This connect
quential devi(
to mean the s

FigureD -

524 Verilog Digital Computer Design: Algorithms into Hardware



D. SEQUENTIAL LOGIC
nber of shifters, BUILDING BLOCKS

Although combinational logic (appendix C) is useful for implementing mathematical
4-bit multiplier functions in hardware, combinational logic has no memory of values that were com-
malogous to the puted previously. Most practical algorithms make use of old values to compute new

ones. Therefore, combinational logic by itself is insufficient to implement interesting
algorithms. In addition to combinational logic building blocks, interesting machines
must include sequential logic building blocks, commonly referred to as registers, that
allow the hardware to remember old values. This appendix reviews several important
synchronous sequential logic building blocks.

D.1 System clock
The term synchronous means that all of the sequential building blocks are connected to
a single signal, known as the system clock or sysclk for short. The place where the
system clock is connected is shown as a wedge in the lower-left corner of each syn-
chronous building block:

synchronous synchronous
sequential sequential

v device 1 r device 2

sysclk 

Figure D-l. Universal connection to system clock signal shown.

This connection need not be drawn because it is understood that all synchronous se-
quential devices connect to this same signal. For example, the following is understood
to mean the same as the above:

synchronous synchronous
sequential sequential
device 1 device 2

Figure D-2. Universal connection to system clock signal assumed.

ware Appendix D 525



D.2 Timing Diagrams In the case
To describe the behavior of sequential logic, it is often helpful to use timing diagrams. time into e(
A timing diagram plots values against time. For single-bit signals, like sysclk, this
plot appears similar to some kind of graph you might have drawn in an algebra class.
The concept of a timing diagram originated with the display produced by an oscillo- sysclk
scope. Computers operate at speeds too fast to be observed by the unaided eye. When
testing (or repairing) an actual physical computer, a computer designer needs some
kind of test equipment to observe signals inside the computer down to a time resolution
of about a nanosecond. The oscilloscope is a kind of test equipment that plots voltage
versus time on a phosphor screen. The earliest electronic computer designers half a
century ago used primitive oscilloscopes, and modem versions Figure 

of oscilloscopes are
still used by computer designers today.1 For example, if you were to connect an oscil-
loscope to the sysclk signal, you might see: Each clock

sequential I
I .l1 1I. 

uniding Ol

\.r-- D.3 So

Figure D-3. An analog waveform for the system clock signal. Synchronou
in a timing 

which shows how the analog voltage (vertical axis) on the sysclk wire varies with example, in
time (horizontal axis). Physical properties, like capacitance and inductance, affect the algorithm:
ragged shape of the analog voltage shown on the oscilloscope. Computer designers are
not concerned with analog voltages, and so this rather messy physical reality is ab-
stracted to an idealized square wave: data

sys
SYSCIK -

Figure D-4. A digital abstraction of the system clock signal.

Figure D
Such a square wave is not physically possible; however, as explained in section C. 1. 1,
computer designers often use models of reality that are physically unrealistic because
such simplified The 

models above 
emphasize i

only those things which are algorithmically impor-
tant. only at the ri

later than th
used to gene

l Computer designers now often use more sophisticated kinds of test equipment.

526 Verilog Digital Computer Design:A lgorithms into Hardware



r

In the case of the sysclk signal, the only thing that is important is that it subdivides
fing diagrams. time into equal-sized intervals, known as clock periods or clock cycles:
sysclk, this
algebra class.

by an oscillo- syscfk
led eye. When
,r needs some
ime resolution I 4 - first clock cycle second clock cycle -

tp lots voltage
signers half a
illoscopes are Figure D-5. The system clock divides time into cycles.
mect an oscil-

Each clock period begins and ends on the rising edge of sysclk. (Some kinds of
sequential logic use the falling edge; however in this book all synchronous sequential
building blocks use the rising edge.)

D.3 Synchronous Logic

Synchronous logic is a restriction on physical reality where changes in the values shown
in a timing diagram occur only at the exact instant of the rising edge of sysclk. For

re varies with example, in the following timing diagram, one bit of data is being manipulated by an
ace, affect the algorithm:
designers are
reality is ab-

data

l

l

sysclk

Figure D-6. An ideal synchronous timing diagram.
;ection C.1 .1 ,
listic because

The above is 
ically a 

impor- valid synchronous timing diagram because the changes in data occur
only at the rising edge of sysc 1k. In physical reality, the changes in data occur slightly
later than the actual instant of the rising edge due to propagation delay of the circuits
used to generate the data signal:

Appendix D 527



signer wants
data a variable, v

on a timing
v[1] -

v[O] _

sysclk sysclk J
Figure D-7. A realistic synchronous timing diagram with propagationd elay. Figure D.

but as discussed in section C. 1.1 , we normally ignore propagation delay. At the begin-
ning of the design process, However 

the de;
primary concern of the designer is getting the algorithm

right. Worrying show 
about the 

physical nut
reality is a distraction from the designer's most impor-

tant mission-ensuring that the algorithm is correct.

v C
The following diagram is not synchronous. It is known as asynchronous because the sysclk S
data pulse might occur at any time with respect to syscik: FigureD -

data
In timing dia;

sysclk
Figure D-8. An asynchronous timing diagram. Figure D-.

With only one exception that happens when a machine is first turned on (described in shows the ins
sections 4.4.5 and 7.1.6), we will not use such asynchronous logic. of the bus cha

Synchronous value 
design of the 

is safe b
and easy. Asynchronous design is hard and dangerous.

Commercial synthesis tools concentrate on synchronous design. Therefore, synchro-
nous design is widely used in industry.

D.5 Thf
The simplest

D.4 Bus timing diagrams
Digital computers represent values other than zero and one using a group of bits on a
bus with the binary number din -

system. The physical reality is that each wire in a bus
represents a separate bit of information. But from an algorithmic viewpoint, the de-

Figure D-1

528 Verilog Digital Computer Design: Algorithms into Hardware

L



signer wants to look at the bus as containing a single binary value. Suppose the value of
a variable, v, goes through the sequence 0, 1, 2, 3, 0, 1, 2, 3, 0 .... This could be shown
on a timing diagram as two separate bits that change synchronously with sysclk:

v[1 ] 

v[O]
sysclk

pid elay. FigureD -9. Timing diagram showing individual bits of a bus.

At the begin- However dealing with separate bits is quite 
the tedious. 

algorithm Instead timing diagrams usually
show the numeric value of the complete bus during 

most each 
impor- clock cycle:

V

because the sysclk 
Figure D-10. Timing diagram showing numeric values on a bus in decimal.

In timing diagrams, the notation shown in figure D- 11:

Figure D-1J. Notation usedfor bus timing diagrams.

(described in shows the instant in time (a particular rising edge of syscik) when the numeric value
of the bus changes. It is only necessary for one bit of the bus to change for the numeric
value of the bus to be completely different.

d dangerous.
)re, synchro-

D.5 The D-type register
The simplest sequential building block is the D-type (or delay type) register:

of bits on a din D dout
vire in a bus n register fl
point, the de-

FigureD -12. Symbol for D-type register.

Appendix D 529

A



-

Some people refer to din as the D input and dout as the Q output. When n=l, this
device is referred to The 

as reason'
a D-flip flop. In fact, an n-bit D-type register is usually built

from n D-type flip the 
flops. D-type r

have variab]
In the D-type register, dout is simply a delayed version of din. Put another way, more sophis
dout in the present clock cycle is the same as din in the previous clock cycle. Sup-
pose that din just happens to be going through the binary sequence:

D.6 En
Algorithms,

din out this bool
moments in

dout vast majorit3
sysclk variables do

register buil
FigureD -13. Example timing diagramf or D-type register. well as beinE

capability is
dout will also go through the same sequence, but it will lag by one clock cycle. In the In order to a]
above, x means unknown (see section 3.5.3 for details on how bx is used in Verilog abled register
simulation), because there is not enough information to predict what is in the register at load signal o
the beginning. ated with a no
As another example, consider what happens when din is somewhat more random:

din

dout

sysclk Figure D-i

Figure D-14. Another timing diagramf or D-type register.
The followin
input:

I ne D-type register is not used by itself in computer design very often. The two most
common uses of the D-type register are synchronizers and the present state register for
controllers (see sections 2.4.1 and 7.1.1).
All of the more useful registers described below can be constructed from a simple D-
type register combined with combinational logic, but it is often not helpful to think of
things that way. It is usually better to think in terms of one of the more sophisticated An action table
building blocks described below. On the other hand, D-type registers together with the concept of
specialized logic are often included in designs created by synthesis tools (see section
D.11).

530 Verilog Digital Computer Design: Algorithms into Hardware

JI I



When n=l, this The reason the D-type 
is register 

usually built by itself is often inadequate for many problems is that
the D-type register only remembers the old value for one clock cycle. Most algorithms
have variables that must remain unchanged for multiple clock cycles. This requires a

it another way, more sophisticated kind of register, discussed in the next section.
)ck cycle. Sup-

D.6 Enabled D-type register
Algorithms are the starting point for the hardware design approach described through-
out this book. Algorithms are composed of steps that manipulate variables at certain

DCD moments in time. The rising clock edge determines when those moments occur. The
vast majority of algorithms manipulate their variables in complicated ways, so that the

LJL variables do not change at every rising clock edge. For this reason, we need a kind of
register building block that can hold its former contents for multiple clock cycles as
well as being able to load itself with new contents. The building block that has such a
capability is known as an enabled D-type register, or just simply an enabled register.

ck cycle. In the In order to allow the designer to choose between these two different 
used actions, 

in Verilog the en-
abled register has a command input. This command input is sometimes 

n the register known as 
at the

load signal or the enable signal. In this book, this command input is typically abbrevi-
ated with a name like d.

ore random:
Id

TDQD
enabled

din 1 0 register cdlopu t
n > n

AL Figure D-15. Symbolfor enabled D-type register

The following action table describes what the enabled register does based on the d
input:

The two most
ate register for

ima  simple D-
pful to think of

eso phisticated An action table is not a truth table, because unlike a truth table, an action table includes
together with the concept of time.

)Is( see section

ire
Appendix D 531



- r_

For example, suppose the following din and ld signals are provided to an enabled In the TTL
register: ment the sai

-

din 3 2 0 YTXTX -0-Y- I)
_ D.7 Uj

la [ JII I

When comb
implement a

dout ( == ° )(3= these operat
sysclk own right. I

n
within itself

Figure D-16. Example timing diagramf or enabled D-type register
Perhaps the
include step!

In this example, d happens to be 0 at certain times when dout happens to be 3. This with digital
means in the clock cycle after ld is 0, dout will continue to hold the value 3, regard- particles for
less of what din happens to be. On the other hand, when id is 1, the enabled register lions of cour
acts just like a simple D-type register.

There are m,
only on the to

The enabled register can be counter 
implemented (desc

as a mux connected to a simple D-type regis-
ter: (described in

up/down cou
means the sy

The up count
dout in an enabled

the next risin
din as the inc c

the clock.

Id
Figure D-l 7. Implementation of enabled D-type register using simple D-type
and mux.

When ld is 0, the mux passes through the old value of dout to be reloaded into the
simple D-type register. When ld is 1, the mux passes through the new din value to be
loaded into the simple D-type register.

Figure D-.
Other arrangements of hardware not based on the simple D-type register can also imple-
ment an enabled register. Therefore, in the top-down approach, designers typically
specify an enabled (or loadable) register without concern for how it is implemented.

2 Except ld is ac
chip.

532 Verilog Digital Computer Design: Algorithms into Hardware

4



)a n enabled In the TTL logic family, the 74xx377 (for n=8) and 74xxx33778  ((fforr  n=6))  chiips  iimplle--
ment the same actions as the above.'

XD D.7 Up counter register
WI the n clDo.m7c~ kb~tli on gedi~c  w~i~th  combin~atviorna lc elorgaic , rttehge i setnaelar  bolpede rDa--*-tty-ytpypepe e r egister is suffffiiciientt  to
implement any

implem~ ae lgor
nt ~ith m, however, certain register operatitIa imleenato asosietqmu e ioonnss  occur  so  ffrrequenttlly  tthatt

these operations deserve special implementation as sequenIitial  building blocks  iin  ttheir

ED own right. The distinguishing characteristic of these operatitttiiionss  iis  tthatt  tthe  rregiistterr  hass
within ittsh~ee lsfe a l~l  the~ in fo~rm at~io n tnhesce sssapreyc itaol oponepr eforartmio nt he isooeppeerraattiion. ..

ownTr ihgeh d. itinguis ing. Infctevris
Perhapsw tihteh~ imn  ost i~m port~an t ofn tnheWse islpimeci ali noe1pl 9e3ra2t iownass  ias, nc coooumunnttiotning.g . Mostt  allgorriitthms
include steps

Perha~ t
p hat in
s ~v olve~  counting. In fact, the very first practical 

en codute bysL ordtRanu t  machiine  ever  buiilltt
taod ebde  i3nt.o T hthise with digital electronics (by Wynn-Williams in 1932) was a 

isntcpluse t ht inolve ccoouuntter  used  tto  countt  alllpha
c ated

ue 3, regard- particles for a physics experiment conducted by Lord Ruthtiheerrfforrd..  Siince  tthatt  ttiimee,,  biill--
bled register lions of counters have been fabricated.

There arl~eio  mnsa n~y  va~ria tio~ns  o~n  hokwi dto  boufi cldo uan cteorusn: tetrh. eIens  ytnhfisa  book, we will concentrate
only on Tth~ee  rtwe ~o  mo~st  im~p ortantn )k ianndds tohfe cyso yunnctherosn: ous 

igrhe the synchronous
D-18 load

l ogi ,
fmly thep   loadable  binary  up

counter o(dnelysc~ r ibe~d in~ th~is s~ectwion)l, anredf eth et osyet nhcehs romnooures lsomadp-aoabmbllelae   biinary  up//down  countterr
)-type regis- (describecdo uin~t  seerc ti~on  D.~8) . W~e wilhl er efethr ctrowb teoh re sec omuonrtee  siimscpMpilly  as the up counter and  the

u2mp/xdeotw ne csomu actilonsw hc as t 
up/do~nw ter, 

n ~re spe~c tive~ly . When the word counter is uised
l binaryru pspcounter.   by  iittsellf  iin  tthiis  book,,  iitt

means the synchronous loadable binary up counter.

Tchhie.7 u p cUou n corner
in~ ~t~er

r~ he~a aand
islsen t

r hree command inputs. The 
 d command

inpts Thele commal   siignall  iis  tthe  same  as  iitt  iiss
in an enabled register. T

the~~~~ ~h~e ~e  r command signal causes thhie   coun
comman signal cause tfthli tter  tto  become  zero  att

the next ris
as ~in g e~d ge ~o f t~he~ kcl ock. The count command signal

The coun command si;nl)c   (sometimes referred  tto
as the inc command 

the~~~ ~sig~na~l) acauuese s the counter to incremel,ent  att  tthe  nextt  i i   
the thccunectk.crm rising edge of

clock.

D)-iyp

dout
n value to be

Figure D-18. Symbol for up counter register.
n also imple-
iiers typically
implpelmemenentetedd..

2 Except ld is active low, which has the apparent effect of reversing the 0  and I  inside the mux of the TTrLL
chip.

Appendix D 533



The behavior of the up counter is summarized by the following action table: D.8 U
ld lr count action Some algoi
o 0 0 hold
o such algorit

o 1 increment
o has three c(

1 0 clear
o 1 1 ters. 

clear The c(
1 0 0 load next rising
1 0 1 load count is]
1 1 0 load ments.
1 1 1 load

Note that the d signal has a higher priority than cr and count. Also cr has a
higher priority than count. An up counter can be constructed from a simple D-type
register, three muxes and an incrementor:

din

FigureD 

The behavic

dout

FigureD -19. Implementation of up counter register using simple D-type
register and combinationall ogic.

Recall that the combinational logic incrementor (section C.5. 1) is considerably faster
than an adder. Even so, there are other more efficient ways of constructing a counter
than the technique shown above. For example, in the TTL logic family, the 74xx163 An up/down
chip provides for n=4 the same actions3 as the above using fewer gates and less propa- combination
gation delay.

3Except that cr and ld are active low.

534 Verilog Digital Computer Design: Algorithms into Hardware

I



able: D.8 Up/down counter
Some algorithms involve both incrementing and decrementing the same variable. For
such algorithms, the use of an up/down counter may be appropriate. The up/down counter
has three command inputs. The ld command signal is the same as in the earlier regis-
ters. The count command signal causes the counter to increment or decrement at the
next rising edge of the clock, depending on the up command signal. If up is 1 when
count is 1, the counter increments. If up is 0 when count is 1, the counter decre-
ments.

ISOsco lr has a
count

sSiim]ppllee D-type
Id up

up/down
din / > counter dout

n >n

Figure D-20. Symbolfor up/down counter register

The behavior of the up/down counter is summarized by the following action table:

dout
I n id u p action

o 0 0 hold
o 0 1 hold
o 1 0 decrement
o 1 1 increment
1 0 0 load
1 0 1 load
1 1 0 load
1 1 1 load

siderably faster
cting a counter
.y, the 74xx163 An up/down counter can be constructed from a simple D-type register, two muxes, a
and less propa- combinational logic incrementor and a combinational logic decrementor:

are Appendix D 535



In addition
register has
shift registe

rsi -
Isi -

din -
Ed out

Figure D

Figure D-21. Implementation of up/down counter register The one-bi
(shi ftct
of dout for

There are other ways of constructing this than the technique shown above. For ex- shifting left
ample, in the TTL logic family, the 74xx669 chip provides for n=4 the same actions as significant b
the above using fewer gates and less propagation delay.

This can be
D.9 Shift register simple D-tyl

Like counting, multiplication and division by two, as well as the related operations of
rotation, can be implemented within a specialized device. Shift registers are sequential
building blocks that implement these operations internally. There are many kinds of
shift registers. The kind used in this book is a synchronous parallel loadable left/right rsi
shift register, with left and right shift (serial) inputs. This device is referred to simply as
a shift register in this book.

The shift register has a ci r signal (similar to the up counter) and a two-bit shi f tctrl Isi
signal. The action table for this shift register is:

cr shiftctrl action
o 00 hold din /
o 01 r

right
o 10 left shiftctrl -
o 11 load
1 00 zero
1 01 zero Figure D-:
1 10 zero
1 11 zero

536 Verilog Digital Computer Design: Algorithms into Hardware



I

In addition to the n-bit-wide din bus that all synchronous registers have, the shift
register has two inputs, rs i and 1s i, each one bit wide, that only play a role when the
shift register is shifting:

rsi
Isi

din dout
am) dout
n

I n Figure D-22. Symbol for shift register

The one-bit input rsi is ignored except when the register is shifting right
(shi f tctrl=01), in which case rs i determines the value of the most significant bit
of dout for the next clock cycle. Similarly, 1si is ignored 

abov except 
i when the register 
ve.e . For ex- is

shifting left (shiftctrl=10), in which case si determines 
same the 

( value of the 
e a ctions least

as significant bit of dout for the next clock cycle.

This can be implemented using two combinational logic shifters, two muxes and a
simple D-type register.

ed orperations of
rs are Ssequueenntitaial l
, mani nyy kinds of
adablele  left/right
rred toto s imply as

bit slhLif tctrl

dout

Figure D-23. Implementation of shift register

rare
Appendix D 537



Recall that the combinational logic shifters do not cost anything. There are other ways It is import/
of constructing this than the technique shown above. For example, in the TTL logic diagram. A,
family, the 74xx194 chip provides for n=4 the same actions4 as the above using fewer automated n
gates and less propagation delay. ing of how d

by designers

The guiding
D.10 Unused inputs the thoughts
Sometimes a designer needs more capability than an enabled register, but not as much the circuit di
as is offered by one of the other register building blocks described above. For example, zero, it is eaw
a designer may need a register that omits any one of the three command inputs of an up detail. Desig
counter:

Id count count
cir Id

cIr d
enable
lear dout non- non-

din c
n register n din clear dout load -**dout

n counter n counter n FigureD -

FigureD -24. Symbols for other registers. is as:

The register on the left omits the count signal and is therefore not truly a counter. The
register on the left is known as a enabled clearable register. The register in the middle is
a counter that does not ever need to be cleared but that instead is loaded with din. The
register on the right is a counter that never has to be loaded and therefore does not need
a din bus.

Figure D-,
All three of these are specializations of the up counter described in section D.7. They
can be implemented by tying one of the three command inputs of an up counter to 0:

although ther
0 count count diagram with

dr Id | Idm  i cir solved. This i
up up up sysclk, gro

din c g e dout din- f& counter fdout no cue clout
n > n n n block diagran

connection n
In a similar w

FigureD -25. Implementationsf or these registers using a loadable clearable
up counter.

4 Except 5Vcc 
that cdr is active low. and ground

synchronous devi

538 Verilog Digital Computer Design: Algorithms into Hardware



e are other ways It is important to understand the 
n distinction 

the TTL logic between a block diagram and a circuit
diagram. A circuit diagram 

eove using is a detailed 
fewer description used by people (or more likely

automated manufacturing equipment) that put together a machine with no understand-
ing of how the machine was designed. A block diagram is an abstract description used
by designers as they think through various design alternatives.
The guiding philosophy for drawing block diagrams is how well the diagram describes
the thoughts of the designer. A block diagram should be as simple as possible. Even if

but not as much the circuit diagram will eventually use a counter with one of its command inputs tied to
ie. For example, zero, it is easier for designers to communicate with each other by simply omitting that
I inputs of an up detail. Designers understand that one way of implementing the following:

count
Id

count
non-

din clear dout
n count n

i dout
ntern Figure D-26. Symbolfor a non-clearableu p counter

is as:

y a counter. The
in the middle is

I with din. The din dout
re does not need

Figure D-27. 
ction Possible 

D.7. They implementation using a clearable up counter
.p counter to 0:

although there is probably a more efficient way. Rather 
count than overspecifying a block

diagram with details, the designer only shows what is essential to the problem being
solved. This is the same philosophical reason why we omit drawing the connection to
sysclk, ground 

-Ad*o ut and Vcc: we know they have to be there,5 and so why clutter the
n block diagram with a detail that adds nothing to our understanding?

In a similar way, it is common to use a shift register that never needs to be cleared:
clearable

5 Vcc and ground supply power to a chip. The chip will not operate without these connections. Likewise,
synchronous devices will not operate without a connection to sysclk.

are Appendix D 539



-

r

the buildin
those build
their partic

rsi From a the
register, wl

Isi approach tr
computer n

din dout but such an

The buildin
Figure D-28. Symbol for a non-clearables hift register They are a

74xx 194) s
designers. 
may someti
sophisticates
blocks give

This can be implemented as:

D.12 F
GmJsm, DAN

rsi NJ, 1997. Cl

PROSSER, FRY
Isi to Top Down

4.
din dout

Figure D-29. Possible implementation using a clearable shift register D.13 E:
D-1. Comple
register with

D.11 Highly specialized registers sysclk -
The registers shown above are but a small sample of the ones that are theoretically
possible. A designer can create a specialized building block just for a particular prob- Id
lem if the value of dout in the next clock cycle can usually be computed as a combi-
national function of the current dout. As with the registers shown above, such special- din C
ized building blocks are typically implemented with a simple D-type register com-
bined with muxes and other combinational logic. With the introduction of Verilog syn-
thesis tools in the mid 1990s, designers may start conceptualizing a problem in terms of

540 Verilog Digital Computer Design: Algorithms into Hardware

L
I



the building blocks given in earlier sections, only to have the synthesis tool convert
those building blocks into some more efficient specialized one which is specific to
their particular algorithm.

From a theoretical viewpoint, every computer can be thought of as a single very big
register, whose value is meaningless to the human mind. In essence, this theoretical
approach treats this one register as the concatenation of every piece of information the
computer needs to remember. Mathematicians like to conceptualize things this way,
but such an approach is an oversimplification that does not help a practical designer.
The building blocks given earlier are at the right level of abstraction for practical use.
They are available as isolated chips (74xx377, 74xx378, 74xx163, 74xx669 and
74xx194) suitable for laboratory experiments which build the confidence of novice
designers. They are commonly used by synthesis tools, even though synthesis tools
may sometimes do something more sophisticated. In order to understand the more
sophisticated things that synthesis tools do, one must already be familiar with the building
blocks given in the earlier sections of this appendix.

D.12 Further Reading
GAJSKI, DANIEL D., Principles of Digital Design, Prentice Hall, Upper Saddle River,
NJ, 1997. Chapter 6.

PROSSER, FRANKLIN P. and DAVID E. WINKEL, The Art of DigitalD esign: An Introduction
to Top Down Design, 2nd ed., Prentice Hall PTR, Englewood Cliffs, NJ, 1987. Chapter
4.

Ir D.13 Exercises
D-1. Complete the following timing diagram to show dout, given an enabled
register with a 4-bit din, and a control input d:

sysclk
e theoretically Id
articular prob-
ed as a combi-
~ din 5 

s,u ch special- 3 1
register corn-
f Verilog syn-

lem in terms of

Ire Appendix D 541



D-2. Complete the following timing diagram to show dout, given a shift register
with a 4-bit din, a 2-bit control input shf and inputs cir, rsi and isi: E.

sysclk A tri-state d
cir m to disconnec

nected. For
shf[O] throughout r
shf[1] chips do. Th

uses for then
.

rsi

Isi

din 7 5 3A 2 E.1 Sw
As explained
each other. T

D-3. Complete the following timing diagram to show dout, given an up counter gate (such as
register with a 4-bit din, and control inputs cir, ld and inc: computer de!

gate operates
sysclk to understanc
clr Each non-tri-
Id as transistors

upon the tech
inc output is part
din (7 X XS 3  . ' I , filament of a

the voltage at

D-4. Complete the following timing diagram to show dout, given an up/down
counter register with a 4-bit din, and control inputs count, ld and up: a

sysclk
Id Figure E-1. A

count
up Saying that th

filament of an
din 7 5 3 tor), the volta,

the light does
on because th

542 Verilog Digital Computer Design: Algorithms into Hardware

A



lift register
Lsi: E. TRI-STATE DEVICES
VLL_ A tri-state device is a special kind of combinational building block that has the ability

to disconnect its output logically from the bus to which that output is physically con-
nected. For simplicity, the combinational devices defined in appendix C and used

F_1h throughout most of this book do not have tri-state capabilities, although many actual
chips do. This appendix describes what tri-state devices are, and shows two common
uses for them.

E.1 Switches
As explained in section C.2. 1, a bus is composed of several wires that run in parallel to
each other. The bit transmitted on each wire of the bus 

ap counter originates at the output of some
gate (such as an AND gate), and is received at the input(s) of other gate(s). Although
computer designers normally prefer to abstract away the electronic details of how a
gate operates, some understanding of how a non-tri-state 

FLF-L- device operates is necessary
to understand the extra feature provided by a tri-state device.
Each non-tri-state gate is actually composed of several simpler switching devices, such
as transistors. Although the details in the operation of these switching devices depend
upon the technology family used (CMOS, TTL, etc.), the effect they have on the gate's
output is partly analogous to the effect that a wall switch has on the voltage across the
filament of a light bulb. When the wall switch is open, the light is turned off because
the voltage at point a is independent of the voltage at point b:

up/down
LFL a b /

Figure E-1. An open switch causes a light to be off.

J1-1 )1

Saying that the switch is open is the same as saying a is disconnected from b. Since the
filament of an ordinary light bulb is really just a wire that is a poor conductor (a resis-
tor), the voltage at b will be the same as at c. For this reason, the filament is cool, and
the light does not shine. On the other hand, when the switch is closed, the light is turned
on because the voltage at a is identical to the voltage at b.

are Appendix E 543



T7

A non-tri-sta
"O" switch cl

E.1.2 Us,
The electroni
state gate all(

Figure E-2. A closed switch causes the light to be on.

1
Saying that the switch is closed is the same as saying a is connected to b.

0
E.1.1 Use of switches in non-tri-state gates
Non-tri-state gates are more complicated than light switches in two ways. First, the Figure E-.
gate has to compute the desired output bit (which may require switching devices not
described here). Second, the gate has to connect the output wire to the proper voltage.

The output a
In most technologies, connecting the output wire to the proper voltage requires two answer. The,
switches: the top switch connects the output wire to the voltage' for the bit 1, and the be determine
bottom switch connects the output wire to the voltage2 for the bit 0. For example, the output bit
suppose the gate needs to output the bit 0. To do this, the "1," switch is open and the "O"
switch is closed:

1 E.2 Sin
A tri-state ga

Figure E-3. A gate producing 0 as output. in -

The only other possibility for a non-tri-state gate is that the gate needs to output the bit
1. To do this, the "1" switch is closed and the "" switch is open:

Figure E-/

The behaviot

i E A 1

FigureE -4. A gate producing I as output.

' For active high 1TL, volts.
3 Hence the narn

2 For active high TIL, 0 volts.

544 Verilog Digital Computer Design: Algorithms into Hardware



A non-tri-state gate is always in one of these two configuration ("1" switch open and
"O" switch closed or vice versa).

E.1.2 Use of switches in tri-state gates
VC The electronic distinction between a non-tri-state gate and a tri-state gate is that a tri-

state gate allows a third configuration' (both the "1" switch and the "" switch open):

b.
0 -1 + Z

0
I

iays. First, the Figure E-5. A gate producing z as output.
ng devices not
)roper voltage.

The output wire is logically disconnected from the part of the gate the computes an
e requires two answer. The voltage on the output wire will not be determined by this gate (but could
e bit 1, and the be determined by some other gate). To denote this situation symbolically, we say that

For example, the output bit is z (1 bz in proper Verilog notation), which stands for high impedance.
)en and the "O"

E.2 Single bit tri-state gate in structural Verilog
A tri-state gate has two inputs, enable 

0 0 and in, and one output, out:

I 
,,, , >, out

0 output the bit
enable

Figure E-6. A tri-state gate.

The behavior of this gate can be described by the following truth table:
- 1 enable in out

0 0 z
0 1 z
1 0 0

1 1 1 1 1~~~~~~~

3 Hence the name tri-state.

Appendix E 545



P.-

In other words, the tri-state driver gate is really nothing more than an electronically takes 10 ut
controlled switch. When enable is 1, the switch is closed: and 30 unit

Also Verilo
active low 

Figure E-7. Effect of tri-state gate when enable is 1.

When enable is 0, the switch is open:

is functiona
in 4h I -u

Figure E-8. Effect of tri-state gate when enabl e is 0.

There is a Verilog built-in gate, known as bu f if 1, that implements this. For example,
the following instance:

wire out,in,enable;
bufifl bl(out,in,enable);

E.3 Bu
is equivalent to the single-bit tri-state gate shown above.

It is the com]
As described in section 6.3.4, Verilog allows you to indicate the propagation delay of a to work with
built-in gate, such as the bu f if 1: more abstrac

us to use bus
state gates si

wire out,in,enable; actions of th
bufifl #10 bl(out,in,enable); device, knov

Also, Verilog allows you to indicate different delays for the (rising) time required to
change to a one and the (falling) time required to change to a zero. For built-in gates
such as bu f i f 1, there is a third separate time that may be of interest in some designs,
the turn off delay, which is how long it takes when the output changes to 1 bz. For
example:

FigureE -

wire out,in,enable;
bufifl #(10,20,30) bl(out,in,enable);

546 Verilog Digital Computer Design: Algorithms into Hardware

L



r

lectronically takes 10 units of $time if out becomes one, 20 units of $time if out becomes zero
and 30 units of $time if out becomes 1 ' bz.
Also Verilog provides other forms of tri-state gates, such as bu f if 0, which has an

t active low enable signal. For example, the following:

wire out,in,enable,enablelow;
not il(enablelow,enable);
bufifO #(10,20,30) bl(out,in,enable-low);

is functionally identical to the above, as explained by the following:

enable low in out
o 0 0

For example, 0 1 1
1 0 z
1 1 z

E.3 Bus drivers
It is the computer designer's job to avoid details such as the ones given above. In order

ion delay of a to work with tri-state devices without having to get down to the gate level, we need a
more abstract model of what a tri-state device does. Such an abstract model will allow
us to use bus-width tri-state devices without having to be concerned with how the tri-
state gates switch on and off for each individual bit. This abstract model describes the
actions of the tri-state device in terms of a non-tri-state device connected to a special
device, known as a tri-state bus driver:

ae required to
built-in gates
some designs, non-tri-state device
to 1 ' bz. For enabln

enable
FigureE -9. Tri-state bus driver

re Appendix E 547



The symbol for a tri-state bus driver looks like a mux, except there is only one input
bus (which is n bits wide). Since a mux always has at least two input busses, there
should be no reason to confuse these two devices, both of which are symbolically
represented as triangles.

Physically, the tri-state bus driver is composed of n independent tri-state driver gates,
each one of which is physically a bu f if 1 instance. Like all other gate-level features
of Verilog, working with buf if 1 gates is not easy, and so it is better to think of an n-
bit-wide tri-state bus driver like any other bus-width building block device, using the
combinational logic modeling technique described in section 3.7.2. 1:

Figure E-
module tristate buffer(out,in,en);

parameter SIZE=1; serves the so
output out; using two in!
input in,en;
reg [SIZE-l:O] out;
wire [SIZE-l:O] in;
wire en; module si
always @(in or en) paramet
begin output

if (en 1) input i
out = in; wire ['

else if (en === 0) wire SE

out = 'bz; wire ns
else

out = 'bx; not nl(
end tristat

endmodule tristat
endmodule

The bz provides as many 1 ' bz values as is required by SIZE.

E.4.1.1 h
E.4 Uses of tri-state Section 3.5.3

of Verilog wi
There are two main uses of tri-state devices: replacement for muxes and bidirectional value 1 ' bx i!
buses. for the fourth

If it were not
E.4.1 Tri-state buffers as a mux replacement outputs of tw
The first primary use of tri-state bus drivers is to create a structure that is a replacement section E.4. 1.
for a mux. For example, the following: state buffers a

548 Verilog Digital Computer Design: Algorithms into Hardware

I



ly one input
eusses, there
Symbolically io

driver gates,
-vel features
ink of an n- ii
ce, using the

FigureE -10. Using tri-state bus drivers to form a mux.

serves the same role as a two-input mux. The above can be described in Verilog by
using two instances of the tristate_buffer defined in the last section:

module sillymux(out,iO,il,sel);
parameter SIZE=1;
output out;
input iO, il, sel;
wire [SIZE-l:0] out,iO,il;
wire sel;
wire nsel;

not n(nsel, sel);
tristatebuffer #SIZE bl(out, iO, nsel);
tristatebuffer #SIZE b2(out, il, sel);

endmodule

E.4.1.1 How Verilog processesf our-valued logic
Section 3.5.3 describes the four-valued logic (O, 1, 1 bz, 1 'bx) used for each bit
of Verilog wires and regs. The need for the binary values 0 and 1 is obvious. The

I bidirectional value 1 bx is often the result of a misconnection of gates. In this appendix, the reason
for the fourth value, 1 'bz, should now become clear.

If it were not for the high-impedance value, 1 bz, it would never make sense for the
outputs of two devices to be tied together, such as shown above in the diagram of

a replacement section E.4. 1. Because of 1 'bz,s moke does not come out of the chip when the two tri-
state buffers are wired together.

Appendix E 549

I L



There is an algorithm built into Verilog that models the physical behavior of a wire, E.4.2 I
based upon the output port(s) of instantiated modules to which that wire is con- Although 
nected. When there is only one output port connected to awire, the value of the wire hardware,:
in question reflects the value of that single-output port. When that single-output port wire remai
changes, the wire connected to it is instantaneously and automatically changed. This must be roi
is the situation that occurs throughout most of the structural examples this book.

Each bit ol
The situation is more complicated when there are two or more output ports con- One of the
nected to the same wire. In this example, the output ports of bi and b2 both drive for a chip.
the same wire. In hierarchical naming (section 3.10.8) the output ports are bl. out the pins th
and b2. out, and the wire they both drive is simply out. The following table de- ways:
scribes what Verilog computes automatically as a particular bit of the wire out, given
the corresponding bits of bl. out and b2. out:

F`
b2.out 0 1 z x

bl. out
Figure I

0 o x 0 x
1 x 1 1 x
z 0 1 z x Routing a E
x x x x x unidirectioi

If we guarantee either that every bit of either bl . out is 1 bz or that every bit of
b2. out is 1 'bz, we can be certain that no bit of out will be 1 hbx (see bold above).
This is precisely what the two tri-state drivers do for us. When sel is 1, every bit of
bl. out is tri-stated, but when sel is 0, every bit of b2 . out is tri-stated.

FigureE 

E.4.1.2 The tri declaration
Verilog provides an alternative to declaring a wire when tri-state drivers are in use, Bidirection;
known as tri. The following would also have been legal inside the declaration of 8.2.2.1).
silly-mux:

E.4.2.1
In order for

wire [SIZE-1:O] iO,il; bus must be
tri [SIZE-1:0] out;

Therefore, 
the module

The wire and tri declarations do the same thing, and so which one to use is a matter instantiated
of personal taste. ing buffer.4

4Although iti s
port could havc

550 Verilog Digital Computer Design: Algorithms into Hardware



I

r of a wire, E.4.2 Bidirectional buses
rire is con- Although most of this book assumes that a wire 
off thee wii re

is essentially 
E free in the fabricated

hardware, in fact a wire does 
~-output cost something. 
_ utput The cost 

port is fairly reasonable when the
wire remains hidden inside a physical 

hr anged. U chip, 
This but the cost is quite high when that wire

must be routed outside the chip.
s book.

Each bit of a Verilog wire that must be routed 
t ports con- outside a chip requires a physical pin.

One of the most severe limitations in hardware 
2 design 

both drive( is the number of pins available
for a chip. Therefore, hardware designers often 

are wish 
bil . out to make maximum utilization of

the pins that are available. A bidirectional bus 
ng table is one 

de- which sends information both
ways:

out, givenr

chip
SIZE

Figure E-11. One bidirectionalb us.

Routing a bidirectional bus off chip requires half the number of pins that routing two
unidirectional buses requires:

every bit of
bold above). chip SIZE
every bit o:f SIZE

4d..
Figure E-12. Two unidirectionalb uses.

-ss a re in use, Bidirectional buses are especially important in the design of memory systems (section
-clarattiionn  of 8.2.2.1).

E.4.2.1 The inout declaration
In order for a Verilog module to use a bidirectional bus, the port for the bidirectional
bus must be declared as inout. An inout port must be declared as a wire (or tri).
Therefore, an inout port cannot be directly given its value by the behavioral code of
the module in which it is declared. The inout port means the wire connecting the

;e is a matter instantiated and instantiating modules is physically tied together, without an interven-
ing buffer.4

4 Although it is not necessary, an input port could have an intervening buffer into the chip, and an output
port could have an intervening buffer out of the chip.

Appendix E 551



The algorithm Verilog uses to determine the value on an inout port combines the and here i
value outside the module together with the value inside the module, according to the
table given in section E.4. 1.1 (except the names will be at a different point in the hier- module

archy than bl . out and b2 . out). The distinction between an input port and an parar

inout port is not visible within the instantiated module (containing the inout
inout decla-

ration). This distinction is only visible within input
some other instantiating module (which

instantiates wire
the module having the inout port). wire

wire

E.4.2.2 A read/write register
enabl

To illustrate how a bidirectional bus can reduce the number of pins on a chip, consider trist
a register whose values can be read and written using a single bidirectional bus: endmodt

wr rd
Here is an

read / write b
register SIZE bus reg rl

wire [
FigureE -13. A read/write register with a bidirectionalb us.

rwreg
If this device were fabricated on a single chip, it would require 5+SIZE pins (including rw.reg

the clock and power). In comparison, the enabled register using unidirectional buses
(described in sections D.6 and 4.2.1.1) would require 4+2*SIZE pins, which is almost
twice as many.

In order for the bidirectional bus to do double duty, there must be two command inputs:
rd and wr. When rd is one, this device drives the bus (provides output) to show the
current contents of the register. When wr is one, this device leaves the bus alone ('bz)
and instead the bus provides the input which the register will load at the next rising
edge of the clock. Here is the internal structure of this register:

FigureI 

Unlike the 
-;11l -Avi 1,

will avuIu L

rird and 

Figure E-14. Implementation offigure E-13. For exampl
commands:

552 Verilog Digital Computer Design: Algorithms into Hardware



mbines the and here is how this can be described in Verilog:
rding to the
in the hier- module rw-register(bus,rd,wr,clk);

parameter SIZE = 1;
port and an

inout bus;
Lout decla- input rd,wr,clk;
dule (which wire [SIZE-l:0] bus;

wire [SIZE-l:0] do;
wire rd,wr;

enabled register #SIZE rl(bus,do,wr,clk);
ip, consider tristatebuffer #SIZE bl(bus,do,rd);
il bus: endmodule

Here is an example of using two instances of the read/write register defined above:

reg rlrd,rlwr,r2rd,r2wr;
wire [3:0] busl;

rw-register #4 rl(busl, rrd, rlwr, sysclk);
rw-register #4 r2(busl, r2rd, r2wr, sysclk);

Is( including
tional buses
.ch is almost rl wr r rd

I I
nand inputs: r1 1' , ,SZ
to show the SIZE
alone ( 'bz) r2wr r2rd

next rising I I

SIZE 1

FigureE -15. Instantiationo f two read/write registers.

Unlike the s i 1 ly mux example, there is nothing in the above to guarantee that bus 1
will avoid becoming bx. Instead, it is the responsibility of the designer to ensure that
rlrd and r2rd are never simultaneously one.

For example, to implement the register transfer rl <- r2 requires generating the
commands:

Appendix E 553



E-7. Pins an
resorted to se
with dynamii
column addr
ot rows and
address pins
guish the use

E.5 Further Reading ras is assei
PALNITKAR, S., Verilog HDL: A Guide to Digital Design and Synthesis, Prentice Hall asserted, the

PTR, Upper Saddle River, NJ, 1996. Chapter 5. signals are s
such chips al
low). The fol

E.6 Exercises
E-1. Revise the architecture of the two-state division machine (whose Verilog code is ras
given in section 4.2.3) so as to eliminate the instance of mux2 and instead use two cas
instances of the tri-statebuffer defined in section E.3. Use the test code given
in section 4.1.1.1. addr bx
E-2. Define a behavioral Verilog module (binmem) for an asynchronous bidirectional
memory (section 8.2.2.1) consisting of 4096 words, each 12-bits wide. The ports are a data
12-bit addr bus, a 12-bit data bus and the commands write and enable. The
following table describes the actions of this memory:

enable write action Writing to si
0 - data = 12'bz content is pr
1 0 data = m[addr] tural Verilog
1 1 m[addr] - data stances of the

binational lot
E-3. Show how the ASM of section 8.4.6 and the architecture of section 8.4.4 need to
be modified to work with the memory defined in problem E-2.

E-4. Define the Verilog corresponding to problem E-3.

E-5. One of the reasons why the tri-state approach is attractive for memory system
design is that it allows multiple memory modules to be connected together to form a
larger memory without the need for a mux. Using eight instances of the memory de-
fined in problem E-2 together with a decoder having a 3-bit input, give a block diagram
that implements a memory of 32,768 12-bit words.

E-6. Give the structural Verilog for problem E-5.

554 Verilog Digital Computer Design: Algorithms into Hardware



E-7. Pins are so limited in many memory packaging technologies that industry has
resorted to several contorted techniques to minimize pin count. One common approach
with dynamic memories is to transmit the address in two parts: the row address and the
column address. Internally, this makes for a square geometric arrangement consisting
of rows and columns of identical memory cells. Externally, this cuts the number of
address pins in half by (approximately) doubling the time to access a word. To distin-
guish the use of the half-size addr bus, there are two input signals: ras and cas. If
ras is asserted when cas is not, the addr bus indicates the row. When both are

entice Hall asserted, the addr bus indicates the column. For simplicity, assume ras and cas
signals are synchronous to the sysclk input which is provided to this chip. (Often
such chips are asynchronous with much stricter timing constraints than are shown be-
low). The following timing diagram illustrates reading a word from such a memory:

ras 
log code is I
ad use two cas I I
code given

addr bx row Col 'bx
[directional
ports are a data 'bz m[{rowcol}] \X 'bz

able. The

Writing to such a memory is similar, except a write signal is asserted and the new
content is provided to the chip on the data bus during the entire time. Define a struc-
tural Verilog module for a memory containing 16 twelve-t bit words using twenty in-
stances of the rwregister defined in section E.4.2.2 tog ether with additional com-
binational logic.

4.4 need to

ory system
~r to form a
nemory de-
ick diagram

Appendix E 555



r

F. TOOLS AND RESOURCES
There are several Verilog example files used in this book. There are also several design
automation software packages (tools) used with these files. In addition, there are sev-
eral information resources that may be helpful on the Internet. This appendix briefly
describes how to obtain and use these tools and resources. The details are subject to
change, and the respective Web sites should contain the most up-to-date information. F.3 M'

Documenta
from www.

F.1 Prentice Hall MACHPR(

Selected Verilog examples can be downloaded from the Prentice Hall Web site,
www.phptr.com.

F.2 VeriWell Simulator
Most of the examples in this book have been tested using the Verilog simulator from F.4 Wi
Wellspring Solutions, Inc, known as VeriWell. At the time of this writing, this excellent To build thi
software package is available at no charge by downloading it from (such as an
www.wellspring.com. The downloaded version has limits on the size of Verilog also require
source files that it accepts and does not provide graphical (timing diagram) output. The able at loca
downloaded version is available for MSDOS (command-line), Windows 95/NT (GUI), Jamesco (v
Macintosh (GUI) and several UNIX (command-line) dialects. For the command-line
versions, simply type:

F.5 e
veriwell filel.v file2.v ... The synthes

Inc. (www. 
ferent vend(

which will produce the output of $display commands both on the screen and in a M4-128/64,
file known as veriwell. log. For the GUI versions, you need to create a "project to readers ol
file" by selecting Project (Alt P) New (Alt N) and choose a name ( . prj) for the project this limited
file. Then select Project (Alt P) Add file (Alt F) to specify the . v file name(s). To run ter at their M
the simulator, select Project (Alt P) rUn (Alt U). other than ir
Most of the designs in this book are able to simulate on the free version. Wellspring etary DSL 1
Solutions sells a hardware key that removes the limitations of the free version and also requires othi
sells a separate package for graphical output: VerilogEAS

556 Verilog Digital Computer Design: Algorithms into Hardware



- I

Wellspring Solutions
ES 7 Tudor Drive, Suite 300

Salem, NH 03079
several design (603) 898-1100
here are sev-
endix briefly
ire subject to
information. F.3 M4-128/64 demoboard

Documentation for the M4-128/64 CPLD chip used in chapter 11 can be downloaded
from www. vant is .com. The demoboard, power supply, download cable and
MACHPRO software can be obtained from:

all Web site, Vantis
Box 3755
Sunnyvale, CA 94088

imulator from F.4 Wirewrap supplies
,t his excellent To build the CPU described in chapter 11 requires wirewrap wire, a wirewrap tool
ing it from (such as an "all in one" tool that strips, wraps and unwraps) and a wirewrap socket. It
;ize of Verilog also requires a memory ("RAM") chip, such as the 2102. Some of these may be avail-
n) output. The able at local electronics stores, but there are several mail-order companies, such as
95/NT (GUI), Jamesco (www. j amesco .com), that carry a complete selection of such supplies.
command-line

F.5 VerilogEASY
The synthesis package used in chapter 11, known as VerilogEASY, is sold by MINC,
Inc. (www .minc. com). VerilogEASY comes in several versions, each targeting dif-
ferent vendors' programmable logic. A limited version of VerilogEASY that targets the

;creen and in a M4- 128/64, but that is restricted on the number of inputs and outputs, will be available
eate a "project to readers of this book in the last quarter of 1998. There is no charge for downloading
lf or the project this limited version, but MINC requires that people downloading their software regis-
ame(s). To run ter at their Web site. VerilogEASY accepts the common synthesizable subset of Verilog

other than implicit style. VerilogEASY produces two output files: . s rc (in the propri-
,on. Wellspring etary DSL language) and .v (structural Verilog netlist). To fabricate working hardware
ersion and also requires other tools, described in sections F.3 and F.6. MINC also sells a full version of

VerilogEASY and an even more powerful synthesis tool, known as PLSynthesizer:

are Appendix F 557



MINC, Inc. Each modu
6755 Earl Drive given in a 
Colorado Springs, CO 80918-1039 reset), th
(719) 590-1155
info~minc .com

vi
vi
vi

F.6 PLDesigner
The place and route tool used in this book for CPLDs, such as the Vantis M4-128/64, is s_
known as PLDesigner. It runs on Windows 95/NT. It is not possible to fabricate a sT

design for the M4-128/64 without using this tool. PLDesigner can be purchased tm]
from

MINC. The following jo
directions apply to PLDesigner: At the PLDesigner menu, choose ff

File (Alt F) Open (Alt O), and enter the name of the . src file created by VerilogEASY qu,
Do a File (Alt F) eXit (Alt X). Select Device (Alt D) Parameters (P) and choose the re;
M4-128/64 (MACH445) and say OK. Select Settings (Alt ) Options (Alt 0) and be sy
sure Timing Models are set only to generic Verilog. Select Project (alt P) Build all (Alt r@(l
B) to create the JEDEC file (. j 1). To create the back annotated Verilog, select Project nei
(Alt P) Generate Timing Model (Alt T), which will put the . v file in a model (I

subdirectory (since a similarly named .v file (the input to VerilogEASY) will already -r(

exist). vit

The other na

F.7 VITO the temporal
are not allov

The Verilog Implicit To One hot (VITO) preprocessor is a freely available synthesis
preprocessor written by James D. Shuler and Mark G. Arnold. It may be down-
loaded from the Prenticite Hall Web site. It can also be downloaded from
www. cs .brockport .edu/-jshulerorplum.uwyo . edu/-vito.UNIXand F.8 Op
MSDOS versions are available at those Web sites. The theory of how this tool operates The indepen(
is discussed in chapter 7. It is a command-line program, and the following is a typical as Open Ver
use: tional Verilo

Convention 
I I~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~so~~u~r~c~e~ f~o~r~ ~q~t~

I vito -t implicit.v >explicit.v

where implicit . v is the name of a file consisting of one or more modules that have
implicit style state machines. The - t option generates comments that explain the trans-
formation. The output of VITO is redirected to another file (explicit v), which
would then be used as the input to VerilogEASY (or another synthesis tool). The de-
signer is free to choose other file names.

558 Verilog Digital Computer Design: Algorithms into Hardware



Each module must include a sysclk and reset port. The names of these are also
given in a special file known as vito. rc. For the M4-128/64 (with its active low
reset), the vito. rc file should contain:

vito. out
vito. stmt
vito.arch

14-128/64, is s_
sT-

)f abricate a tmp_
-chased from join_
nenu, choose iff
erilogEASY qual_
d choose the reset
it 0) and be sysclk

Build all (Alt @(posedge sysclk)

elect Project new_

in a model @(posedge sysclk or negedge reset)
-reset

will already vito.tail

The other names in this file are the prefixes of wire names that VITO will generate, and
the temporary files VITO uses. This file is based on position, and so extra blank lines
are not allowed.

ble synthesis
iy be down-
oaded from
o. UNIX and F.8 Open Verilog International (OVI)
tool operates The independent organization that developed the Verilog standard (IEEE 1364) is known
g is a typical as Open Verilog International (www. ovi .org). OVI is co-sponsor of the Interna-

tional Verilog Conference (www. hdlcon. org) held each spring at the Santa Clara
Convention Center. OVI sells a language reference manual, which is the authoritative
source for questions of Verilog syntax and semantics:

Open Verilog International
15466 Los Gatos Blvd.

iles that have Suite 109-071
lain the trans- Los Gatos, CA 95032
t . v), which (408) 353-8899
ool). The de- ovi@netcom.com

Appendix F 559

L



F.9 Other Verilog and programmable logic vendors
Here is a partial list of other Verilog and vendors' Web sites: www. altera.com, G.
www.avanticorp.com,www.cadence.com,www.fintronic.com,
www.sunburst-design.com,www.synopsys.com,www.simucad.com,
www.synplicity.com,www.veribest.com,www.xilinx.com and
www.eg.bucknell.edu/-cs320/1995-fall/verilog-manual.html. 1. Effic

The founda
there are tv
The ARM i

F.10 PDP-8 are powerft
Additional resources relating to the PDP-8 can be found at strawberry. uwyo. edu, because of 
www. in.net/-bstern/PDP8/pdp8.html,www. faqs.org/faqs/dec-fac so easily the
and www. cs. uiowa.edu/-jones/pdp8. A portion of this information is also high speed.
available at the Prentice Hall website. In general

nature - yet.
is significan

F.11 ARM sion, ARM 

Additional resources relating to the ARM can be found at www. arm. com. Features of

* Asi
* Cor

Features im]

* Ban
pen

* Con
* Loa

tran

2. Instri
The ARM ir
languages.1
forward and
is flat and thi
RISC proces
two instructi
ARM Code ]
code.

ARM documei

560 Verilog Digital Computer Design: Algorithms into Hardware



vendors
w.altera.com, G. ARM INSTRUCTIONS'
ntronic.com,
.simucad.com,
ilinx.com and 1. Efficient instruction set
-manual.html. The foundation of all processor architectures is the instruction set. When designing it

there are two contradictory aims: high code density and easy instruction decoding.
The ARM instruction set strikes an optimal balance between these. The instructions
are powerful so programs in ARM are short, saving memory and speeding execution
because of reduced bus bandwidth requirements. Yet because the instructions decode

rry.uwyo.edu,
so easily the ARM processor is small and cheap, consumes very little power and runs at

/faqs/dec-fac
high speed.

information is also
In general RISC processors code less densely than CISCs because of their very
nature - yet ARM code is generally as dense as code for 32-bit CISC processors, which
is significantly better than other 32-bit RISC processors. With the 16-bit Thumb exten-
sion, ARM code density is the best in the business.

-m.com. Features of the ARM fundamental to easy decoding include:

* A small number of highly flexible instruction types
* Consistent instruction data formats

Features implemented for high code density include:

* Barrel shifter to perform arbitrary shifts within the same cycle, at no speed
penalty

* Conditional execution on every instruction to eliminate many branches
* Load and store multiple instructions for rapid context switching and memory

transfer

2. Instruction set summary
The ARM instruction set is a good target for compilers of many different high-level
languages. Where required, though, assembly code programming in ARM is straight-
forward and enjoyable. The instructions are flexible and orthogonal, the memory model
is flat and there are no complicated instruction interdependencies as there are for some
RISC processors. Because a whole line of C code can often be performed within one or
two instructions, the instructions correspond closely to natural program steps. See the
ARM Code Examples which demonstrate the true power and magic of ARM machine
code.

ARM documentation is copyright 1997 Advanced RISC Machines, Ltd. and is reprinted by permission.

ardware Appendix G 561

A



F

The ARM7 instruction set comprises 10 basic instruction types
* Two of these make use of the on-chip arithmetic logic unit, barrel shifter and User,'

multiplier to perform high-speed operations on the data in the 16 visible 32-bit RO
registers. R[

* three classes of instruction control the transfer of data between main memory
and the register bank, one optimized for flexibility of addressing, R2

another for R3
rapid context switching and the third for managing semaphores.

* two instructions control the flow and privilege level of execution. R4
* three types of instruction are dedicated to the control of external coprocessors R5

which allow the functionality of the instruction set to be extended in an open R6
and uniform way.

R7
The ARM7 instruction set is summarised in the table below: R8

In structi Instruction bit format, 31 ...0 BL9
IData Processing I J Ojpcode R [d Operand 2 ]
Multiply R1 | R11
Single Data Swa con l FT6gPFR 10FRdI | Rm I

[Single Data Transfer co ] jm PEEj[Rd K IR12
Offset 

[Undefined Icon 11 11 Xxxx IN I113

[Block Data Transfer con E Register List
[Branch co §j loff set l CRP1S5( RPC
Copro Data Transfer con R O Offset =E-
Copro Data Operation |Ip 3jEjIRPj R0  cP OP IC-R-3m 
Co ro Regester Transfer CP POPj EEMj-JN Oml
[Software Interrupt ||EN NM Ignored by processor More comp]

Register Model
The processor has a total of 37 registers made up of 31 general 32 bit registers and 6
status registers. At any one time 16 general registers (RO to R5) and one or two status
registers are visible to the programmer. The visible registers depend on the processor
mode and the other registers (the banked registers) are switched in to support rapid
interrupt response and context switching.
Below is a list of the visible registers for each of the processor modes. The banked
registers are in italics.

562 Verilog Digital Computer Design: Algorithms into Hardware



I
F

User32 FIQ32 ISVC32 Abort32 IRQ32 Undef32
reHl fsheiftter and

RO
i RO RO RO
n vevisisibibllee  32-b;di.tt RO RO

daote R1 R1 IR1 R1 R1 R1

main memorrryyy. R2 R2 R2 R2 R2 R2
ig, another fo)r R3 R3 R3 R3 IR3 R3

led in an op R4 R4 R4 R4 R4 R4
Dn.
d R5 R5
n ct hoepprroocceesssor,*srsrspocss R5 R5 R5 R5

led ine ano idmianoen R6 R6 R6 R6 R6 R6
R7 R7 R7 R7 R7 R7
R8 EU-iq- R8 ae-- IRB8- a-~~~IBRfL-
B9-- Rgjiq RIRfifl9 fi m- - IR9-i~ BiE-

rrraengds   i2te r amn B1Q-- E2_fiq__ IiR1 B!Q- BI0 BiQ--
001ll Rm R11 R11 fiq --- IR1 1 R11 IR11 R11
01O|R| m a12- E2 fiq___ R1 2 RlL-- IR12 B12-
c--C-m R13 a! 3 fi R13 svc R13 abt R13 uund

814- a!±f iq__ R14 svc R 14 abt |R14_irq R14 und
rList EiLP-CL EiLLPC-i- R1(5P C) IElL-PCL EiLffcl-
Offset MM- CPSR ---- 7 LEaR- -QEaEL--

SPSFLfiq SPSR abt [SPSRZ-irq SPSR und
SPSRJiq SPSF? SPSR abt SPSRJrq SPSR und

More complete documentation can be found at www. arm. com.

registers and1  6
ne or two stattus
*nth e processsoorr
o support rappid

,s. The bankwed

Fare Appendix G 563



H. ANOTHER VIEW ON The <= wii
and 11.5.6)
event queu

NON-BLOCKING $time ads
plicit style 
ent assignn

ASSIGNMENT
There are other forms of the non-blocking assignment besides the RTN form (<=
@( posedge syscik)) used earlier in this book:

var <= expression;

var <= #delay expression;

Assuming 
The semantics of <= and <=#dela y are more subtle than the extra always analogy regardless c
explained in section 3.8.2, which only applies to <= @(p osedge syscik) . In gen- ing = instea
eral, non-blocking expressions are evaluated immediately and put into a simulator queue one of the r
to be stored after all blocking assignments at the $time given by the specified #de- situation re(
lay. Clifford Cummings of Sunburst Design, Inc. (www. sunburst - design. com)
gave a very informative presentation on the use of such non-blocking assignment state-
ments at the 1998 International Verilog Conference. He suggested that the blocking
assignment, =, should be primarily limited to modeling combinational logic, as in:

always (a or b)

sum = a + b;

with similar

H.1 Sequential logic tional logic
interacting 

According to Cumming's guidelines, sequential logic, such as a simple D type register, intervening
should use the non-blocking assignment:

Most existin
always (posedge sysclk) 7.2.2.1, 11.3

dout <= din; rather than <
without und,
tial logic usi

564 Verilog Digital Computer Design: Algorithms into Hardware

k



The <= without time control above has the same meaning as <= #0 (sections 11.3.3
and 11.5.6). It causes the simulator to put the assignment into a special "non-blocking
event queue" that stores a new value after all = and =#O have finished but before
$time advances. The <= without time control is useful for situations where an ex-
plicit style module uses the same regs on opposite sides (example in bold) of differ-
ent assignments that model distinct sequential devices, as in:

N form (<= always (posedge sysclk)

r2 <= rl;

always (posedge sysclk)

rl <= r2;

Assuming rl and r2 were initialized (not shown), the above exchanges rl and r2,
ays analogy regardless of the order in which the simulator schedules the two always blocks. Us-
lk) . In gen- ing = instead of <= above would have the incorrect effect of duplicating the value of
nulator queue one of the registers (seemingly chosen at random) into both of them. To use = in this
-cified #de- situation requires intervening combinational logic:
sign.com)
Ynnent state-
the blocking always (posedge sysclk)
gic, as in:

r2 = new_rl;

always (rl)

new_rl = rl; //identity

with similar code for r2, which is hard for designers to remember when the combina-
tional logic is simply the identity function. This problem does not occur when the
interacting always blocks are in separate modules because the port(s) act like the

type register, intervening combinational logic.

Most existing explicit style designs, including examples in this book (sections 3.7.2.2,
7.2.2.1, 11.3 and 11.7), use = properly (with intervening combinational logic or ports)
rather than <= . Probably many designers stumble onto correct sequential logic using =
without understanding why it is correct. Even more alarming, some incorrect sequen-
tial logic using = may appear to be correct because of the arbitrary order in which the

Appendix H 565

4



Verilog simulator schedules the assignments. Cummings suggested designers use only and inertial
<= for sequential logic to guarantee correct operation without making the designer more rapidl
remember the intervening combinational logic or ports.

H.2 $strobe alwa

Cummings also suggested using the strokee system task, which works like $dis- de
play, but shows the result of non-blocking assignment at the same $ time the assign- alwa
ment is made. For example, instead of the $display code with delay used in many
examples in this book, as typified by section 3.8.2.3.2: #3

always (posedge sysclk) #20 $tim

$display("%d a=%d b=%d ", $time, a, b); sign

dela

Cummings would recommend: delb

delc

always ? posedge sysclk)

$strobe("%d a=%d b=%d ", $time, a, b);
Of course, tr

which has the advantage that the values that will take effect during a particular clock
cycle will be displayed at the actual $ time of the rising edge. With $di splay, there
must be at least #1 delay (#20 in this example) beyond @( posedge sysclk) to H.4 Se
view the values changed by non-blocking assignments. Because of tl

occur in the!
2 into a.A s
code with <:
clock cycle. I

H.3 Inertial versus transport delay have more t1

An interesting contrast clock 
between cycle. 

blocking and non-blocking assignment that Cummings
illustrated code 

is the for a pl
difference between transport delay, which retains all the values s ig-

nal has, regardless later <= 
of how can

briefly they exist:

always (signal) H.5 Fu
dela <= #3 signal; CUMMINGS, C

national Veri

566 Verilog Digital Computer Design: Algorithms into Hardware



se only and inertial delay, which filters out certain values of signal when values change
.esigner more rapidly than a specified amount of $ time (3 in this example):

always @(signal)

$di s - delb = #3 signal;

assign- always @(signal)
.nm any

#3 delc = signal;

$time 0 1 2 3 4 5 6 7 8 9

signal 1 1 1 1 2 3 3 3 3 3 ...

dela x x x 1 1 1 1 2 3 3 ...

delb x x x 1 1 1 1 2 2 2 ...

delc x x x 1 1 1 1 3 3 3 ...

Of course, transport delay is more realistic of how physical signals behave.

tar clock
gy, there H.4 Sequence 
cik) to preservation

Because of their queued implementation, non-blocking assignments at the same $ time
occur in the sequence the <=s executed. For example, a<=l followed by a<=2 stores
2 into a. As emphasized in section 9.6, hardware registers (described in implicit style
code with <= (posedge sysclk)) cannot store multiple values during a single
clock cycle. Even though Verilog allows it, it is inappropriate for implicit style code to
have more than one <= (posedge sysclk) to a given reg during a particular
clock cycle. On the other hand, Cummings pointed out that it is useful in explicit style

ummings code for a plain <= to give a default values to the output of a state machine, which a
ies ig- later <= can modify at the same $ time.

H.5 Further reading
CUMMINGS, CLIFFORD E., "Verilog Nonblocking Assignments Demystified", 7th Inter-
national Verilog HDL Conference, Santa Clara, CA, Mar 16-19, 1998, pp. 67-69.

Appendix H 567

A
S



I. GLOSSARY Big endian

Blocking p
sion now,

The following include terms used in computer design. Terms marked with Bottom 
* are tesl

unique
to this book. Synonyms for terms not used in this book are also given. In addition, the difficult t
following includes Verilog features (courier font), some of which are not described task with
elsewhere in this book. See the references given at the end of chapter 3 for details Bus: A grou
about Verilog features not described in this book.

Bus driver
outputs I

Access time: The propagation delay of a memory. Cache: An
Active high: Apin of a physical chip where I is represented as a high voltage. casex: A var
Active low: A pin of a physical chip where I is represented as a low 13 bits 

voltage. of

*Actor: A machine or person that interacts with the machine being designed.

Address bus: alway
A bus used to indicate which word of a memory is selected.

begi
Algorithmic State Machine, see ASM ca

3
Architecture: 1. The hardware of a machine that manipulates data, as opposed to the 3

controller. Is present in mixed(l) and pure structural designs. Also known as a 3
datapath. 2. The programmer's model and instructions et of a general-purposec om- 3
puter. See also computer architecture. 3. A feature of VHDL that provides greater 3
abstraction of instantiationt han Verilog does. eni

{n
ALU (Arithmetic Logic Unit): Combinational logic capable of computing several end

different functions of its input based on a command signal. Typically, the functions
include arithmetic operations, such as addition, and bitwise (logical) operations, such casez: Liki
as AND.

*Central Al
ASM (Algorithmic State Machine): A graphic notation for finite state machines con- associated

sisting of rectangles(l), diamonds (or equivalently hexagons), and possibly (for non-blocki
Mealy machines) ovals. A pure behavioralA SM is equivalent to implicit style Verilog architecture
with non-blocking assignment. Moore mixed(1) ASMs can be implemented as im-
plicit style Mealy Verilog. Central Pro,

Asynchronous: Logic which has memory but which does not use the system clock. CPU (Centr
besides me

Backannotation: Recording the propagationd elay in a netlist after synthesis.
Combination

Behavioral: Code which describes what a machine does, rather than how to build it. (including
see also pure behavioral.

or by a co,

568 Verilog Digital Computer Design: Algorithms into Hardware



Big endian notation: The most significant bit (byte, word, etc.) is labeled as 0.
Blocking procedural assignment: A Verilog statement (=) that evaluates an expres-

sion now, causes the process to delay for a specified time and then stores the result.
Bottom testing loop: A loop that 

* is 
are guaranteed 

unique to execute at least once. Such loops are
difficult to code in implicit 

addition, style Verilog. 
the For simulation, use enternewstate

task with !== to the bottom 
ot described state. For synthesis, use disable inside forever.
3 for details Bus: A groups of wires that transmit information.

Bus driver: A tri-state device that passes through its input when it is enabled, but
outputs bz when it is not.

Cache: A memory that allows faster access to words used most frequently.
Itage. casex: A variation of case that treats 1 'bz or 1 'bx as a don't care. For example, the

13 bits of output for the truth 
ige. table given in section 2.4.1 could be coded as:

ned.
always (ps or pb or rlgey)

1. begin
casex ({pspb,rlgey})
3'bOOx: t=13'bOllOOO1010101;

posed to the 3'bOlx: t=13'blllOOO1010101;
known as a 3'blOO: t=13'bOlOlllO110010;

purpose com- 3'bllO: t=13'bllOlllOllOO10;
vides greater 3'blxl: t=13'bllOlllOllOO10;

endcase
{nsldrl,clrr2,incr2,ldr3,muxctrl,aluctrl,ready}=t;

uting several end
the functions
,rations, such casez: Like casex, except it only uses 1 bz.

*Central ALU: An architecture(1) that uses a single ALU for all 
iachines computation. 

con- The
associated pure behavioralA SM is usually restricted to one register transfer 

possibly (RTN 
(for or

non-blocking assignment) per state, and so algorithms designed 
t style for 

Verilog a central ALU
architecture are usually slower than those designed for methodical 

rented architectures.
as im-

Central Processing Unit: see CPU.

Ftem clock. CPU (Central Processing Unit): The main element of a general-purpose computer,
besides memory.

thesis.
Combinational: Logic which has no memory. In Verilog, 

)w ideal 
to build combinational 

it. logic
(including a bus or tri-state device) is modeled with @ followed by a sensitivity list
or by a continuous assignment.

Appendix I 569

M -



Combinatorial: see Combinational Enabled r
Command signal: 1. An internal signal output from a controllert hat tells the architec- data.

ture(l) what to do. Found only at the mixed(l) and pure structural stages. 2. An *External
external signal output from a controller to another actor.

entern
Computer architecture: 1. see Programmer'sm odel and instruction set architecture. and mix

2. A generic term for a field of study that encompasses the computer design topics in chines ai
this book along with more abstract modeling concerns not discussed here, such as
networked general-purpose computers, disk drives and associated software operat- Explicit st,
ing system issues. not have

lent to td
Concatenation: The joining together of bits, indicated by {}  in Verilog. state reg
Conditional: Non-blocking assignments (RTN) and/or command signals that occur in the archi

a particular state only under certain conditions. See Mealy and oval. requires

Continuous assignment: A shorthand for instantiating a hidden module that defines Falling del
behavioral combinationall ogic. Allows assignment to a Verilog wire. Eliminates $fclose:
the need to declare ports and sensitivity lists. file. See

Controller: The hardware of a machine that keeps track of what step of the algorithm $fdispla
is currently active. Described as an ASM at the mixed(1) stage, but as a present state $fclos
and next state logic at the pure structurals tage.

Field Progi
CPLD (Complex Programmable Logic Device): A fixed set of AND/OR gates op-

tionally attached to flip flops with a programmable interconnection network allow- Finite statt
ing the downloading of arbitrary netlists. Flip Flop:

Data bus: A bus used to transmit words to and from a memory. build regi

Datapath, see architecture(]) $fopen: S
ger file h

defparam: An alternative way of instantiating a different constant for a param-
eter.

intec
Dependent: Two or more computations where the evaluation of some parts depends initi

on the result of other parts. It is hard to design pipeline and superscalarc omputers begi
when computations are dependent. ha

$f 
Diamond: The ASM symbol for a decision, usually equivalent to an i f or while in $f 

implicit style Verilog. end

Digital: Pertaining to discrete information, e.g., bits. See also special-purpose com-
puter. fork: An a

example,
$dumpf ile: System task, whose argument is a quoted file name, for VCD. For a

complete dump, also need $dumpvars and $dumpon. Other tasks exist for more
limited dumps.

570 Verilog Digital Computer Design: Algorithms into Hardware



Enabled register: A synchronous register that has the ability to hold as well as load
architec- data.

es. 2. An *External status: Information from outside the machine used to make decisions.
enternewstate: A user defined task only for simulation at the pure behavioral

,hitecture. and mixed(l) stages. Establishes default command signals. Helps with Mealy ma-
a topics in chines and bottom testing loops.
e, such as
re operat- Explicit style: A finite state machine described in terms of next state transitions. Does

not have multiple @( posedge sysclk) s inside the always. Roughly equiva-
lent to the pure structural stage, except instead of separate modules for the present
state register and the next state logic, both are often coded in the same module, and

it occur in the architecture is modeled in a behavioral style, often called RTL. Explicit style
requires the designer to think in terms of gotos. Contrast implicit style.

at defines Falling delay: The propagation delay it takes for an output to change to 0.
eliminates $fclose: System task, whose argument is a file handle, that closes the associated

file. See also $ fopen.
algorithm $fdisplay: A variation of $display that outputs to a file. See also $fopen,
esent state $fclose.

Field Programmable Gate Array: see FPGA
.gates op-
ork allow- Finite state machine, see ASM.

Flip Flop: A sequential(l) logic device that stores one bit of information. Used to
build registers and controllers.

$f open: System function, whose argument is a quoted file name, that returns an inte-
ger file handle used by $ fdisplay, $fstrobe or $fwrite:

param-

integer handle;
ts depends initial
computers begin

handle = $fopen("example.txt');
$fdisplay(handle,"Example of file output");

while in $fclose(handle);
end

pose com-
fork: An alternative to begin that allows parallel execution of each statement. For

example, the following stores 
nD. into 

For b at 
a $ time 2 but stores into d at $ time 3:

;t for more

Appendix I 571



Hierarchic

initial Hierarchic
fork without

#1 a=10; periods.
#2 b=20;

join High impel
initial also prod

begin
#1 c=10; Ideal: An
#2 d=20; delay anc

end Implicit st,
sysclk

Four-valued logic: A simulation feature of Verilog that models each bit as being one lent to aI
of four possible values: 0, 1, high impedance (1 bz) or unknown value (1 bx). Independei

FPGA (Field Programmable Gate Array): A fixed set of lookup (truth) tables op- to design
tionally attached to flip flops with a programmable interconnection network allow- inout dec
ing the downloading of arbitrary netlists. mation tr

$fstrobe: Avariation of $strobe that outputs to a file. See also $ f open, $ fclose. input: A
Full case: A synthesis directive that causes a case statement to act as though all into a mo,

possible binary patterns are listed. May cause synthesis to disagree with simulation. Instance: A
$fwrite: A variation of $write that outputs to a file. See also $ f open, $f close. Instantiatic
General-purpose computer: A machine that fetches machine language instructions Instruction

from memory and executes them. The machine language describes the algorithm general-pi
desired by the user, as opposed to a special-purpose computer. Also known as a
stored program computer. Instruction.

Glitch: see Hazard. *Internal St
ler at the 

Goto: A high-level language statement not found in Verilog. Similar to state transi- in the arch
tions in explicit style Verilog. Equivalent to assembly language jump or branch in-
structions. Gotos are useful for implementing bottom testing loops. The closest Latch: Ana,
statement in Verilog is di sable, which has drawbacks when used for this purpose. when a ca
Avoidance of gotos is part of structuredp rogramming, and is possible with implicit Little endiai
style Verilog.

Macro: Ast
Handshaking: The synchronization required when two actors of different speed transfer parsing.

data.
Macrocells:

Hazard: The momentary spurious incorrect result produced by combinationall ogic of an optiona
non-zero propagationd elay.

Hexagon: Equivalent to diamond in ASM notation.

572 Verilog Digital Computer Design: Algorithms into Hardware



Hierarchical design: Instantiation of one module inside another.
Hierarchical names: A path for test code to access the internal variables of a module

without a port. The instance names of the module(s) in the path are separated with
periods.

High impedance: A value (1 'bz) that models a wire that is disconnected and that is
also produced by a tri-state gate. Used in a special way by casex and casez.

Ideal: A model of a device that ignores most physical details, such as propagation
delay and voltage.

Implicit style: A finite state machine described in terms of multiple @( posedge
sysclk) s inside an always. Does not give nextstate transitions. Roughly equiva-

,ing one lent to a pure behavioral stage ASM. Contrast explicit style.
Ib x). Independent: Two or more computations that do not depend on each other. It is easier
bles op- to design pipeline special-purpose computers when computations are independent.
k allow- inout declaration: A Verilog feature that allows the same port to be used for infor-

mation transfer both into and out of the module. Corresponds to tri-state gates.
close. input: A Verilog feature that only allows a port to be used for information transfer

Dugh all into a module.
iulation. Instance: A copy of a module used in a particular place of a structural design.
close. Instantiation: The act of making an instance.
tructions Instruction set: The set of machine language operations implemented by a particular
Igorithm general-purposec omputer.
)wn as a

Instruction-Set Architecture (ISA): See programmer' s model and instruction set.
*Internal status: Information generated by the architecture(])a nd sent to the control-

ler at the mixed(,l) stage so that the controller can make decisions based on the data
te transi- in the architecture.
ranch in-
e closest Latch: An asynchronousd ata storage device. Synthesis tools produce unwanted latches
purpose. when a case statement is used that is not afull case.
I implicit Little endian notation: The least significant bit (byte, word, etc.) is labeled as 0.

Macro: A string of source code that the simulator or synthesis tool substitutes prior to
d transfer parsing.

Macrocells: The basic unit of a CPLD, consisting of a fixed set of AND/OR gates and
dll ogic of an optional flip flop.

Appendix I 573

W



Mealy: A finite state machine that, unlike a Moore machine, produces command sig- notif 1: A
nals that are a function of both the present state and the status inputs. Such a com-
mand is indicated by an oval in ASM notation. One hot: A

*Methodical: An architecture(])w here each register has an associated ALU or other output:A
combinational logic so that all register transfers may proceed in parallel. Typically out of a m
allows for faster algorithms to be implemented than the central ALU approach. Oval: The i

Memory: Equivalent to a collection of registers. Has the ability to read (remember Parallel: 1.
old data) and write (forget old data and remember new data instead). Often referred time. 2.
to as RAM. Although ROM is often used instead of RAM in parts of a general- same sim
purpose computer, because ROM cannot forget, it is not memory. When one

Mixed: 1. The stage of the design where the controller is specified as an ASM using tial.

command and status signals (rather than RTN and mathematical conditions), but the Parallel cai
architecture(l) is specified as a structure. 2. Any such mixture of behavioral and given in a
structuralc onstructs in a Verilog module. 3. A kind of digital logic netlist where 1 is
sometimes represented as a high voltage (active high) and sometimes represented as paramete:
a low voltage (active low). each insta

module: The basic construct of Verilog which is instantiated to create hierarchical Pin: Theph

and structurald esigns. Pipeline: A

Moore machine: A finite state machine that, unlike a Mealy machine, produces com- to produce

mand signals that are a function of only the present state. All commands in a Moore pare with.

ASM are given in rectangles. Place and r(
Multi-cycle: A machine that requires several fast clock cycles to produce one result. ited resoul

Compare with single cycle and pipeline. PLI (ProgrE
Multi-port memory: Allow simultaneous access to multiple words within one clock C software

cycle. Port: The ai

Netlist: A structural design described at the level of connections between one-bitwires posedge:
and gates.

Present stat
Next state: Combinational logic that computes what the next step is in the algorithm currently a

based on the present state and status inputs to the controller.
Programma

Node collapsing: An optimization technique used by place and route tools. can be rec(

Non-blocking assignment: A Verilog statement (<=) that evaluates an expression Programmi
now but that schedules the storage of the result to occur later. Several non-blocking logic or a
assignments can execute in parallel without delay. There are several forms, but the purpose co
one used most in this book ( <= @( posedge sysc1k) ) is equivalent to the RTN
<- used in the pure behavioral stage for ASMs. Programmi

notifO: A variation of buf if 0 that complements its output.

574 Verilog Digital Computer Design: Algorithms into Hardware

A



mand sig- notif 1: A variation of buf if 1 that complements its output.
Lch a corn-

One hot: An approach for the controller that uses one flip flop for each state.

output: A Verilog feature that only allows a port to be used for information transfer
U or other out of a module.
Typically

roach. Oval: The ASM symbol for a Mealy command.

:remember Parallel: 1. Two or more independent computations that occur at the same physical
en referred time. 2. Two or more computations (dependent or independent) that occur at the
a general- same simulation $time. In Verilog, $tirme is a separate issue from sequence. 3.

When one assumes physical time and sequence are the same, the opposite of sequen-
tial.

ASM using
ns), but the Parallel case: A synthesis directive that allows parallel evaluation of the conditions
zvioral and given in a case statement.
t where I is parameter: A constant within an instantiationo f a module that can be different in
resented as each instance.

Pin: The physical connection of an integrated circuit to a printed circuit board.
ierarchical

Pipeline: A machine that requires, on average, slightly more than one fast clock cycle
to produce one result, provided that each result is independento f other results. Com-

duces corn- pare with single cycle and multi-cycle.
in a Moore

Place and route: A post synthesis tool that maps the synthesized design into the lim-
ited resources of a particular technology, such as a CPLD or FPGA.

one result.
PLI (Programming Language Interface): A way to interface Verilog simulations to

C software, and thus extend the capabilities of Verilog.
in one clock

Port: The aspect of a module that allows structural instantiation.

e-bitwires posedge: The rising edge of a signal, such as sysclk

Present state: The register that indicates what is the step in the algorithm which is
ie algorithm currently active.

Programmable logic: Integrated circuits manufactured with a fixed set of devices that
)Is. can be reconfigured by downloading a netlist. See CPLD and FPGA.

n expression Programming: 1. The act of downloading a synthesized netlist into programmable
ion-blocking logic or a truth table into a ROM. 2. The act of designing software for a general-
)rms, but the purpose computer.
it to the RTN Programming Language Interface: See PLI.

Appendix I 575



Programmer's model: The registers of a general-purpose computer visible to the Some ven
machine language programmer. RTN. Thi

Propagation delay: The time required for combinational logic to stabilize on the cor- implicit, e
rect result after its inputs change. RTN (Regis

*Pure behavioral: The stage where the design is thought of only as an algorithm evaluates
using RTN. Equivalent to implicit style Verilog. of the left

Verilog nc
*Pure structural: The stage where the controller and the architecture(]) are both

structural. SDF (Stand
after place

RAM: see memory.
Sensitivity 

$readmemb: System task, whose arguments are the quoted name of a text file and an the sensiti
array. Reads words represented as a pattern of '0',' ','x' and/or 'z' from the text file cause unw
into the array.

Sequence: l
$readmemh: System task, similar to $readmemb, except for hexadecimal. a particula
Rectangle: 1. The ASM symbol for a Moore command. 2. The block diagram symbol control.

for most devices. Sequential:
Reduction: The unary application of a bitwise operator which acts as though the op- to combine

erator was inserted between each bit of the word. For example, if a is three bits, &a ticular seq
isa[2]&[1]&a[0]. When one

lel.
reg: The declaration used when a value is generated by behavioralV erilog code.

Simulation:
Register: A sequential(J) device that can load, and for some register types otherwise timing dial

manipulate a value. The value in a synchronous register changes at the next rising
edge of the clock. Contrast with combinational. Single-cycle:

pare with 
repeat: A Verilog loop that repeats a known number of times. Very different than the

bottom testing loop. Special-purl
algorithm,

Reset: The only asynchronous signal used in this book, which clears the present state. are often a
Resource sharing: A synthesis optimization where the same hardware unit is used for Standard D

multiple computations.
strength:

Rising delay: The propagation delay it takes for an output to change to 1. ties.
ROM (Read Only Memory): A tabular replacement for combinational logic. Not an State: Aster

actual memory because it does not have the ability to forget.
Status: Seei

RTL: 1. "Register Transfer Logic." In the pre-Verilog literature, the term RTL meant
the logic equations generated by the controller to implement register transfers (sec- Structural:
tion 4.4.1). Today, RTL most commonly means explicit style behavioral Verilog. vices) that

stances of

576 Verilog Digital Computer Design: Algorithms into Hardware

I



-

sible to the Some vendors (notably Synopsys) also use RTL to describe implicit style design and
RTN. This book avoids the use of the term RTL, in favor of the more precise terms:
implicit, explicit and RTN. 2. "Rotate Two Left", a PDP-8 instruction.

on the cor-
RTN (Register Transfer Notation): An - inside a rectangle or oval of an ASM that

evaluates an expression during the current clock cycle, but that schedules the change
Lna lgorithm of the left-hand register to occur at the next rising edge of the clock. Similar to the

Verilog non-blocking assignment ( <= @( posedge sysclk)).
(1) are both SDF (Standard Delay File): A way to backannotate delay information into a netlist

after place and route.

Sensitivity list: The list of input variables of combinationall ogic. The variables in
xt file and an the sensitivity list occur inside @ separated by or. Failure to list all variables can
n the text file cause unwanted latches.

Sequence: The order in which Verilog statements execute in simulation. Statements in
imal. a particular always or initial block execute sequentially, regardless of time

control.
igram symbol

Sequential: 1. A device that has memory, such as a controllero r a register, as opposed
to combinationall ogic. 2. Two or more dependent computations that occur in a par-

hough the op- ticular sequence, even if they occur at the same $time in a Verilog simulation. 3.
three bits, &a When one assumes physical time and sequence are the same, the opposite of paral-

lel.
rilog code. Simulation: The interpretation of Verilog source code to produce textual output and
apes otherwise timing diagrams.
the next rising Single-cycle: A machine that requires one slow clock cycle to produce one result. Com-

pare with multi-cycle and pipeline.
fferent than the Special-purpose computer: A machine that is customized to implement only one

algorithm, as opposed to a general-purpose computer. Special-purpose computers
iep resent state. are often referred to simply as digital logic.

unit is used for Standard Delay File: See SDF.

strength: Additional information about a wire that models its electrical proper-
to 1. ties.

al logic. Not an State: A step that is active in an algorithm during a particular clock cycle.

Status: See internal status and external status.
term RTL meant Structural: An interconnection of wires and gates (or combinationala nd register de-
-r transfers (sec- vices) that forms a machine. Represented by a block diagram, circuit diagram, in-
iavioral Verilog. stances of modules or a netlist.

ware Appendix I 577



Structured programming: Describing an algorithm with high-level software control Value Cha
statements, such as i f, case and while, but avoiding goto. and relate

simulatic
Subbus: A concatenation of a subset of bits from a bus.

Verilog: T
Superscalar: A general-purpose computer that is able to execute more than one in-

struction per clock cycle. VHDL: TI
beginner

Synchronous: A device that makes changes only at an edge of a clock signal, typically
the rising edge. wand: A v,

which im
Synthesis: The automatic translation of Verilog source code into a netlist.

wor: A var
System clock: The single clock used in a completely synchronous design.

which im
*Test code: Non-synthesizable Verilog code used only in simulation to verify the op-

wire: The
eration of other, possibly synthesizable, Verilog code that models hardware. Test
code (sometimes called a testbench) gives an abstract model of the environment in Wirewrap:
which the hardware will operate. wire arou

prototype
Testbench: see test code

Worst case
time: Adeclaration for a variable that stores the result of $time. Often, integeris

possible.
used instead.

-&: Thebit
$time: The current simulation time step.

Time control: - 1: The bits
Verilog features that cause $ time to advance in simulation: @, # and

wait - : The bit'
aA-b, wl

triand: Similar to wand.

trior: Similar to wor.

trireg: A variation of wire that holds the last value when all outputs are 1' bz.

Tri-state: A device that has the ability to disconnect itself electronically from a bus.
Verilog models this using the high impedance value ( bz).

Turn off delay: The propagation delay it takes for an output to change to 1 ' bz,
associated with a tri-state device.

Unary code: A bit pattern where exactly one of the bits is a one. See one hot.

Unconditional: Non-blocking assignments (RTN) and/or command signals that are
synonymous with a machine being in a particular state, regardless of any other con-
ditions that may hold. See Moore and rectangle.

Unknown value: A value (1 bx) that models an uncertain condition for one bit, such
as two fighting output wires, typically indicative of an error in a structurald esign.
Also used in chapter 6 to model abstract hazards.

578 Verilog Digital Computer Design: Algorithms into Hardware



are control Value Change Dump (VCD): A standardized text file format created by $ dumpf ie
and related tasks that record values of simulation variables and that is used by post-
simulation analysis tools.

Verilog: The hardware description language used in this book. (See chapter 3.)
ian one in-

VHDL: The other hardware description language, which is more complicated for the
beginner than Verilog.

al, typically
wand: A variation of wire that produces 0 instead of 1 ' bx when two outputs fight,

which implements & without using a gate (wired AND).

wor: A variation of wire that produces 1 instead of 1 bx when two outputs fight,
which implements I without using a gate (wired OR).

-rify the op- wire: The declaration used when a value is generated by structural Verilog code.
Iware. Test
ironment in Wirewrap: A technique of connecting chips together involving using a tool that wraps

wire around posts connected to the pins of the chips. A convenient way to fabricate
prototypes in an educational or hobby setting.

Worst case: A model of a device that only considers the longest propagationd elay
integer is possible.

-&: The bitwise NAND operator, a-&b (a&b), which is not found in C.
- : The bitwise NOR operator, a- l b === (a Ib ), which is not found in C.

n: @, #and
-A: The bitwise coincidence operator, a^b - (a^b) === a' (-b)

a'-b, which is not found in C.

are I1Ibz.

.yf rom a bus.

nge to 1'bz,

ne hot.

'gnals that are
any other con-

r one bit, such
uictural design.

Appendix I 579



- V.

J. LIMITATIONS ON MEALY cannot be 
always) 
words, if th

WITH IMPLICIT STYLE make corre
this, since ti

Chapters 5, 9 and 10 and sections 7.4 and 11.6 discuss ASM charts and Verilog simula- binational I
tion for Mealy state machines, in which an operation (inside an oval of an ASM chart) instead of G
is conditional. Mealy state machines are more problematic than the Moore state ma- states, but t
chines used in the rest of this book. There are limitations on using the Mealy approach ioral code ti
with implicit style Verilog. Verilog inst

There are three consequences of using an oval in an ASM chart. The first consequence, It is possib]
which can be described with implicit style (pure behavioral) Verilog, is to allow com- Mealy exte
putations dependent on a decision to be initiated in parallel to the decision. For ex- approach is
ample, the decoding and execution of a TAD instruction in chapter 9 illustrate a deci- simulation 
sion (ir2[ 11:9] == 1) and a computation (ac+mb2) that occur in parallel:

if (ir2[ 11:9] == 1)
ac <= @(posedge sysclk) ac + mb2; a

As in most of the examples in this book, the statement that carries out the computation
is a non-blocking assignment, so the effect will not be observable until the next rising
edge of the clock. When viewed by itself, the architecture is a Moore machine (it has
registers that only change at the rising edge). Since the output (ac) of the complete
machine (the controller together with the architecture) only changes at the clock edge,
the complete machine is Moore. Only the controller is Mealy. For this reason, implicit
style Verilog with non-blocking assignment can model such situations.

The second consequence of using an oval in an ASM chart arises only at the mixed
stage, such as figure 5-2. Depending on how complicated the architecture is, there may
be hazards created between the controller and architecture during simulation that an
implicit style Verilog description of the controller will not process properly. The 1994
paper mentioned below describes a bx handshaking technique with an
exitcurrentstate task that overcomes this problem for Verilog simulation.
This technique is an extension to the enter new state method given in this book.

The third consequence of using an oval in an ASM chart arises only when a decision
involves an input to a machine, and RTN is not used to produce the corresponding
output. Figure 5-7 is an illustration of such a situation. For such ASMs, the machine

580 Verilog Digital Computer Design: Algorithms into Hardware

M -



-7

XLY cannot be modeled just with implicit style Verilog (@( posedge sysclk) inside
always) because the output of the machine is supposed to follow the input. In other
words, if the input makes multiple changes during one clock cycle, the output should

'LE make corresponding changes during that clock cycle. The implicit style cannot model
this, since the behavioral block will execute only once. Since figure 5-7 is simple com-

rilog simula- binational logic (single-state ASM), the designer uses the appropriate sensitivity list
iASM chart) instead of @( posedge sysclk). In general, Mealy machines often have multiple
)re state ma- states, but there is no implicit style notation to describe this reexecution of the behav-
aly approach ioral code that must take place in each Mealy state. It is necessary to use explicit style

Verilog instead. The 1998 paper gives more information about this.

It is possible to use a hybrid implicit/explicit style to cope with a machine that has
coo anlsloeqwu ecnocme,- Mealy external outputs, such as the ASM in section 5.2.4 (figure 5-6). This hybrid
sion. For ex- approach is synthesizable. The following shows in bold the distinctions between the
istrate a deci- simulation only technique of section 5.3 and the hybrid implicit/explicit approach:
,arallel:

reg s;
always //implicit block

begin
s <= (posedge sysclk) 0;

computation @(posedge sysclk) #1;
he next rising rl <= @(posedge sysclk) x;
machine (it has //ready = 1;
the complete if (pb)

he clock edge, begin
-ason, implicit r2 <= @(posedge sysclk) ;

while (rl >= y)
begin

y at the mixed s <= (posedge sysclk) 1;
Seis , there may @(posedge sysclk) #1;
ulation that an rl <= (posedge sysclk) rl - y;
ierly. The 1994 if (rl >= y)
ique with an r2 <= (posedge sysclk) r2 + 1;
log simulation. //else
en in this book. // ready = 1;

end
when a decision end
corresponding

is, the machine

are Appendix J 581

N=__ -



Continued

I
always (s or rl or y) //explicit block ,70,80
begin 1, 70

if (s==O) ready = 1; 70, 80
else if (rl >= y) ready = 0; -&,579

else ready = 1; -,79

end -^,579

'bx, 77-80

The hybrid approach eliminates the enter newstate task with an internal 'bz, 77-80,
state

variable, s. A separate always 'define, 
block implements the combinational logic that com-

putes the Mealy output 'ifdef, 
based 73

on the internal state variable and the condition(s) speci- 'timesca
fied in the Mealy decision (rI >= y). Every usage of a Mealy command, including [, 67-68, 2
unconditional ones such as in the in the top state of this example (s==O), must be }, 68, 305
generated by an always block dedicated to that command signal. !,70

!=,70,80
=,80, 19

#,83, 93, 13
J.1 Further Reading in test,
ARNOLD, MARK G., NEAL J. SAMPLE and JAMES SHULER, "Guidelines for Safe Simulation modeli
and Synthesis of Implicit Style Verilog," 7th International Verilog HDL time 

Conference, cc
Santa Clara, CA, with 

March sy
16-19, 1998, pp. 67-69.

$display,
$dumpfilE
$fclose. 5
$fdisplay
$6 of Cp; ;L-An,L , y
$ fopen, 57'
Cffsrnhe.
$fwrite, 5'
$readmemb
$readmemh
$stop, 94
$strobe, 5/
$time, 81:

versus 
with or(

adv,
$write, 72,
' versus
%,70
&,7 0, 80, 309

582 Verilog Digital Computer Design: Algorithms into Hardware



In(lex
,70,80 &&,7 0
1,7 0 *,70
70, 80 +,70

-&,579 -,70
- ,579 /,70

*^579 <,70
inferencee, 'bx, 77-80 <<, 70

'bz, 77-80, 221, 229, 545
,ermnall  state 'define, 73
 that comrn

in RTN simulation, 
- 96, 98

'ifdef, 73, 419 less than, 70
n(s) speci- 'timescale, 448 Mealy, with Moore command
, including 1,6 7-68, 221-222, 281, 305, 480 signals, 266
), must bie },6 8, 305 non-blocking assignment, 95,

70 see also RTN
,70,80 proper use of, 400

!==, 80, 195 =,10,68,90,95,226
#,83,93,136: ==,70,80

in test code, using, 84 ===, 79, 80
modeling combinational logic with, 85

SimulationI >,70
time control, 83

,onferenci with system clock simulation, 87 greater than or equal, 70
$display, 72,419 in specify, 208
$dumpfile, 570 >>,70
$fclose. 571 ?:,70, 257, 392
$fdisplay, 572
$finish, 99 behavioral combinational logic, 89
$fopen, 571 debugging display, 92
$fstrobe, 572 sensitivity list, 90
$fwrite, 572 time control, 89, 191
$readmemb, 576 @(posedge sysclk),
$readmemh, 576 see also system clock:
$stop, 94 bottom test loop, 191
$strobe, 566 controller, 91
$time, 81: implicit style, 100-109

versus sequence, 82 in non-blocking, 96
with ordering processes, without interaction with #1, 98

advancing, 87 one hot, 249, 445, 462, 471
$write, 72, register, 90
' versus ',73 synthesis, 444, 446
%,70 test code, 93, 136, 465
&,70,80,309 with enter_newstate, 113

Index 583

11111r_ - - -



with 'ENS, 461-462 Analysis, childish division software, 319 expli(
AND instructions, 309 exten

A and, 74, 169, 201, 448 impli,
A priori worst case timing analysis, 202 AND/OR structure of CPLD, 443 input.
ABC computer, 277, 287 'AND, 510 Meals
Abstract propagation delay, 209 'ANDNA, 510 Si]
Access time, 282 'ANDNB, 510 to
Acorn RISC: Arbitrary gotos, 194 Moor

Machine (ARM) Family Data Architecture, 20, 568 multi(
Manual, 434 computer, see programmer's model one hi

Microprocessor, 378 division machine, 154 outpu
Action table, 531 instruction set, 573 PDP-1
Active high and low voltage, 495 memory hierarchy, 344 fel
Actor, 14, 20, 568 methodical versus central ALU, 48 mi

memory as a separate, 312, 475 multi-cycle, 238 pipeli
Adder, 54, 500 pipelined, 241 softwi

bit parallel, 460 pipelined PDP-8, 374 supen
bit serial, 461 Princeton versus Harvard, 379 Assembly h
ripple carry, 460 quadratic evaluator, 235 assign, se

Address, 280 single cycle, 235 Assignment
Addressing modes, 202 Arithmetic Logic Unit, see ALU ass

direct, 487 Arithmetic operations, 70, 510 blocki
indirect, 487 ARM (Advanced RISC Microproces contin
PDP-8, 292, 487 sor), 378 non-bl

Advanced Micro Devices (AMD), 442 branch instruction, 383 time c
Advanced RISC Machines, Ltd., 561 compared to PDP-8, 383 Asynchrono
Advanced RISC Microprocessor, instruction set, 561 memo

see ARM program status register, 384, see also Atanasoff, J
Aiken, Howard, 278 psr 4

Atlas compu
Algorithmic State Machine, see ASM resources and website, 560, 563 Autoincrenm
Altera, 443 macros used in, 391
ALU (Arithmetic Logic Unit), 507: multi-cycle, 388 B

central, 48 pipelined, 400 Babbage, Ch
multiple, 403 superscalar Verilog, 417 Baby Mark 

alul8l portlist, 152 Thumb, 381 Back annotai
aluctrl, 508 Arnold, Mark G., 275, 582 Backquote, 
always: ASM (Algorithmic State Machine), 4, 7, Banked regi

block, 70 see also finite state machine Barrel shiftei
with disable statement, 213 behavioral PDP-8, 303 begin, 71
ASM chart, 100, 113 memory as separate actor, 314 Behavioral, I
in infinite loop, 100 behavioral Verilog, 138-149, 186-188 combir
with forever (synthesis), 72 chart, 7 feature

AMD Mach445, see M4-128/64 decisions in, 12 fetch/e:
Analog information, I commands, 9 instanc

584 Verilog Digital ComputerD esign: Algorithms into Hardware



ire, 319 explicit Verilog, 472, 162-165 Mealy machine, 178
external status inputs, 16 multi-cycle, quadratic evaluator, 224
implicit Verilog, 258-265, 270-271 pipeline, quadratic evaluator, 232
input, 15 single cycle, quadratic evalu-
Mealy, 398 ator, 219

single state, 196 synthesis:
to behavioral Verilog, 186 combinational logic, 444

Moore to one hot, 249 explicit state machines, 445
multicycle ARM, 388 implicit state machines, 445

's model one hot, 251 registers, 444
output, 17 Verilog, 138-149, 186-188
PDP-8: complex ASM, 188

fetch/execute, 294, 302 goto-less ASMs, 99
kLU, 48 mixed architecture, 333 legal statements, 68

pipelined ARM, 400 Mealy ASMs, 186
software dependencies, 26 versus structural, 76
superscalar ARM, 411 Bell Labs, 278

379 Assembly language, 485, 561 Bell, C. Gordon, 352
assign, see Assignment, continuous Berry, Charles, 2, 277
Assignment, see also procedural Bidirectional bus, 281, 496, 551

assignment: Big endian notation, 67
blocking, 95 BINAC computer, 279, 314

oces continuous, 255 Bit:
non-blocking, 95, see also RTN blast, 452, 509
time control, 94 parallel adder, 460

Asynchronous, 173, 528: serial:
memory, 285 adder, 461

34s,e e also Atanasoff, John, 2, 277, 287 PDP-8, 475
Atlas computer, 336 slices, 452

i05,6 3 Autoincrement, 487 Bitwise operators (&, I, A, _), 13, 70, 509
Black box, see block diagram

B Block, diagram (black box), 15, 57,
Babbage, Charles, 2, 246, 277 335, 539
Baby Mark I, 279 PDP-8, 335
Back annotation, 215, 441 Block, initial and always, 70
Backquote, 73 specify, 207

ine), 4, 7, Banked register, 562 Blocking procedural assignment, 95
[achine Barrel shifter, 506 Boolean operations, 78, 449, 523

begin, 71 Bottom testing loop, 189:
actor, 314 Behavioral, 1, see also pure behavioral: disable inside forever, 273
49,186-188 combinational logic, 89 forever/if, 108

features of Verilog, 66 Branch, 393:
fetch/execute, 290 instruction, 383
instance, 118, 121, 123, 129 prediction, 433

Index 585

I



buf, 74, 169 actu
buf if 0, 547 Central ALU , 569 beha
buf if 1, 546 architecture, 48 mod(
Building block: Chart, ASM, 7 mod(

devices, 150 Childish division: phys
combinational, 491 algorithm, 22, 314, 368 with
sequential logic, 525 ARM, 424, 426: Combinato

Burning, 518 conditional instructions, 428 see (
Bus, 493, 543: effect of cache size on, 351 Command,

driver, 547 implementations, comparison, 318, Command
timing diagrams, 528 371, 431, 481 Meal
unidirectional, 496: Mealy, 182, 184-185 Mooi

versus bidirectional, 281, 493 Moore, 26, 30, 34, 39 multi
bidirectional, 496, 551 PDP-8, 317, 369 one b
broadcasting with, 496 program: physi

'bx,77-80 C, 23, 316, 423, 428 Comments
bz,77-80, 221, 229, 545 machine language, 318, 369, Comparatoi

424, 426, 429 portli
C Verilog, 134, 143-148, 186 Computer a

C, C++, 1,4,6 Chip, 3, 539 see PR
childish division program, 23, 316, Circuit diagram, 53, 170, 253, 539 Computer:

424, 429 CISC (Complex Instruction Set archit
Cache: Computer): desigi

consistency, 344 processors, 561 gener
hit, 340 versus RISC, 377 histor
instruction, 437 CLA, 489 specie
memory, 337 Clair, C. R., 59 Concatenati
miss, 339 CLL, 308, 489 Condition, 
size, 351 Clock: Conditional
test program, 339 cycle, 7, 222, 527: assign
write-back, 344-345 multi-cycle, 224, 240 comm
write-through, 344-345 pipelined, 226, 244 execui

Cadence Design Systems, 4, 65 single-cycle, 237 Al
Cambridge University, 279 frequency, 199 ch
car function, 457 period, see clock cycle loadin
Carry out signal (cout), 500, 510-511 CLPD, 558 operat
case: CMA, 489 condx func

adder, 116, 457 CML, 308, 489 Constants, s,
controller, 164-165 CMOS, 495 Continuous;
full, 459 Code coverage, 419 with o
parallel, 459 Colossus (computer), 3, 277, 287 Control dep(
statement, 69, 458 Combinational: Controller, 2

casex, 569 adder, synthesis of, 454 divisic
casez, 569 logic, 491: hierarc

586 Verilog Digital Computer Design: Algorithms into Hardware



actual gate level delay, 492 one hot, 253, 271
behavioral synthesis of, 444 pure structural, 162
model, ideal, 492 Cooley, J., 143
modeling with #, 85 Core, 288
physical delay model, 493 Counter, 533:
with @, behavioral modeling, 89 up/down, 535

Combinatorial logic, registerportlist, 151
;,4 28 see Combinational logic cout, see carry out signal

Command, see command signal, signal cover task, 'ifdef for, 420
;on, 318, Command signal, 9: Cowles, J.R., 582

Mealy, 178 CPLD (Complex Programmable Logic
Moore, with Mealy <=, 266 Device), 439, 519:
multi-bit, 10 AND/OR structure of, 443
one bit, 9 CPU, (Central Processing Unit):
physical, 11 bit serial, 476

Comments in Verilog, 74, 459 multi-cycle, 294, 334, 391
Comparator, 511: peripheral and memory, 280

portlist, 153 pipelined, 354, 396
Computer architecture, superscalar, 381, 402

see Programmer's model Cray computer, 289
Computer: Cummings, Clifford, 564

architecture, 570 Cupal, J. J., 582
design, 1 Current page, 488
general purpose, 1, 277, 377 Cycle, see single-cycle and multi-cycle
history, 2, 277, 286
special purpose, 1, 7, 438 D

Concatenation, 68, 305-308 D type:
Condition, Verilog, 69 flip flop, 249, 530
Conditional, 178: register (delay type), 529

assignment of psr, 391 Data:
command, Verilog, 194 and stored program in memory, 280
execution: dependency, see Dependency

ARM, 385 forwarding, 360
childish division, 428 processing instructions, 382, see

loading, 184 also dp
operator (? :), 70, 257, 392 structure, 126

condx function, 390, 437 Datapath, see architecture
Constants, see Verilog constants DCA, 487
Continuous assignment, 255: Deadlock and scheduling process, 82

with one hot, 258 Debouncer, see Switch debouncer
Z87 Control dependencies, 362 Debugging display with @, 92

Controller, 20: DEC (Digital Equipment Corp.), 291,352,
division machine, 157 378
hierarchical refinement of, 167 Decision, implementation of, 332

Index 587



Decision: Dependency:
in ASM charts, 12 M

data, 359
time control within, pr

191 examples, 404
translated as one bit tw

wide demux, software, 26
250 Design:

Declaration, see also .doc, 
variable: 442

automation, 22, 438
event, 'DOUB, 

212 51
flow, synthesis, 439 'DOUBINC

function, 114 hierarchical, 52
inout, 551 dp function

Deterministic access time, 282 DSL, 442
input, 118 Devices, programmable, 518 Dual Inline
integer, 67 Diagram:

Dual rail de
output, 119 block and circuit, 54, 539
real, 115 Dynamic m

bus timing, 528
reg, 67, 119 timing, 526
task, 110 E

Diamond, 7,12, 13 ea, 
tri, 550 see effe

'DIFFERENCE, 511 Eckert, 
triand, 578 Johi

Digital:
EDSAC coI

trior, 578 building blocks, 6, 491, 525 EDVAC, 27
trireg, 578 design, 3
variable, EEPROM,'

67 electronics, 533
wand, 579 Effective ad

Digital Equipment Corp., see DEC
wire, else, 

67, 118-119, see 
494, 579: DIMMs (Dual In-line Memory Modules),

wor, Enabled 
579 reg

289
Decoder, 515 74xx3

Direct, 202:
Decoding instructions, 74xx3

297 addressing mode, 487
'DECREMENT, enabled_

511 current page, 488
default, 69, 116, 459 portlis

page zero, 292, 475
'define, 73 synth(

Directive, synthesis, 459
defparam, Encoder, 

570 51
disable:

Delay: end, 69
inside forever with bottom test-

inertial, endcase,
566 ing loop, 273

line, 288 endfunct
statement, 213, 273

propagation, see Endian nota
propagation delay Discrete electronic devices, 120

minimum/typical/maximum, endmodul
207 Division:

endspeci
rising/falling, 207 childish (see also: Childish division):
transport, endtask,

566 algorithm, 23 ENIAC, 
Delayed assignment, 271

12 with conditional instructions, 428
Demoboard (Vantis), see enterne

M4-128/64 combinational, 507
Demultiplexer, see 'EQU, 510

demux mixed two-state example, 271
Demux (demultiplexer), event, 21;

513: pure behavioral two state example, Event 
in memory, varial

284 270
misuse Example:

of, 514 machine:
translated from a behav

decision, 250 architecture, 154
depend function, ins

417 controller, 157

588 Verilog Digital Computer Design: Algorithms into Hardware

W __ -



Mealy version, 184 Mealy machine, 178
propagation delay in, 215 one hot Verilog, 270
two stage, pure structural state, dependency, 404

161 hierarchy, 57
.doc, 442 independent instructions, 357
'DOUB, 511 machine language program, 298
'DOUBINCR, 511 mixed, 40-41, 45-46:
dp function, 391 Mealy machine, 179
DSL, 442 one hot Verilog, 271
Dual Inline Package (DIP), 120 Moore command with Mealy <=,
Dual rail design, 503 266
Dynamic memory, 286, 555 netlist propagation delay, 200

one hot, 251
E pipeline, childish division, 368

ea, see effective address pure:
Eckert, John P., 278 behavioral, 22, 134, 143
EDSAC computer, 279 structural, 49
EDVAC, 278 quadratic evaluator:
EEPROM, 519 multi-cycle, 224
Effective address (ea), 292, 296, 303, 488 pipelined, 226
else,seeif else single cycle, 219

odules), Enabled register, 451, 531: real function, 115
74xx377 (8 bit), 151 special purpose renaming, 407,
74xx378(6 bit), 151 409

enabled-register: structural instance, 123
portlist, 151 structural Mealy machine, 180
synthesis of, 445 task, 110

Encoder, 517 traffic light:
end, 69 <=,97,98

)m test- endcase, 69 ASM chart, 8
endfunction, 114 behavioral Mealy, 178
Endian notation, 67 bottom testing loop, 189
endmodule, 118 computer, 1, 2, 97, 113
endspecify, 208 mixed Mealy, 180

livision): endtask, 110 structural Mealy, 180
ENIAC, 278, 287 task, 112

ions, 428 enternewstate task, 112 Execution:
'EQU, 510 parallel, 413

271 event, 212 pipeline, 413
xample, Event variables in Verilog, 212 speculative, 406, 413

Example: Exhaustive test, 66
behavioral exitcurrent-state, 580

instance, 121, 123 Explicit style, 99, 162-165, 472:
behavioral synthesis, 445

Index 589



switch debouncer, 472 one hot, 249 Goto-less:
versus implicit, 99 Flushing pipeline, 231 AS!\

Expression, 69 Font, 5
External: for, 69, 80, 85 styl

command output, 18 forever, 72, 106 Graphical
data: fork, 571 Ground,5

input in ASM, 16 Forrester, Jay W., 288
output, 18 Forwarding data, 360 I

External status, 14, 571 Four-state division machine, 134 Half-addei
input, 16 Four-valued logic, 77, 549 Handshaki

Extra state for interface, 312 FPGA (Field Programmable Gate Array), Hardware
443 Hardware:

F Friendly user, 24, 141 inde
Factory, analogy to pipeline, 227 Full: softl
Ferranti, 279 adder, 54 I
Fetch state, 390 case, 459 traw
Fetch/execute, 1: function, 109; 2

ASM for, 294, 304 car, 458 Harvard N
behavioral, 290 combinational logic, 115 Harvard v/
mixed, 324 condx, 390 Hazard, 2(
registers needed for, 292 depend, 417 HDL (Ha

Field Programmable Gate Array dp, 391 4,64
(FPGA), 443 state-gen, 163 Hennessy,

Fighting outputs, 78 syntax, 114 Hexagon,
Filling pipeline, 231 Hierarchic
Finite state machine, 8, see also ASM: G desil

ARM 388, 400, Gajski, Daniel D., 59, 247, 521, 541 nami
logic equation, 167-168 Gate level modeling, advanced, 207 refin
Mealy, 182, 184-185 Gate: Hierarchy:
Moore, 26, 30, 34, 39, 220, 224, instantiation in Verilog, 75 exan

232 non-tristate, 544 mei
netlist, 169 tristate, 545 a
PDP-8 294, 302, 333 General purpose computer, 1, 561: High impe
Verilog: benchmarks, 320, 351, 371, 431- High level

behavioral, 138-149, 186-188 432, 481 Highly spe
explicit, 472 bit serial, 476 History:
implicit, 258-265, 270-271,464, history, 277 CIS(

471 PDP-8, 485 coml
mixed, 158-159 pipelined, 354 gene
structural, 162-165 RISC and CISC, 475 mem

Flattened netlist, 54 structure, 279 pins
Flip flop: superscalar, 411 HLT, 490

D type, 249, 530 Glitch, 205 Hollerith, 
macrocell, 442 Goto, arbitrary, 194 Hopper, Li

590 Verilog Digital Computer Design: Algorithms into Hardware



Goto-less:
ASMs, translation to behavioral

Verilog, 99
style, 18 IAC, 489

Graphical notation, 59 IAS computer, 279
Ground, 539 IBM, 278

IEEE1364, 5, 559
H if:

4 Half-adder, 54 if (no else), 103
13

Handshaking, memory, 341-342 at the bottom of f orever, 108
3ate Array), Hardware Description Language, see HDL with one hot, 262

Hardware: if else, 101:
independent, 485 with one hot, 258
software tradeoff, see software 'ifdef for cover task, 420

hardware tradeoff Immediate operands, ARM, 387
translating algorithms into, 3, 7, 134, Implementation:

249 decisions:
Harvard Mark I, 278, 287 pipelined, 396

15 Harvard versus Princeton architecture, 379 superscalar, 402
Hazard, 205 implicit style, 99:
HDL (Hardware Description Language), limitations with Mealy, 580

4,64 synthesis macros, 462
Hennessy, John L., 247, 352, 375 versus explicit style, 99
Hexagon, 7, 12, 13 Implicit Verilog, 258-265, 270-271
Hierarchical: In-line memory models (SIMMs and

design, 54 DIMMs), 289
i21, 541 names, 125 'include, 73

ed, 207 refinement of the controller, 167 synthesizable, 441
Hierarchy: 'INCREMENT, 511

example, 57 Incrementor, 503
7,75

memory, 336: Independent:
architecture, 344 computations, 217

1, 561: High impedance, 77, 545 instructions, 357
,371, 431- High level language, 485 statements, 23

Highly specialized register, 540 Indirect:
History: addressing mode, 487

CISC versus RISC, 377 current page, 488
computer/digital technology, 2 Inertial delay, 566
general purpose computer, 277 Infinite loop, 100
memory technology, 286, 336 initial block, 70, 110
pins versus ports, 119 inout declaration, 551

HLT, 490 definition, 110
Hollerith, Herman, 277 port, 119,442
Hopper, Lt. Grace, 278 Input, ASM, 15-16

Index 591



__-GPI

input: JMP instruction, 309, 362, 487 MACHPR(
argument of task, 110 JMS, 487 Macro, 73:
port, 15, 118-119, 442 Joslin, R. D., 582 ARM
unused, 155-157, 538 implil

Instance: K sign 
behavioral, 118 Kilburn, Tom, 279-280, 287, 336 state 
structural, 118 macrocells,

Instantiation, 54: L Manchester
by name, 447 Latch, 459, 573 Mapping to
by position, 447 Lavington, S., 352 Mark I, see
module, 117 LDR, 436 Harvw
multiple gates, 75 Lee, James M., 130 Mask, VLS

Instruction: Line, 338 Mauchly, R
concatenation, 305 Little endian notation, 67 nib (memor
data processing, 382 Logic: McClendon
register (ir), 293, 308 combinational, 52, 89, 454, 491, 543 McNamara.
set, 291 equation approach, 167 Mealy, 398,

architecture, 573 four valued, 77 <= Wi
integer, 67, 71: gates in Verilog, 74 ASM.

declaration, 67: sequential, building blocks, 525 comir
in text code, 93 synchronous, 90, 445, 527 divisi,

Intel, 288, 314, 378 wire, 495 impli(
Interconnection errors four-valued Logical operators (&&, 11!, ), 13, 70, 509: machi

logic, 77 ALU, 509 non-b
Interface: Loop: single

extra states for, 312 bottom testing, 189: versus
push button, 25, 317, 469-471 disable inside forever, 273 Memory, 2E

Interleaved memory, 403 while, implicit style, 463 addre!
Internal status, 43, 573 Lovelace, Lady Augusta Ada, 277 rem
International Verilog Conference, 559 as a se
Interrupt, 376, 490 M asyncl
'INVALID, 416 M4-128/64, 558: buffer
IOF (interrupt off), 490 CPLD, 442 cache,
ION (interrupt on), 490 demoboard, 443, 470, 557 hit
Iowa State University, 3, 277 ma (memory address register), 219: mi
ir, see instruction register' multi-cycle, 224 tal
ISZ, 487,376,484 pipelining of, 229 gener

single cycle, 219 hands]
J Machine language: pa

Jacquard, 277 cache test, 339, 349 hieran
Jamesco, 557 childish division program, 318, 369, histor
Java, 1,6,381 424, 426, 429 interle
JEDEC format, 442 program, 298, 485 multi-
. ji , 442 R15 test, 422 non-b]

592 Verilog Digital Computer Design: Algorithms into Hardware

M I



r

MACHPRO, 442 reference instructions, 487, 490
Macro, 73: static versus dynamic, 286

ARM, 391 synchronous, 282:
implicit synthesis, 462 versus asynchronous, 282
sign extension, 393 virtual, 337
state names, 135 volatile versus non-volatile, 286

macrocells, 442 Methodical, 574:
Manchester Mark I, 279, 287, 475 architecture, 48
Mapping to specific pins, 453 MINC Inc., 442:
Mark I, see Manchester Mark I, address and website, 557

Harvard Mark I Minimum/typical/maximum delay, 207
Mask, VLSI, 438 Mixed, 20, 40, 154, 271:
Mauchly, John W., 278 fetch/execute, 324
mb (memory buffer register), 293 Mealy machine, example, 179
McClendon, Susan Taylor, 485, 487 two state division, 150, 271

[, 491, 543 McNamara, John E., 352 MLA, 437
Mealy, 398, see also conditional: Mnemonic, 485

<= with Moore command, 266 Model:
ASM, into behavioral Verilog, 186 advanced gate level, 207

.s5,2 5 commands to one hot, 266 actual gate level delay, 492
7 division machine, 181 behavioral combinational logic

implicit style limitations, 580 with @, 89
I,70, 509: machine, 7 combinational logic:

non-blocking assignment, 580 using a function, 115
single state ASMs, 196 with #, 85
versus Moore, 177 ideal combinational logic, 492

-ever, 273 Memory, 280: inadequate propagation delay, 209
53 address, see ma physical delay, 493
277 register, see ma reality, 491

as a separate actor, 312 synchronous logic controllers, 91
asynchronous, 285 synchronous registers, 90
buffer register, see mb worst case delay, 492
cache, 337: module, 54, see also port:

57 hit, 340 alul8l, 150
,219: miss, 339 behavioral instance, example,

tag, 337 121,123
general purpose computers, 280 comparator, 153
handshaking, 341 counter-register, 151

partial, 342 enabled-register, 151
hierarchy, 336 instantiated, 117

m, 318, 369, history of, 286 mux2, 153
interleaved, 403 nextstate logic, 162
multi-port, 372 port, structural Verilog, 117
non-blocking, 222 structural instance, example, 123

Index 593



_.MPI

supplied by PLDesigner-XL, 450 synthesized, 446, 448 usini
supplied by PLSynthesizer, 447 Neumann, John von, 3, 278
top level, with

117 Newell, A., 352
Moorby, with

Philip R., 4, 131 Next command, 268
Moore, C. with

Gordon, 288 Next state, 8, 50, 161-165 'ONES, 
Moore 51

machine, 7, 177: nextstatelogic module, 162 'OPA, 391
ASM to one hot, rules, 251 Node collapsing, 455 'OPB, 
command 391

signals with Mealy <=, Non-blocking assignment, 95, Open Veril
266 see also RTN

versus Mealy, addn
177 in one hot, 258-261 Operands:

Moore School at the U. of Pennsylvania, Mealy, 580 imm
278 implement Moore command, 266

Mudge, multi
J. C., 352 multi-cycle, 226 Operators,

MUL, 437 pipeline, 233 OR gate 
Multi-bit: in

rename, 406-410 'OR, 510
command signal, 10 synthesis, 464, 466-467 or gate, 74
input, 16 Non-default constant, 128 or sensitiv

Multi-cycle, 218: Non-deterministic access time, 282 Ordering pi
adder, 460 Non-memory reference instructions, 'ORNA, 
ARM, 51

388, 393 308, 486, 489 'ORNB, 
behavioral, 51

224 Non-tristate gate, use of switch, 544 Osborne, T
mixed, 238, 334 Non-volatile, 286 Oscilloscol
PDP-8, 315 NOP, 489 OSR, 
quadratic 308,

evaluator, 224 nor, 74 Out of orde
single cycle and pipeline com- 'NOR, 510 output:

pared, 217 not, 74, 169, 448
Multi-port argun

memory, 372 Notation, graphical and textual, 59, 275,
Multiple port,

ALUs, 403 see also ASM, RTN, input Output:
Multiple blocks, 81 'NOT, 510
Multiple port ASM

register file, 403 'NOTB, 510 exterr
Multiplexer, see mux notify, 575
Mux (multiplexer), cc

153, 502: notifO, 574
in division da

machine, 42 Noyce, Robert, 288 multi-
conditional operator ( :), 257 Nullify, 365 Oval, 7, 17,
using tristate buffers, 548

Overflow, 3
mux2 portlist, 153 0

Object oriented programming, 127 P
N One bit signal, see command signal, one bit Page:

nand, 74, 447 One hot, 249:
'NAND, currer

510 demux for decision, 250 zero, 
negedge, 88: from ASM, example, 251 Palnitkar, S.

use for behavioral memory, 222 from Moore ASM, 249 Parallel:
Netlist, 54, 168: from Verilog, 255 softw,

propagation delay, 200 machine with Mealy commands, 266 case.

594 Verilog Digital Computer Design: Algorithms into Hardware



using continuous assignment, 258 pipeline and speculative execution,
with if, 262 412
withif else,258 Parameter, 128-129
with while, 264 Partial handshaking protocol, 342

'ONES, 510 Pascal (language), 1, 4, 6, 115
e, 162 'OPA, 391, 403 Pascal, Blaise, 2, 277

'OPB, 391, 403 'PASSB, 510
Open Verilog International (OVI), 65: 'PASS, 510

address and website, 559 Path, 125
Operands: Patterson, David A., 247, 352, 375

immediate in ARM, 387 pb, see user interface, switch debouncer
mmand, 266 multiple, 380 pc (program counter), 293

Operators, 13, 70, 579 PDP-8, 291, 302, 314, 378:
OR gate in M4-128/64 macrocell, 442 addressing modes, 487
'OR, 510 bit serial, 475
or gate, 74, 169, 201, 448 block diagram, 335
or sensitivity list, 90 childish division, 318-320, 368,

, 282 Ordering processes #0, 87 481
ctions, 'ORNA, 510 compared to ARM, 383

'ORNB, 510 instruction subset, 291
h, 544 Osborne, T.E., 4 pipelined architecture, 374

Oscilloscope, 526 resources and websites, 560
OSR, 308, 490 synthesis and fabrication, 482
Out of order execution, 433 Peanuts, 23
output: Pentium, 314, 378

argument, 110 PERIOD parameter clock, 215
al, 59, 275, port, 15, 118, 442 Peripheral, 280
aput Output: Physical delay model, 493

ASM, 15, 17 .pi, 442
external: Pins:

command, 18 versus ports, 119
data, 18 mapping to specific, 453

multi-bit command, 10 Pipeline, 246, 354:
Oval, 7, 177 actions in parallel, 357
Overflow, 30, 385, 501 analogy, 227

architecture, 241
g, 127 P ARM, 396
signal, one bit Page: behavioral, 232

current, 488 filling and flushing, 231
50 zero, 488 implementation, 400
251 Palnitkar, S., 130, 247, 484, 554 ma, 229

Parallel: mixed, 241
software, 4 parallel and speculative execution,

ommands, 266 case, 459 413

Index 595



PDP-8: Primitive logical operations, 509
architecture, 374 R

Princeton versus Harvard architec- RI5 test pr(
illustration, 368 ture, 379 Radar signa

quadratic evaluator, 226 Princeton, Institute for Advanced RAL, 307,'
register, 241 Studies, 279 RAR, 306,d
single cycle, multi-cycle com- Problem with <= for RTN simulation, 96 RAW (read

pared, 217 Procedural assignment: 'RD, 391, 4
skip instructions, 365 blocking, 10 Read only n
stage, 241 non-blocking, 95 Read/write 

Place and route, 443, 494 Program: READY, ea
Planetary analogy, 492 cache test, 339 READY, usi
PLD, Complex, 520 childish division, 23, 316-319, real, 67, 1
PLDesigner-XL, 442, 558: 424, 426, 429 declar

modules supplied by, 450 counter, see pc and RI5 Real time, 8
technology mapping, 448 R15 test, 422 Rectangle, 7

PLSynthesizer, 442: status register, 384, see also psr @( po
modules supplied by, 447 Programmable devices, 518 one ho
using VITO code, 466 Programmer's model, 293, 382, 561 Reduction, 5

'PLUS, 511 Programming, object oriented, 127 Reference in
'POPA, 403, 416 Propagation delay, 199: memoi
'POPB, 416 abstracting of, 209 non-mi
Port: division machine, 215 reg, 67, lS

by name, 123, 447 inadequate models of, 209 Register, 13:
by position, 447 netlist, 200 behavii
external, 15 pipelined machine, 244 D type,
inout, 119, 442 Prosser, Franklin P., 60, 276, 352, 521, enable(
input, 118,442 541 file, 37
internal, 15 psr (program status register), 417: mu]
multiple, register file, 403 conditional assignment of, 391 highly:
output, 119,442 Pure, 56: model,
versus pin, 119 behavioral, 19, 22, 134, 143, 148, needed

Portlist: 270, 576 pipelin(
alul8l, 152 structural, 576 program
comparator, 153 controller, 162 read/wr
counterregister, 151 example, 49, 51 rename,
enabledregister, 151 stage, division machine, 161 shift, 52
mux2, 153 Push button, see User interface and synchro

posedge, 88,90, see also @( posedge Switch debouncer Transfei
sysclk) Transfer

Post synthesis simulation, 170 Q transfer,
'PRD, 403 Q output, 530 types, c]
Present state, 8, 50, 161-165: Quadratic evaluator, see Example, up coun

resetting of, 172 quadratic evaluator Relational ope

>=, !=),

596 Verilog Digital Computer Design: Algorithms into Hardware



R Relations in ASM, 13
R15 test program, 422 Rename register, 406
Radar signals, 288 rentag, 416
RAL, 307, 489 repeat, 576
RAR, 306, 489 Resetting the present state, 172
RAW (read after write), 417 Resource sharing, 462

ation, 96
'RD, 391, 403, 416 Response, 66
Read only memory (ROM), 518-519 Ripple carry adder, 457, 460
Read/write register, 552 RISC (Reduced Instruction Set
READY, early assertion of, 185 Computer), 378:
READY, user interface, 22, 272 processors, 561
real, 67, 115: versus CISC, 377

-319,
declaration, 67 Rising/falling delay, 207

Real time, 81 ROM (Read Only Memory), 519
Rectangle, 7, 8, 12: RTL, 489, 576

@ (posedge sysclk), 100 RTN (Register Transfer Notation), 11,
Iso psr

one hot flip flop, 249 see also non-blocking assignment:
Reduction, 576 interaction with decision,

,561 Reference instructions: 29-30
127 memory, 487 multi-cycle, 224

non-memory, 308, 489 parallelization, 36-37
reg, 67, 119 pipeline, 230
Register, 13: register renaming, 406-410

)9 behavioral synthesis of, 444 simulation with <=, 96
D type, 529 RTR, 489
enabled D-type, 531 Rutherford, Lord, 533

,52, 521,
file, 379:

multiple port, 403 S
417:

highly specialized, 540 Sample, Neal, 582
f, 391

model, 562 Scheduling processes and deadlock, 82
needed for fetch/execute, 292 Schulz, Charles, 23

143, 148, pipeline, 241 Scope rules, 125
program status, 384 SDF (Standard Delay File), 577
read/write, 552 Self-modifying program, 278. 376
rename, 406, 416 Sensitivity list, 90
shift, 536

line, 161 Separate actor, memory as, 312
synchronous, 90 Sequence versus $ time, 82

Hea nd Transfer Logic, 576-577 Sequential logic
Transfer Notation, see RTN building blocks, 525
transfer, 11, 13 non-blocking assignment, 564
types, choosing, 326 74xx163, 120
up counter, 533 74xx181, 510, 511

mple,
Relational operators (==, <, >, <=, 74xx377 (8 bit), 151

>=, !=), 13, 70 74xx378 (6 bit), 151

Index 597



Shift register, 462, 536 execution, 406
Shifter, 505-506 parallel and pipeline, 413 state-gE
Shuler, James D., 275, 558, 582 Speed and cost, 198, 496: Static mem,
Sign extension macro, 393 adder, 501 Status:
Signal, see Command, Command signal binary to unary decoder, 517 extern
Silicon foundry, 54 comparator, 512 intern
SIMMs (Single In-line Memory demux, 513 Sternheim, 1

Modules), 289 incrementor, 504 Stibitz. Geoj
Simulation, 64, 81: multiplier, 507 Stimulus, 65

post synthesis, 170, 440 mux, 502 STR, 436
timing analysis, 204 ripple carry, 501, 504 strength,

versus synthesis, 64 SSEC,278 StrongARM
Singh, Rajvir, 131, 375 State, 8, 306: Structural, 1,
Single accumulator, one address see also implicit, explicit and feature

instruction, 291 fnite state machine ASM instanc
Single alternative, 103 fetch, 390 exai
Single cycle: Statement, 69, 71:

adder, 460 $display, 72,420 moc
architecture, 235 $dumpf ile, 570 Mealy 
behavioral, 219 $fclose. 571 synthesi
multi-cycle and pipeline $fdisplay, 572 Verilog,

compared, 217 $finish, 99 sing]
quadratic evaluator, 219 $fopen, 571 versus b

Single pulsing and switch debouncing, $ fstrobe, 572 Structure, 126
469 $fwrite, 572 data, 12(

Single state Mealy ASMs, 196 $readmemb, 576 general I
Skip instructions, 310: $readmnemh, 576 pure, 22

pipeline, 365 $strobe, 566 Structured pro,
SKP, 490 $stop, 94 Style, implicit
Slater, Robert, 352 $write, 72, Subbus, 498, s,
SMA, 490 behavioral Subtractor, 

Verilog, 505
68

Smith, Douglas J., 131 case, 69,458-459 Sunburst Desig
SNA, 490 casex, 569 Superscalar, 38
SNL, 490 casez, 569 ARM, 40
Software: disable, 213 ASM,

dependency, ASM, 26 for, 69, 80, 85 Verilo
hardware tradeoff, 322, 371, 432, forever, 72,106 Switch, 543:

481 fork, 571 debouncei
Source code overview, 135 if, 103, 108 explici
SPA, 490 if else,101,258 implici
Special purpose computer, 1, 277: repeat, 576 non-tristat,

renaming, 407, 409 wait, 93, 136 register, 3(
specify block, 207 while, 72,104,463 tristate gat
Speculative: wire, 67, 118-119, 494, 579

598 Verilog Digital Computer Design: Algorithms into Hardware



state-gen function, 163 Synchonous:
Static memory, 286 hardware register, 11, 527
Status: logic, 527

external, 14, 571 controllers, 91
internal, 43, 573 memory, 282

Sternheim, Eliezer, 131, 375 registers, see Registers, syn-
Stibitz. George R., 278 chronous
Stimulus, 65 Synopsys, 509
STR, 436 Synthesis, 64, 466:
strength, 577 combinational adder, 454
StrongARM, 378 design flow, 439
Structural, 1, see also pure structural: directive, 459

features of Verilog, 74 enabled-register, 445
t and instance, 118, 130: implicit and explicit, 445
SM example of module defined implicit style:

with, 123 bit serial adder, 460
module defined by, 123 macros, 462

Mealy machine, example of, 180 PDP-8, 482
synthesis, 445, 474 structural, 445, 474
Verilog, modules and ports, 117: testing, 441

single bit tristate gate in, 545 versus simulation, 64
versus behavioral, 76 sysclk (system clock), 137, 525, 527,

Structure, 126: see also @( posedge sysclk)
data, 126 System:
general purpose computer, 279 clock simulation with #, 87
pure, 22 task, 72

Structured programming, 126 SZA, 490
Style, implicit versus explicit, 99 SZL, 490
Subbus, 498, see also Bus
Subtractor, 505 T
Sunburst Design, Inc., 564 TAD, 487
Superscalar, 381: Tag memory, 337

ARM, 402: task, 109-110
ASM, 411 Technology family, 543
Verilog, 417 Technology mapping PLDesigner-XL,

Switch, 543: 448
debouncer: Test bench, 420

explicit style, 472 Test code, 441, 578
implicit style, 469 adder, 455

non-tristate gate, 544 approaches, 441
register, 303 ARM, 430
tristate gate, 545 bit serial PDP-8, 479

division, 136
)4, 579 implicit style block, 464

Index 599



importance of, 141 buffer, 119 Variable:
role of, 65 bus driver symbol, 548 dech
state gen, 165 device, 543 lengi
xor, 86 gate, 545:

Test programs, eve]
422 structural Verilog, 545 int

Testbench, see test code uses, 548 4

Thomas, rea.
Donald E., 131 Trivedi, Yatin, 131, 375

Three stage pipeline, reg,
ASM for, 396 TTL logic family, 495, 533

Time: tri,
Turing, Alan, 277 wirE

access, 282 Turn off delay, 546 Vcc and gr
control, 83 Two state division: VCD (Valu

assignment with, 94 implicit Verilog, 270 Verilog:
within a decision, 191 machine:

real algori
81 behavioral stage, 148

'timescale, behav
448 mixed stage, 150, 271

Timing bit sei
analysis: structural stage, 161

a block
priori worst case, 202 Twos complementor, 504 catchi

simulation of, 204 Typography, 5
Timing comm

diagram, 526
comp,

Top down design, 19 U
Top level: co,

Unary code, 463, 515, 517 compe
module, 117 Unconditional command statement, 178
structure of the 76

machine, 313 Unidirectional Bus, 281, 493, 496
Torres consta

y Quevedo, Leonardo, 277 United States:
Traffic light example, noi

see Example, Air Force, 288 eveni
traffic light Department of Defense, 65 expres

Transistor, 3, 543 Navy, 278
Translating: Implic

UNIVAC, 279
algorithms 'inc]

into hardware, 3 University of Manchester, England, 279, logic g
complex ASMs into Verilog, 188 336 macros
conditional commands into Unknown value, 78 multi-c

Verilog, 194 Unused inputs, 538 pipeline
goto-less ASMs to behavioral Up counter register, 533 process

Verilog, 99 Up/down counter, 535 statemE
if at the bottom of forever, 108 User interface, 317:
Mealy structu

ASM to Verilog, 186 hardware, 25
Moore beh

ASM to one hot, 251 software, 317
Transport structure

delay, 566 User mode, 378
tri, 550 supersc

triand, synthes
578 V

trior, 578 translati
Vacuum tube, 2, 287, 495

trireg, 578 con
Vantis, 442, 557:

Tristate: fron
address and website, 557

as mux replacement, vendors
548 demoboard, see M4-128/64 versus 

600 Verilog Digital Computer Design: Algorithms into Hardware



Variable: wire, 74
declaration, 67 VerilogEASY, 557
length instruction set, 378 VeriWell Simulator, 556
event, 212 VHDL versus Verilog, 65
integer, 67,71 Virtual memory, 337
real, 67, 115 Virtual reality systems, 217
reg, 67, 119 VITO, 442,558:
tri, 550 preprocessor:
wire, 67, 118-119, 494 availability and website, 558

Vcc and ground, 539 generating an architecture, 467
VCD (Value Change Dump), 579 in synthesis, 466
Verilog: VLSI Technology, Inc., 434

algorithm for wire, 549 VLSI, mask, 438
behavioral code, 76 Volatile memory, 286
bit serial CPU, 476 Voltage, 495:
blocks, 70 active high and low, 495
catching errors, 140, 141
comments, 73 w
comparison with behavioral wait, 93, 136

code, 76 wand, 579
comparison with structural Verilog, Wayner, P., 352

nent, 178 76 Websites, 556- 560
496 constants, 73: Wellspring Solutions, address and

nondefault, 128 website, 556
event variables in, 212 while, 72, 104:

65 expressions, 69 with one hot, 264
Implicit to One Hot, see VITO Whirlwind computer (USAF), 288
'include, 73 Wilkes, Maurice, 279

gland, 279, logic gates, 74 Williams, Frederic, C. 279, 280, 287
macros, 73 Winkel, David E., 60, 276, 352, 521, 541
multi-cycle, 393 wire, 67, 118-119, 494, 579:
pipeline, 400 in one hot, 250
processing four valued logic, 549 Verilog, 74, 118:
statements legal in behavioral, 68 algorithm, 549
structural compared with Wirewrap supplies, 557

behavioral, 76 Wolf, Wayne, 352
structural features, 74 wor, 579
superscalar ARM, 417 Worst case:
synthesizable, 441 delay model, 492
translating: propagation delay, 506

conditional command, 194 timing analysis, a priori, 202
from ASM, 418 Write buffer, 437

57 vendors' websites, 560 Write-back cache, 344-345
28/64 versus VHDL, 65

Index 601



Write-through cache, 344-345
Wynn-Williams, C. E., 2, 277, 533

x
Xilinx, 443
xor, 74, 85, 201, 208
'XOR, 510

z
'ZERO, 510
Zuse, Konrad, 278, 287, 289

602 Verilog Digital Computer Design: Algorithms into Hardware



3If-0; ::141 * ie t |*4 * * 0 0 0~a.A - a'

i
i Keep Up-to-Date with

PH PTR Online!
We strive to stay on the cutting-edge of what's happening in
professional computer science and engineering. Here's a bit of what
you'll find when you stop by www.phptr.com:

0 Special interest areas offering our latest books, book series, software,
i features of the month, related links and other useful information to

help you get the job done.

Deals, deals, deals! Come to our promotions section for the latest
bargains offered to you exclusively from our retailers.

S 0fH eed to find a bookstore? Chances are, there's a bookseller near you
that carries a broad selection of PTR titles. Locate a Magnet bookstore
near you at www.phptr.com.

0t Ilhat's Hew at PH PTR? We don't just publish books for the professional
community, we're a part of it. Check out our convention schedule, join
an author chat, get the latest reviews and press releases on topics of
interest to you.

Subscribe Todaj! Join PH PTR's monthly email newsletter!

Want to be kept up-to-date on your area of interest? Choose a targeted
category on our website, and we'll keep you informed of the latest PH PTR
products, author events, reviews and conferences in your interest area.
Visit our mailroom to subscribe today! http://www.phptr.com/mail_lists

11,1T II-

L

I 0
M