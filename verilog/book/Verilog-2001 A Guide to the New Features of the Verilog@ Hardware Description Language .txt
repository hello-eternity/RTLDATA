    Verilog-2001 
  A Guide to the New Features of the 
Verilog@ Hardware Description Language 
  THE KLUWER INTERNATIONAL SERIES 
IN ENGINEERING AND   COMPUTER SCIENCE 
    V erilog-2001 
 A Guide ta the New Features of the 
Verilo~ Hardware Description Language 


          Stuart Sutherland 
         Sutherland HDL, Inc. 


      SPRINGER SCIENCE+BUSINESS MEDIA, LLC 
ISBN 978-1-4613-5691-2      ISBN 978-1-4615-1713-9 (eBook) 
DOI  10.1007/978-1-4615-1713-9 
 Library of Congress Cataloging-in-Publication Data 

 A C.I.P. Catalogue record for this book is available 
 from the Library of Congress. 

 Copyright © 2002 by Springer Science+Business Media New York 
Originally published by Kluwer Academic Publishers in 2002 
Softcover reprint ofthe hardcover Ist edition 2002 

 AU rights reserved. No part of this publication may be reproduced, stored in a 
 retrieval system or transmitted in any form or by any means, mechanical, photo•
 copying, recording, or otherwise, without the prior written permission of the 
 publisher. Springer Science+Business Media, LLC. 

 Verilog is a registered trademark of Cadence Design Systems, Inc. 
 Appendix A excerpts are reprinted with permission from the IEEE Std. 1364-2001 
 IEEE Standard for the Verilog® Hardware Description Language.ISBN 978-1-4613 
 -5691-2 .Copyright 2001 by the Institute of Electrical and Electronics Engineers, 
 Inc. (IEEE). The IEEE disclaims any responsibility or liability resulting from the 
 placement and use in this work. 

 Printed on acid-free paper. 
Dedication 


             To my wonderful wife, LeeAnn, 
          and my children: Ammon, Tamara, 
                 Hannah, Seth and Samuel 
                Table ofContents          


Foreword, by Phil Moorby . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 1 
Introduction ................................................. 3 
What's new in Verilog-2001 .................................... 7 
1. Combined port and data type declarations ...................... 8 
2. ANSI C style module declarations ........................... 10 
3. Module port parameter lists ................................ 12 
4. ANSI C style UDP declarations ............................. 14 
5. Variable initial value at declaration .......................... 16 
6. ANSI C style task/function declarations. . . . . . . . . . . . . . . . . . . . . .. 18 
7. Automatic (re-entrant) tasks ... . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 20 
8. Automatic (recursive) functions ............................. 22 
9. Constant functions ....................................... 24 
10. Comma separated sensitivity lists. . . . . . . . . . . . . . . . . . . . . . . . . . .. 26 
11. Combinational logic sensitivity lists. . . . . . . . . . . . . . . . . . . . . . . . .. 28 
12. Implicit nets for continuous assignments. . . . . . . . . . . . . . . . . . . . .. 32 
13. Disabling implicit net declarations . . . . . . . . . . . . . . . . . . . . . . . . . .. 34 
14. Variable vector part selects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 36 
15. Multidimensional arrays .................................. , 38 
16. Arrays of net and real data types ............................ 40 
17. Array bit and part selects .................................. 41 
18. Signed reg, net and port declarations ......................... 42 
19. Signed based integer numbers .............................. 44 
20. Signed functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 46 
21. Sign conversion system functions ........................... 48 
22. Arithmetic shift operators ................................. , 50 
23. Assignment width extension past 32 bits ...................... 52 
24. Power operator .......................................... 54 
25. Attributes .............................................. 56 
26. Sized and typed parameter constants ......................... 59 
27. Explicit in-line parameter redefinition ........................ 62 
28. Fixed local parameters .................................... 64 
29. Standard random number generator .......................... 66 
30. Extended number of open files . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 67 
31. Enhanced file 110 ........................................ 70 
32. String read and write system tasks ........................... 76 
33. Enhanced invocation option testing .......................... 78 
34. Enhanced conditional compilation . . . . . . . . . . . . . . . . . . . . . . . . . .. 80 
35. Source file and line compiler directive. . . . . . . . . . . . . . . . . . . . . . .. 82 
36. Generate blocks ......................................... 84 
37. Configurations .......................................... 90 
38. On-detect pulse error propagation ........................... 94 
39. Negative pulse detection .................................. , 96 
40. Enhanced input timing checks .............................. 98 
41. Negative input timing constraints. . . . . . . . . . . . . . . . . . . . . . . . . .. 100 
42. Enhanced SDF file support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 102 
43. Extended VCD files ..................................... 104 
44. Enhanced PLA system tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. 106 
45. Enhanced Verilog PLI support. . . . . . . . . . . . . . . . . . . . . . . . . . . .. 107 
Appendix A: Verilog-2001 formal definition. . . . . . . . . . . . . . . . . . . . .. 109 
Appendix B: Verilog-2001 reserved words ....................... 131 
Index ..................................................... 133 
                 Acknowledgments 


 I would like to express my gratitude to all those who have helped with this book. A 
 number of true Verilog experts have taken the time to review all or part of the text, 
and provide invaluable feedback on how to make the book useful and accurate. Thank 
you Stefen Boyd of Boyd Technology, Shalom Bresticker of Motorola Semiconduc•
tor Israel, Ted Elkind of Cadence Design Systems, Adam Krolnik of LSI Logic, 
 Roger Lutz of Model Technology, Mike McNamara of Verisity DeSign, Dhiraj Raj 
of Synopsys and Chris Spear of Synopsys, for taking the time to critique this book 
 and provide great suggestions. 

I would also like to express my appreciation to Phil Moorby of Co-design Automa•
tion, Inc., for writing the foreword. Phil created the original Verilog language in 1984. 

The IEEE 1364 Verilog Standard Working Group deserves special acknowledgement 
for their efforts in defining the Verilog-2001 standard. Following are the primary con•
tributors to the creation of the Verilog-2001 standard: Maqsoodul (Maq) Mannan 
(chair), Lynn Horobin (secretary), ~urt Baty, Stefen Boyd, Leigh Brady, Shalom 
Bresticker, Paul Colwill, Cliff Cummings, Debi Dalio, Charles Dawson, Tom 
Dewey, Ted Elkind, Tom Fitzpatrick, Naveen Gupta, Prabhakaran Krishnamur•
thy, Adam Krolnik, Andrew Lynch, James Markevitch, Mike McNamara, Steve 
Meyer, Anders Nordstrom, Karen Pieper, Girish Rao, David Roberts, Marek 
Ryniejski, Lukasz Senator, Steven Sharp, Chris Spear, Stuart Sutherland, Yatin 
Trivedi, and Steve Wadsworth. 

A special thank you goes to my wife, LeeAnn, for painstakingly wading through all 
the hardware engineering jargon in order to review the grammar, punctuation and 
sp~lling of the book (I'm sure I managed to insert a few more errors after her review). 

Finally, thank you Carl Harris and your staff at Kluwer Academic Publishers for 
your help with the complex process of bringing this book from concept to print. 

                                                  Stuart Sutherland 
                     About the Author 


                Mr. Stuart Sutherland is a member of the IEEE Verilog standards 
                committee, where he serves as chair of the Verilog PLI task force 
                and technical editor for the PLI sections of the IEEE Verilog stan•
                dard. He is also a member of the Accellera Verilog++ working 
                group, which is defining the next generation of the Verilog HDL. 
                Mr. Sutherland also serves as the program committee chair for the 
                annual International HDL Conference. 

 Mr. Sutherland has more than 17 years of experience in hardware design and over 13 
 years of experience with Verilog. He is the founder of Sutherland HDL Inc., located 
 in Portland Oregon. Sutherland HDL provides expert Verilog HDL and Verilog PLI 
 design services, including training, modeling, design verification and software tool 
 evaluation. Verilog training is one of the specialties of Sutherland HDL. Prior to 
 founding Sutherland HDL in 1992, Mr. Sutherland was employed as an engineer at 
 Sanders Display Products Division in New Hampshire, where he worked on high 
 speed graphics systems for the defense industry. In 1988, he became a senior applica•
 tions engineer for Gateway Design Automation, the founding company of Verilog. At 
 Gateway, which was acquired by Cadence Design Systems in 1989, Mr. Sutherland 
 specialized in training and support for logic simulation, timing analysis, fault simula•
 tion, and the Verilog PLI. Mr. Sutherland has also worked closely with several EDA 
 vendors to specify, test and bring to market Verilog simulation products. 

 Mr. Sutherland holds a Bachelor of Science in Computer Science, with an emphasis in 
 Electronic Engineering Technology, from Weber State University (Ogden, Utah) and 
Franklin Pierce College (Nashua, New Hampshire). He has taught Verilog engineer•
ing courses at the University of California, Santa Cruz (Santa Clara extension), and 
 has authored the popular "Verilog HDL Quick Reference Guide" and "Verilog PLI 
 Quick Reference Guide", as well as the authoritative 800 page "The Verilog PLI 
Handbook". He has presented tutorials and papers at the International Verilog Confer•
ence and at the International Cadence Users' Group Conference, and has won awards 
for best speaker and best tutorial. 

           visit the author's web page at www.sutherland-hdl.com 
                                                                        3 

                         Introduction 


 The IEEE Std. 1364-2001, nicknamed "Verilog-2001", is the latest update to the Ver•
 Hog Hardware Description Language and Verilog Programming Language Interface. 
 This new Verilog standard adds several significant enhancements to the previous gen•
 eration of Verilog, the IEEE std. 1364-1995, often called "Verilog-1995". This book 
presents 45 key enhancements contained in Verilog-2001 standard. These enhance•
 ments are essential for both those creating Verilog HDL models and those verifying 
 model functionality. All of the "top-five" enhancement requests for Verilog-1995 
 have been incorporated in Verilog-2001. The "top-five" requests are from a survey 
 conducted at the International HDL Conference held in 1996. The requests were: a 
 Verilog generate, multi-dimensional arrays, better file 110, re-entrant tasks, and 
 design configuration control. 

 The purpose of this book is to show what is new in the Verilog-2001 language. It is 
 assumed that the reader is already familiar with using Verilog. This book supplements 
 other excellent books on how to use the Verilog language, such as "Verilog Quick•
start: A Practical Guide to Simulation and Synthesis, 2nd Edition", by James Lee 
 (Kluwer Academic Publishers, ISBN 0-7923-8515-2) and "The Verilog Hardware 
Description Language, 4th edition", by Donald Thomas and Philip Moorby (Kluwer 
Academic Publishers (ISBN: 0-7923-8166-1). 

Caveat: This book does not attempt to convey the full IEEE standard for each 
enhancement  added in Verilog-2001. While the author has worked diligently to 
ensure that this book is accurate, the descriptions of the new features in Verilog-2001 
are based on the author's understanding. The final authority is the IEEE 1364-2001 
Verilog standard, along with any clarifications approved by the IEEE 1364 Verilog 
Standards Group. 

Why a Verilog-2001      Standard? 

The Verilog Hardware Description Language was first created in 1984. The type of 
hardware being designed at that time was primarily full custom ICs, low-speed and 
 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
4                Verilog-2001: A Guide to the New Features of the Verllog HDL 

density ASICs, circuit boards with discrete logic chips, and small PALs. When typical 
processes entered the sub micron sizes, Verilog evolved to meet the design require•
ments, with the addition of specify blocks and delay calculation. When synthesis tools 
adopted Verilog, and required zero-delay RTL models, Verilog evolved by adding 
non-blocking assignments, which model event propagation of zero-delay flip-flops 
the way a true flip-flop (with true delays) propagates logic changes. 

Today's designs are very deep sub micron, with millions of gates in size. The 
enhancements in Verilog-2001 aid in modeling verifying designs of this size and 
speed. The enhancements include simple changes to make it easier to  model large 
designs, changes to make modeling for synthesis more fool-proof, and changes to 
increase timing accuracy for very deep sub micron circuits. 

Simply stated, as what we are designing evolves, Verilog evolves to meet our needs. 

Verilog  Standards History 

1984: Startup company Gateway Design Automation (not the same company as Gate•
way Computer) began selling a digital simulator, first called "Verilog" and then "Ver•
ilog-XL". There were no standard digital hardware description languages at that time, 
so Gateway created a proprietary language intended solely for its simulator, called 
"Verilog" . 

1989: Gateway Design Automation was acquired by Cadence Design Systems. By 
then, the Verilog-XL simulator, with its proprietary Verilog language, had become 
one of the most popular simulators for ASIC design. Several companies had licensed 
the right to use the Verilog language independent of the Verilog-XL simulator, includ•
ing Synopsys, Logic Automation, and LMSI. 

1990: Cadence released the Verilog language to the public domain, to allow any soft•
ware company  to use the Verilog language, without requiring a special license. 
Cadence retained, and still sells, the Verilog-XL product. Open Verilog International 
(OVI) was formed to control and promote the use of the Verilog language. OVI 
labeled the public domain Verilog HDL as "Verilog HDL 1.0". 

1993: OVI released "Verilog HDL 2.0", which contained a few minor enhancements 
to the HDL, and a major change to the Verilog PLI. OVI then submitted a request to 
the IEEE to make Verilog an IEEE standard. 

1995: The IEEE released the "IEEE 1364-1995" Verilog standard. The primary goal 
of the Verilog Standard Group for Verilog-1995 was to standardize the way Verilog 
was used at that time. No enhancements to Verilog were considered for the 1995 stan•
dard. 
                                                                       5 

 2001: The IEEE ratified the "IEEE 1364-2001" Verilog-2001 standard. This latest 
 Verilog standard contains many major and minor enhancements to the Verilog HDL 
 and the Verilog PLI. Just a few are: extended signed arithmetic, re-entrant tasks, 
recursive functions, generate blocks, configurations, ANSI C style port declarations, 
 and many other enhancements. 

 200x: Work has already begun on the next generation of Verilog, under the auspices 
of the Accellera users' group. Accellera was formed in March, 2000 by the merger of 
 the Open Verilog International and VHDL International users' groups. This next gen•
eration of Verilog is very early in the specification process, but will very likely bring a 
new level of modeling abstraction to Verilog by incorporating much of the C language 
constructs such as structures, pointers and enumerated types directly into the Verilog 
language. Other powerful constructs such a hardware-centric assertions and interface 
modeling are also being considered. This combination of C and Verilog in one lan•
guage will enable greater integration of system level design and hardware design. For 
more  information on Accellera's work towards the next generation of Verilog, visit 
their web page at www.accellera.org. 
                                                                        7 

           Whats new in               Verilog-2001 


 The following sections explain 45 major enhancements that are in the Verilog-2001 
 standard. These enhancements can significantly improve the ease and accuracy of 
 modeling design using Verilog at the behavioral, RTL and gate levels. 

 The descriptions which follow are intended to introduce these new features in Ver•
 ilog-2001, along with ideas of how they can be useful in modeling and verifying 
designs. This book does not present the full syntactical and semantic detail for these 
enhancements-that is the role of the IEEE 1364-2001 standard. Software implemen•
 tors and those interested in exact syntax and semantics should refer to the IEEE stan•
dard for additional details on each of these 45 enhancements. Literally hundreds of 
clarifications to the 1364-1995 standard can also be found in the 1364-2001 standard. 
These clarifications do not add new functionality, and therefore are not covered in this 
 book. 

Synthesis support: The description of each enhancement includes a note on whether 
or not the enhancement should be supported by synthesis tools. This note is purely the 
opinion of the author, and does not reflect any existing synthesis products. The IEEE 
 1364-2001 standard does not currently define a synthesis subset of the Verilog lan•
guage. There is, however, an in-progress effort to define a synthesis subset for the 
Verilog HDL, as a proposed IEEE 1364.1 standard. Information on this proposed 
standard can be found at www.eda.org/vlog-synth. 


[Note: The enhancements are presented in an order that has closely related enhancements 
grouped together. Some enhancements affect several topics, however, making them difficult to 
list in a logical order. In general, enhancements that are primarily related to RTL modeling for 
simulation and synthesis are presented first. Enhancements that are more oriented to design 
verification and design management follow. Lastly, enhancements which affect deep sub 
micron timing and a few general enhancements are presented.] 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 8                Verilog-2001: A Guide to the New Features of the Verilog HDL 

 1.    Combined port and              data type 
       declarations 


 Background 

 Verilog-1995 requires two distinct sets of declaration statements in each module. The 
 first set defines information about the module ports, including the port vector size and 
 port direction. The second set of declarations defines the data type of signals within a 
 module, including the vector size of the signals. An example module declaration is: 

    module  adder  (sum, co,  a, b,  ci) ; 
      output   [31: 0]  swn; 
      output            co; 
      input    [31:0]   a, b; 
      input             ci; 

      reg      [31:0]   swn; 
      reg               eo; 
      wire     [31:0]   a, b; 
      wire              ei; 

 It should be noted that Verilog has a default data type of wire. In Verilog-1995, any 
 signal connected to a port of the module will default to a wire data type of the port 
 vector size, if the signal is also connected to a module instance or primitive instance, 
 or if the signal appears on the left-hand side of a continuous assignment. More infor•
 mation on the rules for the inference of implicit wire data types is presented in section 
 12 on page 32. 

What's   new 

    erilOg-2001 introduces an alternate, less verbose method of performing module 
 Vport and data type declarations, by allowing the two statements to be combined. 
The preceding example can be simplified in Verilog-2001 as follows: 

    module  adder  (sum, co,  a, b, ci) ; 
      output   reg    [31:0]   swn; 
      output   reg             eo; 
      input    wire   [31:0]   a, b; 
      input    wire            ei; 

 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Combined port and data type declarations                              9 

 This enhancement does not change model functionality. A signal connected to a port 
 of a module still needs both the port information and data type information defined. 
 This enhancement simply reduces the amount of code required to declare all the infor•
 mation. 

 Note that this enhancement does not affect implicit data types. If a port is declared but 
 no data type is specified, then under specific circumstances, the signal will default to 
 a wire data type. See section 12 on page 32 for details in when wires are inferred. 
The example shown in this section could be written as follows to take advantage of 
 the implicitly wire data types (assuming the contents of the module meet the require•
 ments for implicit wires): 

   module   adder  (surn, co, a, b, ci) ; 
      output   reg    [31:0]   swn; 
      output   reg             co; 
      input           [31:0]   a, b; 
      input                    oi; 

 Synthesis considerations 

This enhancement should be synthesizable. 
 10               Verilog-2001: A Guide to the New Features of the Verilog HDL 

 2.    ANSI     C style module declarations 


 Background 

 Much of the syntax and semantics of the Verilog language is similar to the C program•
 ming language. Because Verilog was originally created in the early 1980's, the style 
 of Verilog port lists follows the Kernighan and Ritchie style of C in use at that time. 
 That style is to list ports of the module (in C, the arguments of a function) within 
 parentheses, and to declare information about those ports (the function arguments in 
 C) within the body of the module (or C function). 

 In Verilog-1995, this means the name of a port may have to be listed three times: first 
 in the port list, second in the port declaration, and third in the data type declaration. 
 For example, the signal sum in the module declaration below is listed in three places 
 in order to completely declare the module port and data type: 

    module  adder  (sum, co,  a, b, ci); 
      output   [31:0]   sum; 
      output            co; 
      input    [31 : 0 ] a , b; 
      input             ci; 

      reg      [31: 0]  sum; 
      reg               co; 
      wire     [31: 0]  a, b; 
      wire              ci; 

    endmodule 

Listing the signal name three times can be tedious, considering that a name in Verilog 
can be quite long (all IEEE compliant software tools must support name lengths of at 
least 1024 characters). 

As noted with the enhancement on the previous page, Verilog has a default net data 
type of wire. Any signal connected to a port of the module will default to a wire 
data type of the port vector size, if the signal meets the requirements for inferring an 
implicit data type. This can save typing the data type declaration, but only if the 
default data type happens to be the desired data type. See section 12 on page 32 for 
details in when wire data types are inferred. 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
ANSI C style module declarations                                     11 

What's new 

    erilog-200 1 adds an alternate syntax that is similar to the ANSI C style of func•
Vtion declarations. With this new, alternate style, the declarations of the module 
ports can be combined within the port list, instead of after the port list. 
   module  adder  (output   [31:0]   sum, 
                   output            co, 
                   input    [31: 0]  a, 
                   input    [31:0]  b, 
                   input             cil; 

Combined port and data type declarations: 

The new Verilog-2001 enhancement for combined port and data type declaration dis•
cussed in the previous section can be used with ANSI C style port declarations. The 
example above can be simplified as follows: 
   module  adder  (output   reg    [31:0]  sum, 
                   output   reg            co, 
                   input    wire   [31:0]  a, 
                   input    wire   [31: 0] b, 
                   input    wire           cil; 

To further reduce verbosity, a comma separated list of declarations can be used with 
the ANSI C style of port declarations. All ports in the list will have the same direc•
tion, data type and vector size. The 32-bit inputs for a and b in previous example can 
also be declared as: 

   module  adder  (output   reg    [31:0]  sum, 
                   output   reg            co, 
                   input    wire   [31:0]  a,  b, 
                   input    wire           cil; 

As in Verilog 1995, explicitly declaring the data type is optional. The data type will 
default to a wire of the same vector size as the port, if the signal is also connected to 
a module instance or primitive instance, or if the signal appears on the left-hand side 
of a continuous assignment. The rules for the inference of implicit data types are pre•
sented in section 12, on page 32. 

Synthesis considerations 

This enhancement should be synthesizable. 
 12             Verilog-2001: A Guide to the New Features of the Verllog HDL 

 3.   Module port parameter lists 


 Background 

 With Verilog-1995, the size of Verilog vectors can be declared using Verilog parame•
 ters, which are run-time constants. A "parameterized" module can be redefined for 
 each instance of that module. Verilog syntax requires that the parameter be declared 
 prior to using it as part of a port declaration or data type declaration. 

 An example of a parameterized module in the older Verilog-1995 style is: 

   module adder  (sum, co, a, b, ci); 
     parameter IISB = 31, 
               LSB • 0; 
     output   [IISB:LSBj sum; 
     output             co; 
     input    [IISB:LSBj a, b; 
     input              ci; 

     reg      [IISB:LSBj sum; 
     reg                co; 
     wire     [HSB:LSB] a, b; 
     wire               ci; 

   endmodule 

What's new 

    eriIOg-2001 adds the ANSI C style module port declarations, as described in the 
 Vpreceding section. To support parameterized modules with the new ANSI C style 
port declarations, Verilog-2001 allows parameter declarations to be made before the 
module port list. The parameters are declared in a group that begins with a # ( token, 
and terminates with a  ) token. The module port parameter list must be declared 
before the module port list. 

The following example illustrates a parameterized module with the new ANSI C style 
port list: 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
Module port parameter lists                                                     13 


   module    adder   # (parameter   MSB  •  32,  LSB  .. 0) 
                     (output   reg     [MSB:LSB]     sum, 
                      output   reg                   co, 
                      input    wire    [MSB:LSB]     a,  b, 
                      input    wire                  ci, 

    endmodule 


    Note: Verilog-2001 adds another type of parameter, called a localparam. Verilog-
    2001 also allows specparam constants to be declared at a module level, instead of 
    only within specify blocks. Neither the localparam nor the specparam constant 
    can be used within the module port parameter list. 


Synthesis considerations 

This enhancement should be synthesizable. 
 14               Verilog-2001: A Guide to the New Features of the Verllog HDL 

 4.    ANSI     C style UDP declarations 


 Background 

 With Verilog-1995, the declaration of a User Defined Primitive (UDP) uses a Ker•
 nighan and Ritchie style of C for the port declarations, similar to the Verilog-1995 
 syntax for module declarations. The names of the ports of the primitive are listed 
 within parentheses, and the declaration of the ports is within the body of the primitive. 
 This means the name of a port may have to be listed two or three times: first in the 
 port list, second in the port declaration, and third in the data type declaration. With 
 Verilog primitives, only the output of a sequential UDP has a data type. All inputs do 
 not have a data type, and the output of a combinational UDP does not have a data 
 type. An example sequential UDP declaration for a D-type flip-flop is: 

    primitive  dff  (q, d, elk,  rst); 
      output  q, 
      input   d, elk,  rst; 

      reg q;    //sequential   logic UDP 

    endprimitive 


 What's new 

    eriIOg-2001 adds an alternate syntax that is similar to the ANSI C style of func•
 Vtion declarations. With this style, the declarations of a primitive port can be com•
bined within the port list. 

   primitive   dff  (output q, 
                     input  d, 
                     input  elk, 
                     input  rst); 

                     reg q;   //sequential  logic  UDP 

    endprimitive 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 ANSI C style UDP declarations                                        15 

 The primitive declarations can also take advantage of the combined port and data type 
 declarations that were presented in section 1. Therefore, the preceding example can 
 be simplified as: 

    primitive  dff  (output  reg Q, 
                     input  d,  elk,  rat); 

    endprimitive 

 Synthesis considerations 

This enhancement should not be synthesizable. Synthesis tools do not support UDP 
definitions. 
 16               Verilog-2001: A Guide to the New Features of the Verilog HDL 

 5.    Variable      initial value at declaration 


 Background 

 Verilog reg, integer, and time variables are uninitialized when simulation begins, 
 and have a logic value of X. Verilog real and real time variables have a value of 
 0.0 when simulation begins. 

 Verilog-1995 requires two statements to declare and set the initial value of variables. 

    module  test; 
      reg clock; 
      initial 
        clock  = 0; 

 The ini tial procedure in Verilog is not executed prior to simulation. It begins exe•
 cution at time zero, when simulation starts running, and is executed in parallel with 
 other initial or always procedures. When there are multiple initial procedures, 
 there is no defined order to the activation of the procedures. 

 What's new 

     eriIOg-2001 optionally allows variables to be assigned initial values as part of the 
 Vdeclaration of the variables. The example above can be simplified as: 

   module   test; 
      reg clock  = 0; 

Declaration initial value assignments are executed at time zero. The variable is not 
 initialized before simulation starts. The declaration initial value assignments are con•
current events which may occur in any order with other events scheduled for execu•
 tion at simulation time zero. There is no difference in specifying an initial value as 
part of the declaration or in an ini tial procedure. 

 Declaring an initial value for variables should not be confused with declaring an 
 implicit continuous assignment for nets.  Variable declaration assignments must be a 
 constant expression, and are executed one-time, at simulation time O. Net declaration 

 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Variable Initial value at declaration                                 17 

 assignments can be any type of expression, and are continuous assignments that eval•
 uate throughout simulation. 
    reg  r    l'b1;   Ilexecuted  once  at  simulation  time  0 
    wire w  = a + b;  Ilexecuted  continuously   throughout  simulation 

 Limitations 

 All variable types can have an initial value assigned as part of the declaration. How•
 ever, only variables declared at the module level may have initial values assigned. 
 Variables declared within tasks, functions, and named statement blocks cannot have 
 initial values assigned as part of the declaration. 

 Combined    port/data type declaration and variable initialization 

 Verilog-2001 adds the alternate declaration style where the port direction and data 
 type declaration can be combined into the same statement. This alternate style is dis•
 cussed in section I, on page 8. Variable data types can have an initial value assigned 
 at the same time, as shown below: 
    module  add32  (sum, ci,  a, b, ci); 
      output  reg  [31:0)   sum = 0; 
      output  reg          co     0; 
      input   wire  [31:0) a,  b; 
      input   wire         ci; 

 Combined ANSI     C style ports and variable initial assignment 

Verilog-2001 provides the ANSI C style port declarations, discussed in sections 2 and 
4. This alternate port declaration syntax allows the data type of signals to be declared 
in the module or UDP port list. Variable data types can have an initial value assigned 
at the same time. The following two examples utilize this ability. 
   module  add32   (output reg  [31:0]   sum •  0, 
                   output  reg           co  •  0, 
                   input   wire  [31:0)  a, b, 
                   input   wire          ci); 

   primitive   dff  (output reg  q  • 0, 
                     input  d,  clk, rst); 

SyntheSiS considerations 

This enhancement should be ignored by synthesis, possibly with a warning message. 
Synthesis does not utilize the logic value of variables. 
18               Verilog-2001: A Guide to the New Features of the Verllog HDL 

6.    ANSI     C style task/function declarations 


Background 

Verilog-1995 uses a style for declaring tasks and functions that is unlike either the C 
language or Verilog module declarations. The declaration of the task or function name 
is not followed by the argument list for inputs and outputs. Instead, the declaration 
ends with a semicolon immediately after the name of the task or function. The inputs 
and outputs of the task or function are declared within the body of the task or func•
tion. The order of the declarations establishes the order in which arguments are passed 
in and out of the task or into the function (functions can only have inputs). An exam•
ple of defining and calling a task is: 

   module  test; 

     task  check_result;          Iltask  declaration 
       input   [63:0]  result;       Ildeclaration order   dete~ines 
       input   [63:0]  expected;     II order  or arguments 
       output          OK; 

     endtask 

     always  @(negedge  clock) 
       check_result(data,    test_value,  passed);    Iltask call 

   endmodule 

What's new 

    eriIOg-2001 introduces an alternate syntax for the declaration of tasks and func•
Vtions which is consistent with the Verilog-2001 syntax for ANSI C style module 
declarations. Task and functions can be declared with the same ANSI C style. For 
example: 

   task check_result   (input   [63:0]  result, 
                        input   [63:0]  expected, 
                        output          OK ); 

   endtask 

S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
ANSI C style task/function declarations                              19 

The ANSI C style task or function I/O declarations clearly documents the order in 
which arguments are passed in and out of the task. The syntax is consistent with the C 
language and with the Verilog-2001 style of module declarations. 

Combined port and data type declarations: 

Verilog task/function inputs and outputs are inferred to be of type reg if no internal 
data types for the ports are declared. The inputs and outputs of a task or function can 
also be explicitly declared to be any variable data type. The new Verilog-2001 
enhancement for combined port and data type declaration can also be used for task/ 
function declarations. This enhancement is discussed in section I, on page 8. 

This Verilog-1995 style ofa function declaration: 

   function  real  fp_alu; 
     input  rl, r2; 
     input  opcode; 
     real   rl, r2; 
     integer  opcode; 

   endfunction 

Can now be declared as: 

   function  real  fp_alu  (input real  rl,  r2, 
                            input integer  opcode); 

   endfunction 

Synthesis considerations 

This enhancement should be synthesizable. 
 20               Verilog-2001: A Guide to the New Features of the Verilog HDL 

 7.    Automatic (re-entrant) tasks 


 Background 

 Verilog-1995 specifically states that tasks are static. For each instance of a module, 
 any storage within tasks is allocated once, and maintained throughout simulation. 
 This includes storage for any inferred reg variables for task inputs and outputs. 
 Within a module instance, every call to a task will use the same memory space. All 
 variables in a static task are maintained throughout simulation, and will retain their 
 values from one call to another. 

 Verilog models have concurrency, which means two concurrent procedures can call 
 the same task. Since a task can have delays and simulation time controls, the task can 
 take simulation time to execute. This means a call to a task can be invoked while the 
 task is already being executed from some other concurrent call. Because the task is 
 static, the second call to the task will clobber the storage being used by the concurrent 
 call to the task. 

 In Verilog-1995, the work-around to be able to concurrently call static tasks is to 
 place the task functionality in a separate module, and instantiate the module multiple 
 times. Even though a task is static, each instance of the module containing the task is 
 unique, and new storage will be allocated for each module instance. This approach, 
 however, requires additional coding, and requires knowing how many concurrent 
calls to the task there will be. 

 What's new 

    eri10g-2001 allows tasks to be declared as automatic. Automatic tasks dynami•
 Vcally allocate new storage each time the task is called, and release the storage 
 when the task exits-there is no retention from one call of the task to another, as there 
 is in static tasks. By declaring a task as automatic, there is no danger of two concur•
rent calls to the same task interfering with each other. The following example illus•
 trates a simple case where using automatic tasks can simplify modeling a test bench. 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Automatic (re-entrant) tasks                                         21 


    module  test; 

      always  @(posedge  instruction_fetch) 
        fork 
          watchdog_timer;     //start  watchdog  timer  task 
          begin 
             ...  //initiate  test 
             disable  watchdog_timer;    //test  complete 
           end 
        join 

      always  @(posedge  data_fetch) 
        fork 
          watchdog_timer;     //start  watchdog  timer  task 
          begin 
             ... //initiate   test 
             disable  watchdog_timer;    //test  complete 
          end 
        join 

      task  automatic  watchdog_timer; 
        integer  i; 
        begin 
           for (i = 0;  i <  1000; i  = i + 1) 
             @(posedge  clock)  ; //count  clock  cycles 
          $display("TIME   OUT  ERROR");  $stop; 
        end 
      endtask 
    endmodule 

Limitations: Because automatic tasks release internal storage upon exit, the storage 
of the task cannot be used in any context that could potentially read the value of the 
storage after the task has exited. This restriction means the inputs, outputs, and any 
internal variables of an automatic task: 
• Cannot be assigned values using non-blocking assignments. 
• Cannot be read by intra-assignment event controls of non-blocking assignments. 
• Cannot be assigned values using procedural continuous assignments. 
• Cannot be read by procedural continuous assignments. 
• Cannot be read by procedural force statements. 
• Cannot be traced with system tasks such as $moni tor and $dumpvars. 

SyntheSiS considerations 

This enhancement may not be synthesizable. 
 22               Verilog-2001: A Guide to the New Features of the Verilog HDL 

 8.    Automatic (recursive) functions 


 Background 

 In Verilog-1995, functions are static, just as tasks are. Static functions allocate mem•
 ory for the inputs of the function, the return of the function, and any internal variables 
 one time, and maintain the storage throughout simulation. All calls to a function 
 within a module instance share the same storage space. Since Verilog functions are 
 required to execute in zero simulation time, there are no issues with concurrent calls 
 to functions-it cannot happen. There is an issue if a function recursively calls itself, 
 however. Each subsequent call will overwrite the storage of previous calls. 

 In Verilog-1995, the following example will not work. Each recursive call to the func•
 tion shares the storage of its parent call, and will destroy the values stored in the par•
 ent call. 

    function  [6310)  factorial; 
      input  [31:01  n; 
      if (n  == 1) 
        factorial     1; 
      else 
        factorial.    n * factorial(n-l);   Ilrecursive   call  to self 
    endfunction 

 What's new 

    eriIOg-2001 allows functions to be declared as automatic. Automatic functions 
 Vallocate new storage each time the function is called, and deallocate the storage 
when the function exits. If a function recursively calls itself, the storage of the calling 
function is pushed onto a stack and is popped off of the stack when the recursive call 
returns. 

The following example illustrates using recursive calls to an automatic function. 


S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Automatic (recursive) functions                                      23 


    function  automatic  [63:0]  factorial; 
      input  [31:0]  n; 
      if (n  == 1) 
        factorial     1; 
      else 
        factorial  =  D * factorial(D-l);   Ilrecursive   call  to self 
    endfunction 

Automatic functions have restrictions on how the storage of the function can be 
accessed. Since an automatic function releases internal storage upon exit, function 
inputs, internal variables, and the name of an automatic function: 

• Cannot be traced with system tasks such as $moni tor and $dumpvars. 
• Cannot be hierarchically referenced. 
• Cannot be viewed in a waveform display or other tools which access information 
  through hierarchy scopes. 

Note, however, the Verilog Programming  Language Interface (PLI) has been 
enhanced in Verilog-2001 so that it can access the storage for all recursive function 
calls of an automatic function that are currently on the stack. 

Synthesis considerations 

This enhancement should be synthesizable, but, similar to loop constructs, synthesis 
must be able to statically determine how many levels of recursive calls will occur. 
24               Verilog-2001: A Guide to the New Features of the Verilog HDL 

9.    Constant functions 


Background 

In Verilog-1995, a function can only be called in places where a non-constant expres•
sion can be used. There are several places in Verilog syntax that require a constant 
expression. Two examples are the most-significant and least-significant bits in a vec•
tor declaration, and the starting and ending address of an array: 
   module  ram  ( ... ); 
     parameter  WIDTH  = 10; 
     parameter  SIZE     1024; 
     input  [WIDTH-1:0)  address_bus;     //must  be a  constant  expr. 
     reg  [WIDTH-1:0)  core  [0:SIZE-1);  //must  be a  constant  expr. 

In this example, it would be convenient to calculate the width of address_bus based 
on the size of the RAM. This would involve the use of programming statements, how•
ever. With Verilog-1995, the restrictions of constant expressions in declarations do 
not permit the use of programming statements to calculate more complex values. 

What's  new 

   erilog-2001 recognizes a special class of functions, called constant/unctions. A 
Vconstant function can be called any place a constant expression value is required. 
Since the function can use programming statements, this enhancement makes it possi•
ble to use complex formulas to calculate the widths of vectors, the sizes of arrays, and 
in other places where the Verilog syntax requires a constant expression. An example 
of using a constant function is: 
  module   ram ( ... ); 
     parameter  SIZE  = 1024; 
     input  [clogb2(SIZE)-1:0)   address_bus;    //must  be constant 

     function  integer  clogb2  (input  integer  depth); 
       begin 
         for(clogb2=O;   depth>O;  clogb2-clogb2+1) 
            depth  • depth  »  1; 
       end 
     endfunction 
   endmodu1e 

S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Constant functions                                                   25 

 Constant functions do not add any new reserved keywords to the Verilog HDL. A 
 constant function is a regular Verilog HDL function, but with restrictions on the func•
 tion contents. These restriction allow the function to be evaluated at elaboration time, 
 without any dependence on simulation run-time values. The restrictions for constant 
 functions are: 
 • The values passed into the function must be constant expressions, such as a literal 
   value or a parameter constant. Variable and net data types cannot be passed into a 
  constant function. 
 • Only parameters, localparams, other constant functions, and locally declared vari•
  ables can be referenced within the function. 
 • Parameters used within the function must be declared before the function is called. 
 • Parameters used by the function should not be redefined using defparam state•
  ments. Using defparam redefinitions may result in an ambiguous return value. 
  That is, different simulators may return different values. Parameters can, however, 
  be redefined using module instance in-line parameter redefinition without the risk 
  of ambiguity (in-line parameter redefinition is discussed in more detail in section 
  27, on page 62). 
 •  A constant function cannot call a system function (such as $random or $time). 
  Calls to system tasks (such as $display) are ignored. 
•  A constant function cannot use hierarchical path references. 

Note that when a constant function is called at elaboration time, any internal storage 
is not retained after elaboration. When simulation starts, it will be as if the function 
has never been called. 

Synthesis considerations 

This enhancement should be synthesizable. 
26               Verllog-2001: A Guide to the New Features of the Verllog HDL 

10.   Comma separated sensitivity lists 


Background 

The @«list_oCsignals»      construct in the Verilog HDL is used to control the 
execution of procedural statements in a Verilog ini t ial or always procedure. This 
construct delays the execution of the next statement until any signal in the list changes 
value. The list of signals is often referred to as a "sensitivity list", because the execu•
tion of the next statement is sensitive to when signals in the list change. 

With Verilog-1995 and earlier generations of the Verilog standard, multiple signals in 
the sensitivity list were separated with the keyword or. Two examples are: 

   always  @(a or  b or ci) 
     sum  = a + b  + ci; 

   always  @(posedge  clock  or negedge  reset) 
     if (!reset) 
       q  <= 0; 
     else 
       q  <= d; 

This usage of the keyword or has been a source of confusion for Verilog users. There 
are many places in the Verilog language where there may be a list of signals, such as 
in a module port list, or a data type declaration statement. In every case except a sen•
sitivity list, the list of signals is separated by a comma. The only place the word or is 
used as a separator is in the @«list_of_signals». In the context of a Verilog 
sensitivity list, the or keyword is simply a separator between two signals. But, to a 
person not familiar with Verilog, the or-separated list may look like the multiple sig•
nals are being bit-wise or-ed together. This is not the case. There is no operation being 
performed in the sensitivity list, it is merely a list of signals. 

What's   new 

    erilOg-2001 allows a  comma   to  be  used  as  a  separator in  the 
V@«list_ot_signals»        sensitivity list. The preceding examples can now be 
written as: 


S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Comma separated sensitivity lists                                    27 


    always  @(a, b,  ci) 
      sum =  a + b  + ci; 

    always  @(posedge  clock,  negedge  reset) 
      if  (!reset) 
        q <=  0; 
      else 
        q <=  d; 

This new, alternate syntax makes the sensitivity list syntax consistent with the syntax 
for other lists of signals in the Verilog language. The old or-separated list can still be 
used, if desired. It is also permissible to inter-mix the or-separators and comma-sepa•
rators in the same list, but this style is discouraged, as it would make the source code 
confusing to read. 

Synthesis considerations 

This enhancement should be synthesizable. 
28               Verilog-2001: A Guide to the New Features of the Verilog HDL 

11.   Combinational logic sensitivity lists 


Background 

In hardware, combinational logic outputs reflect the values of the inputs to that block 
of logic. There is no storage in combinational logic, so each time any input changes, 
the output may be affected. To properly model the behavior of combinational logic 
using a Verilog always procedure requires using an @«list_of_signals» con•
struct at the very beginning of the procedure. The list of signals must include every 
input to that block of combinational logic. An input to the logic is any signal whose 
value may be read by that procedure. Two examples of a simple block of combina•
tionallogic modeled using a Verilog always procedure are: 

   always  @(a or b  or sell 
     if (sel) 
       y  = a; 
     else 
       y  = b; 

   always  @(b or c  or d or  e or f  or g or  i or j or  s or x  or z) 
     begin 
       alb]  = s?c[d] :e[f]; 
       a[g]  = funcl(i[j],{x,z}); 
     end 

With Verilog-1995, the burden is on the engineer writing the Verilog model to deter•
mine what signals are being read by the procedure, and then correctly list those sig•
nals in the sensitivity list. If a signal is inadvertently omitted from the sensitivity list, 
that block of logic will not behave like combinational logic in simulation. 

Synthesis tools, however, may infer combinational logic even when the sensitivity list 
is incomplete. This difference in how simulation and synthesis interpret the Verilog 
source code can cause mismatches in pre-synthesis simulations and post-synthesis 
simulations. Large, complex blocks of combinational logic may have dozens of 
inputs. It can be an easy error to inadvertently leave a signal out of the sensitivity list. 
This can lead to bugs in a hardware design that are difficult to find. 


S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Combinational logic sensitivity lists                                29 

 What's new 

     erilOg-2001 adds two special tokens to the Verilog language, @* and @(*). These 
 Vnew tokens relieve the engineer creating a Verilog model of the burden of deter•
 mining what signals need to be in the sensitivity list to properly model combinational 
 logic. The @* and @( *) tokens place the burden of determining the sensitivity list 
 onto the simulator or synthesis tool (or whatever other software tool is reading the 
 Verilog source code). These special tokens direct the software tool to automatically be 
 sensitive to any change on any signal that may be read by the following statement or 
 statement group. 

 There is no difference between @* and @( *); both tokens represent the exact same 
 behavior. Using either of these tokens, the examples on the previous page can be sim•
 plified as: 

    always @* 
      if (se1) 
        y =  &; 
      else 
        y =  b; 

   always  @(*) 
      begin 
        alb]    s?c[d] :e[f]; 
        a[g]    func1 (i [j] , {x, z} ) ; 
      end 

With the @* or @( *) tokens, no matter how large and complex the block of combina•
tional logic, pre-synthesis and post-synthesis results should match. Both simulator 
and synthesis tools are required to be sensitive to any signal that may be read by the 
statement or begin-end group of statements that follows. 

Possible misuse of the    @*  and  @(*) tokens 

The @ event control token in Verilog is associated with the statement or statement 
group that follows the control. It is not associated with the always keyword. Con•
sider the following procedure: 

   always  @(*) 
      sum = &  + b + c; 

The @( *) in this example is equivalent to @(& or b or c). It is a misconception to 
interpret the @ event control as: "always at a change on a or b or c, execute the 
 30               Verilog-2001: A Guide to the New Features of the Verllog HDL 

 assignment statement". The actual behavior is: "repetitively do the statement, where 
 the statement is wait for a or b or c to change, and then execute the assignment". 

 This distinction is critical to understanding how to correctly use the @* and @( *) con•
 structs. These tokens are only sensitive to the signals which are read by the next state•
 ment or statement group. In the context of: 

    always  @*                //correct  usage 
      begin 
        sum  = a + b; 
        prod  = c *  sum; 
      end 

The  next thing following the @ token is the begin-end statement group. The @* 
token will be sensitive to any signals which are read between the begin-end key•
 words, which are a, b, c and sum. Thus, the token is sensitive to changes on every sig•
 nal read in the procedure, which is the behavior of combinational logic. Placing the 
@*  or @( *) tokens at the very beginning of an always procedure is the intended 
 usage of these tokens. 

 Syntactically, however, the @* and @( *) tokens can be used anywhere the @ construct 
can be used. This means the @* and @( *) tokens can be placed within a statement 
group, instead of before the group. For example: 

    always 
      begin  @*               //incorrect  usage 
        sum  = a + b; 
        prod  = c *  sum; 
      end 

The @ (*) token is only sensitive to changes in signals read by the next statement, 
which are a and b. The token is not sensitive to changes in any other signals read 
within the procedure (c and sum, in this example). In simulation, this example would 
not behave like combinational logic. To behave like combinational logic, the addition 
and multiplication statements should be evaluated whenever any of the inputs change. 
In the preceding example, however, c might change dozens of times, and the product 
will not be re-evaluated. 

This last example is not using the @* token in the way with which it is intended. 
While syntactically allowable, it does not model the behavior of combinational logic. 
It is only when the @* or @( *) tokens are placed at the very beginning of a procedure, 
before the single statement or begin-end block in the procedure that these tokens 
represent combinational logic sensitivity. 

Another potential misuse of the @* and @(*) tokens is within an intra-assignment 
delay. The following example is syntactically allowed, but does not represent the 
 Combinational logic sensitivity lists                                31 


 behavior of real hardware. The @ ( *) token will be interpreted as @ (a or b). The 
 statement will evaluate a + b immediately, delay until there have been three consecu•
 tive changes on a or b, and then assign the value of the original evaluation to y. 

    always 
      y <=  repeat  (3) @(*)  a + b;   //incorrect  usage  of  @ 


 The syntax above is allowed because the @ event control token itself can be useful in 
 this context-with a proper sensitivity list. The following example models a simple 
 pipeline, where a + b is evaluated immediately, and assigned to y after three clock 
 cycles, creating a three stage pipeline. 

    always 
      y <= repeat  (3) @(posedge   elk) a  + b;  //correct usage   of @ 

 The IEEE 1364 standards group considered placing syntactic restrictions on the usage 
 of the @* lind @( *) tokens. The group decided against this because it would not be 
 consistent with the rest of the Verilog language, and associating the tokens to the 
 always statement instead of the following statement or statement group would create 
 an entirely different semantic than the existing @ token. Most, if not all constructs in 
the Verilog language can be misused. This freedom in the syntax is not unique to the 
@* and @ (*) tokens. A basic principle of a hardware modeling language is that the 
user must be allowed to model something that will not work properly, and through 
simulation or other analysis, prove that it does not work. It is the role of rule checkers 
and other tools to impose style restrictions on the usage of Verilog. 

Synthesis considerations 

This enhancement should be synthesizable, though probably with a restriction that the 
@* or @( *) tokens may only be used as a sensitivity list at the very beginning of a 
procedure, the same way the@«list_of_signals»   is restricted by synthesis. 
32               Verilog-2001: A Guide to the New Features of the Verilog HDL 

12.   Implicit nets for continuous assignments 


Background 

Verilog-1995 will implicitly infer a net data type for a signal in any of the following 
situations: 
• When a signal name appears in the connections to an instance of a module. 
• When a signal name appears in the connections to an instance of a primitive. 
• When a signal name is on the left-hand side of a continuous assignment and the 
 same signal name is declared as an input, output or inout port of the module con•
 taining the assignment. 

For any of the above circumstances, the vector width of the net will be the width of 
the port declaration, if the undeclared signal is connected to a port of the module. The 
net will be scalar (l-bit wide) if the undeclared signal is not connected to a port of the 
module. 

The default data type of implicitly inferred nets is wire. This default can be modified 
with the' defaul t_nettype compiler directive to be any other net data type. 

Based on these Verilog-1995 rules, the following example would produce an error on 
the fifth line, because the signal on the left-hand side of the continuous assignment is 
not connected to a port of the module. 

   module  mult32  (y, a, b); 
     output  [63:0]  y; 
     input   [31:0]  a, b; 
     assign  y     a * b;     Iidefaults  to wire,  width  of port  y 
     assign  eQ = (a  == b);  /IERROR:  'eQ' not  declared 
   endmodule 

What's new 

    eri10g-2001 relaxes the conditions for the third rule outlined above. A net data 
Vtype will be inferred for any undeclared signal name that appears on the left-hand 
side of a continuous assignment, regardless of whether or not it is connected to a port 
of that module. The width of the inferred net will follow the same rules as in Verilog-

S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
Implicit nets for continuous assignments                             33 

1995. The net will be the width of the module port, if connected to a port of the mod•
ule. The net will be scalar (I-bit wide) if not connected to a module port. 

Using this new rule, the example on the preceding page will compile without an error. 
The undeclared signal eq will default to a net data type. The vector size of the net will 
be I-bit, because it is not connected to a port of the module containing the assign•
ment. 

Synthesis considerations 

This enhancement should be synthesizable. 
34               Verilog-2001: A Guide to the New Features of the Verilog HDL 

13.   Disabling implicit net declarations 


Background 

Verilog-1995 automaticaUy infers net data types in the following circumstances: 
• When a signal name appears in the connections to an instance of a module. 
• When a signal name appears in the connections to an instance of a primitive. 
• When a signal name is on the left-hand side of a continuous assignment and the 
  same signal name is declared as an input, output or inout port of the module con•
  taining the assignment (Verilog-2001 removes the requirement that the left-hand 
  signal be connected to a module port). 

The default data type of implicitly inferred nets is wire. This default can be modified 
with the 'default_nettype compiler directive to be any other net data type. The 
argument to this compiler directive is any of the net data type keywords. for example: 

   'default_nettype   wor    //inferred nets   have EeL  resolution 

The inference of nets can be a great time saver when creating Verilog modules, 
because only variable data types and internal vectors need to be declared. Most net 
declarations can be inferred rather than explicitly declared. However, the inference of 
net data types can also introduce bugs in a design that may be difficult to find. In the 
following example, there are three problems in the module, due to mis-typed signal 
names. With Verilog-1995, these invalid signal names will automatically infer nets, 
and so the module will compile, even though there are errors. 

   module  bad_chip  (01, nO,  nl); 
     output  01; 
     input   nO, nl; 

     wire    01; 
     wire    nO, nl; 

     and  (01, nO,  nl);   Ilthere are  3 typos  in this  linel 

   endmodule 


S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Disabling Implicit net declarations                                  35 


 The typos are that the ports and data type declarations declare the signals 01 ("oh•
 one") nO ("enn-zero") and n1 ("enn-one"), but the and primitive uses 01 ("oh-ell") 
 nO ("enn-oh") and nl ("enn-ell"). These typographical errors will not be caught by a 
 compiler because the misspelled names simply infer a new net. 

 What's new 

     erilOg-2001 gives the designer, test engineer or other Verilog user the ability to 
 Vdisable implicit net data types. This control is provided with a new argument of 
 none to the 'default_nettype compiler directive. When this option is specified, 
 all nets must be explicitly declared. The same example from above, with this new 
 value for a default net data type, will result in compilation errors for the undeclared 
 signals. 

    'default_nettype   none   !!disable  inference  of  nets 
    module bad_chip   (01, nO,  n1l; 
      output  01; 
      input   nO, n1; 

      wire    01; 
      wire    nO, n1; 

      and  (01, nO, nl);   !!undeclared   signal  names  won't compile 

    endmodule 

Note  that none is not a new reserved word. It is an argument value to the 
 \ defaul t_net type compiler directive. 

Synthesis considerations 

This enhancement should be synthesizable. 
 36               Verilog-2001: A Guide to the New Features of the Verilog HDL 

 14.   Variable vector part selects 


 Background 

 Verilog-1995 allows bits or parts of a vector to be selected. A bit select can use a con•
 stant expression or a variable expression, but a part select can only be a constant 
 expression. Given the following vector declaration: 
    reg   [127:0] vector; 

 A specific byte can be selected from the vector using constant values for the part 
 select, as follows: 
    reg   [7:0] byte; 

    byte =  vector[31:24];     //constant  part  select 

 In Verilog-1995, however, the following code would be illegal: 

    for  (n=O; n<=15;  n=n+1)   //loop  through  16 bytes 
      byte  = vector[n*8+7:n*8];     //XLLEGAL  part select 

 The only way to do a variable part select with Verilog-1995 is to build the part select 
 using several variable bit-selects. One approach is to use a concatenation of bit 
 selects. But this is both verbose and awkward if the part select comprises more than 
just a few bits. An example of selecting one byte using a concatenation of bit selects 
 for the above example would be (n represents the byte number to be selected): 

      byte  = {vector[n*8+7], 'vector[n*8+6],    ••• vector[n*8]) 

 Another coding method is to use a loop construct to build a part select from multiple 
bit selects. This method gives more flexibility, but requires additional programming, 
 and may require modifications each time the functionality is used in a different cir•
 cumstance. A simple example is (n represents the byte number to be selected): 

    for (bit-O;  bit<=7;  bit=bit+l) 
      byte [bit] • Word[n*8+bit]; 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Variable vector part selects                                         37 

 What's new 

     erilOg-2001 provides the ability to have variable part selects of a vector. Two spe•
 Vcial part-select operators are introduced: 

     [<s tarting_bi t>+: <width>] part-select increments from starting bit 

     [<starting_bi t>-: <width>]  part-select decrements from starting bit 

 These new constructs allow the starting bit of the part select to be varied, but the 
 width of the part select must be constant. The new part select operators work with any 
 style of Verilog vector declaration. Either the most-significant bit or least-significant 
 bit of the part select will be the starting bit, depending on the vector declaration and 
 the selection operator. 

 Given the following declarations: 
    reg   [127:0] vector1; 
    reg   [0:127] vector2; 

 Four example part selects which can be made using these new select operators are: 

    byte   vector1[31-:8];      Iiselects  vector1[31:24) 
    byte   vector1[24+:8];      Iiselects  vector1 [31: 24) 
    byte   vector2[31-:8];      Iiselects  vector2[24:31) 
    byte   vector2[24+:8];      Iiselects  vector2[24:31) 

A loop that selects all the bytes from a vector can be coded as: 

    for (i=O;  i<=15;  i=i+1)          Illoop  through  16 bytes 
      byte  = vector1[(i*8)+:8];        Ilvariable  part  select 

The variable part select operators can also be used on the left-hand side of an assign•
ment statement: 

   vector2[~eNUm*8-:16]       = 16'hO;    Ilclear  16 bits 

Synthesis considerations 

This enhancement should be synthesizable. 
38               Verilog-2001: A Guide to the New Features of the Verilog HDL 

15.   Multidimensional arrays 


Background 

Verilog-1995 supports one-dimensional arrays of the reg, integer and time data 
types. Since the reg data type can also have a vector width declared, some texts refer 
to an array of reg types a two-dimensional array. Examples of declaring an array are: 
   reg  [63:0] RAM  [0:4095];    //4K  element  array,  64-bit  words 
   integer  table  [1:128];      //128  element  array,  32-bit  words 
   time  t_array  [15:0];        //16  element  array,  64-bit  words 

The array address range is declared as [<starting_address>: <ending_address> 1 . The 
starting address can be any constant expression; there does not need to be an address 
zero. The ending address must also be a constant expression, and can be smaller or 
greater than the starting address. 

Once an array is declared, a full word from the array can be selected, using an index. 
The index can be constant or variable. For example: 
   data = RAM[100];              //read word   at index  100 
   RAM [address_bus]    data;    //write  to word  at  index of 
                                   address  bus  value 

Verilog-1995 does  not permit accessing a bit-select or part-select from within an 
array. 

Memories 

A one-dimensional array of reg variables is typically used to model the storage of 
RAMs and ROMs. Therefore, the IEEE 1364 Verilog standard and many other texts 
often refer to a one-dimensional array of reg variables as a memory, or memory 
array. 


S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
Multidimensional arrays                                              39 

What's new 

    eri10g-200 1 adds the capability of specifying multidimensional arrays. Any num•
Vber   of dimensions may be declared, and each dimension can have the lowest 
numbered address as the first address or the last address. Two examples are: 

   reg  [63:0] array_lD   [0:127];           //one-dimensional   array 

   reg  [63:0] array_2D   [0:4095] [0:127];  //two-dimensional   array 

   integer  i [15:0] [127:0] [7:0] [3:0];   //four-dimensional   array 

A word from a multidimensional array can be selected using the index numbers for 
that specific element. The indices can be constant expressions or variables. Given the 
array_  2D declaration above, the following example will select a single 64-bit word 
from the array: 

   data  = array_2D[n]  [m] ;  //select  word  at address  n, m 

As in Verilog-1995, attempting to read a word that is out-of-range for the array decla•
ration will return logic X. Attempting to write to a word that is out-of-range will not 
change any value, and may generate a run-time error message. 

It is illegal to select more than one word from a multidimensional array at a time. 
Using the declarations above, the following select would result in a compilation error: 

   array_lD  = array_2D[100];    //ILLEGAL--cannot   select  a 
                                    full dimension  from  an array 

In both Verilog-1995 and Verilog-2001, an array name without any indices is a legal 
argument to a system task. The $readmemb system task, for example, takes the name 
ofa memory array (a one-dimensional array or reg variables) as one of its arguments. 
A system task defined using the Verilog Programming Language Interface (PU) can 
access an entire multidimensional array by passing the array name as a system task 
argument. Note that some built-in system tasks, such as $display and $moni tor, do 
not support using an array name as an argument. 

Synthesis considerations 

This enhancement might be synthesizable, similar to the way one-dimensional arrays 
are synthesiszed in the Verilog-1995 standard. 
 40               Verilog-2001: A Guide to the New Features of the Verilog HDL 

 16.   Arrays of net and real             data types 


 Background 

 In the Verilog-1995 standard, only one-dimensional arrays of reg, integer and 
 time variables can be declared. Arrays of the real and real time variables are not 
 allowed. Arrays of any of the net data types, such as wire, are also not permitted. 

 What's new 

     erilOg-200l allows arrays of real and realtime variables, and arrays of any of the 
 Vnet data types to be declared. The syntax is the same as with declaring an array of 
 reg or integer variables. The arrays may have any number of dimensions. 

 Three examples are: 

    wire  [63:0] w_array   [15:0];   Iione-dimensional   array 

    trireg  [23:0]  row_column_address   [0:4095] [0:127];  //2D  array 

    real float_array   [1:100] [1:16] [1:16];  //3D array 

 An example of using arrays of net data types is shown in conjunction with the new 
 generate capabilities in Verilog-2001, in section 36, on page 85. 

 Synthesis considerations 

This enhancement should be synthesizable. 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Array bit and part selects                                           41 

 17.   Array bit and         part selects 


 Background 

 In Verilog-1995, it is illegal to directly select a bit or part of a word from an array. In 
 order to access a bit or part select of word, the full word must be copied to a tempo•
 rary variable, and a bit select or part select performed on the temporary variable. 

    Iiselect  the high-order   byte  of 1 word  in a memory  array 
    reg  [31:0] RAM  [0:255]; 
    reg   [7:0] high_byte; 
    reg  [31:0] temp; 

    temp = RAM [address] ; 
    high_byte  = temp[31:24]; 


 What's new 

    erilOg-2001 allows bit selects and part selects of arrays of any number of dimen•
 Vsions.  The syntax is the same as selecting a full word from a multidimensional 
array. If the number of indices specified matches the number of dimensions in the 
array, then a full word from the array is selected. If there is one more index than the 
number of dimensions, then the last index is a bit select or part select of a word within 
the array. For example: 

    IIse1ect  high-order  byte  of 1 word  in a  2-dimensiona1   array 
    reg [31:0]  array2  [0:255] [0:15]; 
   wire  [7:0]  out2  = array2[100] [7] [31:24]; 

Synthesis considerations 

This enhancement should be synthesizable. 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 42               Verllog-2001: A Guide to the New Features of the Verllog HDL 

 18.   Signed reg,        net and port declarations 


 Background 

 Verilog math operations and comparison operations (such as the less-than and greater•
 than operators) use the data type of the operands to determine whether to perform 
 signed or unsigned operations. The general rule is that if all operands in the expres•
 sion are signed, then a signed operation is performed. If any operand in the expression 
 is unsigned, then an unsigned operation is performed. 

 Verilog-1995 only provides one signed data type, the integer variable. The reg, 
 time, and all net data types are unsigned. An integer variable has a fixed width of 
 32 bits (the IEEE standard defines integers as "at least 32 bits", but in virtually all 
 simulators, integers are exactly 32 bits). With only one signed data type in Verilog-
 1995, most signed operations are limited to 32-bits wide. The following examples 
 illustrate how signed versus unsigned operands can affect the result of an operation: 
    integer     i,  j;  Ilsigned  32-bit  variables 
    reg  [63:0] m;      Ilunsigned   64-bit variable 

    m = 6;   i = 6;   j = -3; 

    i I j will  return   -2    Ilsigned  integer  math 
    m I j will  return    0    Ilunsigned  integer  math 

 The result of 0 for m I j is not the wrong answer-it is the correct result for unsigned 
 integer arithmetic, which is a valid type of hardware. The reason m I j returns 0 is 
 because m is an unsigned operand, and therefore j is treated as unsigned. Negative 
 values are stored in two's complement form, which means j is storing the two's com•
plement of 3, which is FFFFFFFD. As an unsigned value, this is a very large positive 
 value, and 6 divided by a large number, using integer arithmetic, is O. 

The determination on whether signed or unsigned arithmetic should be performed is 
 based on the data types of the full expression, and not just the arithmetic operation. 
 For the statement below, all three operands must be signed in order to have a signed 
 math operation and a signed compare operation. 

    gt =  (a - b) >  C;  Ilis  a  - b greater  than c? 

 Verilog-1995's rules for doing signed or unsigned arithmetic correctly model hard•
 ware, which may be either signed or unsigned. The limitation in Verilog-1995 is that 
 to model signed arithmetic, only 32-bit integers can be used. 

 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
Signed reg, net and port declarations                        43 

What's new 

   erilog-2001 allows reg variables and all net data types to be declared using the 
Vreserved keyword signed (the signed keyword was reserved in the 1993 OVI 
Verilog 2.0 standard, but was not utilized until now). With Verilog-2001, signed oper•
ations can be performed with vectors of any size. For example: 

   integer           i, j  ; //signed 32-bit variables 
  reg  signed [63:0] m;     //signed 64-bit variable 
  m    6 ; i = 6;  j = -3; 
   i / j will return  -2    //signed integer math 
  m  / j will return  -2    //signed integer math 

   Note: Verilog-2001 does not change the rules for when an operator performs signed 
   or unsigned operations. Verilog-2001 provides more signed data types. 

The signed property can also be placed on module port declarations. When either the 
data type or the port is declared as signed, the other will automatically inherit the 
signed property. An example of declaring module ports as signed is: 
  module  adder (a , b , sum); 
     input  signed [63:0] a, b; 
     output signed [63:0] sum; 
    wire   [63:0] a , b; //automatically signed because of port 
     reg   [63:0] sum;   //automatically signed because of port 

An example of declaring signed ports and data types with the new Verilog-200 1 ANSI 
C style port declarations is: 

  module adder  (input  wire signed [63:0] a , b , 
                 output reg  signed [63:0] sum); 

It should be noted that a part select of a vector is always considered unsigned, even if 
the vector is signed. This is true even if the entire vector is selected in the part select. 

Synthesis considerations 

This enhancement may not be synthesizable. Most current synthesis tools have lim•
ited support for signed operations. 
44               Verilog-2001: A Guide to the New Features of the Verilog HDL 

19.   Signed based integer numbers 


Background 

In Verilog-1995, a literal integer number can be specified in three ways: 
   <integer_number> 
    , <radix><integer_number>  
   <size>' <radix><integer_number>  

The radix can be binary, octal, decimal or hexadecimal, represented with ' b, ' 0, ' d 
or 'h, respectively (the radix specifier can also represented with ' B, ' 0, ' D or ' H). 

A literal integer number is considered signed if no radix is specified, and unsigned if a 
radix is specified. As noted in the previous section, Verilog uses the operands of an 
expression to determine if certain operations should perform signed or unsigned oper•
ations. As an example: 

   integer     i;   //signed  32-bit variables 

   i = 6; 

   i  / -3      will  returns   -2    //signed  integer  math 
   i  / -64'd3  will  returns    0    //unsigned  integer  math 

The reason the last line in the example returns 0 is the same as was explained in the 
previous section. 

In Verilog, a literal integer number with no size specified defaults to at least 32-bit 
wide (virtually all simulators use exactly 32 bits). To specify a literal integer that is 
narrower or wider than 32 bits, the size and radix must be specified. When the radix is 
specified, Verilog-1995 treats the value as unsigned. Therefore, signed operations 
using literal integer values are limited to 32-bit vectors in Verilog-1995. 


S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Signed based integer numbers                                         45 

 What's new 

     eri10g-2001 further extends the capabilities for signed arithmetic by allowing 
 Vsized literal integers to be declared as signed. An optional signed specifier has 
 been added to the syntax for specifying literal integers. 

 In Verilog-2001, a literal integer number can be specified in five ways: 
    <integer_number> 
     '<radix><integer_number>  
    <size>' <radix><integer_number>  
     , s<radix><integer_number>  
    <size>' s<radix><integer_number>  

 In the following example,  declaring a sized literal integer as signed allows signed 
 arithmetic to be performed with a 64-bit value (this example also declares a signed 
 reg variable, as discussed in the previous section): 

    reg signed  [63:0]   m;   Iisigned  64-bit  variable 

    m = 6; 

   m  I -64'd3    will  returns    0    Ilunsigned  integer  math 
   m  I -64'sd3   will  returns   -2    Iisigned  integer  math 

SyntheSiS considerations 

This enhancement may not be synthesizable. Most current synthesis tools have lim•
ited support for signed operations. 
46               Verllog-2001: A Guide to the New Features of the Verllog HDL 

20.   Signed functions 


Background 

Verilog-1995 allows the return value of a function to be specified as: 
•  A one-bit return value. 
   function  f1; 
• An unsigned vector of any size. 
   function  [47:0]  f2; 
• An unsigned time return as a 64-bit vector. 
   function  time  f3; 
•  A signed integer return as a 32-bit vector. 
   function  integer  f4; 
•  A real return, as a double-precision floating point value. 
   function  real  f5; 

A Verilog function can be called any place that an expression can be used. As an 
example: 

   if  (f2(vector)  < 32)   //f2 returns  a  48-bit unsigned   value 

As discussed in section 18 on page 42, several Verilog operators are affected by the 
type of the operands,  performing either signed or unsigned operations. The only 
signed function type in Verilog-1995 is an integer function, which has a fixed width 
of 32 bits. The IEEE standard defines that integer functions should return at least 32 
bits, but virtually all simulators use exactly 32 bits. 

In the example above, and using the declaration above, function f2 returns a 48-bit 
unsigned value. If the function calculated a negative value, which would be repre•
sented in two's-complement form, the unsigned return from the function would be 
interpreted as a large positive value. As an unsigned function return, a negative num•
ber would test as being greater than 32. 


S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
Signed functions                                                     47 

What's new 

verilOg-2001 adds one more type of function to the Verilog language: 

•  A signed function of any vector size 
   function  signed  [47:0)  f6;    //48-bit  signed  return  value 

This enhancement allows signed operations to be performed on function return values 
of any vector size. In the following example, a negative value calculated within the 
function will be returned as a 48-bit negative value, which will then test as being less 
than 32. 

   if (f6(vector)   < 32)   //f6 returns  a  48-bit  signed value 

Synthesis considerations 

This enhancement may not be synthesizable. Most current synthesis tools have lim•
ited support for signed operations in Verilog. 
48               Verilog-2001: A Guide to the New Features of the Verilog HDL 

21.   Sign conversion system functions 


Background 

In Verilog-1995, the only way to "convert" an unsigned value to a signed value is to 
transfer the value into an integer data type. This is not really a conversion. It is sim•
ply a transfer of a value from one data type to another. The limitation of only one 
signed data type forces awkward coding styles, such as: 

   module  adder  (sum, a, b); 
     output   [31:0]  sum; 
     input    [31:0]  a, b; 
     wire     [31:0]  a, b;           //unsigned  data  types 
     integer          sum,  a1, b1;   //signed  data  types 

     always  @(a or  b) 
       begin 
         a1  = a;   //transfer  inputs  to signed  data  type 
         b1  = b; 
          sum = a1  + b1;   //will do  signed  arithmetic 
       end 
   endrnodule 

As discussed in section 18 on page 42, the integer data type has the limitation of 
having a fixed size of 32 bits. With Verilog-1995, there is no simple method of con•
verting an unsigned value that is more than 32 bits wide into a signed value. 

What's   new 

    erilOg-2001 provides two new system functions that convert values to signed or 
V   unsigned values: 
• $signed returns the value passed in as a signed value. 
• $unsigned returns the value passed in as an unsigned value. 

The number of bits returned by these system functions will be the same as the vector 
size passed in to the system function. 


S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Sign conversion system functions                                     49 

 These functions provide a method of truly converting values to signed or unsigned 
 values. In conjunction with the new signed data type declarations, they provide com•
 plete control over how expressions perform signed and unsigned operations. 

 The following example allows the value of a 64-bit unsigned wire data type to be used 
 as a signed value: 

    integer     j;      //signed  32-bit variables 
    reg [63:0]  m;      //unsigned   64-bit variable 

   m  = 6;   j = -3; 

   m  / j              will  return    0   //unsigned   integer  math 
    $signed{m)  / j    will  return   -2   //signed  integer  math 

 Synthesis considerations 

This enhancement will probably not be synthesizable. Most current synthesis tools do 
not support system functions. 
50               Verilog-2001: A Guide to the New Features of the Verilog HDL 

22.   Arithmetic shift operators 


Background 

Verilog-1995 provides two simple shift operators: The» token represents a bitwise 
shift-right operation. The « token represents a bitwise shift-left operation. Both shift 
operators will shift the bits in the first operand the number of times indicated by the 
value in the second operand. The bits which are vacated by the shift are always zero 
filled. 

   integer  a, b,  c;   Iisigned  data  types 
   a   0; 
   b   -10;    112's  complement  is  1111111111111111111111110110; 

   c = a +  (b »3);     II 000111 ••• 1110 binary,  536870910  decimal 

What's new 

    eri10g-2001 adds two new shift operators to support signed arithmetic shift oper•
Vations:  The »> token  represents an arithmetic shift-right operation. The «< 
token represents an arithmetic shift-left operation, which is the same as a bitwise 
shift-left operation. 

The »> arithmetic shift-right operation uses the context of the expression to deter•
mine the value with which to fill vacated bits. If the expression is signed, the »> 
operator will fill the vacated left bits with the value of the sign bit (the left-most bit). 
If the expression is unsigned, the »> operator will fill the vacated bits with zero. An 
expression is considered signed if all operands in the expression are signed, with the 
exception that the second operand of the shift operator can be signed or unsigned. 
Using the declarations above, an arithmetic shift right will yield the following result: 

   c  •  a + (b »> 3);    II 111111 ••• 1110 binary,   -2 decimal 

Note that in this example, both a and b must be signed data types for the expression to 
be considered signed. If the example had been coded as c = a + {b »> 3}, then 
only b would need to be signed, because the concatenation operator forms a self•
determined expression, which does not depend on the rest of the expression. 

S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
Arithmetic shift operators                                            51 

The «< arithmetic shift-left operation will always zero fill the right-most bits, the 
same as the « bit shift-left operator. The arithmetic shift-left operation does not pro•
vide any new functionality. The operator was added to provide a counterpart to the 
arithmetic shift-right operation, for consistency in the language. 

Synthesis considerations 

This enhancement should be synthesizable. 
52               Verilog-2001: A Guide to the New Features of the Verilog HDL 

23.   Assignment width             extension past 32            bits 


Background 

With Verilog-1995, if the expression on the left-hand side of an assignment statement 
is a wider vector than the expression on the right-hand side, then the following rules 
apply (for both procedural assignments and continuous assignments): 
• If the expression on the right-hand side is signed, then values on the right-hand side 
  are sign extended. That is, a value is extended with 1 if the left-most bit of the 
  value (the sign bit) is 1. If the left-most bit is 0, then the value is extended with O. 
• If the expression on the right-hand side is unsigned, then the value is always 
  extended with O. The reg, time, all net data types, and literal integers with a radix 
  are all considered unsigned values. 

The following assignments illustrate the effect of these extension rules: 

   reg  [63:0] d1,  d2, d3;     //64-bit  vectors 
   integer  r1;                 //a  32-bit  signed vector 
   reg  [31: 01 r2;             //a  32-bit unsigned   vector 
   r1   = -1;                   //assigns      'h11111111 
   r2   = -1;                   //assigns      'h11111111 
   d1    r1;                    //fills with   'hllllllll11111111 
   d2    r2;                    //fills with   'h0000000011111111 
   d3    'bz;                   //fills with   'hOOOOOOOOzzzzzzzz 

The second and third assignments are zero extended because the left-hand sides are 
64 bits wide, but the right-hand sides are unsigned values that are only 32 bits wide 
(the unsized literal value of 'bz defaults to 32 bits wide). There is a simple work 
around to avoid this zero extension, which is to make the right-hand side value the 
same vector size as the left-hand vector. Given the declarations above, the assign•
ments could be modified as: 

   d2    {{32{r2[3l]}},r2};     //fills with   'hllllllll11111111 
   d3    64 ' bz;               //fills with   'hzzzzzzzzzzzzzzzz 

What's new 

    erilog-2001 changes the assignment extension rule for logic Z and X. The rule 
 Vfor whether or not to sign extend is not changed, but, as discussed in section 18, 

S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
Assignment width extension past 32 bits                              53 


Verilog-200l allows the reg data type and all net data types to be declared as 
signed. Literal integers with a size and radix can also be declared as signed This pro•
vides more signed data types that can be used on the right-hand side of the expression. 

With Verilog-200l, the assignment extension rules are: 
• If the expression on the right-hand side is signed, then values on the right-hand side 
  are sign extended. That is, a value is extended with 1 if the left-most bit of the 
  value (the sign bit) is 1. If the left-most bit is 0, then the value is extended with O. 
• If the value on the right-hand side is unsigned, and the left-most bit of the value is 0 
  or 1, then the value is extended with O. 
• If the left-most bit of the value is Z, then extend with Z, regardless of whether the 
  expression is signed or unsigned. 
• If the left-most bit of the value is X, then extend with X, regardless of whether the 
  expression is signed or unsigned. 

With these new assignment extension rules, and by declaring r2 as signed, the origi•
nal examples on the previous page will give the following results: 

   reg  [63:0] d1,  d2, d3;     //64-bit  vectors 
   integer  r1;                 //a  32-bit  signed vector 
   reg signed   [31:0] r2;      //a  32-bit  signed vector 
   r1  =  -1;                   //assigns      'h11111111 
   r2  =  -1;                   //assigns      'h11111111 
   dl    rl;                    //fills with   'h1111111111111111 
   d2    r2;                    //fills with   'hllllllll11111111 
   d3    'bz;                   //fills  with  'hzzzzzzzzzzzzzzzz 

Backward compatibility 

This enhancement is not backward compatible with Verilog-1995. Verilog-2001 has 
changed the extension rule for assignment statements. Therefore, models which relied 
on the zero extension shown in the original examples on the previous page will not 
work the same in Verilog-2001. The IEEE Veri log Standards Group considered this 
matter carefully. The group felt that the Verilog-l995 behavior was a bug in the Ver•
ilog standard that needed to be fixed. The standards group felt that most, if not all, 
existing Veri log models avoid the bug by ensuring that the right-hand side expression 
is the same vector size as the left-hand side, so that the zero extension rule is not 
being applied. Models that avoid the Verilog-l995 extension rule will not be affected 
by the changes made to the extension rule. 

Synthesis considerations 

This enhancement should be synthesizable. 
54               Verilog-2001: A Guide to the New Features of the Verilog HDL 

24.   Power operator 


Background 

Verilog-1995 provides addition, multiplication and shift-left operators. While these 
operators can be used to raise one number to the power of another, they require using 
procedural programming statements, such as a for loop. As an example, one of the 
ways to calculate the value of mn in Verilog-1995 is to do repeated multiplication 
operations in a loop, as in the following function: 
   function  [63:0)  pow; 
     input  m, n; 
     integer  m, n; 
     begin 
       if (n  < 0) 
         pow  = 64'bx; 
       else  if  (n == 0) 
         pow    1; 
       else 
          for (pow  = 1; n  > 0; n    n  - 1) 
            pow =  pow * m; 
     end 

An example of using the preceding function is: 
   always  @(posedge  clock) 
     result  = pow (base, exponent); 

What's new 

    eriIOg-2001 adds a power operator, **, to the Verilog language. This operator 
Vbehaves similarly to the C pow () math function, with these differences: 
• The return value is a real number (double-precision floating point) if either operand 
  to ** is a real, integer, or signed value. 
• The return value is an unsigned vector if both operands are unsigned values. 
• The return value is ambiguous (not specified by the IEEE 1364 standard) if the first 
 operand is 0 and the second operand is not a positive number. 
• The return value is ambiguous (not specified by the IEEE 1364 standard) if the first 
 operand is negative and the second operand is not an integral value. 
S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
Power operator                                                       55 

In a compound expression, the * * operator has a higher precedence than the * opera•
tor. 

Using this new operator, the call to the function and the entire function shown on the 
preceding page can be replaced by a single operation. For example: 

   always  @(posedge  clock) 
     result  = base  ** exponent; 

Synthesis considerations 

This enhancement should be synthesizable, but may have restrictions on what can be 
used for operand values. 
56               Verilog-2001: A Guide to the New Features of the Verilog HDL 

25.   Attributes 


Background 

Specific software tools often require information about a module, or a specific object 
within a module, beyond what can be described using the Verilog HDL. Synthesis 
tools may need to know how an engineer wants a case statement to be realized in 
hardware. Co-simulation between a digital simulator and an analog simulator may 
need to know electrical characteristics of a node in a Verilog module that cannot be 
represented in the digital Veri log HDL. 

Verilog-1995 provides two ways to provide additional information that may be 
needed by software tools: compiler directives, such as 'ifdef, and specparam 
attribute constants, such as specparam slopeS = 0.015;. Both of these methods 
have limitations. Compiler directives affect all software tools which read the Verilog 
source code. They do not work well for providing information needed by just one 
type of software tool, such as a synthesis tool. Compiler directives also cannot be 
associated with a specific object within a module. In fact, compiler directives have no 
scope at all. They are not even bound by module boundaries. Specparam attributes are 
often used in ASIC libraries to specify non-Verilog values that are associated with 
specific structural objects in a Verilog module. For example, the rise and slope electri•
cal characteristics of a module input port can be specified with a specparam attribute. 
Specparam attributes can be read by the Veri log Programming Language Interface 
(PLI). Historically, they were often used by ASIC vendors for delay calculation, but 
most ASIC vendors now use other methods to calculate accurate timing. The spec•
param attributes cannot represent information about RTL objects in a module, such as 
a case statement. 

For Verilog-1995 and older generations of Verilog, software tools, such as synthesis 
products, have worked around the limitations of compiler directives and specparam 
attributes by placing tool-specific information in Veri log HDL comments, often 
referred to as a "pragma". Two common pragmas familiar to most engineers who use 
Verilog are shown in the following example: 
   always  @(state)   //state machine   with  one-hot  encoding 
     case  (state)    //synopsys  parallel_case   full_case 
       3'b001:  next_state     3'bOl0; 
       3'bOl0:  next_state     3'bl00; 
       3'bl00:  next_state     3'b001; 
     endcase 

S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
Attributes                                                                      57 

What's new 

     erilOg-2001 adds a new  language construct, called an attribute. An attribute is 
Vrepresented with the token pair    (* and  *). The synthesis pragmas on the previ•
ous page might be represented using attributes as follows: 
    always   @(state)     //state machine     with   one-hot   encoding 
      (*  full_case,    parallel_case      *) case   (state) 
         3'b001:   next_state       3'b010; 
         3'b010:   next_state       3'blOO; 
         3'blOO:   next_state       3 'b001; 
      endcase 

    Note: The attribute names and values in the examples shown in this book are purely 
    conceptual. The IEEE 1364-2001 Verilog standard does not specify any standard 
    attributes. The standard only defines the attribute construct. It is expected that 
    software tools or other standards will define attribute names and values. The 
    proposed IEEE Std. 1364.1 Standard for Verilog Register Transfer Level Synthesis is 
    one such effort at defining standard set of attributes. 

Attributes are not just another style of comment. Attributes are associated with a spe•
cific object within a Verilog module, and only affect that object. The syntax rules for 
specifying attributes are: 
• The attribute is specified as a prefIX to a declaration, a module item, a statement or 
  a port connection. Three examples are: 
    (* optimize    *). module   control    ( ... ); 
    (* state_variable      *)  reg  [7:0]   S; 
   dff   il  (q,  d,  (* clock_line     *)  ckl,  rst}; 
• The attribute is specified as a suffIX to an operator or the function name in a func•
  tion call. 

   sum   = a  +  (* ripple_adder     *)  b; 
   assign   next_state     = fsm_func(*    meally_fsm     *) (state,  a,  b,  c); 

Note that an attribute can be separated from the object with which it is associated by 
any type of white-space, including a return. For example: 

    (* optimize    *) 
   module   control    ( ... ); 
58               Verilog-2001: A Guide to the New Features of the Verilog HDL 

Attribute values 

An attribute can be assigned a value. The value must be a constant expression which 
can be determined at elaboration time, before simulation starts running. An attribute 
with no value assigned is considered to have a non-zero value, and will test as true in 
a true/false test. Some examples of using attributes with values might be: 

   (* full_case=l,   parallel_case=O   *) case  (state) 

   sum =  a + (* mode  = ucla_adder"   *) b; 

The value of an attribute cannot be accessed directly in the Verilog HDL. Software 
tools which read Verilog source code can parse for attributes and read the attribute 
values. Attribute values are also accessible from the Verilog Programming Language 
Interface (PLI). 

An attribute can be associated with a module declaration or an instance of a module. 
If an attribute has different values specified on both the module declaration and an 
instance of that module, the attribute on the instance will take precedence. 

Parameterized attributes 

An attribute can be assigned the value of a parameter constant. Since parameters 
can be redefined during elaboration, it is possible to create attributes that can be con•
figured at elaboration time. An example of a configurable attribute might be: 

   module  ram  ( ... ); 
     parameter  SIZE    1024; 

     (* memory_size   = SIZE  *) reg  [WIDTH-1:0)  core  [0:SIZE-1); 

Synthesis considerations 

This enhancement should be synthesizable. 

   Note: The IEEE 1364.1 Verilog Synthesis Interoperability Group is working on a 
   proposal for a standard set of attributes for all synthesis tools. This proposal was not 
   complete at the time this book was written. The current status of the proposal can be 
   found at the group's web site, www.eda.orglvlog-synth. 
 Sized and typed parameter constants                                   59 

 26.   Sized and typed parameter constants 


 Background 

 The Verilog-1995 syntax for parameter declarations is: 

    parameter  list_of-parameter_assignments; 

 list_of-parameter_assignments is   a comma-separated list of one or more: 

     parameter_name   = constant_expression 

 A constant_expression includes: 
 • Unsized integer numbers (defaults to a size of at least 32 bits) 
 • Sized integer numbers 
 • Real (floating point) numbers 
 • Strings 
 • Other parameters 

In addition to the initial assignment to a parameter, the value of the parameter can be 
redefined using either the defparam statement or by module instance in-line parame•
ter redefinition. The redefined value can be any of the legal data types, and does not 
need to be the same type as the initial value assigned to the parameter. 

The Verilog-1995 rule for the parameter size and type is that the size and type of a 
parameter constant is based on the final value assigned to it, after any parameter 
redefinitions. This rule provides a great deal of flexibility on the values that can be 
assigned to parameter constants. However, the rule also means that the vector size and 
data type of a constant can be changed when the parameter is redefined. This can lead 
to undesirable side affects. The example below illustrates one way changing the type 
of a parameter might be a problem: 

   parameter   INCREMENTOR  =  1; 

   always  @(posedge   clock) 
      result  = data  + XNCREMENTOR; 

The addition operator in Verilog performs its operation based on the data types of the 
operands in the expression. If all operands in the expression are signed integers, 

 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
60               Verilog-2001: A Guide to the New Features of the Verilog HDL 

signed arithmetic is performed. If any operand is unsigned and all operands are vec•
tors or scalar, then unsigned integer arithmetic is performed. If any' operand is a real 
value, then floating point arithmetic is performed. The vector size of integer math 
operations is also affected in part by the size of the operands. 

In the preceding example, the parameter is initially assigned a 32-bit signed integer 
value. If the parameter were redefined with a real value or an unsigned value, it could 
change the type of math operation performed by the model. If the functionality of the 
model only works correctly with signed integer math operations, changing the param•
eter data type through parameter redefinition could have the side affect of breaking 
the model functionality. 

What's new 

verilOg-2001 adds the ability to: 

• Explicitly define the size of a parameter. 
• Explicitly define the data type of a parameter. 

The Verilog-2001 syntax for parameter declarations is: 
   parameter  list_of-parameter_assignments; 

   parameter  [msb: Isb]   list_of-parameter_assignments; 
   parameter  signed  list_of-parameter_assignments; 

   parameter  signed  [msb:  Isb] 1 ist_of-parameter_assignments; 
   parameter  integer  list_of-parameter_assignments; 
   parameter  time  list_of-parameter_assignments; 
   parameter  real  list_of-parameter_assignments; 
   parameter  realtime  list_of-parameter_assignments; 

list_of-parameter_assignments is   a comma-separated list of one or more: 
     parameter_name   = constant_expression 

msb is a constant expression representing the most-significant bit number of a vector 
range: lsb is a constant expression representing the least-significant bit number of a 
vector range: 
 Sized and typed parameter constants                                  61 

 The rules for a parameter's type and size are as follows: 
 • If no sign, range or type is specified, then the parameter will follow the same rules 
   as Verilog-1995, where the parameter inherits the vector size and type of the last 
   value assigned to it after all parameter redefinitions. 
 • If sign and range are specified, the parameter will be signed, with the size specified 
   by the range. Parameter redefinitions will not change the sign or size. 
 • If sign is specified, but no range is specified, the parameter will be signed, and will 
   inherit the vector size of the last value assigned to it after all parameter redefini•
   tions. 
 • If range is specified, but no sign is specified, the parameter will be unsigned, and 
  will keep the size specified by the range. Parameter redefinitions will not change 
   the sign or size. 
 • If a type is specified, the parameter will keep that type. Any parameter redefinitions 
   will be converted to the type specified. 

 These new Verilog-2001 enhancements give much greater control over how parame•
 ter redefinitions can affect a model. Undesirable side effects can be avoided, such as 
 expecting a parameter to have an signed integer data type, but a parameter redefini•
 tion changes the data type to real. Explicitly declared parameters with a sign, size or 
 type cannot be overridden by the parameter value redefinition. The following exam•
 ple illustrates one way to utilize sized, typed parameter constants: 

   parameter   signed  [15:0)  INCREMENTOR  = 1;  //fixed  sign &  range 

    always  @(posedge  clock) 
      result  = data  + INCREMENTOR; 

Synthesis considerations 

This enhancement should be synthesizable, however there may be limitations on 
signed and real data types. 
62               Verilog-2001: A Guide to the New Features of the Verilog HDL 

27.   Explicit in-line parameter redefinition 


Background 

Modules can have parameter constants, as was discussed in the previous section. An 
example of a parameterized module declaration is: 

   module  ram  ( ... ); 
     parameter  WIDTH  = 10; 
     parameter  SIZE   = 1024; 
     input  [WIDTH-l:O]  address_bus; 
     reg  [WIDTH-l:O]  core  [O:SIZE-l]; 

Verilog-1995 provides two ways to redefine the values of module parameter con•
stants: 
• Using the defparam statement, for example: 
     ram   meml  ( ... );                 //instance   of ram module 
     defparam  meml.SIZE  •  4096; 
     defparam  meml.WIDTH   = 12; 
• Using the module instance in-line, implicit parameter redefinition, for example: 
     ram   meml #(12,4096)    ( ... );    //instance   of ram module 

Each of these two methods has advantages and disadvantages. Using defparam state•
ments makes the code where the parameter is redefined well documented. The param•
eter being redefined is explicitly named, so it is clear exactly what is being redefined. 
Since the parameter is explicitly named, parameters can be redefined in any order, 
regardless of the order of the declarations of the parameters. However, the defparam 
statement can be placed anywhere in the Verilog source code, as long as a valid path 
to the parameter being redefined is specified. Placing defparam statements in places 
not near the actual module instance can make the Verilog source code convoluted, and 
forces software tools to scan through all Verilog source files searching for defparam 
statements that may be in bizarre places. 

Using the module instance in-line, implicit parameter redefinition makes the redefi•
nition of parameter part of the module instance. This greatly simplifies the work of 
elaboration for software tools, because they do not have to search for redefinitions 
that may be in other files. But, because the parameters being redefined are not explic•
itly named, the construct becomes obscure source code that is not good self-docu-

S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Explicit in-line parameter redefinition                              63 

 menting code. Another drawback of implicit in-line parameter redefinition is that the 
 new parameter values must be specified in the exact same order in which the parame•
 ters are declared. It is not possible to skip over a parameter, so the second parameter 
 declaration in a module cannot be redefined, without redefining the first parameter 
 declaration as well. 

 What's new 

     eriIOg-2001 adds an enhancement that combines the advantages of both methods 
 Vof Verilog-1995's versions for parameter redefinition. A third method has been 
 added, which is referred to as module instance explicit in-line parameter redefinition. 

 This new method also places the parameter redefinition in the module instance state•
 ment, but it allows specifying the names of the parameters being redefined. Explicitly 
 specifying the parameter names makes the source code much more self-documenting. 
 It also allows the parameters to be redefined in any order. 

 The syntax for module instance explicit in-line parameter redefinition is: 
   module_name   instance_name 
     #(.parameter_name(parameter_value),      ... ) (port_connections); 

The parameters on the previous page can be redefined as follows: 

      ram  meml  #(.SIZE(4096),   .WIDTH(12»    ( ... ); //ram instance 

SyntheSiS considerations 

This enhancement should be synthesizable. 
 64               Verllog-2001: A Guide to the New Features of the Verilog HDL 

 28.   Fixed     local   parameters 


 Background 

 Verilog-1995 provides a run-time constant, which is declared with the parameter key•
 word. The value of the constant can be changed during elaboration of a design, and 
 does not become fixed until simulation starts running. Using parameter constants can 
 be very useful for making a module easily configured. Each instance of the module 
 can have its parameter values redefined, making each instance unique. Sometimes, 
 however, parameter redefinition is not desirable. In the following example, parame•
 ters have been used to represent a specific state machine encoding sequence. Because 
 the values of parameters can be redefined, there is no way to ensure that the state 
parameters are not changed from elsewhere in the design. 

    parameter  statel    4'b0001, 
               state2  = 4'b0010, 
               state3    4'b0100, 
               state4    4'blOOO; 

 Verilog-1995 also provides a speeparam constant, which is typically used within a 
 module's specify block to represent timing and other electrical characteristics about a 
 module. A specparam constant cannot be redefined from the Verilog HDL, but can be 
 modified from Standard Delay Format (SDF) files. 

What's new 

    erilOg-2001 adds a true constant, called loealparam, which cannot be directly 
 Vredefined at elaboration time. The example above can be rewritten as: 

    loealparam  statel  = 4'b0001, 
                state2  = 4'b0010, 
                state3  = 4'b0100, 
                state4    4'blOOO; 

A  localparam cannot be directly redefined from outside the module. However, a 
 localparam can be assigned the value of parameter constants, and can therefore 
be indirectly redefined. In the following, a localparam is used to define the width of 
 an output port. This provides protection, in that the output port width cannot be inad•
 vertently redefined to a width that would be unreasonable for the input widths: 

 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Fixed local parameters                                                65 

    module  multiplier   (a, b, product); 
      parameter  a_width   = 8, b_width  = 8; 
      localparam   product_width     a_width  + b_width; 
      input     [a_width-l:0l         a; 
      input     [b_width-l:0l         b; 
      output    [product_width-l:0J   product; 

 The localparam declaration can include a sign or type, and a vector range: 
    localparam  list_of-parameter_assignments; 
    localparam   [msb:  Isb] list_of-parameter_assignments; 
    localparam  signed  list_of-parameter_assignments; 
    localparam  signed   [msb: Isb]  list_of-parameter_assignments; 
    localparam  integer  list_of-parameter_assignments; 
    localparam  time  lis t_of-parameter_assignmen ts; 
    localparam  real  list_of-parameter_assignments; 
    localparam  realtime   list_of-parameter_assignments; 

 list_of-parameter_assignments is   a comma-separated list of one or more: 
      parameter_name   = constant_expression 

 msb is a constant expression representing the most-significant bit number of a vector 
 range: lsb is a constant expression representing the least-significant bit number of a 
 vector range: 

 The following table summarizes the differences between the three types of constants: 

              • Can be declared in a module, task or function 
              • Can be redefined using defparam or in-line parameter redefinition 
  parameter 
              • Can be assigned the value of another parameter or localparam 
              • Cannot be referenced within a specify block 
              • Can be declared in a module, task or function 
              • Cannot be directly redefined 
 localparam 
              • Can be assigned the value of another parameter or localparam 
              • Cannot be referenced within a specify block 
              • Can be declared in a module or specify block 
              • Can be redefined from SDF files 
  specparam 
              • Can be assigned the value of another parameter, localparam or specparam 
              • Can be referenced within a module or specify block 

 Synthesis considerations 

This enhancement should be synthesizable. 
 66             Verilog-2001: A Guide to the New Features of the Verilog HDL 

 29.  Standard random number generator 


 Background 

 Verilog-1995 provides several system functions for generating random values, distrib•
 uted according to mathematical probabilistic distribution functions. These are: $ran•
 dam, $dist_uniform,$dist_DOrm&l, $dist_exponential, $dist-PQisson, 
 $dist_chi_square, $dist_t, and $dist_erlang. 

 An example of using $random is: 

   parameter SEED = 50; 
   reg  [31:0] test_vector; 

   always @(posedge test_clock) 
     test_vector = $random(SEED); 

 However, Verilog-1995 does not specify the algorithm to be used for generating ran•
dom numbers. Verilog simulators have, therefore, implemented different algorithms, 
 which makes it difficult to have consistency in random number patterns between dif•
 ferent simulators, even when the same seed value is specified. 

 What's new 

    erilOg-2001 defines the algorithms for all of the random number generators listed 
 Vabove.  The algorithms are the same ones used by Verilog-XL, the original Ver•
ilog simulator. With standard algorithms, the same simulation test can be run on dif•
ferent simulators, with consistent random patterns generated for the same seed value. 

Synthesis considerations 

This enhancement is not synthesizable. 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Extended number of open files                                        67 

 30.   Extended number of open files 


 Background 

 Verilog-1995 provides for a maximum of 32 files which may be opened at one time. 
 A file is opened using the $fopen system function, which returns a 32-bit integer 
 value with a single bit set in the integer. The integer value returned by $fopen is 
 referred to as a multi-channel descriptor (mcd). Bit 0 of the mcd is reserved, leaving 
 31 other mcd values available to opened with $fopen. Bit 0 represents the simula•
 tor's output display, and, if open, the simulator's output log file. Output system tasks 
 such as $fdisplay and $fmoni tor take the mcd value as their first argument, and 
 write a formatted text string to the file the mcd represents. The Verilog-1995 syntax 
 for $fopen is: 

    mcd = $fopen("file_name"); 

 Because the mcd value has a single bit set, two or more mcds can be bitwise or-ed 
 together to represent multiple files. This allows a single output command to write to 
 mUltiple files at the same time. 

The following example illustrates using $fopen to write to multiple files at the same 
 time. By bitwise or-ing the two mcd values together, along with the value of 1 (which 
sets bit 0) a $fdisplay system task then writes a message to both files as well as the 
 simulator output display and the simulator log file. 

    integer  fl, f2; 

    fl = $fopen("output.dat");     //returns   a 32-bit  mcd value 
    f2 = $fopen("errors.dat");     //returns   a 32-bit  mcd value 

    $fdisplay(fllf211,   "Error  AT time  %t",  %realtime); 

The system task $fclose will close an open file, and free up the mcd value to be 
used again by $fopen. 

What's new 

    erilOg-2001 increases the number of files which may be opened at the same time 
V   to 1,073,741,824 files (230). The new open file limit is obtained by creating a 

 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 68               Verilog-2001: A Guide to the New Features of the Verilog HDL 

 new single-channel file descriptor (Cd). An fd is a 32-bit integer with bit 31 set. 
 Because the fd has multiple bits set, it is not possible to bitwise or fds together. 
 When writing to a file opened as an fd, only a single file may be written to at a time. 
 Three fd values are reserved, and are predefined to represent the following: An fd of 
 32' h80000000 represents STDIN. An fd of 32' h80000001 represents STDOUT. An 
 fd of 32' h80000002 represents STDERR. STDIN is pre-opened for reading, STDOUT 
 and STDERR are pre-opened for writing in append mode. 

 The $fopen system function has been extended to support opening an fd file by add•
 ing an optional second argument. When this argument is specified, $fopen will 
 return an fd instead of an mcd: 

    mcd =  $fopen("file_name"); 
    fd  = $fopen("file_name",    file_type); 

 The file_type is a string which indicates whether the file should be opened for read•
 ing, writing as a new file, or appending to an existing file. The file_type must be one 
 of: 

      file_type                         Description 

        "r"         open a text file for reading 
        "rb"        open a binary file for reading 
        "w"         create a new text file for writing 
        "wb"        create a new binary file for writing 
        "a"         open a text file for writing at the end of the file (append only) 
        "ab"        open a binary file for writing at the end of the file (append only) 
        "r+"        open a text file for update (reading and writing) 
   "r+b" or "rb+"   open a binary file for update (reading and writing) 
        "W+"        create a new text file for update (reading and writing) 
   "w+b" or "wb+"  create a new binary file for update (reading and writing) 
        "a+"        open a text file for update at the end of the file (append only) 
   "a+b" or "ab+"  open a binary file for update at the end of the file (append only) 

    Note that the file types "w", "wb", "w+", "w+b", and "wb+" will overwrite an 
    existing file with the same name. 


The next section of this book shows how use the new fd values for reading, writing 
and appending to files. 
 Extended number of open files                                        69 

 Backward compatibility 

 This enhancement is not backward compatible with Verilog-1995. In Verilog-2001, a 
 maximum of 30 mcd files can be opened with $fopen at a time (Verilog-1995 could 
open 31 mcd files). To distinguish an fd from an mcd, Verilog-2001 has reserved bit 
31, making that bit no longer available for use as an mcd value. 

The IEEE Verilog Standards Group felt that the risk of compatibility issues was mini•
mal by reserving bit 31 of the mcd. Very few existing Verilog applications actually 
open 31 files at a time. For those few applications that do open 31 files at once, the 
standards group felt the added value of being able to open even more files was worth 
the trade-off of backward compatibility. 

Synthesis considerations 

This enhancement is not synthesizable. Synthesis does not support most system tasks, 
or file I/O. 
70               Verilog-2001: A Guide to the New Features of the Verllog HDL 

31.   Enhanced file 1/0 


Background 

Verilog-1995 provides several system tasks for writing to files: $fdisplay, 
$fwrite, $fstrobe and $fmonitor. These routines can write formatted values and 
strings to files which have been opened using $fopen. 

However, Verilog-1995 has only limited file reading capabilities built into the lan•
guage. The routines defined in Verilog-1995 are the $readmemb and $readmemh sys•
tem tasks, which read numerical patterns represented as text strings and load the 
values into a memory array (a one-dimensional array of reg variables). More com•
plex file 110 operations are performed using the Verilog Programming Language 
Interface (PLI). 

What's new 

    erilog-2001 adds an extensive set of file 110 system functions, which essentially 
Vduplicate  several of the C language file 110 functions, making them part of the 
Verilog HDL. This eliminates the need to create custom PLI applications for reading 
from files. The new file 110 system functions are: 

    c = $fgetc (fd) ; 
   code    $ungetc(c,   fd); 
    code = $fgets(str,   fd); 
   code  = $fscanf(fd,   format,  arguments); 
    code = $fread(reg_variable,    fd); 
   code  = $fread(memory_array,    fd,  start,  count); 
   position   = $ftell(fd); 
   code  = $fseek(fd,   offset,  operation); 
   code  = $rewind(fd); 
   errno  =  $ferror(fd,  str); 
   $fflush(mcd_or_fd); 

(fd and mcd refer to the file descriptor and multi-channel descriptor returned by $fopen, as 
discussed in the previous section) 


S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Enhanced file I/O                                                     71 

 Reading text from files 

 $fgetc reads one byte from a file and returns the value. If an error occurs, -1 is 
 returned. In order to distinguish -1 from a valid value of a byte, the width of the vari•
 able to which the return is assigned should be wider than 8 bits, such as an integer 
 variable. A valid value will be zero extended to the width of the variable, whereas -1 
 will be sign extended. 

 $ungetc pushes one byte onto the file 110 buffer for an open file. That byte will then 
 be returned by the next call to $fgetc for that file. The file itself is unchanged. The 
 operating system may limit the number of bytes that may be pushed onto a file 110 
 buffer. Calling $fseek may erase any pushed bytes. If calling $ungetc results in an 
 error, then -1 is returned, otherwise 0 is returned. 

 $fgets reads a string of bytes from a file and places the string into a reg variable. 
 The file is read until the variable is filled, a newline character is read and transferred 
 to the variable, or end-of-file is encountered. If the variable is not an integral number 
 of bytes in length, the most significant partial byte is not used, and is not counted to 
 determine the number of bytes read. If calling $fgets results in an error, then 0 is 
 returned. Otherwise, the number of bytes read is returned. 

 $fscanf reads bytes from a file and formats the text according to the format codes 
listed in the following table. A format string is specified, followed by a set of argu•
 ments for where to place the values read in. The arguments must be variables of the 
appropriate data type for the format code. The format string may be a literal string or 
a reg variable containing a string. The format string may contain: 

• Format codes consisting of the % character, followed by an optional * character, fol•
  lowed by an optional decimal digit string that specifies a maximum field width for 
  the conversion, followed by a conversion code (e.g. %d or %*c). 
• White-space characters (blanks, tabs, new-lines or form-feeds). A contiguous set of 
  any number of white-spaces will cause the file to be read up to the next non-white•
  space character. The white-spaces read in from the file are discarded. 
• Non-white-space characters, except %. Each group of characters must be separated 
  by a White-space and must match the next character read from the file. If the char•
  acter is not found, $fscanf will terminate. The character is read from the file and 
  discarded. It is not assigned to an argument of $fscanf. 

$fscanf returns the number of arguments actually assigned values. If end-of-file is 
encountered before any value is assigned, then -1 is returned. The conversion format 
code directs the conversion of the next input field. The result is placed in the corre•
sponding variable in the argument list. If the format code contains the optional * char•
acter, the conversion assignment is suppressed, and the value read in is discarded. The 
argument list must not contain a corresponding variable for suppressed conversions. 
72                  Verilog-2001: A Guide to the New Features of the Verilog HDL 

Some example usages of $fscanf are: 
    integer   err;     reg   [63:0]  a,  b;     integer   i;      real  r; 
    err     $fscanf("%t    %b",r,a);    Ilvalues   separated    by  white-space 
    err     $fscanf("%d,%8h",      i,  a);     Ilvalues   separated    by  comma 
    err     $fscanf("%b%*c%b",      a,  b);    Ilvalues   separated    by  any 
                                             character,    which   is discarded 

       Converts the character string read from a file to a binary value. The characters must 
  %b 
       be from the set 0,1 ,X,x,Z,z,? and _. 

       Converts the character string read from a file to an octal value. The characters must be 
  %0 
       from the set 0,1,2,3,4,5,6,7,X,x,Z,z,? and_. 
       Converts the character string read from a file to a signed decimal value. The charac-
  %d   ters must be from the set 0,1,2,3,4,5,6,7,8,9 and _, or a single character from the set 
       x,X,z,Z, ? The value can be preceded by a sign character, from the set + or -. 
       Converts the character string read from a file to a hexadecimal value. The characters 
  %b 
       must be from the set 0,1,2,3,4,5,6,7,8,9,a,A,b,B,c,C,d,D,e,E,f,F,x,X,z,Z,? and_. 

  %x   Same as %h. 
       Converts the character string read from a file to a real value (double-precision floating 
       point). The characters representing a real number must consist of an optional sign 
       character (either + or -) followed by a string of digits from the set 0,1,2,3,4,5,6,7,8,9, 
  %f 
       which can optionally contain a single decimal point character (.), then an optional 
       exponent part beginning with the character e or E, followed by an optional sign char-
       acter, followed by a string of digits from the set 0,1,2,3,4,5,6,7,8,9. 
  %e   Same as %f. 

  %g   Same as %f. 
       Converts the character string read from a file to a net signal strength. The string must 
       be three characters that are the same strength codes returned by %v with $display 
       (e.g., stO for strong logic or wei for weak logic 1). Only I-bit values can be repre-
  %v                          ° 
       sented. Note, this conversion is not particularly useful, because the argument to 
       $ fscanf that receives the value must be a variable, which can only store the logic 
       value and not the strength level. 
       Converts the character string read from a file to a floating point time value. The char-
  %t   acters in the file must the same as with %f. The value read in is scaled according to 
       the current time scale as set by $timeformat and' timescale. 
       Matches a single character from a file, whose 8 bit ASCII value is assigned to the cor-
  %c 
       responding argument. 
       Matches a string of characters from a file, which must be a sequence of characters that 
  %s 
       do not contain a white-space; the string is assigned to the corresponding argument. 
  %%   A single %character  is expected in a file at this point. No assignment is done. 
 Enhanced file I/O                                                     73 


   %u  Reads unformatted 2-state (logic 0 and 1) binary data from a file. 

   %z  Reads unformatted 4-state (logic 0, 1, z, x) binary data from a file. 
       Assigns the corresponding variable a string containing the current hierarchical path to 
   %In 
       the scope containing the call to $fscanf. Does not read data from the input file. 

 For all format codes except %c, any white-space leading an input field is ignored. 

 The %t format reads a value from the file, and converts the value to a scaled simula•
 tion time value. The scaling is based on two factors: the current setting of the $time•
 format system task, and the setting of the' timescale directive in effect when the 
 module containing $fscanf was compiled. For example, if the current time format is 
 $timeformat (-3, 2, "ms",  10) and the time scale is 'timescale 1ns/l00ps, 
 then the string "10.345" would be interpreted as 10.35 milliseconds, which would 
 then be scaled to 10350000.0 nanoseconds 

 The %u format will transfer unformatted 2-state binary data from the input stream to 
 the destination variable, without performing any conversion. Sufficient data from the 
 input is read to fill the number of bits in the corresponding variable. The values in the 
file are in a binary form, not ASCII text form. This format code is intended to be used 
to support the transfer of data to and from external programs that have no concept of x 
 and z. The data is read from the file in the native endian format of the underlying 
operating system. For portability to all operating systems, the file should be opened in 
binary mode, using "rb", "r+b" or "rb+". 

The %z format will transfer unformatted 4-state binary data from the input stream to 
the destination variable, without performing any conversion. Sufficient data from the 
input is read to fill the number of bits in the corresponding variable. This format code 
is intended to be used to support the transfer of data to and from external programs 
that understand logic x and z. The values in the file are in a binary form, not ASCII 
text form. The binary representation of 4-state logic uses a pair of bits known as avaIl 
bval pairs to encode the 4-state logic. For a full description of avallbval pairs, refer to 
the IEEE 1364-2001 standard, or the author's book "The Verilog PLI Handbook", 
also published by Kluwer Academic Publishers. For portability to all operating sys•
tems, the file should be opened in binary mode, using "rb", "r+b" or "rb+". 

Reading binary values from files 

$fscanf (described above) can be used to read binary data from a file, using either 
the %u or %z format. 

$fread can also be used to read raw binary data from files. The value read can be 
loaded into a reg, integer or time variable, as well as I-dimensional array of reg 
variables (referred to as a memory array). The data read from the file is treated as 2-
74               Verilog-2001: A Guide to the New Features of the Verilog HDL 

state values, with logic 0 and 1 only. $ fread returns the number of bytes read in, or 0 
if an error occurs. 

When reading values into a variable, $fread requires two arguments: the name ofthe 
variable, followed by the fd file descriptor that was created by $fopen. The data 
from the file is read in bytes, and loaded into the variable from right to left. The first 
byte read from the file is loaded into the right-most (least significant) byte of the vari•
able. Each subsequent byte is loaded into the next byte to the left, until the variable is 
fully loaded. 

If the width of the variable is not an integral number of bytes, the last byte read in will 
be loaded into the left-most bits of the variable from right to left, and the unused left•
most bits of the byte read in will be truncated. The next call to $fread will begin at 
the next byte in the file; not where the last bit of a byte was truncated. No error is gen•
erated if a byte read in is truncated. 

When reading values into a memory array, $fread can take two additional optional 
arguments: a starting address, which specifies where to begin loading the array, and 
an ending address, which /specifies where to stop loading the array. If a starting 
address is specified, the loading will begin at that address and increments in address 
numbers until either the optional ending address is reached, the highest number 
address in the array is reached or end-of-file is reached. If the optional starting 
address is not supplied, loading begins with the lowest number address of the array 
and increments in address numbers until either the highest number address in the 
array is reached or end-of-file is reached. Each word in the array is loaded using how•
ever many bytes from the file as required to fill the array, the same as with loading a 
single variable. No error is generated if end-of-file is reached before the memory 
array is filled or the optional ending address is reached. As with loading a single vari•
able, no error message is generated if a byte read in is truncated because the memory 
word size is not an integral number of bytes. 

Controlling files 

$ftell returns the byte number of the next byte which will be read or written in a 
file. The number is always relative to the beginning of the file. A -1 is returned if an 
error occurs. 

$fseek repositions the file to a different location. The next byte to be read or written 
will be at the new position. $fseek requires three arguments: the fd file descriptor, an 
offset number, which can be a positive or negative integer value, and an operation 
code. The code must be 0, 1 or 2, where: 

•  0 indicates that the file position should be set to the offset value. 

•  1 indicates that the file position should be set to the current position plus the offset. 
 Enhanced file I/O                                                    75 


 •  2 indicates that the file position should be set to the end-of-file plus the offset. 

 It is legal to set the file position to beyond the end of the file. The next write to the file 
 will extend the file size to the new byte number, filling the gap with zeros. A file that 
 is opened in append mode cannot be written to at a location before the end-of-file. If 
 $ fseek sets the file position to another location, the location can be read, but the next 
 write will automatically reposition the file position back to the current end-of-file. 

 $frewind  repositions the file to the beginning of the file. It is the same as 
 $fseek(fd,  0,  0); 

 $fflush causes any buffered output to one or more open files to be written into the 
 files. The argument to $ f flush can be an fd representing a single file, or an mcd rep•
 resenting one or more files. $fflush can also be called with no arguments, in which 
 case the buffers for all open files will be flushed. 

Testing for file 1/0 errors 

 $ferror can be used to test to see if an error occurred with any of the new file I/O 
system tasks and functions. The arguments supplied to $ ferror are an fd and a reg 
variable that should be at least 640 bytes wide. The routine writes a more complete 
description of the error that occurred in the most recently called file I/O routine and 
returns an error number representing the error. If no error occurred, a 0 is returned and 
the error string variable is cleared. 

Synthesis considerations 

This enhancement is not synthesizable. Synthesis does not support system tasks or 
file I/O. 


    Note: The Verilog-2001 enhanced file 110 routines are generally a super set of public 
    domain PLI-based file 110 routines available on the internet (created and maintained 
    by Chris Spear of Synopsys). There are several differences between the Verilog-2001 
    routines and the public domain PLI routines. Refer to Chris Spear's web page, at 
    www.chris.spear.netlpli for more details. 
76               Verilog-2001: A Guide to the New Features of the Verilog HDL 

32.   String read       and write system tasks 


Background 

With Verilog-1995, reg variables can be used to store string values. The string can be 
loaded into the variable using procedural assignments. For example: 

   reg  [(64*8)-1:0]  name;  //can hold  up  to 64 characters 

   initial 
     name  = "test_vector_file.pat"; 

Using part-selects, any portion of the reg variable can be loaded. However, Verilog-
1995 has no convenient method of converting numerical values or other types of 
information to strings, in order to load them into a variable. 

What's new 

    eri10g-2001 provides several new system tasks and functions to create a format•
Vted string that is then loaded into a reg variable. Another new system function 
allows extracting information from a string, and converting the string to logic values. 

Creating formatted   strings 

The new system tasks and functions that load strings are: 
    $swrite(reg_variable,   format_str,  args, format_str,  args, ... ); 
    $swriteb(reg_variable,   format_str,  args, format_str,  args, ... ); 
    $swriteo(reg_variable,   format_str,  args, format_str,  args, ... ); 
    $swriteh(reg_variable,   format_str,  args, format_str,  args, ... ); 
    $sformat (reg_variable,  format_str,  args); 

The $swrite, $swriteb,  $swriteo and $swriteh, system tasks are similar to 
their corresponding $write system tasks, except that the string is written to the reg 
variable, rather than to a file. The Jonnacstr is an optional argument with these sys•
tem tasks. If it is omitted, the arguments are formatted using a default format of deci•
mal, binary, octal or hexadecimal, respectively. As an example, the following 
statement converts the value of the current simulation time and the value of the signal 
data to strings, and loads the variable message with the resultant string message: 
S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 String read and write system tasks                                   77 


    reg [(64*8)-1:0]   message;  //can  hold up  to 64  characters 

    initial 
      $swrite(message,   "At %d:",  $time,  " data  is %b",  data); 

 $sformat works like $swri te, except that only a single format string is allowed, 
and the format string is mandatory instead of optional. 

 Reading from   formatted  strings 

Verilog-2001 adds a new system function that reads values from a string: 

    code = $sscanf (reg_variable,  format_string,   list_of_args); 

$sscanf is similar to $fscanf, except the string is read from a variable, rather than 
from a file. The previous section of this book describes the formatting controls which 
can be used by $fscanf. 

SyntheSiS considerations 

This enhancement is not synthesizable. 
 78               Verilog-2001: A Guide to the New Features of the Verllog HDL 

 33.   Enhanced invocation option testing 


 Background 

 Verilog-1995 provides the built-in $test$plusargs system function, which allows 
 testing to see if a software tool was invoked with a specific invocation option. The 
 routine returns 0 if the invocation option does not exist, and a non-zero value if the 
 option does exist. 

 The invocation option must begin with a plus sign ( + ). The string provided to 
 $test$plusargs, however, does not include the plus sign. As an example, a Verilog 
 test bench might contain the following code: 

    initial 
      begin 
        if  ($test$plusargs("testl"» 
           $readmemh("testl.dat",   vectors); 
        else  if  ($test$plusargs("test2"» 
           $readmemh("test2.dat",   vectors); 
        else 
           $display("Error:   no test  option  specified"); 
      end 

 If simulation were invoked with +test2 on the command line, then the second call to 
 $test$plusargs in the preceding example would test as true. 

 Note that $test$plusargs does not test for an exact match. Instead, the routine 
 considers the string provided to be a prefix to be matched. This means that if a soft•
 ware tool were invoked with the option +HELLO, all of the following calls to 
 $test$plusargs would return true: 
    $test$plusargs ("HELLO") 
    $test$plusargs("HE") 
    $test$plusargs("H~) 

The following call would test as false, however, because the test string contains addi•
 tional characters which were not part of the invocation option: 
    $test$plusargs ("HELLO_WORLD") 

It should be noted that the Verilog Programming Language Interface (PU) can access 
 the entire invocation command line. 

 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Enhanced Invocation option testing                                   79 

What's new 

    eriIOg-2001 adds another invocation test system function, $value$plusargs, 
 Vwhich allows testing for arguments to an invocation option. $value$plusargs 
requires two arguments: a test string with format codes, and a variable. The system 
function loads the variable with a formatted value, where the value is derived from 
the text that follows the invocation option, up to a white-space. The format codes are: 

    %b   binary conversion 
    %0   octal conversion 
    %d   decimal conversion 
    %h   hexadecimal conversion 
    %f   real decimal conversion 
    %e   real exponential conversion 
    %g   real decimal or exponential conversion 
    %s   string (no conversion) 

 $value$plusargs returns 0 if a matching invocation was not found, and non-zero if 
a matching option was found. The routine considers the test string to be a prefix. 
Since any text that follows the test prefix, up to a white-space, will be converted as 
the value of the option, care should be taken not to have two similar invocation 
options that could both test as true for the same test string. 

Some  examples of using $value$plusargs   are shown below. These examples 
assume a simulation was invoked with options such as +testfile-test2 .dat and 
+clock-»eriod-l0. Note that the equal sign ( - ) is included in the test string in this 
example. $value$plusargs will convert and return whatever text follows the equal 
sign, up to a white space. 

   integer period; 
   reg  [1023:0]  file_string; 
   initial 
      begin 
        if  ($value$plusargs(-testfile-%s",     file_string)} 
          $readmemh(file_string,    vectors); 
        else 
          $display("Error:   no  test file  option  specified"); 
        if  ($value$plusargs(-clock-period-%d",     period)} 
          forever  #(period/2)   clock=-clock; 
        else 
          $display("Error:   no  clock period option   specified"); 
      end 
 80               Verilog-2001: A Guide to the New Features of the Verilog HDL 

 34.   Enhanced conditional compilation 


 Background 

 Verilog-1995 has the conditional compilation directives: 'ifdef, 'else, 'endif, 
 and 'undef. These directives control what portions of Verilog source code will be 
 read in by a software tool. The simple if-else decision flow, however, can be awk•
 ward when there are multiple decisions to make. 

 The following example tests just two conditions for compilation, but becomes some•
 what convoluted using only if-else decisions. If there were several decisions, the 
 example would become very difficult to understand and maintain. 

    'ifdef  RTL_TEST 
       alu_rtl   ul  ( ... ); 
    'else 
    'ifdef  GATE_TEST 
       alu_gate  ul  ( ... ); 
    'else 
       initial  $display(\\ERROR:  neither  RTL  or GATE model  used"); 
    'endif 
    'endif 

What's new 

    erilOg-2001 adds two additional conditional compilation directives, 'ifndef 
 Vand   'e1sif. The' ifndef compiler directive allows testing to see if a macro 
name has not been defined. The' elsif directive allows testing for a series of condi•
tions to determine what source code should be compiled. 

An  example of using 'i fndef is: 

    'ifndef  INCLUDES 
      'include  \\macros.vh" 
      'define  INCLUDES 
    'endif 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
Enhanced conditional compilation                                                81 


The following example uses  'el s i f to simplify testing for mUltiple conditions. 

    'ifdef   RTL_TEST 
       alu_rtl     ul  ( ... ); 
    'elsif GATE_TEST 
       alu_gate    ul  ( ... ); 
    'else 
       initial    $display("ERROR:     neither    RTL  or  GATE  model   used"); 
    'endif 

Synthesis considerations 

This enhancement should be synthesizable. 
 82               Verllog-2001: A Guide to the New Features of the Verilog HDL 

 35.   Source file and line compiler directive 


 Background 

 Designs modeled in Verilog are typically partitioned into dozens, possibly hundreds, 
 of separate source code files. When simulation, synthesis, or other software tools 
 report errors or warnings-whether during compilation or during run-time-the mes•
 sages usually reference the source file name and line number. The Verilog Program•
 ming Language Interface (PLI) can also access the source file and line information 
 from within the simulation data structure. 

 In many design environments, however, it is common to pass the Verilog source code 
 files through some sort of preprocessor, which then passes the code on to the simula•
 tor, synthesis or other software tool. The preprocessor might add additional lines to 
 the source code file, combine multiple source code lines into one line, or even concat•
 enate multiple source files together. When this occurs, error and warning messages 
 generated from the software tool will no longer report accurate information on the 
 original source file and line number that caused the error or warning. 

 Verilog-1995 has no provisions for allowing software tools to locate the original 
 source file and line number after a preprocessor has modified the source locations. 

 What's new 

    eriIOg-2001 adds a special 'line compiler directive that allows the original 
 Vsource location of Verilog code to be maintained in the compiled software tool 
 data structures. 

The  'line directive is not intended to be used by those creating Verilog models. 
More typically, this compiler directive would be inserted by a preprocessor into any 
code that the preprocessor relocates. When a simulator or other software tool needs to 
report a message containing the Verilog source information, the original source file 
 and line number will have been preserved through the use of the 'line compiler 
directive. 

The syntax of the 'line directive is: 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Source file and line compiler directive                              83 

 The 'line directive sets a compiler's current line number counter and source file 
 name to the values provided, replacing whatever the compiler had been maintaining. 
 The line_number argument indicates the line number of the next line of code. The 
 number will be incremented by the compiler for each subsequent line until the end of 
 the file or a new' line directive. The source file_name argument can be a simple file 
 name, or it may include a full or relative directory path. 

 The leveCcode is a flag which is added by the preprocessor when it creates the 'line 
 directive. The code must have a value of 0, 1 or 2. A 1 indicates that the line follow•
 ing the 'line directive is the first line after an include file (from a 'include direc•
 tive) has been entered. A 2 indicates that the line following the 'line directive is the 
first line after an include file has been exited. A 0 indicates that neither of these has 
occurred. The level code might possibly be used by software tools to create more 
 informative error messages, such as: 

    Error: Out-of-bounds   array  index  at file:  control.v   line: 54 
         included   from file:  fsm.v  line: 17 

There is no requirement that a software tool make use of the level code, but the infor•
mation should be provided by a preprocessor so that it is available if a tool does wish 
to utilize level codes. 

Synthesis considerations 

This enhancement may be synthesizable. 
 84               Verilog-2001: A Guide to the New Features of the Verilog HDL 

 36.   Generate blocks 


 Background 

 A complex design modeled in Verilog may have several levels of hierarchy, where 
 one module contains instances of other modules. Even small designs are often repre•
 sented as a top-level module that connects together several lower level modules. One 
 example might be building a larger 64-bit adder from several smaller 8-bit adders. 

 At the structural level of modeling, Verilog-1995 provides three ways to instantiate 
 multiple modules or primitives: 
 • Separate instance statements, such as: 

    adder8  uO (sum [7 : 0),  co (1),  a[7:0),     b[7: 0),     ci[O)l; 
    adder 8 u1 (sum[15: 8),   co [2),  a[15:8),    b[15:8),     ci[1)l; 
    adder8  u2 (sum[23: 16),  co [3),  a[23:16),   b[23:16),    ci[2)l; 

    adder8  u7 (sum[63: 56),  co (8),  a[63:56),   b[63: 56),   ei (7) l ; 
 •  A comma-separated list of instances, such as: 

    adder 8 uO (sum[7: 0),    co (1),  a[7:0),     b[7:0),      ci[O)l, 
            u1 (sum[15:8),    co [2)'  a[15:8),    b[15:8),     ci [1) l , 
            u2 (sum[23: 16),  co [3),  a[23:16)'   b[23:16),    ci(2)l, 

            u7 (sum[63:56),   eo[8),   a[63:56),   b[63:56),    ci(7)l; 
 • An instance array, such as: 
    adder8  u[7:0)  (sum, eo[7:0),  a,  b, ci[7:0)l: 

 The array of instances construct is a convenient short cut for creating multiple 
 instances of a module or primitive, but it does have limitations. The construct works 
 well when each instance is connected to the same signals. It becomes convoluted, if 
not impossible, to use an array of instances to create a netlist of components with 
 more complex interconnections between them. 

 At a more abstract level of modeling, Verilog-1995 does not have a method for repli•
cating the same block of logic several times. Behavioral and RTL level models are 
 represented with always procedures and continuous assignments. The following 
 RTL example models a gray-code to binary converter using continuous assignments 
 (the example assumes an 8-bit gray code input): 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Generate blocks                                                       85 


    assign  bin[7]    gray[7]; 
    assign  bin[6]    bin[7]  A gray[6]; 
    assign  bin[5]    bin[6]  A gray[5]; 

    assign  bin[4]    bin [5] A gray [4] ; 
    assign  bin[3]    bin[4]  A gray[3]; 

    assign  bin[2]    bin[3]  A gray[2]; 

    assign_bin [1]    bin[2]  A gray[l]; 
    assign  bin[O]    bin[l]  A gray[O]; 

 Verilog-1995 does not provide a method to create multiple procedures or continuous 
 assignments. Each one must be created separately, often by typing the code by hand. 

 What's   new 

     erilOg-2001 adds a powerful construct for creating mUltiple instances of an object 
 Vwithin   a module, the generate block. The following new reserved words have 
 been added: generate, endgenerate and genvar. 

 Most types of objects that can be placed within a Verilog module can also be gener•
 ated from a generate block, making it easy to create any number of those objects. The 
 primary items which can be generated are: 
 • Any number of module and primitive instances 
 • Any number of initial or always procedural blocks 
 • Any number of continuous assignments 
• Any number of net and variable declarations 
• Any number of parameter redefinitions 
• Any number of task or function definitions 

Items that are not permitted in a generate statement include: port declarations, con•
stant declarations, and specify blocks. 

Within the generate block, for loops can be used to create any number of objects. In 
addition, if-else decisions and case decisions can be used to selectively control 
what objects are generated. 

The genvar variable 

The genvar variable is a special integer variable for use as the index control variable 
by generate for loops. The value of a genvar variable can only be assigned a posi•
tive number or 0; values with X or Z, or negative values cannot be assigned. A gen•
var variable can only be used during elaboration, and cannot be accessed during 
 86               Verilog-2001: A Guide to the New Features of the Verilog HDL 


 simulation-it no longer exists at that point. A genvar can only be assigned a value 
 as part of a generate for loop control statement. Its value can be read within a gener•
 ate block any place that a parameter constant could be used. 

 A genvar variable can be declared outside of a generate block, or within a generate 
 block. When declared outside of the generate block, any number of generate blocks 
 can use the same variable. 

 Generate loops 

 A generate for loop is used to create one or more instances of items that can be 
 placed within a Verilog module. The loop is essentially the same as a regular Verilog 
 HDL for loop, but with these limitations: 

 • The index loop variable must be a genvar. 
 • Both assignments in the for loop control must assign to the same genvar. 
 • The contents of the loop must be within a named begin-end block. 

 The reason the contents of a generate loop must be within a named begin-end 
 block is so that a unique name can be created for each generated name, such as a mod•
 ule instance name or net name. The name of the block becomes a prefix to the gener•
 ated names, followed by the loop variable count in square brackets. 

 The example having 8 instances of an 8-bit adder module shown on the previous page 
 can easily be generated as follows: 

      generate 
        genvar  i; 
        for  (i-O;  i<-7; i-i+l) 
          begin:  u 
             adder8  add  (sum[(i*8)+:8],  co[i+l], 
                            a[ (i*8)+:8],  b[ (i*8)+:8],  ci[i]); 
          end 
      endgenerate 

The generated instance names in the preceding example are: 

    ufO] . add 
    u[l] . add 

    u [7] . add 

 Note: the square brackets in the generated names are regular characters. They do not represent 
 indexes into an array, and cannot be represented with a variable. (i.e. f f  [ i] . ul is illegal). 
 Generate blocks                                                      87 

 The gray-code to binary converter example, with eight continuous assignment state•
 ments, can also be generated with just a few lines of code, as follows. 

    generate 
      genvar  i; 
      assign  bin[7]  = gray[7]; 
      for  (i-6; i>-O;  i-i-l) 
        begin:  gray2bin 

          assign  bin[i]  =  bin[i+l]  A gray[i]; 
        end 
    endgenerate 

 The number of objects generated can also be based on constants. If parameter con•
 stants are used, the value of the constant can be redefined at elaboration, allowing the 
 number of objects generated to be easily configured. For example: 

    parameter  SIZE  - 64; 
    generate 
      genvar  i; 
      assign  bin[SIZE-l]     gray[SIZE-l]; 
      for  (i=SIZE-2;  i>=O;  i=i-l) 
        begin:  gray2bin 

          assign  bin[i]  = bin[i+l]   A gray[i]; 
        end 
   endgenerate 

The generate block can be used to generate procedural code as well as structural code 
and continuous assignments. The following example illustrates using a generate state•
ment to create multiple always procedures. The example creates a sequential logic 
gray-code to binary converter, using a slightly different algorithm for the conversion. 

   parameter   SIZE =  8; 
   genvar  i; 
   generate 
      for (i=O;  i<=SIZE-l;  i=i-l) 
        begin:  proc 
          always  @(posedge  clock  or negedge   reset) 
            if  (reset  _. 0) 
               bin [i) .. l'bO; 
            else 
               bin[i)  • Agray[SIZE-l:i); 
        end 
   endgenerate 
88               Verllog-2001: A Guide to the New Features of the Verilog HDL 

Conditional generation 

Verilog if-else and case statements can be used within a generate block to con•
trol what objects are generated. The following example examines the width of the 
input busses to determine what type of multiplier should be instantiated. 

   module  multiplier  (a,  b, product); 
     parameter  a_width  = 8,  b_width  = 8; 
     localparam  product_width      a_width  + b_width; 
     input    [a_width-1:0l          a; 
     input    [b_width-1:0l          b; 
     output   [product_width-1:0l    product; 

     generate 
       if  «a_width   < 8)  I I (b_width < 8» 
         CLA_mult   # (a_width, b_width)  u1  (a, b, product); 
       else 
         WALLACE_mult   # (a_width,  b_width)  u1  (a, b, product); 
     endgenerate 
   endmodule 

A case statement can be used when there are several conditions to test to determine 
what should be generated. The case expression and case items can only use constant 
expressions or genvar variables. That is, the values which are tested must be known 
values at elaboration time. Regular variables and nets will not have values during 
elaboration, and therefore cannot be used in a generate block. 

The following example illustrates using a generate case statement to control which 
objects are generated: 

   parameter  WIDTH    1; 
   generate 
     case  (WIDTH) 
       1:   adder_1bit  x1(co,  sum,  a, b, ci); 
       2:   adder_2bit  x1(co,  sum,  a, b, ci); 
       default:  adder_cia   # (WIDTH) x1(co,  sum, a,  b, ci); 
     endcase 
   endgenerate 

Using arrays with generate blocks 

Generate blocks can be used to connect module or primitive instances up to a matrix 
of signals, represented by arrays of nets or variables. Verilog-2001 permits multidi•
mensional arrays of any data type, and to select bits or parts from an array (see sec•
tions 15, 16 and 17). The combination of arrays and generate blocks makes it possible 
to create elaborate netlists with a minimal amount of code. 
 Generate blocks                                                      89 

 The following example illustrates declaring an array of net vectors, where each vector 
 is 4 bits wide (using the default value of the SIZE parameter), with 3 vectors in the 
 array (three internal nets are needed to connect the gates within each adder that is 
 instantiated). Each pass of the generate loop instantiates the logic gates required to 
 model a 1-bit adder, and connects the gates together using bits from the net array, n. 

    module  Nbit_gate_adder   #(parameter  SIZE  = 4) 
                               (output  wire  [SIZE-1:0]  sum, 
                                output  wire              co; 
                                input   wire  [SIZE-1:0]  a, b, 
                                input   wire              ci) ; 

      wire    [SIZE   : 0] c;   //internal  carry bits   between  adders 
      assign  c[O]    ci;       //carry  in 
      assign  co      c[SIZE];  //carryout 

      wire  [SIZE-1:0]  n  [1:3];    //internal  nets  in each  adder 
      genvar              ii 

      generate 
        for(i=O;  i<SIZE;  i=i+1) 
          begin:  addbit 
             xor gl  ( n[l] [i],    a[i],      brill; 
             xor g2  (  sum[i] , n[l] [i],     crill; 
             and g3  ( n[2] [i],    a[i],     b [i] ) ; 
             and g4  ( n[3] [i], n[l] [i] ,    c [i] ) ; 
             or  g5  (  c [i+1], n[2] [i], n[3] [i]) ; 
          end 
      endgenerate 
    endmodule 


Synthesis considerations 

This enhancement should be synthesizable. 
 90             Verilog-2001: A Guide to the New Features of the Verllog HDL 

 37.  Configurations 


 Background 

The Verilog-1995 standard, and all earlier generations of Verilog, have left the task of 
 managing the source files of a design up to software tools. Design source manage•
 ment has not been a part of the Verilog language. 

 Early generations of Verilog simulators and synthesis tools provided a minimum level 
of design source management through invocation options. The two most common 
options are -v and -yo A number of additional options, such as +libext and 
 +liborder provide supplemental information for the -v and -y options. Managing 
design source location using invocation options works marginally when there is a sin•
gle library. When multiple libraries are involved, the invocation options do not pro•
vide the design management control needed. In particular, the -v and -y options do 
not allow two modules with the same name to come from different sources. This 
means two different libraries cannot have modules with the same names. Nor can an 
RTL version of a module be used for one instance, and a gate-level version used for a 
different instance of the same module. 

As design complexity grew, many simulator vendors added a 'us.lib compiler 
directive to their products. This directive provides the same information about source 
libraries that the -v and -y invocation options. As a compiler directive, however, the 
information can be embedded directly in the Verilog models. Each instance of a mod•
ule can come from different libraries, which overcomes some of the shortcomings of 
using invocation options for design management. With 'usel ib, however, the source 
file information must be hard coded into the Verilog models. This requires modifying 
the Verilog source code if a library is moved to a different location or if the design 
configuration changes. Another disadvantage of 'uselib is that the directive is not 
part of the IEEE Verilog standard. 

Simulator vendors and other EDA tool companies have devised other methods for 
managing the source file locations for Verilog models, but none of these proprietary 
methods are universally supported by tools from many different vendors. 


 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Configurations                                                       91 

 What's   new 

     erilOg-2001 adds configurations, which brings design source management into 
 Vthe Verilog language. Configurations provide a consistent method for specifying 
 the location of Verilog source files that will work with all software tools that use Ver•
 ilog. The processes of associating a specific source file with a specific instance is 
 referred to as binding the source and the instance together. Several new reserved 
 words have been added in Verilog-2001 to support configurations: config, endcon•
 fig, design, instance, cell, use and liblist. 

 A configuration block is specified outside of module boundaries. It can be in the same 
 file as the Verilog source code, or in a separate file. One configuration block can ref•
 erence another configuration block, creating a hierarchy in the configurations. A large 
 Verilog design can be described in a single configuration, or the description can be 
 broken into multiple configuration blocks. 

 In the configuration block, symbolic library names are used to represent source file 
 locations. A symbolic library is a collection of module definitions, primitive defini•
 tions, and configurations. Each module, primitive or configuration is referred to as a 
 cell. The symbolic library can represent a single file or a collection of files, which 
 may be in any number of file directories. 

 Separate library map fues map the symbolic library names to the physical location of 
 the source files. By using symbolic library names, the Verilog source files and config•
 uration blocks do not need to be modified if the location of the source files is moved. 

A configuration block consists of these major parts: 
•  A name for the configuration (so that it can be referenced by other configurations). 
• The names of the top level modules in the configuration, and in which symbolic 
  libraries they are found (all designs have at least one top-level module). 
•  A list of one or more default symbolic libraries for where Verilog software tools 
  should search for modules and primitives referenced by a design. 
• Any number (including none) of specific bindings, for when a specific module or 
  primitive definition-or a specific instance of a module or primitive-should be 
  associated with a different symbolic library, other than the default libraries. 

A  configuration block can contain either style of Verilog comments. The following 
example defines that the top-level module is tesCbench, and that the default symbolic 
libraries to be used by the design are first rtlLib, and then gateLib. For certain compo•
nents, however, the source code is in different symbolic libraries. 
 92               Verllog-2001: A Guide to the New Features of the Verllog HDL 

    config  my_chip_cfg2    Iiname of  this configuration 
      design  rtlLib.test_bench     Illocation  & name  of top  level 
      default  liblist rtlLib gateLib;    Iidefault  sources  to  search 
      cell  fsm liblist my_coworkers_lib; 
      instance  test_bench.dut.adder    liblist arithmeticLib; 
    endconfig 

 The design statement identifies the top-level module of a design. There can only be 
 one design statement in a configuration block, but multiple top-level module names 
 can be listed. The design statement must appear before any other configuration 
 statements. The symbolic library name is separated from the top-level module name 
 by a period. The library name is optional. If it is not specified, then the top-level mod•
 ule is searched for in the same location that contains the configuration. 

 Note that the top-level module specified in the design statement is the top-level for 
 the configuration, which is not necessarily the top-level of the entire design. Each 
 major block of a design can be configured separately, and a higher-level configuration 
 block can reference lower-level configuration blocks. 

 The default statement specifies the symbolic libraries in which to search for mod•
 ules, primitives or configurations that do not match a more specific instance clause. 

 The cell statement specifies which symbolic libraries in which to search for all 
 instances of a particular module or primitive. The cell statement must have either a 
 liblist clause or a use clause to indicate the symbolic libraries in which to search. 

 The instance statement specifies a specific symbolic library in which to search for 
 one instance of a module or primitive. The instance name must be a Verilog hierarchi•
 cal name, starting at the top-level module of the configuration (the name specified in 
 the design statement). The instance statement must have either a liblist clause 
 or a use clause to indicate the libraries in which to search for the cell. 

 The liblist clause defines an ordered set of libraries to be searched to find a cell 
 or instance. The liblist is inherited hierarchically downward as instances are 
 bound. 

The use clause specifies the exact library and module or primitive to which a selected 
cell or instance should be bound. The library name is optional. If it is omitted, the 
 library will be inherited from the current liblist. 

 It is possible for a configuration to have the same name as a module or primitive. If 
 the module or pnmitive being referred to by a use clause is another configuration, 
 which has the same name as a module or primitive in the same library,  then an 
 optional : conf ig suffix should be added to the end of the name. For example: 
      cell  fsm use  fsm:config; 
 Configurations                                                        93 

 The library map file 

 A library map file defines the set of files that are contained within a symbolic library. 
 A library statement is used to map a symbolic library name to any number of single 
 physical file name or physical directory names. Multiple files or directories are listed 
 as a comma-separated list. The library map file can contain either style of Verilog 
 comments, but no other Verilog constructs can be in the file. 

 A library map file can also reference other library map files through the use of an 
 include statement. 

 The following example illustrates a possible library map file for the configuration on 
 the previous page: 

    /* define  libraries  for  my design  */ 
    library  rtlLib  ./*.v   -incdir  .. /include_files/  ; 
    library  gateLib  ./flattened.v,   ./synth_out/*; 
    //design ware   is defined  in a  different  library map   file 
    include  /home/tools/synth_lib/designware_lib.map; 

 The following wild cards can be used in directory paths and file names: 

    ?     single character wildcard (matches any single character) 
    *     multiple character wildcard (matches any number of characters) 
          specifies the directory containing the library map file 
          specifies the parent directory of the directory containing the map file 
          hierarchical wildcard (matches any number of hierarchical directories) 

Paths which do not begin with I are relative to the directory in which the current 
library map file is located. Paths which end in either a I or I * include all files in the 
specified directory. 

Optionally, a library statement can include an -incdir clause. This clause speci•
fies where a software tool should search for files referenced by the' include direc•
tive that may occur in Verilog source code. The -incdir clause can specify a single 
location, or a comma-separated list of locations. 

The IEEE standard does not specify how library map files are passed into software 
tools-that is left up to the implementation. As a minimum, most software tools will 
probably have an invocation option to specify the names of library map files. 

SyntheSis considerations 

This enhancement should be synthesizable. 
 94               Verllog-2001: A Guide to the New Features of the Verllog HDL 

 38.   On-detect pulse error propagation 


 Background 

 In the Verilog standard, a glitch is referred to as a pulse, and refers to a sequence of 
 input logic changes that cause a second output change to be scheduled before the first 
 change has actually occurred. As a simple example, assume that a buffer module has 
 a timing path from the a input to the y output, specified as follows: 
      specify 
         (a *> y)  = (4,6);   //rise delay  = 4,  fall  delay    6 
      endspecify 

 In this example, a rising transition on a will take 4 time units to propagate to y, and a 
 falling transition on a will take 6 time units to propagate. If the a input changed from 
 o to 1 at time 10, the output will change to 1 at time 14. If however, the a input 
 changed back to 0 at time 12, the y output will be scheduled to change a second time, 
 before the change at time 14 has actually occurred. In other words, there was a 2 time 
 unit glitch on the input to the buffer, as illustrated below: 

                                        10  12  14     18 
    rise delay =4,  fall delay =6  
                               a 
     ------j[>>----               ----------~~~~I----~---I  I  I  I 
                                         I   I   r - - i  possible transition 
                                                          on the output 
                                  __....... _..0...- ......1  - - ....1_- Y 

 Verilog-1995 provides a means for library modelers to specify how glitches will prop•
 agate through modules. Pulse control is modeled using a specparam constant with 
 the name PATHPULSE$. For example: 
        specparam   PATHPULSE$a$y  = (0,6); 

The  PATHPULSE$  specparam specifies a rejecClimit (0 in this example) and an 
erroclimit (6 in this example). These limits detennine whether glitches are cancelled 
 (inertial delay), propagate through (transport delay), or propagate a logic X to the 
 output. Any combination of these possibilities can also be represented. The example 
 above specifies that all glitches will propagate as a logic X. 

When the pulse control is set to propagate a logic X for the glitch, as in the previous 
example, the Verilog-1995 uses on-event pulse error propagation. With this method, 
 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 On-detect pulse error propagation                                     95 

 the logic X pulse is only propagated to the output during the period of time between 
 the two scheduled output events caused by the glitch. The waveform below illustrates 
 how on-event pulse error propagation would appear on the output for the input transi•
 tions used in this example. As technology has pushed into ever smaller very deep sub•
 micron processes, the on-event pulse error propagation is not always pessimistic 
 enough, because the logic X pulse error can be too small to catch. 

 What's new 

     eri10g-2001 adds on-detect pulse error propagation. With this method, a logic X 
 Vpulse is  propagated to the output as soon as a glitch is detected, instead of wait•
 ing until the leading output edge occurs. This creates a more pessimistic, wider logic 
 X pulse. To specify whether a module path delay should use on-event or on-detect 
 pulse error propagation, two new reserved words have been added in Verilog-2001: 

    pulsestyle_onevent   <lisCo!-path_outputs>; / /Verilog-1995 behavior 
    pulsestyle_ondetect   <lisCo!-path_outputs>; / /Verilog-2001 behavior 

 These properties are specified within a specify block, before the path delays that ref•
 erence the outputs. The liscoCpath_outputs is a comma-separated list of signal 
 names which appear as outputs of pin-to-pin path delays. pulsestyle_onevent is 
 the default. An example of using these pulse control statements is: 
      specify 
        specparam  PATHPULSE$a$y   =  (0,6); 
        pulsestyle_ondetect    y; 
        (a  *> y) =  (4,6); 
      endspecify 

The effects of on-event and on-detect are illustrated below: 

                                    10  12  14      18 

                           a 
 rise delay = 4, fall delay = 6 ____ ~r--l~:--~----~----I  I 
                                     I   I            on-event error pulse 
   ----j[>>-                                                y 
                                                      on-detect error pulse 
                                                            y 

Synthesis considerations 

This enhancement is not synthesizable. 
96               Verilog-2001: A Guide to the New Features of the Verilog HDL 

39.   Negative pulse detection 


Background 

Using specify block pin-to-pin path delays, unique delay values can be specified for 
rising transitions on an output versus falling transitions on the output. Due to differ•
ences in rising and falling transition times, it is possible that a pulse on the output of a 
model could end up with a duration of less than zero. 

A negative output pulse width can occur when a glitch (pulse) on an input occurs. The 
trailing edge of the glitch could be scheduled on the output before the leading edge is 
scheduled to change the output. The following example illustrates this situation: 

                     ___-I[:>rise     delay =4,  fall delay = 6 

                         10  11     15  16 
                a         U 
                          I   I                 y 
                          I   I      I 
          trailing edge of output change ~ I~ leading edge of output change 
                                     I   I 

In this example, the falling transition on a at time 10 schedules a falling transition on 
y at time 16. But then the rising transition on a at time 11 schedules a rising transition 
on y at time IS, before the first transition is scheduled to occur. 

Negative output pulses can also occur when two different inputs change at nearly the 
same time, and both affect the same output. Because the path delay from one of the 
inputs to the output can be slower or faster than the path delay of the other input, the 
second input change can end up being scheduled on the output before the first input 
change. 

In Verilog-1995, this negative output pulse will be cancelled. It does not show up in 
simulation. As processes have shrunk into very deep submicron sizes, the Verilog-
1995 model for handling negative pulses is too optimistic. At the smaller processes 
and higher clock speeds, even a negative width glitch is important to detect. 


S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Negative pulse detection                                              97 

 What's new 

     erilOg-2001 adds an additional control to specify blocks, which allows library 
 Vmodels to specify that a negative pulse width on the output should propagate as a 
 logic X, instead of being cancelled. Two new reserved words have been added, which 
 are used within a module specify block: 
    noshowcancelled   <lisco!--path_outputs>; //Verilog-1995 behavior 
    showcancelled   <lisco!--path_outputs>; //Verilog-2001  behavior 

 These commands specify the behavior for one or more outputs of path delays. Multi•
 ple outputs are listed as a comma-separated list. The commands must be specified 
 before the output is referenced in a path delay statement. noshowcancelled is the 
 default behavior. The commands work in conjunction with the on-event and on-detect 
 pulse handling discussed in the previous section. The following example illustrates 
 the effects on an output when a negative output pulse width occurs: 
      specify 
        specparam   PATHPULSE$a$y  =  (0,6); 
        pulsestyle_ondetect    y; 
        showcancelled   y; 
         (a *> y) =  (4,6); 
      endspecify 

                ___--1l)rise     delay = 4, fall delay = 6 

                   10  11     15  16 
          a 

                    W                      y   no-show-cancelled output 
                                   I 
                               LJ          y   show-cancelled with on-event 
                               I   I      y   show-cancelled with on-detect 


Synthesis considerations 

This enhancement is not synthesizable. 
98               Verllog-2001: A Guide to the New Features of the Verllog HDL 

40.   Enhanced input timing checks 


Background 

Verilog-1995 provides several built-in timing checks to automatically verify that 
input changes meet various timing constraints: 
$setup     (data_event,   ref_event,  setup_limit,   notifier); 
$hold      (ref_event,   data_event,  hold_limit,   notifier); 
$setuphold(ref_event,    data_event,  setup_lim,  hold_lim,   notif); 
$ skew     (ref_event,   data_event,  skew_limit,   notifier); 
$recovery  (ref_event,   data_event,  recovery_limit,   notifier); 
$period    (ref_event,   data_event,  period_limit,   notifier); 
$width     (ref_event,  width_limit,   max_threshold,   notifier); 

Timing check evaluation is based upon the times of two events: the time-stamp event 
and the time-check event. A transition on the time-stamp event signal causes the sim•
ulator to record (stamp) the time of transition for future use in evaluating the timing 
check. A transition on the time-check event signal causes the simulator to actually 
evaluate the timing check to determine whether a violation has occurred. For some 
checks the reference_event is always the time-stamp event, and the datajvent is 
always the time-check event. For other checks, it is the opposite. For timing checks 
that support negative limits, the limit that is negative controls which event is the time•
stamp and which event is the time-check. 

The notifier is an optional argument. It is a scalar reg variable that is toggled when•
ever a violation occurs. 

What's new 

   erilOg-2001 adds four additional timing constraint checks, which provide greater 
Vflexibility for checking constraints on asynchronous inputs: 
$ removal (ref_event,  data_event,   removal_limit,   notifier); 
$recrem   (ref_event,  data_event,   recovery_limit,   removal_limit, 
           notifier,  stamptime_condition,    checktime_condition, 
           delayed_ref,   delayed_data); 
$timeskew (ref_event , data_event,   skew_limit,  notifier, 
           event_based_flag,   remain_active_flag); 
$fullskew (ref_event , data_event,   limit!,  limit2,  notifier, 
           event_based_flag,   remain_active_flag); 
S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Enhanced Input timing checks                                         99 


 $removal  is similar to the capabilities of $hold, but between two asynchronous 
 input signals, such as reset and clock. The reference_event is always the time-stamp 
 time, and the data_event is always the time-check time. 

 $recrem combines the capabilities of $recovery and $removal. It allows specify•
 ing constraints between two asynchronous input signals, such as reset and clock. The 
 last four arguments are not used if both limits are positive, and can be omitted. These 
 arguments are discussed in the next section. When both limits are positive, either the 
 reference_event or the data_event can be the time-stamp time, depending on which 
 occurs first. The other event becomes the time-check time. 

 $timeskew provides a unidirectional time based skew. It can be configured to be 
 either timer based or event based by setting an optional evenCbasedJlag to 0 or 1, 
 respectively. The default mode is timer based, if the flag is not specified. When con•
 figured for timer based, when a reference_event occurs, a timer begins to count. If 
 another reference_event does not occur before the timer reaches the limit, then an 
 error is reported. When  event based, another optional flag is used, the 
 remain_active.Jlag. If the remain_active.Jlag is 0, or if the flag is not specified, then 
 an error is reported for the first datajvent that occurs after the limit. No other viola•
 tions are reported. If the remain_activeJiag is set, then an error is reported for any 
data_event that occurs after the limit, even after another referencejvent. This last 
behavior is identical to the $ skew timing check. 

 $fullskew is similar to $timeskew, but the reference_event and data_event can 
transition in either order, making it a bidirectional skew check. The first signal to 
change becomes the time-stamp event, and the other signal the time-check event. The 
first limit is the maximum  time by  which the data_event can  follow the 
reference_event. The second limit is the maximum time by which the reference_event 
can follow the data_event. 

Synthesis considerations 

This enhancement is not synthesizable. 
100              Verilog-2001: A Guide to the New Features of the Verllog HDL 

41.   Negative input timing constraints 


Background 

Verilog-1995 added the ability to specify a negative setup or hold time (but not both) 
with the $setuphold timing check. However, the Verilog-1995 standard was some•
what ambiguous on how a negative setup or hold time should be processed by simula•
tors. The Verilog-1995 standard for $setuphold is: 
$setuphold(ref_event,    data_event,  setup_lim,  hold_lim,   notif); 

What's new 

    eriIOg-2001 clarifies the behavior of negative timing constraints, in essence stan•
Vdardizing  what was already implemented by simulator companies. In addition, 
Verilog-2001 adds a new $recrem timing constraint, which also supports negative 
timing constraints. 

To fully support the behavior of negative timing constraints, four optional arguments 
have been added to $setuphold. The new $recrem timing check has the same four 
optional arguments. The new arguments are: 
$setuphold(ref_event,    data_event,  setup_limit,   hold_limit, 
            notifier, 
            stampt ime_condit ion,  checkt ime_condit ion, 
            delayed_ref,   delayed_data); 

$recrem    (ref_event,  data_event,  recovery_limit,   removal_limit, 
            notifier, 
            stamptime_condition,    checktime_condition, 
            delayed_ref,   delayed_data); 

The last two arguments must be net data types declared within the module. They rep•
resent delayed copies of the reference_event and data_event signals. The Verilog 
model does not place values on these delayed signals. The values are copied inter•
nally within the simulation. Internally, the setuplhold times, or recovery/removal 
times, are adjusted by the simulator so as to shift the violation window to make it 
overlap the reference signal. After this internal shift has occurred, the delayed signals 
are the ones used by the simulator to evaluate if a violation has occurred. 

S. Sutherland, Verilog - 2001
© Springer Science+Business Media New York 2002
 Negative input timing constraints                                   101 

 The delayed reference and data signals can be explicitly declared within the timing 
 check so that they can be used in the model's functional implementation to ensure 
 accurate simulation. Specifying the delayed signals is optional. If not specified in the 
 timing check, and if a negative limit is present, then implicit delayed signals will be 
 created by the simulator. Implicit delayed signals cannot be used in defining the 
 model behavior, however, limiting the ability to model device behavior accurately. 

 The stamptime3{)fldition and checktime30ndition arguments allow conditions to be 
 placed on the delayed reference and data arguments. If one of the conditions is false 
 (0), then the corresponding copy of the event is disabled, and will be ignored when 
 the stamp-time or check-time events are generated. This is the same ability that exists 
 for the standard, non-delayed arguments of all timing checks, except that with the 
 standard arguments, the condition is specified by logically and-ing the condition with 
 the argument using the &&& operator. 

 The stamptime30ndition and checktime_condition arguments are optional. If not 
 used, and delayed signals are specified, then null values can be placed in the condition 
 fields. For example: 
    $setuphold   (posedge elk,  posedge  d, -3,  a, ,  ,  , elk_d, d_dl; 

 To provide backward compatibility with previous generations of Verilog standards, 
 the IEEE 1364-2001 standard specifies that Verilog simulators should enable negative 
 values in $setuphold and $reerem timing checks with an invocation option. The 
 name of this option is not defined in the standard, and might be not be the same on all 
 simulators. If simulation is run without negative timing checks enabled, then the 
delayed copies of the reference_event and data_event will be exactly the same as the 
original reference and data events. This may result in less accurate reporting of timing 
violations. 

Synthesis considerations 

This enhancement is not synthesizable. 
 102              Verilog-2001: A Guide to the New Features of the Verllog HDL 

 42.   Enhanced SDF file support 


 Background 

 Standard Delay Format (SDF) files contain timing values for specify path delays, 
 specparam values, timing check constraints, and interconnect delays. SDF files can 
 also contain other information in addition to simulation timing that does not affect a 
 Verilog simulation. The timing values in SDF files usually come from layout-driven 
 synthesis or ASIC delay calculation tools that take advantage of connectivity, technol•
 ogy, and layout geometry information to estimate accurate delays for each instance of 
 a component. 

 Verilog-1995 utilizes SDF files as a means of back annotating accurate timing infor•
 mation for each instance of a module or primitive. Back annotation is the process by 
 which timing values from the SDF file update specify-block path delays, specparam 
 values, timing constraint values, and interconnect delays. ASIC cell libraries in par•
 ticular make use of SDF files. Indeed, SDF files were originally created for Verilog as 
 part of the Open Verilog International (OVI) 1993 Verilog 2.0 standard. When the 
 IEEE standardized Verilog, information about the SDF file was purposely separated 
 from the Verilog-1995 standard. A separate standardization effort was begun to make 
 SDF its own IEEE standard, independent of other languages. This separate effort 
 became the IEEE Std. 1497, Standard/or Standard Delay Format (SDF)/or the Elec•
 tronic Design Process. 

The  Verilog-1995 standard does not document the system task $sdCannotate, 
which reads SDF files, even though virtually all Verilog simulators use the task. 

 What's  new 

    erilOg-2001 documents the syntax for $sdCannotate, so that all software tools 
 Vcan implement the same syntax for the command. In addition, Verilog-2001 doc•
uments how SDF file constructs relate to specific Verilog HDL objects, removing the 
ambiguity on how SDF files should be applied to simulation. 

Verilog-2001 also updates the Verilog HDL to support the latest version of the SDF 
 standard, IEEE Std 1497-1999. This version of SDF adds support for negative timing 
checks and the $removal, $recrem, $timeskew and $ full skew system tasks dis•
cussed in the previous two sections of this book. 

 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Enhanced SDF file support                                           103 

 The SOP-1999 standard also adds a concept of labels to the SOP standard. This 
required a change to the Verilog HOL syntax for specparam constants. With Verilog-
 2001, specparam constants can now be declared at either the specify block level or 
 the module level, and can be referenced at either level. Verilog-2001 also states that if 
 a specparam is annotated from an SOP file, all statements which reference the spec•
param  must be re-evaluated. (In Verilog-1995, specparam constants could only be 
 declared within a specify block, and could only be referenced within that specify 
block). 

The   differences between specparam  constants, parameter   constants and 
 localparam constants is discussed in section 28, on page 64. 

Synthesis considerations 

This enhancement should be partially supported by synthesis. The use of specparams 
at the module level should be supported. Reading SOP files with $sdCannotate is 
not supported by synthesis. Note, however, that synthesis tools may generate SOP 
files to be read by simulators or other tools. 
 104              Verilog-2001: A Guide to the New Features of the Verilog HDL 

 43.   Extended vee files 


 Background 

 A Value Change Dump  (VCD)  file contains information about value changes on 
 selected variables in the design stored by value change dump system tasks. In brief, a 
 VCD file defines the names of nets and variables that have been "dumped" to the file, 
 plus the simulation time and new logic value each time any of those signals change 
 value. Verilog simulators can create VCD files, which can then be read by other soft•
 ware tools, such as waveform displays, toggle testers, and code coverage tools. 

 Verilog-1995 supports 4-state VCD files, which represent net and variable changes in 
 0, 1, x, and z. No strength information is included in the VCD file. 

 Verilog-1995 also defines a number of system tasks to support the creation of VCD 
 files from within a simulation. These are: $dwnpfile, $dwnpvars, $dwnpoff, 
 $dwnpon, $dwnpall, $dwnplimit, and $dwnpflush. 

 What's new 

     erilOg-2001 adds support for extended VCD files. This extended VCD file format 
 Vprovides three major enhancements to the contents of a VCD file: 
 • Strength level information. 
 • The ability to dump ports to the file, as well as nets and variables. 
 • The simulation time when the VCD file was closed. 

 Verilog-2001 adds several new system tasks to the Verilog standard to support the 
 new capabilities of extended SDP files: $dwnpports, $dwnpportsoff, $dwnp•
portson,$dwnpportsall,$dwnpportslimit,and$dwnpportsflush. 

 $dwnpports (scope_list, file_name) specifies the ports to be dumped to a VCD file. 
 The arguments are optional. scope_list is one or more module instance identifiers, 
 separated by commas. Hierarchical path names to module instances are allowed. If no 
 scope_list is provided, the scope is the module from which $dumpports is called. All 
 the ports in the module instance(s) in the scope_list are dumped to the VCD file. Any 
 ports which exist in instantiations below those in the scope_list are not dumped. Each 
 scope specified in the scope_list must be unique. If multiple calls to $dumpports are 

 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Extended VCD flies                                                   105 

 specified, the scope_list values in each call must be unique. Thefile_name is the VCD 
 file to receive the port information, and must be a literal string, a reg variable, or an 
 expression. If no file_name is provided, the VCD file is assumed to be dumpports. vcd 
 in the simulator's current working directory. If the file already exists, it will be over•
 written. Specifying the same file_name multiple times is not allowed. 

 $dumpportsoff <file_name) causes a checkpoint to be made in the VCD file, where 
 each specified port is dumped with an X value. Port values are no longer dumped 
 from that simulation time forward. If file_name is not specified, dumping to all files 
 opened by all $dumpports calls is suspended. 

 $dumpportson<file_name) resumes dumping after the execution of a $dumpport•
 soff. All ports specified by the associated $dumpports will have their current val•
 ues dumped to the file. Iffile_name is not specified, dumping will resume for all files 
 specified by all $dumpports, if dumping to those files had been stopped. 

 $dumpportsall <file_name) creates a checkpoint in the VCD file which shows the 
 current value of all selected ports at that time in the simulation, regardless of whether 
 the port values have changed since the last simulation time step. If file_name is not 
 specified, a checkpoint is written for all files opened by all $dumpports calls. 

 $dumpportslimit <file_size, file_name) provides control of the VCD file size. The 
file_size argument is required. It specifies the maximum size in bytes for the associ•
 ated file_name. When the file size is reached, dumping stops, and a comment is 
 inserted into the file indicating that the size limit was attained. If file_name is not 
 specified, the file size limit applies to all files opened by all $dumpports calls. 

 $dumpportsflush<file_name)  forces a simulator's internal VCD buffer and any 
operating system file I/O buffer to be emptied to the associated file. To improve per•
formance, some simulators buffer VCD output, and only write to the file at intervals, 
rather than one line at a time. If file_name is not specified, the VCD buffers shall be 
flushed for all files opened by all $dumpports calls. 

    Note: The format of extended VeD files is outside the scope of this book. Refer to 
    the IEEE 1364-2001 Verilog Language Reference Manual for this information. 

Synthesis considerations 

This enhancement is not synthesizable. 
 106              Verilog-2001: A Guide to the New Features of the Verllog HDL 

 44.   Enhanced PLA system tasks 


 Background 

 Verilog-1995 has several system tasks to aid in modeling Programmable Logic Arrays 
 (PLAs). These are: 

           $async$and$array               $sync$and$array 
           $async$and$plane               $sync$and$plane 
           $async$nand$array              $ sync $nand$array 
           $async$nand$plane              $sync$nand$plane 
           $async$or$array                $sync$or$array 
           $async$or$plane                $ sync $or$plane 
           $async$nor$array               $sync$nor$array 
           $async$nor$plane               $ sync $nor$plane 

 In Verilog-1995, it is illegal to pass a vector as the input or output of a PLA system 
 task. The tasks require that the inputs to the PLA be represented as a concatenation of 
 I-bit wires and that the outputs be represented as a concatenation of I-bit reg vari•
 ables. This limitation makes it awkward to model PLAs with large numbers of 110 
 pins. An example of using a PLA system task is: 
    reg   [1:7] mem[1:3]i    II memory  for array personality 
    wire        a1,  a2,  a3,  a4, as, a6, a7i 
    reg         b1,  b2, b3i 
    $async$and$array(mem,    {al,a2,a3,a4,a5,a6,a7},    {bl,b2,b3}); 

 What's new 

    eriIOg-2001 changes the syntax of the PLA system tasks to allow inputs and out•
 Vputs of any vector size. 
    reg   [1:7] mem[1:3]i    II memory  for array personality 
   wire   [1:7] ai 
    reg   [1:3] bi 
    $async$and$array(mem,   a,  b); 

Synthesis considerations 

This enhancement is not synthesizable. 

 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
 Enhanced Verilog PLI support                                        107 

 45.   Enhanced Verilog             PLI   support 


 Background 

 Verilog-1995 defines a Programming Language Interface (PLI). The PLI allows users 
 of Verilog simulator products to extend the capabilities of the simulator by defining 
 new system tasks or system functions. Each user-defined system task or function is 
 associated with a C language function. When simulation encounters the user-defined 
 system task or function, the simulator calls the C function associated with it. The C 
 function must be statically or dynamically linked into the simulator executable. 

 The C function associated with a user-defined system task or function can call PLI 
 routines from the PLI libraries. These routines can read and modify values within the 
 simulation data structure. For example, a routine in a PLI library can be called to 
 locate every net in a module. Another routine can be called to read the current logic 
value of each of these nets. A third routine can be called to print the value of the nets 
to the simulation output display and the simulation log file. 

The Verilog-1995 standard contains three generations of PLI routine libraries: the TF 
library, the ACe library, and the VPI library. The latter library is the newest of the 
three, and is virtually a complete super set of the older TF and ACC libraries. It offers 
far greater capability, and much simpler syntax and semantics. The older libraries are 
maintained in the IEEE standard for backward compatibility. 

What's new 

 verilOg-2001 contains three types of enhancements to the Verilog PLI standard: 

• Clarifications and errata corrections to the TF and ACC libraries. 
• Enhanced functionality in the VPI library, such as simulation control routines and 
  operating system signal handling. 
• Support for every enhancement in the Verilog HDL for Verilog-2001, including 
  multidimensional arrays, automatic tasks and functions, signed arithmetic, etc. 

    Note: All enhancements and new features in the Verilog PLI have only been made in 
    the VPI library. The older TF and ACC libraries are being maintained for backward 
    compatibility, but are not being enhanced. 

 S. Sutherland, Verilog - 2001
 © Springer Science+Business Media New York 2002
108              Verilog-2001: A Guide to the New Features of the Verilog HDL 

The number of clarifications and enhancements contained in the PLI portion of the 
Verilog HDL are far too extensive for inclusion in this book. For details on these 
changes, readers are encouraged to obtain a copy of the second edition of the author's 
book "The Verilog PLI Handbook: A User's Guide and Comprehensive Reference 
on the Verilog Programming Language Interface", by Stuart Sutherland, published 
by Kluwer Academic Publishers (available circa January, 2002). 

Synthesis considerations 

This enhancement is not synthesizable. 
                                                                     109 

Appendix A: 
 Verilog-2001 formal definition 


 This appendix contains the formal definition of the Verilog-2001 standard. The defi•
 nition is taken directly from Annex A of the IEEE Std. 1364-2001 IEEE Standard for 
 the Verilog® Hardware Description Language. This document is also referred to as 
 the Verilog-2001 Language Reference Manual, or Verilog LRM. 

The formal definition of the Verilog HDL is described in Backus-Naur Form (BNF). 
The variant used in this appendix is as follows: 
• Bold  text represents literal words themselves (these are called terminals). For 
  example: module. 
• Non-bold text (possibly with underscores) represents syntactic categories (i.e. non 
  terminals). For example: port_identifier. 
• Syntactic categories are defined using the form: 
    syntactic_category ::= definition 
•  [   square brackets (non-bold) surround optional items. 
•  {   curly brackets (non-bold) surround items that can repeat zero or more times. 
•      vertical line (non-bold) separates alternatives. 


    The Verilog HDL formal definintion is reprinted with permission from the IEEE Std 
    1364-2001 IEEE Standard for the Verilog® Hardware Description Language. Copy•
    right 2001 by the Institute of Electrical and Electronics Engineers, Inc. (IEEE). The 
    IEEE disclaims any responsibility or liability resulting from the placement and use in 
    this work. 
110                 Verilog-2001: A Guide to the New Features of the Verilog HDL 

A.1  Source text 

A.1.1 Library source text 
Iibrary_text::= { library_descriptions } 
library_descriptions ::= 
     library_declaration 
    I include_statement 
    I confi~declaration 
library_declaration ::= 
     library library_identifier file_path_spec [ { , file_path_spec } ] 
     [ ·incdir file_path_spec [ { ,file_path_spec } ] ; 
file_path_spec ::= file_path 
include_statement ::= include <file_path_spec>; 
A.1.2 Configuration source text 
confi~declaration ::= 
     contig confi~identifier ; 
     design_statement 
     {confi~rule_statement } 
     endcontig 
design_statement ::= design { [library_identifier.]ceIUdentifier} ; 
confi~rule_statement ::= 
     defaulCclause liblisCclause 
    I insCclause liblisCclause 
    I insCclause use_clause 
    I cell_clause liblisCclause 
    I cell_clause use_clause 
defaulCclause ::= default 
inscclause ::= instance inscname 
inst_narne ::= topmodule_identifier{ .instance_identifier} 
cell_clause ::= cell [ Iibrary_identifier.]ceIUdentifier 
liblisCclause ::= Iiblist [{library_identifier}] 
use_clause ::= use [library_identifier.]ceIUdentifier[:contig] 
A.1.3 Module and   primitive source text 
source_text ::= { description} 
description ::= 
     module_declaration 
    I udp_declaration 
module_declaration ::= 
     { attribute_instance } module_keyword module_identifier [ module_pararnetecporUist ] 
         [ liscoCports ] ; { module_item} 
         endmodule 
    I { attribute_instance } module_keyword module_identifier [ module_pararnetecporUist ] 
         [ list_oCporCdeclarations ] ; { non_port_module_item } 
         endmodule 
module_keyword ::= module I macromodule 
A.1.4 Module parameters and     ports 
module_pararnetecport_list ::= # ( parameter_declaration { ,pararnetecdeclaration } ) 
IisCoCports ::= (port { ,port} ) 
list_oCport_declarations ::= 
     ( port_declaration { ,port_declaration } ) 

              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
Appendix A:   Verllog-2001 formal definition                                   111 

    10 
port ::= 
     [ port_expression] 
    I . port_identifier ( [ port_expression] ) 
port_expression ::= 
     port_reference 
    I { port_reference ( ,port_reference ) } 
port_reference ::= 
     port_identifier 
    I port_identifier [ constanCexpression ] 
    I port_identifier [ range_expression] 
port_declaration ::= 
     (attribute_instance) inoucdeciaration 
    I (attribute_instance) inpucdeclaration 
    I (attribute_instance) output_declaration 
A.1.5 Module items 
module_item ::= 
     module_or-Jlenerate_item 
    I port_declaration; 
    I ( attribute_instance ) generated_instantiation 
    I { attribute_instance} local_parameter_declaration 
    I { attribute_instance } parametecdeciaration 
    I { attribute_instance} specify_block 
    I { attribute_instance} specparam_declaration 
module_or-Jlenerate_item ::= 
     ( attribute_instance) module_or-Jlenerate_item_declaration 
    I { attribute_instance} parameter_override 
    I { attribute_instance } continuous_assign 
    I { attribute_instance } gate_instantiation 
    I { attribute_instance} udp_instantiation 
    I { attribute_instance } module_instantiation 
    I { attribute_instance } initiaLconstruct 
    I { attribute_instance} always_construct 
module_or-Jlenerate_item_declaration ::= 
     necdeciaration 
    I reg_declaration 
    I integer_declaration 
    I real_declaration 
    I time_declaration 
    I realtime_declaration 
    I evenCdeciaration 
    I genvar_declaration 
    I task_declaration 
    I function_declaration 
non_port_module_item ::= 
     { attribute_instance} generated_instantiation 
    I { attribute_instance} local_parametecdeciaration 
    I { attribute_instance} module_or-Jlenerate_item 
    I { attribute_instance} parameter_declaration 
    I { attribute_instance } specify_block 
    I { attribute_instance} specparam_declaration 
parameter_override ::= defparam liscoCparam_assignments ; 

             From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
112                 Verilog-2001: A Guide to the New Features of the Verllog HDL 

A.2 Declarations 

A.2.1 Declaration types 
A.2.1.1 Module parameter declarations 
local_parameter_declaration ::= 
     localparam [ signed] [ range] list_oCparam_assignments ; 
    Ilocalparam integer liscoCparam_assignments ; 
    Ilocalparam reallist_oCparam_assignments ; 
    Ilocalparam realtime lisCoCparam_assignments ; 
    Ilocalparam time liscoCparam_assignments ; 
parameter_declaration ::= 
     parameter [ signed] [ range] Iist_oCparam_assignments ; 
    I parameter integer IiscoCparam_assignments ; 
    I parameter realliscoCparam_assignments ; 
    I parameter realtime IisCoCparam_assignments ; 
    I parameter time IiscoCparam_assignments ; 
specparam_declaration ::= specparam [ range] lisCoCspecparam_assignments ; 
A.2.1.2 Port declarations 
inout_declaration ::= inout [ neUype ] [ signed] [ range] 
         liscoCporUdentifiers 
input_declaration ::= input [neuype] [signed] [range] 
         liscoCporUdentifiers 
output_declaration ::= 
     output [ neUYpe ] [ signed] [ range] 
         list_oCporUdentifiers 
    I output [ reg] [ signed] [ range] 
         liscoCporUdentifiers 
    I output reg [ signed] [ range] 
         lisCoCvariable_porUdentifiers 
    I output [ outpuCvariable_type]  
         list_oCporUdentifiers 
    I output outpuCvariable_type  
         list_oCvariable_porUdentifiers  
A.2.1.3 Type declarations 
event_declaration ::= event lisCoCevenUdentifiers ; 
genvar_declaration ::= genvar lisCoCgenvar_identifiers ; 
integer_declaration ::= integer lisCoCvariable_identifiers ; 
net_declaration ::= 
     neUype [ signed] 
         [ delay3 ] liscoCneUdentifiers ; 
    I neUype [ drive_strength] [ signed] 
         [ delay3 ] lisCoCneCdecCassignments ; 
    I net_type [ vectored I scalared ] [ signed] 
         range [ delay3 ] liscoCneUdentifiers ; 
    I net_type [ drive_strength] [ vectored I scalared ] [ signed] 
         range [ delay3 ] list_oCneCdecl_assignments ; 
    I trireg [ charge_strength] [ signed ] 
         [ delay3 ] liscoCneUdentifiers ; 
    I trireg [ drive_strength] [ signed] 
         [ delay3 ] IiscoCneCdecl_assignments ; 
    I trireg [ charge_strength] [ vectored I scalared ] [ signed] 

              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
Appendix A:  Verllog-2001  formal definition                                   113 


         range [ delay3 ] liseoCneUdentifiers ; 
    I trireg [ drive_strength] [ vectored I scalared ] [ signed ] 
         range [ delay3 ] list_oCneedecCassignments ; 
real_declaration ::= realliseoCreal_identifiers ; 
realtime_declaration ::= realtime list_oCreal_identifiers ; 
re~declaration ::= reg [signed] [range 1 
         liseoCvariable_identifiers;  
time_declaration ::= time liseoCvariable_identifiers;  

A.2.2 Declaration data types 
A.2.2.1 Net and variable types 
neetype ::= 
     supplyO I supplyl 
    I tri     I triand I trior I triO I tril 
    I wire    I wand  I wor 
outpuevariable_type ::= integer I time 
real_type ::= 
     real_identifier [ =constaneexpression  ] 
    I real_identifier dimension { dimension } 
variable_type: := 
     variable_identifier [ =constant_expression]  
    I variable_identifier dimension { dimension} 
A.2.2.2 Strengths 
drive_strength ::= 
     ( strengthO , strength 1 ) 
    I ( strength 1 , strengthO ) 
    I ( strengthO , highz! ) 
    I ( strength 1 , highzO ) 
    I ( highzO , strength 1 ) 
    I ( highzl , strengthO ) 
strengthO ::= supplyO I strongO I pullO I weakO 
strength! ::= supply! I strong! I pullli weak! 
charge_strength ::= ( small) I ( medium) I ( large) 
A.2.2.3 Delays 
delay3 ::= # delay_value 1#( delay_value [, delay_value [, delay_value 11) 
delay2 ::= # delay_value I # (delay_value [, delay_value 1)  
delay_value ::= 
     unsigned_number 
    I parameter_identifier 
    I specparam_identifier 
    I mintypmax_expression 
A.2.3 Declaration lists 
liseoCevenUdentifiers ::= evenUdentifier [dimension { dimension }] 
        { ,evenUdentifier [ dimension { dimension }1  } 
list_oCgenvar_identifiers ::= genvar_identifier { ,genvar_identifier } 
liseoCnet_decl_assignments ::= needecl_assignment { ,net_decl_assignment } 
liseoCneUdentifiers ::= neUdentifier [dimension { dimension }] 
        { ,neUdentifier [ dimension { dimension }1  } 
list_oCparam_assignments ::= param_assignment { ,param_assignment } 
liseoCporUdentifiers ::= porUdentifier { ,port_identifier} 

              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
114                 Verllog-2001: A Guide to the New Features of the Verllog HDL 


lisCoCreaUdentifiers ::= reaUype { ,reaUype } 
liscoCspecparam_assignments ::= specparam_assignment { ,specparam_assignment } 
lisCoCvariable_identifiers ::= variable_type { ,variable_type } 
liscoCvariable-POrUdentifiers ::= port_identifier [= constanCexpression] 
               { , port_identifier [ =constancexpression]  } 
A.2.4 Declaration assignments 
neCdecl_assignment ::= neUdentifier = expression 
param_assignment ::= parameter_identifier = constanCexpression 
specparam_assignment ::= 
     specparam_identifier =constancmintypmax_expression  
    I pulse_control_specparam 
pulse_control_specparam ::= 
     PATHPULSE$ =(rejecUimiCvalue     [, erroclimiCvalue]); 
    I PATHPULSE$specify _inpuCterminaCdescriptor$specify _outpucterminal_descriptor  
                 = ( rejecClimiCvalue  [ , erroclimiCvalue]  ) ; 
error_limiCvalue ::= limicvalue 
rejecClimicvalue ::= limiCvalue 
limiCvalue  ::= constanCmintYPlllllJC.expression 
A.2.5 Declaration ranges 
dimension ::= [ dimension_constancexpression : dimension_constancexpression ] 
range ::= [ msb_constancexpression : lsb_constancexpression ] 
A.2.6 Function declarations 
function_declaration ::= 
      function [ automatic] [ signed] [ range_octype ] function_identifier; 
      function_iteM_declaration { function_iteM_declaration } 
      functioll.-statement 
      endfunction 
     I function [ automatic] [ signed] [ range_or_type ] function_identifier ( function_port_list ) ; 
      block_iteM_declaration { blockjtem_declaration } 
      function_statement 
      endfunction 
function_iteM_declaration ::= 
     block_iteM_declaration 
    I tf_inpucdeclaration ; 
function-POrt_list ::= { attribute_instance} tf_inpucdeclaration { , { attribute_instance} 
              tf_inpuCdeclaration } 
range_octype ::= range I integer I real I realtime I time 
A.2.7 Task declarations 
task_declaration ::= 
      task [ automatic] task_identifier; 
      { task_iteM_declaration } 
      statement 
      endtask 
     I task [ automatic] task_identifier ( task_port_list ) ; 
      { block_iteM_declaration } 
      statement 
      endtask 
task_iteM_declaration ::= 
     bloclc.Jtem_declaration 
    I { attribute_instance } tf_inpuCdeclaration ; 

              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
Appendix A:   Verllog-2001 formal definition                                   115 

    I { attribute_instance} tCoutpuCdeciaration ; 
    I { attribute_instance } tCinout_deciaration ; 
task_port_list ::= task_port_item { ,task_port_item } 
task_port_item ::= 
     { attribute_instance} tCinput_declaration 
    I { attribute_instance} tCoutpucdeclaration 
    I { attribute_instance } tCinouCdeclaration 
tCinput_declaration ::= 
      input [ reg ] [ signed] [ range] list_oCport_identifiers 
    I input [ task_port_type ] lisCoCport_identifiers 
tCoutpuCdeciaration ::= 
      output [ reg] [ signed] [ range] liscoCport_identifiers 
    I output [ task_port_type ] liscoCport_identifiers 
tCinouCdeclaration ::= 
      inout [ reg] [ signed] [ range] lisCoCport_identifiers 
    I inout [ task_port_type ] lisCoCport_identifiers 
task_port_type ::= 
      time I real I realtime I integer 
A.2.8 Block item declarations 
block_item_dcclaration ::= 
     { attribute_instance } block_re~declaration 
    I { attribute_instance } evenCdeciaration 
    I { attribute_instance} integecdeciaration 
    I { attribute_instance} loca'-parametecdeciaration 
    I { attribute_instance } parametecdeclaration 
    I { attribute_instance } real_declaration 
    I { attribute_instance} realtime_declaration 
    I { attribute_instance} time_declaration 
block_re~declaration ::= reg [signed] [range] 
         lisCoCblock_variable_identifiers;  
lisCoCblock_variable_identifiers::=  
         block_variable_type { , block_variable_type } 
block_variable_type ::= 
     variable_identifier 
    I variable_identifier dimension { dimension } 

A.3  Primitive instances 

A.3.1 Primitive instantiation and instances 
gate_instantiation ::= 
     cmos_switchtype [delay3] 
         cmos_switch_instance { ,cmos_switch_instance } ; 
    I enable~atetype [drive_strength] [delay3] 
         enable~ate_instance { ,enable~ate_instance } ; 
    I mos_switchtype [delay3] 
         mos_switch_instance { , mos_switch_instance } ; 
    I n_input~atetype [drive_strength] [delay2] 
         n_input~ate_instance { ,n_input~ate_instance } ; 
    I n_output~atetype [drive_strength] [delay2] 
         n_output~ate_instance { ,n_output~ate_instance } ; 
    I pass_en_switchtype [delay2J 
         pass_enable_switch_instance { , pass_enable_switch_instance } ; 

             From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
116                 Verllog-2001: A Guide to the New Features of the Verllog  HDL 

    I pass_switch type 
         pass_switch_instance { ,pass_switch_instance } ; 
    I pulldown [pulldown_strength] 
         pull~ate_instance { , pull~ate_instance } ; 
    I pullup [pulIup_strength] 
         pulI~ate_instance { ,pulI~ate_instance } ; 
cmos_switch_instance ::= [ name_of~ate_instance 1(  outpuCterminal , inpuCterminal , 
        ncontrol_terminal , pcontrol_terminal ) 
enable~ate_instance ::= [ name_of~ate_instance 1(  outpucterminal , inpuCterminal , 
              enable_terminal) 
mos_switch_instance ::= [ name_of~ate_instance 1(  outpuuerminal , inpuuerminal , 
              enable_terminal) 
n_input~ate_instance ::= [name_of~ate_instance 1(outpuCterminal,  inpuCterminal { , 
              inpuuerminal } ) 
n_output~ate_instance ::= [name_of~ate_instance 1(outpuCterminai  { ,outpuCterminal } , 
               inpuuerminal ) 
pass_switch_instance ::= [name_of~ate_instance 1(inouCterminal,  inouCterminal) 
pass_enable_switch_instance ::= [name_of~ate_instance 1(inouCterminal,  inouCterminal, 
              enable_terminal) 
pulI~ate_instance ::= [name_of~ate_instance 1(outpuUerminal)  
name_of~ate_instance ::= gate_instance_identifier [range 1 
A.3.2 Primitive strengths 
pulldown_strength ::= 
     ( strengthO , strength 1 ) 
    I ( strength 1 , strengthO ) 
    I ( strengthO ) 
pullup_strength ::= 
     ( strengthO , strengthl ) 
    I ( strength 1 , strengthO ) 
    I ( strengthl ) 
A.3.3 Primitive terminals 
enable_terminal ::= expression 
inouCterminal ::= net_lvalue 
inpuCterminal ::= expression 
ncontroCterminal ::= expression 
outpucterminal ::= net_l value 
pcontroCterminal ::= expression 
A.3.4 Primitive gate and switch types 
cmos_switchtype ::= cmos I rcmos 
enable~atetype ::= bufifO I bufin I notifO I notin 
mos_switchtype ::= nmos I pmos I rnmos I rpmos 
n_input~atetype ::= and I nand I or I nor I xor I xnor 
n_output~atetype ::= buf I not 
pass_en_switchtype ::= tranifO I tranin I rtranin I rtranifO 
pass_switchtype ::= tran I rtran 


              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
Appendix A:   Verllog-2001 formal definition                                   117 

A.4 Module and      generated     instantiation 

A.4.1 Module instantiation 
module_instantiation ::= 
     module_identifier [ parameter_value_assignment] 
       module_instance { ,module_instance} ; 
parametecvalue_assignment ::= # (list_oCparameter_assignments) 
list_oCparameter_assignments ::= 
    ordered_parametecassignment { ,ordered_parametecassignment } I 
    named_parameter_assignment {, named_parameter_assignment } 
ordered_parameter_assignment ;;= expression 
named_parameter_assignment ::= • parameter_identifier ( [ expression] ) 
module_instance ;;= name_oCinstance ([ list_oCporCconnections] ) 
name_oCinstance ::= module_instance_identifier [ range] 
IiscoCporcconnections ::= 
     ordered_port_connection { ,ordered_port30nnection } 
    I named_porcconnection { , named_port30nnection } 
ordered_port30nnection ::= { attribute_instance} [expression] 
named_port_connection ::= { attribute_instance} .porUdentifier ( [expression] ) 
A.4.2 Generated instantiation 
generated_instantiation ::= generate { generate_item} endgenerate 
generate_item_or_null ;;= generate_item I; 
generate_item ;;= 
     generate_conditional_statement 
    I generate_case_statement 
    I generate_loop_statement 
    I generate_block 
    I module_or~enerate_item 
generate_conditional_statement ;;= 
     if ( constant3xpression ) generate_item_ocnull [else generate_item_ocnull ] 
generate_case_statement ;;= case (constanCexpression) 
            genvar_case_item { genvar3ase_item } endcase 
genvaccase_item ::= constanCexpression {, constant3xpression } : 
            generate_item_ocnull I default [ : ] generate_item_ocnull 
generate_loop_statement ::= for ( genvar_assignment ; constancexpression ; genvacassignment ) 
            begin: generate_block_identifier { generate_item} end 
genvar_assignment ::= genvar_identifier = constancexpression 
generate_block ::= begin [ : generate_block_identifier] {generate_item} end 

A.5  UDP declaration and       instantiation 

A.S.1 UDP declaration 
udp_declaration :;= 
     { attribute_instance} primitive udp_identifier ( udp_port_list ) ; 
      udp_port_dec1aration { udp_port_declaration } 
      udp_body 
      endprimitive 
     I { attribute_instance} primitive udp_identifier ( udp_dec1aration_port_list ) ; 
      udp_body 
      endprimitive 


             From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
118                 Verilog-2001: A Guide to the New Features of the Verllog HDL 

A.S.2 UDP ports 
udp_porUist ::= outpuCporUdentifier, inpucport_identifier { , inpucport_identifier } 
udp_decIaration_port_list ::= 
    udp_outpuCdeclaration , udp_input_declaration { , udp_inpucdeclaration } 
udp_port_declaration ::= 
     udp_output_decIaration ; 
    I udp_inpuCdeclaration ; 
    I udp_re~decIaration ; 
udp_outpucdeclaration ::= 
     { attribute_instance } output port_identifier 
    I { attribute_instance } output reg port_identifier [ = constant_expression 1 
udp_inpuCdeclaration ::= { attribute_instance} input IiscoCport_identifiers 
udp_re~declaration ::= { attribute_instance} reg variable_identifier 
A.S.3 UDP body 
udp_body ::= combinational_body I sequential_body 
combinational_body ::= table combinationaCentry { combinational_entry} endtable 
combinational_entry ::= level_inpuClist : outpuCsymbol ; 
sequentiaCbody ::= [udp_initiaCstatement 1 table sequentiaCentry { sequential_entry} endtable 
udp_initial_statement ::= initial outpuCport_identifier = iniCval ; 
inicval ::= 1'bO I l'blI 1'bx l1'bX I1'BO I l'Bl I l'Bx Il'BX 111 0 
sequential_entry ::= seq_inpuClist: currenCstate : next_state; 
seq_inpuClist ::= level_inpuClist I edge_inpuClist 
level_inpuclist ::= leveCsymbol { leveCsymbol } 
edge_inpuClist ::= { leveCsymbol } edge_indicator { level_symbol} 
edge_indicator ::= (level_symbol level_symbol) I edge_symbol 
currenCstate ::= level_symbol 
next_state ::= outpucsymboll· 
outpuCsymboJ ::= 0 111 x I X 
leveCsymbol ::= 0 111 x I X I ? I biB 
edge_symbol ::= r I R I f I F I piP I n I N I * 
A.S.4 UDP instantiation 
udp_instantiation ::= udp_identifier [ drive_strength 1 [ delay21 
                         udp_instance { , udp_instance } ; 
udp_instance ::= [ name_oCudp_instance 1 ( outpuCterminal , inpuCterminal 
                         { , inpuuerminal } ) 
name_oCudp_instance ::= udp_instance_identifier [range 1 

A.6 Behavioral statements 

A.6.1 Continuous assignment statements 
continuous_assign ::= assign [ drive_strength 1 [ delay3 lliscoCnecassignments ; 
IiscoCnecassignments ::= neCassignment { , necassignment } 
neCassignment ::= neClvalue = expression 
A.6.2 Procedural blocks and assignments 
initial_construct ::= initial statement 
always_construct ::= always statement 
blockin~assignment ::= variable_lvalue = [delay_or_event_controll expression 
nonblockin~assignment ::= variable_lvalue <= [delay_or_event30ntroll expression 


              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
Appendix A:   Verllog-2001 formal definition                                   119 


procedural_continuo us_assignments ::= 
     assign variable_assignment 
    I deassign variable_1 value 
    I force variable_assignment 
    I force neCassignment 
    I release variable_l value 
    I release neUvalue 
function_blockin~assignment ::= variable_lvalue = expression 
function_statemenCor_nuli ::= 
     function_statement 
    I { attribute_instance } ; 
A.6.3 Parallel and  sequential  blocks 
function_seq_block ::= begin [ : block_identifier 
        { block_item_declaration } ] { function_statement } end 
variable_assignment ::= variable_lvalue = expression 
par_block ::= fork [ : block_identifier 
         { block_item_declaration } ] { statement } join 
seq_block ::= begin [ : block_identifier 
        { block_item_declaration } ] { statement } end 
A.6.4 Statements 
statement ::= 
     { attribute_instance } blockin~assignment ; 
     { attribute_instance} case_statement 
     { attribute_instance } conditional_statement 
     { attribute_instance } disable_statement 
     { attribute_instance } evenctrigger 
     { attribute_instance} loop_statement 
     { attribute_instance } nonblockin~assignment ; 
     { attribute_instance } par_block 
     { attribute_instance} proceduraI_continuous_assignments ; 
     { attribute_instance } procedural_timing30ntrol_statement 
     { attribute_instance } seq_block 
     { attribute_instance} system_task_enable 
     { attribute_instance} task_enable 
     { attribute_instance} wait_statement 
statemencocnull ::= 
     statement 
    I { attribute_instance } ; 
function_statement ::= 
     { attribute_instance } function_blockin~assignment ; 
    I { attribute_instance } function3ase_statement 
    I { attribute_instance } function30nditionaCstatement 
    I { attribute_instance} function_loop_statement 
    I { attribute_instance } function_seq_block 
    I { attribute_instance } disable_statement 
    I { attribute_instance} system_task_enable 
A.6.S Timing control  statements 
delay_control ::= 
     # delay_value 
    I # ( mintypmax_expression ) 

              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
120                 Verllog-2001: A Guide to the New Features of the Verilog  HDL 


delay_ocevenccontrol ::= 
     delay_control 
    I evenCcontrol 
    I repeat ( expression) evenCcontrol 
disable_statement ::= 
     disable hierarchicaUask_identifier ; 
    I disable hierarchical_block_identifier; 
event_control ::= 
     @  evenUdentifier 
    I @  ( evencexpression ) 
    I@'" 
    I @ ("') 
evenctrigger ::= 
     .> hierarchical3venUdentifier ; 
evencexpression ::= 
     expression 
    I hierarchical_identifier 
    I posedge expression 
    I negedge expression 
    I evencexpression or evencexpression 
    I evencexpression , evencexpression 
procedural_timin~control_statement ::= 
     delay _or_event30ntrol statement_or_null 
waiCstatement ::= 
     wait ( expression) statemenCocnull 
A.6.6 Conditional statements 
conditional_statement ::= 
     if ( expression) 
         statemencor_null [ else statemenCor_null ] 
    I iCelse_iCstatement 
iCelse_iCstatement ::= 
     if ( expression) statement_ocnull 
     { else if ( expression) statemencor_null } 
     [ else statemenCor_null ] 
function_conditional_statement ::= 
     if ( expression) function_statement_ocnull 
         [ else function_statement_or_null ] 
    I function_iCelse_iCstatement 
function_iCelse_iCstatement ::= 
     if ( expression) function_statement_or_null 
     { else if ( expression) function_statement_or_null } 
     [ else function_statemencocnull ] 
A.6.7 Case statements 
case_statement ::= 
     case ( expression) 
         case_item { case_item} endcase 
    I casez ( expression) 
         case_item { case_item} endcase 
    I casex ( expression) 
         case_item { case_item} endcase 


              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
Appendix A:   Verllog-2001 formal definition                                   121 


case_item ::= 
     expression { • expression} : statement_or_null 
    I default [ : 1statemencor_null  
function_case_statement ::= 
     case ( expression) 
         function3ase_item { function_case_item } endcase 
    I casez ( expression) 
         function3ase_item { function3ase_item } endcase 
    I casex ( expression) 
         function_case_item { function3ase_item } endcase 
function_case_item ::= 
     expression { • expression} : function_statemenCor_null 
    I default [ : 1function_statement_or_null  
A.6.S Looping statements 
function_loop_statement ::= 
     forever function_statement 
    I repeat ( expression) function_statement 
    I while ( expression) function_statement 
    I for ( variable_assignment; expression; variable_assignment) 
         function_statement 
loop_statement ::= 
     forever statement 
    I repeat ( expression) statement 
    I while ( expression) statement 
    I for ( variable_assignment; expression; variable_assignment) 
         statement 
A.6.9 Task enable statements 
system_task_enable ::= system_task_identifier [ ( expression { • expression} ) 1 ; 
task_enable ::= hierarchical_task_identifier [ ( expression { • expression} ) 1 ; 

A.7 Specify section 

A.7.1 Specify block declaration 
specify_block ::= specify { specify_item} endspecify 
specify_item ::= 
     specparam_declaration 
    I pulsestyle_decIaration 
    I showcancelled_decIaration 
    I path_declaration 
    I system_timin~check 
pulsestyle_decIaration ::= 
     pulsestyle_onevent list_oCpath_outputs ; 
   I pulsestyle_ondetect liscoCpath_outputs ; 
showcancelIed_decIaration ::= 
     showcancelled list_oCpath_outputs ; 
    I noshowcancelled liscoCpath_outputs ; 


              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
122                 Verllog-2001: A Guide to the New Features of the Verilog  HDL 

A. 7.2 Speslfy path declarations 
path_declaration ::= 
     simple_path_declaration ; 
    I edge_sensitive_path_declaration ; 
    I state_dependenCpath_declaration ; 
simple_path_declaration ::= 
     parallel_path_description = path_delay_value 
    I full_path_description = path_delay_value 
parallel_path_description ::= 
   (specify _inpuuerminal_descriptor [ polarity_operator] => specify_outpuuerminal_descriptor)  
full_path_description ::= 
    (liscoCpath_inputs [polarity_operator] *> liscoCpath_outputs) 
list~oCpath_inputs ::= 
     specify_inpuuerminal_descriptor { ,specify_input_terminal_descriptor } 
lisCoCpath_outputs ::= 
     specify_output_terminal_descriptor  { , specify_output_terminal_descriptor  } 
A.7.3 Specify block terminals 
specify _inpuuerminal_descriptor::=  
     inpuUdentifier 
    I inpuUdentifier [ constancexpression ] 
    I inpuUdentifier [ range_expression] 
specify_outpucterminal_descriptor  ::= 
     outpuUdentifier 
    I outpuUdentifier [ constancexpression ] 
    I outpuUdentifier [ range_expression] 
inpuUdentifier ::= inpucport_identifier I inoucport_identifier 
output_identifier ::= outpuCport_identifier I inoucport_identifier 
A.7.4 Specify path  delays 
path_delay_value ::= 
     liscoCpath_delay_expressions  
    I (liscoCpath_delay_expressions) 
liscoCpath_delay_expressions ::= 
     cpath_delay_expression  
    I trise_path_delay_expression,  tfalCpath_delay_expression  
    I trise_path_deJay _expression, tfalCpath_delay_expression,  tz_path_delay_expression  
    I tOl_path_delay_expression, tlO_path_delay_expression, tOz_path_delaY3xpression, 
     tzl_path_delay_expression, tlz_path_delaY3xpression, tzO_path_delay_expression 
    I tOCpath_delay_expression, tlO_path_delay_expression, tOz_path_delaY3xpression, 
     tzl_path_delay_expression, tlz_path_delay_expression, tzO_path_delay_expression 
     tOx_path_delay_expression, txl_path_delay_expression, tlx_path_delay_expression, 
     txO_path_delay _expression, txz_path_delay_expression,  tzx_path_delay_expression  
cpath_delay_expression ::= path_delay_expression 
trise_path_delay _expression::= path_delay3xpression  
tfall_path_delay_expression  ::= path_delay_expression 
tz_path_delay_expression  ::= path_delay_expression 
tOCpath_delay_expression ::= path_delay_expression 
tlO_path_delay _expression ::= path_delay_expression 
tOz_path_delay _expression ::= path_delay_expression 
tzCpath_delay_expression ::= path_delaY3xpression 
tlz_path_delay_expression:  := path_delay_expression 
tzO_path_delay_expression ::= path_delay_expression 

              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
Appendix A:   Verilog-2001 formal definition                                   123 


tOx_path_delay_expression ::= path_delaY3xpression 
txl_path_delay_expression ::= path_delay_expression 
tlx_path_delay_expression  ::= path_delay_expression 
txO_path_delay_expression ::= path_delay_expression 
txz_path_delay_expression ::= path_delay_expression 
tzx_path_delay_expression::=  path_delay_expression 
path_delay_expression::= constancmintypmax_expression 
edge_sensitive_path_declaration ::= 
     parallel_edge_sensitive_path_description = path_delay_value 
    1full_edge_sensitive_path_description  = path_delay _value 
paraIlel_edge_sensitive_path_description ::= 
     ( [ edge_identifier 1specify _inpuuerminal_descriptor  => 
        specify_outpuuerminal_descriptor [polarity_operator 1:  data_source_expression) 
full_edge_sensitive_path_description ::= 
     ( [ edge_identifier lliscoCpath_inputs *> 
        list_oCpath_outputs [polarity_operator 1: data_source_expression) 
data_source_expression ::= expression 
edge_identifier ::= posedge 1 negedge 
state_dependenCpath_deelaration ::= 
     if ( module_path_expression ) simple_path_declaration 
    1 if ( module_path3xpression ) edge_sensitive_path_deelaration 
    1ifnone  simple_path_declaration 
polarity_operator ::= + I· 
A.7.S System timing checks 
A.7.S.1 System timing check commands 
system_timin~check ::= 
     $setup_timin~cheek 
    1$hold  _timin~cheek 
    1 $setuphold_timin~cheek 
    1 $recovery _timin~cheek 
    I $removaUimin~cheek 
    I $reerem_timin~cheek 
    1 $skew_timin~check 
    1$timeskew  _timin~cheek 
    1$fullskew_timin~cheek  
    1$period_timin~cheek  
    1 $width_timin~check 
    I $nochange_timin~check 
$setup_timin~cheek ::= 
     $setup (data_event, reference_event, timin~cheek_Iimit [, [notify_reg 11 ) ; 
$hold _timin~cheek ::= 
     $hold (reference_event, data_event, timing_cheek_limit [, [notify_reg 11 ) ; 
$setuphold_timin~check ::= 
     $setuphold ( reference_event, data_event, timing3heek_Iimit, timin~check_limit 
                    [, [notify_reg 1 [, [stamptime30ndition 1 [, [cheektime30ndition 1 
                    [ , [ delayed_reference 1 [ , [ delayed_data 111111 ) ; 
$reeovery_timin~check ::= 
     $recovery (reference_event, data_event, timin~cheek_limit [, [notify_reg 11) ; 
$removal_timin~check ::= 
     $removal (reference_event, data_event, timin~cheek_limit [ , [notify_reg 11) ; 


              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
124                 Verllog-2001: A Guide to the New Features of the Verllog  HDL 


$recrem_timin~check ::= 
     $recrem ( reference_event, data_event , timin~check_limit , timin~check_limit 
                     [ , [ notify_reg] [ , [ stamptime30ndition ] [ , [ checktime_condition ] 
                     [ , [ delayedJeference ] [ , [ delayed_data] ] ] ] ] ] ) ; 
$skew_timing_check ::= 
     $skew (reference_event, data_event, timin~check_limit [, [notify_reg] ] ) ; 
$timeskew_timin~check ::= 
     $timeskew ( reference_event, data_event , timin~check_limit 
                     [ , [ notify_reg] [ , [ evenCbased_flag ] [ , [ remain_active_flag ] ] ] ] ) ; 
$fullskew_timin~check ::=                              . 
     $fullskew ( reference_event, data_event , timin~check_limit , timin~check_limit 
                     [ , [ notify_reg] [ , [ evencbased_flag ] [ , [ remain_active_flag ] ] ] ] ) ; 
$period_timin~check ::= 
     $period ( controlled_reference_event , timing3heck_limit [ , [ notify_reg] ] ) ; 
$width_timing_check ::= 
     $width ( controlled_reference_event , timing3heck_limit , 
                     threshold [ , [ notify_reg] ] ) ; 
$nochange_timing_check ::= 
     $nochange ( reference_event, data_event, start_edge_offset , 
                     end_edge_offset [ , [ notify_reg] ] ) ; 
A.7.S.2 System timing check command arguments 
checktime_condition ::= mintypmax_expression 
controlled_reference_event ::= controlled_timin~check_event 
data_event ::= timin~check_event 
delayed_data ::= 
     terminal_identifier 
    I terminaUdentifier [ constancmintypmax3xpression ] 
delayed_reference: := 
     terminal_identifier 
    I terminal_identifier [ constanCmintypmax_expression ] 
end_edge_offset ::= mintypmax_expression 
evenCbased_flag ::= constanCexpression 
notify_reg ::= variable_identifier 
reference_event ::= timin~check_event 
remain_active_flag ::= constancmintypmax_expression 
stamptime_condition ::= mintypmax_expression 
start_edge_offset ::= mintypmax_expression 
threshold ::=constanCexpression 
timing3heck_limit ::= expression 
A.7.S.3 System timing  check event definitions 
timing3heck_event ::= 
     [timin~check_event_control] specify_terminal_descriptor [&&& timin~check_condition] 
controlled_timin~check_event ::= 
     timin~check_evenccontrol specify_terminal_descriptor [ &&& timin~check_condition ] 
timin~check_evenccontrol ::= 
     posedge 
    I negedge 
    I edge30ntrol_specifier 
specify_terminal_descriptor ::= 
     specify_inpuuerminal_descriptor  
    I specify _outpuuerminal_descriptor 
edge_control_specifier ::= edge [edge_descriptor [, edge_descriptor] ] 

              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
Appendix A:   Verllog-2001 formal definition                                   125 


edge_descriptor ::= 
     01 
    110 
    I z_or_x zero_or_one 
    I zero_ocone z_ocx 
zero_or_one ::= 011 
z_or_x ::= x I X I z I Z 
timin~check_condition ::= 
     scalactimin~check_condition 
    I ( scalactimin~check30ndition ) 
scalar_timing3heck30ndition ::= 
     expression 
    I - expression 
    I expression == scalar_constant 
    I expression === scalar_constant 
    I expression 1= scalar_constant 
    I expression 1== scalar30nstant 
scalar_constant ::= 
     l'bO 11'blI1'BO 11'Bll 'bO I 'bll 'BO I 'BIll I 0 

A.S  Expressions 

A.S.1 Concatenations 
concatenation ::= { expression { , expression} } 
constant30ncatenation ::= {constancexpression { , constancexpression } } 
constant_multiple_concatenation ::= { constancexpression constant_concatenation} 
module_path30ncatenation ::= { module_path_expression { , module_path_expression } } 
module_path_multiple_concatenation ::= { constant_expression module_path_concatenation } 
multiple30ncatenation ::= {constanCexpression concatenation} 
neCconcatenation ::= { neCconcatenation_value  { , net30ncatenation_value}  } 
necconcatenation_value  ::= 
     hierarchical_neCidentifier 
    I hierarchical_neUdentifier [ expression] { [expression] } 
    I hierarchical_neUdentifier [ expression] { [expression] } [range_expression] 
    I hierarchical_neUdentifier [ range_expression] 
    I neCconcatenation 
variable_concatenation ::= { variable30ncatenation_value { , variable30ncatenation_value } } 
variable_concatenation_value  ::= 
     hierarchical_variable_identifier 
    I hierarchical_variable_identifier [ expression] { [expression] } 
    I hierarchicaCvariable_identifier  [ expression] { [ expression] } [range_expression] 
    I hierarchical_variable_identifier [ range_expression] 
    I variable_concatenation 
A.S.2 Function calls 
constantjunction_call  ::= function_identifier { attribute_instance} 
         ( constanCexpression { , constanCexpression } ) 
function_call ::= hierarchicaljunction_identifier{ attribute_instance} 
         ( expression { , expression } ) 
genvar_function_call ::= genvarjunction_identifier { attribute_instance} 
         ( constant_expression { , constanCexpression } ) 
system_function_call ::= system_functioD_identifier 
         [ ( expression { , expression } ) ] 

              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
126                 Verilog-2001: A Guide to the New Features of the Verllog  HDL 

A.B.3 Expressions 
base_expression ::= expression 
conditional_expression ::= expression! ? { attribute_instance} expression2 : expression3 
constanCbase_expression ::= constancexpression 
constancexpression ::= 
     constanCprimary 
    I unary_operator { attribute_instance} constancprimary 
    I constancexpression bin~'_operator { attribute_instance} constancexpression 
    I constanCexpression ? { attribute_instance} constancexpression : constanCexpression 
    I string 
constant_mintypmax_expression ::= 
     constant_expression 
    I constant_expression: constant_expression: constant_expression 
constancrange_expression ::= 
     constant_expression 
    I msb_constancexpression : lsb_constancexpression 
    I constanCbase_expression +: width_constancexpression 
    I constanCbase_expression .: width_constancexpression 
dimension_constancexpression ::= constanCexpression 
expression! ::= expression 
expression2 ::= expression 
expression3 ::= expression 
expression ::= 
     primary 
    I unary_operator { attribute_instance} primary 
    I expression binary_operator { attribute_instance } expression 
    I conditional_expression 
    I string 
lsb_constancexpression ::= constant_expression 
mintypmax_expression ::= 
     expression 
    I expression: expression: expression 
module_path30nditional_expression ::= module_path_expression ? { attribute_instance} 
         module_path_expression : module_path_expression 
module_path_expression ::= 
     module_path_primary 
    I unary_module_path_operator { attribute_instance} module_path_primary 
    I module_path_expression binary_module_path_operator { attribute_instance} 
         module_path_expression 
    I module_path30nditional_expression 
module_path_mintypmax_expression ::= 
     module_path_expression 
    I module_path_expression : module_path_expression : module_path_expression 
msb_constancexpression ::= constancexpression 
range_expression ::= 
     expression 
    I msb_constant_expression : lsb_constancexpression 
    I base_expression +: width30nstancexpression 
    I base_expression -: width30nstancexpression 
width_constancexpression ::= constant_expression 


              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
Appendix A:   Verllog-2001 formal definition                                   127 


A.8.4 Primaries 
constancprimary ::= 
     constanCconcatenation 
    I constancfunction3all 
    I ( constanCmintypmax_expression ) 
    I constant_multiple30ncatenation 
    I genvar_identifier 
    I number 
    I parameter_identifier 
    I specparam_identifier 
module_path_primary::= 
     number 
    I identifier 
    I module_path_concatenation 
    I module_path_multiple30ncatenation 
    I function_call 
    I system_function3all 
    I constantjunction_call  
    I ( module_path_mintypmax_expression ) 
primary ::= 
     number 
    I hierarchicaUdentifier 
    I hierarchicaUdentifier [ expression] { [ expression] } 
    I hierarchical_identifier [ expression] { [expression]} [range_expression] 
    I hierarchical_identifier [ range_expression] 
    I concatenation 
    I multiple_concatenation 
    I function_call 
    I system_function_call 
    I constantjunction_call  
    I ( mintypmax_expression ) 
A.8.S Expression left-side values 
neClvalue ::= 
     hierarchical_neUdentifier 
    I hierarchical_neCidentifier [ constancexpression ] { [constanCexpression ] } 
    I hierarchical_neUdentifier [ constancexpression ] { [constanCexpression ] } [ 
              constanCrange3 xpression ] 
    I hierarchical_neUdentifier [ constancrange_expression ] 
    I net30ncatenation 
variable_lvalue ::= 
     hierarchical_variable_identifier 
    I hierarchical_variable_identifier [ expression] { [expression] } 
    I hierarchical_variable_identifier [ expression] { [ expression] } [range_expression] 
    I hierarchical_variable_identifier [ range_expression] 
    I variable_concatenation 
A.8.6 Operators 
unary_operator ::= 
     + I -I ! I-I & I -& III -II" I _" 1"-
binary_operator ::= 
     + I -I * III % I = I != I === I !== I && 1111 ** 
    I < I <= I > I >= I & III" 1"- 1-" I » I « I >>> I <<< 

              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
128                 Verilog-2001: A Guide to the New Features of the Verllog  HDL 


unary_module_path_operator ::= 
     ! I-I & /-& ///-//" / _" /"-
binary _module-path_operator ::= 
     == / != / && / " / & ///" 1"-1-" 
A.8.7 Numbers 
number ::= 
     decimal_number 
    / octal_number 
    / binary_number 
    / hex_number 
    I reaCnumber 
real_number ::= 
     unsigned_number. unsigned_number 
    / unsigned_number [ • unsigned_number] exp [ sign] unsigned_number 
exp ::=e 1E  
decimal_number ::= 
     unsigned_number 
    1 [ size] decimal_base unsigned_number 
    / [ size] decimal_base x_digit { _ } 
    / [ size] decimal_base z_digit { _  } 
binary_number ::= [size] binary_base binary_value 
octal_number ::= [size] octaCbase octal_value 
hex_number ::= [ size] hex_base hex_value 
sign ::= + I-
size ::= non_zero_unsigned_number 
non_zero_unsigned_number ::= non_zero_decimaCdigit { _/ decimal_digit} 
unsigned_number ::= decimaCdigit { _I decimal_digit} 
binary_value ::= binary_digit { _I binary_digit} 
octal_value ::= octal_digit { _I octal_digit} 
hex_value ::= hex_digit { _I hex_digit} 
decimaCbase ::= '[sIS]d 1 '[sIS]D 
binary_base ::= '[s/S]b 1 '[s/S]B 
octal_base ::= '[sIS]o 1 '[sIS]O 
hex_base ::= '[s/S]h 1 '[sIS]H 
non_zero_decimal_digit ::= 112/314/ 5 16171819 
decimaCdigit ::= 0111213141516171819 
binary_digit ::= x_digit I z_digit / 0 /1 
octal_digit ::= x_digit / z_digit I 0 11/2/314/ 5 16/7 
hex_digit ::= 
     x_digit 1z_digit  / 0 /1 12 I  3 141  5 / 6/ 7/ 8I  9 
    / a/ b / c / d / e / f/ A / B / C I D / ElF 
x_digit ::= x I X 
z_digit ::= z / Z / ? 
A.8.8 Strings 
string ::= "  { Any_ASCICCharacters_excepcnew_line } " 


              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
Appendix A:   Verllog-2001 formal definition                                   129 

A.9 General 

A.9.1 Attributes 
attribute_instance ::= (* attr_spec { , attr_spec} *) 
attcspec ::= 
     attr_name =constancexpression  
    I attcname 
attr_name ::= identifier 
A.9.2 Comments 
comment ::= 
     one_line30mment 
    I block_comment 
one_line_comment ::= /I commenCtext \n 
block30mment ::= 1* commenCtext *1 
commenuext ::= { Any_ASCII3haracter } 
A.9.3 Identifiers 
arrayed_identifier ::= 
     simple_arrayed_identifier 
    I escaped_arrayed_identifier 
block_identifier::= identifier 
cell_identifier ::= identifier 
config_identifier ::= identifier 
escaped_arrayed_identifier ::= escaped_identifier [ range 1 
escaped_hierarchicaUdentifier ::= 
     escaped_hierarchical_branch 
        { .simple_hierarchical_branch I .escaped_hierarchical_branch } 
escaped_identifier ::= \ {Any_ASCII3haracter_excepc white_space}  white_space 
event_identifier::= identifier 
function_identifier::= identifier 
gate_instance_identifier ::= arrayed_identifier 
generate_block_identifier ::= identifier 
genvar3unction_identifier ::= identifier 1* Hierarchy disallowed *1 
genvar_identifier ::= identifier 
hierarchical_block_identifier ::= hierarchical_identifier 
hierarchical_evenCidentifier ::= hierarchical_identifier 
hierarchical_function_identifier :: = hierarchical_identifier 
hierarchical_identifier: := 
     simple_hierarchicaUdentifier 
    I escaped_hierarchical_identifier 
hierarchical_net_identifier ::= hierarchicaUdentifier 
hierarchical_variable_identifier::= hierarchical_identifier 
hierarchicaUask_identifier ::= hierarchicaUdentifier 
identifier: := 
     simple_identifier 
    I escaped_identifier 
inoucporUdentifier ::= identifier 
inpucport_identifier ::= identifier 
instance_identifier ::= identifier 
library_identifier ::= identifier 
memory_identifier ::= identifier 
module_identifier ::= identifier 

              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
130                 Verllog-2001: A Guide to the New Features of the Verllog HDL 


module_instance_identifier ::= arrayed_identifier 
neUdentifier ::= identifier 
output_port_identifier ::= identifier 
parametecidentifier ::= identifier 
port_identifier::= identifier 
real_identifier ::= identifier 
simple_arrayed_identifier ::= simple_identifier [range 1 
simple_hierarchical_identifier ::= 
     simple_hierarchical_branch [ .escaped_identifier 1 
simple_identifier ::= [a-zA-Z_l { [a-zA-ZO-9_$1 } 
specparam_identifier ::= identifier 
system3unction_identifier ::= $[ a-zA-ZO-9_$]{ [a-zA-ZO-9_$1 } 
system_task_identifier ::= $[ a-zA-ZO-9_$]{ [a-zA-ZO-9_$1 } 
task_identifier::= identifier 
terminal_identifier ::= identifier 
texCmacro_identifier ::= simple_identifier 
topmodule_identifier ::= identifier 
udp_identifier ::= identifier 
udp_instance_identifier ::= arrayed_identifier 
variable_identifier ::= identifier 
A.9.4 Identifier branches 
simple_hierarchicaCbranch ::= 
     simple_identifier [ [ unsigned_number 11 
        [ { .simple_identifier [ [ unsigned_number 11 } 1 
escaped_hierarchicaCbranch ::= 
     escaped_identifier [ [ unsigned_number 11 
        [ { .escaped_identifier [ [ unsigned_number 11 } 1 
A.9.5 White space 
white_space ::= space I tab I newline I eof 

NOTES: 

1-Embedded spaces are illegal. 
2-  A simple_identifier and arrayed_reference shall start with an alpha or underscore L) 
    character, shall have at least one character, and shall not have any spaces. 
3-The period (.) in simple_hierarchical_identifier and simple_hierarchica'- branch shall not 
    be preceded or followed by white_space. 
4-The period in escaped_hierarchical_identifier and escaped_hierarchical_ branch shall be 
    preceded by white_space, but shall not be followed by white_space. 
5-The   $ character in a system_function_identifier or system_task_identifier shall not be 
    followed by white_space. A system3unction_identifier or system_task_identifier shall not 
    be escaped. 
6-  End of file. 


              From IEEE Std. 1364-2001. Copyright 2001 IEEE. All rights reserved. 
                                                                     131 

AppendixB: 
 Verilog-2001             reserved words 


 always          event               notifl                  strongO 
 and             for                 or                      strongl 
 assign          force               output                  supplyO 
automatic        forever             parameter               supplyl 
begin            fork                pmos                    table 
buf              function            posedge                 task 
bufifO           generate            primitive               time 
bufifl           genvar              pull 0                  tran 
case             highzO              pulll                   tranifO 
casex            highzl              pulldown                tranifl 
casez            if                  pullup                  tri 
cell             ifnone              pulsestyle_onevent      triO 
cmos             initial             pulsestyle_ondetect     tril 
config           instance            rcmos                   triand 
deassign         inout               real                    trior 
default          input               realtime                trireg 
defparam         integer             reg                     unsigned 
design           join                release                use 
disable          large               repeat                  vectored 
edge             liblist             rnmos                  wait 
else             localparam          rpmos                  wand 
end              macromodule         rtran                  weakO 
endcase          medium              rtranifO               weakl 
endconfig        module              rtranifl               while 
endfunction      nand                scalared               wire 
endgenerate      negedge             signed                 wor 
endmodule        nmos                showcancelled          xnor 
endprimitive     nor                 small                  xor 
endspecify       not                 specify 
endtable         noshowcancelled     specparam 
endtask          notifO              strength 

(bold text indicates new reserved words that were added for the Verilog-2001 standard) 
                                                                     133 

                               Index 


 Symbols                             $sync$and$array .................. 106 
 #( ............................... 12 $test$plusargs...................... 78 
 $async$and$array ................. 106 $timeskew .................... 98, 102 
 $dumpports ...................... 104 $ungetc ........................ 70-71 
 $dumpportsall .................... 104 $unsigned......................... 48 
 $dumpportsflush .................. 104 $value$plusargs.................... 79 
 $dumpportslimit . . . . . . . . . . . . . . . . . .. 104 $write............................ 76 
 $dumpportsoff .................... 104 (* ............................... 57 
 $dumpportson .................... 104 *)............................... 57 
 $fdisplay. . . . . . . . . . . . . . . . . . . . . .. 67,70 +: ............................... 37 
 $ferror ........................ 70, 75 -................................. 37 
 $fflush ........................ 70, 75 «<.............................. 50 
 $fgetc ......................... 70-71 »>.............................. 50 
 $fgets ......................... 70-71 @(*) .......................... 29-31 
 $fmonitor . . . . . . . . . . . . . . . . . . . . .. 67,70 @*........................... 29-31 
 $fopen ........................ 67--69 'defaulcnettype ................. 32,34 
 $fread . . . . . . . . . . . . . . . . . . . . . . . .. 70, 73 'else. . . . . . . . . . . . . . . . . . . . . . . . . . . .. 80 
 $frewind . . . . . . . . . . . . . . . . . . . . . . . . .. 75 'elsif............................. 80 
 $fscanf .. . . . . . . . . . . . . . . . . . . . . .. 70-73 'endif... . . . . . . . . . . . . . . . . . . . . . . . .. 80 
 $fseek . . . . . . . . . . . . . . . . . . . . . . . .. 70, 74 'ifdef............................. 80 
 $fstrobe .......................... 70 'ifndef . . . . . . . . . . . . . . . . . . . . . . . . . . .. 80 
 $ftell . . . . . . . . . . . . . . . . . . . . . . . . .. 70, 74 'line............................. 82 
 $fullskew ..................... 98, 102 'undef............................ 80 
 $fwrite ........................... 70 
 $random . . . . . . . . . . . . . . . . . . . . . . . . .. 66 A 
$readmemb . . . . . . . . . . . . . . . . . . . . . . .. 70 ANSI C style declarations 10,14,17-18,43 
$readmemh . . . . . . . . . . . . . . . . . . . . . . .. 70 arithmetic 
$recrem .................. 98, 100, 102 shift operators . .. . .. . .. .. . .. .. .... 50 
$removal ..................... 98,102  signed .................... 42-51 59 
$rewind .......................... 70  unsigned ........................ ' 42 
$sdCannotate . . . . . . . . . . . . . . . . . . . .. 102 arrays 
$setuphold ....................... 100 bit selects ....................... 41 
$sformat ....................... 76-77 memories ...................... . 38 
$signed ........................... 48 multidimensional ................ . 38 
$sscanf ........................... 77 of nets ......................... . 40 
$swrite ........................ 76-77 of real variables .................. 40 
$swriteb .......................... 76 of variables ..................... . 38 
$swriteh .......................... 76 part selects ..................... . 41 
$swriteo .......................... 76 assignment width extension .......... . 52 
134                 Verllog-2001: A Guide to the New Features of the Verllog HDL 

attributes ........ , . . . . . . . . . . . . . . . .. 56 F 
automatic functions ................. 22  fd...............................     68 
automatic tasks . . . . . . . . . . . . . . . . . . . .. 20 fil d I' '1 d' ti'  82 
                                           I e an me compl er lrec ve ....... . 
                                          file IJO ........................ 67-75 
B                                         fixed parameters . . . . . . . . . . . . . . . . . . .. 64 
Backus-Naur Form. . . . . . . . . . . . . . . .. 109 for, in generate blocks ............ 85-86 
backward compatible . . . . . . . . . . . . . . .. 53 formal definition .................. 109 
bit selects of arrays ................. 41 full_case . . . . . . . . . . . . . . . . . . . . . . . . .. 56 
BNF   ............................   109  functions 
                                            automatic (recursive) .............. 22 
                                            constant ........................ . 24 
c                                           declarations ..................... . 18 
case, in generate blocks ........... 85, 88 signed ......................... .  46 
cell ...........................  91-92 
checktime_condition ...............  100  (j 
combinational logic sensitivity list ..... 28 
combined port/type declarations .. 8, II, 15, generate ....................... 84-89 
         17, 19                           genvar ............................   85 
comma-separated sensitivity list ...... . 26 glitch detection . . . . . . . . . . . . . . . . .. 94-97 
compiler directives 
  conditional compilation ............ 80 
  file and line . . . . . . . . . . . . . . . . . . . . .. 82 IEEE Std. 1364.1 ................. 7,57 
config ............................   91  IEEE Std. 1364-2001 .................  3 
configurations .................. 90-92   IEEE Std. 1497 ....................  102 
constant functions .................. 24  if-else, in generate blocks ........ 85, 88 
constants                                 implicit nets 
  fixed ...........................   64    disabling ........................  34 
  localparam ...................   13, 65   with continuous assignments ........ 32 
  parameter ..............  12, 59, 62, 65 -incdir . . . . . . . . . . . . . . . . . . . . . . . . . . .. 93 
  redefinition ...................... 62  include ...........................  93 
  specparam . . . . . . . . . . . . . . . . . . .. 13,65 inertial delay ...................... 94 
                                          in-line parameter redefinition ......... 62 
D                                         instance .......................  91-92 
declarations                              integer numbers .................... 44 
  data type ................... 8, 10, 42 integers, signed .................... 44 
  ports ......................  8, 10,43  invocation option testing ............. 78 
  signed .......................  42-43 
default ...........................   92  L 
default net type ................. , 32, 34 labels ........................... 103 
delayed_data .....................   100  liblist ......................... 91-92 
delayed_reference. . . . . . . . . . . . . . . .. 100 
                                          library ............................ 93 
design . . . . . . . . . . . . . . . . . . . . . . . .. 91-92 library map file ................ " 91,93 
                                          localparam ..................  13,64-65 
E 
endconfig ........................ . 91   M 
endgenerate ...................... .  85 
                                      63  mcd ..............................   67 
explicit in-line parameter redefinition .. . memory arrays .. . . . . . . . . . . . . . . . . . .. 38 
extended VCD  ....................   104  multi-channel descriptor ............. 67 
                                          multidimensional arrays . . . . . . . . . . . . .. 38 
Index                                                                          135 

N                                         single-channel file descriptor . . . . . . . . .. 68 
negative pulse detection. . . . . . . . . . . . .. 96 specparam ........... 13,64-65,94, 103 
negative timing constraints .......... 100 stamptime_condition ............... 100 
net declarations .................... 42  Standard Delay Format, see SDF 
noshowcancelled  ...................  97  STDERR    .........................   68 
                                          STDIN   ...........................   68 
                                          STDOUT    .........................   68 
o                                         string read and write tasks ............ 76 
on-detect pulse error propagation     94  symbolic library names .............. 91 
on-event pulse error propagation . . . . . .. 94 synthesis pragmas .................. 56 
                                          synthesis subset .................. 7,57 
p 
parallel_case. . . . . . . . . . . . . . . . . . . . . .. 56 T 
parameter . . . . . . . . . . . . . . . . . .. 12, 64-65 tasks 
parameter redefinition ............... 62   automatic (re-entrant) . . . . . . . . . . . . .. 20 
parameter, sized and typed. . . . . . . . . . .. 59 declarations. . . . .. . . . . . . . . . . . . . . .. 18 
part selects of arrays ................ 41 timing checks 
PATHPULSE$    .....................   94    $fullskew. . . . . . . . . . . . . . . . . . . . . .. 98 
PLA system tasks. . . . . . . . . . . . . . . . .. 106 $recrem ..................... 98,100 
PLI ... . . . .. 23, 39, 56, 70, 75, 78, 82, 107 $removal . . . . . . . . . . . . . . . . . . . . . . .. 98 
port declarations. . . . . . . . . . .. 8, 10, 42-43 $setuphold . . . . . . . . . . . . . . . . . . . . .. 100 
power operator . . . . . . . . . . . . . . . . . . . .. 54 $timeskew . . . . . . . . . . . . . . . . . . . . . .. 98 
pragmas  ..........................   56    negative. . . . . . . . . . . . . . . . . . . . . . .. 100 
Programming Language Interface, see PLI   transport delay ..................... 94 
pulse detection . . . . . . . . . . . . . . . . .. 94-97 
pulsestyle_ondetect ................. 95 
pulsestyle_onevent . . . . . . . . . . . . . . . . .. 95 u 
                                          UDP  ..........................    14,17 
                                          unsigned arithmetic ................. 42 
R                                         use ...........................   91-92 
random numbers  ...................   66 
recursive functions . . . . . . . . . . . . . . . . .. 22 V 
re-entrant tasks . . . . . . . . . . . . . . . . . . . .. 20 
reg declarations .................... 42  Value Change Dump files, see VCD 
                                          variable initial value. . . . . . . . . . . . . . . .. 16 
                                          variable vector part selects . . . . . . . . . . .. 36 
S                                         VCD  ............................    104 
SDF  .........................   64,102   vector part selects . . . . . . . . . . . . . . . . . .. 36 
sensitivity list 
  combinational logic ............... 28 
  comma separated .................  26 
showcancelled .....................  97 
signed 
 arithmetic .................  42-51,59 
 conversion system functions . . . . . . . .. 48 
 functions ... . . . . . . . . . . . . . . . . . . . .. 46 
 integers .........................  44 
 keyword   ..................  43,47,60 
 net declarations . . . . . . . . . . . . . . . . . .. 42 
 parameters . . . . . . . . . . . . . . . . . . . . . .. 60 
 port declarations .................. 42 
 reg declarations. . . . . . . . . . . . . . . . . .. 42 
 shift operators . . . . . . . . . . . . . . . . . . .. 50 