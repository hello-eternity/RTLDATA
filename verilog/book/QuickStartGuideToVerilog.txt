Brock J. LaMeres

Quick Start
Guide to Verilog



QUICK START GUIDE TO VERILOG



QUICK START GUIDE TO VERILOG
1ST EDITION

Brock J. LaMeres



Brock J. LaMeres
Department of Electrical & Computer Engineering
Montana State University
Bozeman, MT, USA

ISBN 978-3-030-10551-8 ISBN 978-3-030-10552-5 (eBook)
https://doi.org/10.1007/978-3-030-10552-5

Library of Congress Control Number: 2018968403

# Springer Nature Switzerland AG 2019
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the material is
concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction
on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic
adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication does not
imply, even in the absence of a specific statement, that such names are exempt from the relevant protective laws and
regulations and therefore free for general use.
The publisher, the authors, and the editors are safe to assume that the advice and information in this book are believed
to be true and accurate at the date of publication. Neither the publisher nor the authors or the editors give a warranty,
express or implied, with respect to the material contained herein or for any errors or omissions that may have been
made. The publisher remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.

Cover credit:# MRMake j Dreamstime.com - Binary Code Photo

This Springer imprint is published by the registered company Springer Nature Switzerland AG
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland



Preface
The classical digital design approach (i.e., manual synthesis and minimization of logic) quickly

becomes impractical as systems become more complex. This is the motivation for the modern digital
design flow, which uses hardware description languages (HDL) and computer-aided synthesis/minimi-
zation to create the final circuitry. The purpose of this book is to provide a quick start guide to the Verilog
language, which is one of the two most common languages used to describe logic in the modern digital
design flow. This book is intended for anyone that has already learned the classical digital design
approach and is ready to begin learning HDL-based design. This book is also suitable for practicing
engineers that already know Verilog and need quick reference for syntax and examples of common
circuits. This book assumes that the reader already understands digital logic (i.e., binary numbers,
combinational and sequential logic design, finite state machines, memory, and binary arithmetic basics).

Since this book is designed to accommodate a designer that is new to Verilog, the language is
presented in a manner that builds foundational knowledge first before moving into more complex topics.
As such, Chaps. 1–6 provide a comprehensive explanation of the basic functionality in Verilog to model
combinational and sequential logic. Chapters 7–11 focus on examples of common digital systems such
as finite state machines, memory, arithmetic, and computers. For a reader that is using the book as a
reference guide, it may be more practical to pull examples from Chaps. 7–11 as they use the full
functionality of the language as it is assumed the reader has gained an understanding of it in
Chaps. 1–6. For a Verilog novice, understanding the history and fundamentals of the language will
help form a comprehensive understanding of the language; thus it is recommended that the early
chapters are covered in the sequence they are written.

Bozeman, MT, USA Brock J. LaMeres

v



Acknowledgments

For Kylie. Your humor brings me laughter and happiness every day. Thank you.

vii



Contents
1: THE MODERN DIGITAL DESIGN FLOW ............................................................. 1

1.1 HISTORY OF HARDWARE DESCRIPTION LANGUAGES ..................................................... 1
1.2 HDL ABSTRACTION ................................................................................................ 4
1.3 THE MODERN DIGITAL DESIGN FLOW ........................................................................ 8

2: VERILOG CONSTRUCTS .................................................................................... 13

2.1 DATA TYPES .......................................................................................................... 13
2.1.1 Value Set ..................................................................................................... 14
2.1.2 Net Data Types ............................................................................................ 14
2.1.3 Variable Data Types .................................................................................... 15
2.1.4 Vectors ........................................................................................................ 15
2.1.5 Arrays .......................................................................................................... 16
2.1.6 Expressing Numbers Using Different Bases .............................................. 16
2.1.7 Assigning Between Different Types ............................................................ 17

2.2 VERILOG MODULE CONSTRUCTION ............................................................................ 17
2.2.1 The Module ................................................................................................. 18
2.2.2 Port Definitions ............................................................................................ 18
2.2.3 Signal Declarations ..................................................................................... 19
2.2.4 Parameter Declarations .............................................................................. 20
2.2.5 Compiler Directives ..................................................................................... 20

3: MODELING CONCURRENT FUNCTIONALITY IN VERILOG ............................. 23

3.1 VERILOG OPERATORS .............................................................................................. 23
3.1.1 Assignment Operator .................................................................................. 23
3.1.2 Continuous Assignment .............................................................................. 23
3.1.3 Bitwise Logical Operators ........................................................................... 24
3.1.4 Reduction Logic Operators ......................................................................... 25
3.1.5 Boolean Logic Operators ............................................................................ 25
3.1.6 Relational Operators ................................................................................... 25
3.1.7 Conditional Operators ................................................................................. 26
3.1.8 Concatenation Operator .............................................................................. 26
3.1.9 Replication Operator ................................................................................... 27
3.1.10 Numerical Operators ................................................................................... 27
3.1.11 Operator Precedence .................................................................................. 28

3.2 CONTINUOUS ASSIGNMENT WITH LOGICAL OPERATORS ................................................. 29
3.2.1 Logical Operator Example: SOP Circuit ..................................................... 29
3.2.2 Logical Operator Example: One-Hot Decoder ............................................ 30
3.2.3 Logical Operator Example: 7-Segment Display Decoder ........................... 31
3.2.4 Logical Operator Example: One-Hot Encoder ............................................ 34
3.2.5 Logical Operator Example: Multiplexer ....................................................... 36
3.2.6 Logical Operator Example: Demultiplexer .................................................. 36

ix



x • Contents

3.3 CONTINUOUS ASSIGNMENT WITH CONDITIONAL OPERATORS .......................................... 37
3.3.1 Conditional Operator Example: SOP Circuit ............................................... 38
3.3.2 Conditional Operator Example: One-Hot Decoder ..................................... 39
3.3.3 Conditional Operator Example: 7-Segment Display Decoder .................... 40
3.3.4 Conditional Operator Example: One-Hot Decoder ..................................... 40
3.3.5 Conditional Operator Example: Multiplexer ................................................ 41
3.3.6 Conditional Operator Example: Demultiplexer ........................................... 42

3.4 CONTINUOUS ASSIGNMENT WITH DELAY ..................................................................... 43

4: STRUCTURAL DESIGN AND HIERARCHY ........................................................ 51

4.1 STRUCTURAL DESIGN CONSTRUCTS .......................................................................... 51
4.1.1 Lower-Level Module Instantiation ............................................................... 51
4.1.2 Port Mapping ............................................................................................... 51
4.1.3 Gate-Level Primitives .................................................................................. 53
4.1.4 User-Defined Primitives .............................................................................. 54
4.1.5 Adding Delay to Primitives .......................................................................... 55

4.2 STRUCTURAL DESIGN EXAMPLE: RIPPLE CARRY ADDER ............................................... 56
4.2.1 Half Adders .................................................................................................. 56
4.2.2 Full Adders .................................................................................................. 56
4.2.3 Ripple Carry Adder (RCA) .......................................................................... 58
4.2.4 Structural Model of a Ripple Carry Adder in Verilog ................................... 59

5: MODELING SEQUENTIAL FUNCTIONALITY ..................................................... 65

5.1 PROCEDURAL ASSIGNMENT ...................................................................................... 65
5.1.1 Procedural Blocks ....................................................................................... 65
5.1.2 Procedural Statements ................................................................................ 68
5.1.3 Statement Groups ....................................................................................... 73
5.1.4 Local Variables ............................................................................................ 73

5.2 CONDITIONAL PROGRAMMING CONSTRUCTS ................................................................ 74
5.2.1 if-else Statements ........................................................................................ 74
5.2.2 case Statements ......................................................................................... 75
5.2.3 casez and casex Statements ...................................................................... 77
5.2.4 forever Loops .............................................................................................. 77
5.2.5 while Loops ................................................................................................. 77
5.2.6 repeat Loops ............................................................................................... 78
5.2.7 for Loops ...................................................................................................... 78
5.2.8 disable ......................................................................................................... 79

5.3 SYSTEM TASKS ...................................................................................................... 80
5.3.1 Text Output .................................................................................................. 80
5.3.2 File Input/Output .......................................................................................... 81
5.3.3 Simulation Control and Monitoring .............................................................. 83

6: TEST BENCHES .................................................................................................. 89

6.1 TEST BENCH OVERVIEW .......................................................................................... 89
6.1.1 Generating Manual Stimulus ....................................................................... 89
6.1.2 Printing Results to the Simulator Transcript ............................................... 91



Contents • xi

6.2 USING LOOPS TO GENERATE STIMULUS ..................................................................... 93
6.3 AUTOMATIC RESULT CHECKING ................................................................................. 95
6.4 USING EXTERNAL FILES IN TEST BENCHES ................................................................ 96

7: MODELING SEQUENTIAL STORAGE AND REGISTERS ................................. 103

7.1 MODELING SCALAR STORAGE DEVICES ..................................................................... 103
7.1.1 D-Latch ........................................................................................................ 103
7.1.2 D-Flip-Flop ................................................................................................... 103
7.1.3 D-Flip-Flop with Asynchronous Reset ........................................................ 104
7.1.4 D-Flip-Flop with Asynchronous Reset and Preset ...................................... 105
7.1.5 D-Flip-Flop with Synchronous Enable ........................................................ 106

7.2 MODELING REGISTERS ............................................................................................ 107
7.2.1 Registers with Enables ............................................................................... 107
7.2.2 Shift Registers ............................................................................................. 108
7.2.3 Registers as Agents on a Data Bus ............................................................ 109

8: MODELING FINITE STATE MACHINES .............................................................. 113

8.1 THE FSM DESIGN PROCESS AND A PUSH-BUTTON WINDOW CONTROLLER EXAMPLE ...... 113
8.1.1 Modeling the States .................................................................................... 114
8.1.2 The State Memory Block ............................................................................. 115
8.1.3 The Next State Logic Block ........................................................................ 115
8.1.4 The Output Logic Block ............................................................................... 116
8.1.5 Changing the State Encoding Approach .................................................... 118

8.2 FSM DESIGN EXAMPLES ........................................................................................ 119
8.2.1 Serial Bit Sequence Detector in Verilog ...................................................... 119
8.2.2 Vending Machine Controller in Verilog ........................................................ 121
8.2.3 2-Bit, Binary Up/Down Counter in Verilog ................................................... 123

9: MODELING COUNTERS ...................................................................................... 129

9.1 MODELING COUNTERS WITH A SINGLE PROCEDURAL BLOCK ......................................... 129
9.1.1 Counters in Verilog Using the Type reg ...................................................... 129
9.1.2 Counters with Range Checking .................................................................. 130

9.2 COUNTER WITH ENABLES AND LOADS ........................................................................ 131
9.2.1 Modeling Counters with Enables ................................................................ 131
9.2.2 Modeling Counters with Loads ................................................................... 131

10: MODELING MEMORY ........................................................................................ 135

10.1 MEMORY ARCHITECTURE AND TERMINOLOGY .............................................................. 135
10.1.1 Memory Map Model .................................................................................... 135
10.1.2 Volatile vs. Non-volatile Memory ................................................................ 136
10.1.3 Read-Only vs. Read/Write Memory ............................................................ 136
10.1.4 Random Access vs. Sequential Access ..................................................... 136

10.2 MODELING READ-ONLY MEMORY ............................................................................. 137
10.3 MODELING READ/WRITE MEMORY ............................................................................ 139



xii • Contents

11: COMPUTER SYSTEM DESIGN ......................................................................... 143

11.1 COMPUTER HARDWARE ........................................................................................... 143
11.1.1 Program Memory ......................................................................................... 144
11.1.2 Data Memory ............................................................................................... 144
11.1.3 Input/Output Ports ....................................................................................... 144
11.1.4 Central Processing Unit .............................................................................. 144
11.1.5 A Memory Mapped System ......................................................................... 146

11.2 COMPUTER SOFTWARE ............................................................................................ 148
11.2.1 Opcodes and Operands .............................................................................. 149
11.2.2 Addressing Modes ...................................................................................... 149
11.2.3 Classes of Instructions ................................................................................ 150

11.3 COMPUTER IMPLEMENTATION: AN 8-BIT COMPUTER EXAMPLE ....................................... 157
11.3.1 Top-Level Block Diagram ............................................................................ 157
11.3.2 Instruction Set Design ................................................................................. 158
11.3.3 Memory System Implementation ................................................................ 159
11.3.4 CPU Implementation ................................................................................... 163

APPENDIX A: LIST OF WORKED EXAMPLES ...................................................... 187

INDEX ....................................................................................................................... 189



Chapter 1: The Modern Digital
Design Flow

The purpose of hardware description languages is to describe digital circuitry using a text-based
language. HDLs provide a means to describe large digital systems without the need for schematics,
which can become impractical in very large designs. HDLs have evolved to support logic simulation at
different levels of abstraction. This provides designers the ability to begin designing and verifying
functionality of large systems at a high level of abstraction and postpone the details of the circuit
implementation until later in the design cycle. This enables a top-down design approach that is scalable
across different logic families. HDLs have also evolved to support automated synthesis, which allows the
CAD tools to take a functional description of a system (e.g., a truth table) and automatically create the
gate-level circuitry to be implemented in real hardware. This allows designers to focus their attention on
designing the behavior of a system and not spend as much time performing the formal logic synthesis
steps as in the classical digital design approach.

There are two dominant hardware description languages in use today. They are VHDL and Verilog.
VHDL stands for very high speed integrated circuit hardware description language. Verilog is not an
acronym but rather a trade name. The use of these two HDLs is split nearly equally within the digital
design industry. Once one language is learned, it is simple to learn the other language, so the choice of
the HDL to learn first is somewhat arbitrary. In this text we will use Verilog to learn the concepts of an
HDL. Verilog is more lenient on its typecasting than VHDL, so it is a good platform for beginners as
systems can be designed with less formality. The goal of this chapter is to provide the background and
context of the modern digital design flow using an HDL-based approach.

Learning Outcomes—After completing this chapter, you will be able to:

1.1 Describe the role of hardware description languages in modern digital design.
1.2 Describe the fundamentals of design abstraction in modern digital design.
1.3 Describe the modern digital design flow based on hardware description languages.

1.1 History of Hardware Description Languages

The invention of the integrated circuit is most commonly credited to two individuals who filed patents
on different variations of the same basic concept within 6 months of each other in 1959. Jack Kilby filed
the first patent on the integrated circuit in February of 1959 titled “Miniaturized Electronic Circuits” while
working for Texas Instruments. Robert Noyce was the second to file a patent on the integrated circuit in
July of 1959 titled “Semiconductor Device and Lead Structure” while at a company he cofounded called
Fairchild Semiconductor. Kilby went on to win the Nobel Prize in Physics in 2000 for his invention, while
Noyce went on to cofound Intel Corporation in 1968 with Gordon Moore. In 1971, Intel introduced the first
single-chip microprocessor using integrated circuit technology, the Intel 4004. This microprocessor IC
contained 2300 transistors. This series of inventions launched the semiconductor industry, which was
the driving force behind the growth of Silicon Valley and led to 40 years of unprecedented advancement
in technology that has impacted every aspect of the modern world.

Gordon Moore, cofounder of Intel, predicted in 1965 that the number of transistors on an integrated
circuit would double every 2 years. This prediction, now known as Moore’s Law, has held true since the
invention of the integrated circuit. As the number of transistors on an integrated circuit grew, so did the
size of the design and the functionality that could be implemented. Once the first microprocessor was

# Springer Nature Switzerland AG 2019 1
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5_1



2 • Chapter 1: The Modern Digital Design Flow

invented in 1971, the capability of CAD tools increased rapidly enabling larger designs to be accom-
plished. These larger designs, including newer microprocessors, enabled the CAD tools to become even
more sophisticated and, in turn, yield even larger designs. The rapid expansion of electronic systems
based on digital integrated circuits required that different manufacturers needed to produce designs that
were compatible with each other. The adoption of logic family standards helped manufacturers ensure
their parts would be compatible with other manufacturers at the physical layer (e.g., voltage and current);
however, one challenge that was encountered by the industry was a way to document the complex
behavior of larger systems. The use of schematics to document large digital designs became too
cumbersome and difficult to understand by anyone besides the designer. Word descriptions of the
behavior were easier to understand, but even this form of documentation became too voluminous to
be effective for the size of designs that were emerging.

In 1983, the US Department of Defense (DoD) sponsored a program to create a means to document
the behavior of digital systems that could be used across all of its suppliers. This program was motivated
by a lack of adequate documentation for the functionality of application specific integrated circuits
(ASICs) that were being supplied to the DoD. This lack of documentation was becoming a critical
issue as ASICs would come to the end of their life cycle and need to be replaced. With the lack of a
standardized documentation approach, suppliers had difficulty reproducing equivalent parts to those that
had become obsolete. The DoD contracted three companies (Texas Instruments, IBM, and Intermetrics)
to develop a standardized documentation tool that provided detailed information about both the interface
(i.e., inputs and outputs) and the behavior of digital systems. The new tool was to be implemented in a
format similar to a programming language. Due to the nature of this type of language-based tool, it was a
natural extension of the original project scope to include the ability to simulate the behavior of a digital
system. The simulation capability was desired to span multiple levels of abstraction to provide maximum
flexibility. In 1985, the first version of this tool, called VHDL, was released. In order to gain widespread
adoption and ensure consistency of use across the industry, VHDL was turned over to the Institute of
Electrical and Electronic Engineers (IEEE) for standardization. IEEE is a professional association that
defines a broad range of open technology standards. In 1987, IEEE released the first industry standard
version of VHDL. The release was titled IEEE 1076-1987. Feedback from the initial version resulted in a
major revision of the standard in 1993 titled IEEE 1076-1993. While many minor revisions have been
made to the 1993 release, the 1076-1993 standard contains the vast majority of VHDL functionality in
use today. The most recent VHDL standard is IEEE 1076-2008.

Also in 1983, the Verilog HDL was developed by Automated Integrated Design Systems as a logic
simulation language. The development of Verilog took place completely independent from the VHDL
project. Automated Integrated Design Systems (renamed Gateway Design Automation in 1985) was
acquired by CAD tool vendorCadence Design Systems in 1990. In response to the popularity of Verilog’s
intuitive programming and superior simulation support, and also to stay competitive with the emerging
VHDL standard, Cadencemade the Verilog HDL open to the public. IEEE once again developed the open
standard for this HDL, and in 1995 released the Verilog standard titled IEEE 1364-1995. This release has
undergone numerous revisions with the most significant occurring in 2001. It is common to refer to the
major releases as “Verilog 1995” and “Verilog 2001” instead of their official standard numbers.

The development of CAD tools to accomplish automated logic synthesis can be dated back to the
1970s when IBM began developing a series of practical synthesis engines that were used in the design
of their mainframe computers; however, the main advancement in logic synthesis came with the founding
of a company called Synopsis in 1986. Synopsis was the first company to focus on logic synthesis
directly from HDLs. This was a major contribution because designers were already using HDLs to
describe and simulate their digital systems, and now logic synthesis became integrated in the same
design flow. Due to the complexity of synthesizing highly abstract functional descriptions, only lower
levels of abstraction that were thoroughly elaborated were initially able to be synthesized. As CAD tool



1.1 History of Hardware Description Languages • 3

capability evolved, synthesis of higher levels of abstraction became possible, but even today not all
functionality that can be described in an HDL can be synthesized.

The history of HDLs, their standardization, and the creation of the associated logic synthesis tools is
key to understanding the use and limitations of HDLs. HDLs were originally designed for documentation
and behavioral simulation. Logic synthesis tools were developed independently and modified later to
work with HDLs. This history provides some background into the most common pitfalls that beginning
digital designers encounter, that being that mostly any type of behavior can be described and simulated
in an HDL, but only a subset of well-described functionality can be synthesized. Beginning digital
designers are often plagued by issues related to designs that simulate perfectly but that will not
synthesize correctly. In this book, an effort is made to introduce Verilog at a level that provides a
reasonable amount of abstraction while preserving the ability to be synthesized. Figure 1.1 shows a
timeline of some of the major technology milestones that have occurred in the past 150 years in the field
of digital logic and HDLs.

Fig. 1.1
Major milestones in the advancement of digital logic and HDLs



4 • Chapter 1: The Modern Digital Design Flow

CONCEPT CHECK

CC1.1 Why does Verilog support modeling techniques that aren’t synthesizable?

(A) There wasn’t enough funding available to develop synthesis capability as it all
went to the VHDL project.

(B) At the time Verilog was created, synthesis was deemed too difficult to
implement.

(C) To allow Verilog to be used as a generic programming language.

(D) Verilog needs to support all steps in the modern digital design flow, some of
which are unsynthesizable such as test pattern generation and timing
verification.

1.2 HDL Abstraction

HDLs were originally defined to be able to model behavior at multiple levels of abstraction.
Abstraction is an important concept in engineering design because it allows us to specify how systems
will operate without getting consumed prematurely with implementation details. Also, by removing the
details of the lower-level implementation, simulations can be conducted in reasonable amounts of time to
model the higher-level functionality. If a full computer system was simulated using detailed models for
every MOSFET, it would take an impracticable amount of time to complete. Figure 1.2 shows a graphical
depiction of the different layers of abstraction in digital system design.

Fig. 1.2
Levels of design abstraction



1.2 HDL Abstraction • 5

The highest level of abstraction is the system level. At this level, behavior of a system is described
by stating a set of broad specifications. An example of a design at this level is a specification such as “the
computer system will perform 10 Tera Floating Point Operations per Second (10 TFLOPS) on double
precision data and consume no more than 100 W of power.” Notice that these specifications do not
dictate the lower-level details such as the type of logic family or the type of computer architecture to use.
One level down from the system level is the algorithmic level. At this level, the specifications begin to be
broken down into subsystems, each with an associated behavior that will accomplish a part of the
primary task. At this level, the example computer specifications might be broken down into subsystems
such as a central processing unit (CPU) to perform the computation and random-access memory (RAM)
to hold the inputs and outputs of the computation. One level down from the algorithmic level is the
register transfer level (RTL). At this level, the details of how data is moved between and within
subsystems are described in addition to how the data is manipulated based on system inputs. One
level down from the RTL level is the gate level. At this level, the design is described using basic gates and
registers (or storage elements). The gate level is essentially a schematic (either graphically or text-
based) that contains the components and connections that will implement the functionality from the
above levels of abstraction. One level down from the gate level is the circuit level. The circuit level
describes the operation of the basic gates and registers using transistors, wires, and other electrical
components such as resistors and capacitors. Finally, the lowest level of design abstraction is the
material level. This level describes how different materials are combined and shaped in order to
implement the transistors, devices, and wires from the circuit level.

HDLs are designed to model behavior at all of these levels with the exception of the material level.
While there is some capability to model circuit level behavior such as MOSFETs as ideal switches and
pull-up/pull-down resistors, HDLs are not typically used at the circuit level. Another graphical depiction of
design abstraction is known as the Gajski and Kuhn’s Y-chart. A Y-chart depicts abstraction across
three different design domains: behavioral, structural, and physical. Each of these design domains
contains levels of abstraction (i.e., system, algorithm, RTL, gate, and circuit). An example Y-chart is
shown in Fig. 1.3.



6 • Chapter 1: The Modern Digital Design Flow

Fig. 1.3
Y-chart of design abstraction

A Y-chart also depicts how the abstraction levels of different design domains are related to each
other. A top-down design flow can be visualized in a Y-chart by spiraling inward in a clockwise direction.
Moving from the behavioral domain to the structural domain is the process of synthesis. Whenever
synthesis is performed, the resulting system should be compared with the prior behavioral description.
This checking is called verification. The process of creating the physical circuitry corresponding to the
structural description is called implementation. The spiral continues down through the levels of abstrac-
tion until the design is implemented at a level that the geometries representing circuit elements
(transistors, wires, etc.) are ready to be fabricated in silicon. Figure 1.4 shows the top-down design
process depicted as an inward spiral on the Y-chart.



1.2 HDL Abstraction • 7

Fig. 1.4
Y-chart illustrating top-down design approach

The Y-chart represents a formal approach for large digital systems. For large systems that are
designed by teams of engineers, it is critical that a formal, top-down design process is followed to
eliminate potentially costly design errors as the implementation is carried out at lower levels of
abstraction.

CONCEPT CHECK

CC1.2 Why is abstraction an essential part of engineering design?

(A) Without abstraction all schematics would be drawn at the transistor level.

(B) Abstraction allows computer programs to aid in the design process.

(C) Abstraction allows the details of the implementation to be hidden while the
higher-level systems are designed. Without abstraction, the details of the
implementation would overwhelm the designer.

(D) Abstraction allows analog circuit designers to include digital blocks in their
systems.



8 • Chapter 1: The Modern Digital Design Flow

1.3 The Modern Digital Design Flow

When performing a smaller design or the design of fully contained subsystems, the process can be
broken down into individual steps. These steps are shown in Fig. 1.5. This process is given generically
and applies to both classical andmodern digital design. The distinction between classical and modern is
that modern digital design uses HDLs and automated CAD tools for simulation, synthesis, place and
route, and verification.

Fig. 1.5
Generic digital design flow

This generic design process flow can be used across classical and modern digital design, although
modern digital design allows additional verification at each step using automated CAD tools. Figure 1.6
shows how this flow is used in the classical design approach of a combinational logic circuit.



1.3 The Modern Digital Design Flow • 9

Fig. 1.6
Classical digital design flow

The modern design flow based on HDLs includes the ability to simulate functionality at each step of
the process. Functional simulations can be performed on the initial behavioral description of the system.
At each step of the design process the functionality is described in more detail, ultimately moving toward
the fabrication step. At each level, the detailed information can be included in the simulation to verify that
the functionality is still correct and that the design is still meeting the original specifications. Figure 1.7
shows the modern digital design flow with the inclusion of simulation capability at each step.



10 • Chapter 1: The Modern Digital Design Flow

Fig. 1.7
Modern digital design flow

CONCEPT CHECK

CC1.3 Why did digital designs move from schematic entry to text-based HDLs?

(A) HDL models could be much larger by describing functionality in text similar to
traditional programming language.

(B) Schematics required sophisticated graphics hardware to display correctly.

(C) Schematics symbols became too small as designs became larger.

(D) Text was easier to understand by a broader range of engineers.



Exercise Problems • 11

Summary

v The modern digital design flow relies on after the original definition of Verilog. As
computer-aided engineering (CAE) and such, only a subset of the behavioral
computer-aided design (CAD) tools to man- modeling techniques in Verilog can be auto-
age the size and complexity of today’s digital matically synthesized.
designs. v HDLs can model digital systems at different

v Hardware description languages (HDLs) levels of design abstraction. These include
allow the functionality of digital systems to the system, algorithmic, RTL, gate, and cir-
be entered using text. VHDL and Verilog are cuit levels. Designing at a higher level of
the two most common HDLs in use today. abstraction allows more complex systems to

v Verilog was originally created to support be modeled without worrying about the
functional simulation of text-based designs. details of the implementation.

v The ability to automatically synthesize a logic
circuit from a Verilog behavioral description
became possible approximately 10 years

Exercise Problems

Section 1.1: History of HDLs 1.2.7 Give the design domain that the following activ-
ity relates to: drawing the physical layout of the

1.1.1 What was the original purpose of Verilog?
CPU will require 6 months of engineering time.

1.1.2 Can all of the functionality that can be
1.2.8 Give the design domain that the following activ-

described in Verilog be simulated?
ity relates to: the CPU will be connected to four

1.1.3 Can all of the functionality that can be banks of memory.
described in Verilog be synthesized?

1.2.9 Give the design domain that the following activ-
ity relates to: the fan-in specifications for this

Section 1.2: HDL Abstraction logic family require excessive logic circuitry to
1.2.1 Give the level of design abstraction that the be used.

following statement relates to: if there is ever 1.2.10 Give the design domain that the following activ-
an error in the system, it should return to the ity relates to: the performance specifications
reset state. for this system require 1 TFLOP at <5 W.

1.2.2 Give the level of design abstraction that the
following statement relates to: once the design Section 1.3: The Modern Digital
is implemented in a sum of products form, Design Flow
DeMorgan’s Theorem will be used to convert
it to a NAND-gate only implementation. 1.3.1 Which step in the modern digital design flow

does the following statement relate to: a CAD
1.2.3 Give the level of design abstraction that the

tool will convert the behavioral model into a
following statement relates to: the design will

gate-level description of functionality.
be broken down into two subsystems, one that
will handle data collection and the other that 1.3.2 Which step in the modern digital design flow
will control data flow. does the following statement relate to: after

realistic gate and wiring delays are determined,
1.2.4 Give the level of design abstraction that the

one last simulation should be performed to
following statement relates to: the interconnect

make sure the design meets the original timing
on the IC should be changed from aluminum to

requirements.
copper to achieve the performance needed in
this design. 1.3.3 Which step in the modern digital design flow

does the following statement relate to: if the
1.2.5 Give the level of design abstraction that the

memory is distributed around the perimeter of
following statement relates to: the MOSFETs

the CPU, the wiring density will be minimized.
need to be able to drive at least eight other
loads in this design. 1.3.4 Which step in the modern digital design flow

does the following statement relate to: the
1.2.6 Give the level of design abstraction that the

design meets all requirements, so now I’m
following statement relates to: this system will

building the hardware that will be shipped.
contain 1 host computer and support up to
1000 client computers.



12 • Chapter 1: The Modern Digital Design Flow

1.3.5 Which step in the modern digital design flow 1.3.7 Which step in the modern digital design flow
does the following statement relate to: the sys- does the following statement relate to: to meet
tem will be broken down into three subsystems the power requirements, the gates will be
with the following behaviors. implemented in the 74HC logic family.

1.3.6 Which step in the modern digital design flow
does the following statement relate to: this sys-
tem needs to have 10 Gbytes of memory.



Chapter 2: Verilog Constructs
This chapter begins looking at the basic construction of a Verilog module. The chapter begins by

covering the built-in features of a Verilog module including the file structure, data types, operators, and
declarations. It provides a foundation of Verilog that will lead to modeling examples provided in Chap. 3.
The original Verilog standard (IEEE 1364) has been updated numerous times since its creation in 1995.
The most significant update occurred in 2001, which was titled IEEE 1394-2001. In 2005, minor
improvements were added to the standard, which resulted in IEEE 1394-2005. The constructs described
in this book reflect the functionality in the IEEE 1394-2005 standard. The functionality of Verilog (e.g.,
operators, signal types, functions) is defined within the Verilog standard; thus, it is not necessary to
explicitly state that a design is using the IEEE 1394 package because it is inherent in the use of Verilog.

Verilog is case sensitive. Also, each Verilog assignment, definition, or declaration is terminated with
a semicolon (;). As such, line wraps are allowed and do not signify the end of an assignment, definition, or
declaration. Line wraps can be used to make Verilog more readable. Comments in Verilog are supported
in two ways. The first way is called a line comment and is preceded with two slashes (i.e., //). Everything
after the slashes is considered a comment until the end of the line. The second comment approach is
called a block comment and begins with /* and ends with a */. Everything between /* and */ is considered
a comment. A block comment can span multiple lines. All user-defined names in Verilog must start with
an alphabetic letter, not a number. User-defined names are not allowed to be the same as any Verilog
keyword. This chapter contains many definitions of syntax in Verilog. The following notations will be used
throughout the chapter when introducing new constructs.

bold ¼ Verilog keyword, use as is, case sensitive.
italics ¼ User-defined name, case sensitive.
<> ¼ A required characteristic such as a data type, input/output, etc.

Learning Outcomes—After completing this chapter, you will be able to:

2.1 Describe the data types provided in Verilog.
2.2 Describe the basic construction of a Verilog module.

2.1 Data Types

In Verilog, every signal, constant, variable, and function must be assigned a data type. The IEEE
1394-2005 standard provides a variety of predefined data types. Some data types are synthesizable,
while others are only for modeling abstract behavior. The following are the most commonly used data
types in the Verilog language.

# Springer Nature Switzerland AG 2019 13
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5_2



14 • Chapter 2: Verilog Constructs

2.1.1 Value Set

Verilog supports four basic values that a signal can take on: 0, 1, X, and Z. Most of the predefined
data types in Verilog store these values. A description of each value supported is given below.

Value Description

0 A logic zero, or false condition.
1 A logic one, or true condition.
x or X Unknown or uninitialized.
z or Z High impedance, tri-stated, or floating.

In Verilog, these values also have an associated strength. The strengths are used to resolve the
value of a signal when it is driven by multiple sources. The names, syntax, and relative strengths are
given below.

Strength Description Strength level

supply1 Supply drive for VCC 7
supply0 Supply drive for VSS, or GND 7
strong1 Strong drive to logic one 6
strong0 Strong drive to logic zero 6
pull1 Medium drive to logic one 5
pull0 Medium drive to logic zero 5
large Large capacitive 4
weak1 Weak drive to logic one 3
weak0 Weak drive to logic zero 3
medium Medium capacitive 2
small Small capacitive 1
highz1 High impedance with weak pull-up to logic one 0
highz0 High impedance with weak pull-down to logic zero 0

When a signal is driven by multiple drivers, it will take on the value of the driver with the highest
strength. If the two drivers have the same strength, the value will be unknown. If the strength is not
specified, it will default to strong drive, or level 6.

2.1.2 Net Data Types

Every signal within Verilog must be associated with a data type. A net data type is one that models
an interconnection (aka, a net) between components and can take on the values 0, 1, X, and Z. A signal
with a net data type must be driven at all times and updates its value when the driver value changes. The
most common synthesizable net data type in Verilog is the wire. The type wire will be used throughout
this text. There are also a variety of other more advanced net data types that model complex digital
systems with multiple drivers for the same net. The syntax and description for all Verilog net data types
are given below.



2.1 Data Types • 15

Type Description

wire A simple connection between components.
wor Wired-OR. If multiple drivers, their values are OR’d together.
wand Wired-AND’d. If multiple drivers, their values are AND’d together.
supply0 Used to model the VSS, (GND), power supply (supply strength inherent).
supply1 Used to model the VCC power supply (supply strength inherent).
tri Identical to wire. Used for readability for a net driven by multiple sources.
trior Identical to wor. Used for readability for nets driven by multiple sources.
triand Identical to wand. Used for readability for nets driven by multiple sources.
tri1 Pulls up to logic one when tri-stated.
tri0 Pulls down to logic zero when tri-stated.
trireg Holds last value when tri-stated (capacitance strength inherent).

Each of these net types can also have an associated drive strength. The strength is used in
determining the final value of the net when it is connected to multiple drivers.

2.1.3 Variable Data Types

Verilog also contains data types that model storage. These are called variable data types. A variable
data type can take on the values 0, 1, X, and Z, but does not have an associated strength. Variable data
types will hold the value assigned to them until their next assignment. The syntax and description for the
Verilog variable data types are given below.

Type Description

reg A variable that models logic storage. Can take on values 0, 1, X, and Z.
integer A 32-bit, 2’s complement variable representing whole numbers between

2,147,483,64810 and +2,147,483,647.
real A 64-bit, floating point variable representing real numbers between –

(2.2  10308)10 and +(2.2  10308)10.
time An unsigned, 64-bit variable taking on values from 010 to +(9.2  1018).
realtime Same as time. Just used for readability.

2.1.4 Vectors

In Verilog, a vector is a one-dimensional array of elements. All of the net data types, in addition to the
variable type reg, can be used to form vectors. The syntax for defining a vector is as follows:

<type> [<MSB_index>:<LSB_index>] vector_name

While any range of indices can be used, it is common practice to have the LSB index start at zero.

Example:

wire [7:0] Sum; // This defines an 8-bit vector called “Sum” of type wire. The
// MSB is given the index 7 while the LSB is given the index 0.

reg [15:0] Q; // This defines a 16-bit vector called “Q” of type reg.

Individual bits within the vector can be addressed using their index. Groups of bits can be accessed
using an index range.

Sum[0]; // This is the least significant bit of the vector “Sum” defined above.
Q[15:8]; // This is the upper 8-bits of the 16-bit vector “Q” defined above.



16 • Chapter 2: Verilog Constructs

2.1.5 Arrays

An array is a multidimensional array of elements. This can also be thought of as a “vector of vectors.”
Vectors within the array all have the same dimensions. To declare an array, the element type and
dimensions are defined first followed by the array name and its dimensions. It is common practice to
place the start index of the array on the left side of the “:”when defining its dimensions. The syntax for the
creation of an array is shown below.

<element_type> [<MSB_index>:<LSB_index>] array_name [<array_start_index>:
<array_end_index>];

Example:

reg[7:0] Mem[0:4095]; // Defines an array of 4096, 8-bit vectors of type reg.
integer A[1:100]; // Defines an array of 100 integers.

When accessing an array, the name of the array is given first, followed by the index of the element. It
is also possible to access an individual bit within an array by adding appending the index of element

Example:

rd
Mem[2]; // This is the 3 element within the array named “Mem”.

// This syntax represents an 8-bit vector of type reg.

rd
Mem[2][7]; // This is the MSB of the 3 element within the array named “Mem”.

// This syntax represents a single bit of type reg.

nd
A[2]; // This is the 2 element within the array named “A”. Recall

// that A was declared with a starting index of 1.
// This syntax represents a 32-bit, signed integer.

2.1.6 Expressing Numbers Using Different Bases

If a number is simply entered into Verilog without identifying syntax, it is treated as an integer.
However, Verilog supports defining numbers in other bases. Verilog also supports an optional bit size
and sign of a number. When defining the value of arrays, the “_” can be inserted between numerals to
improve readability. The “_” is ignored by the Verilog compiler. Values of numbers can be entered in
either upper or lower case (i.e., b or B, f or F). The syntax for specifying the base of a number is as
follows:

<size_in_bits>’<base><value>

Note that specifying the size is optional. If it is omitted, the number will default to a 32-bit vector with
leading zeros added as necessary. The supported bases are as follows:

Syntax Description

‘b Unsigned binary.
‘o Unsigned octal.
‘d Unsigned decimal.
‘h Unsigned hexadecimal.
‘sb Signed binary.
‘so Signed octal.
‘sd Signed decimal.
‘sh Signed hexadecimal.



2.2 Verilog Module Construction • 17

Example:

10 // This is treated as decimal 10, which is a 32-bit signed vector.
4’b1111 // A 4-bit number with the value 11112.
8’b1011_0000 // An 8-bit number with the value 101100002.
8’hFF // An 8-bit number with the value 111111112.
8’hff // An 8-bit number with the value 111111112.
6’hA // A 6-bit number with the value 0010102. Note that leading zeros

// were added to make the value 6-bits.
8’d7 // An 8-bit number with the value 000001112.
32’d0 // A 32-bit number with the value 0000_000016.
‘b1111 // A 32-bit number with the value 0000_000F16.
8’bZ // An 8-bit number with the value ZZZZ_ZZZZ.

2.1.7 Assigning Between Different Types

Verilog is said to be a weakly typed (or loosely typed) language, meaning that it permits assignments
between different data types. This is as opposed to a strongly typed language (such as VHDL) where
signal assignments are only permitted between like types. The reason Verilog permits assignment
between different types is because it treats all of its types as just groups of bits. When assigning between
different types, Verilog will automatically truncate or add leading bits as necessary to make the assign-
ment work. The following examples illustrate how Verilog handles a few assignments between different
types. Assume that a variable called ABC_TB has been declared as type reg[2:0].

Example:

ABC_TB¼ 2’b00; // ABC_TB will be assigned 3’b000. A leading bit is automatically
added.

ABC_TB ¼ 5; // ABC_TB will be assigned 3’b101. The integer is truncated to
3-bits.

ABC_TB ¼ 8; // ABC_TB will be assigned 3’b000. The integer is truncated to
3-bits.

CONCEPT CHECK

CC2.1 The two most commonly used data types in Verilog are wire and reg? What is the
fundamental difference between these types?

(A) They are the same because they can both take on 0, 1, X, or Z.

(B) A wire is a net data type, meaning that it must be driven at all times. A reg is a
variable data type, meaning that it will hold its value after it is assigned.

(C) A wire can only take on values of 0 and 1 while a reg can take on 0, 1, X, or Z.

(D) They cannot drive one other.

2.2 Verilog Module Construction

AVerilog design describes a single system in a single file. The file has the suffix *.v. Within the file,
the system description is contained within a module. The module includes the interface to the system
(i.e., the inputs and outputs) and the description of the behavior. Figure 2.1 shows a graphical depiction
of a Verilog file.



18 • Chapter 2: Verilog Constructs

Fig. 2.1
The anatomy of a Verilog file

2.2.1 The Module

All systems in Verilog are encapsulated inside of a module. Modules can include instantiations of
lower-level modules in order to support hierarchical designs. The keywords module and endmodule
signify the beginning and end of the system description. When working on large designs, it is common
practice to place each module in its own file with the same name.

module module_name (port_list); // Pre Verilog-2001
// port_definitions
// module_items

endmodule

or

module module_name (port_list and port_definitions); // Verilog-2001 and after
// module_items

endmodule

2.2.2 Port Definitions

The first item within a module is its definition of the inputs and outputs, or ports. Each port needs to
have a user-defined name, a direction, and a type. The user-defined port names are case sensitive and
must begin an alphabetic character. The port directions are declared to be one of the three types: input,
output, and inout. A port can take on any of the previously described data types, but only wires,
registers, and integers are synthesizable. Port names with the same type and direction can be listed
on the same line separated by commas.

There are two different port definition styles supported in Verilog. Prior to the Verilog-2001 release,
the port names were listed within parentheses after the module name. Then within the module, the
directionality and type of the ports were listed. Starting with the Verilog-2001 release, the port directions
and types could be included alongside the port names within the parenthesis after the module name.
This approach mimicked more of an ANSCI-C approach to passing inputs/outputs to a system. In this
text, the newer approach to port definition will be used. Example 2.1 shows multiple approaches for
defining a module and its ports.



2.2 Verilog Module Construction • 19

Example 2.1
Declaring Verilog module ports

2.2.3 Signal Declarations

A signal that is used for internal connections within a system is declared within the module before its
first use. Each signal must be declared by listing its type followed by a user-defined name. Signal names
of like type can be declared on the same line separated with a comma. All of the legal data types
described above can be used for signals; however, only types net, reg, and integer will synthesize
directly. The syntax for a signal declaration is as follows:

<type> name;

Example:

wire node1; // declare a signal named “node1” of type wire
reg Q2, Q1, Q0; // declare three signals named “Q2”, “Q1”, and “Q0”, all

of type reg
wire [63:0] bus1; // declare a 64-bit vector named “bus1” with all bits of type

wire
integer i,j; // declare two integers called “i” and “j”

Verilog supports a hierarchical design approach, thus signal names can be the same within a
subsystem as those at a higher level without conflict. Figure 2.2 shows an example of legal signal
naming in a hierarchical design.



20 • Chapter 2: Verilog Constructs

Fig. 2.2
Verilog signals and systems

2.2.4 Parameter Declarations

A parameter, or constant, is useful for representing a quantity that will be used multiple times in the
architecture. The syntax for declaring a parameter is as follows:

parameter <type> constant_name ¼ <value>;

Note that the type is optional and can only be integer, time, real, or realtime. If a type is provided,
the parameter will have the same properties as a variable of the same time. If the type is excluded, the
parameter will take on the type of the value assigned to it.

Example:

parameter BUS_WIDTH ¼ 64;
parameter NICKEL ¼ 8’b0000_0101;

Once declared, the constant name can be used throughout the module. The following example
illustrates how we can use a constant to define the size of a vector. Notice that since we defined the
constant to be the actual width of the vector (i.e., 32-bits), we need to subtract one from its value when
defining the indices (i.e., [31:0]).

Example:

wire [BUS_WIDTH-1:0] BUS_A; // It is acceptable to add a “space” for readability

2.2.5 Compiler Directives

A compiler directive provides additional information to the simulation tool on how to interpret the
Verilog model. A compiler directive is placed before the module definition and is preceded with a backtick
(i.e., `). Note that this is not an apostrophe. A few of the most commonly used compiler directives are as
follows:



Exercise Problems • 21

Syntax Description

`timescale <unit>, <precision> Defines the timescale of the delay unit and its smallest precision.
`include <filename> Includes additional files in the compilation.
`define <macroname> <value> Declares a global constant.

Example:

‘timescale 1ns/1ps // Declares the unit of time is 1 ns with a precision of 1ps.
// The precision is the smallest amount that the time can
// take on. For example, with this directive the number
// 0.001 would be interpreted as 0.001 ns, or 1 ps.
// However, the number 0.0001 would be interpreted as 0 since
// it is smaller than the minimum precision value.

CONCEPT CHECK

CC2.2 If a signal is declared within a module, can the same name be used in other modules
within a hierarchical system?

(A) Yes. To support hierarchy, Verilog signals are only seen within their respective
module. That allows other modules to use the same names.

(B) No. Once a signal name is defined, it cannot be used again.

Summary

v In a Verilog source file, all functionality is v Instantiating other modules from within a
contained within a module. The first portion higher-level module is how Verilog
of the module is the port definition. The sec- implements hierarchy. A lower-level module
ond portion contains declarations of internal can be instantiated as many times as
signals/constants/parameters. The third por- desired. An instance identifier is useful is
tion contains the description of the behavior. keeping track of each instantiation. The

v A port is an input or output to a system that is ports of the component can be connected
defined as part of the initial module state- using either explicit or positional port
ment. A signal, or net, is an internal connec- mapping.
tion within the system that is declared inside
of the module. A signal is not visible outside
of the system.

Exercise Problems

Section 2.1: Data Types 2.1.5 What is the highest strength that a value can
take on in Verilog.

2.1.1 What is the name of the main design unit in
Verilog? 2.1.6 What is the range of decimal numbers that can

be represented using the type integer in
2.1.2 What portion of the Verilog module describes

Verilog?
the inputs and outputs.

2.1.7 What is the width of the vector defined using
2.1.3 What step is necessary if a system requires

the type [63:0] wire?
internal connections?

2.1.8 What is the syntax for indexing the most signif-
2.1.4 What are all the possible values that a Verilog

icant bit in the type [31:0] wire? Assume the
net type can take on?

vector is named example.



22 • Chapter 2: Verilog Constructs

2.1.9 What is the syntax for indexing the least signif- Section 2.2: Verilog Module Construction
icant bit in the type [31:0] wire? Assume the

2.2.1 What three directions can a module port take
vector is named example.

on?
2.1.10 What is the difference between a wire and reg

2.2.2 What data types can a signal take on within a
type?

module?
2.1.11 How many bits is the type integer by default?

2.2.3 What data types can a parameter take on
2.1.12 How many bits is the type real by default? within a module?

2.2.4 What is the purpose of a compiler directive?



Chapter 3: Modeling Concurrent
Functionality in Verilog

This chapter presents a set of built-in operators that will allow basic logic expressions to be modeled
within a Verilog module. This chapter then presents a series of combinational logic model examples.

Learning Outcomes—After completing this chapter, you will be able to:

3.1 Describe the various built-in operators within Verilog.
3.2 Design a Verilog model for a combinational logic circuit using continuous assignment and

logical operators.
3.3 Design a Verilog model for a combinational logic circuit using continuous assignment and

conditional operators.
3.4 Design a Verilog model for a combinational logic circuit using continuous assignment with

delay.

3.1 Verilog Operators

There are a variety of predefined operators in the Verilog standard. It is important to note that
operators are defined to work on specific data types and that not all operators are synthesizable.

3.1.1 Assignment Operator

Verilog uses the equal sign (¼) to denote an assignment. The left-hand side (LHS) of the assign-
ment is the target signal. The right-hand side (RHS) contains the input arguments and can contain both
signals, constants, and operators.

Example:

F1 ¼ A; // F1 is assigned the signal A
F2 ¼ 8’hAA; // F2 is an 8-bit vector and is assigned the value 101010102

3.1.2 Continuous Assignment

Verilog uses the keyword assign to denote a continuous signal assignment. After this keyword, an
assignment is made using the ¼ symbol. The left-hand side (LHS) of the assignment is the target signal
and must be a net type. The right-hand side (RHS) contains the input arguments and can contain nets,
regs, constants, and operators. A continuous assignment models combinational logic. Any change to the
RHS of the expression will result in an update to the LHS target net. The net being assigned to must be
declared prior to the first continuous assignment. Multiple continuous assignments can be made to the
same net. When this happens, the assignment containing signals with the highest drive strength will take
priority.

Example:

assign F1 ¼ A; // F1 is updated anytime A changes, where A is a signal
assign F2 ¼ 1’b0; // F2 is assigned the value 0
assign F3 ¼ 4’hAA; // F3 is an 8-bit vector and is assigned the value 101010102

Each individual assignment will be executed concurrently and synthesized as separate logic
circuits. Consider the following example.

# Springer Nature Switzerland AG 2019 23
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5_3



24 • Chapter 3: Modeling Concurrent Functionality in Verilog

Example:

assign X ¼ A;
assign Y ¼ B;
assign Z ¼ C;

When simulated, these three lines of Verilog will make three separate signal assignments at the
exact same time. This is different from a programming language that will first assign A to X, then B to Y,
and finally C to Z. In Verilog this functionality is identical to three separate wires. This description will be
directly synthesized into three separate wires.

Below is another example of how continuous signal assignments in Verilog differ from a sequentially
executed programming language.

Example:

assign A ¼ B;
assign B ¼ C;

In a Verilog simulation, the signal assignments of C to B and B to A will take place at the same time.
This means during synthesis, the signal B will be eliminated from the design since this functionality
describes two wires in series. Automated synthesis tools will eliminate this unnecessary signal name.
This is not the same functionality that would result if this example was implemented as a sequentially
executed computer program. A computer program would execute the assignment of B to A first, then
assign the value of C to B second. In this way, B represents a storage element that is passed to A before
it is updated with C.

3.1.3 Bitwise Logical Operators

Bitwise operators perform logic functions on individual bits. The inputs to the operation are single
bits and the output is a single bit. In the case where the inputs are vectors, each bit in the first vector is
operated on by the bit in the same position from the second vector. If the vectors are not the same length,
the shorter vector is padded with leading zeros to make both lengths equal. Verilog contains the following
bitwise operators:

Syntax Operation

~ Negation
& AND
| OR
^ XOR
~^ or ^~ XNOR
<< Logical shift left (fill empty LSB location with zero)
>> Logical shift right (fill empty MSB location with zero)

Example:

~X // invert each bit in X
X & Y // AND each bit of X with each bit of Y
X | Y // OR each bit of X with each bit of Y
X ^ Y // XOR each bit of X with each bit of Y
X ~^ Y // XNOR each bit of X with each bit of Y
X << 3 // Shift X left 3 times and fill with zeros
Y >> 2 // Shift Y right 2 times and fill with zeros



3.1 Verilog Operators • 25

3.1.4 Reduction Logic Operators

A reduction operator is one that uses each bit of a vector as individual inputs into a logic operation
and produces a single-bit output. Verilog contains the following reduction logic operators.

Syntax Operation

& AND all bits in the vector together (1-bit result)
~& NAND all bits in the vector together (1-bit result)
| OR all bits in the vector together (1-bit result)
~| NOR all bits in the vector together (1-bit result)
^ XOR all bits in the vector together (1-bit result)
~^ or ^~ XNOR all bits in the vector together (1-bit result)

Example:

&X // AND all bits in vector X together
~&X // NAND all bits in vector X together
|X // OR all bits in vector X together
~|X // NOR all bits in vector X together
^X // XOR all bits in vector X together
~^X // XNOR all bits in vector X together

3.1.5 Boolean Logic Operators

A Boolean logic operator is one that returns a value of TRUE (1) or FALSE (0) based on a logic
operation of the input operations. These operations are used in decision statements.

Syntax Operation

! Negation
&& AND
|| OR

Example:

!X // TRUE if all values in X are 0, FALSE otherwise
X && Y // TRUE if the bitwise AND of X and Y results in all ones, FALSE otherwise
X || Y // TRUE if the bitwise OR of X and Y results in all ones, FALSE otherwise

3.1.6 Relational Operators

A relational operator is one that returns a value of TRUE (1) or FALSE (0) based on a comparison of
two inputs.

Syntax Description

¼¼ Equality
!¼ Inequality
< Less than
> Greater than
<¼ Less than or equal
>¼ Greater than or equal



26 • Chapter 3: Modeling Concurrent Functionality in Verilog

Example:

X ¼¼ Y // TRUE if X is equal to Y, FALSE otherwise
X !¼ Y // TRUE if X is not equal to Y, FALSE otherwise
X < Y // TRUE if X is less than Y, FALSE otherwise
X > Y // TRUE if X is greater than Y, FALSE otherwise
X <¼ Y // TRUE if X is less than or equal to Y, FALSE otherwise
X >¼ Y // TRUE if X is greater than or equal to Y, FALSE otherwise

3.1.7 Conditional Operators

Verilog contains a conditional operator that can be used to provide a more intuitive approach to
modeling logic statements. The keyword for the conditional operator is ? with the following syntax:

<target_net> ¼ <Boolean_condition> ? <true_assignment> : <false_assignment>;

This operator specifies a Boolean condition in which if evaluated TRUE, the true_assignment will be
assigned to the target. If the Boolean condition is evaluated FALSE, the false_assignment portion of the
operator will be assigned to the target. The values in this assignment can be signals or logic values. The
Boolean condition can be any combination of the Boolean operators described above. Nested condi-
tional operators can also be implemented by inserting subsequent conditional operators in place of the
false_value.

Example:

F ¼ (A ¼¼ 1’b0) ? 1’b1 : 1’b0; // If A is a zero, F¼1, otherwise F¼0.
This models an inverter.

F ¼ (sel ¼¼ 1’b0) ? A : B; // If sel is a zero, F¼A, otherwise F¼B.
This models a selectable switch.

F ¼ ((A ¼¼ 1’b0) && (B ¼¼ 1’b0)) ? 1’b’0 : // Nested conditional statements.
((A ¼¼ 1’b0) && (B ¼¼ 1’b1)) ? 1’b’1 : // This models an XOR gate.
((A ¼¼ 1’b1) && (B ¼¼ 1’b0)) ? 1’b’1 :
((A ¼¼ 1’b1) && (B ¼¼ 1’b1)) ? 1’b’0;

F ¼ ( !C && (!A || B) ) ? 1’b1 : 1’b0; // This models the logic expression
// F ¼ C’(A’+B).

3.1.8 Concatenation Operator

In Verilog, the curly brackets (i.e., {}) are used to concatenate multiple signals. The target of this
operation must be the same size of the sum of the sizes of the input arguments.

Example:

Bus1[7:0] ¼ {Bus2[7:4], Bus3[3:0]}; // Assuming Bus1, Bus2, and Bus3 are all 8-bit
// vectors, this operation takes the upper

4-bits of
// Bus2, concatenates them with the lower

4-bits of
// Bus3, and assigns the 8-bit combination

to Bus1.

BusC ¼ {BusA, BusB}; // If BusA and BusB are 4-bits, then BusC
// must be 8-bits.

BusC[7:0] ¼ {4’b0000, BusA}; // This pads the 4-bit vector BusA with
4x leading

// zeros and assigns to the 8-bit vector BusC.



3.1 Verilog Operators • 27

3.1.9 Replication Operator

Verilog provides the ability to concatenate a vector with itself through the replication operator. This
operator uses double curly brackets (i.e., {{}}) and an integer indicating the number of replications to be
performed. The replication syntax is as follows:

{<number_of_replications>{<vector_name_to_be_replicated>}}

Example:

BusX¼ {4{Bus1}}; // This is equivalent to: BusX¼ {Bus1, Bus1, Bus1, Bus1};
BusY ¼ {2{A,B}}; // This is equivalent to: BusY ¼ {A, B, A, B};
BusZ ¼ {Bus1, {2{Bus2}}}; // This is equivalent to: BusZ ¼ {Bus1, Bus2, Bus2};

3.1.10 Numerical Operators

Verilog also provides a set of numerical operators as follows:

Syntax Operation

+ Addition
 Subtraction (when placed between arguments)
 2’s complement negation (when placed in front of an argument)
* Multiplication
/ Division
% Modulus
** Raise to the power
<<< Shift to the left, fill with zeros
<<< Shift to the right, fill with sign bit

Example:

X + Y // Add X to Y
X - Y // Subtract Y from X
-X // Take the two’s complement negation of X
X * Y // Multiply X by Y
X / Y // Divide X by Y
X % Y // Modulus X/Y
X ** Y // Raise X to the power of Y
X <<< 3 // Shift X left 3 times, fill with zeros
X >>> 2 // Shift X right 2 times, fill with sign bit

Verilog will allow the use of these operators on arguments of different sizes, types, and signs. The
rules of the operations are as follows:

• If two vectors are of different sizes, the smaller vector is expanded to the size of the larger
vector.
– If the smaller vector is unsigned, it is padded with zeros.
– If the smaller vector is signed, it is padded with the sign bit.

• If one of the arguments is real, then the arithmetic will take place using real numbers.

• If one of the arguments is unsigned, then all arguments will be treated as unsigned.

Example 3.1 shows the behavioral model for a 4-bit adder in Verilog using a combination of
operators including continuous assignment, numerical addition, and concatenation. Note that when
adding two n-bit arguments the sum produced will be n + 1 bits. This can be handled in Verilog by
concatenating the Cout and Sum outputs on the LHS of the assignment. The entire add operation can be



28 • Chapter 3: Modeling Concurrent Functionality in Verilog

accomplished in a single continuous assignment that contains both the concatenation and addition
operators. When using continuous assignment, the LHSmust be a net data type. This means the outputs
Cout and Sum need to be declared as type wire.

Example 3.1
Behavioral model of a 4-bit adder in Verilog

3.1.11 Operator Precedence

The following is the order of precedence of the Verilog operators. If two operators of the same type
appear in an expression without parenthesis to dictate the order of precedence, the precedence will be
determined by executing from the operations from left to right.

Operators Precedence Notes

! ~ +  Highest Bitwise/Unary
{} {{}} Concatenation/Replication
() # No operation, just parenthesis
** Power
* / % Binary Multiply/Divide/Modulo
+  # Binary Addition/Subtraction
<< >> <<< >>> Shift Operators
< <¼ > >¼ Greater/Less than Comparisons
¼¼ !¼ # Equality/Inequality Comparisons
& ~& AND/NAND Operators
^ ~^ XOR/XNOR Operators
| ~| # OR/NOR Operators
&& Boolean AND
|| Boolean OR
?: Lowest Conditional Operator



3.2 Continuous Assignment with Logical Operators • 29

CONCEPT CHECK

CC3.1 For the expression: F ¼ !A & (B I !C); What is the order of execution of the bitwise
operations?

(A) Negate ! OR ! AND

(B) Negate ! AND ! OR

(C) OR ! Negate ! AND

(D) OR ! AND ! Negate

3.2 Continuous Assignment with Logical Operators

When modeling synthesizable logic, it is important to remember that Verilog is a hardware descrip-
tion language, not a programming language. In a programming language, the lines of code are executed
sequentially as they appear in the source file. In Verilog, the lines of code represent the behavior of real
hardware. Thus, the assignments are executed concurrently unless specifically noted otherwise. Each of
the bitwise logical operators described in Sect. 3.1.3 can be used in conjunction with continuous signal
assignments to create individual combinational logic circuits.

3.2.1 Logical Operator Example: SOP Circuit

Example 3.2 shows how to design a Verilog model of a combinational logic circuit using continuous
assignment and logical operators. Note that in this example the logic expressions must first be deter-
mined by hand prior to modeling in Verilog.



30 • Chapter 3: Modeling Concurrent Functionality in Verilog

Example 3.2
Combinational logic using continuous assignment with logical operators

3.2.2 Logical Operator Example: One-Hot Decoder

A one-hot decoder is a circuit that has n inputs and 2n outputs. Each output will assert for one and
only one input code. Since there are 2n outputs, there will always be one and only one output asserted at
any given time. Example 3.3 shows how to model a 3-to-8 one-hot decoder in Verilog with continuous
assignment and logic operators.



3.2 Continuous Assignment with Logical Operators • 31

Example 3.3
3-to-8 One-hot decoder—Verilog modeling using logical operators

3.2.3 Logical Operator Example: 7-Segment Display Decoder

A 7-segment display decoder is a circuit used to drive character displays that are commonly found in
applications such as digital clocks and household appliances. A character display is made up of seven
individual LEDs, typically labeled a–g. The input to the decoder is the binary equivalent of the decimal or
Hex character that is to be displayed. The output of the decoder is the arrangement of LEDs that will form
the character. Decoders with 2-inputs can drive characters “0” to “3.” Decoders with 3-inputs can drive
characters “0” to “7.” Decoders with 4-inputs can drive characters “0” to “F” with the case of the Hex
characters being “A, b, c or C, d, E and F.”

Let’s look at an example of how to design a 3-input, 7-segment decoder in Verilog. The first step in
the process is to create the truth table for the outputs that will drive the LEDs in the display. We’ll call
these outputs Fa, Fb, . . ., Fg. Example 3.4 shows how to construct the truth table for the 7-segment
display decoder. In this table, a logic 1 corresponds to the LED being ON.



32 • Chapter 3: Modeling Concurrent Functionality in Verilog

Example 3.4
7-Segment display decoder—truth table

If we wish to model this decoder using logical operators, we need to first create the seven separate
combinational logic expressions for each output. Each of the outputs (Fa – Fg) can be put into a 3-input
K-map to find the minimized logic expression. Example 3.5 shows the derivation of the logic expressions
for the decoder from the truth table in Example 3.4 using Karnaugh maps.



3.2 Continuous Assignment with Logical Operators • 33

Example 3.5
7-Segment display decoder—logic synthesis by hand

Now these seven logic expressions can be modeled in Verilog. Example 3.6 shows how to model
the 7-segment decoder in Verilog using continuous assignment with logic operators.



34 • Chapter 3: Modeling Concurrent Functionality in Verilog

Example 3.6
7-Segment display decoder—Verilog modeling using logical operators

3.2.4 Logical Operator Example: One-Hot Encoder

A one-hot binary encoder has n outputs and 2n inputs. The output will be an n-bit, binary code which
corresponds to an assertion on one and only one of the inputs. Example 3.7 shows the process of
designing a 4-to-2 binary encoder by hand (i.e., using the classical digital design approach) in order to
find the logic expression to model in Verilog using logical operators.



3.2 Continuous Assignment with Logical Operators • 35

Example 3.7
4-to-2 Binary encoder—logic synthesis by hand

Example 3.8 shows how to model the encoder with continuous assignments and logical operators
using the logic expressions from Example 3.7.

Example 3.8
4-to-2 Binary encoder—Verilog modeling using logical operators



36 • Chapter 3: Modeling Concurrent Functionality in Verilog

3.2.5 Logical Operator Example: Multiplexer

A multiplexer is a circuit that passes one of its multiple inputs to a single output based on a select
input. This can be thought of as a digital switch. The multiplexer has n select lines, 2n inputs, and
1 output. Example 3.9 shows the process of modeling a 4-to-1 multiplexer using continuous signal
assignments and logical operators.

Example 3.9
4-to-1 Multiplexer—Verilog modeling using logical operators

3.2.6 Logical Operator Example: Demultiplexer

A demultiplexer works in a complementary fashion to a multiplexer. A demultiplexer has one input
that is routed to one of its multiple outputs. The output that is active is dictated by a select input. A demux
has n select lines that chooses to route the input to one of its 2n outputs. When an output is not selected,
it outputs a logic 0. Example 3.10 shows how to model the demultiplexer in Verilog using continuous
assignments and logical operators.



3.3 Continuous Assignment with Conditional Operators • 37

Example 3.10
1-to-4 Demultiplexer—Verilog modeling using logical operators

CONCEPT CHECK

CC3.2 Why does modeling combinational logic in its canonical form with continuous assign-
ment and logical operators defeat the purpose of the modern digital design flow?

(A) It requires the designer to first create the circuit using the classical digital
design approach and then enter it into the HDL in a form that is essentially a
text-based netlist. This doesn’t take advantage of the abstraction capabilities
and automated synthesis in the modern flow.

(B) It cannot be synthesized because the order of precedence of the logical
operators in Verilog doesn’t match the precedence defined in Boolean algebra.

(C) The circuit is in its simplest form, so there is no work for the synthesizer to do.

(D) It doesn’t allow an else clause to cover the outputs for any remaining input
codes not explicitly listed.

3.3 Continuous Assignment with Conditional Operators

Logical operators are good for describing the behavior of small circuits; however, in the prior examples
we still needed to create the canonical sum of products logic expression by hand before describing the
functionality with logical operators. The true power of an HDL is when the behavior of the system can be



38 • Chapter 3: Modeling Concurrent Functionality in Verilog

described fully without requiring any hand design. The conditional operator allows us to describe a
continuous assignment using Boolean conditions that effect the values of the result. In this approach, we
use the conditional operator (?) in conjunction with the continuous assignment keyword assign.

3.3.1 Conditional Operator Example: SOP Circuit

Example 3.11 shows how to design a Verilog model of a combinational logic circuit using continuous
assignment with conditional operators. Note that this example uses the same truth table as in Example
3.2 to illustrate a comparison between approaches.

Example 3.11
Combinational logic using continuous assignment with conditional operators (1)

In the prior example, the conditional operator was based on a truth table. Conditional operators can
also be used to model logic expressions. Example 3.12 shows how to design a Verilog model of a
combinational logic circuit when the logic expression is already known. Note that this example again
uses the same truth table as in Examples 3.2 and 3.11 to illustrate a comparison between approaches.



3.3 Continuous Assignment with Conditional Operators • 39

Example 3.12
Combinational logic using continuous assignment with conditional operators (2)

3.3.2 Conditional Operator Example: One-Hot Decoder

Example 3.13 shows how to model the 3-to-8 one-hot decoder in Verilog using continuous assign-
ment with conditional operators. This description of a one-hot decoder can be simplified by using vector
notation for the ports.

Example 3.13
3-to-8 One-hot decoder—Verilog modeling using conditional operators



40 • Chapter 3: Modeling Concurrent Functionality in Verilog

3.3.3 Conditional Operator Example: 7-Segment Display Decoder

Example 3.14 shows how to model the 7-segment decoder in Verilog using continuous assignment
with conditional operators. Again, a more compact description of the decoder can be accomplished if the
ports are described as vectors.

Example 3.14
7-Segment display decoder—Verilog modeling using conditional operators

3.3.4 Conditional Operator Example: One-Hot Decoder

Example 3.15 shows how to model the encoder with continuous assignments and conditional
operators. Notice that using this approach does not require synthesizing the logic expressions by
hand but rather can model the functionality directly from the truth table.



3.3 Continuous Assignment with Conditional Operators • 41

Example 3.15
4-to-2 Binary encoder—Verilog modeling using conditional operators

3.3.5 Conditional Operator Example: Multiplexer

Example 3.16 shows the process of modeling a 4-to-1 multiplexer using continuous signal
assignments and conditional operators. Notice that this approach can also be implemented directly
from the truth table.

Example 3.16
4-to-1 Multiplexer—Verilog modeling using conditional operators



42 • Chapter 3: Modeling Concurrent Functionality in Verilog

3.3.6 Conditional Operator Example: Demultiplexer

Example 3.17 shows how to model the demultiplexer in Verilog using continuous assignments and
conditional operators. Notice that this approach can be implemented directly from the truth table as well.

Example 3.17
1-to-4 Demultiplexer—Verilog modeling using conditional operators

CONCEPT CHECK

CC3.3 Why does a continuous signal assignment with conditional operators better reflect the
modern digital design flow compared to using logical operators?

(A) It allows the logic to be modeled directly from its functional description as
opposed to from the final logic expressions, which must be determined prior to
HDL modeling. This allows the continuous signal assignment approach to
take advantage of automated synthesis and avoids any hand design.

(B) A conditional operator has a final clause that covers any input cases not
explicitly listed. This makes it more like a programming language operator.

(C) A conditional operator has a final clause that covers any input cases not
explicitly listed. This allows a final assignment of “X,” which provides the
ability to assign any outputs not explicitly listed to be treated as “unknowns”.

(D) The conditional operators can model the entire logic circuit in one assignment
while the logical operator approach often takes multiple separate
assignments.



3.4 Continuous Assignment with Delay • 43

3.4 Continuous Assignment with Delay

Verilog provides the ability to model gate delays when using a continuous assignment. The # is used
to indicate a delayed assignment. For combinational logic circuits, the delay can be specified for all
transitions, for rising and falling transitions separately, and for rising, falling, and transitions to the value
off separately. A transition to off refers to a transition to Z. If only one delay parameter is specified, it is
used to model all delays. If two delay parameters are specified, the first parameter is used for the rise
time delay while the second is used to model the fall time delay. If three parameters are specified, the
third parameter is used to model the transition to off. Parenthesis are optional but recommended when
using multiple delay parameters.

assign #(<del_all>) <target_net> ¼ <RHS_nets, operators,
etc. . .>;

assign #(<del_rise, del_fall>) <target_net> ¼ <RHS_nets, operators,
etc. . .>;

assign #(<del_rise, del_fall, del_off>) <target_net> ¼ <RHS_nets, operators,
etc. . .>;

Example:

assign #1 F ¼ A; // Delay of 1 on all transitions.
assign #(2,3) F ¼ A; // Delay of 2 for rising transitions and 3 for falling.
assign #(2,3,4) F ¼ A; // Delay of 2 for rising, 3 for falling, and 4 for

off transition.

When using delay, it is typical to include the `timescale directive to provide the units of the delay
being specified. Example 3.18 shows a graphical depiction of using delay with continuous assignments
when modeling combinational logic circuits.



44 • Chapter 3: Modeling Concurrent Functionality in Verilog

Example 3.18
Modeling delay in continuous assignments

Verilog also provides a mechanism to model a range of delays that are selected by a switch set in
the CAD compiler. There are three delays categories that can be specified: minimum, typical, and
maximum. The delays are separated by a “:”. The following is the syntax of how to use the delay
range capability.

assign #(<min>:<typ>:<max>) <target_net> ¼ <RHS_nets, operators, etc. . .>;



3.4 Continuous Assignment with Delay • 45

Example:

assign #(1:2:3) F ¼ A; // Specifying a range of delays for all
transitions.

assign #(1:1:2, 2:2:3) F ¼ A; // Specifying a range of delays for
rising/falling.

assign #(1:1:2, 2:2:3, 4:4:5) F ¼ A; // Specifying a range of delays for
each transition.

The delay modeling capability in continuous assignment is designed to model the behavior of real
combinational logic with respect to short duration pulses. When a pulse is shorter than the delay of the
combinational logic gate, the pulse is ignored. Ignoring brief input pulses on the input accurately models
the behavior of on-chip gates. When the input pulse is faster than the delay of the gate, the output of the
gate does not have time to respond. As a result, there will not be a logic change on the output. This is
called inertial delay modeling and is the default behavior when using continuous assignments. Example
3.19 shows a graphical depiction of inertial delay behavior in Verilog.

Example 3.19
Inertial delay modeling when using continuous assignment

CONCEPT CHECK

CC3.4 Can a delayed signal assignment impact multiple continuous signal assignments?

(A) Yes. If a signal assignment with delay is made to a signal that is also used as
an input in a separate continuous signal assignment, then the delay will
propagate through both assignments.

(B) No. Only the assignment in which the delay is used will experience the delay.



46 • Chapter 3: Modeling Concurrent Functionality in Verilog

Summary

v Concurrency is the term that describes v Delay can also be included in continuous
operations being performed in parallel. This assignments.
allows real-world system behavior to be v Verilog supports a variety of delay models
modeled. including delay for all transitions, separate

v Verilog provides the continuous assignment delay for rising and falling transitions, sepa-
operator to support modeling concurrent rate delay for rising, falling, and transitions to
combinational logic operations. off, and finally support for a min:typ:max

v Complex logic circuits can be implemented delay that is selected by a compiler switch.
by using continuous assignment with logical
operators or conditional operators.

Exercise Problems

Section 3.1: Verilog Operators 3.2.2 Design a Verilog model to implement the
behavior described by the 3-input maxterm

3.1.1 What is the purpose of the continuous assign-
list shown in Fig. 3.2. Use continuous assign-

ment operator?
ment with logical operators. Declare your mod-

3.1.2 If two continuous assignments are made to the ule and ports to match the block diagram
same net, which one will take priority? provided. Use the type wire for your ports.

3.1.3 What is the difference between a bitwise logi-
cal AND (&) operation and a reduction AND (&)
operation?

3.1.4 How is a conditional operator (?) similar to an
if/then programming construct?

3.1.5 How many bits will the target vector F need to
be if the following concatenation assignment is
made? Fig. 3.2

F ¼ {4'hA, 2'b00}; System F Functionality

3.1.6 How many bits will the target vector F need to 3.2.3 Design a Verilog model to implement the
be if the following replication assignment is behavior described by the 3-input truth table
made? shown in Fig. 3.3. Use continuous assignment
F ¼ {3{4'hA}}; with logical operators. Declare your module

and ports to match the block diagram provided.
3.1.7 When adding two unsigned vectors of different

Use the type wire for your ports.
sizes using the + numerical operator, what
happens to the smaller vector prior to the
addition?

3.1.8 What operation has the highest precedence
operation in Verilog?

Section 3.2: Continuous Assignment
with Logical Operators
3.2.1 Design a Verilog model to implement the

behavior described by the 3-input minterm list
shown in Fig. 3.1. Use continuous assignment
with logical operators. Declare your module
and ports to match the block diagram provided.
Use the type wire for your ports. Fig. 3.3

System G Functionality

3.2.4 Design a Verilog model to implement the
behavior described by the 4-input minterm list
shown in Fig. 3.4. Use continuous assignment
and logical operators. Declare your module
and ports to match the block diagram provided.
Use the type wire for your ports.

Fig. 3.1
System E Functionality



Exercise Problems • 47

your module and ports to match the block dia-
gram provided.

Fig. 3.4
System I Functionality

3.2.5 Design a Verilog model to implement the
behavior described by the 4-input maxterm
list shown in Fig. 3.5. Use continuous assign-
ment and logical operators. Declare your mod-
ule and ports to match the block diagram
provided. Use the type wire for your ports.

Fig. 3.5
System J Functionality

3.2.6 Design a Verilog model to implement the
behavior described by the 4-input truth table Fig. 3.7
shown in Fig. 3.6. Use continuous assignment 4-to-16 One-Hot Decoder Functionality
and logical operators. Declare your module
and ports to match the block diagram provided. 3.2.8 Design a Verilog model for the 8-to-3 one-hot
Use the type wire for your ports. encoder shown in Fig. 3.8. Use continuous

assignment and logical operators. Declare
your module and ports to match the block dia-
gram provided.

Fig. 3.6
System K Functionality

3.2.7 Design a Verilog model for the 4-to-16 one-hot Fig. 3.8
decoder shown in Fig. 3.7. Use continuous 8-to-3 One-Hot Encoder Functionality
assignment and logical operators. Declare



48 • Chapter 3: Modeling Concurrent Functionality in Verilog

3.2.9 Design a Verilog model for the 8-to-1 multi- module and ports to match the block diagram
plexer shown in Fig. 3.9. Use continuous provided. Use the type wire for your ports.
assignment and logical operators. Declare 3.3.2 Design a Verilog model to implement the
your module and ports to match the block behavior described by the 3-input maxterm
diagram provided. list shown in Fig. 3.2. Use continuous assign-

ment with conditional operators. Declare your
module and ports to match the block diagram
provided. Use the type wire for your ports.

3.3.3 Design a Verilog model to implement the
behavior described by the 3-input truth table
shown in Fig. 3.3. Use continuous assignment
with conditional operators. Declare your mod-
ule and ports to match the block diagram
provided. Use the type wire for your ports.

3.3.4 Design a Verilog model to implement the
behavior described by the 4-input minterm list
shown in Fig. 3.4. Use continuous assignment
and conditional operators. Declare your mod-
ule and ports to match the block diagram
provided. Use the type wire for your ports.

3.3.5 Design a Verilog model to implement the
behavior described by the 4-input maxterm
list shown in Fig. 3.5. Use continuous assign-
ment and conditional operators. Declare your
module and ports to match the block diagram
provided. Use the type wire for your ports.

3.3.6 Design a Verilog model to implement the
Fig. 3.9

behavior described by the 4-input truth table
8-to-1 Multiplexer Functionality shown in Fig. 3.6. Use continuous assignment

and conditional operators. Declare your mod-
3.2.10 Design a Verilog model for the 1-to-8 demulti- ule and ports to match the block diagram

plexer shown in Fig. 3.10. Use continuous provided. Use the type wire for your ports.
assignment and logical operators. Declare
your module and ports to match the block dia- 3.3.7 Design a Verilog model for the 4-to-16 one-hot

gram provided. decoder shown in Fig. 3.7. Use continuous
assignment and logical operators. Declare
your module and ports to match the block dia-
gram provided.

3.3.8 Design a Verilog model for the 8-to-3 one-hot
encoder shown in Fig. 3.8. Use continuous
assignment and logical operators. Declare
your module and ports to match the block dia-
gram provided.

3.3.9 Design a Verilog model for the 8-to-1 multi-
plexer shown in Fig. 3.9. Use continuous
assignment and logical operators. Declare
your module and ports to match the block dia-
gram provided.

3.3.10 Design a Verilog model for the 1-to-8 demulti-
plexer shown in Fig. 3.10. Use continuous

Fig. 3.10 assignment and logical operators. Declare
1-to-8 Demultiplexer Functionality your module and ports to match the block dia-

gram provided.

Section 3.3: Continuous Assignment with Section 3.4: Continuous Assignment
Conditional Operators with Delay
3.3.1 Design a Verilog model to implement the 3.4.1 Design a Verilog model to implement the

behavior described by the 3-input minterm list behavior described by the 3-input minterm list
shown in Fig. 3.1. Use continuous assignment shown in Fig. 3.1. Use continuous assignment
with conditional operators. Declare your with logical operators and give each logic oper-

ation 1 ns of delay. Declare your module and



Exercise Problems • 49

ports to match the block diagram provided. Use a delay of 2 ns. Declare your module and ports
the type wire for your ports. to match the block diagram provided. Use the

3.4.2 Design a Verilog model to implement the type wire for your ports.

behavior described by the 3-input maxterm 3.4.5 Design a Verilog model to implement the
list shown in Fig. 3.2. Use continuous assign- behavior described by the 4-input maxterm
ment with logical operators and give each list shown in Fig. 3.5. Use continuous assign-
rising transition a delay of 1 ns and each falling ment and logical operators and give each logic
transition a delay of 2 ns. Declare your module operation a delay of 1, 2, and 3 ns, respec-
and ports to match the block diagram provided. tively, for the operation’s min:typ:max behavior.
Use the type wire for your ports. Declare your module and ports to match the

3.4.3 Design a Verilog model to implement the block diagram provided. Use the type wire for

behavior described by the 3-input truth table your ports.

shown in Fig. 3.3. Use continuous assignment 3.4.6 Design a Verilog model to implement the
with conditional operators and give the entire behavior described by the 4-input truth table
logic operation a delay of 3 ns. Declare your shown in Fig. 3.6. Use continuous assignment
module and ports to match the block diagram and conditional operators and give the entire
provided. Use the type wire for your ports. operation a delay of 1, 2, and 3 ns, respec-

3.4.4 Design a Verilog model to implement the tively, for the operation’s min:typ:max behavior.

behavior described by the 4-input minterm list Declare your module and ports to match the

shown in Fig. 3.4. Use continuous assignment block diagram provided. Use the type wire for

with conditional operators and give rising your ports.

transitions a delay of 3 ns and falling transitions



Chapter 4: Structural Design
and Hierarchy

This chapter describes how to accomplish hierarchy within Verilog using lower-level subsystems.
Structural design in Verilog refers to including lower-level subsystems within a higher-level module in
order to produce the desired functionality. This is called hierarchy and is a good design practice because
it enables design partitioning. A purely structural design will not contain any behavioral constructs in the
module such as signal assignments, but instead just contain the instantiation and interconnections of
other subsystems. A subsystem in Verilog is simply another module that is called by a higher-level
module. Each lower-level module that is called is executed concurrently by the calling module.

Learning Outcomes—After completing this chapter, you will be able to:

4.1 Instantiate and map the ports of a lower-level component in Verilog.
4.2 Design a Verilog model for a system that uses hierarchy.

4.1 Structural Design Constructs

4.1.1 Lower-Level Module Instantiation

The term instantiation refers to the use or inclusion of a lower-level module within a system. In
Verilog, the syntax for instantiating a lower-level module is as follows.

module_name <instance_identifier> (port mapping. . .);

The first portion of the instantiation is the module name that is being called. This must match the
lower-level module name exactly, including case. The second portion of the instantiation is an optional
instance identifier. Instance identifier are useful when instantiating multiple instances of the same lower-
level module. The final portion of the instantiation is the port mapping. There are two techniques to
connect signals to the ports of the lower-level module, explicit and positional.

4.1.2 Port Mapping

4.1.2.1 Explicit Port Mapping

In explicit port mapping the names of the ports of the lower-level subsystem are provided along with
the signals they are being connected to. The lower-level port name is preceded with a period (.) while the
signal it is being connected is enclosed within parenthesis. The port connections can be listed in any
order since the details of the connection (i.e., port name to signal name) are explicit. Each connection is
separated by a comma. The syntax for explicit port mapping is as follows:

module_name <instance identifier> (.port_name1(signal1), .port_name2(signal2),
etc.);

Example 4.1 shows how to design a Verilog model of a hierarchical system that consists of two
lower-level modules.

# Springer Nature Switzerland AG 2019 51
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5_4



52 • Chapter 4: Structural Design and Hierarchy

Example 4.1
Verilog structural design using explicit port mapping

4.1.2.2 Positional Port Mapping

In positional port mapping the names of the ports of the lower-level modules are not explicitly listed.
Instead, the signals to be connected to the lower-level system are listed in the same order in which the
ports were defined in the subsystem. Each signal name is separated by a comma. This approach
requires less text to describe the connection but can also lead to misconnections due to inadvertent
mistakes in the signal order. The syntax for positional port mapping is as follows:

module_name : <instance_identifier> (signal1, signal2, etc.);

Example 4.2 shows how to create the same structural Verilog model as in Example 4.1, but using
positional port mapping instead.



4.1 Structural Design Constructs • 53

Example 4.2
Verilog structural design using positional port mapping

4.1.3 Gate-Level Primitives

Verilog provides the ability to model basic logic functionality through the use of primitives. A primitive
is a logic operation that is simple enough that it doesn’t require explicit modeling. An example of this
behavior can be a basic logic gate or even a truth table. Verilog provides a set of gate-level primitives to
model simple logic operations. These gate-level primitives are not(), and(), nand(), or(), nor(), xor(), and
xnor(). Each of these primitives are instantiated as lower-level subsystems with positional port mapping.
The port order for each primitive has the output listed first followed by the input(s). The output and each of
the inputs are scalars. Gate-level primitives do not need to be explicitly created as they are provided as
part of the Verilog standard. One of the benefits of using gate-level primitives is that the number of inputs
is easily scaled as each primitive can accommodate an increasing number of inputs automatically.
Furthermore, modeling using this approach essentially provides a gate-level netlist, so it represents a
very low-level, detailed gate-level implementation that is ready for technology mapping. Example 4.3
shows how to use gate-level primitives to model the behavior of a combinational logic circuit.



54 • Chapter 4: Structural Design and Hierarchy

Example 4.3
Modeling combinational logic circuits using gate-level primitives

4.1.4 User-Defined Primitives

A user-defined primitive (UDP) is a system that describes the behavior of a low-level component
using a logic table. This is very useful for creating combinational logic functionality that will be used
numerous times. UDPs are also useful for large truth tables where it is more convenient to list the
functionality in table form. UDPs are lower-level subsystems that are intended to be instantiated in
higher-level modules just like gate-level primitives, with the exception that the UPD needs to be created
in its own file. The syntax for a UDP is as follows:

primitive primitive_name (output output_name,
input input_name1, input_name2, ...);

table
in1_val in2_val ... : out_val;
in1_val in2_val ... : out_val;

:
endtable

endprimitive

A UDPmust list its output(s) first in the port definition. It also does not require types to be defined for
the ports. For combinational logic UDPs, all ports are assumed to be of type wire. Example 4.4 shows
how to design a user-defined primitive to implement a combinational logic circuit.



4.1 Structural Design Constructs • 55

Example 4.4
Modeling combinational logic circuits with a user-defined primitive

4.1.5 Adding Delay to Primitives

Delay can be added to primitives using the same approach as described in Sect. 3.4. The delay is
inserted after the primitive name but before the instance name.

Example:

not #2 U0 (An, A); // Gate level primitive for an inverter with delay
of 2.

and #3 U3 (m0, An, Bn, Cn); // Gate level primitive for an AND gate with delay
of 3.

SystemX_UDP #1 U0 (F, A, B, C); // UDP with a delay of 1.



56 • Chapter 4: Structural Design and Hierarchy

CONCEPT CHECK

CC4.1 Does the use of lower-level sub-modules model concurrent functionality? Why?

(A) No. Since the lower-level behavior of the module being instantiated may
contain non-concurrent behavior, it is not known what functionality will be
modeled.

(B) Yes. The modules are treated like independent sub-systems whose behavior
runs in parallel just as if separate parts were placed in a design.

4.2 Structural Design Example: Ripple Carry Adder

This section gives an example of a structural design that implements a simple binary adder.

4.2.1 Half Adders

When creating an adder, it is desirable to design incremental subsystems that can be reused. This
reduces design effort and minimizes troubleshooting complexity. The most basic component in the adder
is called a half adder. This circuit computes the sum and carry out on two input arguments. The reason it
is called a half adder instead of a full adder is because it does not accommodate a carry in during the
computation, thus it does not provide all of the necessary functionality required for a positional adder.
Example 4.5 shows the design of a half adder. Notice that two combinational logic circuits are required in
order to produce the sum (the XOR gate) and the carry out (the AND gate). These two gates are in
parallel to each other; thus, the delay through the half adder is due to only one level of logic.

Example 4.5
Design of a half adder

4.2.2 Full Adders

A full adder is a circuit that still produces a sum and carry out, but considers three inputs in the
computations (A, B, and Cin). Example 4.6 shows the design of a full adder using the classical design



4.2 Structural Design Example: Ripple Carry Adder • 57

approach. This step is shown to illustrate why it is possible to reuse half adders to create the full adder. In
order to do this, it is necessary to have the minimal sum of products logic expression.

Example 4.6
Design of a full adder

As mentioned before, it is desirable to reuse design components as we construct more complex
systems. One such design reuse approach is to create a full adder using two half adders. This is
straightforward for the sum output since the logic is simply two cascaded XORgates (Sum¼ABCin).
The carry out is not as straightforward. Notice that the expression for Cout derived in Example 4.6
contains the term (A + B). If this term could be manipulated to use an XOR gate instead, it would allow the
full adder to take advantage of existing circuitry in the system. Figure 4.1 shows a derivation of an
equivalency that allows (A + B) to be replaced with (A  B) in the Cout logic expression.

Fig. 4.1
A Useful logic equivalency that can be exploited in arithmetic circuits



58 • Chapter 4: Structural Design and Hierarchy

The ability to implement the carry out logic using the expression Cout¼ AB + (A B)Cin allows us to
implement a full adder with two half adders and the addition of a single OR gate. Example 4.7 shows this
approach. In this new configuration, the sum is produced in two levels of logic while the carry out is
produced in three levels of logic.

Example 4.7
Design of a full adder out of half adders

4.2.3 Ripple Carry Adder (RCA)

The full adder can now be used in the creation of multi-bit adders. The simplest topology exploiting
the full adder is called a ripple carry adder (RCA). In this approach, full adders are used to create the sum
and carry out of each bit position. The carry out of each full adder is used as the carry in for the next
higher position. Since each subsequent full adder needs to wait for the carry to be produced by the
preceding stage, the carry is said to ripple through the circuit, thus giving this approach its name.

Example 4.8 shows how to design a 4-bit ripple carry adder using a chain of full adders. Notice that
the carry in for the full adder in position 0 is tied to a logic 0. The 0 input has no impact on the result of the
sum but enables a full adder to be used in the 0th position.



4.2 Structural Design Example: Ripple Carry Adder • 59

Example 4.8
Design of a 4-bit ripple carry adder (RCA)

4.2.4 Structural Model of a Ripple Carry Adder in Verilog

Now that the hierarchical design of the RCA is complete, we can nowmodel it in Verilog as a system
of lower-level modules. Example 4.9 shows the structural model for a full adder in Verilog consisting of
two half adders. The full adder is created by instantiating two versions of the half adder as subsystems.
The half adder in this example is implemented using gate-level primitives. In this example, all gates are
modeled with a delay of 1 ns.



60 • Chapter 4: Structural Design and Hierarchy

Example 4.9
Structural model of a full adder using two half adders

Example 4.10 shows the structural model of a 4-bit ripple carry adder in Verilog. The RCA is created
by instantiating four full adders. Notice that a logic 1’b0 can be directly inserted into the port map of the
first full adder to model the behavior of C0 ¼ 0.



Summary • 61

Example 4.10
Structural model of a 4-bit ripple carry adder in Verilog

CONCEPT CHECK

CC4.2 Why is the use of hierarchy considered a good design practice?

(A) Hierarchy allows the design to be broken into smaller pieces, each with
simpler functionality that can be verified independently prior to being used in a
higher-level system.

(B) Hierarchy allows a large system to be broken into smaller subsystems that
can be designed by multiple engineers, thus decreasing the overall
development time.

(C) Hierarchy allows a large system to be broken down into smaller subsystems
that can be more easily understood so that debugging is more manageable.

(D) All of the above.

Summary

v Instantiating other modules from within a v Verilog subsystems are also treated as con-
higher-level module is how Verilog current subsystems.
implements hierarchy. A lower-level module v Gate-level primitives are provided in Verilog
can be instantiated as many times as to implement basic logic functions (not, and,
desired. An instance identifier is useful is nand, or, nor, xor, xnor). These primitives are
keeping track of each instantiation. instantiated just like any other lower-level

v The ports of the component can be subsystem.
connected using either explicit or positional v User-Defined Primitives are supported in
port mapping. Verilog that allow the functionality of a circuit

to be described in table form.



62 • Chapter 4: Structural Design and Hierarchy

Exercise Problems

Section 4.1: Structural Design Constructs list shown in Fig. 4.3. Use a structural design
approach based on gate-level primitives. This

4.1.1 How many times can a lower-level module be
is considered structural because you will need

instantiated?
to instantiate the gate-level primitives just like a

4.1.2 Which port mapping technique is more com- traditional subsystem; however, you don’t need
pact, explicit or positional? to create the gate-level modules as they are

4.1.3 Which port mapping technique is less prone to already built into the Verilog standard. You will
connection errors because the names of the need to determine a logic expression for the
lower-level ports are listed within the mapping? system prior to connecting the gate-level

primitives. You can use whatever approach
4.1.4 Would it make sense to design a lower-level

you prefer to create the logic expression (i.e.,
module to implement an AND gate in Verilog?

canonical SOP/POS, minimized SOP/POS).
4.1.5 When would it makes more sense to build a Declare your module and ports to match the

user-defined primitive instead of modeling the block diagram provided. Use the type wire for
logic using continuous assignments? your ports.

Section 4.2: Structural Design Examples
4.2.1 Design a Verilogmodel to implement the behav-

ior describedby the3-inputminterm list shown in
Fig. 4.2. Usea structural designapproachbased
on gate-level primitives. This is considered
structural because you will need to instantiate
the gate-level primitives just like a traditional Fig. 4.3
subsystem; however, you don’t need to create System F Functionality
the gate-level modules as they are already built
into the Verilog standard. You will need to deter- 4.2.4 Design a Verilog model to implement the
mine a logic expression for the system prior to behavior described by the 3-input maxterm
connecting the gate-level primitives. You can list shown in Fig. 4.3. Use a structural design
use whatever approach you prefer to create approach based on a user-defined primitive.
the logic expression (i.e., canonical SOP/POS, This is considered structural because you will
minimized SOP/POS). Declare your module need to instantiate the user-defined primitive
and ports to match the block diagram provided. just like a traditional subsystem. You will need
Use the type wire for your ports. to create both the upper level module and the

lower-level UDP. Declare your module and
ports to match the block diagram provided.
Use the type wire for your ports. Declare your
module and ports to match the block diagram
provided. Use the type wire for your ports.

4.2.5 Design a Verilogmodel to implement the behav-
ior described by the 3-input truth table shown in

Fig. 4.2 Fig. 4.4. Usea structural design approachbased
System E Functionality on gate-level primitives. This is considered

structural because you will need to instantiate

4.2.2 Design a Verilog model to implement the the gate-level primitives just like a traditional

behavior described by the 3-input minterm list subsystem; however, you don’t need to create

shown in Fig. 4.2. Use a structural design the gate-level modules as they are already built

approach based on a user-defined primitive. into the Verilog standard. You will need to deter-

This is considered structural because you will mine a logic expression for the system prior to

need to instantiate the user-defined primitive connecting the gate-level primitives. You can

just like a traditional subsystem. You will need use whatever approach you prefer to create

to create both the upper level module and the the logic expression (i.e., canonical SOP/POS,

lower-level UDP. Declare your module and minimized SOP/POS). Declare your module

ports to match the block diagram provided. and ports to match the block diagram provided.

Use the type wire for your ports. Use the type wire for your ports.

4.2.3 Design a Verilog model to implement the
behavior described by the 3-input maxterm



Exercise Problems • 63

This is considered structural because you will
need to instantiate the user-defined primitive
just like a traditional subsystem. You will need
to create both the upper level module and the
lower-level UDP. Declare your module and
ports to match the block diagram provided.
Use the type wire for your ports.

4.2.9 Design a Verilog model to implement the
behavior described by the 4-input maxterm
list shown in Fig. 4.6. Use a structural design
approach based on gate-level primitives. This
is considered structural because you will need
to instantiate the gate-level primitives just like a

Fig. 4.4
traditional subsystem; however, you don’t need

System G Functionality to create the gate-level modules as they are
already built into the Verilog standard. You will

4.2.6 Design a Verilog model to implement the need to determine a logic expression for the
behavior described by the 3-input truth table system prior to connecting the gate-level
shown in Fig. 4.4. Use a structural design primitives. You can use whatever approach
approach based on a user-defined primitive. you prefer to create the logic expression (i.e.,
This is considered structural because you will canonical SOP/POS, minimized SOP/POS).
need to instantiate the user-defined primitive Declare your module and ports to match the
just like a traditional subsystem. You will need block diagram provided. Use the type wire for
to create both the upper level module and the your ports.
lower-level UDP. Declare your module and
ports to match the block diagram provided.
Use the type wire for your ports.

4.2.7 Design a Verilog model to implement the
behavior described by the 4-input minterm list
shown in Fig. 4.5. Use a structural design
approach based on gate-level primitives. This
is considered structural because you will need
to instantiate the gate-level primitives just like a Fig. 4.6
traditional subsystem; however, you don’t need System J Functionality
to create the gate-level modules as they are
already built into the Verilog standard. You will 4.2.10 Design a Verilog model to implement the
need to determine a logic expression for the behavior described by the 4-input maxterm
system prior to connecting the gate-level list shown in Fig. 4.6. Use a structural design
primitives. You can use whatever approach approach based on a user-defined primitive.
you prefer to create the logic expression (i.e., This is considered structural because you will
canonical SOP/POS, minimized SOP/POS). need to instantiate the user-defined primitive
Declare your module and ports to match the just like a traditional subsystem. You will need
block diagram provided. Use the type wire for to create both the upper level module and the
your ports. lower-level UDP. Declare your module and

ports to match the block diagram provided.
Use the type wire for your ports.

4.2.11 Design a Verilog model to implement the
behavior described by the 4-input truth table
shown in Fig. 4.7. Use a structural design
approach based on gate-level primitives. This
is considered structural because you will need
to instantiate the gate-level primitives just like a

Fig. 4.5 traditional subsystem; however, you don’t need

System I Functionality to create the gate-level modules as they are
already built into the Verilog standard. You will
need to determine a logic expression for the

4.2.8 Design a Verilog model to implement the
system prior to connecting the gate-level

behavior described by the 4-input minterm list
primitives. You can use whatever approach

shown in Fig. 4.5. Use a structural design
you prefer to create the logic expression (i.e.,

approach based on a user-defined primitive.
canonical SOP/POS, minimized SOP/POS).



64 • Chapter 4: Structural Design and Hierarchy

Declare your module and ports to match the
4.2.12 Design a Verilog model to implement the

block diagram provided. Use the type wire for
behavior described by the 4-input truth table

your ports.
shown in Fig. 4.7. Use a structural design
approach based on a user-defined primitive.
This is considered structural because you will
need to instantiate the user-defined primitive
just like a traditional subsystem. You will need
to create both the upper level module and the
lower-level UDP. Declare your module and
ports to match the block diagram provided.
Use the type wire for your ports.

Fig. 4.7
System K Functionality



Chapter 5: Modeling Sequential
Functionality

In Chap. 3 techniques were presented to describe the behavior of concurrent systems. The
modeling techniques presented were appropriate for combinational logic because these types of circuits
have outputs dependent only on the current values of their inputs. This means a model that continuously
performs signal assignments provides an accurate model of this circuit behavior. When we start looking
at sequential circuits (i.e., D-Flip-Flops, registers, finite state machine, and counters), these devices only
update their outputs based upon an event, most often the edge of a clock signal. The modeling
techniques presented in Chap. 3 are unable to accurately describe this type of behavior. In this chapter
we describe the Verilog constructs to model signal assignments that are triggered by an event to
accurately model sequential logic. We can then use these techniques to describe more complex
sequential logic circuits such as finite state machines and register transfer level systems.

Learning Outcomes—After completing this chapter, you will be able to:

5.1 Describe the behavior of a Verilog procedural block and how it is used to model sequential
logic circuits.

5.2 Model combinational logic circuits using a procedural block and conditional programming
constructs.

5.3 Use Verilog system tasks to provide additional functionality to a simulation model.

5.1 Procedural Assignment

Verilog uses procedural assignment to model signal assignments that are based on an event. An
event is most commonly a transition of a signal. This provides the ability to model sequential logic circuits
such as D-flip-flops and finite state machines by triggering assignments off of a clock edge. Procedural
assignments can only drive variable data types (i.e., reg, integer, real, and time); thus, they are ideal for
modeling storage devices. Procedural signal assignments can be evaluated in the order they are listed;
thus, they are able to model sequential assignments.

A procedural assignment can also be used to model combinational logic circuits by making signal
assignments when any of the inputs to the model change. Despite the left-hand side of the assignment
not being able to be of type wire in procedural assignment, modern synthesizers will recognize properly
designed combinational logic models and produce the correct circuit implementation. Procedural assign-
ment also supports standard programming constructs such as if-else decisions, case statements, and
loops. This makes procedural assignment a powerful modeling approach in Verilog and is the most
common technique for designing digital systems and creating test benches.

5.1.1 Procedural Blocks

All procedural signal assignments must be enclosed within a procedural block. Verilog has two types
of procedural blocks, initial and always.

# Springer Nature Switzerland AG 2019 65
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5_5



66 • Chapter 5: Modeling Sequential Functionality

5.1.1.1 Initial Blocks

An initial block will execute all of the statements embedded within it one time at the beginning of the
simulation. An initial block is not used to model synthesizable behavior. It is instead used within test
benches to either set the initial values of repetitive signals or to model the behavior of a signal that only
has a single set of transitions. The following is the syntax for an initial block.

initial
begin // an optional “: name” can be added after the begin keyword

signal_assignment_1
signal_assignment_2

:
end

Let’s look at a simple model of how an initial block is used to model the reset line in a test bench. In
the following example, the signal “Reset_TB” is being driven into a DUT. At the beginning of the
simulation, the initial value of Reset_TB is set to a logic zero. The second assignment will take place
after a delay of 15 time units. The second assignment statement sets Reset_TB to a logic one. The
assignments in this example are evaluated in sequence in the order they are listed due to the delay
operator. Since the initial block executes only once, Reset_TB will stay at the value of its last assignment
for the remainder of the simulation.

Example:

initial
begin

Reset_TB ¼ 1’b0;
#15 Reset_TB ¼ 1’b1;

end

5.1.1.2 Always Blocks

An always block will execute forever, or for the duration of the simulation. An always block can be
used to model synthesizable circuits in addition to non-synthesizable behavior in test benches. The
following is the syntax for an always block.

always
begin

signal_assignment_1
signal_assignment_2

:
end

Let’s look at a simple model of how an always block can be used to model a clock line in a test
bench. In the following example, the value of the signal Clock_TB will continuously change its logic value
every 10 time units.

Example:

always
begin

#10 Clock_TB ¼ ~Clock_TB;
end

By itself, the above always block will not work because when the simulation begins, Clock_TB does
not have an initial value so the simulator will not know what the value of Clock_TB is at time zero. It will
also not know what the output of the negation operation (~) will be at time unit 10. The following example



5.1 Procedural Assignment • 67

shows the correct way of modeling a clock signal using a combination of initial and always blocks. Verilog
allows assignments to the same variable from multiple procedural blocks, so the following example is
valid. Note that when the simulation begins, Clock_TB is assigned a logic zero. This provides a known
value for the signal at time zero and also allows the always block negation to have a deterministic value.
The example below will create a clock signal that will toggle every 10 time units.

Example:

initial
begin

Clock_TB ¼ 1’b0;
end

always
begin

#10 Clock_TB ¼ ~Clock_TB;
end

5.1.1.3 Sensitivity Lists

A sensitivity list is used in conjunction with a procedural block to trigger when the assignments within
the block are executed. The symbol @ is used to indicate a sensitivity list. Signals can then be listed
within parenthesis after the @ symbol that will trigger the procedural block. The following is the base
syntax for a sensitivity list.

always @ (signal1, signal2)
begin

signal_assignment_1
signal_assignment_2

:
end

In this syntax, any transition on any of the signals listed within the parenthesis will cause the always
block to trigger and all of its assignments to take place one time. After the always block ends, it will await
the next signal transition in the sensitivity list to trigger again. The following example shows how to model
a simple 3-input AND gate. In this example, any transition on inputs A, B, or C will cause the block to
trigger and the assignment to F to occur.

Example:

always @ (A, B, C)
begin

F ¼ A & B & C;
end

Verilog also supports keywords to limit triggering of the block to only rising edge or falling edge
transitions. The keywords are posedge and negedge. The following is the base syntax for an edge
sensitive block. In this syntax, only rising edge transitions on signal1 or falling edge transitions on signal2
will cause the block to trigger.

always @ (posedge signal1, negedge signal2)
begin

signal_assignment_1
signal_assignment_2

:
end



68 • Chapter 5: Modeling Sequential Functionality

Sensitivity lists can also contain Boolean operators to more explicitly describe behavior. The
following syntax is identical to the syntax above.

always @ (posedge signal1 or negedge signal2)
begin

signal_assignment_1
signal_assignment_2

:
end

The ability to model edge sensitivity allows us to model sequential circuits. The following example
shows how to model a simple D-flip-flop.

Example:

always @ (posedge Clock)
begin

Q ¼ D; // Note: This model does not include a reset.
end

In Verilog-2001, the syntax to support sensitivity lists that will trigger based on any signal listed on
the right-hand side of any assignment within the block was added. This syntax is @*. The following
example shows how to use this modeling approach to model a 3-input AND gate.

Example:

always @*
begin

F ¼ A & B & C;
end

5.1.2 Procedural Statements

There are two kinds of signal assignments that can be used within a procedural block, blocking and
non-blocking.

5.1.2.1 Blocking Assignments

A blocking assignment is denoted with the ¼ symbol and the evaluation and assignment of each
statement takes place immediately. Each assignment within the block is executed in parallel. When this
behavior is coupled with a sensitivity list that contains all of the inputs to the system, this approach can
model synthesizable combinational logic circuits. This approach provides the same functionality as
continuous assignments outside of a procedural block. The reason that designers use blocking
assignments instead of continuous assignment is that more advanced programming constructs are
supported within Verilog procedural blocks. These will be covered in the next section. Example 5.1
shows how to use blocking assignments within a procedural block to model a combinational logic circuit.



5.1 Procedural Assignment • 69

Example 5.1
Using blocking assignments to model combinational logic

5.1.2.2 Non-blocking Assignments

A non-blocking assignment is denoted with the <¼ symbol. When using non-blocking assignments,
the assignment to the target signal is deferred until the end of the procedural block. This allows the
assignments to be executed in the order they are listed in the block without cascading interim
assignments through the list. When this behavior is coupled with triggering the block off of a clock signal,
this approach canmodel synthesizable sequential logic circuits. Example 5.2 shows an example of using
non-blocking assignments to model a sequential logic circuit.

Example 5.2
Using non-blocking assignments to model sequential logic

The difference between blocking and non-blocking assignments is subtle and is often one of the
most difficult concepts to grasp when first learning Verilog. One source of confusion comes from the fact
that blocking and non-blocking assignments can produce the same results when they contain either a
single assignment or a list of assignments that don’t have any signal interdependencies. A signal
interdependency refers to when a signal that is the target of an assignment (i.e., on the LHS of an
assignment) is used as an argument (i.e., on the RHS of an assignment) in subsequent statements.
Example 5.3 shows two models that produce the same results regardless of whether a blocking or
non-blocking assignment is used.



70 • Chapter 5: Modeling Sequential Functionality

Example 5.3
Identical behavior when using blocking vs. non-blocking assignments

When a list of statements within a procedural block does have signal interdependencies, blocking
and non-blocking assignments will have different behavior. Example 5.4 shows how signal
interdependencies will cause different behavior between blocking and non-blocking assignments. In
this example, all inputs are listed in the sensitivity list with the intent of modeling combinational logic.



5.1 Procedural Assignment • 71

Example 5.4
Different behavior when using blocking vs. non-blocking assignments (1)

Example 5.5 shows another case where signal interdependencies will cause different behavior
between blocking and non-blocking assignments. In this example, the procedural block is triggered by
the rising edge of a clock signal with the intent of modeling two stages of sequential logic.



72 • Chapter 5: Modeling Sequential Functionality

Example 5.5
Different behavior when using blocking vs. non-blocking assignments (2)

While the behavior of these procedural assignments can be confusing, there are two design
guidelines that can make creating accurate, synthesizable models straightforward. They are:

1. When modeling combinational logic, use blocking assignments and list every input in the
sensitivity list.

2. When modeling sequential logic, use non-blocking assignments and only list the clock and
reset lines (if applicable) in the sensitivity list.



5.1 Procedural Assignment • 73

5.1.3 Statement Groups

A statement group refers to how the statements in a block are processed. Verilog supports two types
of statement groups: begin/end and fork/join. When using begin/end, all statements enclosed within the
group will be evaluated in the order they are listed. When using a fork/join, all statements enclosed within
the group will be evaluated in parallel. When there is only one statement within procedural block, a
statement group is not needed. For multiple statements in a procedural block, a statement group is
required. Statement groups can contain an optional name that is appended after the first keyword
preceded by a “:”. Example 5.6 shows a graphical depiction of the difference between begin/end and
fork/join groups. Note that this example also shows the syntax for naming the statement groups.

Example 5.6
Behavior of statement groups begin/end vs. fork/join

5.1.4 Local Variables

Local variables can be declared within a procedural block. The statement group must be named,
and the variables will not be visible outside of the block. Variables can only be of variable type.

Example:

initial
begin: stim_block // it is required to name the block when declaring local variables

integer i; // local variables can only be of variable type
i¼2;

end



74 • Chapter 5: Modeling Sequential Functionality

CONCEPT CHECK

CC5.1 If a model of a combinational logic circuit excludes one of its inputs from the sensitivity
list, what is the implied behavior?

(A) A storage element because the output will be held at its last value when the
unlisted input transitions.

(B) An infinite loop.

(C) A don’t care will be used to form the minimal logic expression.

(D) Not applicable because this syntax will not compile.

5.2 Conditional Programming Constructs

One of the more powerful features that procedural blocks provide in Verilog is the ability to use
conditional programming constructs such as if-else decisions, case statements, and loops. These
constructs are only available within a procedural block and can be used to model both combinational
and sequential logic.

5.2.1 if-else Statements

An if-else statement provides a way to make conditional signal assignments based on Boolean
conditions. The if portion of statement is followed by a Boolean condition that if evaluated TRUE will
cause the signal assignment listed after it to be performed. If the Boolean condition is evaluated FALSE,
the statements listed after the else portion are executed. If multiple statements are to be executed in
either the if or else portion, then the statement group keywords begin/end need to be used. If only one
statement is to be executed, then the statement group keywords are not needed. The else portion of the
statement is not required and if omitted, no assignment will take place when the Boolean condition is
evaluated FALSE. The syntax for an if-else statement is as follows:

if (<boolean_condition>)
true_statement

else
false_statement

The syntax for an if-else statement with multiple true/false statements is as follows:

if (<boolean_condition>)
begin
true_statement_1
true_statement_2

end
else

begin
false_statement_1
false_statement_2

end

If more than one Boolean condition is required, additional if-else statements can be embedded
within the else clause of the preceding if statement. The following shows an example of if-else
statements implementing two Boolean conditions.



5.2 Conditional Programming Constructs • 75

if (<boolean_condition_1>)
true_statement_1

else if (<boolean_condition_2>)
true_statement_2

else
false_statement

Let’s look at using an if-else statement to describe the behavior of a combinational logic circuit.
Recall that a combinational logic circuit is one in which the output depends on the instantaneous values
of the inputs. This behavior can bemodeled by placing all of the inputs to the circuit in the sensitivity list of
an always block and using blocking assignments. Using this approach, a change on any of the inputs in
the sensitivity list will trigger the block and the assignments will take place immediately. Example 5.7
shows how to model a 3-input combinational logic circuit using if-else statements within a procedural
always block.

Example 5.7
Using if-else statements to model combinational logic

5.2.2 case Statements

A case statement is another technique to model signal assignments based on Boolean conditions.
As with the if-else statement, a case statement can only be used inside of a procedural block. The
statement begins with the keyword case followed by the input signal name that assignments will be
based off of enclosed within parenthesis. The case statement can be based on multiple input signal
names by concatenating the signals within the parenthesis. Then a series of input codes followed by the
corresponding assignment is listed. The keyword default can be used to provide the desired signal
assignment for any input codes not explicitly listed. When multiple input conditions have the same
assignment statement, they can be listed on the same line comma-delimited to save space. The keyword
endcase is used to denote the end of the case statement. The following is the syntax for a case
statement.



76 • Chapter 5: Modeling Sequential Functionality

case (<input_name>)
input_val_1 : statement_1
input_val_2 : statement_2

:
input_val_n : statement_n
default : default_statement

endcase

Example 5.8 shows how to model a 3-input combinational logic circuit using a case statement within
a procedural block. Note in this example the inputs are scalars, so they must be concatenated so that the
input values can be listed as 3-bit vectors. In this example, there are three versions of the model
provided. The first explicitly lists out all binary input codes. This approach is more readable because it
mirrors a truth table form. The second approach only lists the input codes corresponding to an output of
one and uses the default clause to handle all other input codes. The third approach shows how to list
multiple input codes with the same assignment on the same line using a comma-delimited series.

Example 5.8
Using case statements to model combinational logic

If-else statements can be embedded within a case statement and, conversely, case statements can
be embedded within an if-else statement.



5.2 Conditional Programming Constructs • 77

5.2.3 casez and casex Statements

Verilog provides two additional case statements that support don’t cares in the input conditions. The
casez statement allows the symbols ? and Z to represent a don’t care. The casex statement extends the
casez statement by also interpreting X as a don’t care. Care should be taken when using the casez and
casex statement as it is easy to create unintended logic when using don’t cares in the input codes.

5.2.4 forever Loops

A loop within Verilog provides a mechanism to perform repetitive assignments infinitely. This is
useful in test benches for creating stimulus such as clocks or other periodic signals. We have already
covered a looping construct in the form of an always block. An always block provides a loop with a
starting condition. Verilog provides additional looping constructs to model more sophisticated behavior.
All looping constructs must reside with a procedural block.

The simplest looping construct is the forever loop. As with other conditional programming
constructs, if multiple statements are associated with the forever loop, they must be enclosed within a
statement group. If only one statement is used, the statement group is not needed. A forever loop within
an initial block provides identical behavior as an always loop without a sensitivity loop. It is important to
provide a time step event or delay within a forever loop or it will cause a simulation to hang. The following
is the syntax for a forever loop in Verilog.

forever
begin
statement_1
statement_2

:
statement_n

end

Consider the following example of a forever loop that generates a clock signal (CLK) with a period of
10 time units. In this example, the forever loop is embedded within an initial block. This allows the initial
value of CLK to be set to zero upon the beginning of the simulation. Once the forever loop is entered, it
will execute indefinitely. Notice that since there is only one statement after the forever keyword, a
statement group (i.e., begin/end) is not needed.

Example:

initial
begin

CLK ¼ 0;

forever
#10 CLK ¼ ~CLK;

end

5.2.5 while Loops

A while loop provides a looping structure with a Boolean condition that controls its execution. The
loop will only execute as long as the Boolean condition is evaluated true. The following is the syntax for a
Verilog while loop.



78 • Chapter 5: Modeling Sequential Functionality

while (<boolean_condition>)
begin
statement_1
statement_2

:
statement_n

end

Let’s implement the previous example of a loop that generates a clock signal (CLK) with a period of
10 time units as long as EN¼ 1. The TRUE Boolean condition for the while loop is EN¼ 1. When EN¼ 0,
the while loop will be skipped. When the loop becomes inactive, CLK will hold its last assigned value.

Example:

initial
begin

CLK ¼ 0;

while (EN ¼¼ 1)
#10 CLK ¼ ~CLK;

end

5.2.6 repeat Loops

A repeat loop provides a looping structure that will execute a fixed number of times. The following is
the syntax for a Verilog repeat loop.

repeat (<number_of_loops>)
begin
statement_1
statement_2

:
statement_n

end

Let’s implement the previous example of a loop that generates a clock signal (CLK) with a period of
10 time units, except this time we’ll use a repeat loop to only produce 10 clock transitions, or 5 full periods
of CLK.

Example:

initial
begin

CLK ¼ 0;
repeat (10)

#10 CLK ¼ ~CLK;
end

5.2.7 for Loops

A for loop provides the ability to create a loop that can automatically update an internal variable. A
loop variable within a for loop is altered each time through the loop according to a step assignment. The
starting value of the loop variable is provided using an initial assignment. The loop will execute as long as
a Boolean condition associated with the loop variable is TRUE. The following is the syntax for a Verilog
for loop:



5.2 Conditional Programming Constructs • 79

for (<initial_assignment>; <Boolean_condition>; <step_assignment>)
begin
statement_1
statement_2

:
statement_n

end

The following is an example of creating a simple counter using the loop variable. The loop variable
i was declared as an integer prior to this block. The signal Count is also of type integer. The loop variable
will start at 0 and increment by 1 each time through the loop. The loop will execute as long as i < 15, or
16 times total. For loops allow the loop variable to be used in signal assignments within the block.

Example:

initial
begin

for (i¼0; i<15; i¼i+1)
#10 Count ¼ i;

end

5.2.8 disable

Verilog provides the ability to stop a loop using the keyword disable. The disable function only works
on named statement groups. The disable function is typically used after a certain fixed amount of time or
within a conditional construct such as an if-else or case statement that is triggered by a control signal.
Consider the following forever loop example that will generate a clock signal (CLK), but only when an
enable (EN) is asserted. When EN ¼ 0, the loop will disable and the simulation will end.

Example:

initial
begin

CLK ¼ 0;
forever

begin: loop_ex
if (EN ¼¼ 1)

#10 CLK ¼ ~CLK;
else

disable loop_ex; // The group name to be disabled comes after the keyword
end

end

CONCEPT CHECK

CC5.2 When using an if-else statement to model a combinational logic circuit, is using the else
clause the same as using don’t careswhenminimizing a logic expression with a K-map?

(A) Yes. The else clause allows the synthesizer to assign whatever output values
are necessary in order to create the most minimal circuit.

(B) No. The else clause explicitly states the output values for all input codes not
listed in the if portion of the statement. This is the same as filling in the truth
table with specific values for all input codes covered by the else clause and
the synthesizer will create the logic expression accordingly.



80 • Chapter 5: Modeling Sequential Functionality

5.3 System Tasks

A system task in Verilog is one that is used to insert additional functionality into a model that is not
associated with real circuitry. There are three main groups of system tasks in Verilog: (1) text output;
(2) file input/output; and (3) simulation control. All system tasks begin with a $ and are only used during
simulation. These tasks are ignored by synthesizers, so they can be included in real circuit models. All
system tasks must reside within procedural blocks.

5.3.1 Text Output

Text output system tasks are used to print strings and variable values to the console or transcript of a
simulation tool. The syntax follows ANSI C where double quotes (“”) are used to denote the text string to
be printed. Standard text can be entered within the string in addition to variables. Variable can be printed
in two ways. The first is to simply list the variable in the system task function outside of the double quotes.
In this usage, the default format to be printed will be decimal unless a task is used with a different default
format. The second way to print a variable is within a text string. In this usage, a unique code is inserted
into the string indicating the format of how to print the value. After the string, a comma-separated list of
the variable name(s) is listed that corresponds positionally to the codes within the string. The following
are the most commonly used text output system tasks.

Task Description

$display() Print text string when statement is encountered and append a newline.
$displayb() Same as $display, but default format of any arguments is binary.
$displayo() Same as $display, but default format of any arguments is octal.
$displayh() Same as $display, but default format of any arguments is hexadecimal.

$write() Same as $display, but the string is printed without a newline.
$writeb() Same as $write, but default format of any arguments is binary.
$writeo() Same as $write, but default format of any arguments is octal.
$writeh() Same as $write, but default format of any arguments is hexadecimal.

$strobe() Same as $display, but printing occurs after all simulation events are executed.
$strobeb() Same as $strobe, but default format of any arguments is binary.
$strobeo() Same as $strobe, but default format of any arguments is octal.
$strobeh() Same as $strobe, but default format of any arguments is hexadecimal.

$monitor() Same as $display, but printing occurs when the value of an argument changes.
$monitorb() Same as $monitor, but default format of any arguments is binary.
$monitoro() Same as $monitor, but default format of any arguments is octal.
$monitorh() Same as $monitor, but default format of any arguments is hexadecimal.
$monitoron Begin tracking argument changes in subsequent $monitor tasks.
$monitoroff Stop tracking argument changes in subsequent $monitor tasks.

The following is a list of the most common text formatting codes for printing variables within a string.

Code Format

%b Binary values
%o Octal values
%d Decimal values
%h Hexadecimal values
%f Real values using decimal form
%e Real values using exponential form



5.3 System Tasks • 81

Code Format

%t Time values
%s Character strings
%m Hierarchical name of scope (no argument required when printing)
%l Configuration library binding (no argument required when printing)

The format letters in these codes are not case sensitive (i.e., %d and %D are equivalent). Each of
these formatting codes can also contain information about truncation of leading and trailing digits.
Rounding will take place when numbers are truncated. The formatting syntax is as follows:

%<number_of_leading_digits>.<number_of_trailing_digits><format_code_letter>

There are also a set of string formatting and character escapes that are supported for use with the
text output system tasks.

Code Description

\n Print a new line.
\t Print a tab.
\” Print a quote (“).
\cr Print a backslash (\).
%% Print a percent sign (%).

The following is a set of examples using common text output system tasks. For these examples,
assume two variables have been declared and initialized as follow: A ¼ 3 (integer) and B ¼ 45.6789
(real). Recall that Verilog uses 32-bit codes to represent type integer and real.

Example:

$display("Hello World"); // Will print: Hello World
$display("A ¼ %b", A); // This will print: A ¼ 00000000000000000000000000000

011
$display("A ¼ %o", A); // This will print: A ¼ 00000000003
$display("A ¼ %d", A); // This will print: A ¼ 3
$display("A ¼ %h", A); // This will print: A ¼ 00000003
$display("A ¼ %4.0b", A); // This will print: A ¼ 0011

$display("B ¼ %f", B); // This will print: B ¼ 45.678900
$display("B ¼ %2.0f", B); // This will print: B ¼ 46
$display("B ¼ %2.1f", B); // This will print: B ¼ 45.7
$display("B ¼ %2.2f", B); // This will print: B ¼ 45.68
$display("B ¼ %e", B); // This will print: B ¼ 4.567890e+001
$display("B ¼ %1.0e", B); // This will print: B ¼ 5e+001
$display("B ¼ %1.1e", B); // This will print: B ¼ 4.6e+001
$display("B ¼ %2.2e", B); // This will print: B ¼ 4.57e+001

$write("A is ", A, "\n"); // This will print: A is 3
$writeb("A is ", A, "\n"); // This will print: A is 00000000000000000000000000000

011
$writeo("A is ", A, "\n"); // Will print: A is 00000000003
$writeh("A is ", A, "\n"); // Will print: A is 00000003

5.3.2 File Input/Output

File I/O system tasks allow a Verilog module to create and/or access data files in the same way files
are handled in ANSI C. This is useful when the results of a simulation are large and need to be stored in a
file as opposed to viewing in a waveform or transcript window. This is also useful when complex stimulus



82 • Chapter 5: Modeling Sequential Functionality

vectors are to be read from an external file and driven into a device under test. Verilog supports the
following file I/O system task functions:

Task Description

$fopen() Opens a file and returns a unique file descriptor.
$fclose() Closes the file associated with the descriptor.
$fdisplay() Same as $display but statements are directed to the file descriptor.
$fwrite() Same as $write but statements are directed to the file descriptor.
$fstrobe() Same as $strobe but statements are directed to the file descriptor.
$fmonitor() Same as $monitor but statements are directed to the file descriptor.
$readmemb() Read binary data from file and insert into previously defined memory array.
$readmemh() Read hexadecimal data from file and insert into previously defined memory array.

The $fopen() function will either create and open, or open an existing file. Each file that is opened is
given a unique integer called a file descriptor that is used to identify the file in other I/O functions. The
integer must be declared prior to the first use of $fopen. A file name argument is required and provided
within double quotes. By default, the file is opened for writing. If the file name doesn’t exist, it will be
created. If the file name does exist, it will be overwritten. An optional file_type can be provided that gives
specific action for the file opening including opening an existing file and appending to a file. The following
are the supported codes for $fopen().

$fopen types Description

“r” or “rb” Open file for reading.
“w” or “wb” Create for writing.
“a” or “ab” Open for writing and append to the end of file.
“r+” or “r+b” or “rb+” Open for update, reading or writing file.
“w+” or “w+b” or “wb+” Create for update.
“a+” or “a+b” or “ab+” Open or create for update, append to the end of file.

Once a file is open, data can be written to it using the $fdisplay(), $fwrite(), $fstrobe(), and
$fmonitor() tasks. These functions require two arguments. The first argument is the file descriptor and
the second is the information to be written. The information follows the same syntax as the I/O system
tasks. The following example shows how to create a file and write data to it. This example will create a
new file called “Data_out.txt” and write two lines of text to it with the values of variables A and B.

Example:

integer A ¼ 3;
real B ¼ 45.6789;
integer FILE_1;

initial
begin

FILE_1 ¼ $fopen("Data_out.txt", "w");
$fdisplay(FILE_1, "A is %d", A);
$fdisplay(FILE_1, "B is %f", B);
$fclose(FILE_1);

end

When reading data from a file, the functions $readmemb() and $readmemh() can be used. These
tasks require that a storage array be declared that the contents of the file can be read into. These tasks



5.3 System Tasks • 83

have two arguments, the first being the name of the file and the second being the name of the storage
array to store the file contents into. The following example shows how to read the contents of a file into a
storage array called “memory.” Assume the file contains eight lines, each containing a 3-bit vector. The
vectors start at 000 and increment to 111 and each symbol will be interpreted as binary using the
$readmemb() task. The storage array “memory” is declared to be an 8  3 array of type reg. The
$readmemb() task will insert each line of the file into each 3-bit vector location within “memory.” To
illustrate how the data is stored, this example also contains a second procedural block that will print the
contents of the storage element to the transcript.

Example:

reg[2:0] memory[7:0];

initial
begin: Read_Block
$readmemb("Data_in.txt", memory);
end

initial
begin: Print_Block

$display("printing memory %b", memory[0]); // This will print “000”
$display("printing memory %b", memory[1]); // This will print “001”
$display("printing memory %b", memory[2]); // This will print “010”
$display("printing memory %b", memory[3]); // This will print “011”
$display("printing memory %b", memory[4]); // This will print “100”
$display("printing memory %b", memory[5]); // This will print “101”
$display("printing memory %b", memory[6]); // This will print “110”
$display("printing memory %b", memory[7]); // This will print “111”

end

5.3.3 Simulation Control and Monitoring

Verilog also provides a set of simulation control and monitoring tasks. The following are the most
commonly used tasks in this group.

Task Description

$finish() Finishes simulation and exits.
$stop() Halts the simulation and enters an interactive debug mode.
$time() Returns the current simulation time as a 64-bit vector.
$stime() Returns the current simulation time as a 32-bit integer.
$realtime() Returns the current simulation time as a 32-bit real number.
$timeformat() Controls the format used by the %t code in print statements.

The arguments are: (<unit>, <precision>, <suffix>, <min_field_width>)
where:
<unit> 0 ¼ 1 s

1 ¼ 100 ms
2 ¼ 10 ms
3 ¼ 1 ms
4 ¼ 100 μs
5 ¼ 10 μs
6 ¼ 1 μs
7 ¼ 100 ns
8 ¼ 10 ns
9 ¼ 1 ns
10 ¼ 100 ps



84 • Chapter 5: Modeling Sequential Functionality

Task Description

11 ¼ 10 ps
12 ¼ 1 ps
13 ¼ 100 fs
14 ¼ 10 fs
15 ¼ 1 fs

<precision> ¼ The number of decimal points to display.
<suffix> ¼ A string to be appended to time to indicate units.
<min_field_width> ¼ The minimum number of characters to display.

The following shows an example of how these tasks can be used.

Example:

initial
begin

$timeformat (-9, 2, "ns", 10);
$display("Stimulus starting at time: %t", $time);

#10 A_TB¼0; B_TB¼0; C_TB¼0;
#10 A_TB¼0; B_TB¼0; C_TB¼1;
#10 A_TB¼0; B_TB¼1; C_TB¼0;
#10 A_TB¼0; B_TB¼1; C_TB¼1;
#10 A_TB¼1; B_TB¼0; C_TB¼0;
#10 A_TB¼1; B_TB¼0; C_TB¼1;
#10 A_TB¼1; B_TB¼1; C_TB¼0;
#10 A_TB¼1; B_TB¼1; C_TB¼1;

$display("Simulation stopping at time: %t", $time);
end

This example will result in the following statements printed to the simulator transcript:

Stimulus starting at time: 0.00ns
Simulation stopping at time: 80.00ns

CONCEPT CHECK

CC5.3 How can Verilog system tasks be included in synthesizable circuit models when they
provide inherently unsynthesizable functionality?

(A) They can’t. System tasks can only be used in test benches.

(B) The “$” symbol tells the CAD tool that the task can be ignored during
synthesis.

(C) The designer must only use system tasks that model sequential logic.

(D) The designer must only use system tasks that model combinational logic.



Exercise Problems • 85

Summary

v To model sequential logic, an HDL needs to are made when the procedural block ends
be able to trigger signal assignments based and are evaluated in the order they appeared
on an event. This is accomplished in Verilog in the block. Blocking assignments are used
using procedural assignment. to model sequential logic. Sequential logic

v There are two types of procedural blocks in models list only the clock and reset in the
Verilog, initial and always. An initial block sensitivity list.
executes one time. An always block runs v Variables can be defined within a procedural
continually. block as long as the block is named.

v A sensitivity list is a way to control when a v Procedural blocks allow more advanced
Verilog procedural block is triggered. A sen- modeling constructs in Verilog. These
sitivity list contains a list of signals. If any of include if-else statements, case statements,
the signals in the sensitivity list transitions it and loops.
will cause the block to trigger. If a sensitivity v Verilog provides numerous looping
list is omitted, the block will trigger immedi- constructs including forever, while, repeat,
ately. Sensitivity lists are most commonly and for. Loops can be terminated using the
used with always blocks. disable keyword.

v Sensitivity lists and always blocks are used v System Tasks provide additional functionality
to model synthesizable logic. Initial blocks to Verilog models. Tasks begin with the $
are typically only used in test benches. symbol and are omitted from synthesis. Sys-
Always blocks are also used in test benches. tem tasks can be included in synthesizable

v There are two types of signal assignments logic models.
that can be used within a procedural block, v There are three groups of system tasks: text
blocking and non-blocking. output, file input/output, and simulation con-

v A blocking assignment is denoted with the ¼ trol and monitoring.
symbol. All blocking assignments are made v System tasks that perform printing functions
immediately within the procedural block. can output strings in addition to variable
Blocking assignments are used to model values. Verilog provides a mechanism to
combinational logic. Combinational logic print the variable values in a variety of format.
models list all input to the circuit in the
sensitivity list.

v A non-blocking assignment is denoted with
the <¼ symbol. All non-blocking assignments

Exercise Problems

Section 5.1: Procedural Assignment 5.1.9 What type of procedural assignment is used
when modeling sequential logic?

5.1.1 When using a sensitivity list with a procedural
block, what will cause the block to trigger? 5.1.10 What signals should be listed in the sensitivity

list when modeling combinational logic?
5.1.2 When a sensitivity list is not used with a proce-

dural block, when will the block trigger? 5.1.11 What signals should be listed in the sensitivity
list when modeling sequential logic?

5.1.3 When are statements executed when using
blocking assignments?

Section 5.2: Conditional Programming
5.1.4 When are statements executed when using

non-blocking assignments? Constructs
5.1.5 When is it possible to exclude statement 5.2.1 Design a Verilog model to implement the

groups from a procedural block? behavior described by the 4-input truth table
in Fig. 5.1. Use procedural assignment and an

5.1.6 What is the difference between a begin/end
if-else statement. Declare the module to match

and fork/join group when each contain multiple
the block diagram provided. Use the type wire

statements?
for the inputs and type reg for the output. Hint:

5.1.7 What is the difference between a begin/end Notice that there are far more input codes pro-
and fork/join group when each contain only a ducing F ¼ 0 than producing F ¼ 1. Can you
single statement? use this to your advantage to make your if-else

5.1.8 What type of procedural assignment is used statement simpler?
when modeling combinational logic?



86 • Chapter 5: Modeling Sequential Functionality

Fig. 5.3
System K Functionality

5.2.6 Design a Verilog model to implement the
behavior described by the 4-input maxterm list
in Fig. 5.3. Use procedural assignment and a
case statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output.

5.2.7 Design a Verilog model to implement the
behavior described by the 4-input truth table
in Fig. 5.4. Use procedural assignment and an
if-else statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output. Hint:
Notice that there are far more input codes pro-

Fig. 5.1 ducing F ¼ 1 than producing F ¼ 0. Can you
System I Functionality use this to your advantage to make your if-else

statement simpler?
5.2.2 Design a Verilog model to implement the

behavior described by the 4-input truth table
in Fig. 5.1. Use procedural assignment and a
case statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output.

5.2.3 Design a Verilog model to implement the
behavior described by the 4-input minterm list
in Fig. 5.2. Use procedural assignment and an
if-else statement. Declare the module to match
the block diagram provided. Use the type wire
for the inputs and type reg for the output.

Fig. 5.2
System J Functionality

5.2.4 Design a Verilog model to implement the
behavior described by the 4-input minterm list Fig. 5.4
in Fig. 5.2. Use procedural assignment and a System L Functionality
case statement. Declare the module to match
the block diagram provided. Use the type wire 5.2.8 Design a Verilog model to implement the
for the inputs and type reg for the output. behavior described by the 4-input truth table

5.2.5 Design a Verilog model to implement the in Fig. 5.4. Use procedural assignment and a
behavior described by the 4-input maxterm case statement. Declare the module to match
list in Fig. 5.3. Use procedural assignment the block diagram provided. Use the type wire
and an if-then statement. Declare the module for the inputs and type reg for the output.
to match the block diagram provided. Use the 5.2.9 Figure 5.5 shows the topology of a 4-bit shift
type wire for the inputs and type reg for the register when implemented structurally using
output. D-Flip-Flops. Design a Verilog model to



Exercise Problems • 87

describe this functionality using a single proce- 5.2.11 Design a Verilog model for a counter using a
dural block and non-blocking assignments for loop with an output type of reg[4:0].
instead of instantiating D-Flip-Flops. The figure Figure 5.7 shows the block diagram for the
also provides the block diagram for the module module definition. The counter should incre-
port definition. Use the type wire for the inputs ment from 000002 to 111112 and then start
and type reg for the outputs. over. Use delay in your loop to update the

counter value every 10 ns. Consider using the
loop variable of the for loop to generate an
integer version of your count value, and then
assign it to the output variable of type reg[4:0].

Fig. 5.7
5-Bit Binary Counter Block Diagram

Section 5.3: System Tasks
5.3.1 Are system tasks synthesizable? Why or why

not?

5.3.2 What is the difference between the tasks $dis-
Fig. 5.5 play() and $write()?
4-Bit Shift Register Block Diagram

5.3.3 What is the difference between the tasks $dis-
play() and $monitor()?

5.2.10 Design a Verilog model for a counter using a
for loop with an output type of integer. Fig- 5.3.4 What is the data type returned by the task
ure 5.6 shows the block diagram for the mod- $fopen()?
ule definition. The counter should increment
from 0 to 31 and then start over. Use delay in
your loop to update the counter value every
10 ns. Consider using the loop variable of the
for loop to generate your counter value.

Fig. 5.6
Integer Counter Block Diagram



Chapter 6: Test Benches
One of the essential components of the modern digital design flow is verifying functionality through

simulation. This functional verification is accomplished using a test bench. A test bench is a Verilog
model that instantiates the system to be tested as a subsystem, generates the input patterns to drive into
the subsystem, and observes the outputs. Test benches are only used for simulation, so they can use
abstract modeling techniques that are unsynthesizable to generate the stimulus patterns. Verilog
conditional programming constructions and system tasks can also be used to report on the status of a
test and also automatically check that the outputs are correct. This chapter provides the details of
Verilog’s built-in capabilities that allow test benches to be created and some examples of automated
stimulus generation.

Learning Outcomes—After completing this chapter, you will be able to:

6.1 Design a Verilog test bench that manually creates each stimulus pattern using a series of
signal assignments within a procedural block.

6.2 Design a Verilog test bench that uses for loops to automatically generate an exhaustive set
of stimulus patterns.

6.3 Design a Verilog test bench that automatically checks the outputs of the system being
tested using report and assert statements.

6.4 Design a Verilog test bench that uses external I/O as part of the testing procedures
including reading stimulus patterns from, and writing the results to, external files.

6.1 Test Bench Overview

A test bench is a file in Verilog that has no inputs or outputs. The test bench instantiates the system
to be tested as a lower-level module. The system being tested is often called a device under test (DUT) or
unit under test (UUT).

6.1.1 Generating Manual Stimulus

When creating stimulus for combinational logic circuits, it is common to use a procedural block to
generate all possible input patterns to drive the DUTand especially any transitions that may cause timing
errors. Example 6.1 shows how to create a simple test bench to verify the operation of a DUT called
SystemX. The test bench does not have any inputs or outputs; thus, there are no ports declared in the
module. SystemX is then instantiated (DUT) in the test bench. Internal signals of type reg are declared to
connect to the DUT inputs (A_TB, B_TB, C_TB) and an internal signal of type wire is declared to connect
to the DUToutput (F_TB). A procedural block is then used to generate the inputs of SystemX. Within the
procedural block, delayed assignments are used to control the timing of the input patterns. In this
example, each possible input code is generated within an initial block. The output (F_TB) is observed
using a simulation tool in either the form of a waveform or a table listing.

# Springer Nature Switzerland AG 2019 89
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5_6



90 • Chapter 6: Test Benches

Example 6.1
Test bench for a combinational logic circuit with manual stimulus generation

Multiple procedural blocks can be used within a Verilog test bench to provide parallel stimulus
generation. Using both initial and always blocks allows the test bench to drive both repetitive and
aperiodic signals. Initial and always blocks can also be used to drive the same signal in order to provide
a starting value and a repetitive pattern. Example 6.2 shows a test bench for a rising edge triggered
D-flip-flop with an asynchronous, active LOW reset in which multiple procedural blocks are used to
generate the stimulus patterns for the DUT.



6.1 Test Bench Overview • 91

Example 6.2
Test bench for a sequential logic circuit

6.1.2 Printing Results to the Simulator Transcript

In the past test bench examples, the input and output values are observed using either the
waveform or listing tool within the simulator tool. It is also useful to print the values of the simulation to
a transcript window to track the simulation as each statement is processed. Messages can be printed
that show the status of the simulation in addition to the inputs and outputs of the DUT using the text
output system tasks. Example 6.3 shows a test bench that prints the inputs and output to the transcript of
the simulation tool. Note that the test bench must wait some amount of delay before evaluating the
output, even if the DUT does not contain any delay.



92 • Chapter 6: Test Benches

Example 6.3
Printing test bench results to the transcript



6.2 Using Loops to Generate Stimulus • 93

CONCEPT CHECK

CC6.1 How can the output of a DUT be verified when it is connected to a signal that does not go
anywhere?

(A) It can’t. The output must be routed to an output port on the test bench.

(B) The values of any dangling signal are automatically written to a text file.

(C) It is viewed in the logic simulator as either a waveform or text listing.

(D) It can’t. A signal that does not go anywhere will cause an error during
simulation.

6.2 Using Loops to Generate Stimulus

When creating stimulus that follow regular patterns such as counting, loops can be an effective way
to produce the input vectors. A for loop is especially useful for generating exhaustive stimulus patterns
for combinational logic circuits. An integer loop variable can increment within the for loop and then be
assigned to the DUT inputs as type reg. Recall that in Verilog, when an integer is assigned to a variable of
type reg, it is truncated to match the size of the reg. This allows a binary count to be created for an input
stimulus pattern by using an integer loop variable that increments within a for loop. Example 6.4 shows
how the stimulus for a combinational logic circuit can be produced with a for loop.



94 • Chapter 6: Test Benches

Example 6.4
Using a loop to generate stimulus in a test bench

CONCEPT CHECK

CC6.2 If you used two nested for loops to generate an exhaustive set of patterns for the inputs
of an 8-bit adder, how many patterns would be generated? There is no carry-in bit.

(A) 16

(B) 256

(C) 512

(D) 65,536



6.3 Automatic Result Checking • 95

6.3 Automatic Result Checking

Test benches can also perform automated checking of the results using the conditional program-
ming constructs described earlier in this book. Example 6.5 shows an example of a test bench that uses
if-else statements to check the output of the DUTand print a PASS/FAIL message to the transcript.

Example 6.5
Test bench with automatic output checking



96 • Chapter 6: Test Benches

CONCEPT CHECK

CC6.3 Will the test bench approach of checking the results and then printing PASS/FAIL to the
transcript window stop the simulation?

(A) Yes. As soon as “FAIL” is printed, the simulation will halt.

(B) No. The printing of PASS/FAIL is just simple text and doesn’t influence the
simulation.

6.4 Using External Files in Test Benches

There are often cases where the results of a test bench need to be written to an external file, either
because they are too verbose for visual inspection or because there needs to be a stored record of the
system’s validation. Verilog allows writing to external files via the file I/O system tasks (i.e., $fdisplay(),
$fwrite(), $fstrong(), and $fmonitor()). Example 6.6 shows a test bench in which the input vectors and the
output of the DUT are written to an external file using the $fdisplay() system task.



6.4 Using External Files in Test Benches • 97

Example 6.6
Printing test bench results to an external file

It is often the case that the input vectors are either too large to enter manually or were created by a
separate program. In either case, a useful technique in test benches is to read input vectors from an
external file. Example 6.7 shows an example where the input stimulus vectors for a DUTare read from an
external file using the $readmemb() system task.



98 • Chapter 6: Test Benches

Example 6.7
Reading test bench stimulus vectors from an external file



Exercise Problems • 99

CONCEPT CHECK

CC6.4 What is an advantage of using external files as the input/output in test benches compared
to the built-in stimulus generation and reporting functionality within a Verilog module?

(A) External stimulus files allow more complex input stimulus vectors to be used.

(B) External output files allow more sophisticated post-processing of the results.

(C) External files allow much larger datasets to be used and analyzed.

(D) All of the above.

Summary

v A test bench is a way to simulate a device and also to read in stimulus vectors from an
under test (DUT) by instantiating it as a sub- external file.
system, driving in stimulus, and observing v Conditional programming constructs can be
the outputs. used within a test bench to perform automatic

v Test benches do not have inputs or outputs checking of the outputs of a DUTwithin a test
and are unsynthesizable. bench.

v Test benches for combinational logic typically v Loops can be used in test benches to auto-
exercise the DUT under an exhaustive set of matically generate stimulus patterns. A for
stimulus vectors. These include all possible loop is a convenient technique to produce a
logic inputs in addition to critical transitions counting pattern.
that could cause timing errors. v Assignment from an integer to a reg in a for

v Text I/O system tasks provide a way to print loop is allowed. The binary value of the inte-
the results of a test bench to the simulation ger is truncated to fit the size of the reg
tool transcript. vector.

v File I/O system tasks provide a way to print
the results of a test bench to an external file

Exercise Problems

Section 6.1: Test Bench Overview
6.1.1 What is the purpose of a test bench?

6.1.2 Does a test bench have input and output ports?

6.1.3 Can a test bench be simulated?

6.1.4 Can a test bench be synthesized?

6.1.5 Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 6.1. Your
test bench should drive in each input code for
the vector ABCD in the order they would
appear in a truth table (i.e., “0000,” “0001,”
“0010,” . . .). Your test bench should use a pro-
cedural block and individual signal
assignments for each pattern. Your test bench
should change the input pattern every 10 ns.

Fig. 6.1
System I Functionality



100 • Chapter 6: Test Benches

6.1.6 Design a Verilog test bench to verify the func- Section 6.2: Generating Stimulus Vectors
tional operation of the system in Fig. 6.2. Your Using for Loops
test bench should drive in each input code for
the vector ABCD in the order they would 6.2.1 Design a Verilog test bench to verify the func-
appear in a truth table (i.e., “0000,” “0001,” tional operation of the system in Fig. 6.1. Your
“0010,” test bench should drive in each input code for

. . .). Your test bench should use a pro-
cedural block and individual signal the vector ABCD in the order they would
assignments for each pattern. Your test bench appear in a truth table (i.e., “0000,” “0001,”
should change the input pattern every 10 ns. “0010,” . . .). Your test bench should use a sin-

gle for loop within a procedural block to gener-
ate all of the stimulus patterns automatically.
Your test bench should change the input pat-
tern every 10 ns.

6.2.2 Design a Verilog test bench to verify the func-
tional operation of the system in Fig. 6.2. Your

Fig. 6.2 test bench should drive in each input code for
System J Functionality the vector ABCD in the order they would

appear in a truth table (i.e., “0000,” “0001,”
6.1.7 Design a Verilog test bench to verify the func- “0010,” . . .). Your test bench should use a sin-

tional operation of the system in Fig. 6.3. Your gle for loop within a procedural block to gener-
test bench should drive in each input code for ate all of the stimulus patterns automatically.
the vector ABCD in the order they would Your test bench should change the input pat-
appear in a truth table (i.e., “0000,” “0001,” tern every 10 ns.
“0010,” . . .). Your test bench should use a pro-

6.2.3 Design a Verilog test bench to verify the func-
cedural block and individual signal

tional operation of the system in Fig. 6.3. Your
assignments for each pattern. Your test bench

test bench should drive in each input code for
should change the input pattern every 10 ns.

the vector ABCD in the order they would
appear in a truth table (i.e., “0000,” “0001,”
“0010,” . . .). Your test bench should use a sin-
gle for loop within a procedural block to gener-
ate all of the stimulus patterns automatically.

Fig. 6.3 Your test bench should change the input pat-

System K Functionality tern every 10 ns.

6.2.4 Design a Verilog test bench to verify the func-
6.1.8 Design a Verilog test bench to verify the func- tional operation of the system in Fig. 6.4. Your

tional operation of the system in Fig. 6.4. Your test bench should drive in each input code for
test bench should drive in each input code for the vector ABCD in the order they would
the vector ABCD in the order they would appear in a truth table (i.e., “0000,” “0001,”
appear in a truth table (i.e., “0000,” “0001,” “0010,” . . .). Your test bench should use a sin-
“0010,” . . .). Your test bench should use a pro- gle for loop within a procedural block to gener-
cedural block and individual signal ate all of the stimulus patterns automatically.
assignments for each pattern. Your test bench Your test bench should change the input pat-
should change the input pattern every 10 ns. tern every 10 ns.

6.2.5 Design a Verilog model for an 8-bit Ripple
Carry Adder (RCA) using a structural design
approach. This involves creating a half adder
(half_adder.v), full adder (full_adder.v), and
then finally a top-level adder (rca.v) by
instantiating eight full adder subsystems.
Model the ripple delay by inserting 1 ns of
gate delay for the XOR, AND, and OR
operators using a delayed signal assignment.
The general topology and module definition for
the design are shown in Example 4.8. Design a
Verilog test bench to exhaustively verify this
design under all input conditions. Your test
bench should use two nested for loops within
a procedural block to generate all of the stimu-
lus patterns automatically. Your test bench
should change the input pattern every 30 ns
in order to give sufficient time for the signals to
ripple through the adder.

Fig. 6.4
System L Functionality



Exercise Problems • 101

Section 6.3: Automated Result Checking Section 6.4: Using External Files in Test
6.3.1 Design a Verilog test bench to verify the func- Benches

tional operation of the system in Fig. 6.1. Your 6.4.1 Design a Verilog test bench to verify the func-
test bench should drive in each input code for tional operation of the system in Fig. 6.1. Your
the vector ABCD in the order they would test bench read in the input patterns from an
appear in a truth table (i.e., “0000,” “0001,” external file called “input.txt.” This file should
“0010,” . . .). Your test bench should change contain an exhaustive list of input patterns for
the input pattern every 10 ns. Your test bench the vector ABCD in the order they would
should include automatic result checking for appear in a truth table (i.e., “0000,” “0001,”
each input pattern and then print either “0010,” . . .). Your test bench should read in a
“PASS” or “FAIL” depending on the output of new input pattern every 10 ns. Your test bench
the DUT. should write the input pattern and the

6.3.2 Design a Verilog test bench to verify the func- corresponding output of the DUT to an external
tional operation of the system in Fig. 6.2. Your file called “output.txt.”
test bench should drive in each input code for 6.4.2 Design a Verilog test bench to verify the func-
the vector ABCD in the order they would tional operation of the system in Fig. 6.2. Your
appear in a truth table (i.e., “0000,” “0001,” test bench read in the input patterns from an
“0010,” . . .). Your test bench should change external file called “input.txt.” This file should
the input pattern every 10 ns. Your test bench contain an exhaustive list of input patterns for
should include automatic result checking for the vector ABCD in the order they would
each input pattern and then print either appear in a truth table (i.e., “0000,” “0001,”
“PASS” or “FAIL” depending on the output of “0010,” . . .). Your test bench should read in a
the DUT. new input pattern every 10 ns. Your test bench

6.3.3 Design a Verilog test bench to verify the func- should write the input pattern and the
tional operation of the system in Fig. 6.3. Your corresponding output of the DUT to an external
test bench should drive in each input code for file called “output.txt.”
the vector ABCD in the order they would 6.4.3 Design a Verilog test bench to verify the func-
appear in a truth table (i.e., “0000,” “0001,” tional operation of the system in Fig. 6.3. Your
“0010,” . . .). Your test bench should change test bench read in the input patterns from an
the input pattern every 10 ns. Your test bench external file called “input.txt.” This file should
should include automatic result checking for contain an exhaustive list of input patterns for
each input pattern and then print either the vector ABCD in the order they would
“PASS” or “FAIL” depending on the output of appear in a truth table (i.e., “0000,” “0001,”
the DUT. “0010,” . . .). Your test bench should read in a

6.3.4 Design a Verilog test bench to verify the func- new input pattern every 10 ns. Your test bench
tional operation of the system in Fig. 6.4. Your should write the input pattern and the
test bench should drive in each input code for corresponding output of the DUT to an external
the vector ABCD in the order they would file called “output.txt.”
appear in a truth table (i.e., “0000,” “0001,” 6.4.4 Design a Verilog test bench to verify the func-
“0010,” . . .). Your test bench should change tional operation of the system in Fig. 6.4. Your
the input pattern every 10 ns. Your test bench test bench read in the input patterns from an
should include automatic result checking for external file called “input.txt.” This file should
each input pattern and then print either contain an exhaustive list of input patterns for
“PASS” or “FAIL” depending on the output of the vector ABCD in the order they would
the DUT. appear in a truth table (i.e., “0000,” “0001,”

“0010,” . . .). Your test bench should read in a
new input pattern every 10 ns. Your test bench
should write the input pattern and the
corresponding output of the DUT to an external
file called “output.txt.”



Chapter 7: Modeling Sequential
Storage and Registers

In this chapter, we will look at modeling sequential storage devices. We begin by looking at modeling
scalar storage devices such as D-latches and D-flip-flops and then move into multiple-bit storage models
known as registers.

Learning Outcomes—After completing this chapter, you will be able to:

7.1 Design a Verilog model for a single-bit sequential logic storage device.
7.2 Design a Verilog model for a register.

7.1 Modeling Scalar Storage Devices

7.1.1 D-Latch

Let’s begin with the model of a simple D-Latch. Since the outputs of this sequential storage device
are not updated continuously, its behavior is modeled using a procedural assignment. Since we want to
create a synthesizable model of sequential logic, non-blocking assignments are used. In the sensitivity
list, we need to include the C input since it controls when the D-Latch is in track or store mode. We also
need to include the D input in the sensitivity list because during the track mode, the output Q will be
assigned the value of D, so any change on D needs to trigger the procedural assignments. The use of an
if-else statement is used to model the behavior during track mode (C ¼ 1). Since the behavior is not
explicitly stated for when C ¼ 0, the outputs will hold their last value, which allows us to simply omit the
else portion of the if statement to complete the model. Example 7.1 shows the behavioral model for a
D-Latch.

Example 7.1
Behavioral model of a D-Latch in Verilog

7.1.2 D-Flip-Flop

The rising edge behavior of a D-Flip-Flop is modeled using a (posedge Clock) Boolean condition in
the sensitivity list of a procedural block. Example 7.2 shows the behavioral model for a rising edge
triggered D-Flip-Flop with both Q and Qn outputs.

# Springer Nature Switzerland AG 2019 103
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5_7



104 • Chapter 7: Modeling Sequential Storage and Registers

Example 7.2
Behavioral model of a D-Flip-Flop in Verilog

7.1.3 D-Flip-Flop with Asynchronous Reset

D-Flip-Flops typically have a reset line to initialize their outputs to known states (e.g., Q ¼ 0,
Qn ¼ 1). Resets are asynchronous, meaning whenever they are asserted, assignments to the outputs
takes place immediately. If a reset was synchronous, the outputs would only update on the next rising
edge of the clock. This behavior is undesirable because if there is a system failure, there is no guarantee
that a clock edge will ever occur. Thus, the reset may never take place. Asynchronous resets are more
desirable not only to put the D-Flip-Flops into a known state at startup, but also to recover from a system
failure that may have impacted the clock signal. In order to model this asynchronous behavior, the reset
signal is included in the sensitivity list. This allows both clock and the reset transitions to trigger the
procedural block. The edge sensitivity of the reset can be specified using posedge (active HIGH) or
negedge (active LOW). Within the block an if-else statement is used to determine whether the reset has
been asserted or a rising edge of the clock has occurred. The if-else statement first checks whether the
reset input has been asserted since it has the highest priority. If it has, it makes the appropriate
assignments to the outputs (Q ¼ 0, Qn ¼ 1). If the reset has not been asserted, the else clause is
executed, which corresponds to a rising edge of clock (Q <¼ D, Qn <¼ ~D). No other assignments are
listed in the block; thus, the outputs are only updated on a transition of the reset or clock. At all other
times the outputs remain at their current value, thus modeling the store behavior of the D-Flip-Flop.
Example 7.3 shows the behavioral model for a rising edge triggered D-Flip-Flop with an asynchronous,
active LOW reset.



7.1 Modeling Scalar Storage Devices • 105

Example 7.3
Behavioral model of a D-Flip-Flop with asynchronous reset in Verilog

7.1.4 D-Flip-Flop with Asynchronous Reset and Preset

A D-Flip-Flop with both an asynchronous reset and asynchronous preset is handled in a similar
manner as the D-Flip-Flop in the prior section. The preset input is included in the sensitivity list in order to
trigger the block whenever a transition occurs on either the clock, reset, or preset inputs. The edge
sensitivity keywords are used to dictate whether the preset is active HIGH or LOW. Nested if-else
statements are used to first check whether a reset has occurred, then whether a preset has occurred,
and finally whether a rising edge of the clock has occurred. Example 7.4 shows the model for a rising
edge triggered D-Flip-Flop with asynchronous, active LOW reset and preset.



106 • Chapter 7: Modeling Sequential Storage and Registers

Example 7.4
Behavioral model of a D-Flip-Flop with asynchronous reset and preset in Verilog

7.1.5 D-Flip-Flop with Synchronous Enable

An enable input is also a common feature of modern D-Flip-Flops. Enable inputs are synchronous,
meaning that when they are asserted, action is only taken on the rising edge of the clock. This means
that the enable input is not included in the sensitivity list of the always block. Since enable is only
considered when there is a rising edge of the clock, the logic for the enable is handled in a nested if-else
statement that is included in the section that models the behavior for when a rising edge of clock is
detected. Example 7.5 shows the model for a D-Flip-Flop with a synchronous enable (EN) input. When
EN ¼ 1, the D-Flip-Flop is enabled, and assignments are made to the outputs only on the rising edge of
the clock. When EN¼ 0, the D-Flip-Flop is disabled and assignments to the outputs are not made. When
disabled, the D-Flip-Flop effectively ignores rising edges on the clock and the outputs remain at their last
values.



7.2 Modeling Registers • 107

Example 7.5
Behavioral model of a D-Flip-Flop with synchronous enable in Verilog

CONCEPT CHECK

CC7.1 Why is the D input not listed in the sensitivity list of a D-flip-flop?

(A) To simplify the behavioral model.

(B) To avoid a setup time violation if D transitions too closely to the clock.

(C) Because a rising edge of clock is needed to make the assignment.

(D) Because the outputs of the D-flip-flop are not updated when D changes.

7.2 Modeling Registers

7.2.1 Registers with Enables

The term register describes a circuit that operates in a similar manner as a D-Flip-Flop with the
exception that the input and output data are vectors. This circuit is implemented with a set of D-Flip-Flops
all connected to the same clock, reset, and enable inputs. A register is a higher level of abstraction that
allows vector data to be stored without getting into the details of the lower-level implementation of the D-
Flip-Flop components. Register Transfer Level (RTL) modeling refers to a level of design abstraction in
which vector data is moved and operated on in a synchronous manner. This design methodology is



108 • Chapter 7: Modeling Sequential Storage and Registers

widely used in data path modeling and computer system design. Example 7.6 shows an RTL model of an
8-bit, synchronous register. This circuit has an active LOW, asynchronous reset that will cause the 8-bit
output Reg_Out to go to 0 when it is asserted. When the reset is not asserted, the output will be updated
with the 8-bit input Reg_In if the system is enabled (EN¼ 1) and there is a rising edge on the clock. If the
register is disabled (EN ¼ 0), the input clock is ignored. At all other times, the output holds its last value.

Example 7.6
RTL model of an 8-bit register in Verilog

7.2.2 Shift Registers

A shift register is a circuit which consists of multiple registers connected in series. Data is shifted
from one register to another on the rising edge of the clock. This type of circuit is often used in serial-to-
parallel data converters. Example 7.7 shows an RTL model for a 4-stage, 8-bit shift register. In the
simulation waveform, the data is shown in hexadecimal format.



7.2 Modeling Registers • 109

Example 7.7
RTL model of a 4-stage, 8-bit shift register in Verilog

7.2.3 Registers as Agents on a Data Bus

One of the powerful topologies that registers can easily model is a multi-drop bus. In this topology,
multiple registers are connected to a data bus as receivers, or agents. Each agent has an enable line that
controls when it latches information from the data bus into its storage elements. This topology is
synchronous, meaning that each agent and the driver of the data bus is connected to the same clock
signal. Each agent has a dedicated, synchronous enable line that is provided by a system controller
elsewhere in the design. Example 7.8 shows this multi-drop bus topology. In this example system, three
registers (A, B, and C) are connected to a data bus as receivers. Each register is connected to the same
clock and reset signals. Each register has its own dedicated enable line (A_EN, B_EN, and C_EN).



110 • Chapter 7: Modeling Sequential Storage and Registers

Example 7.8
Registers as agents on a data bus—system topology

This topology can be modeled using RTL abstraction by treating each register as a separate
procedural block. Example 7.9 shows how to describe this topology with an RTL model in Verilog. Notice
that the three-procedural blocks modeling the A, B, and C registers are nearly identical to each other
except for the signal names they use.

Example 7.9
Registers as agents on a data bus—RTL model in Verilog

Example 7.10 shows the resulting simulation waveform for this system. Each register is updated
with the value on the data bus whenever its dedicated enable line is asserted.



Summary • 111

Example 7.10
Registers as agents on a data bus—simulation waveform

CONCEPT CHECK

CC7.2 Does RTL modeling synthesize as combinational logic, sequential logic, or both? Why?

(A) Combinational logic. Since only one process is used for each register, it will be
synthesized using basic gates.

(B) Sequential logic. Since the sensitivity list contains clock and reset, it will
synthesize into only D-flip-flops.

(C) Both. The model has a sensitivity list containing clock and reset and uses an
if-else statement indicative of a D-flip-flop. This will synthesize a D-flip-flop to
hold the value for each bit in the register. In addition, the ability to manipulate
the inputs into the register (using either logical operators, arithmetic
operators, or choosing different signals to latch) will synthesize into combi-
national logic in front of the D input to each D-flip-flop.

Summary

v A synchronous system is modeled with a a nested if-else statement within the main
procedural block and a sensitivity list. The procedural block’s if-else statement. The
clock and reset signals are always listed by nested if-else goes beneath the clause for
themselves in the sensitivity list. Within the the synchronous signal assignments.
block is an if-else statement. The if clause of v Registers are modeled in Verilog in a similar
the statement handles the asynchronous manner to a D-flip-flop with a synchronous
reset condition while the else clause handles enable. The only difference is that the inputs
the synchronous signal assignments. and outputs are vectors.

v Edge sensitivity is modeled within a proce- v Register Transfer Level, or RTL, modeling
dural block using the (posedge Clock or provides a higher level of abstraction for
negedge reset) syntax in the sensitivity lists. moving and manipulating vectors of data in

v Most D-flip-flops and registers contain a syn- a synchronous manner.
chronous enable line. This is modeled using



112 • Chapter 7: Modeling Sequential Storage and Registers

Exercise Problems

Section 7.1: Modeling Scalar Storage
Devices
7.1.1 How does a Verilog model for a D-flip-flop han-

dle treating reset as the highest priority input?

7.1.2 For a Verilog model of a D-flip-flop with a syn-
chronous enable (EN), why isn’t EN listed in
the sensitivity list?

7.1.3 For a Verilog model of a D-flip-flop with a syn-
chronous enable (EN), what is the impact of
listing EN in the sensitivity list?

7.1.4 For a Verilog model of a D-flip-flop with a syn-
chronous enable (EN), why is the behavior of
the enable modeled using a nested if-else
statement under the else clause handling the
logic for the clock edge input?

Section 7.2: Modeling Registers Fig. 7.2

7.2.1 In register transfer level modeling, how does 16-Bit Shift Register Block Diagram
the width of the register relate to the number of

7.2.5 Design a Verilog RTL model of the multi-drop
D-flip-flops that will be synthesized?

bus topology in Fig. 7.3. Each of the 16-bit
7.2.2 In register transfer level modeling, how is the registers (RegA, RegB, RegC, and RegD) will

synchronous data movement managed if all latch the contents of the 16-bit data bus if their
registers are using the same clock? enable line is asserted. Each register should be

7.2.3 Design a Verilog RTL model of a 32-bit, syn- modeled using an individual procedural block.
chronous register. The block diagram for the
port definition is shown in Fig. 7.1. The register
has a synchronous enable. The register should
be modeled using a single procedural block.

Fig. 7.1
32-Bit Register Block Diagram

7.2.4 Design a Verilog RTL model of an 8-stage,
16-bit shift register. The block diagram for the
port definition is shown in Fig. 7.2. Each stage
of the shift register will be provided as an out-
put of the system (A, B, C, D, E, F, G, and H).
The shift register should be modeled using a
single procedural block.

Fig. 7.3
Agents on a Bus Block Diagram



Chapter 8: Modeling Finite State
Machines

In this chapter, we will look at modeling finite state machines (FSMs). An FSM is one of the most
powerful circuits in a digital system because it can make decisions about the next output based on both
the current and past inputs. Finite state machines are modeled using the constructs already covered in
this book. In this chapter, we will look at the widely accepted three-process model for designing a FSM.

Learning Outcomes—After completing this chapter, you will be able to:

8.1 Describe the three-process modeling approach for FSM design.
8.2 Design a Verilog model for a FSM from a state diagram.

8.1 The FSM Design Process and a Push-Button Window
Controller Example

The most common modeling practice for FSMs is to declare two signals of type reg that are called
current_state and next_state. Then a parameter is declared for each descriptive state name in the state
diagram. A parameter also requires a value, so the state encoding can be accomplished during the
parameter declaration. Once the signals and parameters are created, all of the procedural assignments
in the state machine model can use the descriptive state names in their signal assignments. Within the
Verilog state machine model, three separate procedural blocks are used to describe each of the
functional blocks, state memory, next state logic, and output logic. In order to examine how to model a
finite state machine using this approach, let’s use the push-button window controller example from
Chap. 7. Example 8.1 gives the overview of the design objectives for this example and the state diagram
describing the behavior to be modeled in Verilog.

# Springer Nature Switzerland AG 2019 113
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5_8



114 • Chapter 8: Modeling Finite State Machines

Example 8.1
Push-button window controller in Verilog—design description

Let’s begin by defining the ports of the module. The system has an input called Press and two
outputs called Open_CW and Close_CCW. The system also has clock and reset inputs. We will design
the system to update on the rising edge of the clock and have an asynchronous, active LOW, reset.
Example 8.2 shows the port definitions for this example. Note that outputs are declared as type reg while
inputs are declared as type wire.

Example 8.2
Push-button window controller in Verilog—port definition

8.1.1 Modeling the States

Now we begin designing the finite state machine in Verilog using behavioral modeling constructs.
The first step is to create two signals that will be used for the state variables. In this text we will always
name these signals current_state and next_state. The signal current_state will represent the outputs of
the D-flip-flops forming the state memory and will hold the current state code. The signal next_state will
represent the D inputs to the D-flip-flops forming the state memory and will receive the value from the
next state logic circuitry. Since the FSM will be modeled using procedural assignment, both of these



8.1 The FSM Design Process and a Push-Button Window Controller Example • 115

signals will be declared of type reg. The width of the reg vector depends on the number of states in the
machine and the encoding technique chosen. The next step is to declare parameters for each of the
descriptive state names in the state diagram. The state encoding must be decided at this point. The
following syntax shows how to declare the current_state and next_state signals and the parameters.
Note that since this machine only has two states, the width of these signals is only 1-bit.

reg current_state, next_state;
parameter w_closed ¼ 1’b0,

w_open ¼ 1’b1;

8.1.2 The State Memory Block

Now that we have variables and parameters for the states of the FSM, we can create the model for
the state memory. State memory is modeled using its own procedural block. This block models the
behavior of the D-Flip-Flops in the FSM that are holding the current state on their Q outputs. Each time
there is a rising edge of the clock, the current state is updated with the next state value present on the D
inputs of the D-Flip-Flops. This block must also model the reset condition. For this example, we will have
the state machine go to the w_closed state when Reset is asserted. At all other times, the block will
simply update current_state with next_state on every rising edge of the clock. The block model is very
similar to the model of a D-Flip-Flop. This is as expected since this block will synthesize into one or more
D-Flip-Flops to hold the current state. The sensitivity list contains only Clock and Reset and assignments
are only made to the signal current_state. The following syntax shows how to model the state memory of
this FSM example.

always @ (posedge Clock or negedge Reset)
begin: STATE_MEMORY

if (!Reset)
current_state <¼ w_closed;

else
current_state <¼ next_state;

end

8.1.3 The Next State Logic Block

Now we model the next state logic of the FSM using a second procedural block. Recall that the next
state logic is combinational logic; thus, we need to include all of the input signals that the circuit considers
in the next state calculation in the sensitivity list. The current_state signal will always be included in the
sensitivity list of the next state logic block in addition to any inputs to the system. For this example, the
system has one other input called Press. This block makes assignments to the next_state signal. It is
common to use a case statement to separate out the assignments that occur at each state. At each state
within the case statement, an if-else statement is used to model the assignments for different input
conditions on Press. The following syntax shows how to model the next state logic of this FSM example.
Notice that we include a default clause in the case statement to ensure that the state machine has a path
back to the reset state in the case of an unexpected fault.

always @ (current_state or Press)
begin: NEXT_STATE_LOGIC
case (current_state)
w_closed : if (Press¼¼1’b1) next_state¼ w_open; else next_state¼ w_closed;
w_open : if (Press ¼¼ 1’b1) next_state ¼ w_closed; else next_state ¼ w_open;
default : next_state ¼ w_closed;

endcase
end



116 • Chapter 8: Modeling Finite State Machines

8.1.4 The Output Logic Block

Now we model the output logic of the FSM using a third procedural block. Recall that output logic is
combinational logic; thus, we need to include all of the input signals that this circuit considers in the
output assignments. The current_state will always be included in the sensitivity list. If the FSM is a Mealy
machine, then the system inputs will also be included in the sensitivity list. If the machine is a Moore
machine, then only the current_state will be present in the sensitivity list. For this example, the FSM is a
Mealy machine, so the input Press needs to be included in the sensitivity list. Note that this block only
makes assignments to the outputs of the machine (Open_CW and Close_CCW). The following syntax
shows how to model the output logic of this FSM example. Again, we include a default clause to ensure
that the state machine has explicit output behavior in the case of a fault.

always @ (current_state or Press)
begin: OUTPUT_LOGIC

case (current_state)
w_closed : if (Press ¼¼ 1’b1)

begin
Open_CW ¼ 1’b1;
Close_CCW ¼ 1’b0;

end
else
begin

Open_CW ¼ 1’b0;
Close_CCW ¼ 1’b0;

end
w_open : if (Press ¼¼ 1’b1)

begin
Open_CW ¼ 1’b0;
Close_CCW ¼ 1’b1;

end
else
begin

Open_CW ¼ 1’b0;
Close_CCW ¼ 1’b0;

end
default : begin

Open_CW ¼ 1’b0;
Close_CCW ¼ 1’b0;

end
endcase

end

Putting this all together yields a behavioral model for the FSM that can be simulated and
synthesized. Example 8.3 shows the entire model for this example.



8.1 The FSM Design Process and a Push-Button Window Controller Example • 117

Example 8.3
Push-button window controller in Verilog—full model

Example 8.4 shows the simulation waveform for this state machine. This functional simulation was
performed using ModelSim-Altera Starter Edition 10.1d. A macro file was used to display the current and
next state variables using their parameter names instead of their state codes. This allows the functional-
ity of the FSM to be more easily observed. This approach will be used for the rest of the FSM examples in
this book.



118 • Chapter 8: Modeling Finite State Machines

Example 8.4
Push-button window controller in Verilog—simulation waveform

8.1.5 Changing the State Encoding Approach

In the prior example we had two states that were encoded as: w_closed ¼ 1’b0; w_open_1’b1. This
encoding technique is considered binary and takes 1-bit; however, a one-hot could be adopted that
would require 2-bits. The way that state variables and state codes are assigned in Verilog makes is
straightforward to change the state codes. The only consideration that must be made is expanding the
size of the current_state and next_state variables to accommodate the new state codes. The following
example shows how the state encoding would look if a one-hot approach was used (w_closed ¼ 2’b01;
w_open_2’b10). Note that the state variables now must be two bits wide. This means the state variables
need to be declared as type reg[1:0]. Example 8.5 shows the resulting simulation waveforms. The
simulation waveform shows the value of the state codes instead of the state names.

reg [1:0] current_state, next_state;
parameter w_closed ¼ 2’b01,

w_open ¼ 2’b10;

Example 8.5
Push-button window controller in Verilog—changing state codes



8.2 FSM Design Examples • 119

CONCEPT CHECK

CC8.1 Why is it always a good design approach to model a generic finite state machine using
three processes?

(A) For readability.

(B) So that it is easy to identify whether the machine is a Mealy or Moore.

(C) So that the state memory process can be reused in other FSMs.

(D) Because each of the three subsystems of a FSM has unique inputs and
outputs that should be handled using dedicated processes.

8.2 FSM Design Examples

This section presents a set of example finite state machine designs using the behavioral modeling
constructs of Verilog.

8.2.1 Serial Bit Sequence Detector in Verilog

Let’s look at the design of the serial bit sequence detector finite state machine using the behavioral
modeling constructs of Verilog. Example 8.6 shows the design description and port definition for this
state machine.

Example 8.6
Serial bit sequence detector in Verilog—design description and port definition



120 • Chapter 8: Modeling Finite State Machines

Example 8.7 shows the full model for the serial bit sequence detector. Notice that the states are
encoded in binary, which requires three bits for the variables current_state and next_state.

Example 8.7
Serial bit sequence detector in Verilog—full model



8.2 FSM Design Examples • 121

Example 8.8 shows the functional simulation waveform for this design.

Example 8.8
Serial bit sequence detector in Verilog—simulation waveform

8.2.2 Vending Machine Controller in Verilog

Let’s now look at the design of the vending machine controller using the behavioral modeling
constructs of Verilog. Example 8.9 shows the design description and port definition.

Example 8.9
Vending machine controller in Verilog—design description and port definition

Example 8.10 shows the full model for the vending machine controller. In this model, the descriptive
state names Wait, 25¢, and 50¢ cannot be used directly. This is because Verilog user-defined names
cannot begin with a number. Instead, the letter “s” is placed in front of the state names in order to make
them legal Verilog names (i.e., sWait, s25, s50).



122 • Chapter 8: Modeling Finite State Machines

Example 8.10
Vending machine controller in Verilog—full model



8.2 FSM Design Examples • 123

Example 8.11 shows the resulting simulation waveform for this design.

Example 8.11
Vending machine controller in Verilog—simulation waveform

8.2.3 2-Bit, Binary Up/Down Counter in Verilog

Let’s now look at how a simple counter can be implemented using the three-block behavioral
modeling approach in Verilog. Example 8.12 shows the design description and port definition for the
2-bit, binary up/down counter FSM from Chap. 7.

Example 8.12
2-Bit up/down counter in Verilog—design description and port definition

Example 8.13 shows the full model for the 2-bit up/down counter using the three-block modeling
approach. Since a counter’s outputs only depend on the current state, counters are Moore machines.
This simplifies the output logic block since it only needs to contain the current state in its sensitivity list.



124 • Chapter 8: Modeling Finite State Machines

Example 8.13
2-Bit up/down counter in Verilog—full model (three-block approach)

Example 8.14 shows the resulting simulation waveform for this counter finite state machine.

Example 8.14
2-Bit up/down counter in Verilog—simulation waveform



Exercise Problems • 125

CONCEPT CHECK

CC8.2 The procedural block for the state memory is nearly identical for all finite state machines
with one exception. What is it?

(A) The sensitivity list may need to include a preset signal.

(B) Sometimes it is modeled using an SR latch storage approach instead of with
D-flip-flop behavior.

(C) The name of the reset state will be different.

(D) The current_state and next_state signals are often swapped.

Summary

v Generic finite state machines are modeled is defined for each unique state in the
using three separate procedural blocks that machine with the state name and desired
describe the behavior of the next state logic, state code. Throughout the rest of the
the state memory, and the output logic. Sep- model, the unique state names can be used
arate blocks are used because each of the as both assignments to current_state/
three functions in a FSM are dependent on next_state and as inputs in case and if-else
different input signals. statements. This approach allows the model

v In Verilog, descriptive state names can be to be designed using readable syntax while
created for a FSM using parameters. Two providing a synthesizable design.
signals are first declared called current_state
and next_state of type reg. Then a parameter

Exercise Problems

Section 8.1: The FSM Design Process are listed in the sensitivity list of the next state
logic block?

8.1.1 What is the advantage of using parameters for
the state when modeling a finite state 8.1.7 When using the three-procedural block behav-
machine? ioral modeling approach for FSMs, what inputs

are listed in the sensitivity list of the state mem-
8.1.2 What is the advantage of having to assign the

ory block?
state codes during the parameter declaration
for the state names when modeling a finite 8.1.8 When using the three-procedural block behav-
state machine? ioral modeling approach for FSMs, what inputs

are listed in the sensitivity list of the output logic
8.1.3 When using the three-procedural block behav-

block?
ioral modeling approach for FSMs, does the
next state logic block model combinational or 8.1.9 When using the three-procedural block behav-
sequential logic? ioral modeling approach for FSMs, how can the

signals listed in the sensitivity list of the output
8.1.4 When using the three-procedural block behav-

logic block immediately indicate whether the
ioral modeling approach for FSMs, does the

FSM is a Mealy or a Moore machine?
state memory block model combinational or
sequential logic? 8.1.10 Why is it not a good design approach to com-

bine the next state logic and output logic
8.1.5 When using the three-procedural block behav-

behavior into a single procedural block?
ioral modeling approach for FSMs, does the
output logic block model combinational or
sequential logic? Section 8.2: FSM Design Examples

8.1.6 When using the three-procedural block behav- 8.2.1 Design a Verilog behavioral model to imple-
ioral modeling approach for FSMs, what inputs ment the finite state machine described by

the state diagram in Fig. 8.1. Use the port



126 • Chapter 8: Modeling Finite State Machines

definition provided in this figure for your design.
Use the three-block approach to modeling
FSMs described in this chapter for your design.
Model the state variables using parameters
and encode the states in binary using the fol-
lowing state codes: Start¼ “00,”Midway¼ “01,”
Done ¼ “10.”

Fig. 8.2
FSM 2 State Diagram and Port Definition

8.2.4 Design a Verilog behavioral model to imple-
Fig. 8.1 ment the finite state machine described by
FSM 1 State Diagram and Port Definition the state diagram in Fig. 8.2. Use the port

definition provided in this figure for your design.
8.2.2 Design a Verilog behavioral model to imple- Use the three-block approach to modeling

ment the finite state machine described by FSMs described in this chapter for your design.
the state diagram in Fig. 8.1. Use the port Model the state variables using parameters
definition provided in this figure for your design. and encode the states in one-hot using the
Use the three-block approach to modeling following state codes: S0 ¼ “0001,”
FSMs described in this chapter for your design. S1 ¼ “0010,” S2 ¼ “0100,” and S3 ¼ “1000.”
Model the state variables using parameters 8.2.5 Design a Verilog behavioral model for a 4-bit
and encode the states in one-hot using the serial bit sequence detector similar to Example
following state codes: Start ¼ “001,” Mid- 8.6. Use the port definition provided in Fig. 8.3.
way ¼ “010,” Done ¼ “100.” Use the three-block approach to modeling

8.2.3 Design a Verilog behavioral model to imple- FSMs described in this chapter for your design.
ment the finite state machine described by The input to your sequence detector is called
the state diagram in Fig. 8.2. Use the port DIN and the output is called FOUND. Your
definition provided in this figure for your design. detector will assert FOUND anytime there is a
Use the three-block approach to modeling 4-bit sequence of “0101.” Model the states in
FSMs described in this chapter for your design. this machine with parameters. Choose any
Model the state variables using parameters state encoding approach you wish.
and encode the states in binary using the fol-
lowing state codes: S0 ¼ “00,” S1 ¼ “01,”
S2 ¼ “10,” and S3 ¼ “11.”



Exercise Problems • 127

8.2.7 Design a Verilog behavioral model for a finite
state machine for a traffic light controller. Use
the port definition provided in Fig. 8.5. This
time, you will implement the functionality
using the behavioral modeling techniques
presented in this chapter. Your FSM will control
a traffic light at the intersection of a busy high-
way and a seldom used side road. You will be

Fig. 8.3 designing the control signals for just the red,
Sequence Detector Port Definition yellow, and green lights facing the highway.

Under normal conditions, the highway has a

8.2.6 Design a Verilog behavioral model for a 20-¢ green light. The side road has car detector

vending machine controller similar to Example that indicates when car pulls up by asserting

8.9. Use the port definition provided in Fig. 8.4. a signal called CAR. When CAR is asserted,

Use the three-block approach to modeling you will change the highway traffic light from

FSMs described in this chapter for your design. green to yellow, and then from yellow to red.

Your controller will take in nickels and dimes Once in the red position, a built-in timer will

and dispense a product anytime the customer begin a countdown and provide your controller

has entered 20¢. Your FSM has two inputs,Nin a signal called TIMEOUT when 15 s has

and Din. Nin is asserted whenever the cus- passed. Once TIMEOUT is asserted, you will

tomer enters a nickel while Din is asserted change the highway traffic light back to green.

anytime the customer enters a dime. Your Your system will have three outputs GRN,

FSM has two outputs, Dispense and Change. YLW, and RED, which control when the high-

Dispense is asserted anytime the customer way facing traffic lights are on (1 ¼ ON,

has entered at least 20¢ and Change is 0 ¼ OFF). Model the states in this machine

asserted anytime the customer has entered with parameters. Choose any state encoding

more than 20¢ and needs a nickel in change. approach you wish.

Model the states in this machine with
parameters. Choose any state encoding
approach you wish.

Fig. 8.5
Traffic Light Controller Port Definition

Fig. 8.4
Vending Machine Port Definition



Chapter 9: Modeling Counters
Counters are a special case of finite state machines because they move linearly through their

discrete states (either forward or backwards) and typically are implemented with state-encoded outputs.
Due to this simplified structure and widespread use in digital systems, Verilog allows counters to be
modeled using a single procedural block with arithmetic operators (i.e., + and ). This enables a more
compact model and allows much wider counters to be implemented in a practical manner. This chapter
will cover some of the most common techniques for modeling counters.

Learning Outcomes—After completing this chapter, you will be able to:

9.1 Design a behavioral model for a counter using a single procedural block.
9.2 Design a behavioral model for a counter with enable and load capability.

9.1 Modeling Counters with a Single Procedural Block

9.1.1 Counters in Verilog Using the Type reg

Let’s look at how we can model a 4-bit, binary up counter with an output called CNT. We want to
model this counter using the “+” operator to avoid having to explicitly define a state code for each state as
in the three-block modeling approach to FSMs. The “+” operator works on the type reg, so the counting
behavior can simply be modeled using CNT <¼ CNT + 1. The procedural block also needs to handle the
reset condition. Both the Clock and Reset signals are listed in the sensitivity list. Within the block, an
if-else statement is used to handle both the reset and increment behaviors. Example 9.1 shows the
Verilog model and simulation waveform for this counter. When the counter reaches its maximum value of
“1111,” it rolls over to “0000” and continues counting because it is declared to only contain 4-bits.

Example 9.1
Binary counter using a single procedural block in Verilog

# Springer Nature Switzerland AG 2019 129
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5_9



130 • Chapter 9: Modeling Counters

9.1.2 Counters with Range Checking

When a counter needs to have a maximum range that is different from the maximum binary value of
the count vector (i.e., <2n 1), then the procedural block needs to contain range checking logic. This can
be modeled by inserting a nested if-else statement beneath of the else clause that handles the behavior
for when the counter receives a rising clock edge. This nested if-else first checks whether the count has
reached its maximum value. If it has, it is reset back to it minimum value. If it hasn’t, the counter is
incremented as usual. Example 9.2 shows the Verilog model and simulation waveform for a counter with
a minimum count value of 010 and a maximum count value of 1010. This counter still requires 4-bits to be
able to encode 1010.

Example 9.2
Binary counter with range checking in Verilog

CONCEPT CHECK

CC9.1 If a counter is modeled using only one procedural block in Verilog, is it still a finite state
machine? Why or why not?

(A) Yes. It is just a special case of a FSM that can easily be modeled using one
block. Synthesizers will recognize the single block model as a FSM.

(B) No. Using only one block will synthesize into combinational logic. Without the
ability to store a state, it is not a finite state machine.



9.2 Counter with Enables and Loads • 131

9.2 Counter with Enables and Loads

9.2.1 Modeling Counters with Enables

Including an enable in a counter is a common technique to prevent the counter from running
continuously. When the enable is asserted, the counter will increment on the rising edge of the clock
as usual. When the enable is de-asserted, the counter will simply hold its last value. Enable lines are
synchronous, meaning that they are only evaluated on the rising edge of the clock. As such, they are
modeled using a nested if-else statement within the main if-else statement checking for a rising edge of
the clock. Example 9.3 shows an example model for a 4-bit counter with enable.

Example 9.3
Binary counter with enable in Verilog

9.2.2 Modeling Counters with Loads

A counter with a load has the ability to set the counter to a specified value. The specified value is
provided on an input port (i.e., CNT_in) with the same width as the counter output (CNT). A synchronous
load input signal (i.e., Load) is used to indicate when the counter should set its value to the value present
on CNT_in. Example 9.4 shows an example model for a 4-bit counter with load capability.



132 • Chapter 9: Modeling Counters

Example 9.4
Binary counter with load in Verilog

CONCEPT CHECK

CC9.2 If a counter is modeled using only one procedural block in Verilog, is it still a finite state
machine? Why or why not?

(A) Yes. It is just a special case of a FSM that can easily be modeled using one
block. Synthesizers will recognize the single block model as a FSM.

(B) No. Using only one block will synthesize into combinational logic. Without the
ability to store a state, it is not a finite state machine.

Summary

v Counters are a special type of finite state enable. The only difference is that the inputs
machine that can be modeled using a single and outputs are vectors.
procedural block. Only the clock and reset v Register Transfer Level, or RTL, modeling
signals are listed in the sensitivity list of the provides a higher level of abstraction for
counter block. moving and manipulating vectors of data in

v Registers are modeled in Verilog in a similar a synchronous manner.
manner to a D-flip-flop with a synchronous



Exercise Problems • 133

Exercise Problems

Section 9.1: Modeling Counters with a 9.2.2 Design a Verilog behavioral model for a 16-bit,

Single Procedural Block binary up counter with enable and load using a
single procedural block. The block diagram for

9.1.1 Design a Verilog behavioral model for a 16-bit, the port definition is shown in Fig. 9.3.
binary up counter using a single procedural
block. The block diagram for the port definition
is shown in Fig. 9.1.

Fig. 9.3
Fig. 9.1

16-Bit Binary Up Counter with Load Block
16-Bit Binary Up Counter Block Diagram

Diagram

9.1.2 Design a Verilog behavioral model for a 16-bit,
9.2.3 Design a Verilog behavioral model for a 16-bit,

binary up counter with range checking using a
binary up/down counter using a single proce-

single procedural block. The block diagram for
dural block. The block diagram for the port

the port definition is shown in Fig. 9.1. Your
definition is shown in Fig. 9.4. When Up ¼ 1,

counter should count up to 60,000 and then
the counter will increment. When Up ¼ 0, the

start over at 0.
counter will decrement.

Section 9.2: Counters with Enables and
Loads
9.2.1 Design a Verilog behavioral model for a 16-bit,

binary up counter with enable using a single
procedural block. The block diagram for the
port definition is shown in Fig. 9.2.

Fig. 9.4
16-Bit Binary Up/Down Counter Block Diagram

Fig. 9.2
16-Bit Binary Up Counter with Enable Block
Diagram



Chapter 10: Modeling Memory
This chapter covers how to model memory arrays in Verilog. These models are technology inde-

pendent, meaning that they can be ultimately synthesized into a wide range of semiconductor memory
devices.

Learning Outcomes—After completing this chapter, you will be able to:

10.1 Describe the basic architecture and terminology for semiconductor-based memory
systems.

10.2 Design a Verilog model for a read-only memory array.
10.3 Design a Verilog model for a read/write memory array.

10.1 Memory Architecture and Terminology

The termmemory is used to describe a system with the ability to store digital information. The term
semiconductor memory refers to systems that are implemented using integrated circuit technology.
These types of systems store the digital information using transistors, fuses, and/or capacitors on a
single semiconductor substrate. Memory can also be implemented using technology other than
semiconductors. Disk drives store information by altering the polarity of magnetic fields on a circular
substrate. The two magnetic polarities (north and south) are used to represent different logic values
(i.e., 0 or 1). Optical disks use lasers to burn pits into reflective substrates. The binary information is
represented by light either being reflected (no pit) or not reflected (pit present). Semiconductor memory
does not have any moving parts, so it is called solid state memory and can hold more information per unit
area than disk memory. Regardless of the technology used to store the binary data, all memory has
common attributes and terminology that are discussed in this chapter.

10.1.1 Memory Map Model

The information stored in memory is called the data. When information is placed into memory, it is
called a write. When information is retrieved from memory, it is called a read. In order to access data in
memory, an address is used. While data can be accessed as individual bits, in order to reduce the
number of address locations needed, data is typically grouped into N-bit words. If a memory system has
N ¼ 8, this means that 8-bits of data are stored at each address. The number of address locations is
described using the variable M. The overall size of the memory is typically stated by saying “M  N.”
For example, if we had a 16  8 memory system, that means that there are 16 address locations, each
capable of storing a byte of data. This memory would have a capacity of 16  8 ¼ 128 bits. Since the
address is implemented as a binary code, the number of lines in the address bus (n) will dictate the
number of address locations that the memory system will have (M ¼ 2n). Figure 10.1 shows a graphical
depiction of how data resides in memory. This type of graphic is called a memory map model.

# Springer Nature Switzerland AG 2019 135
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5_10



136 • Chapter 10: Modeling Memory

Fig. 10.1
Memory map model

10.1.2 Volatile vs. Non-volatile Memory

Memory is classified into two categories depending on whether it can store information when power
is removed or not. The term non-volatile is used to describe memory that holds information when the
power is removed, while the term volatile is used to describe memory that loses its information when
power is removed. Historically, volatile memory is able to run at faster speeds compared to non-volatile
memory, so it is used as the primary storage mechanism while a digital system is running. Non-volatile
memory is necessary in order to hold critical operation information for a digital system such as startup
instructions, operations systems, and applications.

10.1.3 Read-Only vs. Read/Write Memory

Memory can also be classified into two categories with respect to how data is accessed. Read-Only
Memory (ROM) is a device that cannot be written to during normal operation. This type of memory is
useful for holding critical system information or programs that should not be altered while the system is
running. Read/Write memory refers to memory that can be read and written to during normal operation
and is used to hold temporary data and variables.

10.1.4 Random Access vs. Sequential Access

Random-Access Memory (RAM) describes memory in which any location in the system can be
accessed at any time. The opposite of this is sequential access memory, in which not all address
locations are immediately available. An example of a sequential access memory system is a tape drive.
In order to access the desired address in this system, the tape spool must be spun until the address is in
a position that can be observed. Most semiconductor memory in modern systems is random access. The
terms RAM and ROM have been adopted, somewhat inaccurately, to also describe groups of memory
with particular behavior. While the term ROM technically describes a system that cannot be written to, it
has taken on the additional association of being the term to describe non-volatile memory. While the term
RAM technically describes how data is accessed, it has taken on the additional association of being the
term to describe volatile memory. When describing modern memory systems, the terms RAM and ROM
are used most commonly to describe the characteristics of the memory being used; however, modern
memory systems can be both read/write and non-volatile, and the majority of memory is random access.

CONCEPT CHECK

CC10.1 An 8-bit wide memory has eight address lines. What is its capacity in bits?

(A) 64 (B) 256 (C) 1024 (D) 2048



10.2 Modeling Read-Only Memory • 137

10.2 Modeling Read-Only Memory

A read-only memory in Verilog can be defined in two ways. The first is to simply use a case
statement to define the contents of each location in memory based on the incoming address. A second
approach is to declare an array and then initialize its contents. When using an array, a separate
procedural block handles assigning the contents of the array to the output based on the incoming
address. The array can be initialized using either an initial block or through the file I/O system tasks
$readmemb() or $readmemh(). Example 10.1 shows two approaches for modeling a 4  4 ROM
memory. In this example the memory is asynchronous, meaning that as soon as the address changes
the data from the ROM will appear immediately. To model this asynchronous behavior the procedural
blocks are sensitive to the incoming address. In the simulation, each possible address is provided (i.e.,
“00,” “01,” “10,” and “11”) to verify that the ROM was initialized correctly.

Example 10.1
Behavioral models of a 4  4 asynchronous read-only memory in Verilog

A synchronous ROM can be created in a similar manner as in the asynchronous approach. The only
difference is that in a synchronous ROM, a clock edge is used to trigger the procedural block that
updates data_out. A sensitivity list is used that contains the clock to trigger the assignment. Example 10.2



138 • Chapter 10: Modeling Memory

shows two Verilog models for a synchronous ROM. Notice that prior to the first clock edge, the simulator
does not know what to assign to data_out so it lists the value as unknown (X).

Example 10.2
Behavioral models of a 4  4 synchronous read-only memory in Verilog

CONCEPT CHECK

CC10.2 Explain the advantage of modeling memory in Verilog without going into the details of
the storage cell operation.

(A) It allows the details of the storage cell to be abstracted from the functional
operation of the memory system.

(B) It is too difficult to model the analog behavior of the storage cell.

(C) There are too many cells to model, so the simulation would take too long.

(D) It lets both ROM and R/W memory to be modeled in a similar manner.



10.3 Modeling Read/Write Memory • 139

10.3 Modeling Read/Write Memory

In a simple read/write memory model, there is an output port that provides data when reading
(data_out) and an input port that receives data when writing (data_in). Within the module, an array signal
is declared with elements of type reg. To write to the array, signal assignment are made from the data_in
port to the element within the array corresponding to the incoming address. To read from the array, the
data_out port is assigned the element within the array corresponding to the incoming address. A write
enable (WE) signal tells the system when to write to the array (WE ¼ 1) or when to read from the array
(WE ¼ 0). In an asynchronous R/W memory, data is immediately written to the array when WE ¼ 1 and
data is immediately read from the array when WE ¼ 0. This is modeled using a procedural block with a
sensitivity list containing every input to the system. Example 10.3 shows an asynchronous R/W 4  4
memory system and functional simulation results. In the simulation, each address is initially read from to
verify that it does not contain data. The data_out port produces unknown (X) for the initial set of read
operations. Each address in the array is then written to. Finally, the array is read from verifying that the
data that was written can be successfully retrieved.

Example 10.3
Behavioral model of a 4  4 asynchronous read/write memory in Verilog

A synchronous read/write memory is made in a similar manner with the exception that a clock is
used to trigger the procedural block managing the signal assignments. In this case, the WE signal acts
as a synchronous control signal indicating whether assignments are read from or written to the RWarray.
Example 10.4 shows the Verilog model for a synchronous read/write memory and the simulation
waveform showing both read and write cycles.



140 • Chapter 10: Modeling Memory

Example 10.4
Behavioral model of a 4  4 synchronous read/write memory in Verilog

CONCEPT CHECK

CC10.3 Does modeling the R/W memory as an uninitialized array accurately describe the
behavior of real R/W memory technology?

(A) Yes. Read/Write memory is not initialized upon power-up.

(B) No. Read/Write memory should be initialized to all zeros to model the reset
behavior found in memory.

Summary

v The term memory refers to arrays of storage. v A memory device always contains an
The technology used in memory is typically address bus input. The number of bits in the
optimized for storage density at the expense address bus dictates how many storage
of control capability. This is different from a locations can be accessed. An n-bit address
D-flip-flop, which is optimized for complete bus can access 2n (or M ) storage locations.
control at the bit level.



Exercise Problems • 141

v The width of each storage location (N ) allows operation. Read/Write (R/W) memory is a
the density of the memory array to be memory type that can be written to during
increased by reading and writing vectors of normal operation. Both ROM and R/W mem-
data instead of individual bits. ory can be read from during normal

v A memory map is a graphical depiction of a operation.
memory array. A memory map is useful to v Random-Access Memory (RAM) is a mem-
give an overview of the capacity of the array ory type in which any location in memory can
and how different address ranges of the array be accessed at any time. In Sequential
are used. Access Memory the data can only be

v A read is an operation in which data is retrieved in a linear sequence. This means
retrieved from memory. A write is an opera- that in sequential memory the data cannot be
tion in which data is stored to memory. accessed arbitrarily.

v An asynchronous memory array responds v ROM Memory can be modeled in Verilog
immediately to its control inputs. A synchro- using a case statement or an array data
nous memory array only responds on the type consisting of elements of type reg that
triggering edge of clock. are initialized with an initial procedural block.

v Volatile memory will lose its data when the v R/W Memory can be modeled in Verilog
power is removed. Non-volatile memory will using an array data type consisting of
retain its data when the power is removed. elements of type reg that are uninitialized.

v Read-Only Memory (ROM) is a memory type
that cannot be written to during normal

Exercise Problems

Section 10.1: Memory Architecture and
Terminology
10.1.1 For a 512k  32 memory system, how many

unique address locations are there? Give the
exact number.

10.1.2 For a 512k  32 memory system, what is the
data width at each address location?

10.1.3 For a 512k  32 memory system, what is the
capacity in bits?

10.1.4 For a 512k  32-bit memory system, what is
the capacity in bytes?

10.1.5 For a 512k  32 memory system, how wide
does the incoming address bus need to be in
order to access every unique address
location?

Section 10.2: Modeling Read-Only
Fig. 10.2

Memory 16 x 8 Asynchronous ROM Block Diagram
10.2.1 Design a Verilog model for the 16  8, asyn-

chronous, read-only memory system shown in 10.2.2 Design a Verilog model for the 16 8, synchro-
Fig. 10.2. The system should contain the infor- nous, read-only memory system shown in
mation provided in the memory map. Create a Fig. 10.3. The system should contain the infor-
test bench to simulate your model by reading mation provided in the memory map. Create a
from each of the 16 unique addresses and test bench to simulate your model by reading
observing data_out to verify it contains the from each of the 16 unique addresses and
information in the memory map. observing data_out to verify it contains the

information in the memory map.



142 • Chapter 10: Modeling Memory

10.3.2 Design a Verilog model for the 16 8, synchro-
nous, read/write memory system shown in
Fig. 10.5. Create a test bench to simulate
your model. Your test bench should first read
from all of the address locations to verify they
are uninitialized. Next, your test bench should
write unique information to each of the address
locations. Finally, your test bench should read
from each address location to verify that the
information that was written was stored and
can be successfully retrieved.

Fig. 10.3
16 x 8 Synchronous ROM Block Diagram

Fig. 10.5
Section 10.3: Modeling Read/Write 16 x 8 Synchronous R/W Block Diagram
Memory
10.3.1 Design a Verilog model for the 16  8, asyn-

chronous, read/write memory system shown in
Fig. 10.4. Create a test bench to simulate your
model. Your test bench should first read from
all of the address locations to verify they are
uninitialized. Next, your test bench should write
unique information to each of the address
locations. Finally, your test bench should read
from each address location to verify that the
information that was written was stored and
can be successfully retrieved.

Fig. 10.4
16 x 8 Asynchronous R/W Block Diagram



Chapter 11: Computer System Design
This chapter presents the design of a simple computer system that will illustrate the use of many of

the Verilog modeling techniques covered in this book. The goal of this chapter is not to provide an
in-depth coverage of modern computer architecture, but rather to present a simple operational computer
that can be implemented in Verilog to show how to use many of the modeling techniques covered thus
far. The chapter begins with some architectural definitions so that consistent terminology can be used
throughout the computer design example.

Learning Outcomes—After completing this chapter, you will be able to:

11.1 Describe the basic components and operation of computer hardware.
11.2 Describe the basic components and operation of computer software.
11.3 Design a fully operational computer system using Verilog.

11.1 Computer Hardware

A computer accomplishes tasks through an architecture that uses both hardware and software.
The hardware in a computer consists of many of the elements that we have covered so far. These include
registers, arithmetic and logic circuits, finite state machines, and memory. What makes a computer so
useful is that the hardware is designed to accomplish a predetermined set of instructions. These
instructions are relatively simple, such as moving data between memory and a register or performing
arithmetic on two numbers. The instructions comprise binary codes that are stored in a memory device
and represent the sequence of operations that the hardware will perform to accomplish a task. This
sequence of instructions is called a computer program. What makes this architecture so useful is that
the preexisting hardware can be programmed to perform an almost unlimited number of tasks by simply
defining the sequence of instructions to be executed. The process of designing the sequence of
instructions, or program, is called software development or software engineering.

The idea of a general-purpose computing machine dates back to the nineteenth century. The first
computing machines were implemented with mechanical systems and were typically analog in nature.
As technology advanced, computer hardware evolved from electromechanical switches to vacuum
tubes and ultimately to integrated circuits. These newer technologies enabled switching circuits and
provided the capability to build binary computers. Today’s computers are built exclusively with semicon-
ductor materials and integrated circuit technology. The term microcomputer is used to describe a
computer that has its processing hardware implemented with integrated circuitry. Nearly all modern
computers are binary. Binary computers are designed to operate on a fixed set of bits. For example, an
8-bit computer would perform operations on 8-bits at a time. This means it moves data between registers
and memory and performs arithmetic and logic operations in groups of 8-bits.

Computer hardware refers to all of the physical components within the system. This hardware
includes all circuit components in a computer such as the memory devices, registers, and finite state
machines. Figure 11.1 shows a block diagram of the basic hardware components in a computer.

# Springer Nature Switzerland AG 2019 143
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5_11



144 • Chapter 11: Computer System Design

Fig. 11.1
Hardware components of a computer system

11.1.1 Program Memory

The instructions that are executed by a computer are held in program memory. Program memory is
treated as read only during execution in order to prevent the instructions from being overwritten by the
computer. Programs are typically held in non-volatile memory so that the computer system does not lose
its program when power is removed. Modern computers will often copy a program from non-volatile
memory (e.g., a hard disk drive) to volatile memory (i.e., SRAM or DRAM) after startup in order to speed
up instruction execution as volatile memory is often a faster technology.

11.1.2 Data Memory

Computers also require data memory, which can be written to and read from during normal
operation. This memory is used to hold temporary variables that are created by the software program.
This memory expands the capability of the computer system by allowing large amounts of information to
be created and stored by the program. Additionally, computations can be performed that are larger than
the width of the computer system by holding interim portions of the calculation (e.g., performing a 128-bit
addition on a 32-bit computer). Data memory is typically implemented with volatile memory as it is often
faster than read-only memory technology.

11.1.3 Input/Output Ports

The term port is used to describe the mechanism to get information from the output world into or out
of the computer. Ports can be input, output, or bidirectional. I/O ports can be designed to pass information
in a serial or parallel format.

11.1.4 Central Processing Unit

The central processing unit (CPU) is considered the brains of the computer. The CPU handles
reading instructions from memory, decoding them to understand which instruction is being performed,
and executing the necessary steps to complete the instruction. The CPU also contains a set of registers



11.1 Computer Hardware • 145

that are used for general-purpose data storage, operational information, and system status. Finally, the
CPU contains circuitry to perform arithmetic and logic operations on data.

11.1.4.1 Control Unit

The control unit is a finite state machine that controls the operation of the computer. This FSM has
states that perform fetching the instruction (i.e., reading it from program memory), decoding the instruc-
tion, and executing the appropriate steps to accomplish the instruction. This process is known as fetch,
decode, and execute and is repeated each time an instruction is performed by the CPU. As the control
unit state machine traverses through its states, it asserts control signals that move and manipulate data
in order to achieve the desired functionality of the instruction.

11.1.4.2 Data Path: Registers

The CPU groups its registers and ALU into a subsystem called the data path. The data path refers to
the fast storage and data manipulations within the CPU. All of these operations are initiated and
managed by the control unit state machine. The CPU contains a variety of registers that are necessary
to execute instructions and hold status information about the system. Basic computers have the following
registers in their CPU:

• Instruction Register (IR)—The instruction register holds the current binary code of the
instruction being executed. This code is read from program memory as the first part of
instruction execution. The IR is used by the control unit to decide which states in its FSM to
traverse in order to execute the instruction.

• Memory Address Register (MAR)—The memory address register is used to hold the current
address being used to access memory. The MAR can be loaded with addresses in order to
fetch instructions from program memory or with addresses to access data memory and/or I/O
ports.

• Program Counter (PC)—The program counter holds the address of the current instruction
being executed in program memory. The program counter will increment sequentially through
the program memory reading instructions until a dedicated instruction is used to set it to a new
location.

• General-Purpose Registers—These registers are available for temporary storage by the
program. Instructions exist to move information from memory into these registers and to move
information from these registers into memory. Instructions also exist to perform arithmetic and
logic operations on the information held in these registers.

• Condition Code Register (CCR)—The condition code register holds status flags that provide
information about the arithmetic and logic operations performed in the CPU. The most common
flags are negative (N), zero (Z), two’s complement overflow (V), and carry (C). This register can
also contain flags that indicate the status of the computer, such as if an interrupt has occurred
or if the computer has been put into a low-power mode.

11.1.4.3 Data Path: Arithmetic Logic Unit (ALU)

The arithmetic logic unit is the system that performs all mathematical (i.e., addition, subtraction,
multiplication, and division) and logic operations (i.e., and, or, not, shifts). This system operates on data
being held in CPU registers. The ALU has a unique symbol associated with it to distinguish it from other
functional units in the CPU.

Figure 11.2 shows the typical organization of a CPU. The registers and ALU are grouped into the
data path. In this example, the computer system has two general-purpose registers called A and B. This
CPU organization will be used throughout this chapter to illustrate the detailed execution of instructions.



146 • Chapter 11: Computer System Design

Fig. 11.2
Typical CPU organization

11.1.5 A Memory Mapped System

A common way to simplify moving data in or out of the CPU is to assign a unique address to all
hardware components in the memory system. Each input/output port and each location in both program
and data memory are assigned a unique address. This allows the CPU to access everything in the
memory system with a dedicated address. This reduces the number of lines that must pass into the CPU.
A bus system facilitates transferring information within the computer system. An address bus is driven by
the CPU to identify which location in the memory system is being accessed. A data bus is used to
transfer information to/from the CPU and the memory system. Finally, a control bus is used to provide
other required information about the transactions such as read or write lines. Figure 11.3 shows the
computer hardware in a memory mapped architecture.



11.1 Computer Hardware • 147

Fig. 11.3
Computer hardware in a memory mapped configuration

To help visualize how the memory addresses are assigned, a memory map is used. This is a
graphical depiction of the memory system. In the memory map, the ranges of addresses are provided for
each of the main subsections of memory. This gives the programmer a quick overview of the available
resources in the computer system. Example 11.1 shows a representative memory map for a computer
system with an address bus with a width of 8-bits. This address bus can provide 256 unique locations.
For this example, the memory system is also 8-bits wide, thus the entire memory system is 256  8 in
size. In this example, 128 bytes are allocated for program memory; 96 bytes are allocated for data
memory; 16 bytes are allocated for output ports; and 16 bytes are allocated for input ports.



148 • Chapter 11: Computer System Design

Example 11.1
Memory map for a 256  8 memory system

CONCEPT CHECK

CC11.1 Is the hardware of a computer programmed in a similar way to a programmable logic
device?

(A) Yes. The control unit is reconfigured to produce the correct logic for each
unique instruction just like a logic element in an FPGA is reconfigured to
produce the desired logic expression.

(B) No. The instruction code from program memory simply tells the state
machine in the control unit which path to traverse in order to accomplish the
desired task.

11.2 Computer Software

Computer software refers to the instructions that the computer can execute and how they are
designed to accomplish various tasks. The specific group of instructions that a computer can execute
is known as its instruction set. The instruction set of a computer needs to be defined first before the
computer hardware can be implemented. Some computer systems have a very small number of
instructions in order to reduce the physical size of the circuitry needed in the CPU. This allows the
CPU to execute the instructions very quickly but requires a large number of operations to accomplish a
given task. This architectural approach is called a reduced instruction set computer (RISC). The
alternative to this approach is to make an instruction set with a large number of dedicated instructions
that can accomplish a given task in fewer CPU operations. The drawback of this approach is that the
physical size of the CPU must be larger in order to accommodate the various instructions. This
architectural approach is called a complex instruction set computer (CISC).



11.2 Computer Software • 149

11.2.1 Opcodes and Operands

A computer instruction consists of two fields, an opcode and an operand. The opcode is a unique
binary code given to each instruction in the set. The CPU decodes the opcode in order to know which
instruction is being executed and then takes the appropriate steps to complete the instruction. Each
opcode is assigned a mnemonic, which is a descriptive name for the opcode that can be used when
discussing the instruction functionally. An operand is additional information for the instruction that may be
required. An instruction may have any number of operands including zero. Figure 11.4 shows an
example of how the instruction opcodes and operands are placed into program memory.

Fig. 11.4
Anatomy of a computer instruction

11.2.2 Addressing Modes

An addressing mode describes the way in which the operand of an instruction is used. While modern
computer systems may contain numerous addressing modes with varying complexities, we will focus on
just a subset of basic addressing modes. These modes are immediate, direct, inherent, and indexed.

11.2.2.1 Immediate Addressing (IMM)

Immediate addressing is when the operand of an instruction is the information to be used by the
instruction. For example, if an instruction existed to put a constant into a register within the CPU using
immediate addressing, the operand would be the constant. When the CPU reads the operand, it simply
inserts the contents into the CPU register and the instruction is complete.

11.2.2.2 Direct Addressing (DIR)

Direct addressing is when the operand of an instruction contains the address of where the informa-
tion to be used is located. For example, if an instruction existed to put a constant into a register within the
CPU using direct addressing, the operand would contain the address of where the constant was located



150 • Chapter 11: Computer System Design

in memory. When the CPU reads the operand, it puts this value out on the address bus and performs an
additional read to retrieve the contents located at that address. The value read is then put into the CPU
register and the instruction is complete.

11.2.2.3 Inherent Addressing (INH)

Inherent addressing refers to an instruction that does not require an operand because the opcode
itself contains all of the necessary information for the instruction to complete. This type of addressing is
used on instructions that performmanipulations on data held in CPU registers without the need to access
the memory system. For example, if an instruction existed to increment the contents of a register (A),
then once the opcode is read by the CPU, it knows everything it needs to know in order to accomplish the
task. The CPU simply asserts a series of control signals in order to increment the contents of A and then
the instruction is complete. Notice that no operand is needed for this task. Instead, the location of the
register to be manipulated (i.e., A) is inherent within the opcode.

11.2.3 Classes of Instructions

There are three general classes of instructions: (1) loads and stores; (2) data manipulations; and
(3) branches. To illustrate how these instructions are executed, examples will be given based on the
computer architecture shown in Fig. 11.3.

11.2.3.1 Loads and Stores

This class of instructions accomplishes moving information between the CPU and memory. A load
is an instruction that moves information from memory into a CPU register. When a load instruction uses
immediate addressing, the operand of the instruction is the data to be loaded into the CPU register. As an
example, let’s look at an instruction to load the general-purpose register A using immediate addressing.
Let’s say that the opcode of the instruction is x“86”, has a mnemonic LDA_IMM, and is inserted into
program memory starting at x“00”. Example 11.2 shows the steps involved in executing the LDA_IMM
instruction.



11.2 Computer Software • 151

Example 11.2
Execution of an instruction to “load register A using immediate addressing”

Now let’s look at a load instruction using direct addressing. In direct addressing, the operand of the
instruction is the address of where the data to be loaded resides. As an example, let’s look at an
instruction to load the general-purpose register A. Let’s say that the opcode of the instruction is x“87”,
has a mnemonic LDA_DIR, and is inserted into program memory starting at x“08”. The value to be
loaded into A resides at address x“80”, which has already been initialized with x“AA” before this
instruction. Example 11.3 shows the steps involved in executing the LDA_DIR instruction.



152 • Chapter 11: Computer System Design

Example 11.3
Execution of an instruction to “load register A using direct addressing”

A store is an instruction that moves information from a CPU register intomemory. The operand of a
store instruction indicates the address of where the contents of the CPU register will be written. As an
example, let’s look at an instruction to store the general-purpose register A into memory address x“E0”.
Let’s say that the opcode of the instruction is x“96”, has a mnemonic STA_DIR, and is inserted into
program memory starting at x“04”. The initial value of A is x“CC” before the instruction is executed.
Example 11.4 shows the steps involved in executing the STA_DIR instruction.



11.2 Computer Software • 153

Example 11.4
Execution of an instruction to “store register A using direct addressing”

11.2.3.2 Data Manipulations

This class of instructions refers to ALU operations. These operations act on data that resides in the
CPU registers. These instructions include arithmetic, logic operators, shifts and rotates, and tests and
compares. Data manipulation instructions typically use inherent addressing because the operations are
conducted on the contents of CPU registers and don’t require additional memory access. As an example,
let’s look at an instruction to perform addition on registers A and B. The sum will be placed back in
A. Let’s say that the opcode of the instruction is x“42”, has a mnemonic ADD_AB, and is inserted into
program memory starting at x“04”. Example 11.5 shows the steps involved in executing the ADD_AB
instruction.



154 • Chapter 11: Computer System Design

Example 11.5
Execution of an instruction to “add registers A and B”

11.2.3.3 Branches

In the previous examples the program counter was always incremented to point to the address of
the next instruction in programmemory. This behavior only supports a linear execution of instructions. To
provide the ability to specifically set the value of the program counter, instructions called branches are
used. There are two types of branches: unconditional and conditional. In an unconditional branch, the
program counter is always loaded with the value provided in the operand. As an example, let’s look at an
instruction to branch always to a specific address. This allows the program to perform loops. Let’s say
that the opcode of the instruction is x“20”, has a mnemonic BRA, and is inserted into program memory
starting at x“06”. Example 11.6 shows the steps involved in executing the BRA instruction.



11.2 Computer Software • 155

Example 11.6
Execution of an instruction to “branch always”

In a conditional branch, the program counter is only updated if a particular condition is true. The
conditions come from the status flags in the condition code register (NZVC). This allows a program to
selectively execute instructions based on the result of a prior operation. Let’s look at an example
instruction that will branch only if the Z flag is asserted. This instruction is called a branch if equal to
zero. Let’s say that the opcode of the instruction is x“23”, has a mnemonic BEQ, and is inserted into
program memory starting at x“05”. Example 11.7 shows the steps involved in executing the BEQ
instruction.



156 • Chapter 11: Computer System Design

Example 11.7
Execution of an instruction to “branch if equal to zero”

Conditional branches allow computer programs to make decisions about which instructions to
execute based on the results of previous instructions. This gives computers the ability to react to input
signals or act based on the results of arithmetic or logic operations. Computer instruction sets typically
contain conditional branches based on the NZVC flags in the condition code registers. The following
instructions are a set of possible branches that could be created using the values of the NZVC flags.

• BMI—Branch if minus (N ¼ 1)

• BPL—Branch if plus (N ¼ 0)

• BEQ—Branch if equal to Zero (Z ¼ 1)

• BNE—Branch if not equal to Zero (Z ¼ 0)

• BVS—Branch if two’s complement overflow occurred, or V is set (V ¼ 1)



11.3 Computer Implementation: An 8-Bit Computer Example • 157

• BVC—Branch if two’s complement overflow did not occur, or V is clear (V ¼ 0)

• BCS—Branch if a carry occurred, or C is set (C ¼ 1)

• BCC—Branch if a carry did not occur, or C is clear (C ¼ 0)

Combinations of these flags can be used to create more conditional branches.

• BHI—Branch if higher (C ¼ 1 and Z ¼ 0)

• BLS—Branch if lower or the same (C ¼ 0 and Z ¼ 1)

• BGE—Branch if greater than or equal ((N ¼ 0 and V ¼ 0) or (N ¼ 1 and V ¼ 1)), only valid for
signed numbers

• BLT—Branch if less than ((N ¼ 1 and V ¼ 0) or (N ¼ 0 and V ¼ 1)), only valid for signed
numbers

• BGT—Branch if greater than ((N¼ 0 and V¼ 0 and Z¼ 0) or (N¼ 1 and V¼ 1 and Z¼ 0)), only
valid for signed numbers

• BLE—Branch if less than or equal ((N¼ 1 and V¼ 0) or (N¼ 0 and V¼ 1) or (Z¼ 1)), only valid
for signed numbers

CONCEPT CHECK

CC11.2 Software development consists of choosing which instructions, and in what order, will
be executed to accomplish a certain task. The group of instructions is called the
program and is inserted into program memory. Which of the following might a software
developer care about?

(A) Minimizing the number of instructions that need to be executed to accom-
plish the task in order to increase the computation rate.

(B) Minimizing the number of registers used in the CPU to save power.

(C) Minimizing the overall size of the program to reduce the amount of program
memory needed.

(D) Both A and C.

11.3 Computer Implementation: An 8-Bit Computer Example

11.3.1 Top-Level Block Diagram

Let’s now look at the detailed implementation and instruction execution of a computer system.
In order to illustrate the detailed operation, we will use a simple 8-bit computer system design.
Example 11.8 shows the block diagram for the 8-bit computer system. This block diagram also contains
the Verilog file and module names, which will be used when the behavioral model is implemented.



158 • Chapter 11: Computer System Design

Example 11.8
Top-level block diagram for the 8-bit computer system

We will use the memory map shown in Example 11.1 for our example computer system. This
mapping provides 128 bytes of program memory, 96 bytes of data memory, 16 output ports, and
16 input ports. To simplify the operation of this example computer, the address bus is limited to 8-bits.
This only provides 256 locations of memory access but allows an entire address to be loaded into the
CPU as a single operand of an instruction.

11.3.2 Instruction Set Design

Example 11.9 shows a basic instruction set for our example computer system. This set provides a
variety of loads and stores, data manipulations, and branch instructions that will allow the computer to be
programmed to perform more complex tasks through software development. These instructions are
sufficient to provide a baseline of functionality in order to get the computer system operational. Additional
instructions can be added as desired to increase the complexity of the system.



11.3 Computer Implementation: An 8-Bit Computer Example • 159

Example 11.9
Instruction set for the 8-bit computer system

11.3.3 Memory System Implementation

Let’s now look at the memory system details. The memory system contains program memory, data
memory, and input/output ports. Example 11.10 shows the block diagram of the memory system. The
program and data memory will be implemented using lower-level components (rom_128x8_sync.v and
rw_96x8_sync.v), while the input and output ports can be modeled using a combination of RTL blocks
and combinational logic. The program and data memory subsystems contain dedicated circuitry to
handle their addressing ranges. Each output port also contains dedicated circuitry to handle its unique
address. A multiplexer is used to handle the signal routing back to the CPU based on the address
provided.



160 • Chapter 11: Computer System Design

Example 11.10
Memory system block diagram for the 8-bit computer system

11.3.3.1 Program Memory Implementation in Verilog

The program memory can be implemented in Verilog using the modeling techniques presented in
Chap. 12. To make the Verilog more readable, the instruction mnemonics can be declared as
parameters. This allows the mnemonic to be used when populating the program memory array. The
following Verilog shows how the mnemonics for our basic instruction set can be defined as parameters.

parameter LDA_IMM ¼ 8’h86; //-- Load Register A with Immediate Addressing
parameter LDA_DIR ¼ 8’h87; //-- Load Register A with Direct Addressing
parameter LDB_IMM ¼ 8’h88; //-- Load Register B with Immediate Addressing
parameter LDB_DIR ¼ 8’h89; //-- Load Register B with Direct Addressing
parameter STA_DIR ¼ 8’h96; //-- Store Register A to memory (RAM or IO)
parameter STB_DIR ¼ 8’h97; //-- Store Register B to memory (RAM or IO)
parameter ADD_AB ¼ 8’h42; //-- A <¼ A + B
parameter BRA ¼ 8’h20; //-- Branch Always
parameter BEQ ¼ 8’h23; //-- Branch if Z¼1

Now the program memory can be declared as an array type with initial values to define the program.
The following Verilog shows how to declare the program memory and an example program to perform a
load, store, and a branch always. This program will continually write x“AA” to port_out_00.



11.3 Computer Implementation: An 8-Bit Computer Example • 161

reg[7:0] ROM[0:127];

initial
begin

ROM[0] ¼ LDA_IMM;
ROM[1] ¼ 8’hAA;
ROM[2] ¼ STA_DIR;
ROM[3] ¼ 8’hE0;
ROM[4] ¼ BRA;
ROM[5] ¼ 8’h00;

end

The address mapping for the program memory is handled in two ways. First, notice that the array
type defined above uses indices from 0 to 127. This provides the appropriate addresses for each location
in the memory. The second step is to create an internal enable line that will only allow assignments from
ROM to data_out when a valid address is entered. Consider the following Verilog to create an internal
enable (EN) that will only be asserted when the address falls within the valid program memory range of
0 to 127.

always @ (address)
begin

if ( (address >¼ 0) && (address <¼ 127) )
EN ¼ 1’b1;

else
EN ¼ 1’b0;

end

If this enable signal is not created, the simulation and synthesis will fail because data_out
assignments will be attempted for addresses outside of the defined range of the ROM array. This enable
line can now be used in the behavioral model for the ROM as follows:

always @ (posedge clock)
begin

if (EN)
data_out ¼ ROM[address];

end

11.3.3.2 Data Memory Implementation in Verilog

The data memory is created using a similar strategy as the program memory. An array signal is
declared with an address range corresponding to the memory map for the computer system (i.e., 128 to
223). An internal enable is again created that will prevent data_out assignments for addresses outside of
this valid range. The following is the Verilog to declare the R/W memory array:

reg[7:0] RW[128:223];

The following is the Verilog to model the local enable and signal assignments for the R/W memory:

always @ (address)
begin

if ( (address >¼ 128) && (address <¼ 223) )
EN ¼ 1’b1;

else
EN ¼ 1’b0;

end



162 • Chapter 11: Computer System Design

always @ (posedge clock)
begin

if (write && EN)
RW[address] ¼ data_in;

else if (!write && EN)
data_out ¼ RW[address];

end

11.3.3.3 Implementation of Output Ports in Verilog

Each output port in the computer system is assigned a unique address. Each output port also
contains storage capability. This allows the CPU to update an output port by writing to its specific
address. Once the CPU is done storing to the output port address and moves to the next instruction in
the program, the output port holds its information until it is written to again. This behavior can be modeled
using an RTL procedural block that uses the address bus and the write signal to create a synchronous
enable condition. Each output port is modeled with its own block. The following Verilog shows how the
output ports at x“E0” and x“E1” are modeled using address specific procedural blocks.

//-- port_out_00 (address E0)
always @ (posedge clock or negedge reset)
begin

if (!reset)
port_out_00 <¼ 8’h00;

else
if ((address ¼¼ 8’hE0) && (write))

port_out_00 <¼ data_in;
end

//-- port_out_01 (address E1)
always @ (posedge clock or negedge reset)
begin

if (!reset)
port_out_01 <¼ 8’h00;

else
if ((address ¼¼ 8’hE1) && (write))

port_out_01 <¼ data_in;
end

:
“the rest of the output port models go here. . .”

:

11.3.3.4 Implementation of Input Ports in Verilog

The input ports do not contain storage but do require a mechanism to selectively route their
information to the data_out port of the memory system. This is accomplished using the multiplexer
shown in Example 11.10. The only functionality that is required for the input ports is connecting their ports
to the multiplexer.

11.3.3.5 Memory data_out Bus Implementation in Verilog

Now that all of the memory functionality has been designed, the final step is to implement the
multiplexer that handles routing the appropriate information to the CPU on the data_out bus based on the
incoming address. The following Verilog provides a model for this behavior. Recall that a multiplexer is
combinational logic, so if the behavior is to be modeled using a procedural block, all inputs must be listed
in the sensitivity list and blocking assignments are used. These inputs include the outputs from the
program and data memory in addition to all of the input ports. The sensitivity list must also include the



11.3 Computer Implementation: An 8-Bit Computer Example • 163

address bus as it acts as the select input to the multiplexer. Within the block, an if-else statement is used
to determine which subsystem drives data_out. Program memory will drive data_out when the incoming
address is in the range of 0 to 127 (x“00” to x“7F”). Data memory will drive data_out when the address is
in the range of 128 to 223 (x“80” to x“DF”). An input port will drive data_out when the address is in the
range of 240 to 255 (x“F0” to x“FF”). Each input port has a unique address, so the specific addresses are
listed as nested if-else clauses.

always @ (address, rom_data_out, rw_data_out,
port_in_00, port_in_01, port_in_02, port_in_03,
port_in_04, port_in_05, port_in_06, port_in_07,
port_in_08, port_in_09, port_in_10, port_in_11,
port_in_12, port_in_13, port_in_14, port_in_15)

begin: MUX1

if ( (address >¼ 0) && (address <¼ 127) )
data_out ¼ rom_data_out;

else if ( (address >¼ 128) && (address <¼ 223) )
data_out ¼ rw_data_out;

else if (address ¼¼ 8’hF0) data_out ¼ port_in_00;
else if (address ¼¼ 8’hF1) data_out ¼ port_in_01;
else if (address ¼¼ 8’hF2) data_out ¼ port_in_02;
else if (address ¼¼ 8’hF3) data_out ¼ port_in_03;
else if (address ¼¼ 8’hF4) data_out ¼ port_in_04;
else if (address ¼¼ 8’hF5) data_out ¼ port_in_05;
else if (address ¼¼ 8’hF6) data_out ¼ port_in_06;
else if (address ¼¼ 8’hF7) data_out ¼ port_in_07;
else if (address ¼¼ 8’hF8) data_out ¼ port_in_08;
else if (address ¼¼ 8’hF9) data_out ¼ port_in_09;
else if (address ¼¼ 8’hFA) data_out ¼ port_in_10;
else if (address ¼¼ 8’hFB) data_out ¼ port_in_11;
else if (address ¼¼ 8’hFC) data_out ¼ port_in_12;
else if (address ¼¼ 8’hFD) data_out ¼ port_in_13;
else if (address ¼¼ 8’hFE) data_out ¼ port_in_14;
else if (address ¼¼ 8’hFF) data_out ¼ port_in_15;

end

11.3.4 CPU Implementation

Let’s now look at the central processing unit details. The CPU contains two components, the control
unit (control_unit.v) and the data path (data_path.v). The data path contains all of the registers and the
ALU. The ALU is implemented as a subsystem within the data path (alu.v). The data path also contains a
bus system in order to facilitate data movement between the registers and memory. The bus system is
implemented with two multiplexers that are controlled by the control unit. The control unit contains the
finite state machine that generates all control signals for the data path as it performs the fetch-decode-
execute steps of each instruction. Example 11.11 shows the block diagram of the CPU in our 8-bit
microcomputer example.



164 • Chapter 11: Computer System Design

Example 11.11
CPU block diagram for the 8-bit computer system

11.3.4.1 Data Path Implementation in Verilog

Let’s first look at the data path bus system that handles internal signal routing. The system consists
of two 8-bit busses (Bus1 and Bus2) and two multiplexers. Bus1 is used as the destination of the PC, A,
and B register outputs, while Bus2 is used as the input to the IR, MAR, PC, A, and B registers. Bus1 is
connected directly to the to_memory port of the CPU to allow registers to write data to the memory
system. Bus2 can be driven by the from_memory port of the CPU to allow the memory system to provide
data for the CPU registers. The two multiplexers handle all signal routing and have their select lines
(Bus1_Sel and Bus2_Sel) driven by the control unit. The following Verilog shows how the multiplexers
are implemented. Again, a multiplexer is combinational logic, so all inputs must be listed in the sensitivity
list of its procedural block and blocking assignments are used. Two additional signal assignments are
also required to connect the MAR to the address port and to connect Bus1 to the to_memory port.



11.3 Computer Implementation: An 8-Bit Computer Example • 165

always @ (Bus1_Sel, PC, A, B)
begin: MUX_BUS1

case (Bus1_Sel)
2’b00 : Bus1 ¼ PC;
2’b01 : Bus1 ¼ A;
2’b10 : Bus1 ¼ B;
default : Bus1 ¼ 8’hXX;

endcase
end

always @ (Bus2_Sel, ALU_Result, Bus1, from_memory)
begin: MUX_BUS2

case (Bus2_Sel)
2’b00 : Bus2 ¼ ALU_Result;
2’b01 : Bus2 ¼ Bus1;
2’b10 : Bus2 ¼ from_memory;
default : Bus1 ¼ 8’hXX;

endcase
end

always @ (Bus1, MAR)
begin

to_memory ¼ Bus1;
address ¼ MAR;

end

Next, let’s look at implementing the registers in the data path. Each register is implemented using a
dedicated procedural block that is sensitive to clock and reset. This models the behavior of synchronous
latches, or registers. Each register has a synchronous enable line that dictates when the register is
updated. The register output is only updated when the enable line is asserted and a rising edge of the
clock is detected. The following Verilog shows how to model the instruction register (IR). Notice that the
signal IR is only updated if IR_Load is asserted and there is a rising edge of the clock. In this case, IR is
loaded with the value that resides on Bus2.

always @ (posedge clock or negedge reset)
begin: INSTRUCTION_REGISTER

if (!reset)
IR <¼ 8’h00;

else
if (IR_Load)

IR <¼ Bus2;
end

A nearly identical block is used to model the memory address register. A unique signal is declared
called MAR in order to make the Verilog more readable. MAR is always assigned to address in this
system.

always @ (posedge clock or negedge reset)
begin: MEMORY_ADDRESS_REGISTER

if (!reset)
MAR <¼ 8’h00;

else
if (MAR_Load)

MAR <¼ Bus2;
end

Now let’s look at the program counter block. This register contains additional functionality beyond
simply latching in the value of Bus2. The program counter also has an increment feature that will take
place synchronously when the signal PC_Inc coming from the control unit is asserted. This is handled
using an additional nested if-else clause under the portion of the block handling the rising edge of clock
condition.



166 • Chapter 11: Computer System Design

always @ (posedge clock or negedge reset)
begin: PROGRAM_COUNTER

if (!reset)
PC <¼ 8’h00;

else
if (PC_Load)
PC <¼ Bus2;

else if (PC_Inc)
PC <¼ MAR + 1;

end

The two general-purpose registers A and B are modeled using individual procedural blocks as
follows:

always @ (posedge clock or negedge reset)
begin: A_REGISTER

if (!reset)
A <¼ 8’h00;

else
if (A_Load)

A <¼ Bus2;
end

always @ (posedge clock or negedge reset)
begin: B_REGISTER

if (!reset)
B <¼ 8’h00;

else
if (B_Load)

B <¼ Bus2;
end

The condition code register latches in the status flags from the ALU (NZVC) when the CCR_Load
line is asserted. This behavior is modeled using a similar approach as follows:

always @ (posedge clock or negedge reset)
begin: CONDITION_CODE_REGISTER

if (!reset)
CCR_Result <¼ 8’h00;

else
if (CCR_Load)

CCR_Result <¼ NZVC;
end

11.3.4.2 ALU Implementation in Verilog

The ALU is a set of combinational logic circuitry that performs arithmetic and logic operations. The
output of the ALU operation is called Result. The ALU also outputs 4 status flags as a 4-bit bus called
NZVC. The ALU behavior can be modeled using case and if-else statements that decide which operation
to perform based on the input control signal ALU_Sel. The following Verilog shows an example of how to
implement the ALU addition functionality. A case statement is used to decide which operation is being
performed based on the ALU_Sel input. Under each operation clause, a series of procedural statements
are used to compute the result and update the NZVC flags. Each of these flags is updated individually.
The N flag can be simply driven with position 7 of the ALU result since this bit is the sign bit for signed
numbers. The Z flag can be driven using an if-else condition that checks whether the result was x“00”.
The V flag is updated based on the type of the operation. For the addition operation, the V flag will be
asserted if a POS + POS ¼ NEG or a NEG + NEG ¼ POS. These conditions can be checked by looking
at the sign bits of the inputs and the sign bit of the result. Finally, theC flag can be computed as the 8th bit
in the addition of A + B.



11.3 Computer Implementation: An 8-Bit Computer Example • 167

always @ (A, B, ALU_Sel)
begin

case (ALU_Sel)
3’b000 : begin //-- Addition

//-- Sum and Carry Flag
{NZVC[0], Result} ¼ A + B;

//-- Negative Flag
NZVC[3] ¼ Result[7];

//-- Zero Flag
if (Result ¼¼ 0)

NZVC[2] ¼ 1;
else

NZVC[2] ¼ 0;

//-- Two’s Comp Overflow Flag
if ( ((A[7]¼¼0) && (B[7]¼¼0) && (Result[7] ¼¼ 1)) ||

((A[7]¼¼1) && (B[7]¼¼1) && (Result[7] ¼¼ 0)) )
NZVC[1] ¼ 1;

else
NZVC[1] ¼ 0;

end

:
//-- other ALU operations go here...

:

default : begin
Result ¼ 8’hXX;
NZVC ¼ 4’hX;

end
endcase

end

11.3.4.3 Control Unit Implementation in Verilog

Let’s now look at how to implement the control unit state machine. We’ll first look at the formation of
the Verilog to model the FSM and then turn to the detailed state transitions in order to accomplish a
variety of the most common instructions. The control unit sends signals to the data path in order to move
data in and out of registers and into the ALU to perform data manipulations. The finite state machine is
implemented with the behavioral modeling techniques presented in Chap. 9. The model contains three
processes in order to implement the state memory, next state logic, and output logic of the FSM.
Parameters are created for each of the states defined in the state diagram of the FSM. The states
associated with fetching (S_FETCH_0, S_FETCH_1, S_FETCH_2) and decoding the opcode
(S_DECODE_3) are performed each time an instruction is executed. A unique path is then added
after the decode state to perform the steps associated with executing each individual instruction. The
FSM can be created one instruction at a time by adding additional state paths after the decode state. The
following Verilog code shows how the user-defined state names are created for nine basic instructions
(LDA_IMM, LDA_DIR, STA_DIR, LDB_IMM, LDB_DIR, STB_DIR, ADD_AB, BRA, and BEQ). Eight-bit
state variables are created for current_state and next_state to accommodate future state codes. The
state codes are assigned in binary using integer format to allow additional states to be easily added.



168 • Chapter 11: Computer System Design

reg [7:0] current_state, next_state;
parameter S_FETCH_0 ¼ 0, //-- Opcode fetch states

S_FETCH_1 ¼ 1,
S_FETCH_2 ¼ 2,

S_DECODE_3 ¼ 3, //-- Opcode decode state

S_LDA_IMM_4 ¼ 4, //-- Load A (Immediate) states
S_LDA_IMM_5 ¼ 5,
S_LDA_IMM_6 ¼ 6,

S_LDA_DIR_4 ¼ 7, //-- Load A (Direct) states
S_LDA_DIR_5 ¼ 8,
S_LDA_DIR_6 ¼ 9,
S_LDA_DIR_7 ¼ 10,
S_LDA_DIR_8 ¼ 11,

S_STA_DIR_4 ¼ 12, //-- Store A (Direct) States
S_STA_DIR_5 ¼ 13,
S_STA_DIR_6 ¼ 14,
S_STA_DIR_7 ¼ 15,

S_LDB_IMM_4 ¼ 16, //-- Load B (Immediate) states
S_LDB_IMM_5 ¼ 17,
S_LDB_IMM_6 ¼ 18,

S_LDB_DIR_4 ¼ 19, //-- Load B (Direct) states
S_LDB_DIR_5 ¼ 20,
S_LDB_DIR_6 ¼ 21,
S_LDB_DIR_7 ¼ 22,
S_LDB_DIR_8 ¼ 23,

S_STB_DIR_4 ¼ 24, //-- Store B (Direct) States
S_STB_DIR_5 ¼ 25,
S_STB_DIR_6 ¼ 26,
S_STB_DIR_7 ¼ 27,

S_BRA_4 ¼ 28, //-- Branch Always States
S_BRA_5 ¼ 29,
S_BRA_6 ¼ 30,

S_BEQ_4 ¼ 31, //-- Branch if Equal States
S_BEQ_5 ¼ 32,
S_BEQ_6 ¼ 33,
S_BEQ_7 ¼ 34,

S_ADD_AB_4 ¼ 35; //-- Addition States

Within the control unit module, the state memory is implemented as a separate procedural block that
will update the current state with the next state on each rising edge of the clock. The reset state will be the
first fetch state in the FSM (i.e., S_FETCH_0). The following Verilog shows how the state memory in the
control unit can be modeled. Note that this block models sequential logic, so non-blocking assignments
are used.

always @ (posedge clock or negedge reset)
begin: STATE_MEMORY

if (!reset)
current_state <¼ S_FETCH_0;

else
current_state <¼ next_state;

end



11.3 Computer Implementation: An 8-Bit Computer Example • 169

The next state logic is also implemented as a separate procedural block. The next state logic
depends on the current state, instruction register (IR), and the condition code register (CCR_Result). The
following Verilog gives a portion of the next state logic process showing how the state transitions can be
modeled.

always @ (current_state, IR, CCR_Result)
begin: NEXT_STATE_LOGIC

case (current_state)
S_FETCH_0 : next_state ¼ S_FETCH_1; //-- Path for FETCH instruction
S_FETCH_1 : next_state ¼ S_FETCH_2;
S_FETCH_2 : next_state ¼ S_DECODE_3;

S_DECODE_3 : if (IR ¼¼ LDA_IMM) next_state ¼ S_LDA_IMM_4; //-- Register
A

else if (IR ¼¼ LDA_DIR) next_state ¼ S_LDA_DIR_4;
else if (IR ¼¼ STA_DIR) next_state ¼ S_STA_DIR_4;
else if (IR ¼¼ LDB_IMM) next_state¼ S_LDB_IMM_4;//-- Register

B
else if (IR ¼¼ LDB_DIR) next_state ¼ S_LDB_DIR_4;
else if (IR ¼¼ STB_DIR) next_state ¼ S_STB_DIR_4;
else if (IR ¼¼ BRA) next_state ¼ S_BRA_4; //-- Branch

Always
else if (IR ¼¼ ADD_AB) next_state ¼ S_ADD_AB_4; //-- ADD
else next_state ¼ S_FETCH_0; //-- others

go here

S_LDA_IMM_4 : next_state ¼ S_LDA_IMM_5; //-- Path for LDA_IMM instruction
S_LDA_IMM_5 : next_state ¼ S_LDA_IMM_6;
S_LDA_IMM_6 : next_state ¼ S_FETCH_0;

:
Next state logic for other states goes here. . .

:
endcase

end

Finally, the output logic is modeled as a third, separate procedural block. It is useful to explicitly state
the outputs of the control unit for each state in the machine to allow easy debugging and avoid
synthesizing latches. Our example computer system has Moore type outputs, so the process only
depends on the current state. The following Verilog shows a portion of the output logic process.

always @ (current_state)
begin: OUTPUT_LOGIC

case (current_state)

S_FETCH_0 : begin //-- Put PC onto MAR to provide address of Opcode
IR_Load ¼ 0;
MAR_Load ¼ 1;
PC_Load ¼ 0;
PC_Inc ¼ 0;
A_Load ¼ 0;
B_Load ¼ 0;
ALU_Sel ¼ 3’b000;
CCR_Load ¼ 0;
Bus1_Sel ¼ 2’b00;//-- "00"¼PC, "01"¼A, "10"¼B
Bus2_Sel ¼ 2’b01; //-- "00"¼ALU,"01"¼Bus1,"10"¼from_memory
write ¼ 0;

end



170 • Chapter 11: Computer System Design

S_FETCH_1 : begin //-- Increment PC, Opcode will be available next state
IR_Load ¼ 0;
MAR_Load ¼ 0;
PC_Load ¼ 0;
PC_Inc ¼ 1;
A_Load ¼ 0;
B_Load ¼ 0;
ALU_Sel ¼ 3’b000;
CCR_Load ¼ 0;
Bus1_Sel ¼ 2’b00; //--"00"¼PC, "01"¼A, "10"¼B
Bus2_Sel ¼ 2’b00; //--"00"¼ALU,"01"¼Bus1,"10"¼from_memory
write ¼ 0;

end;

:
Output logic for other states goes here. . .

:
endcase

end

11.3.4.3.1 Detailed Execution of LDA_IMM
Now let’s look at the details of the state transitions and output signals in the control unit FSM when

executing a few of the most common instructions. Let’s begin with the instruction to load register A using
immediate addressing (LDA_IMM). Example 11.12 shows the state diagram for this instruction. The first
three states (S_FETCH_0, S_FETCH_1, S_FETCH_2) handle fetching the opcode. The purpose of
these states is to read the opcode from the address being held by the program counter and put it into the
instruction register. Multiple states are needed to handle putting PC into MAR to provide the address of
the opcode, waiting for the memory system to provide the opcode, latching the opcode into IR, and
incrementing PC to the next location in program memory. Another state is used to decode the opcode
(S_DECODE_3) in order to decide which path to take in the state diagram based on the instruction being
executed. After the decode state, a series of three more states are needed (S_LDA_IMM_4,
S_LDA_IMM_5, S_LDA_IMM_6) to execute the instruction. The purpose of these states is to read the
operand from the address being held by the program counter and put it into A. Multiple states are needed
to handle putting PC into MAR to provide the address of the operand, waiting for the memory system to
provide the operand, latching the operand into A, and incrementing PC to the next location in program
memory. When the instruction completes, the value of the operand resides in A and PC is pointing to the
next location in program memory, which is the opcode of the next instruction to be executed.



11.3 Computer Implementation: An 8-Bit Computer Example • 171

Example 11.12
State diagram for LDA_IMM

Example 11.13 shows the simulation waveform for executing LDA_IMM. In this example, register A
is loaded with the operand of the instruction, which holds the value x“AA”.



172 • Chapter 11: Computer System Design

Example 11.13
Simulation waveform for LDA_IMM

11.3.4.3.2 Detailed Execution of LDA_DIR
Now let’s look at the details of the instruction to load register A using direct addressing (LDA_DIR).

Example 11.14 shows the state diagram for this instruction. The first four states to fetch and decode the
opcode are the same states as in the previous instruction and are performed each time a new instruction
is executed. Once the opcode is decoded, the state machine traverses five new states to execute the
instruction (S_LDA_DIR_4, S_LDA_DIR_5, S_LDA_DIR_6, S_LDA_DIR_7, S_LDA_DIR_8). The pur-
pose of these states is to read the operand and then use it as the address of where to read the contents to
put into A.



11.3 Computer Implementation: An 8-Bit Computer Example • 173

Example 11.14
State diagram for LDA_DIR

Example 11.15 shows the simulation waveform for executing LDA_DIR. In this example, register A
is loaded with the contents located at address x“80”, which has already been initialized to x“AA”.



174 • Chapter 11: Computer System Design

Example 11.15
Simulation waveform for LDA_DIR

11.3.4.3.3 Detailed Execution of STA_DIR
Now let’s look at the details of the instruction to store register A to memory using direct addressing

(STA_DIR). Example 11.16 shows the state diagram for this instruction. The first four states are again the
same as prior instructions in order to fetch and decode the opcode. Once the opcode is decoded, the
state machine traverses four new states to execute the instruction (S_STA_DIR_4, S_STA_DIR_5,
S_STA_DIR_6, S_STA_DIR_7). The purpose of these states is to read the operand and then use it as
the address of where to write the contents of A to.



11.3 Computer Implementation: An 8-Bit Computer Example • 175

Example 11.16
State diagram for STA_DIR

Example 11.17 shows the simulation waveform for executing STA_DIR. In this example, register A
already contains the value x“CC” and will be stored to address x“E0”. The address x“E0” is an output port
(port_out_00) in our example computer system.



176 • Chapter 11: Computer System Design

Example 11.17
Simulation waveform for STA_DIR

11.3.4.3.4 Detailed Execution of ADD_AB
Now let’s look at the details of the instruction to add A to B and store the sum back in A (ADD_AB).

Example 11.18 shows the state diagram for this instruction. The first four states are again the same as
prior instructions in order to fetch and decode the opcode. Once the opcode is decoded, the state
machine only requires one more state to complete the operation (S_ADD_AB_4). The ALU is combina-
tional logic, so it will begin to compute the sum immediately as soon as the inputs are updated. The inputs
to the ALU are Bus1 and register B. Since B is directly connected to the ALU, all that is required to start
the addition is to put A onto Bus1. The output of the ALU is put on Bus2 so that it can be latched into A on
the next clock edge. The ALU also outputs the status flags NZVC, which are directly connected to the
condition code register. A_Load and CCR_Load are asserted in this state. A and CCR_Result will be
updated in the next state (i.e., S_FETCH_0).



11.3 Computer Implementation: An 8-Bit Computer Example • 177

Example 11.18
State diagram for ADD_AB

Example 11.19 shows the simulation waveform for executing ADD_AB. In this example, two load
immediate instructions were used to initialize the general-purpose registers to A ¼ x“FF” and B ¼ x“01”
prior to the addition. The addition of these values will result in a sum of x“00” and assert the carry (C) and
zero (Z) flags in the condition code register.



178 • Chapter 11: Computer System Design

Example 11.19
Simulation waveform for ADD_AB

11.3.4.3.5 Detailed Execution of BRA
Now let’s look at the details of the instruction to branch always (BRA). Example 11.20 shows the

state diagram for this instruction. The first four states are again the same as prior instructions in order to
fetch and decode the opcode. Once the opcode is decoded, the state machine traverses four new states
to execute the instruction (S_BRA_4, S_BRA_5, S_BRA_6). The purpose of these states is to read the
operand and put its value into PC to set the new location in program memory to execute instructions.



11.3 Computer Implementation: An 8-Bit Computer Example • 179

Example 11.20
State diagram for BRA

Example 11.21 shows the simulation waveform for executing BRA. In this example, PC is set back to
address x“00”.



180 • Chapter 11: Computer System Design

Example 11.21
Simulation waveform for BRA

11.3.4.3.6 Detailed Execution of BEQ
Now let’s look at the branch if equal to zero (BEQ) instruction. Example 11.22 shows the state

diagram for this instruction. Notice that in this conditional branch, the path that is taken through the FSM
depends on both IR and CCR. In the case that Z ¼ 1, the branch is taken, meaning that the operand is
loaded into PC. In the case that Z¼ 0, the branch is not taken, meaning that PC is simply incremented to
bypass the operand and point to the beginning of the next instruction in program memory.



11.3 Computer Implementation: An 8-Bit Computer Example • 181

Example 11.22
State diagram for BEQ

Example 11.23 shows the simulation waveform for executing BEQwhen the branch is taken. Prior to
this instruction, an addition was performed on x“FF” and x“01”. This resulted in a sum of x“00”, which
asserted the Z and C flags in the condition code register. Since Z¼ 1 when BEQ is executed, the branch
is taken.



182 • Chapter 11: Computer System Design

Example 11.23
Simulation waveform for BEQ when taking the branch (Z ¼ 1)

Example 11.24 shows the simulation waveform for executing BEQ when the branch is not taken.
Prior to this instruction, an addition was performed on x“FE” and x“01”. This resulted in a sum of x“FF”,
which did not assert the Z flag. Since Z ¼ 0 when BEQ is executed, the branch is not taken. When not
taking the branch, PC must be incremented again in order to bypass the operand and point to the next
location in program memory.



11.3 Computer Implementation: An 8-Bit Computer Example • 183

Example 11.24
Simulation waveform for BEQ when the branch is not taken (Z ¼ 0)



184 • Chapter 11: Computer System Design

CONCEPT CHECK

CC11.3 The 8-bit microcomputer example presented in this section is a very simple architec-
ture used to illustrate the basic concepts of a computer. If we wanted to keep this
computer an 8-bit system but increase the depth of the memory, it would require adding
more address lines to the address bus. What changes to the computer system would
need to be made to accommodate the wider address bus?

(A) The width of the program counter would need to be increased to support the
wider address bus.

(B) The size of the memory address register would need to be increased to
support the wider address bus.

(C) Instructions that use direct addressing would need additional bytes of oper-
and to pass the wider address into the CPU 8-bits at a time.

(D) All of the above

Summary

v A computer is a collection of hardware An operand is additional information that may
components that are constructed to perform be needed for the instruction.
a specific set of instructions to process and v An addressing mode refers to the way that
store data. The main hardware components the operand is treated. In immediate
of a computer are the central processing unit addressing the operand is the actual data to
(CPU), program memory, data memory, and be used. In direct addressing the operand is
input/output ports. the address of where the data is to be

v The CPU consists of registers for fast stor- retrieved or stored. In inherent addressing
age, an arithmetic logic unit (ALU) for data all of the information needed to complete
manipulation, and a control state machine the instruction is contained within the
that directs all activity to execute an opcode, so no operand is needed.
instruction. v A computer also contains data memory to

v A CPU is typically organized into a data path hold temporary variables during run time.
and a control unit. The data path contains v A computer also contains input and output
circuitry used to store and process informa- ports to interface with the outside world.
tion. The data path includes registers and the v A memory mapped system is one in which
ALU. The control unit is a large state machine the program memory, data memory, and I/O
that sends control signals to the data path in ports are all assigned a unique address. This
order to facilitate instruction execution. allows the CPU to simply process information

v The control unit performs a fetch-decode- as data and addresses and allows the pro-
execute cycle in order to complete gram to handle where the information is
instructions. being sent to. A memory map is a graphical

v The instructions that a computer is designed representation of what address ranges vari-
to execute is called its instruction set. ous components are mapped to.

v Instructions are inserted into program mem- v There are three primary classes of
ory in a sequence that when executed will instructions. These are loads and stores,
accomplish a particular task. This sequence data manipulations, and branches.
of instructions is called a computer program. v Load instructions move information from

v An instruction consists of an opcode and a memory into a CPU register. A load instruc-
potential operand. The opcode is the unique tion takes multiple read cycles. Store
binary code that tells the control state instructions move information from a CPU
machine which instruction is being executed. register into memory. A store instruction



Exercise Problems • 185

takes multiple read cycles and at least one Conditional branches only change the loca-
write cycle. tion of instruction execution if a status flag is

v Data manipulation instructions operate on asserted.
information being held in CPU registers. v Status flags are held in the condition code reg-
Data manipulation instructions often use ister and are updated by certain instructions.
inherent addressing. The most commonly used flags are the nega-

v Branch instructions alter the flow of instruc- tive flag (N), zero flag (Z), two’s complement
tion execution. Unconditional branches overflow flag (V), and carry flag (C).
always change the location in memory of
where the CPU is executing instructions.

Exercise Problems

Section 11.1: Computer Hardware ability to execute the three instructions
LDA_IMM, STA_DIR, and BRA. Simulate your

11.1.1 What computer hardware subsystem holds the
computer system using the following program

temporary variables used by the program?
that will continually write the patterns x“AA”

11.1.2 What computer hardware subsystem contains and x“BB” to output ports port_out_00 and
fast storage for holding and/or manipulating port_out_01:
data and addresses?

11.1.3 What computer hardware subsystem allows initial
the computer to interface to the outside world? begin

11.1.4 What computer hardware subsystem contains ROM[0] ¼ LDA_IMM;
the state machine that orchestrates the fetch- ROM[1] ¼ 8’hAA;
decode-execute process? ROM[2] ¼ STA_DIR;

ROM[3] ¼ 8’hE0;
11.1.5 What computer hardware subsystem contains ROM[4] ¼ STA_DIR;

the circuitry that performs mathematical and ROM[5] ¼ 8’hE1;
logic operations? ROM[6] ¼ LDB_IMM;

11.1.6 What computer hardware subsystem holds the ROM[7] ¼ 8’hBB;
instructions being executed? ROM[8] ¼ STB_DIR;

ROM[9] ¼ 8’hE0;

Section 11.2: Computer Software ROM[10] ¼ STB_DIR;
ROM[11] ¼ 8’hE1;

11.2.1 In computer software, what are the names of ROM[12] ¼ BRA;
the most basic operations that a computer can ROM[13] ¼ 8’h00;
perform? end

11.2.2 Which element of computer software is the 11.3.2 Add the functionality to the computer model
binary code that tells the CPUwhich instruction from 11.3.1 the ability to perform the LDA_DIR
is being executed? instruction. Simulate your computer system

11.2.3 Which element of computer software is a col- using the following program that will continually
lection of instructions that perform a desired read from port_in_00 and write its contents to
task? port_out_00:

11.2.4 Which element of computer software is the
supplementary information required by an initial
instruction such as constants or which begin
registers to use? ROM[0] ¼ LDA_DIR;

ROM[1] ¼ 8’hF0;
11.2.5 Which class of instructions handles moving ROM[2] ¼ STA_DIR;

information between memory and CPU ROM[3] ¼ 8’hE0;
registers? ROM[4] ¼ BRA;

11.2.6 Which class of instructions alters the flow of ROM[5] ¼ 8’h00;
program execution? end

11.2.7 Which class of instructions alters data using 11.3.3 Add the functionality to the computer model
either arithmetic or logical operations? from 11.3.2 the ability to perform the

instructions LDB_IMM, LDB_DIR, and
Section 11.3: Computer Implementation: STB_DIR. Modify the example programs

An 8-Bit Computer Example given in Exercises 11.3.1 and 11.3.2 to use
register B in order to simulate your

11.3.1 Design the example 8-bit computer system implementation.
presented in this chapter in Verilog with the



186 • Chapter 11: Computer System Design

11.3.4 Add the functionality to the computer model implementation using the following program.
from 11.3.3 the ability to perform the addition The first addition in this program will perform
instruction ADD_AB. Test your addition instruc- x“FE” + x“01” ¼ x“FF” (Z ¼ 0). The subsequent
tion by simulating the following program. The BEQ instruction should NOT take the branch.
first addition instruction will perform x“FE” + The second addition in this program will per-
x“01” ¼ x“FF” and assert the negative form x“FF” + x“01” ¼ x“00” (Z ¼ 1) and
(N) flag. The second addition instruction will SHOULD take the branch. The final instruction
perform x“01” + x“FF” ¼ x“00” and assert the in this program is a BRA that is inserted for
carry (C) and zero (Z) flags. The third addition safety. In the event that the BEQ is not
instruction will perform x“7F” + x“7F” ¼ x“FE” operating properly, the BRA will set the pro-
and assert the two’s complement overflow gram counter back to x“00” and prevent the
(V) and negative (N) flags. program from running away.

initial initial
begin begin
ROM[0] ¼ LDA_IMM; //-- test 1 ROM[0] ¼ LDA_IMM; //-- test 1
ROM[1] ¼ 8’hFE; ROM[1] ¼ 8’hFE;
ROM[2] ¼ LDB_IMM; ROM[2] ¼ LDB_IMM;
ROM[3] ¼ 8’h01; ROM[3] ¼ 8’h01;
ROM[4] ¼ ADD_AB; ROM[4] ¼ ADD_AB;
ROM[5] ¼ LDA_IMM; //-- test 2 ROM[5] ¼ BEQ; //--NO branch
ROM[6] ¼ 8’h01; ROM[6] ¼ 8’h00;
ROM[7] ¼ LDB_IMM;
ROM[8] ¼ 8’hFF; ROM[7] ¼ LDA_IMM; //-- test 2
ROM[9] ¼ ADD_AB; ROM[8] ¼ 8’h01;
ROM[10] ¼ LDA_IMM; //-- test 3 ROM[9] ¼ LDB_IMM;
ROM[11] ¼ 8’h7F; ROM[10] ¼ 8’hFF;
ROM[12] ¼ LDB_IMM; ROM[11] ¼ ADD_AB;
ROM[13] ¼ 8’h7F; ROM[12] ¼ BEQ; //-- Branch
ROM[14] ¼ ADD_AB; ROM[13] ¼ 8’h00;
ROM[15] ¼ BRA;
ROM[16] ¼ 8’h00;

end ROM[14] ¼ BRA;
ROM[15] ¼ 8’h00;

11.3.5 Add the functionality to the computer model end
from 11.3.4 the ability to perform the branch if
equal to zero instruction BEQ. Simulate your



Appendix A: List of Worked Examples

EXAMPLE 2.1 DECLARING VERILOG MODULE PORTS ..................................................... ..................................................... 19
EXAMPLE 3.1 BEHAVIORAL MODEL OF A 4-BIT ADDER IN VERILOG ............................................ ........................................... 28
EXAMPLE 3.2 COMBINATIONAL LOGIC USING CONTINUOUS ASSIGNMENT WITH LOGICAL OPERATORS ...................... ..................... 30
EXAMPLE 3.3 3-TO-8 ONE-HOT DECODER—VERILOG MODELING USING LOGICAL OPERATORS ......................... ......................... 31
EXAMPLE 3.4 7-SEGMENT DISPLAY DECODER—TRUTH TABLE ............................................... ............................................... 32
EXAMPLE 3.5 7-SEGMENT DISPLAY DECODER—LOGIC SYNTHESIS BY HAND ..................................... ..................................... 33
EXAMPLE 3.6 7-SEGMENT DISPLAY DECODER—VERILOG MODELING USING LOGICAL OPERATORS ....................... ....................... 34
EXAMPLE 3.7 4-TO-2 BINARY ENCODER—LOGIC SYNTHESIS BY HAND ......................................... ......................................... 35
EXAMPLE 3.8 4-TO-2 BINARY ENCODER—VERILOG MODELING USING LOGICAL OPERATORS ........................... .......................... 35
EXAMPLE 3.9 4-TO-1 MULTIPLEXER—VERILOG MODELING USING LOGICAL OPERATORS ............................. ............................. 36
EXAMPLE 3.10 1-TO-4 DEMULTIPLEXER—VERILOG MODELING USING LOGICAL OPERATORS ........................... .......................... 37
EXAMPLE 3.11 COMBINATIONAL LOGIC USING CONTINUOUS ASSIGNMENT WITH CONDITIONAL OPERATORS (1) ............... ............... 38
EXAMPLE 3.12 COMBINATIONAL LOGIC USING CONTINUOUS ASSIGNMENT WITH CONDITIONAL OPERATORS (2) ............... .............. 39
EXAMPLE 3.13 3-TO-8 ONE-HOT DECODER—VERILOG MODELING USING CONDITIONAL OPERATORS ..................... .................... 39
EXAMPLE 3.14 7-SEGMENT DISPLAY DECODER—VERILOG MODELING USING CONDITIONAL OPERATORS ................... .................. 40
EXAMPLE 3.15 4-TO-2 BINARY ENCODER—VERILOG MODELING USING CONDITIONAL OPERATORS ...................... ...................... 41
EXAMPLE 3.16 4-TO-1 MULTIPLEXER—VERILOG MODELING USING CONDITIONAL OPERATORS ......................... ......................... 41
EXAMPLE 3.17 1-TO-4 DEMULTIPLEXER—VERILOG MODELING USING CONDITIONAL OPERATORS ....................... ....................... 42
EXAMPLE 3.18 MODELING DELAY IN CONTINUOUS ASSIGNMENTS ............................................. ............................................. 44
EXAMPLE 3.19 INERTIAL DELAY MODELING WHEN USING CONTINUOUS ASSIGNMENT ................................ ................................ 45
EXAMPLE 4.1 VERILOG STRUCTURAL DESIGN USING EXPLICIT PORT MAPPING ..................................... .................................... 52
EXAMPLE 4.2 VERILOG STRUCTURAL DESIGN USING POSITIONAL PORT MAPPING ................................... .................................. 53
EXAMPLE 4.3 MODELING COMBINATIONAL LOGIC CIRCUITS USING GATE-LEVEL PRIMITIVES ............................ ............................ 54
EXAMPLE 4.4 MODELING COMBINATIONAL LOGIC CIRCUITS WITH A USER-DEFINED PRIMITIVE ........................... .......................... 55
EXAMPLE 4.5 DESIGN OF A HALF ADDER ............................................................. ............................................................. 56
EXAMPLE 4.6 DESIGN OF A FULL ADDER ............................................................. ............................................................. 57
EXAMPLE 4.7 DESIGN OF A FULL ADDER OUT OF HALF ADDERS .............................................. ............................................. 58
EXAMPLE 4.8 DESIGN OF A 4-BIT RIPPLE CARRY ADDER (RCA) ............................................ ............................................ 59
EXAMPLE 4.9 STRUCTURAL MODEL OF A FULL ADDER USING TWO HALF ADDERS .................................. .................................. 60
EXAMPLE 4.10 STRUCTURAL MODEL OF A 4-BIT RIPPLE CARRY ADDER IN VERILOG ................................ ............................... 61
EXAMPLE 5.1 USING BLOCKING ASSIGNMENTS TO MODEL COMBINATIONAL LOGIC .................................. .................................. 69
EXAMPLE 5.2 USING NON-BLOCKING ASSIGNMENTS TO MODEL SEQUENTIAL LOGIC ................................. ................................. 69
EXAMPLE 5.3 IDENTICAL BEHAVIOR WHEN USING BLOCKING VS. NON-BLOCKING ASSIGNMENTS ......................... ......................... 70
EXAMPLE 5.4 DIFFERENT BEHAVIOR WHEN USING BLOCKING VS. NON-BLOCKING ASSIGNMENTS (1) ...................... ..................... 71
EXAMPLE 5.5 DIFFERENT BEHAVIOR WHEN USING BLOCKING VS. NON-BLOCKING ASSIGNMENTS (2) ...................... ..................... 72
EXAMPLE 5.6 BEHAVIOR OF STATEMENT GROUPS BEGIN/END VS. FORK/JOIN ..................................... ..................................... 73
EXAMPLE 5.7 USING IF-ELSE STATEMENTS TO MODEL COMBINATIONAL LOGIC ..................................... .................................... 75
EXAMPLE 5.8 USING CASE STATEMENTS TO MODEL COMBINATIONAL LOGIC ...................................... ..................................... 76
EXAMPLE 6.1 TEST BENCH FOR A COMBINATIONAL LOGIC CIRCUIT WITH MANUAL STIMULUS GENERATION .................. .................. 90
EXAMPLE 6.2 TEST BENCH FOR A SEQUENTIAL LOGIC CIRCUIT .............................................. .............................................. 91
EXAMPLE 6.3 PRINTING TEST BENCH RESULTS TO THE TRANSCRIPT ........................................... .......................................... 92
EXAMPLE 6.4 USING A LOOP TO GENERATE STIMULUS IN A TEST BENCH ........................................ ....................................... 94
EXAMPLE 6.5 TEST BENCH WITH AUTOMATIC OUTPUT CHECKING ............................................. ............................................. 95
EXAMPLE 6.6 PRINTING TEST BENCH RESULTS TO AN EXTERNAL FILE .......................................... ......................................... 97
EXAMPLE 6.7 READING TEST BENCH STIMULUS VECTORS FROM AN EXTERNAL FILE ................................ ................................ 98
EXAMPLE 7.1 BEHAVIORAL MODEL OF A D-LATCH IN VERILOG ............................................. ............................................. 103
EXAMPLE 7.2 BEHAVIORAL MODEL OF A D-FLIP-FLOP IN VERILOG ........................................... ........................................... 104
EXAMPLE 7.3 BEHAVIORAL MODEL OF A D-FLIP-FLOP WITH ASYNCHRONOUS RESET IN VERILOG ...................... ...................... 105
EXAMPLE 7.4 BEHAVIORAL MODEL OF A D-FLIP-FLOP WITH ASYNCHRONOUS RESET AND PRESET IN VERILOG ............. ............. 106
EXAMPLE 7.5 BEHAVIORAL MODEL OF A D-FLIP-FLOP WITH SYNCHRONOUS ENABLE IN VERILOG ....................... ...................... 107
EXAMPLE 7.6 RTL MODEL OF AN 8-BIT REGISTER IN VERILOG ............................................. ............................................ 108

# Springer Nature Switzerland AG 2019 187
B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5



188 • Appendix A: List of Worked Examples

EXAMPLE 7.7 RTL MODEL OF A 4-STAGE, 8-BIT SHIFT REGISTER IN VERILOG .................................. .................................. 109
EXAMPLE 7.8 REGISTERS AS AGENTS ON A DATA BUS—SYSTEM TOPOLOGY .......................................................................... 110
EXAMPLE 7.9 REGISTERS AS AGENTS ON A DATA BUS—RTL MODEL IN VERILOG ................................................................. 110
EXAMPLE 7.10 REGISTERS AS AGENTS ON A DATA BUS—SIMULATION WAVEFORM .................................................................. 111
EXAMPLE 8.1 PUSH-BUTTON WINDOW CONTROLLER IN VERILOG—DESIGN DESCRIPTION ......................................................... 114
EXAMPLE 8.2 PUSH-BUTTON WINDOW CONTROLLER IN VERILOG—PORT DEFINITION ............................................................... 114
EXAMPLE 8.3 PUSH-BUTTON WINDOW CONTROLLER IN VERILOG—FULL MODEL ..................................................................... 117
EXAMPLE 8.4 PUSH-BUTTON WINDOW CONTROLLER IN VERILOG—SIMULATION WAVEFORM ...................................................... 118
EXAMPLE 8.5 PUSH-BUTTON WINDOW CONTROLLER IN VERILOG—CHANGING STATE CODES ..................................................... 118
EXAMPLE 8.6 SERIAL BIT SEQUENCE DETECTOR IN VERILOG—DESIGN DESCRIPTION AND PORT DEFINITION ............................... 119
EXAMPLE 8.7 SERIAL BIT SEQUENCE DETECTOR IN VERILOG—FULL MODEL .................................... .................................... 120
EXAMPLE 8.8 SERIAL BIT SEQUENCE DETECTOR IN VERILOG—SIMULATION WAVEFORM ............................. ............................ 121
EXAMPLE 8.9 VENDING MACHINE CONTROLLER IN VERILOG—DESIGN DESCRIPTION AND PORT DEFINITION ................ ............... 121
EXAMPLE 8.10 VENDING MACHINE CONTROLLER IN VERILOG—FULL MODEL .................................... .................................... 122
EXAMPLE 8.11 VENDING MACHINE CONTROLLER IN VERILOG—SIMULATION WAVEFORM ............................. ............................ 123
EXAMPLE 8.12 2-BIT UP/DOWN COUNTER IN VERILOG—DESIGN DESCRIPTION AND PORT DEFINITION ................... ................... 123
EXAMPLE 8.13 2-BIT UP/DOWN COUNTER IN VERILOG—FULL MODEL (THREE-BLOCK APPROACH) ..................... ..................... 124
EXAMPLE 8.14 2-BIT UP/DOWN COUNTER IN VERILOG—SIMULATION WAVEFORM ................................. ................................. 124
EXAMPLE 9.1 BINARY COUNTER USING A SINGLE PROCEDURAL BLOCK IN VERILOG ............................... ............................... 129
EXAMPLE 9.2 BINARY COUNTER WITH RANGE CHECKING IN VERILOG ......................................... ......................................... 130
EXAMPLE 9.3 BINARY COUNTER WITH ENABLE IN VERILOG ................................................ ................................................ 131
EXAMPLE 9.4 BINARY COUNTER WITH LOAD IN VERILOG .................................................. ................................................. 132
EXAMPLE 10.1 BEHAVIORAL MODELS OF A 4  4 ASYNCHRONOUS READ-ONLY MEMORY IN VERILOG ................... .................. 137
EXAMPLE 10.2 BEHAVIORAL MODELS OF A 4  4 SYNCHRONOUS READ-ONLY MEMORY IN VERILOG .................... ................... 138
EXAMPLE 10.3 BEHAVIORAL MODEL OF A 4  4 ASYNCHRONOUS READ/WRITE MEMORY IN VERILOG ................... .................. 139
EXAMPLE 10.4 BEHAVIORAL MODEL OF A 4  4 SYNCHRONOUS READ/WRITE MEMORY IN VERILOG .................... ................... 140
EXAMPLE 11.1 MEMORY MAP FOR A 256  8 MEMORY SYSTEM ........................................... ........................................... 148
EXAMPLE 11.2 EXECUTION OF AN INSTRUCTION TO “LOAD REGISTER A USING IMMEDIATE ADDRESSING” ................. ................. 151
EXAMPLE 11.3 EXECUTION OF AN INSTRUCTION TO “LOAD REGISTER A USING DIRECT ADDRESSING” ................... ................... 152
EXAMPLE 11.4 EXECUTION OF AN INSTRUCTION TO “STORE REGISTER A USING DIRECT ADDRESSING” ................... .................. 153
EXAMPLE 11.5 EXECUTION OF AN INSTRUCTION TO “ADD REGISTERS A AND B” ................................. ................................. 154
EXAMPLE 11.6 EXECUTION OF AN INSTRUCTION TO “BRANCH ALWAYS” ........................................ ........................................ 155
EXAMPLE 11.7 EXECUTION OF AN INSTRUCTION TO “BRANCH IF EQUAL TO ZERO” ................................ ................................ 156
EXAMPLE 11.8 TOP-LEVEL BLOCK DIAGRAM FOR THE 8-BIT COMPUTER SYSTEM .................................. ................................. 158
EXAMPLE 11.9 INSTRUCTION SET FOR THE 8-BIT COMPUTER SYSTEM ......................................... ........................................ 159
EXAMPLE 11.10 MEMORY SYSTEM BLOCK DIAGRAM FOR THE 8-BIT COMPUTER SYSTEM ............................ ............................ 160
EXAMPLE 11.11 CPU BLOCK DIAGRAM FOR THE 8-BIT COMPUTER SYSTEM .................................... .................................... 164
EXAMPLE 11.12 STATE DIAGRAM FOR LDA_IMM ..................................................... ..................................................... 171
EXAMPLE 11.13 SIMULATION WAVEFORM FOR LDA_IMM ................................................ ................................................ 172
EXAMPLE 11.14 STATE DIAGRAM FOR LDA_DIR ...................................................... ..................................................... 173
EXAMPLE 11.15 SIMULATION WAVEFORM FOR LDA_DIR ................................................ ................................................ 174
EXAMPLE 11.16 STATE DIAGRAM FOR STA_DIR ...................................................... ..................................................... 175
EXAMPLE 11.17 SIMULATION WAVEFORM FOR STA_DIR ................................................. ................................................ 176
EXAMPLE 11.18 STATE DIAGRAM FOR ADD_AB ...................................................... ...................................................... 177
EXAMPLE 11.19 SIMULATION WAVEFORM FOR ADD_AB ................................................. ................................................ 178
EXAMPLE 11.20 STATE DIAGRAM FOR BRA .......................................................... ......................................................... 179
EXAMPLE 11.21 SIMULATION WAVEFORM FOR BRA .................................................... .................................................... 180
EXAMPLE 11.22 STATE DIAGRAM FOR BEQ .......................................................... ......................................................... 181
EXAMPLE 11.23 SIMULATION WAVEFORM FOR BEQ WHEN TAKING THE BRANCH (Z ¼ 1) ........................... .......................... 182
EXAMPLE 11.24 SIMULATION WAVEFORM FOR BEQ WHEN THE BRANCH IS NOT TAKEN (Z ¼ 0) ...................... ...................... 183



Index

A Design levels, 5
algorithmic level, 5

Abstraction, 4 circuit level, 5
gate-level, 5

C
register transfer level, 5

Capacity, 135, 136 system level, 5

Classical digital design flow, 8 Digital design flow, 8

Computer system design, 143
F

addressing modes, 149
arithmetic logic unit (ALU), 145, 146 Full adders, 56, 57
central processing unit, 144, 145
condition code register, 145 G

control unit, 145
Gajski and Kuhn’s Y-chart, 5

data memory, 144
data path, 145 H
direct addressing, 149
example 8-bit system, 157, 158 Half adders, 56

CPU, 163, 164 History of HDLs, 1–3
detailed instruction execution, 170, 171
instruction set, 158, 159 M

memory system, 159, 160
Memory map model, 135, 136

general-purpose registers, 145
Modern digital design flow, 8

hardware, 143
Multiplexer design by hand, 36, 41

immediate addressing, 149
Multiplexers, 36, 41

inherent addressing, 150
input output ports, 144 N
instruction register, 145
instructions, 143 Non-volatile memory, 136

branches, 154, 155
data manipulations, 153 O

loads and stores, 150, 151
One-hot binary encoder design by hand, 34, 35

memory address register, 145
One-hot binary encoder modeling in Verilog, 34, 35

memory map, 147
One-hot decoder modeling in Verilog, 30, 31

memory mapped system, 146
opcodes, 149 P
operands, 149
program, 143 Place and route, 8

program counter, 145
R

program memory, 144
registers, 145 Random-access memory (RAM), 136
software, 143, 148 Read cycle, 135, 136

Counters, 131 Read-only memory (ROM), 136
modeling in Verilog, 131 Read/write (RW) memory, 136

Ripple carry adders (RCA), 58
D

S
Design abstraction, 4
Design domains, 5 Semiconductor memory, 135

behavioral domain, 5 Sequential access memory, 136
physical domain, 5 7-segment decoder design by hand, 31
structural domain, 5 7-segment decoder modeling in Verilog, 33

# Springer Nature Switzerland AG 2019 189

B. J. LaMeres, Quick Start Guide to Verilog, https://doi.org/10.1007/978-3-030-10552-5



190 • Index

T net data types, 14
number formatting

Technology mapping, 8 binary, 16
decimal, 16

V hex, 16

Verification, 6 octal, 16

Verilog operators, 23
assignment, 23

always blocks, 66
bitwise logical, 24

arrays, 16
bitwise replication, 27

behavioral modeling techniques
Boolean logic, 25

agents on a bus, 109, 110
concatenation, 26

counters, 129–131
conditional, 26

D-flip-flops, 103, 104
numerical, 27

D-flip-flop with enable, 106, 107
precedence, 28

D-flip-flop with preset, 105, 106
reduction, 25

D-flip-flop with reset, 104, 105
relational, 25

D-latches, 103
parameters, 20

encoding styles, 118
procedural assignment, 65

finite state machines, 113
next state logic, 115 procedural blocks, 65

output logic, 116 repeat loops, 78

registers, 107, 108 resolution, 14

shift registers, 108, 109 sensitivity lists, 67, 68

state memory, 115 signal declaration, 19

state variables, 114 statement groups, 73
up counters with enables, 131 structural design and hierarchy, 56–61
up counters with loads, 131, 132 explicity port mapping, 51
up counter, 129 gate level primitives, 53, 54
up counter with range checking, 130 instantiation, 51

casex statements, 77 positional port mapping, 52, 53
casez statements, 77 user defined primitives, 54, 55

compiler directives, 20 system tasks, 80

include, 20, 21 file I/O, 81, 82
timescale, 20 simulation control, 83

continuous assignment, 23, 24 text I/O, 80

continuous assignment with conditional operators, 38 test benches, 89

continuous assignment with delay, 43, 44 user defined primitives, 54, 55

continuous assignment with logical operators, 29 value set, 14

counters, 129, 130 variable data types, 15

data types, 13 vectors, 15

disable, 79 while loops, 77

drive strength, 14 Volatile memory, 136

finite state machines, 113
W

forever loops, 77
for loops, 78 Write cycle, 135, 136
gate level primitives, 53, 54
history, 2 Y

if-else statements, 74, 75
Y-chart, 5

initial blocks, 66