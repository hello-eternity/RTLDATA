Verilog and SystemVerilog
Gotchas
101 Common CodingErrors and How to
Avoid Them



Stuart Sutherland
Don Mills

Verilog and SystemVerilog
Gotchas
101 Common Coding Errors and How to
Avoid Them

~ Springer



StuartSutherland Don Mills
Sutherland HDL, Inc. LCDM Engineering
Tualatin, OR Chandler, AZ
USA USA

Libraryof CongressControlNumber: 2007926706

ISBN978-0-387-71714-2 e-ISBN978-0-387-71715-9

Printedon acid-freepaper.

© 2007SpringerScience+Business Media,LLC
All rights reserved. This work may not be translated or copied in whole or in part without
the writtenpermissionof the publisher(SpringerScience-BusinessMedia,LLC,233 Spring
Street,New York, NY 10013,USA),except for brief excerptsin connection with reviews or
scholarly analysis. Use in connection with any form of information storage and retrieval,
electronic adaptation, computer software, or by similar or dissimilar methodology now
know or hereafter developed is forbidden. The use in this publication of trade names,
trademarks, servicemarksand similar terms, even if they are not identifiedas such, is not to
be taken as an expression of opinion as to whether or not they are subject to proprietary
rights.

9 8 7 6 5 432 1

springer.com



Dedication

To my wonderful wife, LeeAnn, and my children, Ammon, Tamara, Hannah, Sethand
Samuel- thankyoufor yourpatienceduringthe many longhoursand latenights
you toleratedwhile this bookwas beingwritten.

StuSutherland
Portland, Oregon

To my wifeandsweetheart GeriJean, and my children, Sara, Kirsten, Adam, Alex,
Dillan, Donnelle, Grantand Gina- thanks to eachofyoufor thepatienceyou have
hadwithme as I havedealtwithdebugging manyofthesegotchason designs overthe
years.

Don Mills
Chandler, Arizona



About the Authors

Mr. Stuart Sutherland is a member of the IEEE 1800 working
group that oversees both the Verilog and SystemVerilog
standards. He has been involved with the definition of the
Verilog standard since its inception in 1993, and the
SystemVerilog standard since work began in 200I. In addition,
Stuart is the technical editor of the official IEEE Verilog and
SystemVerilog Language Reference Manuals (LRMs). Stuart is
an independent Verilog consultant, specializing in providing

comprehensive expert training on the Verilog HDL, SystemVerilog and PLI.
Stuart is a co-authorof the books "SystemVerilog for Design", "Verilog-2001: A
Guide to the New Features in the Verilog Hardware Description Language" and
is the author of "The Verilog PLl Handbook", as well as the popular "Verilog
HDL Quick Reference Guide" and"Verilog PLl QuickReference Guide". He has
alsoauthored a number of technical papers on Verilog and SystemVerilog, which
are available at www.sutherland-hdl.com/papers. You can contact Stuart at
stuart@sutherland-hdl.com.

visit the authorswebpage at www.sutherland-hdl.com

Mr. Don Mills has been involved in ASIC design since 1986.
During that time, he has worked on morethan 30 ASIC projects.
Don started using top-down design methodology in 1991
(Synopsys Design Compiler 1.2). Don has developed and
implemented top-down ASIC design flows at several companies.
His specialty is integrating tools and automating the flow. Don
works for Microchip Technology Inc. as an internal
SystemVerilog and Verilog consultant. Don is a member of the

IEEE Verilog and System Verilog committees that are working on language
issues and enhancements. Don has authored and co-authored numerous papers,
such as "SystemVerilog Assertions are for Design Engineers Too!" and "RTL
Coding Styles that Yield Simulation and Synthesis Mismatches". Copies of these
papers can be found at www.lcdm-eng.com.Mr. Mills can be reached at
mills@lcdm-eng.comor don.mills@microchip.com.

visit the authorswebpage at www.lcdm-eng.com



Acknowledgments

The authors express their sincere appreciation to the contributions of several
Verilog and SystemVerilog experts.

Chris Spear of Synopsys, Inc. suggested several of the verification related
gotchas, provided the general descriptions of these gotchas, and ran countless
tests forus.

Shalom Bresticker of Intelalsosuggested several gotchas.

Jonathan Bromley of Doulos, Ltd., Clifford Cummings of Sunburst Design,
Tom Fitzpatrick of Mentor Graphics, Steve Golson of Trilobyte Systems, Gregg
Lahti of Microchip Technology, Inc. and Chris Spear of Synopsys, Inc. provided
thorough technical reviews of this book, and offered invaluable comments on
howto improve the gotcha descriptions.

Steve Golson of Trilobyte Systems provided a wonderful foreword to thisbook

Lastly, we acknowledge and express our gratitude to our wives, LeeAnn
Sutherland and Geri Jean Mills, for meticulously reviewing this book for
grammar and punctuation. If any sucherrataremain in the book, it could onlybe
due to changes we madeaftertheirreviews.



Table ofContents

List of Gotchas...•••.••..•....•••....•..•.•..•..••.....•...••..•.........••................•..•.........•..•.............•..... xv

Foreword
by SteveGolson...••..•.......••...•......................•.....•...................•.................•..••................•.•.•. 1

Chapter 1:
Introduction,
What Is A Gotcha? 3

Chapter 2:
Declaration and Literal Number Gotchas 7
Gotcha 1: Case sensitivity 7
Gotcha 2: Implicitnet declarations 10
Gotcha 3: Default of l-bit internal nets 13
Gotcha4: Single file versus multi-file compilation of $unit declarations 15
Gotcha 5: Local variable declarations 17
Gotcha6: Escapednames in hierarchical paths 19
Gotcha 7: Hierarchical references to automatic variables 22
Gotcha 8: Hierarchical references to variables in unnamedblocks 25
Gotcha9: Hierarchical references to importedpackage items 27
Gotcha 10: Importingenumerated types from packages 28
Gotcha 11: Importingfrom multiplepackages 29
Gotcha 12: Default base of literal integers 30
Gotcha 13: Signedness of literal integers 32
Gotcha 14: Signed literal integerszero extend to their specifiedsize 33
Gotcha 15: Literal integer size mismatch in assignments 35
Gotcha 16: Filling vectorswith all ones 37
Gotcha 17: Array literalsversusconcatenations 38
Gotcha 18: Port connectionrules 39
Gotcha 19: Back-driven ports 43



Table of Contents

Gotcha 20: Passing real (floating point)numbers through ports 46

Chapter 3:
RTL Modeling Gotchas 49

Gotcha21: Combinational logicsensitivity listswith function calls 49
Gotcha22: Arrays in sensitivity lists 52
Gotcha23: Vectors in sequential logicsensitivity lists 54
Gotcha24: Operations in sensitivity lists 56
Gotcha25: Sequential logicblocks withbegin end groups 57
Gotcha26: Sequential logicblockswith resets 59
Gotcha 27: Asynchronous set/reset flip-flop for simulation and synthesis 60
Gotcha28: Blocking assignments in sequential procedural blocks 62
Gotcha29: Sequential logicthat requires blocking assignments 64
Gotcha30: Nonblocking assignments in combinational logic 66
Gotcha31: Combinational logicassignments in the wrongorder 70
Gotcha32: Casez/casex masksin caseexpressions 72
Gotcha33: Incomplete decision statements 74
Gotcha34: Overlapped decision statements 77
Gotcha35: Inappropriate use of unique casestatements 79
Gotcha36: Resetting 2-statemodels 82
Gotcha 37: Lockedstatemachines modeled with enumerated types 84
Gotcha38: Hidden design problems with4-statelogic 86
Gotcha39: Hiddendesign problems using2-statetypes 88
Gotcha40: Hidden problems with out-of-bounds arrayaccess 90
Gotcha 41: Out-of-bounds assignments to enumerated types 92
Gotcha 42: Undetected sharedvariables in modules 94
Gotcha43: Undetected sharedvariables in interfaces and packages 96

Chapter 4:
Operator Gotchas 99
Gotcha 44: Assignments in expressions 99
Gotcha 45: Self-determined versuscontext-determined operators 101
Gotcha46: Operation sizeand sign extension in assignment statements 105
Gotcha47: Signedarithmetic rules 108

xii



Table of Contents

Gotcha 48: Bit-select and part-select operations 111
Gotcha 49: Increment, decrement and assignment operators 112
Gotcha 50: Pre-increment versuspost-increment operations 113
Gotcha 51: Modifying a variable multiple times in one statement 115
Gotcha52: Operator evaluation shortcircuiting 116
Gotcha53: The not operator( ! ) versus the invertoperator( -- ) 118
Gotcha54: Arraymethod operations 119
Gotcha 55: Arraymethod operations on an arraysubset. 121

Chapter 5:
General Programming Gotchas 123

Gotcha56: Verifying asynchronous and synchronous reset at time zero 123
Gotcha57: Nestedif else blocks 128
Gotcha 58: Evaluation of equality with4-statevalues 129
Gotcha 59: Eventtriggerrace conditions 131
Gotcha60: Usingsemaphores for synchronization 134
Gotcha 61: Usingmailboxes for synchronization 137
Gotcha 62: Triggering on clocking blocks 139
Gotcha 63: Misplaced semicolons afterdecision statements 140
Gotcha 64: Misplaced semicolons in for loops ~ 142
Gotcha65: Infinitefor loops 144
Gotcha 66: Lockedsimulation due to concurrent for loops 145
Gotcha 67: Referencing for loopcontrol variables 147
Gotcha68: Defaultfunction returnsize 148
Gotcha69: Task/function arguments with defaultvalues 150
Gotcha70: Continuous assignments with delays cancel glitches 151

Chapter 6:
Object Oriented and Multi-Threaded Programming Gotchas 153
Gotcha 71: Programming statements in a class 153
Gotcha 72: Using interfaces with object-oriented testbenches 155
Gotcha 73: All objects in mailbox comeout with the samevalues 157
Gotcha 74: Passing handles to methods using inputversus ref arguments 158
Gotcha 75: Constructing an arrayof objects 159

xiii



Table of Contents

Gotcha 76: Statictasksand functions are not re-entrant 160
Gotcha 77: Staticversus automatic variable initialization 162
Gotcha 78: Forkedprogramming threads needautomatic variables 164
Gotcha 79: Disable forkkills too manythreads 166
Gotcha 80: Disabling a statement blockstopsmorethan intended 168
Gotcha 81: Simulation exitsprematurely, beforetestscomplete 171

Chapter 7:
Randomization, Coverage and Assertion Gotchas 173
Gotcha 82: Variables declared withrandare not getting randomized 173
Gotcha 83:Undetected randomization failures 175
Gotcha 84: $assertoffcoulddisable randomization 177
Gotcha 85: Boolean constraints on more than tworandom variables 179
Gotcha 86: Unwanted negative values in random values 181
Gotcha 87: Coverage reports default to groups, not bins 182
Gotcha 88: Coverage is always reported as 0% 184
Gotcha 89: The coverage reportlumps all instances together 186
Gotcha 90: Covergroup argument directions are sticky 187
Gotcha 91: Assertion passstatements execute witha vacuous success 188
Gotcha 92: Concurrent assertions in procedural blocks 190
Gotcha 93: Mismatch in assert else statements 192
Gotcha 94: Assertions that cannot faiI. 193

Chapter 8:
Tool Compatibility Gotchas 195
Gotcha 95: Defaultsimulation timeunitsand precision 195
Gotcha 96: Package chaining 198
Gotcha 97: Random number generator is not consistent across tools 200
Gotcha 98: Loading memories modeled withalways_latchlalways_ff 202
Gotcha 99: Non-standard language extensions 204
Gotcha 100:Array literals versus concatenations 206
Gotcha 101 :Module portsthat passfloating pointvalues (real types) 208

Index •.••••..••.•..•••.••..•.•••••••••••••..••.••••.•....•••..•.••..••.••••.••.•..•..••.......•...•••.•.••.•.••..•••....•••..•...••. 209

xiv



List ofGotchas

Gotcha 1: 7
The names in my code look correct and worked in my VHDL models, but
Verilog/System Verilog gets errors about "undeclared identifiers ''.

Gotcha 2: 10
A typo in my design connections was not caught by the compiler, and only
showedup as afunctional problemin simulation.

Gotcha 3: 13
In my netlist, only bit zero ofmy vectorports get connected.

Gotcha 4: 15
My models compile OK, and the modelsfrom anothergroup compile OK; but
whencompiledtogether, I get errorsaboutmultiple declarations.

Gotcha 5: 17
I get compilation errorson my localvariable declarations, but the declaration
syntax is correct.

Gotcha 6: 19
I get weird compiler errors when I try to reference a design signal with an
escapednamefrom my testbench.

Gotcha 7: 22
I get compilation errorswhenmy testbench tries toprint outsomesignalsin my
design, but othersignalscan beprinted withouta problem.

Gotcha 8: 25
With Verilog, my testbench couldprintout localvariables in a begin endblock,
but with SystemVerilog I get compilation errors.

Gotcha 9: 27
My design can use importedpackage itemsjust fine, but my testbench cannot
access the itemsfor verification.

Gotcha 10: 28
I importedan enumerated typefrom a package, but I cannot access the labels
definedby the enumerated type.

Gotcha 11: 29
I get errorswhenI try to wildcardimportmultiplepackages, but I can wildcard
importeachpackageseparately withoutany errors.



Listof Gotchas

Gotcha 12: 30
Some branches ofmy case statement are neverselected, even with the correct
inputvalues.

Gotcha 13: 32
My lncrementor modelsometimes gets incorrect values when I increment using
a literal1 'b1.

Gotcha 14: 33
When I specifya signed, sized literalinteger with a negative value, it does not
sign extend.

Gotcha 15: 35
When I assign a 4-bit negative value to an 8-bit signed variable, it is not sign
extended.

Gotcha 16: 37
I can use a literal integerto set all bits to Z on a vectorofany size, but when I
use the samesyntaxto set all bits to 1, I get a decimal 1 instead.

Gotcha 17: 38
The wrongvalues arestoredwhenI assign a listofvalues to a packedarrayor
structure.

Gotcha 18: 39
My design doesn't workcorrectly when I connect all the modules together, but
eachmodule workscorrectly by itself.

Gotcha 19: 43
I declaredmy port as an input, and software tools let me accidentally use the
port as an output, without any errors or warnings.

Gotcha 20: 46
I cannotfind a way topass realvalues from onemodule to anotherusingeither
Verilog or System Veri/og.

Gotcha 21: 49
My combinational logic seemedto simulate OK, but after synthesis, the gate­
levelsimulation doesnot matchthe RTLsimulation.

Gotcha 22: 52
I need my combinational logic block to be sensitive to all elements ofa RAM
array, but the sensitivity list won't triggerat the correcttimes.

Gotcha 23: 54
My always block is supposedto triggeron anypositiveedge in a vector, but it
misses mostedges.

xvi



Listof Gotchas

Gotcha 24: 56
My sensitivity list should trigger on any edge of a or b, but it misses some
changes.

Gotcha 25: 57
The clocked logic in my sequential block gets updated, even when no clock
occurred.

Gotcha 26: 59
Someofthe outputs ofmy sequential logicdo not get reset.

Gotcha 27: 60
When I code an asynchronous set/reset D-type flip-flop following synthesis
codingrules, mysimulation results are sometimes wrong.

Gotcha 28: 62
Myshift register sometimes doesa double shift in one clockcycle.

Gotcha 29: 64
I'm following the recommendations for using nonblocking assignments in
sequential logic, butI still haveraceconditions in simulation.

Gotcha 30: 66
MyRTLsimulation locksup and timestopsadvancing.

Gotcha 31: 70
Simulation ofmygate-level combinational logicdoesnotmatch RTLsimulation.

Gotcha 32: 72
Mycasexstatement is takingthewrongbranch whenthereis anerrorinthecase
expression.

Gotcha 33: 74
Myfull_case, parallel_case decision statement simulatedas I expected, but the
chipdoesnot work.

Gotcha 34: 77
Oneofmy decision branches nevergets executed.

Gotcha 35: 79
I am using uniquecase everywhere to help trap design bugs but my synthesis
results are not whatI expected.

Gotcha 36: 82
My design fails to reset thefirst time in RTL simulation.

Gotcha 37: 84
Mystate machine modellocksup in its start-up state.

xvii



Listof Gotchas

Gotcha 38: 86
There wasaproblemdeep insidethe logicofmy design, but it neverpropagated
to moduleboundaries.

Gotcha 39: 88
Some majorfunctional bugs in my design did not show up untilaftersynthesis,
whenI ran gate-levelsimulations.

Gotcha 40: 90
A design bugcausedreferences to nonexistent memoryaddresses, but therewas
no indication ofa problem in RTL simulation.

Gotcha 41: 92
My enumerated state machine variables have values that don't exist in the
enumerated definition.

Gotcha 42: 94
My RTL model output changes values when it shouldn't, and to unexpected
values.

Gotcha43: 96
Variables in mypackagekeepchanging at unexpected timesand to unexpected
values.

Gotcha 44: 99
I need to do an assignment as part ofan ifcondition, but cannot get my code to
compile.

Gotcha 45: 101
In some operations, my data is sign extendedand in other operations it is not
sign extended, and inyet otheroperations it is not extendedat all.

Gotcha 46: 105
I declared my outputs as signed types, but my design is still doing unsigned
operations.

Gotcha 47: 108
MysignedaddermodelworkedperfectlyuntilI addeda carry-in input, andnow
it only does unsignedaddition.

Gotcha 48: 111
All my data typesaredeclaredas signed, andI am referencing theentiresigned
vectors in my operations, yet I still get unsignedresults.

Gotcha 49: 112
I'm usingthe ++operatorfor mycounter; thecountervalueis correct, butother
code that reads the countersees the wrongvalue.

xviii



Listof Gotchas

Gotcha 50: 113
My while loop is supposedto execute 16 times, but it exits after 15 times, even
though the loopcontrolvariable has a valueof16.

Gotcha 51: 115
When I have multiple operations on a variable in a single statement. I get
different results from different simulators.

Gotcha52: 116
I am callingafunction twice in a statement, but sometimes onlyoneofthecalls
is executed.

Gotcha 53: 118
My ifstatement witha not-true condition did not execute when I wasexpecting
it to.

Gotcha 54.' 119
I get the wrongresult when I sum all the values ofan array using the built-in
.summethod

Gotcha 55: 121
I get the wronganswerwhenI sum specific arrayelements in an array.

Gotcha 56.' 123
Sometimes my design resets correctly at time zero, and sometimes it fails to
reset.

Gotcha 57: 128
My else branch ispairingup with the wrongifstatement.

Gotcha 58: 129
My testbench completely misses problems on design outputs, even though it is
testingthe outputs.

Gotcha59: 131
I'm using the event data type to synchronize processes, but sometimes when I
triggeran event, thesensingprocessdoes not activate.

Gotcha 60: 134
Myprocesses arenotsynchronizing thewayI expectedusingsemaphores. Even
when therearewaitingprocesses, someotherprocessgets to runaheadofthem.

Gotcha 61: 137
My mailbox works atfirst, and thenstartsgettingerrorsduringsimulation.

Gotcha 62: 139
I cannotget my testprogram to waitfor a clocking blockedge.

xix



Listof Gotchas

Gotcha 63: 140
Statements in my i/O decision execute, evenwhen the condition is not true.

Gotcha 64: 142
Myfor loop only executes one time.

Gotcha 65.' , " " .. , , 144
Myfor loopneverexits. When the loopvariable reaches the exit value, the loop
just starts over again.

Gotcha 66.' 145
When I run simulation, myfor loopslock up or do strangethings.

Gotcha 67: , 147
My Verilog code no longercompiles after I convertmy Verilog-style for loops
to a SystemVerilog style.

Gotcha 68: , 148
Myfunction only returns the leastsignificant bit ofthe return value.

Gotcha 69.' , , 150
I get a syntax error when I try to assign my task/function input arguments a
defaultvalue.

Gotcha 70.' , , " 151
Some delayedoutputsshow up with continuous assignments and others do not.

Gotcha 71: , , ,., , .. , .. "", ",." .. , .153
Someprogramming code in an initialprocedurecompiles OK, but whenI move
the code to a class definition, I get compilation errors.

Gotcha 72.' , 155
I get a compilation error whenI try to use a class object to create test values
whenthe testbench connects to the design usingan interface.

Gotcha 73.' , ,." , , , " .. 157
My codecreatesrandom objectvaluesandputs themintoa mailbox, but all the
objectscomingout ofthe mailboxhave the same value.

Gotcha 74.' "."" , , ", .. , ,., , .. ,., ,., 158
My methodconstructs and initializes an object, but I can neversee the object's
value.

Gotcha 75: " , " .. , , .. , 159
I declaredan arrayofobjects, butget a syntaxerrorwhenI try to construct the
array.

Gotcha 76: , , , ,. 160
My task worksOKsometimes, butgets bogusresults other times.

xx



Listof Gotchas

Gotcha 77.' 162
The variables in my testbench do not initialize correctly.

Gotcha 78.' , , 164
When I fork offmultiple tests, I get incorrect results, but each test runs OK by
itself.

Gotcha 79.' , 166
When I execute a disable fork statement, sometimes it kills threads that are
outside the scopecontaining the disable fork statement.

Gotcha 80.' , 168
When I try to disable a statement block in one thread, it stops the block in all
threads.

Gotcha 81.' , 171
Mysimulation exitsprematurely, beforeI call Sfinish, and while sometestsare
still running.

Gotcha 82.' 173
Someofmy class variables are notgettingrandomized, even though theywere
taggedas rand variables.

Gotcha 83: , , 175
My class variables do not get random values, even though I called the
randomize function.

Gotcha 84.' 177
I used an assertion to detect randomization failures, and now nothing gets
randomized during reset.

Gotcha 85.' , 179
When I specifyconstraints on morethantworandom variables, I don't get what
I expect.

Gotcha 86: , 181
I amgettingnegative values in my random values, whereI onlywantedpositive
values,

Gotcha 87.' .. , 182
I've definedspecificcoverage bins insidemy covergroup to track coverage of
specificvalues, but thereportonlyshowsthecoverage oftheentirecovergroup.

Gotcha 88: 184
I defined a covergroup, but the group always has 0% coverage in the cover
report.

xxi



Listof Gotchas

Gotcha 89: 186
I haveseveralinstances ofa covergroup, but thecoverage reportlumps them all
together.

Gotcha 90: 187
Sometimes the call to my covergroup constructor doesnot compile.

Gotcha 91: 188
My assertion pass statement executed, even though I thought thepropertywas
not active.

Gotcha 92: "" , , 190
My assertion pass statements are executing, even when the procedural code
does not execute the assertion.

Gotcha 93: " , , .. ,.,., 192
My assertion fail statement executes when the assertion succeeds instead of
fails.

Gotcha 94.' , , " , .. , , 193
I have an assertion propertywith an open-ended delay in the consequent, and
doesn'tfail when it should.

Gotcha 95: ,." , , " .. ,." , , 195
My design outputs do not change at the sametime in different simulators.

Gotcha 96,' , , , 198
My packages compile fine on all simulators, but my design that uses the
packages will onlycompile on somesimulators.

Gotcha 97: , 200
I cannotrepeatmy constrained random testson different tools.

Gotcha 98: , ,., , 202
When I use System Verilog, some simulators will not let me load my memory
models using$readmemb.

Gotcha 99: , , , 204
MySystem Verilog codeonlyworks on one vendor's tools.

Gotcha 100: , , 206
Sometoolsrequire onesyntaxfor arrayliterals. Othertoolsrequirea different
syntax.

Gotcha 101.' , , ,. 208
Some SystemVeriiog tools allowme to declare my inputports as real (floating
point), but othertoolsdo not.

xxii



Foreword
by Steve Golson

Some people collectbaseball cards, old car magazines, or maybe rubber duckies.

I collectVerilog books.

It started back in 1989 with a looseleaf copy of "Gateway VERILOG-XL
Reference Manual Version I.5a" in a three-ring binder. Verilog was a bit simpler
back then-it's hard to believe we actually designed chipsusingonlyone typeof
procedural assignment (nonblocking assigns were not part of the language yet).
Andwe ran our simulations on a VAX, or maybe a fancy Apollo workstation.

SincethenI'vebought prettymuchevery Verilog bookthat camealong. I'vegot a
few synthesis books, and I'll pick up an occasional VHDL reference or maybe a
text on the history of hardware description languages, but mostly it's Verilog.
Dozens and dozens of booksabout Verilog.

There'sa funny thingaboutmostof these books though. AfterI leaf through them
a few times, they sit on the shelf. I admitthat it looks pretty impressive onceyou
have an entire bookcase filled with Verilog books, but the discerning visitor will
notice how fresh and newtheyall are. Unused. Unread. Useless.

I'm often disappointed to find very little information which is useful for the
practicing engineer. What I'm looking for is a book I can use every day, a book
that will helpme get my chipout the door, on timeand working.

StuandDonhavewritten sucha book. I've known these guysfor manyyears, and
they have probably forgotten more Verilog than I've ever known. They have
distilled their collective knowledge into this helpful and extremely useful book.
Readit and you won'tbe disappointed.

If you are an old hand at Verilog try to pick out all the Gotchas that you have
found the hard way. Smile and say to yourself "Oh yeah, I remember getting
caught by that one!"

Those of you who are new to Verilog and SystemVerilog, welcome aboard!
Here's your chance to learn from two of the leading experts in the field. And if
you ever have a chance to take a training class from either of these gentlemen,
don'thesitate to signup. I guarantee you won't regret it.



2 Verilog andSystemVeriiog Gotchas

Ohby the way, my favorite Gotcha is "Gotcha 65: Infinite for loops". Why? Well,
I builta chipwiththatbug in it. Believe me,when a modeling errorcauses you to
have broken silicon, you never forget why it happened. Back then I didn't have
this book to help me, but you do! Keep this bookcloseat hand, refer to it often,
andmayall yourmodels compile andall your loops terminate.

Steve Golson
Trilobyte Systems

http://www.trilobyte.com



Chapter 1
Introduction,

What Is A Gotcha?

This chapter defines what a "gotcha" is, and why programming languages
allowgotchas. For the curious, the chapteralsoprovides a briefhistoryof the

Verilog and SystemVerilog standards. The topics presented in this chapter
include:
• Whatare Verilog and SystemVerilog
• The definition of a gotcha
• A brief description of the Verilog and SystemVerilog standards

What are Verilog and SystemVerilog?

The terms "Verilog" and "SystemVerilog" are sometimes a source of confusion
because the terms are not used consistently in the industry. For the purposes of
this book,"Verilog" and SystemVerilog are used as follows:

Verilog is a Hardware Description Language (HDL). It is a specialized
programming language used to model digital hardware designs and, to a limited
extent, to write test programs to exercise thesemodels.

SystemVerilog is a substantial set of extensions to the Verilog HDL. A primary
goal of these extensions is to enablemodeling and verifying larger designs with
morecompact code. By itself, SystemVerilog is not a complete language; it is just
a set of additions to the base Verilog language.



4 Verilog and SystemVeriiog Gotchas

What is a Gotcha?

A programming "gotcha" is a language feature, which, if misused, causes
unexpected-and, in hardware design, potentially disastrous-behavior. The
classic example in the C language is having an assignment within a conditional
expression, suchas:

if (day=15) /* GOTCHA! assigns value of 15 to day, then */
do_mid_month_payroll; /* if day is non-zero, do a payroll */

Most likely, what the programmer intended to code is if (a==b) instead of if
(a=b). The results are very different! This classic C programming Gotcha is not
a syntax error; the code is perfectly legal. However, the code probably does not
produce the intended results. If the coding erroris not detected before a product is
shipped, a simple bug like this couldleadto serious ramifications in a product.

Just like any programming language, Verilog, and the SystemVerilog extensions
to Verilog, have gotchas. Thereare constructs in Verilog and SystemVerilog that
can be used in ways that are syntactically correct, but yield unexpected or
undesirable results. Some of theprimary reasons Verilog and SystemVerilog have
gotchas are:
• Inheritance of C and C++ gotchas

Verilog and SystemVerilog leverage the general syntax and semantics of the
C and C++ languages. Verilog and SystemVerilog inherit the strengths of
these powerful programming languages, but they also inherit many of the
gotchas of C and C++. (Which raises the question, can the common C cod­
ing error such as if (day= 15) be made in Verilog/SystemVerilog? The
answercan be found in Gotcha 44 on page99.)

• Loosely typedoperations
Verilog and SystemVerilog are loosely typed languages. As such, operations
can be performed on any data type, and underlying language rules take care
of how operations should be performed. If a design or verification engineer
does not understand these underlying language rules, then unexpected
results can occur.

• Allowance to model goodandbad designs
An underlying philosophy of Verilog and SystemVerilog is that engineers
should be allowed to model and prove both what works correctly in hard­
ware, and what will not work in hardware. In order to legally model hard­
ware that does not work, the language must also permit unintentional
modeling errorswhenthe intent is to model designs thatworkcorrectly.



Chapter 1: Introduction, What Is A Gotcha? 5

The Verilog and SystemVerilog standards

Veri/og is an international standard Hardware Description Language. The official
standard is IEEE Std 1364-2005 Verilog Language ReferenceManual (LRM),
commonly referred to as ((Veri/og-2005". The Verilog standard defines a rich set
of programming and modeling constructs specific to representing the behavior of
digital logic. The Verilog Hardware Description Language was first created in
1984. Verilog was designed to meet the needs of engineering in the mid 1980s,
when a typical design was under 50,000 gates and ICs were based on 3 micron
technology. As digital design size and technologies changed, Verilog evolved to
meet new design requirements. Verilog was first standardized by the IEEE in
1995 (IEEE Std 1364-1995). In 2001, The IEEE released the Verilog-2001
standard (IEEE Std 1364-2001) which enhanced Verilog in several ways, suchas
synthesizable signed arithmetic on any vector size and re-entrant tasks and
functions. TheIEEE updated theVerilog standard in 2005, but no major modeling
enhancements were added in this version. Instead, all enhancements to Verilog
were documented in a separate standard, SystemVerilog.

System Verilog is a standard set of extensions to the Verilog-2005 Standard. These
extensions are documented in a separate standard, IEEE Std 1800-2005
SystemVerilog Language Reference Manual, commonly referred to as
"SystemVeri/og-2005". The SystemVerilog extensions enable writing
synthesizable models that are continuously increasing in size and complexity, as
well as verifying these multi-million gate designs. SystemVerilog addsto Verilog
features from the SUPERLOG, VERA C, C++, and VHDL languages, along with
OVA and PSL assertions. SystemVerilog was first developed by Accellera, a
consortium of companies that do electronic design and companies that provide
Electronic Design Automation (EDA) tools. Accellera released a preliminary
version of the extensions to Verilog in 2002, called SystemVerilog 3.0 (3.0 to
showthat SystemVerilog was the nextgeneration of Verilog, where Verilog-1995
was the first generation and Verilog 2001 was the second generation). In 2003,
Accellera released SystemVerilog 3.1 and in 2004 SystemVerilog 3.la. This latter
Accellera standard was thensubmitted to the IEEE for full standardization.

The original intent was for the IEEE to fold the Accellera SystemVerilog
extensions into the Verilog standard. At the insistence of EDA companies,
however, the IEEE made the decision to temporarily keep the SystemVerilog
extensions in a separate document to make it easier for EDA companies to
implement theextensive set of newfeatures in theirVerilog tools.



6 Verilog and SystemVeriiog Gotchas

The official standards for Verilog and SystemVerilog are:
• HIEEE 1364-2005 standardfor the Verilog Hardware Description Language",

IEEE, Pascataway, NewJersey, 2002. ISBN 978-1-4020-7089-1.
• HIEEE 1800-2005 standardfor the System Verilog Hardware Description and

Verification Language", IEEE, Pascataway, New Jersey, 2001. ISBN 0- 7381­
4811-3.

For moredetails on the Verilog and SystemVerilog languages, refer to thebooks:
• "The Verilog Hardware Description Language, 5th edition", by Donald

Thomas and PhilipMoorby. Published by Springer, Boston, MA, 2002, ISBN
978-1-4020-7089-1.

• "Verilog-2001: A Guide to the New Features in the Verilog Hardware
Description Language ", by Stuart Sutherland. Published by Springer, Boston,
MA, 2002, ISBN 978-0-7923-7568-5.

• "SystemVerilog for Design: A Guide to Using System Veri/og for Hardware
Design and Modeling, Second Edition", by Stuart Sutherland, Simon
Davidmann and PeterFlake. Published by Springer, Boston, MA, 2006, ISBN
978-0-387-33399-1.

• "System Verilog for Verification: A Guide to Learning the Testbench Language
Features", by Chris Spear. Published by Springer, Boston, MA, 2006, ISBN
978-0-387-27036-4.

Thereare manymoreexcellent books on usingVerilog and SystemVerilog.

Note that at the time this book was written, the IEEE had begun the process of
merging the base Verilog language into the SystemVerilog Language Reference
Manual, to create a single language and standard. In time, "Verilog" will
disappear, and "SystemVerilog" will be a single, unified "Hardware Design and
Verification Language".



Chapter 2
Declaration andLiteralNumber

Gotchas

Gotcha 1: Case sensitivity

Gotcha: The names in mycodelookcorrect andworked in my VHDL models,
but Verilog/System Verilog getserrors about "undeclared identifiers ",

Synopsis: Verilog and SystemVerilog are case-sensitive languages, whereas
VHDL is a case-insensitive language.

An identifier in Verilog and SystemVerilog is the user-specified name of some
object, such as the name of a module, wire, variable, or function. Verilog and
SystemVerilog are case-sensitive languages, meaning that lowercase letters and
uppercase letters are perceived as different in identifiers and in keywords.
Keywords are always in all lowercase letters. User-created identifiers can use a
mix of lowercase and uppercase letters, as well as numbers and the special
characters _' $, and \ (the latter is an escape character).

This case sensitivity is often a gotcha to engineers learning Verilog/
SystemVerilog, especially those migrating from a case insensitive language such
as VHDL. Even experienced engineers occasionally get caught making a case
sensitivity error. Generally, this case sensitivity gotcha occurs when what is
intended to be the same identifier is sometimes spelled using lowercase
characters, and at other times using uppercase characters.

Note: the code examples in this chapter are contrived in order to illustrate each gotcha using small
examples. In real designand verification code, thesegotchasmightnot be as obviousor easy to debug.



8 Verilog and SystemVeriiog Gotchas

The following example has threecasesensitivity gotchas.
module FSM (... );

enum logic [1:0] {WAIT, LOAD, READY} State, nState;

always_comb begin
case (state) II GOTCHA!

WAIT: nState = LOAD; II GOTCHA!
LOAD: nState = READY;
READY: nState = wait; II GOTCHA!

endcase
end

endmodule: FSM

One gotcha in the preceding example is that the enumerated variable State is
declared using a mix of uppercase and lowercase characters. Later in the code­
possibly hundreds of lines after the declaration-a signal called state is
referenced. These identifiers read the same in English, but, to a Verilog or
SystemVerilog tool, theyare verydifferent names. Gotcha!

A second gotcha is that the enumerated label LOAD is in all uppercase letters. But
later in the codean identifier called LOAD is referenced. Visually, these identifiers
may appear to be the same, but to a Verilog/SystemVerilog tool they are very
different names. Thedifference is thattheenumerated labelcontains an uppercase
letter"0" (pronounced "oh") in the name, whereas the reference in the codebody
contains the number "a" (or "zero") in the name. Gotcha, again!

The third gotcha in the example above is the enumerated label WAIT. While
syntactically correct, this is a poorchoice foran identifier namebecause thereis a
Verilog/SystemVerilog keyword wai t. Laterin themodel, the nState variable is
assigned the valueof wait. This time, a Verilog/SystemVerilog toolwon't report
an error about an undeclared identifier. It will issue an error about a procedural
wai t statement appearing where an expression was expected. Identifier names
with capital letters that are the same name as a keyword in all lowercase letters
can make code harder to read, and can lead to coding errors that are difficult to
see, and can causeobscure syntax errormessages. Gotcha, a third time!

In the example above, the misspelled names will all result in compilation errors,
whichmaybe frustrating, but at leastdo not causea gotcha that runsbut doesnot
behave as intended. Case sensitivity errors can also result in gotchas that will
compile without an error, and will cause functional problems in the design.
Gotcha 2 on page 10shows an example of this.



Chapter 2: Declaration and Literal Number Gotchas 9

How to avoidthisGotcha

The way to avoid this case-sensitivity gotcha is to adopt good naming
conventions within a company, and then strictly enforce these conventions. The
naming conventions used in thisbook are:
• Variable andnetnames are in lowercase.

• User-defined type names endwith _t.
• Enumerated variable names endwith e.
• Active-low signal names endwith _no

• Constant names andenumerated labels are in all uppercase (e.g. LOAD).

• Class definition names begin with a capital letter, followed by all lowercase
letters (e.g. class Packet;).

• Names arechosen thatwould notcontlict with a keyword if the language were
case insensitive (e.g. HOLD instead of WAr T).

A corrected version of theprevious example is:
module fsm ( ... );

enum logic [1:0] {HOLD, LOAD, READY} state_e, nstate_e;

always_comb begin
case (state_e) II OK, names match declarations

HOLD: nstate e = LOAD; II OK, names match declarations
LOAD: nstate e = READY;
READY: nstate e = HOLD; II OK, names match declarations

endcase
end

endmodule: fsm



10 Verilog and SystemVeriiog Gotchas

Gotcha 2: Implicit net declarations

Gotcha: A typo in my design connections wasnotcaught by thecompiler, and
onlyshowedupas afunctional problem insimulation.

Synopsis.' Mis-typed identifiers may inferan implicit net instead ofa syntax
error.

What does a Verilog/SystemVerilog tool do when it encounters an undeclared
identifier? The answer to this question depends on the context in which the
undeclared identifier is used.
• If an undeclared identifier is usedon the right- or left-hand sideof a procedural

assignment statement, then a compilation error occurs. For example (also see
Gotcha 1on page 7):

logic [7: 0] faa;
initial faa = bar; II ERROR: bar not declared

• If an undeclared identifier is used on the right-hand side of a continuous
assignment statement, thena compilation erroroccurs.

logic [7:0] faa;
assign foo = bar; II ERROR: bar not declared

• If an undeclared identifier is used on the left-hand side of a continuous
assignment, then an implicit net declaration is inferred, and no error or
warning is reported.

logi c [7: 0] faa;
assign bar = faa; II GOTCHA: bar not declared, but no error

• If an undeclared identifier is used as a connection to an instance of a module,
interface, program, or primitive, then an implicit net is inferred, and no error
or warning is reported.

The last rule above can cause hard-to-find functional errors in a design, as shown
in the following example of a netlist connecting two I-bit adders together.
module adder (input logic a, b, ci,

output logic sum, co);

endmodule

module top;
wire a, b, ci, 51, 52, c1;

adder il (.a(a), .b(b), .ci(cl), .sum(sl), .co(c1) ); II GOTCHA!

adde r i 2 (. a (a), . b (b), . c i (c) , . sum (s 2), . co (co) ); / / GOTCHA!
endmodule



Chapter 2: Declaration andLiteral Number Gotchas 11

Onegotcha in this example is the declaration of c 1 ("see-one"), but the reference
to cl ("see-ell") in the i 1 adder instance. Another gotcha is an undeclared
identifier, c, in the i 2 adder instance. These typos are not syntax errors. Instead,
they infer implicit nets in the design, causing functional errors that must be
detected and debugged. Gotcha!

Why does Verilog/SystemVerilog allow this gotcha? Because the ability to have
implicit data types automatically inferred canbe useful, whenusedcorrectly. One
of the benefits of implicit data types is that in a large, multi-million gate design
that has thousands of interconnecting wires, it is not necessary to explicitly
declare every wire.

How to avoid this Gotcha using Verilog

Some language-aware editors, such as Emacs with a Verilog model, can auto­
complete theconnections ina Verilog netlist. Thisis a simple andpractical wayto
avoidthe gotcha of a typographical error.

Most engineers, including the authors, find that implicit nets is a strength of the
Verilog language, despite the potential gotcha of a typographical error in a netlist
showing up as a functional bug instead of a compilation error. The Verilog
language does provide a mechanism to disable implicit data types. The way it is
done, however, is controversial,. Some engineers feel it can introduce more
gotchas then it might help avoid. This Verilog-based control is not discussed in
thisbook.

How to avoid this Gotcha using System Verilog

SystemVerilog provides two convenient short cuts, dot-name and dot-star, for
connecting nets to instances of modules, programs, and interfaces. These
shortcuts remove the repetition in named port connections.
• Thedot-name shortcut explicitly names theport to which a connection is being

made, but infers thata net of the same name is connected.
• The dot-star shortcut automatically infers that ports and signals with the same

name are connected.

The following example illustrates all three connections styles: fully explicit, dot­
name partially inferred, anddot-star fully inferred connections.

1. Onepopular Verilog mode for Emacs is available at www.verilog.com.



12 Verilog and SystemVeriiog Gotchas

module adder (input logic a, b, ci,
output logic sum, co);

endmodule

module top;
wire a, b, ci, sl, s2, cl;

adder i1 (.a, .b, .ci, .sum(s1), .co(c1»; II .name connections

adder i2 (.sum(s2), .ciCcI), .* )i II .* connections
endmodule

By reducing the number of times a signal name mustbe typed, the possibility of
typographical errors is also reduced. The dot-name and dot-star shortcuts also
require that all nets be explicitly declared. A typo in the netlist or in the net
declarations will not infer an implicit wire when using the shortcuts. Such typos
willbe compilation errors instead of functional problems in simulation.

Programmers who use the Emacs editor can take advantage of a nice feature in
some Verilog/SystemVerilog modes for Emacs which will automatically expand
dot-star inferred port connections to its inferred explicit connections. Thisfeature
requires that the dot-star be the last item in the port connection list, as shown in
theexample above.



Chapter2: Declaration and Literal NumberGotchas 13

Gotcba 3: Default of I-bit internal nets

Gotcha: In my netlist, only bit zero ofmy vector ports get connected.

Synopsis: Undeclared internal connections within a netlist infer l-bit wires,
even if theport to which the net is connected is a vector.

Verilog andSystemVerilog have a convenient shortcut when modeling netlists, in
that it is not necessary to declare all of the interconnecting nets. Undeclared
identifiers used as port connections default to a wire net type (see Gotcha 2 on
page 10). In a netlist with hundreds or thousands of connections, implicit wires
cansignificantly simplify theVerilog/SystemVerilog source code.

The vector size of implicit nets is determined from local context. If the
undeclared signal is also a port of the module containing the signal, then the
implicit net will be the same size as the containing module's port. If the
undeclared signal is onlyusedinternally in thecontaining module, thena I-bitnet
is inferred. Verilog and SystemVerilog do not look at the port sizes of what the
signal is connected to in order to determine the implicit net type size.

The following top-level netlist connects signals to a 4-to-1 multiplexer. The data
inputs and outputs of the mux are 8 bits wide. The select input is 2 bits wide.
No data types are declared in the top-level netlist. Therefore, implicit wires will
be inferred for all connections.

module top_level
(output [7:0] out, II a-bit port, no data type declared
input [7:0] a, b, c, d II a-bit ports, no data type declared

) ;

mux4 ml (.y(out), II out infers an a-bit wire type
.a(a), II a, b, c, d infer a-bit wires
.b(b) ,
.C (c),
.d(d) ,
.sel(select»; II GOTCHA! select infers l-bit wire

endmodule

module mux4
(input logic [1:0] sel, II 2-bit input port
input logic [7:0] a, b, c, d , II a-bit input ports
output logic [7:0] y II a-bit output port

) ;

endmodule



14 Verilog and SystemVeriiog Gotchas

In the example above, the top-level netlist connects a signal called select to the
sel port of mux4. Within mux4, the sel port is 2 bits wide. When inferring
undeclared nets in the top_level module, however, Verilog and SystemVerilog
only look within the local context of top_level. There is nothing within
top_level from which to inferthe sizeof select. Therefore, select defaults
to a l-bit wire. Gotcha!

Most Verilog/SystemVerilog tools will generate compilation warning messages
for this gotcha, reporting size mismatches in port connections. Engineers should
not ignore these warnings! Almost without exception, warnings about size
mismatches in port connections indicate unintentional errors in a netlist.

How to avoidthis Gotcha

Toavoid this gotcha, all internal nets and variables that are morethan I-bit wide
mustbe explicitly declared. An internal signal is one that is onlyusedwithin the
module,program or interface, and is not a port of that module, program or
interface through a port.

The SystemVerilog dot-name and dot-star port connection shortcuts can help in
avoiding thisgotcha. These shortcuts willnot inferundeclared nets. Further, these
shortcuts willnot inferconnections thatdonotmatch in size. Gotcha 2 onpage 10
explains the dot-name and dot-star portconnection shortcuts.

The following example, which usesdot-star implicit port connections, will cause
a compilation error instead of a functional gotcha.

module top_level
(output logic [7:0] out, II 8-bit port
input logic [7:0J a, b, c, d II 8-bit ports

) ;

mux4 ml (.y(out), *); II ERROR: no net declared for sel port

endmodule

module mux4
(input logic [1: 0] sel, II 2-bit input port
input logic [7: 0] a, b, c, d, II 8-bit input ports
output logic [7: 0] y II 8-bit output port

) ;



Chapter 2: Declaration and Literal Number Gotchas 15

Gotcha 4: Single file versus multi-file compilation of $unit declarations

Gotcha: My models compile OK, and the models from another group compile
OK; but whencompiledtogether, I get errors aboutmultiple declarations.

Synopsis: Separate file compilation has separate Sunit declaration name
spaces. Multi-file compilation has a singleSunitcompilation namespace.

$un i t is a declaration space that is visible to all design units that are compiled
together. The purpose of $uni t is to provide a place where design and
verification engineers can place shared definitions and declarations. Any user­
defined type definition, task defintion, function definition, parameter declaration
or variable declaration that is not placed inside a module, interface, test program,
or package is automatically placed in $uni t. For all practical purposes, $uni t
canbe considered to be a predefined package namethat is automatically wildcard
imported into all modeling blocks. All declarations in $un i t are visible without
having to specifically reference $uni t. Declarations in $uni t can also be
explicitly referenced using the package scope resolution operator. This can be
necessary if an identifier exists in multiple packages. An example of an explicit
reference to $uni tis:
II following declaration is in $unit
typedef enum logic [1:0] {RESET, HOLD, LOAD, READY} states_t;

module chip ( ... );

$unit: :states_t state_e, nstate_e; II OK: definition in $unit

A gotcha with $uni t is that these shared definitions and declarations can be
scattered throughout multiple source code files, and can be at the beginning or
end of a file. At best, this is an unstructured, spaghetti-code modeling style, that
can lead to design and verification code that is difficult to debug, difficult to
maintain, and nearly impossible to reuse. Worse, $uni t definitions and
declarations scattered across multiple files can resultin nameresolution conflicts.
Say, for example, that a design has a $uni t definition of an enumerated type
containing the label RESET. By itself, the design may compile just fine. But then,
what happens if an IP model is added to the design that also contains a $ un i t
definition of an enumerated type containing a label calledRESET? The IP model
also compiles just fine by itself, but when compiled along with the design's
$un i t declarations, thereis a name conflict. There are nowtwo definitions in the
samenamespacetryingto reserve the labelRESET. Gotcha!



16 Verllog and SystemVeriiog Gotchas

How to avoidthis Gotcha

Use packages for shared declarations, instead of $uni t. Packages serve as
containers for shared definitions and declarations, preventing inadvertent
spaghetti code. Packages also have their ownname space, which will not collide
with definitions in otherpackages. There can still be name collision problems if
two packages are wildcard imported into the same name space. This can be
prevented by using explicit package imports and/or explicit package references,
instead of wildcard imports (see Gotcha 9 on page 27 for examples of wildcard
andexplicit imports).



Chapter 2: Declaration and Literal Number Gotchas 17

Gotcha 5: Local variable declarations

Gotcha: I get compilation errors on my local variable declarations, but the
declaration syntax is correct.

Synopsis: Verilog and SystemVerilog allow local variables to be declared
within a statement group, but require all declarations to come before any
procedural code.

Verilog and SystemVerilog allow local variables to be declared within a
begin...end or fork ... join statement group. However, just as in C, variables
mustbe declared beforeany programming statements. This is different from the
context of a module, interface or program block, where variables canbe declared
anywhere, so long as they are declared before they are referenced. This subtle
difference can be a gotcha.
package Transaction;

endpackage

package Extented_trans extends Transaction;

endpackage

initial begin
Transaction tr = new; II declaration with constructor
bit status; II declaration
status = tr.randomize; II procedural statement
Extended_trans etr = new; II GOTCHA! decla~ation afte~ statement

end

How to avoid this Gotcha

Two modeling stylescan be used to fix this localvariable gotcha. One style is to
declare all variables at the top of the block, before any procedural statements. For
example:

initial begin II move all declarations to top of the block
Transaction tr = new; II declaration with constructor
Extended_trans etr = new; II OK, declaration before statement
bit status; II declaration
status = tr.randomize; II procedural statement

end

The second style is to create a new begin...end block within the procedure to
localize the scopeof a variable, as follows:



18 Verilog and SystemVeriiog Gotchas

initial begin
Transaction tr = new; II declaration with constructor
bit status; II declaration
status = tr.randomize; II procedural statement
begin

Extended_trans etr = new; II OK, local declaration

end

end



Chapter 2: Declaration and Literal Number Gotchas 19

Gotcha 6: Escaped names in hierarchical paths

Gotcha: I get weird compiler errors when I try to reference a design signal
withan escapednamefrom my testbench.

Synopsis: Escapedidentifiers in a hierarchical path require embedded spaces
in thepath.

An identifier in Verilog and SystemVerilog is the name of some object, such as
the name of a module, the nameof a wire, the nameof a variable, or the nameof
a function. The legal characters in an identifier are alphabetic characters,
numbers, underscore, or dollarsign. Allothercharacters, suchas +, -, (, ), [, and
] , are illegal in an identifier name.

Verilog and SystemVerilog allow these illegal characters to be used in a nameby
escaping the identifier. A name is escaped by preceding the name with a back
slash ( \ ) and terminating the name with a whitespace character. A whitespace
character is a space, tab, carriage return, line feed, form feed, or an end-of-file.
Some examples of escaped identifiers are:

module \d-flop (output logic q, \q- ,
input logic \d[O] ,ck, \rst- )i

endmodule

Observe in the above example that a whitespace character must be used before
the commas that follow \q- and \d [0] . The whitespace terminates the escaped
name, so that the comma is a separator between port names. If there were no
whitespace before the comma, thenthe comma wouldbecome partof the escaped
name. A whitespace is also required between the last escaped name, \rst-, and
the closing parenthesis.

Potential gotcha.· An escaped name with square brackets, such as \ d [ 0 ] , can be
confusing. It is a namefor I-bit wire. \d [0] is not a bit selectof vectorcalled \d.
Thisdifference is illustrated with the following declarations:

logic [7:0J \a i II 8-bit vector called \a
logic \b[O] II l-bit signal called \a[O]

buf bl (\b[O] , \a[O])i II GOTCHA: infers a net called \a[O]
buf b2 (\b[O] , \a [O])i II CORRECT: bit select of vector \a

Observe thata whitespace wasrequired after \ a andbefore the [0] in orderto do
a bit selectof a vector that has an escaped name. The use of \a [0] in buffer bI
will notbe a syntax error. An implicit net called \a [0] willbe declared. Gotcha!
(see Gotcha 2 on page 10 for a description of implicit net gotchas).



20 Verilog and SystemVeriiog Gotchas

Another gotcha can occur when an escaped identifier is used as part of a
hierarchical path. For example:

module test (output [7:0] q, input [7:0] d, input ck, rst_n);

\ d- flop \ d- 0 (. q (q [0] ) , . \ q~ (), . \ d [0] (d [0] ) , / / GOTCHA!
. ck (ck), . \rst- (rst_n) ) ; / / GOTCHA!

initial begin
$display("d = %b", test.\d-O.\d[O] ); / / GOTCHA!

end
endmodule

Thisexample will get compilation errors, but the errors willprobably not indicate
the real problem. An escaped name must be terminated by a whitespace. In the
code above, \d-flop and \d-O are correctly followed by a whitespace. The
escaped name \q- is not followed by a whitespace, making all text following it
part of the escaped name. A Verilog/SystemVerilog tool will see the name,
"\q- () , ", which is not what was intended. Since the parenthesis and comma
were also escaped, the tool will report a compilation error due to those missing
tokens.

The next line also has a gotcha. The escaped name \rst- is not terminated by a
whitespace. The first whitespace comes after the semicolon at the end of the
module instance. Therefore, the name a Verilog/SystemVerilog tool will see is
"\ r s t - (r s t _ n) ) i", The tool will not find a closing parenthesis and semicolon
to end the module instance, and will probably report an obscure error message
aboutthe initial keyword two linesfurther down in the code.

The $display statement will also get a compilation error that might not be
obvious. The display statement uses a hierarchical path to print the value of
\ d [ 0] inside the flip-flop model. However, the instance name is an escaped
name, whichmust be terminated by a whitespace. What the tool sees is a single
nameof"\d-O. \d [0]".

How to avoid this Gotcha

Escaped names mustbe terminated by a whitespace, evenwhenpartof an explicit
port nameor a hierarchical path. Thecorrect codefor the example above is:

module test (output [7:0] q, input [7:0] d, input ck, rst_n);

\d-flop \d-O (. q (q [0] ), . \q~ (), . \d[O] (d[O]), I I CORRECT
• ck (ck) , • \rst- (rst_n»); I I CORRECT

initial begin
$display("d = %b", test.\d-O .\d[O]); II CORRECT

end
endmodule



Chapter 2: Declaration andLiteral Number Gotchas 21

The whitespace in the middle of a hierarchical path, as in the $display
statement above, might look like it breaks the hierarchical path into two
identifiers, but the terminating whitespace is ignored, which, in effect,
concatenates thetwonames intoonename.

The authors recommend avoiding purposely using escaped names in a design,
especially an escaped name with square brackets in thename, as in thecontrived
example above. Unfortunately, life is not that simple. Notall identifiers areuser­
defined. Some software tools, especially synthesis tools, often create tool­
generated identifier names in the Verilog or SystemVerilog code. And, as ugly as
these tool-generated identifiers looks to users, these tools often put square
brackets in escaped identifiers.



22 Verilog and SystemVeriiog Gotchas

Gotcha 7: Hierarchical references to automatic variables

Gotcha: I get compilation errors when my testbench tries to print out some
signals in my design, butothersignals can beprintedwithout a problem.

Synopsis: Automatic variables cannot be referenced usinghierarchical paths.
They arealso not dumpedto VCD files.

Verilog has automatic tasks and functions, which dynamically allocate storage
each time they are called, and automatically free that storage when they exit.
SystemVerilog adds manymore types of automatic storage, including classes for
object-oriented programming, dynamically sized arrays, queues, and strings.
Thesedynamically allocated types are intended for-and are very important in­
modeling test programs using modem verification methodologies.

The following two examples are nearly identical. Both examples use a task to
calculate a result. The task contains an intermediate variable, s 1. The task is
calledtwice, and the intermediate s 1 variable can have different values for each
call.

The only difference between the two models is that math_static uses static
storage for the local variable, whereas math_au to uses automatic storage.
Automatic storage would avoid possible conflicts between the two task calls,
because eachcall to the task is allocated a unique copyof the s 1 variable.
module math_static ( ... ); II use static storage

task math ( 000 );

logic [15:0] s1; II local variable

endtask

always_comb begin
rnat h (a I , b I , c I, 0 I) ;
rnath(a2, b2, c2, 02);

end
endrnodule

module automatic math_auto ( ... ); II use automatic storage
task math ( 00' );

logic [15:0] s1; II local variable

endtask

always_comb begin
math (a l , bl, cl, dl, ala, alb);
math(a2, b2, c2, d2, o2a, 02b);

end
endmodule



Chapter 2: Declaration and Literal Number Gotchas 23

The following testbench is used to verify the two modules. As part of the
verification, coverage, and possible debug of the design, the intent in this
testbench is to use a hierarchical path to look at the values of the s 1 variable in
eachmodule'smath task.

module top;

test tl (.*); II connect testbench to design
math static ml (.*);
math auto m2 (.*);

endmodule

program automatic test;

initial begin
II apply stimulus

$display (" math_static sl %h", top.ml.math.sl II OK
$display (n math auto 51 %h", top.m2.math.sl II GOTCHA!

end
endprogram

Everything in the testbench excerpt looks correct, and accessing internal data in
the design, in order to do verification and debug, is certainly reasonable.
Hierarchical references allow the verification code to evaluate, and possibly
stimulate, logic deep down in the design, without having to pull those internal
signals up to the testbench through multiple layers of extra, verification only,
module ports.

Unfortunately, the testbench above will not compile, due to the hierarchical
references to s1 in module instance m2. Gotcha!

The gotcha happens because it is illegal to hierarchically reference automatic
variables. The reason is that hierarchical paths are static in nature, whereas
automatic variables come and go during simulation. This limitation places a
burden on the verification engineer. Before usinga hierarchical path to reference
a variable, the verification engineer must first examine the source code, to
determine whether the variable is static or automatic. Gotcha!

A closely related gotcha is that the Verilog and SystemVerilog value changes on
automatic variables are not dumped to a Value Change Dump (VCD) file. VCD
files are used as an input to waveform displays and other design analysis tools.
However, only static nets and variables are dumped to VCD files. When
simulation results are analyzed, important information mightbe missing. Gotcha,
again!



24 Verilog and SystemVeriiog Gotchas

Howto avoidthisGotcha

This gotcha cannot be completely avoided, but it can be minimized. A coding
guideline is to only use automatic storage in the testbench, and for tasks and
functions declared in Suni t, packages and interfaces. In this way, test programs
will be able to hierarchically access most design data. It is also helpful to use
naming conventions thatmake automatic variables obvious in the source code.

There is no workaround for this VeD limitation. Proprietary waveform tools that
do not use VCD files, however, might not havethis limitation.

Coding guidelines to helpavoidstatic versus automatic storage gotchas

Programs should be declared as program automatic. This makes the default
storage automatic, which is more like the C and C++ programming languages.
Note, however, that this only changes the default for variables declared within
tasks, functions, and procedural blocks. Variables declared at the program block
level will still be static by default. The following parallel examples illustrate the
effects of declaring a program as automatic.

program testi program automatic testi
int ai Ila is static int ai Ila is static

task t (int b)i lIb is static task t (int b); lIb is automatic
int Ci I/c i8 static int c; //c is automatic

endtask endtask

initial begin initial begin
logic di //d is static logic di lid is automatic

end end
endprogram endprogram

Packages should be declared as package automatic. Task and function
definitions in a package are oftenshared between several programs, modules and
interfaces, and therefore should be automatic to avoid problems of sharing
storage between multiple callers. Gotcha 43 on page 96 describes RTL design
problems that can occurwhen static storage in a package is shared with multiple
callers.

Modules should not be declared as automatic. Tasks, functions andlocal variables
in a module that are automatic will not be accessible hierarchically, which limits
the ability to debug design problems. If automatic storage is needed in a module,
such as for a recursively called function, the local variable, task or function
should be explicitly declared as automatic. This both documents the exception,
and permits debug access to therestof themodule.



Chapter 2: Declaration and Literal Number Gotchas 25

Gotcha 8: Hierarchical references to variables in unnamed blocks

Gotcha.· With Verilog, my testbench could print out local variables in a
begin...end block, but withSystemVerilog I get compilation errors.

Synopsis.' Variables declared in an unnamed scope have no hierarchical
paths.

Verilog allows local variables to be declared in named begin...end and
fork... join blocks. These variables can be referenced hierarchically, using the
blocknameas part of the hierarchical path.

The following example defines a begin...end block called loop, with a local
variable called temp. A testbench module hierarchically references temp to print
out its value.

module ehip_vlog_style ( ... );

always @(posedge elk)
for (i=O; i<=15; i=i+l) begin: loop II named block

integer temp; II local variable

end
endmodule

module test;

ehip_vlog_style dut ( ... );

initial $display ("temp = %Od", test.dut.loop.temp); II OK
endmodule

An second advantage of local variables is that they can prevent the inadvertent
gotcha of having multiple initial or always procedural blocks write to the
samevariable (see Gotcha66 on page 145).

SystemVerilog simplifies Verilog by allowing local variables to be declared in
unnamed begin...end and fork... join blocks. This simplification comes with a
potential gotcha!

module ehip_sv_style ( ... );

always_ff @(posedge elk)
for (int i=O; i<=15; i++) begin II unnamed block

integer temp; II local variable

end
endmodule



26 Verilog and SystemVeriiog Gotchas

program automatic test;

chip_sv_style dut ( ... );

initial $display ("temp = %Od", test.dut.temp); II GOTCHA!
endmodule

Local variables in unnamed blocks cannot be accessed from the testbench for
verification or debugging. Binding assertions to a design to verify functionality or
coverage involving the local variable is alsonot allowed. Nor will local variables
in unnamed blocks showup in Value Changed Dump (VCD) files usedby many
waveform displays. Gotcha!

The gotcha is that variables declared in an unnamed block cannot be referenced
hierarchically, because there is no named scope to reference in the hierarchical
path. This is the same limitation that exists for automatic variables, as discussed
in Gotcha 7 onpage22.

A similar gotcha exists withfor loopcontrol variables defined as partof the for
loop, which is shown in Gotcha 67 on page 147.

How to avoid this Gotcha

If a local variable needs to be referenced hierarchically, or dumped to a waveform
file, declare local variables in named begin...end or fork ... join blocks as
shown in thefirstexample in thisgotcha description. Use unnamed blocks if there
is a reason to protect the local variable from codeoutside of the block, including
the testbench andveD waveform files.



Chapter 2: Declaration and Literal Number Gotchas 27

Gotcha 9: Hierarchical references to imported package items

Gotcha: Mydesign canuse importedpackage itemsjust fine, butmy testbench
cannotaccess the items for verification.

Synopsis: Imported identifiers must be referenced using the scope resolution
operators insteadofhierarchically.

SystemVerilog packages allow type definitions and other information to be
declared in a sharedspace. Package definitions can be imported intootherdesign
blocksto giveaccess to thoseshared definitions. Verification of imported items is
handled differently than verification of data declared locally within a design
block. The following example hasa gotcha in the testbench program.

package chip_types;
typedef enum logic [1:0] {RESET, HOLD, LOAD, READY} states_ti

endpackage: chip_types

module chip ( ... );
import chip_types::*; II wildcard import definitions in package

endmodule: chip

module top;
chip chip ( ); II instance of design that uses the package
test test ( ); II instance of test program

endmodule: top

program automatic test ( ... );

initial begin
$display ("RESET is %b", top.chip.RESET); II GOTCHA! illegal

endprogram: test

In the example above, the test program uses a hierarchical path to access the
value of RESET in the scope in which RESET is imported and used. Thisresults in
an error. Hierarchical paths are used to access signals where they are declared.
The enumerated label RESET in the example above is not declared in module
chip. It is only imported into chip. When package items are imported into a
module, interface, or test program, these itemsare not locally defined within that
scope. Theseimported itemscannot be referenced hierarchically.

Howto avoidthis Gotcha

External references to package items are doneusing the package name followed
by the scoperesolution operator ( : : ) instead of hierarchical paths. For example:

$display ("RESET is %b", chip_types:: RESET) ; I I OK



28 Verilog and SystemVeriiog Gotchas

Gotcha 10: Importing enumerated types from packages

Gotcha: I imported an enumerated typefrom a package, but I cannot access
the labels definedby the enumerated type.

Synopsis: Importing an enumerated type definition does not import its
enumerated labels.

Enumerated type definitions definedin a packagecan be explicitly imported into
a designor verification block.For example:
package chip_types;

typedef enum logic [1:0] {RESET, HOLD, LOAD, READY} states_t;
endpackage

module chip ( ... );
import chip_types::states_t; II explicit import of states t type
states_t state_e, nstate_e;

always_ff @(posedge clock, negedge reset_n)
if (!reset_n) state_e <= RESET; II GOTCHA: RESET not imported
else state_e <= nstate_e;

endmodule

The package contains a user-defined enumerated type called s tate s_ t, which
has the value labels RESET, HOLD, LOAD and READY. The chip module imports
states_t type from the package. When this example is read in by a software
tool, a compilation error will result, statingthat RESET has not been defined. The
reason is that the importof states_t only imports the name s t a t e s jt.. It does
not import the labels that s tate s_ t uses. Gotcha!

How to avoid this Gotcha

One way to avoid this gotcha is to explicitly importeach enumerated label along
with the enumerated type definition.
~port chip_types::states_t; II explicit import of states t type
import chip_types::RESET; II and its labels
~port chip_types:: HOLD;
import chip_types::LOAD;
import chip_types:: READY ;

A second way to avoid this gotchawith a wildcardimportof the package, which
will make both the enumerated type definition and its enumerated labelsvisible.

import chip_types::*; II wildcard import of package declarations

Wildcard imports have a gotcha if multiple packages are used in a design block,
as discussedin Gotcha lIon page 29.



Chapter 2: Declaration and Literal Number Gotchas 29

Gotcha 11: Importing from multiple packages

Gotcha: I get errors when I try to wildcard import multiple packages, but I
can wildcard import eachpackage separately without any errors.

Synopsis: Wildcard imports from multiple packages can cause name
collisions.

Large designs, anddesigns thatuse IP models, will likely havemultiple packages,
For convenience, a package can be wildcard imported into a design, which can
savehaving to explicitly import eachitemfrom eachpackage. However, wildcard
imports of multiple packages can lead to a gotcha, as illustrated in the following
example.

package chip_types;
typedef enum logic [1:0] {HOLD, LOAD, READY} states_t;

endpackage

package bus_types;
localparam HOLD 32;

endpackage

module chip (, .. );
import chip_types::*; II wildcard import of a package
import bus_types::*; II wildcard import of another package

states_t state_e, nstate_e;

always_ff @(posedge clock, negedge reset_n)
if (!reset_n) state_e <= HOLD; II GOTCHA: HOLD has multiple
else state_e <= nstate_e; II definitions

The gotcha in the example above is that both packages contain an identifier
namedHOLD. Wildcard importing bothpackages will result in a compilation error
due to the nameconflict.

How to avoidthis Gotcha

The gotcha with wildcard package imports occurs when there are identifiers
common to more than one package, To avoid this gotcha, explicitly import any
duplicate identifiers from the desired package. Wildcard imports of other
packages will not import identifiers that have been explicitly declared or
explicitly imported in the localscope.

import chip_types::*; II wildcard import of a package
import bus_types::*; II wildcard import of another package
import chip_types::HOLD; II explicit import of HOLD



30 Verilog and SystemVeriiog Gotchas

Gotcha 12: Default base of literal integers

Gotcha: Some branches ofmycasestatement areneverselected, even with the
correct inputvalues.

Synopsis.' Literal integers have a default base that might not be what is
intended.

Literal integers in Verilog and SystemVerilog can be specified as a simple
decimal integer(e.g. 5) or as a basedinteger (e.g. ' ns), A based literal integer
is specified usingthe following syntax:

<size>'s<base><value>

Where:
• <s i ze> is optional. If given, it specifies the total number of bits

represented by the literal integer. If not given, the default size, per the
Verilog/SystemVerilog standard is "at least"32 bits.

• s is optional. If given, it specifies that the literal integer should be treated as
a signed value in operations. If not given, the default is unsigned. (The
signed specifier wasadded to Verilog as part of the Verilog-200 I standard.)

• <ba s e > is required, and specifies whether the value is in binary, octal,
decimal, or hex.

• <val ue> is required, andspecifies the literal integer value.

A simple literal integer (e.g. 5) defaults to a decimal base. Touse a binary, octal,
or hex value, a based-literal integer must be specified (e.g. ' h 5 or 2' b 10). The
baseoptions are represented using b, 0, d, or h for binary, octal, decimal andhex,
respectively. The base specifier can be either lowercase or uppercase (i.e. ' h 5
and ' H5 are the same).

The following example of a 4-to-l multiplexer illustrates a common gotcha when
an engineer forgets that a simple integer number is a decimal value.
logic [1:0] select; II 2-bit vector

always_comb begin
case (select) II intent is for a 4-to-l MUX behavior

00: y = a;
01: y = b;
10: y = c; II GOTCHA! This branch is never selected
11: y = d; II GOTCHA! This branch is never selected

endcase
end

This gotcha fits nicelywith the joke that only engineers laugh at: "There are 10
typesofpeople in the world, thosethatknow binary, and those thatdont ".



Chapter 2: Declaration and Literal Number Gotchas 31

The previous example may look reasonable, and it is syntactically correct. Since
the default base of a simple integer is decimal, however, the case select values
"10" and "11" are ten and eleven. The 2-bit select signal can only contain the
values 0, 1,2 and 3. The select values of2 and 3 willnot match anyof the case
items, and the branches for thecase items of decimal "10" and "11" willneverbe
executed. This is not a syntax error. The problem shows up in simulation as a
functional failure which canbe difficult to detect and debug. Gotcha!

How to avoid this Gotcha using Verilog

With Verilog, the easiest coding stylefor detecting that there is a design problem
is to add a default branch to the case statement that detects when none of the
expected branches evaluate as true. For example:

case (select) II intent is for a 4-to-l MUX behavior
00: y = ai
01: y = bi
10: y = Ci II GOTCHA! This branch is never selected
11: y = di II GOTCHA! This branch is never selected
default: $display(ltselect value of %b not decoded", select);

endcase

How to avoid this Gotcha usingSystemVerilog

SystemVerilog adds a unique modifier for case statements. This extension to
Verilog provides an easyway to detect this gotcha.

unique case (select) II intent is for a 4-to-l MUX behavior
00: y = a;
01: y = bi
10: y = Ci II GOTCHA! This branch is never selected
11: y = di II GOTCHA! This branch is never selected

endcase

The unique modifier reports an error if two or morecase select items are true at
the sametime, or if no caseselect items are true. The example above becomes an
error, ratherthan a functional bug in the code.

The following example codes the casestatement correctly.
unique case (select) II intent is for a 4-to-l MUX behavior

2'bOO: y = ai
2'b01: y = bi
2'b10: y c ; II OK, this branch can be selected
2'b11: y = di II OK, this branch can be selected

endcase

Caution! The unique modifier is not appropriate for every case statement. See
Gotcha 35 on page 79 for additional discussion on usingunique case.



32 Verllog and SystemVeriiog Gotchas

Gotcha 13: Signedness of literal integers

Gotcha: My incrementor model sometimes gets incorrect values when I
increment usinga literal l 'bl,

Synopsis.' Unbased literal integers default to signed. Based literal integers
default to unsigned.

Literal integers in Verilog and SystemVerilog can be specified as a simple
decimal integer (e.g. S) or as a basedinteger (e.g. ' h s). A simple literal integer
(e.g. 5) defaults to a signedvalue, and cannot be specified as unsigned. A based
literal integer (e.g. ' h5) defaults to an unsigned value, unless explicitly specified
as signed (e.g. ' shS). A basedliteral integer is specified as follows:

<size>'s<base><value>

• <S i ze> is optional. If given, it specifies the totalnumber of bitsrepresented by
the literal integer. If not given, the default size,per the Verilog/SystemVerilog
standard is "at least"32 bits.

• s is optional. If given, it specifies that the literal integer should be treated as a
signed value in operations. If not given, the default is unsigned. (The signed
specifier wasadded to Verilog as partof the Verilog-2001 standard.)

• <ba s e > is required, and specifies whether the value is in binary, octal,
decimal, or hex.

• <val ue> is required, andspecifies the literal integer value.

The signedness of a literal value affects several types of operations. Unexpected
operation results will occur if an engineer forgets-or is not aware of-the
different signedness of a simple literal integer versus a based literal integer.

Are the following twosigned counter statements the same?
byte in; II signed a-bit variables
int outl, out2; II signed 32~bit variables

initial begin
in ==-5;
outl = in + 1; II OK: -5 + 1 = -4 (literal 1 is signed)

out2 • in + l'bl; II GOTCHA: -5 +l'bl = 252 (l'bl is unsigned)
end

How to avoidthis Gotcha

Toavoidthis gotcha, engineers needto know, properly use,andtakeadvantage of
Verilog's rich set of signed and unsigned literal values. Signed arithmetic is
discussed in moredetail in Gotcha 47 on page 108.



Chapter 2: Declaration and Literal Number Gotchas 33

Gotcha 14: Signed literal integers zero extend to their specified size

Gotcha: When I specifya signed, sized literalinteger witha negative value, it
does not sign extend.

Synopsis: Too small a size truncates the most-significant bits ofa value. Too
large a size left-extends a value with 0, x, or z, butdoes not sign extend.

Literal integers can be specified as unsized integers (e.g. 'hS) or as sized
integers (e.g. 16' hS). The syntax for specifying literal integers is:

<size>'s<base><value>

Where:
• <si ze> is optional. If given, it specifies the total number of bits

represented by the literal integer. If not given, the default size, per the
Verilog/SystemVerilog standard is "at least"32 bits.

• s is optional. If given, it specifies that the literal integer shouldbe treated as
a signed value in operations. If not given, the default is unsigned. (The
signedspecifier wasaddedto Verilog as part of the Verilog-2005 standard.)

• <ba s e > is required, and specifies whether the value is in binary, octal,
decimal, or hex.

• <value> is required, and specifies the literalinteger value.

It is legal to specify a mismatch between the size and the number of bits
represented by the value. Verilog/SystemVerilog has built-in rules for how to
handle a mismatch. If these rules are not understood, engineers might be caught
by a gotcha. The following example specifies a valuethatappears to be a negative
value,but is zero extended as if an unsigned value.
logic signed [11:0] ai
a = 12'shFFi II GOTCHA! signed value hex FF does not represent -1

II 8-bit FF value extends to 12-bit 000011111111
II WHY?

The Verilog/SystemVerilog rules for a mismatch between the size and the value
are explained in the following paragraphs.

Size smaller than value rule. If the bit size specified is fewer bits than the value,
then the left-most bits of the value are truncated. This can be a gotchawhen the
value is signed, because the sign bit will be truncated as well. In the following
example, a negative 15 (8-bit Fl hex) is truncated to 4-bits wide, becoming a
positive 1. Gotcha!
logic signed [7:0] bi
b = -4'sd15i II GOTCHA! 11110001 (-15) is truncated to 0001 (+1)



34 Verilog and SystemVeriiog Gotchas

Size greater than value rule. When the bit size specified is more bits than the
value, thevaluewillbe expanded to thesizeby left-extending. The fill value used
to leftextend isbased on the most-significant bit of thevalue, as follows:
• If the most-significant bit of the specified value is a 0 or a I, then the value is

left extended withzeros.
• If the most-significant bit is an X, thenthe valueis left extended Xs.
• If the most-significant bit is a Z, thenthe valueis left extended Zs.

This left extension can be useful. For example, it is not necessary to specify the
value of each and every bit of a vector to reset the vector to zero or to set the
vectorto high impedance.
64'hOi II fills all 64 bits with 0
64'bZi II fills all 64 bits with Z

When the bit-size is larger than the value, and the value is signed, the expansion
rules above do not sign-extend a signed value. Evenif the number is specified to
be signed, and the most-significant bit is a l, the value will still be extended by
O's. For example:
logic signed [11:0] a, bi

initial begin
a = 12'sh3ci II OK, signed 00111100 expands to 000000111100
b = 12'8074; II GOTCHA! signed 111100 expands to 000000111100

end

The hex value 3c is an 8-bitvalue thatdoesnot set its most-significant bit. When
the valueis expanded to the 12-bit size, the expansion zero-extends, regardless of
whether the literal integer is signed or unsigned. This is as expected.

The octalvalue 74 is the samebit pattern as a hex 3c, but is a 6-bitvaluewith its
most-significant bit set. The expansion to the 12bit size still zero-extends, rather
than sign-extends. Gotchal.

The subtlety in the preceding example is that the sign bit is not the most­
significant bit of the value. It is the most-significant bit of the specified size.
Thus,to specify a negative valuein the examples above, thevaluemustexplicitly
set bit 12of the literalinteger. Negating a positive valuewill set its signbit.
12'shFFB II expands to 111111111011, which is -5 decimal
-12'sh5 II expands to 111111111011, which is -5 decimal

How to avoid this Gotcha

The way to avoid these gotchas is to be sure that the bit size specified is the same
size as the value, especially when using signedvalues. Some tools, such as lint
tools(coding stylecheckers), will detecta sizeversus valuemismatch.



Chapter 2: Declaration and Literal Number Gotchas 35

Gotcha 15: Literal integersize mismatch in assignments

Gotcha: When I assign a 4-bitnegative value to an 8-bitsignedvariable, it is
notsign extended.

Synopsis: A size mismatch in an assignment mightzero extendor mightsign
extend, depending on the types of expressions on the right-hand side of the
assignment.

When a literal integer is assigned to a variable, twoexpansion/truncation rulesare
applied:
• First, the value is expanded or truncated to the specified size of the literal

integer, via the rulesdiscussed in Gotcha 14on page33.
• Second, the assignment operator rules are then applied, as discussed in this

gotcha.

Note: This gotcha discusses assignment of literal integers (e.g. a = 5;). Gotcha
46 on page 105 discusses assignment rules and gotchas when thereare operators
on the right-hand sideof the assignment.

The assignment operation rulesfor assigning literal integers are:
• When the left-hand side expression of an assignment statement is fewer bits

than the right-hand side literal integer, then the most-significant bits of the
right-hand sidevalueare truncated.

• When the left-hand side expression of an assignment statement is more bits
than the right-hand side literal integer, then:
• If the right-hand side literal integer is unsigned, it willbe leftextended with

zeros.
• If the right-hand side literal integer is signed, it will be left extended using

sign extension.
• Exceptions: If the right-hand side is an unsized high-impedance literal

integer (e.g.: 'bz) or unsized unknown (e.g.: 'bx), the value will left­
extendwith z or x, respectively, regardless of whether signedor unsigned.

These rules might seem, at first glance, to be the samerules discussed in Gotcha
14 on page 33 for when a literal integer size does not match the literal integer
value. There is a subtle, but important, difference in the rules, however. The
difference is that literal integer expansion will never sign-extend, but an
assignment statement might sign-extend.

And now the gotcha. Sign extension of the right-hand side only occurs if the
expression on the right-hand side of the assignment statement is signed. The



36 Verilog and SystemVeriiog Gotchas

signedness of the left-hand side expression does not affect whether or not sign
extension will occur.

Consider the following examples:

logic [3:0] ai II unsigned 4-bit variables
logic signed [3:0] bi II signed 4-bit variables
logic [7:0] Ui II unsigned 8-bit variables
logic signed [7:0] Si II signed 8-bit variables

u = 4'hCi II OK, 1100 (hex C) is zero-extended to 00001100

s = 4'hCi II GOTCHA! 1100 is zero-extended to 00001100,
II even though s is a signed variable

u = 4'shCi II GOTCHA! 1100 is sign-extended to 11111100,
II even though u is an unsigned variable

s = 4'shCi II OK, 1100 is sign-extended to 11111100

a = 4'hCi II assign 4-bit literal to 4-bit unsigned variable
u = ai II OK, 1100 is zero-extended to 00001100

s = ai II GOTCHA! 1100 is zero-extended to 00001100,
II even though s is a signed variable

b = 4'hCi II assign 4-bit literal to 4-bit signed variable
U = bi II GOTCHA! 1100 is sign-extended to 11111100,

II even though u is an unsigned variable

s = bi II OK, 1100 is sign-extended to 11111100

Thesesimple examples illustrate two types of gotchas:
• Assigning to a signed variable does not cause sign extension. Sign extension

onlyoccurs if the right-hand sideexpression is signed.
• Assigning to an unsigned variable can have sign extension. Sign extension

occurs if the right-hand side expression is signed.

In other words, it is the right-hand side of an assignment that determines if sign
extension will occur. The signedness of the left-hand sidehas no bearing on sign
extension.

Thesesameassignment expansion rulesapplywhenoperations are performed on
the right-hand side of an assignment. However, whether zero extension or sign
extension will occuralso depends on the typeof operation. These operation rules
are covered in Gotcha 45 on page 101.



Chapter 2: Declaration and Literal Number Gotchas 37

Gotcha 16: Filling vectors with all ones

Gotcha: I can use a literal integer to set all bits to Z on a vectorofany size,
but whenI use thesamesyntax to set all bits to 1, I get a decimal 1 instead.

Synopsis: Verilog does not have a literal integer value thatfills all bits ofa
vector with ones. SystemVerilog does.

In Verilog, assigning' bx, ' bz, or 0 willfill a vector of anysizewithall bitsset to
X, Z, or zero, respectively. However, assigning' bl is not orthogonal. It doesnot
fill a vector withall bits set to one.
parameter WIDTH = 64;
reg [WIDTH-l:O] data;

data 'bO; II fills with 64'hOOOOOOOOOOOOOOOO
data ' bz; II fills with 64'hzzzzzzzzzzzzzzzz
data 'bx; II fills with 64'hxxxxxxxxxxxxxxxx
data ' bl; II fills with 64'hOOOOOOOOOOOOOOOl GOTCHA!

Note: Prior to the Verilog-2001 standard, using' bz or ' bx would only fill up to
32bits with z or x. Anyadditional bits to the leftof these 32bits were zerofilled.

How to avoidthis Gotcha using Verilog

In orderto assign a vector of anysizewithall bits set to one,designers must learn
clever coding tricks involving various Verilog operators, suchas:

data {64{1'bl}}; II replicate operation (must hard code size)
data -1; II negate operation (must use signed literal)
data -0; II invert operation

None of these coding tricks for filling a vector of any sizewith all bits set to 1 is
obvious, self-documenting code. SystemVerilog has a better way to avoid this
gotcha, as shown below.

How to avoidthis Gotcha usingSystem Verilog

SystemVerilog provides a simple and consistent syntax for filling any size of
variable with all ones, all zeros, all Xs or all Zs. This is done by just assigning
, <value>, as shown below:
parameter WIDTH = 64;
logic [WIDTH-l:0] data;

data '1; II fills with 64'hffffffffffffffff
data ' 0; II fills with 64'hOOOOOOOOOOOOOOOO
data ' z; II fills with 64'hzzzzzzzzzzzzzzzz
data ' x; II fills with 64'hxxxxxxxxxxxxxxxx



38 Verilog and SystemVeriiog Gotchas

Gotcha 17: Array literals versus concatenations

Gotcha: The wrong values are stored when I assign a list of values to a
packedarrayor structure.

Synopsis: Packed arrays and structures can be assigned either a
concatenation or an assignment patternwitha listofvalues.

The Verilog concatenation operator joins one or more values and signals into a
singlevector. Array and structure literals (alsoknown as an assignment patterns)
are lists of one or more individual values. To make the difference between these
constructs obvious to bothengineers andsoftware tools, the syntax foran array or
structure literal is an apostrophe and { } surrounding a list of values, which is
different from concatenation, which usesjust { }.

logic [1:0] [31:0] Aj II two-dimensional packed array
A = {1'bl, l'bl}j II GOTCHA? assign concatenation to A
A = '{I'bl, l'bl}j II GOTCHA? assign list of values to A

Thegotcha in this example is that it is not clearwhether the intentwas to assign a
list of values or to assign a concatenation. Since A is a packed array, both types of
assignments are legal. If a list of values was intended in the example above, but
the apostrophe is inadvertently omitted, it is not a syntax error. The values
assigned to A, however, are very different. As a list of values, the assignment is
equivalent to:

A[l] = l'bl; II decimal 1
A[O] = l'bl; II decimal 1

As a concatenation, the assignment is equivalent to:
A[l] l'bO II decimal 0
A[O] = 2'bllj II decimal 3

How to avoid this Gotcha

Oneway to avoidthis gotcha is to onlyuse unsized values in a list of values. The
concatenation operator requires sized values, which would make inadvertently
leaving off the apostrophe a syntax error.

logic [1:0] [31:0] A; II two-dimensional packed array
A = {I, I}; II ERROR, illegal concatenation
A = '{ 1, I}; II OK, assign list of values to A

Another way to detectthis coding erroris with tools that lookfor assignment size
mismatches, suchas a lint tools(coding stylecheckers).

A closely relatedgotcha is described in Gotcha 100 on page206.



Chapter 2: Declaration and Literal Number Gotchas 39

Gotcha 18: Port connection rules

Gotcha.· My design doesn 1 work correctly when I connect all the modules
together, buteach module works correctly by itself.

Synopsis: The size ofa port and thesize ofthe net or variable connected to it
can be different.

The Verilog standard states that module ports are treated as continuous assign
statements that continuously transfer values into, andout of, modules. This is not
a gotcha, but rather a rule that helps explain some gotchas relating to port
connections.

In Verilog, the receiving side of an input or inout port can only be a net type,
such as wire. The transmitting side of an output port can be either a net or a
variable. When considering ports as continuous assignment statements, it
becomes easier to understand why the receiving sidesof ports are required to be
net data types, and why the driver (or source) sideof portscouldbe eithernetsor
variables. The receiving side of a port is the same as the left-hand side of a
continuous assign statement, and the driveror source side of a port is the sameas
the right-hand sideof a continuous assign statement. In otherwords, the left-hand
side/right-hand side rules for continuous assignments apply directly to port
assignments.

With this in mind, consider the four scenarios regarding port size connections
(threeof whichcan be gotchas if not wellunderstood):

• Theport size and the sizeof the signal driving the port are the samesize
• The signal driving the port has morebits thanthe port (a gotcha)
• The signal driving the porthas fewer bits thanthe port (a gotcha)
• An inputport is unconnected; there is no signal driving the port (a gotcha)

Applying Verilog/SystemVerilog assignment size rules to ports gives the
following effects for thesefourscenarios:

1. If the size of the port and thesizeof the signaldriving the portmatch, thenthe
valuepasses through the port withno change.

2. If the signaldriving the port (the right-hand side of a continuous assignment)
has more bits than the port's receiving net (the left-hand side of an assign­
ment), then the upper bits of the driving signal are truncated, including any
signbit.



40 Verilog and SystemVeriiog Gotchas

3. If the signal driving the port (the right-hand sideof a continuous assignment)
has fewer bits than the port's receiving net (the left-hand side of an assign­
ment), thentheupperbits areextended, following Verilog's assignment rules:
• If the driving signal (right-hand side of an assignment) is unsigned, the

upperbits are zero-extended to the sizeof the receiving signal.
• If the driving signal (right-hand side of an assignment) is signed, then the

upperbits willbe sign-extended.
4. If an inputport is unconnected, the value for the receiving signal of the port

willbe the default uninitialized value for its given data type. For thewire net
type, the uninitialized value is Z. For triO and tril net types, the uninitial­
izedvalues are 0 and 1,respectively, witha pull-up strength.

In Verilog/SystemVerilog, an incorrect size declaration is an easydesign mistake
to make, especially when the modules that make up a design are written by
several different engineers, (and possibly even come from outside sources). A
simple typo in a netlist, or an incorrect parameter redefinition, can also lead to
port size mismatches. Typographical errors in a netlist can also result in some
portsof a module instance unintentionally leftunconnected.

Most often, any mismatch in port connection sizes is a design error. It is not a
syntax error, however. Because it is not an error, understanding the rules of how
Verilog/SystemVerilog handles a mismatch in connection size helps avoid
unexpected simulation or synthesis results (gotchas). Trying to trace backto why
somebits disappeared from a vector, or additional bits suddenly appeared, canbe
difficult. And that assumes that verification detected that there is a problem! The
following example illustrates how values are extended or truncated when passed
through a portof a different size thanthevalue.

module top;
wire [3:0] data = 4'bllll; II decimal 15
wire [7:0] addr = 8'bllllllll; II decimal 255

blockl bl (.data(data), II 4-bit net connected to 8-bit port
.addr(addr)); II 8-bit net connected to 4-bit port

II third port left unconnected
endmodule: top

module blockl (input [7:0] data,
input [3:0] addr,
input [3:0] byte_en);

initial
#1 $display(" data = %b \n address = %b \n byte_en %b\n",

data, address, byte_en);
endmodule: blockl



Chapter 2: Declaration and Literal Number Gotchas 41

The outputfromsimulating this example is:
data = 00001111 GOTCHA!
address = 1111
byte_en = zzzz

The example above shows how confusing unconnected or partially connected
ports can be. The valueof data has mysteriously changed, gaining an extra four
bits. The value of address changed from 255 to 15 (decimal), and byte_en is
high-impedance instead of a validlogicvalue.

How to avoidthis Gotcha using Verilog

Mostsimulators, synthesis toolsandothersoftware toolsgenerate warnings when
there are port connection mismatches, but suchwarnings are not required by the
Verilog or SystemVerilog standards, and engineers are notorious for ignoring
these warnings. In Verilog, the only way to avoid this type of gotcha is to pay
attention to warning messages.

How to avoidthis Gotcha usingSystemVerilog

SystemVerilog provides a great solution to this gotcha: implicit port connections
using either dot-name or dot-star module instantiations (see Gotcha 2 on page
10). When using the dot-name or the dot-star module instantiation syntax, the
driver and receiver port signals are required to be the same size. If, for some
reason, a driver/receiver signal pair size mismatch is desired, the port must be
explicitly connected. This makes it very obvious in the code that the mismatch
was intended.
module top;

wire [7:0] data;
wire [7:0] addr;

block1 b1 (.data, II implicit port connections
.addr);

endmodule: top

module block1 (input [7:0] data,
input [3:0] addr,
input [3:0] byte_en);

endmodule: block1

In this example, the size of the wire called data has been corrected to be 8-bits
wide, which is the same as the size of the data port in blockl. The dot-name
shortcut will infer that the wire calleddata is connected to the port calleddata.
However, thereis still a typo in thedeclaration of the wirecalledaddr. Instead of
a port connection mismatch (a gotcha), a compilation errorwill occurbecause the



42 Verilog and SystemVeriiog Gotchas

signal at the top level is a different size than the port in blockl. The dot-name
willnot inferconnections thatdo notmatch in size.

Thedot-name method willallow unconnected ports, such as thebyte_en portin
the example above. Was this port left unconnected on purpose, or is it another
typo in the netlist? To catch all thesizemismatches andunconnected ports, using
the dot-star shortcut is the best solution. The dot-star shortcut requires explicitly
listing all unconnected portsandall thesignals withdifferent sizes.

module top;
wire [7:0] datai
wire [7:0] addri

blockl bl (.*, II implicit port connection
.addr(addr[7:4]), II explicitly shows size mismatch
.byte_en()); II explicitly shows unconnected

endmodule: top

module blockl (input [7:0] data,
input [3:0] addr,
input [3:0] byte_en);

endmodule: blockl



Chapter 2: Declaration and Literal Number Gotchas 43

Gotcha 19: Back-driven ports

Gotcha: I declaredmyport as an input, and software tools let me accidentally
use theport as an output, withoutany errorsor warnings.

Synopsis: Software tools can ignore the declareddirection ofa moduleport,
based on how theport is used.

One of the surprising gotchas in Verilog and SystemVerilog is that a module
input portcanbe usedas an output. If a designer mistakenly assigns a value to
a signal declared as an input port, there will not be any warnings or errors.
Instead, Verilog/SystemVerilog simply treats the input port as if it were a
bidirectional inout port. Similarly, a higher level module can drive values back
into a module's output port. The output port is simply treated as if it were a
bidirectional inout port,andno errors or warnings are generated.

The Verilog/SystemVerilog standard refers to driving a value back onto a port
declared the opposite direction as port coercion. Port coercion can only occur
when net data types (such as wire) are used on both sides of a port. This is
because net types allow multi-driver functionality. Since back-driven ports are
coerced to inout ports, theybecome multi-driver ports, which require net types.

Port coercion canbe useful. A port is really just a transparent connection between
an external and internal signal. Port coercion allows software tools to connect
modules in thewaytheyareused. It alsoaccurately represents physical hardware,
where "ports" don't exist; the external and internal signals are the same single
net, and there is no connection of one net to another net. However, port coercion
can also allow unexpected design behavior (gotchas), as illustrated in the
following example.

module top
(output wire [7:0] out, II net data type
input wire [7:0] in II net data type

) ;

buffer8 bl (. y (out), . a (in) ) ;
endmodule

module buffer8
(output wire [7:0] y, II net data type
input wire [7:0] a II net data type

) ;
assign a = y; II GOTCHA! this should have been y = a;

endmodule



44 Verilog and SystemVeriiog Gotchas

In this example, there is a coding error in module buffer8. Instead of assigning
the input value to the output (y = a), the model assigns the output to the input
(a = y). Instead of being a syntax error, software tools can coerce the module's
ports to be inout ports. Gotcha!

How to avoid this Gotcha using Verilog

Portcoercion cannot occurif a variable type(e.g. reg or logic) is usedas a port.
Verilog allows output ports to be declared as a variable type, but inputportsmust
be a net type. Prior to the Verilog-2005 standard, the gotcha in the previous
example could not be completely avoided. Designers had be careful not to
inadvertently assign values to inputports. Some tools, such as lint tools (coding
style checkers) may issue a warning when this occurs, which could help detect
that the gotcha is present.

The Verilog-2005 standard adds a uwire (unresolved wire) net data type. The
uwire type only allows a single driver on a net. Thus, when buffer8 is
connected within module top, a compilation error occurs because the buffer8
inputport (a) has multiple drivers.

module buffer8
(output uwire [7:0] y, II variable data type
input uwire [7:0] a II variable data type

) ;
assign a = y; II ERROR! multiple drivers for a;

endmodule

The functional gotcha has become a compilation errorbecause boththe inputport
and the continuous assignment writeto theuwire a.

How to avoid this Gotcha usingSystem Verilog

SystemVerilog allows variables to be used on both input and output ports.
(Bidirectional inout ports must still be a net type, as in Verilog). SystemVerilog
also allows continuous assignments to assign to variables. In addition,
SystemVerilog restricts variables to having a single source, which can be a single
port, a single continuous assignment, or any number of procedural assignments
(which are treated as one source).

In SystemVerilog, module buffer8, canbe codedas follows.

module buffer8
(output logic [7:0] y, II variable data type
input logic [7:0] a II variable data type

) ;
assign a = y; II ERROR! multiple sources for a;

endmodule



Chapter 2: Declaration andLiteral Number Gotchas 45

Thefunctional gotcha hasbecome a compilation errorbecause boththe input port
and the continuous assignment writeto thevariable a.

Coding guidelines

When using SystemVerilog, the authors recommend that all module inputs and
outputs be declared as logic variable types, unless it is intended to have multiple
drivers on the port (e.g. a bidirectional data bus). By using variables, port
coercion cannot occur, andthecoding mistake becomes anerrorthatis detected at
compilation time.



46 Verilog and SystemVeriiog Gotchas

Gotcha 20: Passing real (floating point) numbers through ports

Gotcha: I cannotfind a way to pass real values from one module to another
usingeither Verilog or System Veri/og.

Synopsis: Verilog does not allow real numbers to be passed directly through
ports. System Verilog does, but requires a specialport declaration.

Verilog has a real variable type, which stores a double-precision floating point
value. The following example attempts to pass real values from one module to
another module through module portsanda top-level netlist.

module real out (output real ro , ... ); II ERROR: output is real

endmodule

module real in (input real ri, ... ); II ERROR: input is real

endmodule

module top;
real real_connect;
real_out rl (.ro(real connect)); II ERROR: real connected to port
real_in r2 (.ri(real_connect)); II ERROR: real connected to port

endmodule

The gotcha is that it is illegal in Verilog to pass realnumbers through ports.

How to avoidthis Gotcha using Verilog

In Verilog, the only way to pass floating pointvalues through ports is by using a
pair of built-in system functions to convert real numbers to a format that can be
passed through ports. The numbers are then converted back to real in the
receiving module. Thesefunctions are $realtobits and $bitstoreal.
module real_out (output wire [63:0] net_real_out); II vector output

real r;
assign net_real_out = $realtobits(r); II convert real to vector

endmodule

module real in (input wire [63:0] net_real_in); II vector input
real r;
always @(net_real_in)

r = $bitstoreal(net_real_in); II convert vector to real

endmodule



Chapter 2: Declaration and Literal Number Gotchas 47

module top;
wire [63:0] net_real; 1/ net types used in netlist
real out ro (.net_real_out(net_real));
real in ri (.net_real in(net_real));

endmodule

Howto avoidthis Gotcha using System Verilog

SystemVerilog allows floating point values to be passed directly through ports
without having to convert the real values to and from bit vectors. However, the
SystemVerilog syntax is not intuitive. An output port of a module can be
declared as a real (double precision) or shortreal (single precision) type, but
input ports must be declared with a keyword pair, var real or
var shortreal.

module real out (output real r); 1/ output is real variable type

endmodule

module real in (input var real r); II input is real variable type

endmodule

module top;
real r; II variable types can be used in netlist
real out ro (.r);
real in ri (. r ) ;

endmodule

A closely related gotcha involving how tools implement real ports is covered in
Gotcha 101 on page208.



Chapter 3
RTL Modeling Gotchas

Gotcha 21: Combinational logic sensitivity lists with function calls

Gotcha: My combinational logic seemed to simulate OK, but after synthesis,
thegate-level simulation does not match theRTLsimulation.

Synopsis: If combinational logic calls a function, then the combinational
sensitivity list must include signals that thefunction reads. @* does not infer
sensitivity to values readbyfunctions calledfrom combinational logic.

Synthesizable RTL modeling style requires that Verilog always procedural
blocks have an edge sensitive timing control (the @token) following the always
keyword. This time control is referred to as the block's sensitivity list.

always @(a, b) begin II OK, sensitivity list complete
sum = a + b;

end

always @(a, b) begin II OK, sensitivity list complete
prod = mult(a, b}; II call function that reads a, b

end

always @(a, b) begin II GOTCHA! sensitivity list not complete
out = sel? sum: prod II missing sel

end

function [15:0] mult (input [7:0] m, n);
mult = m * n;

endfunction

Note: the code examples in this chapter are contrived in order to illustrate each gotcha using small
examples. In realdesignand verification code,thesegotchas mightnot be as obvious or easy to debug.



50 Verilog and SystemVeriiog Gotchas

When modeling combinational logic, if the sensitivity list is not complete, then
the outputs of the block will not be updated for all possible input changes. This
behavior models a latch in simulation. However, synthesis will assume a
complete sensitivity list and build combinational logic instead of a latch. The
simulation results of the RTL model andthesynthesized gate-level model willnot
match. Gotcha!

In the simple examples above, it is easy to manually code a complete sensitivity
list,andto see if something is missing. Realdesigns arenot always thatsimple. A
complex decoder, for example, couldread several dozen signals, each and every
one of which mustbe listed in the sensitivity list. A verycommon coding gotcha
occurs when a designer, in the process of implementing a design, adds another
statement to the complex decode logic that reads an additional variable, and
forgets to add that additional signal to the sensitivity list. The functional problem
that results canbe verydifficult to detect anddebug. Gotcha!

How to avoidthis Gotcha using Verilog

Verilog has an @* wildcard sensitivity list that infers a complete sensitivity list for
both simulation and synthesis-most of the time. The @* wildcard will
automatically be sensitive to any nets or variables that are read in the always
procedural block, including any nets or variables that are passed to a function
input. Using @* will fix the gotcha in the example above (either @* or @(*) can
be used; theyare equivalent).

always @* begin II OK, infers @(a, b)
sum = a + b;

end

always @* begin II OK, infers @(a, b)
prod = mult(a, b); II call function that reads a, b

end

always @* begin II OK, infers @(sel, sum, prod)
out = sel? sum: prod

end

function [15:0] mult (input [7:0] m, n);
mult = m * n;

endfunction

However, @* has a subtle gotcha that is not widely known. It only infers
sensitivity to signals directly referenced in the always block. It will not infer
sensitivity to signals that are externally referenced in a function that is called
from thealways block. Thatis, the @* willonlybe sensitive to thesignals passed
into the function or task. Thefollowing example illustrates thisgotcha:



Chapter 3: RTL Modeling Gotchas 51

always @* begin II GOTCHA! infers @(a, b)
prod = mult(a, b); II call function that reads a, b, max rtn

end

function [15:0] mult (input [7:0] m, n);
mult = m * n;
if (mult > max_rtn) II reference to external variable

mult = max_rtn;
endfunction

In the preceding example, the sensitivity list inferred by @* will not be complete,
and therefore willnot correctly represent combinational logic in RTL simulations.
Synthesis will assume a complete sensitivity list, leading to a mismatch in RTL
simulation versus the gate-level simulation. Gotcha!

Howto avoidthis Gotcha using System Vertlog

SystemVerilog has two specialized procedural blocks that infer a complete
sensitivity list, always_comb and always_latch (there is also an always_ff
procedural block for sequential logic). The always_comb and always_latch
procedural blocks will descend intofunction calls to inferthe sensitivity list.

always_comb begin II OK, infers @(a, b)
sum = a + b;

end

always_comb begin II OK, infers @(a, b, max_rtn)
prod = mult(a, b); II call function that reads a, b, max rtn

end

always_comb begin II OK, infers @(sel, sum, prod)
out = sel? sum: prod

end

function [15:0] mult (input [7:0] m, n);
mult = m * n;
if (mult > max_rtn) II reference external variable

mult = max_rtn;
endfunction

Note that always_comb and always_latch do not descend into task calls. Ifa
synthesizable task-like subroutine is required, a SystemVerilog void function
shouldbe used.



52 Verilog and SystemVeriiog Gotchas

Gotcha 22: Arrays in sensitivity lists

Gotcha.· I need my combinational logicblockto be sensitive to all elements of
a RAM array, but thesensitivity list won't trigger at the correct times.

Synopsis: It is not straightforward to explicitly specifya combinational logic
sensitivity list when the combinational logicreads values from an array.

A subtlety that is not well understood is combinational logic sensitivity when the
combinational block reads a valuefroman array. For example:

logic [31:0] mem_array [0:1023]; II array of vectors

always @( 1* WHAT GOES HERE? *1 ) II want combinational logic
data = mem_array[addr];

In order to accurately model true hardware combinational logic behavior, what
should the sensitivity include? Should the logic only be sensitive to changes in
addr, or should it also be sensitive to changes in the contents of mem_array
being selected by addr? If sensitive to changes in the contents of mem_array,
whichaddress of the array?

The answer, in actualhardware, is that da ta will continually reflect the value that
is currently being selected from the array. If the address changes, data will
reflect that change. If the contents of the array location currently being indexed
change, da t a will also reflect that change.

The problem, and gotcha, is that this behavior is not so easy to modelat the RTL
level,using an explicitsensitivity list. In essence, the sensitivity list only needs to
be sensitive to changes on two things: addr, and the location in mem_array
currentlyselectedby addr. But, an explicitsensitivity list needs to be hard-coded
before simulation is run, whichmeans the valueof addr is not knownat the time
the model is written. Therefore, the explicitsensitivity list needs to be sensitive to
changes on any and all locations of mem_a r ray, rather than just the current
location.

Tobe sensitiveto the entire array, it wouldseem reasonable to write:

always @( addr or mem_array ) II ERROR! illegal reference to array
data = mem_array[addr];

Unfortunately, the example above is a syntax error. Neither Verilog nor
SystemVerilog allow explicitly naming an entire array in a sensitivity list. Only
explicitselects from an array can be listed. For example:

always @( addr, mem_array[O) , mem_array[l) , mem_array[2) , ... )
data = mem_array[addr];



Chapter 3: RTL Modeling Gotchas 53

This example will work, but it is not practical to explicitly list every array
location. Even the relatively small one-dimensional array used in this example,
whichhas 1024 addresses, wouldbe tedious to code.

What about the following example? Will it be sensitive to both addr and the
valueof the mem_array location currently selected by addr?

always @( mem_array[addr] ) II GOTCHA! not sensitive addr
data = mem_array[addr);

The answer is...It almost works. The example above is sensitive to a change in
valueofmem_array at the location currently indexed by addr. However, it is not
sensitive to changes on addr. If addr changes, data will not be re-evaluated to
reflectthe change. Gotcha!

How to avoid this Gotcha

There are three ways to properly model combinational logic sensitivity when
reading from an array. The best way is to use Verilog's always @* or
SystemVerilog's always_comb to infer the sensitivity list. Both constructs will
infer a correct sensitivity list. Using always_comb has an added advantage of
triggering once at simulation time zero, even if nothing in the sensitivity list
changed. This ensures that the outputs of the combinational logic match the
inputs at the beginning of simulation.

always @* II OK, infers @(addr, mem_array[addr])
data = mem_array[addr);

always_comb II OK, infers @(addr, mem_array[addr])
data = mem_array[addr);

The Verilog-1995 solution to this gotcha is to explicitly specify a sensitivity list
that includes the selectaddress andan arrayselectwith that address. For example:

always @(addr, mem_array[addr]) II OK, this works correctly
data = mem_array[addrJ;

Another way to avoid this gotcha is to use a continuous assignment instead of a
procedural block to model the combinational logic. This will work correctly, but
has the limitation that continuous assignments cannot directly use programming
statements.
assign data = mem_array[addr); II This works correctly



54 Verilog and SystemVeriiog Gotchas

Gotcha 23: Vectors in sequential logic sensitivity lists

Gotcha: My always block is supposed to trigger on any positive edge in a
vector, but it misses mostedges.

Synopsis.' A sequential logic sensitivity list triggers on changes to the least
significant bit ofthe vector.

A sensitivity list can trigger on changes to a vector, which, in the rightcontext, is
useful and important.

logic [15:0] address, data;

always @(address, data) II OK: trigger on change to
II any bit of vectors

There is a gotcha if the sensitivity list contains a posedge or negedge edge
qualifier on a vector. In this case, the edgeeventwill only trigger on a change to
the leastsignificant bit of the vector.

always @(posedqe address) II GOTCHA! triggering on
II specific edge of vector

Howto avoidthis Gotcha

The posedge and negedge event qualifiers serve as filters. Consider the
following example:

always @(posedqe clock or neqedqe reset_n)

The sensitivity list triggers on a rising transition of clock and filters out all
falling transitions on clock. The sensitivity list also triggers whenever reset_ n
has a falling transition, but anyrising transition of reset_ n is filtered out.

When used with I-bit signals such as a clock or reset, the behavior of the
posedge and negedge event qualifiers accurately represents hardware. Testing
for a positive or negative edge of a vector, however, does not make sense in
hardware. Consider the following:

logic [3:0] data; II 4-bit vector
initial begin

#1 data = 5; II data chanqed from 4'bxxxx to 4'b010l

#1 data = 3; II data chanqed from 4'b010l to 4'bOOll
end



Chapter 3: RTL Modeling Gotchas 55

On a I-bit signal, a change from x to 1 is a positive edge, and from x to 0 is a
negative edge. In the code above, when data changes from 4' bxxxx to
4' bOlOl, both scenarios occur. Should always @(posedge data) trigger
because a rising transition occurred, or not trigger because a falling transition
occurred? Or should the blocknot trigger at all because posedge filtered out the
falling transitions and negedge filtered out the rising transitions? Similarly,
when data changes from 4'bOlOl to 4'bOOll, both rising and falling
transitions occuron the samesignal.

Verilog's language rule is well-defined for this situation. By only evaluating the
least significant bit of the vector, there is no ambiguity on how simulation will
behave when multiple bits change at the same time. This rule, however, is not
obvious, and if different behavior was intended or expected, then a gotcha has
occurred.

To avoid this gotcha, only single-bit expressions should be used with the
posedge and negedge edgeeventqualifiers. When transitions on a vector need
to be evaluated, there are some coding tricks that avoid the gotcha of trying to
sample the entirevector. Some examples follow.

To trigger if any bit of vectorhas a rising transition:
always @(posedge data [0] , II rising edge of each bit

posedge data[l],
posedge data[2],
posedge data[3])

To trigger if a specificbit of vector has a rising transition, and ignores transitions
on all other bits:

always @(posedge data[3]) II rising edge of specific bit only

Totrigger if a vectortransitions from zeroto anynon-zero value:
always @(posedge Idata) II rising edge of unary OR of all bits

Totriggerif a vectortransitions from anynon-zero valueto zero:
always @(negedge Idata) II falling edge of unary OR of all bits

Observe that eachof theseexamples is triggering on a I-bit expression or a listof
I-bit expressions. This concept can be extended to other types of operations, so
long as the final expression monitored by posedge or negedge is a l-bit
expression.

A related gotcha involving operations in sensitivity lists is Gotcha 24 on page56.



56 Verilog and SystemVeriiog Gotchas

Gotcha 24: Operations in sensitivity lists

Gotcha: My sensitivity list shouldtrigger on any edgeofa or b, hut it misses
somechanges.

Synopsis: Operations in sensitivity lists only trigger on changes to the
operation result.

Occasionally, an engineer might mistakenly use the vertical bar ( I) OR operator
instead of the or keyword as a delimiter in a sensitivity list. The code compiles
without any errors, but doesnot function as expected. Gotcha!

The @ symbol is typically used to monitor a list of identifiers used as event
triggers for a procedural blocksensitivity list. The Verilog standard also allows @
to monitor an eventexpression.
always @(a or b) II "or" is separator, not operator

sum = a + bi

always @(a I b) II GOTCHA! "I" is operator
sum = a + bi

always @(a "b) II GOTCHA!
sum = a + bi

always @(a == b) II GOTCHA!
sum = a + bi

Whenan operation is used in a sensitivity list, the @tokenwill triggeron a change
to the resultof the operation. It will not triggeron changes to the operands. In the
always @(a I b) example above, if a is 1, and b changes, the result of the OR
operation will not change, and the procedural blockwill not trigger.

Why does Verilog a/low this gotcha? Using expressions in the sensitivity list can
be useful for modeling concise verification monitors or high-level bus-functional
models. An example usage might be to trigger on a change to a true/false test,
such as always @(addressl != address2). The procedural block sensitivity
list will triggerif the expression changes fromfalse to true (0 to 1),or viceversa.

How to avoid this Gotcha

When modeling combinational logic, the best way to avoid this gotcha is to use
the SystemVerilog always_comb procedural block,whichautomatically infers a
correct sensitivity list. This eliminates any possibility of typos or mistakes in
combinational sensitivity lists. The Verilog @* can also be used, but this has its
own gotcha (see Gotcha 21 on page 49). When modeling sequential logic,
engineers need to be careful to avoidusingoperations withina sensitivity list.



Chapter 3: RTL Modeling Gotchas 57

Gotcha 25: Sequential logic blocks with begin...end groups

Gotcha: The clockedlogic in my sequential blockgets updated, even whenno
clockoccurred.

Synopsis: Resettab/e sequentialprocedural blocks witha begin..end blockcan
contain statements that execute asynchronous to the clock.

A common modeling style is to place a begin...end block around the code in
initial and always procedural blocks, even when the procedural block
contains just one statement. Some companies even mandate this modeling style.
For example:
always @(state_e) begin

nstate_e = HOLD; II first statement in block
case (state_e) II second statement in block

HOLD: if (ready) nstate e = LOAD;
LOAD: if (done) nstate_e = HOLD;

endcase
end

This modeling style has a gotcha when modeling resettable sequential logic such
as flip-flops. A synthesis requirement is that a resettable sequential procedural
block should only contain a single if...else statement, though each branch of
the if...else might contain multiple statements. An example of a correct
sequential procedural block is:

always @(posedge clock or negedge reset_n) II good code
if (!reset_n) state_e <= RESET;
else state_e <= nstate_e;

The purpose ofbegin...end is to group multiple statements together so that they
are semantically a single statement. If there is only one statement in the
procedural block, then the begin...end is not required. In a combinational logic
procedural block, specifying begin...end when it is not needed is extra typing,
but does not cause any gotchas.

When modeling resettable sequential logic, however, adding begin...end can
lead to functional gotchas in the model. A resettable sequential block should only
contain a single if...else statement. Adding begin...end allows additional
statements in the block that are functionally incorrect. For example:

always @(posedge clock or negedge reset_n) begin
if (!reset_n) state_e <= RESET; II first statement
else state_e <= nstate_e;
fsm_out <= decode_func(nstate_e); II GOTCHA! second statement

end



58 Verilog and SystemVeriiog Gotchas

This is a gotcha where Verilog/SystemVerilog allows engineers to prove what
won't work in hardware. If the simulation results are not analyzed carefully, it
may appear that fsm_out behaves as a flip-flop that is set on a positive edge of
clock. Gotcha!

In the example above, f sm_au t is notpart of the if...else decision for the reset
logic. This means:
1. The f sm_ au t sequential blockoutput doesnotget resetby the reset logic.
2. When reset goes active, the f sm_au t assignment will be executed asynchro-

nouslyto the clock.

Both 1and 2 above arenot flip-flop behavior. Because of this, synthesis tools will
not allow statements outside of an if...else statement in resettable sequential
procedural blocks. The example above can be simulated and proven to not work
correctly, but it cannot be synthesized.

How to avoid this Gotcha

Some engineers prefer to automatically add begin...end to every procedural
block, even when there is only one statement in the block. This style should be
discouraged! Using begin...end is not appropriate for resettable sequential
procedural blocks, and leads to the gotcha described above.

A better modeling guideline is to mandate that begin...end not be used in
sequential procedural blocks that have reset logic. The following example will
reporta compilation error, instead of allowing the incorrect codeto simulate.
always @(posedge clock or negedge reset_n) II no begin

if (!reset_n) state_e <= RESET; II first statement
else state_e <= nstate_e;
fsm_out <= decode_func(nstate_e); II ERROR instead of gotcha!

The only time begin end should be used in resettable sequential procedural
blocksis within the if else branches, as follows:
always @(posedge clock or negedge reset_n) 1/ no begin

if (!reset_n) begin II multiple statements in if branch
ql <= l'bO;
q2 <= l'bO;

end
else begin II multiple statements in else branch

ql <= dl;
q2 <= d2;

end

A related potential gotcha is when begin...end is used in the if...else branches
of a resettable sequential device, as described in Gotcha 26 on page59.



Chapter 3: RTL Modeling Gotchas 59

Gotcha 26: Sequential logic blocks with resets

Gotcha: Some ofthe outputs ofmy sequential logic do notget reset.

Synopsis: Resettable sequential procedural blocks can incorrectly reset only
someofthe outputs.

A syntactically legal, but functionally incorrect, flip-flop model is illustrated
below:

always @(posedge clock or negedge reset_n)
if (!reset_n) begin

ql <= 0;
q2 <= 0;
q3 <= 0; II GOTCHA! q4 is missing from this branch

end
else begin

ql <= -q4;
q2 <= ql;
q3 <= q2;
q4 <= q3;

end

The problem with the example above is that q4 is notpart of the reset logic, but is
part of the clocked logic. Because q4 is not reset, it is not the same type of flip­
flop as ql, q2 and q3.

In the RTL model above, what will happen to q4 on a reset in simulation? The
answer is that q4 will retain its old value. If a clock occurs while reset is active,
q 4 is neitherresetnor clocked. Thisbehavior represents a gatedor disabled clock
on q 4 during reset. Synthesis will most likely create an ugly gate-level
implementation of this disabled clock, which is probably not what the designer
intended. Gotcha!

A closely related gotcha is if the reset branch assigns to some variables that are
not assigned in the clock branch. This will also not behave as correct sequential
logic,and is probably not what the designer intended.

How to avoidthis Gotcha

To avoid this gotcharequires careful modeling. Designers need to makesure that
the samevariables are assigned values in bothbranches of the if...else decision.
SystemVerilog crosscoverage can be used to verifythat all variables are assigned
values when reset occurs and when clock occurs. Software tools such as a lint
checkers (coding style checkers) and synthesis tools might warn that the two
branches do not assignto the samevariables.



60 Verilog and SystemVeriiog Gotchas

Gotcha 27: Asynchronous set/reset flip-flop for simulation and synthesis

Gotcha: When I code an asynchronous set/reset D-type flip-flop following
synthesis coding rules, mysimulation results aresometimes wrong.

Synopsis: The codingstyle required by synthesis to model an asynchronous
set/reset D-type flip-flop has a simulation race condition. When the race
condition isfixed, the codewillnot synthesize.

Synthesis tools have very specific coding rules for modeling sequential logic
devices such as flip-flops, so that, when the code is read into the tool, the correct
flip-flop type can be selected. One of the rules for an always block sensitivity
list is that,whenone itemin the list hasan edgequalifier (posedge or negedge),
all items in the sensitivity list must have an edge qualifier. In the case of an
asynchronous set/reset D-type flip-flop, the following sensitivity list is required
by synthesis:

always_ff @(posedge elk, negedge rst_n, negedge set_n)

Themodeling withinthe always blocknecessitates certain coding stylesto ensure
the engineer's intent is captured. For a set/reset D-type flip-flop, the set/reset
functionality is modeled using an if ...else...if...else priority encoding style
to prioritize the set and the reset. The model of a synthesizable set/reset set/reset
D-typeflip-flop model is:

always_ff @(posedge elk, negedge rst_n, negedge set_n)
if (!rst_n) II reset has priority over set

q_out <= l'bO; II reset assignments
else if (! set_n)

q_out <= l'bl; II set assignments
else

q_out <= data_in; II d input assignment

This modelsynthesizes as intended. However, the model doesnot workcorrectly
for all simulation conditions. Consider r s t _ n going low. While r s t _ n is low,
set_n goes low. With both rst_n and set_n low at the same time, the flip-flop
will be held in reset, because of the priority coding of reset and set in the model.
Everything is OK so far. Next, rst_n goes high and set_n stays low. Since the
sensitivity list is only sensitive to edges, and is monitoring only the negedge of
r s t _ n, the release of r s t _ n will not trigger the sensitivity list. This means that
the flip-flop will be held in reset whileonly the set signalis active. Gotcha!

This gotchaonly exists with synthesizable asynchronous set/reset flip-flops, and
will only be evidentuntil the next clock. The next clockwill causethe if...else
decisions to be re-evaluated and transition the flip-flop to its set state.



Chapter 3: RTL Modeling Gotchas 61

The problem is that actual asynchronous set/reset inputs are level sensitive, so
when the reset is removed, the active set takes over and drives the flip-flop to its
set level. In the model, however, synthesis rules require the sensitivity list trigger
on the leading edges of the set/reset inputs, causing the simulation gotcha.

How to avoidthis Gotcha

Thisgotcha is a resultof the synthesis-imposed coding stylefor a set/reset d-type
flip-flop. In order to model accurate simulation behavior, a level-sensitive,
combinational logic block must be added that overrides the synthesizable set/
reset logic in simulation. The override is done using the force and release
statements that are normally reserved for verification tests. This simulation­
specific additional code must be hidden from synthesis by using conditional
compilation.

'ifndef SYNTHESIS II start non-synthesizable simulation code
always @*

if (rst_n " !set_n) force ~out = l'bl;
else release ~out;

'endif II start synthesizable and simulatable code
always_ff @(posedge elk, negedge rst_n, negedge set_n)

if (! rst_n) II reset has priority over set
q_out <= l'bO; II reset assignments

else if (! set_n)
q_out <= l'bl; II set assignments

else
q_out <= data_in; II d input assignment



62 Verilog and SystemVeriiog Gotchas

Gotcha 28: Blocking assignments in sequential procedural blocks

Gotcha: My shift register sometimes doesa double shift in one clockcycle.

Synopsis: Blockingassignments in sequential logic is syntactically legal, but
usually the wrongfunctionality.

Verilog has two types of assignments: Blocking assignments (e.g. a = b) have the
simulation behavior of hardware combinational logic. Nonblocking assignments
(e.g. q <= d) have the behavior of hardware sequential logic with a clock-to-Q
propagation.

The following example illustrates a very common Verilog coding gotcha. The
example uses a blocking assignment where a nonblocking assignment would
normally be used. The use of blockingassignments in a clockedproceduralblock
is not a syntax error. The example proves that a shift register will not work if a
flip-flop does not have a clock-to-Q delay.

always @(posedge clock) begin II NOT a shift register
ql = d; II GOTCHA! load d into ql without clock-to-Q delay
q2 = ql; II load ql into q2

end

Why does Verilog allow blocking assignments in sequential procedural blocks if
they result in simulation race conditions? For two reasons. One reason is that if
the sequential logic block uses a temporary variable that is assigned and read
within the block, that assignmentneeds to be made with a blockingassignment. A
second reason is the underlyingphilosophyof Verilog that a hardwaredescription
and verification language needs to be able to prove what will work correctly­
and what won't work correctly-in hardware.

In the example above, if ql and q2 were positive edge triggered flip-flops, then
this example would represent a shift register, where d is loaded into flip-flop ql
on a positive edge of c10 ck, and then shifted into q2 on the next positiveedge of
clock. Using simulation, however, it can be proven that this example does not
behave as a shift register. Verilog's blocking assignment to ql "blocks" the
evaluationof the statement that follows it, until the value of ql has been updated.
This means that the value of d passes directly to q2 on the first clock edge, rather
than being shifted through a flip-flop with a clock-to-Qdelay. In other words, the
example has proven that a flip-flop without a clock-to-Q propagation behavior
will not function properly in hardware.

As an aside, the synthesis tool will recognize that ql behaves like a buffer, rather
than a flip-flop. If the value of ql is not used outsideof the proceduralblock, then
synthesiswill remove q 1 from the design, and d will be directly loaded into q2.



Chapter 3: RTL Modeling Gotchas 63

How to avoid this Gotcha

As a general rule,engineers should adopt a modeling stylethat requires theuse of
nonblocking assignments in sequential procedural blocks. Lint tools(coding style
checkers) can help enforce this coding style.

always @(posedge clock) begin II NOT a shift register
ql <= d; II OK, load d into ql with clock-to-Q delay
q2 <= ql; II OK, load previous ql into q2

end

NOTE.' There are exceptions to this rule, where a blocking assignment is needed
within a sequential procedural block. Only by understanding how blocking and
nonblocking assignments work, will engineers know when to correctly make an
exception to the rule. Onesuchexception is shown in Gotcha 29 on page64.



64 Verilog and SystemVerilog Gotchas

Gotcha 29: Sequential logic that requires blocking assignments

Gotcha.· I'm following the recommendations for using nonblocking
assignments in sequential logic, butI still haveraceconditions insimulation.

Synopsis.' When modeling clockdividers, theRTLsynthesis design guidelines
doni always apply.

RTL modeling guidelines recommend that nonblocking assignments should be
used for modeling sequential assignments. In a zero-delay RTL model these
guidelines helpprevent simulation raceconditions. A race condition occurs when
a valueis readat the samemoment in timein which it is changing.

These RTL coding guidelines are intended for modeling data flow and data
manipulation. These RTL guidelines for using nonblocking assignments do not
apply to non-RTL models. When the guidelines are applied to clock generators
such as clock dividers and PLLs, the guidelines may actually cause race
conditions in the generated clocks. The following codeillustrates thisproblem:
always @(posedge elk)

if (!rstn) elk_divided2 <= 0;
else clk_divided2 <= -"'clk_divided2; II GOTCHA!

II delay update to after delta

always @(posedge elk)
if (!rstn) outl <= 0;
else outl <= inl; II delay update to after delta

always @(posedge clk_divided2)
if (!rstn) out2 <= 0;
else out2 <= out1; II race condition with outl

Nonblocking assignments represent the behavior of a flip-flop clock-to-Q delay,
but with zero time. To do this, a nonblocking assignment breaks the assignment
into two steps: first, evaluate the right-hand side expression, and second, after a
delta, update the left-hand side. During the delta, other statements scheduled for
the current simulation time are executed. This two-step process is critical for
preventing read/write raceconditions in zero-delay RTL models.

In the clockdivider example above, however, the nonblocking assignments cause
a racecondition, instead of preventing it. Thebasicsequence of events that occur
are:
1. Advance the simulator clock. If a positive edgeof clock, then:

• Evaluate -clk_divided2 and schedule clk_divided2 to change aftera
zero-delay delta

• Evaluate inl and schedule outl to change aftera zero-delay delta



Chapter 3: RTL Modeling Gotchas 65

2. Aftera zero-delay delta, in any order:
• Update elk_divided2 with its new value. If a positive edge of

elk divided2 occurred:
• Evaluate outl and schedule out2 to change aftera seconddelta.

• Update outl with its new value.
3. If a positive edgeof elk_ divided2 occurred:

• Evaluate outl and schedule out2 to change aftera seconddelta.
4. After the secondzero-delay delta:

• Update out2 with its new value.
5. Advance the simulation timeclock.

The racecondition in this sequence of events is subtle, but real. It occurs in step2,
when elk_divided2 is updated. The update couldcausea positive edge, which
then triggers step 3, to sample outl. But, has outl beenupdatedyet?

The answer is maybe, and maybe not. This is the race condition! The value of
outl is beingsampled at the sametime,and in the samedelta, in whichthe value
is beingupdated. Simulators arepermitted to execute this in a read-then-write or a
write-then-read event order. Gotcha!

How to avoid this Gotcha

To avoid this gotcha, it is necessary to code the clock divider so that out1 will
always be evaluated beforethe deltain which outl willchange. Thiscan be done
a few ways, but perhaps the easiestis to use a blocking assignment for modeling
the clockdivider.
always @(posedge elk)

if (!rstn) clk_divided2 = 0;
else elk_divided2 = ~elk_divided2; II OK, immediate update

Blocking assignments update the left-hand side immediately, without a clock-to­
Q delta. Using a blocking assignment will cause an immediate event on
elk_divided2, which, if a positive edge, will immediately trigger the
sensitivity list of the always @(elk_ divided2) block. Thus, the sampling of
the right-hand side of ou t 1 is guaranteed to occurbeforethe delta in whichau t 1
will change.

This modeling style will synthesize correctly because the clock divider does not
receive anydata inputfromothersources, nor does it sourcedata to otheralways
blocks.



66 Verilog and SystemVeriiog Gotchas

Gotcha30: Nonblocking assignments in combinational logic

Gotcha.· MyRTLsimulation locks upand time stops advancing.

Synopsis.' Nonblocking assignments in a combinational logic blockcancause
infinite loops thatlockupsimulation.

Verilog's nonblocking assignment is intended to model the behavior of sequential
logic clock-to-Q delay. A nonblocking assignment evaluates its right-hand side
expression immediately, and schedules a change on the left-hand side variable
after a clock-to-Q delta within the current moment in time. Any statements
following the nonblocking assignment statement are "not blocked", and will be
executed prior to the delta in the current time. This deltabetween evaluation and
change behaves as a clock-to-Q delay, even in a zero-delay RTL model.

The following example uses nonblocking assignments incorrectly, by placing
themin a combinational logicprocedural block. Theexample canpotentially lock
up simulation in the timestep in which mor n changes value.
always @(m, n) II combinational sensitivity list (no clock edge)

m <= m + ni II GOTCHA! schedules change after clock-to-Q delta

Thealways blocktriggers when eithermor n changes value. Theresult of m + n
is calculated, and the left-hand side of the nonblocking assignment, m, is
scheduled to be updated aftera zero-delay clock-to-Q delta. During this delta, the
nonblocking assignment does not block the execution flow of the procedural
block, and so the blockreturns to its sensitivity list to wait for the nextchange on
mor n. Afterthe clock-to-Q delta, thevalueof mis updated. Thischange willonce
again trigger the sensitivity list, repeating the evaluation and update of m after a
clock-to-Q delta. As long as the result of m + n results in a new value of m,
simulation will be stuck in the current simulation time, continually scheduling
changes to m, and thentriggering on the change. Gotcha!

There are actually two gotchas in the preceding example. One is that simulation
locks up as soon as m or n changes value the first time (assuming n is not 0). The
second gotcha is that this is actually a bad design, that would likely cause
instability when implemented in gates. This second gotcha is an example of the
underlying philosophy of Verilog, which is that engineers should be permitted to
model designs that won't work correctly, in order to analyze the behavior of the
incorrect hardware. In this case, the model represents combinational logic witha
zero-delay feedback path.

Thisexample is not realistic because of the combinational feedback loopwith the
output, m,also in the inputsensitivity list. Theexample was contrived to show the
gotchaof nonblocking assignments in combinational logic in a smallcircuit.



Chapter 3: RTL Modeling Gotchas 67

The following example is basedon code from a real design that can also lock up
simulation-and did-due to the use of nonblocking assignments within
combinational logicblocks.

module chip ( ... )

always @( a or ... ) begin II a combinational process

b <= l'bOi II nonblocking assignment to b

case (statel)
STATE_G: begin

b <= c II nonblocking assignment to b

end

endcase
end

II many lines of code later ...

always @( b or ... ) begin II another combinational process

a <= l'bOi II nonblocking assignment to a

case (state2)
STATE_H: begin

a <= d; II nonblocking assignment to a
end

endcase
end

endmodule: chip

There are three Verilog/SystemVerilog event scheduling rules that are important
to understand in the example above. This book summarizes those rules, and
leaves it to the reader to ponderhow thiscan lead to locking up simulation.
• Events scheduled from parallel procedural blocks (the two always blocks in

the example above) can be scheduled in any order, which means the parallel
events are allowed to be interleaved.

• Events scheduled between begin...end are executed in the order listed in the
sourcecode, including nonblocking assignments.

• In a zero-delay always procedural block, nonblocking assignments do not
update their left-hand side variables until the procedural block has returned to
its sensitivity list at the beginning of the block.



68 Verilog and SystemVeriiog Gotchas

How to avoidthese Gotchas using Verilog

The simulation lock-up problem can be fixed by changing the assignment
statement from nonblocking to blocking, blocking the execution of the rest of the
procedural block until the left-hand side variable has its new value. In the
example below, a blocking assignment ensures that m will have a new, stable
value before the procedural block returns to its sensitivity list, and thus will not
re-trigger the procedural block.

always @(m, n) II combinational sensitivity list (no clock edge)
m = m + nj II OK, immediate update to m with no clock-to-Q delta

Thischange onlyfixes the lock-up in simulation. It doesnot fix the second gotcha
of an RTL model that does not represent goodcombinational logic design. There
are two ways to fix this design problem, depending on whether the intent is to
modela simple combinational logicadderor an accumulator (an adderthat stores
its output, allowing that outputto feedback to the adder input).

How to avoidthese gotchas using System Verilog

SystemVerilog comes to the rescue with specialized always procedural blocks.
The always_comb and always_ff constructs can be used to help avoid this
coding error gotcha. These constructs do more than just document what type of
logic is intended. The always_comb procedural block infers a proper
combinational logic sensitivity list and also enforces somecoding rules that help
ensurepropercombinational logic is modeled. One of theserules is that onlyone
sourcecan write to a variable. In the codem <= m + n;, mis beingused as both
an input and an output of the adder. If any other part of the design also writes a
value to m (as an input to the adder), it is a syntax error. In the context of a full
design, the following codecauses a syntax error, instead of locking up simulation.

always_comb II inferred combinational logic sensitivity list
m <= m + nj II PROBABLE SYNTAX ERROR: no other process can

II write to m

Following is an example error message generated by one simulator when
always_comb is used, and someothersource also generates valuesfor the adder
inputs.
Variable "m" driven by invalid combination of procedural drivers.

Variables written on left-hand of "always_comb" cannot be
written to by any other processes.

If the intent is to model a simple adder, then a blocking assignment should be
used, and the output of the adder should be assigned to a different variable, to
preventthe combinational logic feedback loop. For example:



Chapter 3: RTL Modeling Gotchas 69

always_comb II inferred combinational logic sensitivity list
y = m + n; II immediate update to y with no clock-to-Q delay

If the intent is to model an accumulator with a registered output, then a clock
needs to be specified in the procedural block sensitivity list. The clock edge
controls when the feedback path can change the adder input. The SystemVerilog
always_ff procedural block helps document that the intent is to have clocked
sequential logic.

always_ff @(posedge clk) II sequential sensitivity list with clock
m <= m + n; II scheduled change to m after clock-to-Q delta



70 Verilog and SystemVeriiog Gotchas

Gotcha 31: Combinational logic assignments in the wrong order

Gotcha: Simulation ofmy gate-level combinational logic doesnot match RTL
simulation.

Synopsis: Synthesis might optimize away inferred storage in combinational
logic.

Verilog and SystemVerilog require that the left-hand side of procedural
assignments be variable types. In simulation, variables havestorage, andpreserve
values between assignments. In hardware, combinational logic devices do not
have storage. If the designer's intent is to model combinational logic, then the
RTL model should not rely on the storage of the simulation variables. That is,
when the combinational block is entered, all outputs of the combinational logic
mustbe assigned a value. If a value is not assigned, then the output is relying on
thevariable's storage from a previous assignment.

Generally, a synthesis tool is very good at detecting if a combinational logic
procedural blockis relying on simulation storage. When variable storage is used,
the synthesis tool will add latches to the gate-level implementation to preserve
thatstorage. In the following example, however, synthesis tools do notdetect that
the RTL model is using the storage of thevariables.

module bad_comb_logic (input wire inl,
output reg outl, out2

) ;
always @(inl) begin

out2 = out!; II GOTCHA: out2 is first stores last out! value
out! = in!; II second, out! is updated to new value of in!

end
endmodule

In simulation, variable out2 is assigned the current value of variable outl,
which is the value of in1 stored the previous time the procedural block was
evaluated. After out2 has saved the current value of outl, variable outl is
updated to reflect the new value of input in1. The functionality represented by
thisRTL model is:

iot .......... outt

Stored value of
.......... out2

previous inI



Chapter 3: RTL Modeling Gotchas 71

When this example is synthesized, the following gate-level functionality is
created:

int outl

out2

Simulation of the post-synthesis functionality might not match the RTL
simulation functionality. Some synthesis tools will fail to detect that out2 is
reflecting the storedvalue of outl (which is the previous value of .in l ), and do
not implement the RTL functionality. Gotcha!

How to avoid this Gotcha

This coding example is a bad model. The RTL functionality does not match
combinational logic, latched logic, or sequential logic. The problem is that the
model assigns to the two combinational logic outputs in the wrong order, and
therefore creates a dependency on the variable storage. To correct the problem,
the model should be codedas:

always @(inl) begin
outl = inl; II outl is first updated to new value of inl
out2 = out1; II OK, second out2 gets new value of outl

end



72 Verilog and SystemVeriiog Gotchas

Gotcha 32: Casez/casex masks in case expressions

Gotcha: My casex statement is taking the wrong branch when there is an
errorin the caseexpression.

Synopsis.' Masked bits can be specified on either side of a casez or casex
statement comparison.

Verilog's casez and casex statements allowbits to be maskedout fromthe case
comparisons. With casez, any bits set to Z or ? are masked out (Z and ? are
equivalent). With casex, any bits set to X, Z or ? are masked out. These
constructs concisely model many types of hardware, as well as in verification
code.An example of using the wildcard casex statements is:

always_comb begin
casex (instruction) II potential GOTCHA!

4'bO???: opcode = instruction[2:0]; II only test upper bit
4'blOOO: opcode = 3'bOOl;

II decode other valid instructions
default: begin

$display ("ERROR: invalid instruction!");
opcode 3'bxxx;

end
endcase

end

In the preceding example, the mask bits are set in the first case item, using
4' bO??? The intent is that, if the left-most bit of instruction is 0, the other bits
do not need to be evaluated. After all possible valid instructions have been
decoded, a default branch is used to trap a design problem, should an invalid
instruction occur.

What case branch willbe taken if there is a design problem, and instruction
has the value 4'bxxxx? The intuitive answer is that the default branch will be
taken, and an invalidinstruction will be reported. Gotcha!

The casex and casez statements allow the mask bit to be set on either side of
the comparison. In the preceding example, if instruction has a value of 4 ' bxxxx
or 4' bzzzz, all bits are masked from the comparison, which means the first
branchof the case statement will be executed.

How to avoid this Gotcha using Verilog

A partial solution is to use casez instead of casex. In the example above, if a
casez were used, a design problem that causes an instruction of 4' bxxxx (or
evenjust an X in the left-most bit) will not be masked, and an invalid instruction



Chapter 3: RTL Modeling Gotchas 73

will be reportedby the default branch. However, a designproblemthat causesan
instruction of 4 ' b zz z z (or just a Z in the left-most bit) will still be masked, and
an invalid instruction will not be trapped.

How to avoid this Gotcha usingSystem Verilog

SystemVerilog offers two solutions to this gotcha. The first solution is a special
one-sided, wildcard comparison operator, ==?, which returns true if its two
operands match in value and false if its two operands do not match. There is also
a !=? operator, which negates the true/false test result. This wildcard operator
works similar to casex, in that bits can be masked fromthe comparison usingX,
Z, or ? However, the mask bits can only be set in the left-hand side of the
comparison. In the following example, any X or Z bits in instruction will not
be masked, and the invalidinstruction will be trapped.

if (instruction ==? 4'bO???) opcode = instruction[2:0);
else if ... II decode other valid instructions
else begin

Sdisplay ("ERROR: invalid instruction!");
opcode = 3'bxxx;

end

A secondsolution to the gotchais the SystemVerilog case () inside statement.
This statement allows mask bits to be used in the case items using X, Z or ?, as
with casex. But, case () inside uses a one-way, asymmetric masking for the
comparison. Any X or Z bits in the case expression are not masked. In the
following example, any X or Z bits in instruction will not be masked, and the
invalidinstruction will be trapped:

always_comb begin
case (instruction) inside

4'bO???: opcode = instruction[2:0]; II only test upper bit
4'blOOO: opcode = 3'bOOl;

II decode other valid instructions
default: begin

Sdisplay ("ERROR: invalid instruction!");
opcode 3'bxxx;

end
endcase

end



74 Verilog and SystemVeriiog Gotchas

Gotcha 33: Incomplete decision statements

Gotcha: My full case, parallel_case decision statement simulated as I
expected, but the chipdoes notwork.

Synopsis: Incomplete case statements or if..else decision statements can
result in hard-to-detect design errors.

Verilog's if...else and case statements (including casez and casex) have
somepotential gotchas that can resultin design problems:
• It is legal to have incomplete decision statements, where not all possible

selection values havea corresponding decision branch.
• It is legal to have redundant selection values, where the selection values for

two or moredecision branches are trueat the sametime.
• Simulation evaluates multi-branch decisions in source code order (priority

decoding), but synthesis mightimplement the evaluation as parallel decoding.

Verilog/SystemVerilog synthesis tools can use pragmas, which are commands
hidden in comments, to instruct thesynthesis toolon howto handle incomplete or
redundant case statements. The synthesis full_case pragma instructs synthesis
to ignore any unspecified decision selection values. The parallel_case
pragma instructs synthesis to ignore thepossibility of redundant selection values.

The following example illustrates the RTL logic to decode the next state of a
finite state machine. The statevariable is 3 bits wide, which can have 8 possible
values. Only three of these values are used by the state machine encoding. The
synthesis full_case and parallel_case pragmas are used to instruct
synthesis toolsthat the other5 values are notusedby the design.

logic [2:0] state, nstate; II 3-bit variables (8 possible values)

always @(state) begin II next state decoder
case (state) //synthesis fUll_case -- GOTCHA!

3'b001: nstate 3'b010i
3'b010: nstate 3'blOO;
3'blOO: nstate 3'b001;

endcase
end

Note that this example hard codes the state values to make discussion of the
potential gotchas more obvious. The preferred coding style is to define the state
values as local parameter (if using Verilog) or enumerated types (if using
SystemVerilog). The samegotchas can still exist, but won't be as obvious.



Chapter 3: RTL Modeling Gotchas 75

The example above is an incomplete case statement. There is a decision branch
for only three of the eightpossible values of state. The designer has assumed
that since the state encoding is one-hot, the five possible values that were not
specified willneverhappen. Thisdesign assumption hasbeendocumented for the
synthesiscompilerusinga //synthesis full_case pragma.

What happens if a state value of 2 'bOOO occurs? The synthesis pragma has
instructed synthesis that none of the unspecified values will ever happen.
Therefore the gate-level implementation will most likely not decode the
unspecified values. The logic gates willdo something, but the tool, instead of the
designer, has selected what will happen. In RTL simulation, if a selection value
occurs that doesnot select a branch, thenno assignment statements are executed.
Thevalueof the ns tate variable in this example is not updated, andjust retains
its previous value. Thus RTL simulation will exhibit one behavior if s ta te is
3' bOOO, and the gate-level implementation willdo something different. Gotcha!

A second problem in RTL simulation is that since nstate doesnot change when
an unspecified selection value occurs, it mightnotbe obvious that an unexpected
s ta te value occurred. The design could appear to be working fine in RTL
simulation, when there is actually a problem in the design. Gotcha, again!

How to avoidthis Gotcha in Verilog

With Verilog the only way to avoid this gotcha is to not use the full_case
pragma, and instead explicitly specify what should happen with unexpected
selection values. Thiscanbe done using a defaul t branch in the casestatement.
In thepreceding example, if the default branch assigns a known value to nstate,
the gate-level behavior is well-defined foranyunexpected values of sta teo

case (state)
3'bOOl: nstate 3'bOlO;
3'bOlO: nstate 3'blOO;
3'blOO: nstate 3'b001;
default: nstate = 3'b001; lIon error, go back to first state

endcase

Many Verilog engineers liketo use the default branch to assign a value of X.
default: nstate = 3'bxxx; lIon error, set nstate to unknown

What will happen in the synthesized gate-level implementation if the default
branch assigns a value ofX to nstate? Synthesis treats this assignment the same
as a full_case pragma, meaning the gate-level implementation will do
something, but the designer has given up control of what should happen for
unexpected selection values. The gotcha of a difference between RTL and gate­
level is still there, but the gotcha of not knowing that unexpected state values
occurred in RTLsimulation hasbeenavoided.



76 Verilog and SystemVeriiog Gotchas

How to avoidthis Gotcha in System Verilog

SystemVerilog provides the synthesis optimization advantages of the fUll_case
and parallel_case pragmas, and, at the same time, avoids the gotcha of
undetected functional problems in RTL simulation. This is done using two
decision modifiers, unique andpriority, that can be specified on either case
statements or if...else...if statements.

For synthesis, unique case is the sameas specifying both the full_case and
parallel_case pragmas. A priority case is the same as specifying the
full_case pragma. The gotcha with the synthesis pragmas is that they only
affect synthesis. They are ignored by simulation. The unique and priority
modifiers are both synthesizable and simulatable, enabling verification that the
instructions to the synthesis compiler are correct.

In simulation, the behavior of unique case is:
• A warning is issued if the casestatement is entered and no branch is taken.
• A warning is issued if the case statement is entered and more than one case

selectexpression is true. That is, if morethanonebranch couldbe taken.

In simulation, the behavior ofpriority case is:
• A warning is issued if the casestatement is entered andno branch is taken.

For example:
always @(state) begin II next state decoder

unique case (state)
3'b001: nstate 3'b010;
3'b010: nstate 3'blOO;
3'blOO: nstate 3'b001;

endcase
end

Using unique case allows the designer to verify that the instructions on howto
synthesize the casestatement arecorrect. Therun-time checking canbe combined
with SystemVerilog's constrained random test generation andfunctional coverage
to prove that unexpected values truly cannot occur, or to warn if they do occur.
Formal verification can also use the unique decision modifier to prove, or
disprove, the designer's assumptions about the decision statement.

WARNING! All design guidelines for the proper use of full_case and
parallel_case still apply with unique case and priority case. That is,
thesedecision modifiers can be abused, just as the pragmas canbe abused.

Additional examples of usingunique case andpriority case are shown in
Gotcha 34 on page77 and Gotcha 35 on page79.



Chapter 3: RTL Modeling Gotchas 77

Gotcha 34: Overlapped decision statements

Gotcha.· Oneofmy decision branches nevergets executed.

Synopsis.' Redundant decision selection values can go undetected in
simulation.

Verilog evaluates a seriesof if...else...if...else decisions in the orderin which
the decisions are listed. If a coding error is made, such that two decisions could
bothevaluate as true, thenonlythe firstbranch is executed.

always @* begin
if (sel == 2'bOO) Y = ai

else if (sel == 2'bOl) y = bi
else if (sel == 2'bOl) Y = Ci II GOTCHA! same sel value
else if (sel == 2'bll) Y = di

end

The coding error in this example-probably a cut-and-paste error-is not a
syntax error. The code will compile and simulate, but the thirdbranch will never
execute. Since it is not a syntax error, the coding error can go undetected in
simulation. Gotcha!

A similar cut-and-paste errorcanbe made in case statements. An overlap in case
decisions is not an error. Instead, onlythe firstmatching casebranch is executed.

always @* begin
case (sel)

2'bOO: y = ai

2'bOl: y = bi
2'bOl: y = Ci II GOTCHA! same sel value as previous line
2'bl1: y = di

endcase
end

How to avoid this Gotcha using Verilog

Both of the above examples are easyerrors to make, andcan be difficult to detect
in Verilog simulation. Software tools such as lint tools (coding style checkers)
and synthesis tools will warn about the overlap in decisions in the preceding
examples. However, sinceit is onlya warning message, it may go unnoticed.

How to avoid this Gotcha usingSystem Verilog

SystemVerilog addsa unique modifier thatcanbe usedwithboth if...else...if
and case decision statements.



78 Verilog and SystemVeriiog Gotchas

always_comb begin
unique if {sal 2'bOO} Y = ai

else if (sel == 2'bOl) y = bi II will get simulation warning
else if (8el == 2'bOl) Y Ci II will get simulation warning
else if {sel 2'bll) y = di

end

always_comb begin
unique case {sel}

2'bOO: y ai
2'bOl: y bi II will get simulation warning
2'bOl: y Ci II will get simulation warning
2'bll: y di

endcase
end

Theunique decision modifier requires thatsimulators report a warning if twoor
more decision selection expressions are true at the same time. The unique
modifier alsorequires that simulation generate a warning message if no decision
branch is taken. Do not ignore the simulation warnings generated by using
unique-the warnings indicate there is a coding problem!

Additional examples of using unique case are shown in Gotcha 33 on page 74
andGotcha 35 onpage79.



Chapter 3: RTL Modeling Gotchas 79

Gotcha 35: Inappropriate use of unique case statements

Gotcha: I am using unique case everywhere to help trap design bugs but my
synthesis results arenotwhatI expected

Synopsis: Systemverilog's unique case synthesizes the same as a case
statement tagged with full_case andpriority_case.

SystemVerilog extends the Verilog language with a unique decision modifier
keyword. This modifier can be specified on either case statements or
if...else...if statements. The unique modifier specifies that a decision
statement should be considered complete, and that there is no overlap in the
decision selection values.

Many coding methodologies today are recommending that unique be specified
for all case statements, just as the synthesis full_case pragma was
recommended for all casestatements a few years ago. The reason unique case
is recommended is that it comes with built-in assertions that provide visibility
during RTL simulation, indicating when a case statement did not execute as
expected. Design problems can potentially become visible earlier in the design
cycle.

Thiscoding guideline ofusing unique case forall casestatements is a Gotcha!

The intent in the following example is to have a simple decoder that sets the
rdata flag if address is zero.
module address decocde (input logic [1:0] address,

output logic rdata);

always_comb begin
rdata = l'bO; II default value for rdata
unique case (address) II decode address -- GOTCHA!

2'bOO : rdata = l'bI;
endcase

end
endmodule

The example may look overly simple, but it comes from a real design, and is a
real gotcha! Thesimulation results wereas expected; when address is 0, rdata
is 1; for any other value of address, rdata is O. Here's what a synthesis tool
sees from thismodel:

VDD1__~ Gotcha!

{ .. rdata



80 Verilog and SystemVeriiog Gotchas

By specifying unique case, the designer has informed synthesis that all
unspecified caseselection values should be considered a "don't care", andcanbe
ignored. Since the designer has indicated that only the selection values listed are
real, and that no othervalues can occur, the default assignments for these other
selection values do not have meaning. They are assigning a default output for
conditions that unique case says can never happen. Therefore, synthesis
ignores the default assignments! Gotcha!

How to avoid this Gotcha

To avoid this gotcha do not ignore simulation warnings! The unique case
statement will issue a run-time warning anytime no branch is taken. In the
example above, however, it was easy to look at the code and come to the
conclusion that the warnings were bogus and could be ignored. Yes, there are
times whenno casebranch would be taken, but the default assignment before the
case statement takes care of those situations. In truth, the simulation warnings
also indicated that the case statement was not evaluating the way synthesis had
been instructed to interpret it. The warnings from unique case should not be
ignored!

The real problem in the example above is not understanding the purpose of the
unique decision qualifier. Thepurpose of unique is to inform tools thatnot all
of the possible selection values of a decision are being used, because the values
are not used in the design. In the example above, the decoder actually does
decode every value of address. An address of zero sets rdata, and all other
addresses clear rdatal It is incorrect to use unique case in this design, as
evidenced in the synthesis results.

The correction for the example above is simple. Do not use the unique decision
qualifier.

module address decocde (input logic [1:0] address,
output logic rdata);

always_comb begin
rdata = l'bO; II default value for rdata
case (address) II OK, incomplete case statement

2'bOO : rdata l'b1; II decodes exception to default
endcase

end
endmodule

This is not to say unique case should never be used. It is to say that
unique case should be used correctly, just like the synthesis full case
pragma needs to be usedwisely andcorrectly.



Chapter 3: RTL Modeling Gotchas 81

A few years ago, many companies followed a coding guideline that all case
statements should be specified with the synthesis full_case pragma, so that
they would synthesize more optimally. In the past few years, there have been
several conference papers showing why blanket usage of the synthesis
full_case pragma can be bad for a design. Experience has proven that
specifying full_case should be the exception, ratherthan the general rule. The
indiscriminate use of the full_case pragma is nowstrongly discouraged.

SystemVerilog's unique case does not change this guideline. Synthesis tools
treat unique case as if the case statement has both the full_case and
parallel_case pragmas specified. The only difference between the synthesis
pragmas and unique case is thatunique case can alsobe simulated. That is,
however, an important difference, as illustrated in the nextparagraph.

When unique case is used correctly, it has significant advantages over the
synthesis full_case pragma. An example of an appropriate place to use
unique case is in a one-hot state machine decoder, where only certain state
values are valid. The other values should never occur. In that situation,
unique case is appropriate. It instructs synthesis that the unused values of the
state variable are "don't cares", and need not be implemented in the gate-level
design. At the sametime, theunique case instructs simulation to assert that the
unused state values never occur. SystemVerilog's constrained random test
generation, coupled with SystemVerilog's functional coverage, can be used to
thoroughly exercise the design to verify that the unused state values truly cannot
occur. Formal verification tools can also use the unique decision modifier to
guide whatneeds to be formally proven.

Gotcha 33 on page 74 describes the simulation semantics of unique case.
Gotcha 34 on page77 illustrates another appropriate use unique case.

Note.' The SystemVerilog priority case statement has the same gotcha.
Synthesis tools treat priority case the same as if the synthesis full_case
pragma had been specified. Careneeds to be taken to onlyuse priority case
where it is appropriate, which is when not all decision selection values are used,
and it is permissible to have an overlap in the selection values for each decision
branch.



82 Verilog and SystemVeriiog Gotchas

Gotcha 36: Resetting 2-state models

Gotcha: Mydesign fails to reset thefirst time inRTLsimulation.

Synopsis: Two-state data types begin with a known value, andmight notcause
simulation events thefirst timea value is assigned.

One of the features of SystemVerilog is 2-state data types, which, in theory, can
be advantageous in simulation. However, 2-state types alsohavesomesimulation
gotchas. One of these gotchas is that, at the beginning of simulation (timezero),
the value of each variable is a default uninitialized value, which is X for 4-state
variables andzerofor 2-state variables. Theuninitialized 2-state value of zerocan
lead to a resetgotcha. Consider the following code:

module chip_tb;
logic elk; II 4-state type
bit rst_n; II GOTCHA! 2-state type for reset

initial begin II clock oscillator
elk <= 0;
forever #5ns elk = -elk;

end

initial begin II reset stimulus (active low reset)
rst_n <= 0; II turn on reset at t~e zero
,3ns rst_n = 1; II turn off reset after 3 nanoseconds

end

chip ul(.rst_n, .clk, ... ); II instance of design under test

endmodule: chip_tb

module chip (input bit rst_n, elk, ... ); II GOTCHA! 2-state types

enum {HOLD, LOAD, STORE} state_e, nstate_e; II GOTCHA! 2-state

always_ff @(posedge clk, negedge rst_n) II asynchronous reset
if (!rst_n) state_e <= HOLD;
else state e <= nstate_e;

endmodule: chip

In the example above, the always_ff flip-flop in module chip is supposed to
reset on a negative edge of r s t _ n. The testbench sets r s t _ n to zero at the
beginning of simulation, and holds it low for 3 nanoseconds. However, in the
testbench, r s t _ n is a 2-state type, which begins simulation with a value of zero.
Setting r s t _ n to zero does not change its value, and therefore does not cause a



Chapter 3: RTL Modeling Gotchas 83

negative edge on r s t _ n. Since the testbench does not cause a negative edge on
rst_n, the always_ff sensitivity list for the flip-flop in module chip does not
trigger, and the flip-flop doesnot resetasynchronously. If r s t _ n wereheldlowat
least one clock cycle, the flip-flop would reset synchronously when clock
occurred. In this example, though, the test stimulus does not hold r s t _ n low a
full clockcycle, and therefore the reset is completely missed. Gotcha!

Howto avoidthis Gotcha

This gotcha can be avoided in a number of ways. One way is to initialize the 2­
state reset signal to the non-reset value with a blocking assignment, and then to
the reset value with a nonblocking assignment. This will trigger the always_ff
blocks waiting for a negative edge of reset. Additionally, the nonblocking
assignment will ensure that all the always_ff blocks are active before the
transition to zero occurs.

initial begin
rst_n = 1; II initialize to inactive value
rst_n <= 0; II set to active value using nonblocking assign
#3ns rst_n = 1;

Note, however, that this solution potentially creates a newgotcha! Changing any
signal at time zero using a blocking assignment can potentially cause a race
condition with any procedural blocks that trigger on that signal. This is because
the order in whichprocedural blocks become active at timezero is not defined, so
the change in value could occur before other procedural blocks have activated
their sensitivity lists. Since rst_n is an active low reset, there is little or no risk
of a race condition by setting it to a logic 1, the inactive state, at timezero.

A second wayto avoidthis gotcha is to use in-line variable initialization to assign
r s t _ n to its inactive value at the same time r s t _ n is declared. Then, when the
test program assigns r s t _ n to 0, a change will occur which will trigger the
always_ ff sensitivity list.

bit rst n = 1 II initialize to inactive value
initial begin

rst_n <= 0; II set to active value using nonblocking assign
#3ns rst_n = 1;

A third way to fix this gotcha is to use 4-state types instead of 2-state types for
active-low signals. 4-state variable types will beginsimulation witha value of X.
Assigning a 4-state type a value of zero, even at simulation time zero,will cause
an X-to-O transition, which is a negative edge.



84 Verilog and SystemVeriiog Gotchas

Gotcha 37: Locked state machines modeled with enumerated types

Gotcha: Mystate machine modellocks up in its start-up state.

Synopsis: Two-state enumerated variables begin with a known value, and
mightnot causesimulation events thefirst timea value is assigned.

By default, enumerated types are 2-state types. Also by default, the value of the
first label in an enumerated list is zero. Functional logic based on 2-state
enumerated data typescan havegotchas. Consider the following code:

module controller (output logic read, write,
input instr t instruction,
input logic clock, reset_n);

enum {HOLD, LOAD, STORE} state_e, nstate_e; II 2-state types

always @(posedge clock, negedge reset_n) II state sequencer
if (!reset_n) state_e <= HOLD;
else state_e <= nstate_e;

always @(state_e) begin II GOTCHA! next state decoder
unique case (state_e)

HOLD: nstate_e LOAD;
LOAD: nstate_e STORE;
STORE: nstate e HOLD;

endcase
end

endmodule

In simulation, this example will lock up in the HOLD state. Applying reset,
whether 2-stateor 4-state, will not get the state machine out of this lock up. This
is because state- e and nstate e are 2-state enumerated variables. 2-state

-
types begin simulation with a value of zero, which is the value of HOLD in the
enumerated list. When the always_ff state sequencer is reset, it will assign
s ta te_ e the value of HOLD, which is the same value as the current value of
state_e, and thus doesnot causea transition on state_e. Since state_e does
not change, the always @(state_e) combinational procedural block does not
trigger. Sincethe combinational blockis not entered, ns ta te_ e is not updated to
a new value, and retains its initial value of HOLD. On a positive edge of clock,
state_e is assigned the value of nstate_e, but, since the two variables have
the same value of HOLD, state_e does not change,. Once again, the
always @(state_e) combinational block is not triggered and nstate_e is not
updated. The simulation is stuck in the start-up state, no matterhow manyclock
cyclesare run, and no matterhow manytimes the statemachine is reset. Gotcha!



Chapter 3: RTL Modeling Gotchas 85

How to avoidthis Gotcha

The best way to avoid this gotcha is to use the SystemVerilog always_comb for
the combinational block in this code. Unlike the Verilog always procedural
block,an always_comb procedural blockwill automatically execute onceat time
zero, even if the sensitivity list wasnot triggered. Whenthe always_comb block
executes, nstate_e will be assigned the correctvalueof LOAD. Then, after reset
is removed, the statemachine will function correctly, and not be lockedin a HOLD
state.

A secondmethod to avoid this gotcha is to declare the state_e and nstate_e
enumerated variables as 4-statetypes, as follows:

II 4-state types
enum logic [1:0] {HOLD, LOAD, STORE} state_e, nstate_e;

By doing this, s ta te_e and ns ta te_e will begin simulation with the value of
X. When state_e is assigned HOLD during reset, the always @(state_e) will
trigger, settingns ta te_e to LOAD.

A third way to fix this 2-state lock-up gotchais to explicitly assign values to the
HOLD, LOAD and READY labels thatare different fromtheuninitialized valueof the
enumerated variables. For example:

enum bit [2:0] {HOLD = 3'b001,
LOAD = 3'b010,
STORE = 3'b100} state_e, nstate_e;

In this example, s ta te_ e and ns ta te_ e are 2-state types, which begin
simulation with an uninitialized valueof zero. This value does not match any of
the values in the enumerated list. When reset is applied, s tat e_ e will be
assigned HOLD. The change on state_e will trigger the always @(state_e)
combinational block,whichwill update nstate_e to LOAD, preventing the lock­
up gotcha.



86 Verilog and SystemVeriiog Gotchas

Gotcha 38: Hidden design problems with 4-state logic

Gotcha: There was a problemdeep inside the logic ofmy design, but it never
propagatedto moduleboundaries.

Synopsis.' Someprogramming statements do notpropagate logicX values.

In 4-statesimulation, a logicvalueof X can occur. Logic X is not a real hardware
logicvalue. Nor is it a "don't care", the way it used in somedata books. Logic X
is the simulator's way of saying that simulation algorithms cannot predictwhat
actual hardware would do with a given set of circumstances. While no engineer
likes to see X values in the simulation log files or waveform displays, savvy
engineers have come to know that X is their friend. Whenan X valuedoes show
up, it is a clear indication of a problem in a design.

But there is a gotcha. A number of Verilog programming statements can swallow
an X value, and generate a seemingly good value. These statements hide design
problems, whichcan be disastrous. Two of the most common X hidingconstructs
are decisions statements and optimistic operators. An example of a decision
statement that willhide design errorsis:

always_comb begin
if ( sel) y = a; II 2-to-l MUX
else y = b;

end

In this example, should a design bug cause sel to have a logic X, the else
branch will be taken, and a valid value assigned to y. If the verification code is
primarily verifying the functional results of the design, it will only see known
values on this multiplexer output. The design bug on the sel signal has been
hidden. Gotcha!

How to avoid this Gotcha using Verilog

The ideal would be if each model had internal code to trap errors within the
model. Functional verification of the design could focus on verifying the overall
functionality, and each design block would take care of detecting unexpected
valueswithinthat block.

In Verilog, adding self-checking logic within the model can be awkward and
require many extra lines of code. This extra code must be hidden from synthesis
tools, as it is not really part of the hardware. There is also a risk that the extra
code could inadvertently change the intended behavior of the design. Because of
the extra coding and associated risks, design engineers are often hesitant to add
error-monitoring codewithinRTL models. Consider the following:



Chapter 3: RTL Modeling Gotchas 87

always_comb begin
if (sel)

y = ai II do true statements
else

Ilsynthesis translate_off
if (!sel) II opposite of if condition)

Ilsynthesis translate_on
y = bi II do the not true statements

//synthesis translate_off
else begin

y = 'bXi
$display("if condition tested either an X or Z")i

end
/Isynthesis translate_on
end

This additional code illustrates the awkwardness of embedding error handling in
RTL models using Verilog, Few, if any design engineers are willing to do this.

How to avoid this Gotcha using SystemVerilog

A better way to avoid this gotcha is to use SystemVerilog Assertions (SVA).
Assertions are more concise, and do not need to be hidden from synthesis tools.
Assertions can be turnedon and off as needed. Theycan also provide verification
coverage information. An assertion for the example above can be written as:
always_comb begin

assert ($isunknown(sel» else $error("sel = XU)i
if ( sel) y = ai II 2-to-l MUX
else y = b;

end

This example uses an immediate assertion, which will execute every time the
always blockis entered. Falseassertion failures couldbe reported if se I glitches,
but becomes stable before the MUX output is used. To avoid executing the
assertion on glitches, synchronous concurrent assertion can be used.

For more details on X hiding gotchas and using assertions, refer to two papers
from the authors, "BeingAssertive With Your X' 1, and "System Verilog Assertions
are/or DesignEngineers, too,,2.

1. Being Assertive With Your X, by Don Mills. Published in the proceedings of
SNUG San Jose, 2004. Also available from the author's web site, http://
www.lcdm-eng.comlassertiveX.pdf.

2. SystemVerilog Assertions arefor Design Engineers, Too, by DonMillsandStu­
art Sutherland. Published in the proceedings of SNUG San Jose, 2006. Also
available fromthe author's website,http://www.sutherland.com/papers.html.



88 Verilog and SystemVeriiog Gotchas

Gotcha 39: Hidden design problems using 2-state types

Gotcha: Some majorfunctional bugs in my design did not show up untilafter
synthesis, whenI rangate-level simulations.

Synopsis: Designerrors mightnotpropagate through 2-statelogic.

An important gotcha to be aware of when modeling with 2-state data types,
whether at the RTL levelor at the verification level, is the fact that 2-state types
begin simulation with a valueof 0 instead of X. It is common for a value of 0 to
also be the reset value of registers within a design. Consider the following
example:

bit [31:0] data_reg; II 2-state variable

always_ff @(posedge clock, negedge reset_n) II data register
if (!reset_n) data_reg <= 0; II reset to zero
else data_reg <= data_in;

The initial valueof data_ reg is zero. This is also the valueto which da ta_ reg
is reset. This means that, if for some reason the design fails to generate a reset, it
will not be obvious by looking at the valueof data_ reg that therewas a failure
in the design logic.

Another way in which 2-state logic can hide design errors is when an operation
returns a logic X, as illustrated below:

module comparator (output bit eq, II 2-state output
input bit a, b); II 2-state inputs

assign eq = (a == b);

endmodule

In the example above, the gotcha is the2-state inputs. Whatwillhappen if thereis
a design error, andeitherthe a or b inputis leftunconnected? With 4-state values,
the unconnected input would float at high-impedance, and the (a == b)
operation will return a logic X-an obvious design failure. With 2-state inputs,
however, there is no high-impedance to represent a floating input. The design
error will result in zero on the input, and an output of one or zero. The design
failure has been hidden, and did not propagate to an obvious incorrect result.
Gotcha!

What if the inputs and outputs in the preceding example were 4-state, but the
outputwas connected to another design block, perhaps an IP model written by a
third party provider, that was modeled using 2-state types? In this case, the



Chapter 3: RTL Modeling Gotchas 89

comparator module would output a logic X, due to the unconnected inputdesign
failure, but that X would be converted to a zero as it propagates into the 2-state
model, onceagain hiding the design problem. Gotcha, again!

How to avoid this Gotcha

The best way to avoid this gotcha is to use 4-state types in all design blocks. 4­
statevariables begin simulation witha value of X, making it veryobvious if reset
did not occur. Should an operation or programming statement produce a logic X,
the use of 4-state types will propagate the design error instead of hiding it. In
addition to using 4-state types, SystemVerilog assertions can be used to verify
that inputs to eachdesign block arevalid. SystemVerilog functional coverage can
alsobe usedto verifythat reset occurs during simulation.

CAUTION! 4-state types can also hide design problems, but in different ways.
SeeGotcha 38 on page86 formore details.



90 Verilog and SystemVerllog Gotchas

Gotcha 40: Hidden problems with out-or-bounds array access

Gotcha: A design bugcausedreferences to nonexistent memory addresses, but
there was no indication ofa problem in RTLsimulation.

Synopsis: Out-of-bounds errors mightnotpropagate through 2-state logic.

A type of failure that can be hidden by 2-state types is when an out-of-bounds
address is read froman array. An example wherethis can occur follows:

module RAM # (parameter SIZE = 1024, A_WIDTH = 16, D_WIDTH = 31)
(output logic [D_WIDTH-1:0] data_out,
input logic [D_WIDTH-1:0] data_in,
input logic [A_WIDTH-1:0] addr, II 16 bit bus
input logic read, write);

bit [D_WIDTH-1:0] mem_array [0:SIZE-1]; II 2-state array
II GOTCHA! only need 10 bit index

assign data out = read? mem_array[addr] : 'z; II read from array

endmodule

In this example, the address bus is widerthan is required to accessall addresses of
mem_ar ray. If a 4-state array is accessed using an address that does not exist, a
logic X is returned. But, when a 2-state array is accessed using an address that
does not exist, a value of zero is returned. Sincea value of zero couldbe a valid
value, the out-of-bounds readerrorhas been hidden. Gotcha!

The example aboveis an obvious design error, but is also one that couldeasily be
inadvertently coded. The same error is less obvious when the defaults of the
memory size and address bus parameters are correct, but an error is made when
redefining the parameter values for an instance of the RAM. Gotcha, again!

How to avoid this Gotcha

There are a few ways to avoid this gotcha. One way is to use 4-state types for
arrays. An out-of-bounds reference to a 4-state array will return a logic X,
indicating thata design problem occurred. However, a 4-statearrayrequires twice
the amount of simulation storage as a 2-state array. It can be advantageous to use
2-statearraysto model largememories.

Another way to avoidthis gotcha is to use SystemVerilog assertions to verifythat
the redefined values of parameters cannotresult in an out-of-bounds access. The
assertions only need to execute onceat time zero.



Chapter 3: RTL Modeling Gotchas 91

A third way, and a preferred modeling style, can be used when the values of
constants are related, such as the SIZE, D_WIDTH and A_WIDTH constants in the
preceding example. In thiscase, thevalue of oneconstant canbe calculated based
on the value of another constant.

module RAM # (parameter A_~DTH = 16,
SIZE = 1<<A_WIDTH,
D_WIDTH = $clog2(SIZE)

(output logic [D_WIDTH-l:O] data_out,
input logic [D_WIDTH-l:O] data_in,
input logic [A_WIDTH-l:O] addr,
input logic read, write);

This solution reduces, but does not completely avoid the gotcha of incorrect
parameter sizes. The calculated constant values will be correct, but, since the
constants are a parameter type, they could be overridden using parameter
redefinition andendup withincorrect values.

To completely avoid the gotcha of incorrect parameter sizes, the calculated
constant should be declared as a localparam. A localparam constant cannot
be redefined, ensuring that the calculated value cannot be overridden. It is not
legal to declare localparam constants in the module declaration parameter list,
however. Touse localparam values in port declarations, the olderVerilog-1995
styleof module declarations mustbe used. For example:

module RAM (data_out, data_in, addr, read, write);
parameter A_WIDTH = 16;
localparam SIZE = l<<A_~DTH,

D_WIDTH = $clog2(SIZE)
output logic [D_WIDTH-l:0] data_out;
input logic [D_WIDTH-l:0] data_in;
input logic [A_WIDTH-l:0] addr;
input logic read, write);

(Note: the $clog2 function used in the example above wasadded in the Verilog­
2005 standard. Prior to 2005, this function had to be written by the designer,
usingeithera recursive Verilog function or using the Verilog PLI.)



92 Verilog and SystemVeriiog Gotchas

Gotcha 41: Out-or-bounds assignments to enumerated types

Gotcha: My enumerated state machine variables have values that don't exist
in the enumerated definition.

Synopsis: Enumerated typesarestrongly typed, butcanstill have values other
thanthose in theirenumerated list.

Verilog is a loosely typedlanguage. Anydatatypecanbe assigned to a variable of
a different type without an error or warning. Unlike Verilog, the SystemVerilog
enumerated type is, in theory, a strongly typedvariable. Part of the definition of
an enumerated type variable is the legal set of values for that variable. For
example:

typedef enum bit [2:0] {HOLD = 3'bOOl, II 2-state type
LOAD = 3'bOlO,
STORE = 3'blOO} states_t;

states_t state_e, nstate_e; II two enumerated variables

A surprising gotcha is that an enumerated type variable can have values that are
outside of the defined set of values.

Thereare two parts to this gotcha of out-of-bounds enumerated values, which are
.explained in more detail, below.

Part One: Unitialized enumerated variables

As with all static Verilog and SystemVerilog variables, enumerated variables
begin simulation with a default value. For enumerated variables, this default is
the uninitialized value of its base data type. In the preceding example, the base
data type of state_e is a 2-state bit type, which begins simulation with an
uninitialized value of zero. Thisvalue is not in the variable's enumerated list, and
is, therefore, out-of-bounds. Gotcha!

How to avoid this Gotcha

In actuality, this gotcha can be a desirable feature of the language. If the
uninitialized enumerated variable value is out-of-bounds, it is a clear indication
that the design has not beenproperly reset. This is evenmore obvious if the base
data type is a 4-statetype, which has an uninitialized value of X.

Part Two: Using casting withenumerated variables

SystemVerilog requires thatanyprocedural assignment to an enumerated variable
be in the enumerated list, or from another variable of the same enumerated type.



Chapter 3: RTL Modeling Gotchas 93

The following examples illustrate legal and illegal assignments to s ta te_e.

nstate e LOAD; II legal assignment
nstate e state_e; II legal assignment
nstate e 5; II illegal (not an enum label)
nstate e 3'bOOl; II illegal (not an enum label)
nstate estate e + 1; II illegal (not an enum label)

SystemVerilogallows a normally illegal assignment to be made to an enumerated
variable usingcasting. For example:
nstate_e = states_t' (state_e + 1); II legal, but GOTCHA!

When a value is cast to an enumerated type, the value is forced into the variable
without any type checking. In the example above, if s ta te_e had the value of
HOLD (3' b001), then state_e + 1 would result in the value of 3' bOlO. This
can be forced into the nstate_e variable using casting. As it happens, thisvalue
matches the value of LOAD. If, however, s tate_e had the value of LOAD, then
s ta te e + 1 would result in the value of 3' bO11. When this value is forced
intothe enumerated variable ns tate_e, it doesnotmatch anyof the enumerated
labels. Thenstate e variable nowhas an out-of-bounds value. Gotcha!

Howto avoidthis Gotcha

There are two waysto avoid this gotcha. Instead of using the static cast operator,
the SystemVerilog dynamic $cast function can be used. Dynamic casting
performs run-time error checking, and will not assign an out-of-bounds value to
an enumerated variable. Thegeneral syntax of the $cast function is:

success_flag = $cast(target_variable, expression)

The $cas t function converts the expression to the type of the target variable. If
the expression is a legal value for the target variable, $cast returns 1 andmakes
the assignment. If the value of the expression is not legal, $cast returns 0 and
leaves the target variable unchanged. The return value of $cast can be tested
withan assertion.

assert(nstate_e, state_e+l); II increment to next label in list
else nstate_e = LOAD;

SystemVerilog enumerated types have several built-in methods which can
manipulate the values of enumerated variables, and, at the sametime, ensure the
variable never goes out-of-bounds. For example, the .next () method will
increment an enumerated variable to the next label in the enumerated list, rather
thanincrementing by the value of 1.If the enumerated variable is at the last label
in the enumerated list, .next () willwrap around to the first label in the list. An
example of using the .next () method is:

nstate e state_e.next(l); II increment to next label in list



94 Verilog and SystemVeriiog Gotchas

Gotcha 42: Undetected shared variables in modules

Gotcha.· My RTL model output changes values when it shouldn t, and to
unexpected values.

Synopsis: Variables written to by multiple processes create sharedresource
conflicts.

Syntactically, Verilog and SystemVerilog variables declared at the module level
can be read or written by any number of initial or always procedural blocks
within the module. Reading a variable from multiple procedural blocks is fine,
andprovides a wayforparallel processes to passvalues between themselves. But,
there is a gotcha whentwo or moreprocedural blocks write to the same variable.
The effect is that the samepieceof storage is shared by all the procedural blocks.
Since theseprocedural blocks run concurrently, it is possible, and likely, that the
codewithin the blocks will collide, and interfere witheachother's functionality.

The following example shows a common-and perhaps not obvious in large
models-Verilog/SystemVeriIog gotcha, where the variable result is shared by
two concurrent always procedural blocks.

module chip (output logic [31:0] result, II local variable
input logic [31:0] a, b, c, d);

always @(a or b)
result = a 'b; II this process writes to result

II dozens of lines of code later ...

always @(c or d)
result = c I d; II GOTCHA: this process also writes to result

endmodule

How to avoidthis Gotcha using Verilog

Verilog does not restrict how variables are used, which provides versatility in
writing test programs andabstract bus functional models. In an RTL model that is
intended to be synthesized, such as the example above, however, this versatility
becomes a go/chat When using Verilog without the SystemVerilog extensions, the
only way to avoid this gotcha is to use software tools such as lint tools (coding
stylecheckers) to checkfor multiple processes writing to the samevariable.

A betterway to avoid this gotcha is to use SystemVerilog, which enforces proper
RTL coding rules, as shown in the following explanation.



Chapter 3: RTL Modeling Gotchas 95

How to avoid this Gotcha usingSystem Verilog

For RTL models, a simple way to avoid this gotcha is to use SystemVerilog's
always_comb, always_ff, always_latch, and continuous assign to assign
values to a variable. Theseprocesses make it illegal for a variable to be written to
by multiple processes. If the code is for verification or an abstract bus functional
model, the way to avoid this gotcha is to use SystemVerilog's inter-process
synchronization (event triggers, semaphores or mailboxes) to prevent concurrent
processes fromwriting to the samevariable at the sametime.

Gotcha 43 on page 96 and discusses similar problems with shared variables in
interfaces, packages, tasksand functions.

Gotcha 66 on page 145 illustrates another common gotcha with shared variables
used in for loops.

Gotcha 76 on page 160shows somegotchas with shared variables in verification
code.



96 Verilog and SystemVerllog Gotchas

Gotcha 43: Undetected shared variables in interfaces and packages

Gotcha.· Variables in mypackage keep changing at unexpected times and to
unexpected values.

Synopsis.' Interface, package and global variables written to by multiple
design and/or verification blocks create shared resource conflicts.

SystemVerilog compounds the Verilog shared variable gotcha described in
Gotcha 42 on page 94 by providing more places where shared variables can be
declared (or obfuscated). In SystemVerilog, variables can be declared in external
spaces outside of a module. These external declaration spaces are user-defined
packages, $uni t (a type of built-in package), and interfaces. These externally
declared variables can thenbe referenced by multiple modules, creating a shared
variable.

Multiple initial and always procedural blocks that write to shared variables
will likely interfere with each other. These procedural blocks can be in different
design and verification blocks, which are generally in different files. This can
make it verydifficult to find anddebug shared variable conflicts. Gotcha!

package sig_defs;
logic [31:0] result, pipe;

endpackage

module blk1 (output logic [31:0] d_out,
input logic [31:0] a, b,
input logic clk, rstn);

import sig_defs::*;

always @*
result = a , h; II GOTCHA! shared variable

always @(posedge clk or negedge rstn)
if (!rstn) begin

pipe <=0;
d_out <=0;

end
else begin

pipe <= result; II GOTCHA! shared variables
d_out <= pipe;

end
endmodule



Chapter 3: RTL Modeling Gotchas 97

module blk2 (output logic [31:0] d_out,
input logic [31:0J c, d,
input logic clk, rstn);

import sig_defs::*;

always @*
result = a I hi II GOTCHA! shared variable

always @(posedge clk or negedge rstn)
if (!rstn) begin

pipe <=0;
d_out <=0;

end
else begin

pipe <= result; II GOTCHA! shared variables
d_out <= pipe;

end
endmodule

How to avoidthis Gotcha

Shared variables are generally not synthesizable, and should not be used in RTL
models. They can easily be avoided by using SystemVerilog's always_comb,
a lways_ff, always_latch, and continuous assign to assign values to
variables. With theseprocesses, it is illegal for a variable to be written to by more
than one process, even when theseprocesses are in different modules, interfaces
or test programs.
module blk1 ( ... );

import sig_defs::*;

always_comb
result = a , b; II ERROR! multiple processes write to result

endmodule

module blk2 ( ... );

import sig_defs::*;

always_comb
result = a I b; II ERROR! multiple processes write to result

endmodule

Shared variables can be useful in verification code, but care must be taken to
avoid conflicts between processes sharing the same storage. This can be
accomplished through the use of process synchronization, such as eventtriggers,
semaphores or mailboxes.



Chapter 4
Operator Gotchas

Gotcha44: Assignments in expressions

Gotcha: I need to do an assignment as part ofan if condition, but cannot get
my codeto compile.

Synopsis: System Verilog allows assignments within expressions, with the
same gotchas as C, but System Verilog ssyntax is different from C, confusing
programmers familiarwith C.

In Verilog, assignments are not allowed within an expression. Therefore, the
common C gotcha of if (a=b) is illegal. Unfortunately, this also means the
useful application of an assignment within an expression is also illegal, such as:
while (data = fscanf ( ... ) ....

SystemVerilog extends Verilog, and adds the ability to make an assignment
within an expression. Thus, with SystemVerilog, the intentional usage of this
capability, such as to exit a loop on zero, is legal. SystemVerilog requires that the
assignment be enclosed in parentheses to prevent unintentional uses of this
capability, such as if (a=b). Thus:
if (a=b) ... I I illegal in SystemVerilog

if ( (a=b) ) II legal in SystemVerilog; probably not useful

while (a=b») ... / / legal in SystemVerilog, and can be useful

Ironically, in an effort to prevent the common C gotcha of if (a=b), the
SystemVerilog syntax becomes a gotcha. Speaking from the personal experience
of one of the authors, programmers familiar with C will attempt, more than once,

Note: the code examples in this chapter are contrived in order to illustrate each gotcha using small
examples. In realdesignand verification code,thesegotchas mightnot be as obviousor easy to debug.



100 Verilog and SystemVeriiog Gotchas

to use theC-like syntax, andthenwonder whythe toolis reporting a syntax error.
Is it an errorbecause, likeVerilog, assignments in an expression arenotallowed?
Is theerrorbecause the toolhasnot implemented thecapability? No, it is anerror
because SystemVerilog's syntax is different from C's. Gotcha!

How to avoidthis Gotcha

TheSystemVerilog syntax canhelp prevent the infamous C gotcha of if (a=b).
The gotcha of a different syntax cannot be avoided, however. Engineers must
learn, and remember, thatC and SystemVerilog usea different syntax to make an
assignment within an expression.



Chapter 4: Operator Gotchas 101

Gotcha45: Self-determined versus context-determined operators

Gotcha.· In someoperations, my data is signextended and in otheroperations
it is notsign extended, and inyet otheroperations it is not extended at all.

Synopsis: Some Veri/og and SystemVeri/og operators are context-determined,
otheroperators are self-determined. The type ofoperation determines ifand
howvectors areexpanded.

Whatshould happen if a 4-bitvector is ANDed witha 6-bitvector, and the result
is assigned to an 8-bit vector? Will the results be different if one or both of the
AND operands are signed or unsigned? Does the result change if the vector to
which the operation is assigned is signed or unsigned?

Verilog andSystemVerilog are"loosely typed" languages. Loosely typed doesnot
mean there are no data typerules. Rather, loosely typed means that the language
has built-in rules for performing operations on various data types, and for
assigning one data type to another data type. The most subtle of these rules is
whether an operator is "self-determined" or "context-determined'. If an engineer
does not understand the difference between these two operation types, he or she
mayfind the resultof the operation to be different from expected. Gotcha!

A context-determined operator looks at the size and data types of the complete
statement before performing its operation. All operands in the statement are
expanded to the largest vector size of any operand before the operations are
performed. Consider the following example:

logic [5:0] a = 6'b010101; II 6-bit vector
logic [3:0] b = 4'b1111; II 4-bit vector
logic [7:0] c; II 8'bit vector

c = a & b; II results in 8-bit 00000101

In this example, the context of the bitwise AND operation includes the vector
sizes of a, band c. The largest vector size is 8 bits. Therefore, before doing the
operation, the4-bitvectorand the 6-bitvector are expanded to 8-bitvectors.

Why were a and b left extended withzeros? Thisquestion is answered in Gotcha
46 on page 105, which discusses zero-extension andsign-extension in Verilog,

A self-determined operator is onlyaffected by thedatatypes of its operands. The
operation is not affected by the context in which it is performed. For example, a
unary AND operation will AND all the bits of its operand together, without
changing the sizeof the operand.

For example:



102 Verilog and SystemVeriiog Gotchas

logic [5:0] a = 6'b101010; II 6-bit vector
logic [3:0] b = 4'b1111; II 4-bit vector
logic [7:0] c; II 8'bit vector

c = a I &hi II results in 8-bit 00101011

In this example, theunaryANDof o ( &b ) is self-determined. The vector sizesof
a and c haveno bearing on theunaryAND of'b, Theresultof ANDing thebits of
4 ' b 1111 together is a 1 ' b 1.

If the self-determined operator is part of a compound expression, as in the
example above, then the result of the self-determined operator becomes part of
the context for the rest of the statement.

What if &bhadbeencontext-determined? In context, b would firstbe expanded to
8 bits wide, becoming 00001111. TheunaryAND of this value is 1 ' b 0, instead
of l' b1. The result of a I &b would be 00101010, which would be the wrong
answer. But this is not a gotcha, because the unary AND operator is self­
determined, and therefore gets the correct answer.

How to avoid this Gotcha

Verilog generally does the right thing. Verilog's rules of self-determined and
context-determined operators behave the way hardware behaves (at leastmostof
the time). The gotcha is in not understanding how Verilog and SystemVerilog
operators are evaluated, and therefore expecting a different result. The only way
to avoid the gotcha is propereducation on Verilog and SystemVerilog. Table 4-1,
below, should help. This table lists the Verilog and SystemVerilog operators, and
whether theyare self-determined or context-determined.

Table 4-1: Determination of Operand Size and Sign Extension1

Operand
Operator Extension Notes

Determined By

Assignment statements Both sidesof assignment affectsize
= <= extension.

context
Only right-hand side affectssign
extensiorr'.

Assignment operations Both sidesof assignment affectsize
+= -= *= /= %= extension.
&= 1= A= context Leftoperandis part of the right-hand side

assignment context(e.g. a += b expands
to a = a + b).



Chapter 4: Operator Gotchas 103

Table 4-1: Determination of Operand SizeandSign Extension1 (continued)

Operand
Operator Extension Notes

Determined By

Assignment operations Leftoperand iscontext-determined. Right
«= »= «<= operand is self-determined. Left operand

»>= see notes is part of the right-hand side assignment
context. (e.g. a «= b expands to
a = a « b)

Conditional Firstoperand (the condition) is self deter­
? : mined.

seenotes
Second and thirdoperands are context­
determined.

Arithmetic
context

+ - * I %

Arithmetic Power Left operand (base)is context-deter­

** mined.
see notes

Rightoperand (exponent) is self-deter­
mined.

Increment and Decre­
ment self
++ --
UnaryReduction Resultis a self-determined, unsigned, 1­
- & -& I -I " _" self bit value.

Bitwise
context

Shift Left operand is context-determined.
« «< » »> see notes Rightoperand (shift factor) is self-deter­

mined.

UnaryLogical Resultis a self-determined, unsigned, 1­
self bit value.

BinaryLogical Resultis a self-determined, unsigned, 1­
self

&& I I bit value.

Equality Resultis a self-determined, unsigned, 1­
-- != --- !== context bit value.
==? ! =?



104 Verilog and SystemVeriiog Gotchas

Table 4-1: Determination of Operand SizeandSign Extension1 (continued)

Operand
Operator Extension Notes

Determined By

Relational Result is a self-determined, unsigned, }-
context

< <= > >= bit value.

Concatenation Result is unsigned.
self

{ } {{} }

Bit andPart Select Result is unsigned.
[ ] [ : ] self
[ +: ] [ -: ]

1 This table onlyreflects operations where theoperands are vectors. Therearealsorules for
when operands are real(floating point) numbers, unpacked structures, andunpacked arrays,
which are not covered in thisbook.

2 Anassignment in an expression canbe on the right-hand sideof another assignment (e.g.
d = (a =b + 5) + c;). In thiscase,the left-hand sideexpression of theassignment-in-an­
expression is partof thecontext of theright-hand sideof theassignment statement (i.e,a in the
example doesnotaffect thesigncontext ofb + 5, butdoesaffect thesigncontext of the+ c
operation).

Additional note: If a context-determined operation is anoperand to a self-determined operation,
the context of thecontext-determined operation is limited to its operands, instead of the full
statement. E.g., in d = a » (b + c) ;, thecontext of theADDoperation is onlyband c.

Self-determined and context-determined operations affect the gotchas described
in Gotchas 46, 47 and 48, whichfollow (withsome interesting examples).



Chapter 4: Operator Gotchas 105

Gotcha 46: Operation size and sign extension in assignment statements

Gotcha.· I declared my outputs as signed types, but my design is still doing
unsigned operations.

Synopsis.' In an assignment statement, sign extension context is only
dependent on the right-hand sideofthe assignment.

Operation sign extension is controlled by the operands of the operator, and
possibly the context in which the operation is performed. A self-determined
operator is only affected by the data types of its operands. A context-determined
operator is affected by the size and data types of all operands in the full
expression. Gotcha 45 on page 101, Table 4-1, lists which operators are self­
determined and which are context-determined.

Before a context-determined operation is evaluated, its operands are first
expanded to the largest vector width in the operation context. There are three
steps in thisoperand expansion, and these steps use different context rules!

Step 1. Evaluate the size and sign that will result from all self-determined
operations on the right-hand and left-hand sides of the assignment. This
information will be used in the subsequent steps.

Step2. Determine the largest vectorsize in the context. The context is the largest
vectoron both the right-hand and left-hand sidesof assignment statements.

Step3. Expand all context-determined operands to the largest vector size by left­
extending each operand. The expansion will either zero-extend or sign-extend,
basedon the operation context, as follows:
• If any operand or self-determined operation resulton the right-hand sideof the

assignment is unsigned, thenall operands andself-determined operation results
on the right-hand side are treated as unsigned, and the smaller vectors are left
extended with zeros.

• If all operands and self-determined operation results on the right-hand side of
the assignment are signed, then all operands and self-determined operation
results on the right-hand sideare left extended usingsignextension.

Note the difference in steps 2 and 3! The context for largest vector size is both
sides of an assignment statement, whereas the context for sign extension is just
the right-hand side of the assignment containing the operation.

Verilog's rulesfor operand expansion reflect howhardware works. The following
examples illustrate cases where Verilog's rules work as one would expect (no
gotchas).



106 Verilog andSystemVeriiog Gotchas

logic [3: 0] u1, u2; II unsigned 4-bit vectors
logic signed [3: 0] sl, s2; II signed 4-bit vectors

logic [7: 0] u3; II unsigned 8-bit vector
logic signed [7: 0] s3; II signed 8-bit vector
logic 0; II unsigned I-bit vector

u3 u1 + u2; II zero extension (unsigned = unsigned + unsigned)

s3 sl + s2; II sign extension (signed signed + signed)

s3 sl + 1; II sign extension (signed signed + signed)

s3++; II sign extension (expands to s3 = s3 + 1,
II which is signed = signed + signed)

u3 += 2'b11; II zero extension (expands to u3 = u3 + 2'b11,
II which is unsigned = unsigned + unsigned)

s3 += 2'sb11; II sign extension (expands to s3 = s3 + 2'sb11,
II which is signed = signed + signed)

A gotcha can occur when an engineer doesn't understand the operand expansion
rules. The next examples show some operation results that might be different
from expected. These examples usethe same declarations as the examples above.
s3 = u1 + u2; II GOTCHA? zero extension, even though 83 is signed

II Rule: left-hand side does not affect sign
II extension context of operands on right-hand side

u3 sl + s2; II GOTCHA? sign extension, even though U3 is unsigned
II Rule: left-hand side does not affect sign
II extension context of operands on right-hand side

s3 sl + u2; II GOTCHA? zero extension, even though sl and 83
II are signed
II Rule: unsigned type on right-hand side means the
II entire right-hand side context is unsigned

s3 sl + l'b1;11 GOTCHA? zero extension, even though sl and 83
II are signed
II Rule: unsigned type on right-hand side means the
II entire right-hand side context is unsigned

s3 += 2'b11; II GOTCHA? zero extension, even though s3 is signed
II (operation is same as: s3 = s3 +2'b11)
II Rule: unsigned type on right-hand side means
II entire right-hand side context is unsigned

u3 += 2'sb11; II GOTCHA? zero extension, even though the 2'sb11
II is signed (operation is same as: u3 = u3 +2'sb11)
II Rule: unsigned type on right-hand side means the
II entire right-hand side context is unsigned



Chapter 4: Operator Gotchas 107

A compound expression can contain a mix of self-determined operations and
context-determined operations. In this case, the resultant type of the self­
determined operation is used to determine the types that will be used by the
context-determined operations. The following examples use the same
declarations as the previous examples.

{o,u3} = ul + u2; II First evaluate the self-determined
II concatenation on the left-hand side.
II This affects the size context of operations
lion the right-hand side (which are expanded
II to 9-bit size of the concatenation result)

u3 ul + lu2; II First do unary OR of a-bit vector u3
II (self-determined) then zero-extend the I-bit
II unary OR result to a bits before doing the
II context-determined math operation

s3 sl + Is2; II GOTCHA? First do unary OR of 4-bit vector s2
II (self-determined), then zero-extend sl and the
II I-bit unary OR result to a bits (even though sl
II is a signed type, the Is2 result is unsigned,
II and therefore the right-hand side context
II is unsigned)

The gotcha of zero extension versus sign extension is, in reality, a useful feature
of the Verilog and SystemVerilog languages. A single operator token, such as +,
can modelan adderwith or withoutoverflow, depending on the largestvectorsize
in the context of the operation. The same + operator can model either a signed
adderor an unsignedadder, againdepending on the contextof the operation.

How to avoid this Gotcha

The gotcha of operand expansion comes from not understanding when vector
expansion will occur, and whether the vector will be zero-extended or sign­
extended. To avoid this gotcha, engineers must know the underlying loosely
typed rules of Verilog and SystemVerilog. Once the rules are understood,
engineers must use the correct sizes and data types for the intended type of
operation. Verilog-2001 provides control over the signedness of an operandwith
the $signed () and $unsigned () functions. SystemVerilog gives engineers
more controlover the application of theseexpansion rules throughthe use of type
casting, size casting, and signedness casting. For example (assuming the same
declarations as in the examples above):
s3 sl + u2; II GOTCHA? zero extension (u2 is unsigned)

s3 8' (51) + signed' (u2); II OK, cast sl to a bits wide (self­
II determined) cast u2 to signed and
II do sign extension



108 Verilog and SystemVeriiog Gotchas

Gotcha 47: Signed arithmetic rules

Gotcha.· My signed adder model worked perfectly until I added a carry-in
input, and now it onlydoesunsigned addition.

Synopsis.' The entire right-hand side contextofan assignment mustbesigned,
in orderto havesignedarithmetic operations.

Gotcha 13 on page 32 discusses some of the gotchas with literal integer sign
extension rules, and Gotcha46 on page 105 coversgotchas with signextension in
operations. This gotcha covers important gotchas when performing arithmetic
operations on signeddata.

Verilog and SystemVerilog overload the mathoperators so that they can represent
several types of hardware. For example, the +operatorcan represent:
• An adder of any bit widthwithno carry-in or carry-out
• An adderof any bit widthwithno carry-in but with carry-out
• An adder of any bit widthwith carry-in and with carry-out
• An unsignedadder
• A signedadder
• A single-precision floating pointadder
• A double-precision adder

The type of arithmetic performed is controlled by the types of the operands and
the context of the operation. In order to perform signed operations, all operands
must be signed. Arithmetic operators are context-determined, Not only must the
operands to the arithmetic operatorbe signed, all otheroperands on the right-hand
side of an assignment must also be signed.

The example below is a signed adder with no gotchas, that simulates and
synthesizes correctly.
module signed_adder_no_carry_in
(input logic signed [3:0] a, b, II signed 4-bit inputs
output logic signed [3:0] sum, II signed 4-bit output
output logic CO)i II unsigned I-bit output

assign {co,sum} = a + bi II signed 5-bit adder
endmodule

In the example above, the left-hand side concatenation is a self-determined
expression that defines a 5-bit unsigned vector. The size of the left-hand side
affects the right-hand side ADD operation, but the signedness of the left-hand
side has no bearing on operations. All operands on the right-hand side of the



Chapter 4: Operator Gotchas 109

assignment are signed, which does affect the add operation. In this context, the
ADDoperator performs a 5-bitsigned operation.

Using an unsigned carry-in. Thenextexample is almost the same, but addsa 1­
bit carry-in input. Thisexample hasa gotcha! It doesnot simulate or synthesize as
a signedadder.
module signed_adder_with_carry_in
(input logic signed [3: 0] a, b, II signed 4-bit inputs
input logic ci, II unsigned l-bit input
output logic signed [3:0J sum, II signed 4-bit output
output logic co) ; II unsigned l-bit output

assign {co,sum} = a + b + ci; II GOTCHA! unsigned 5-bit adder
endmodule

In simulation, the only indication that there is a problem is in the value of the
resultwheneithera or b is negative. Synthesis toolswill issuea warning message
to the effect that a and b were coerced to unsigned types. The reason for this
coercion is that Verilog's arithmetic operators are context-determined. Even
though a and b are signed, one of the operands in the compound expression, ci,
is unsigned. Therefore, all operands are converted to unsigned values before any
context determined operation is performed. Gotcha!

Using a signed carry-in. Declaring the I-bit carry-in input as a signed type
seems like it would solvethe problem. Thischange is illustrated below.
module signed_adder_with_carry_in
(input logic signed [3:0] a, b, II signed 4-bit inputs
input logic signed ci, II signed l-bit input
output logic signed [3:0] sum, II signed 4-bit output
output logic co); II unsigned I-bit output

assign {co,sum} = a + b + ci; II GOTCHA! ci is subtracted
endmodule

Now all operands on the right-hand side are signed, so a signed operation will be
performed, right? No. Gotcha!

The example above does signed arithmetic, but uses incorrect signextension-at
least incorrect for the intended functionality. The gotcha again relates to the ADD
operator beingcontext-determined. As such, all operands are firstexpanded to the
vectorsize of the largest operand, which is the 5-bit self-determined concatenate
operator on the left-hand side of the assignment. Before the addition operations
are performed, a, band c i are sign-extended to be 5-bitswide. This is correct for
a and b, but is thewrongthingto do for cit If ci has a valueof 0, sign-extending
it to 5 bits will be 5' bOO 000, which is still zero. However, if c i is 1, sign­
extending it to 5 bits willbe 5' b 11111, whichis negative 1, instead of positive 1.
The resultof the ADDoperation is a + b + -1. Gotcha!



110 Verilog and SystemVeriiog Gotchas

Using sign casting. Verilog-200I introduced the $signed and $unsigned
conversion functions, and SystemVerilog adds sign casting. Sign casting allows
changing the signedness of an operand. The following example uses signcasting
to try to fix the signed adderproblem.

module signed_adder_with_carry_in
(input logic signed [3:0] a, b, II signed 4-bit inputs
input logic ci, II unsigned l-bit input
output logic signed [3:0] sum, II signed 4-bit output
output logic co); II unsigned I-bit output

assign {co,sum} = a + b + signed' (ci); II GOTCHA! ci is subtracted
endmodule

Casting the sign of the carry-in introduces the same gotcha as declaring carry-in
as signed. When carry-in is set, it is sign-extended to 5 bits,making thecarry-in a
negative 1. Gotcha!

How to avoidthis Gotcha

The realproblem is that a signed I-bit value cannot represent both a value and a
sign bit. Declaring or casting a l-bit value to signed creates a value where the
value and the signbit are thesame bit,which doesnot represent truehardware.

The correct way to avoid this signed arithmetic gotcha is to cast the I-bit carry-in
inputto a 2-bitsigned expression, as follows:

assign {co,sum} = a + b + signed' ({l'bO,ci}); II signed 5-bit
II adder

The signed' ({ l' bO, ci}) operation creates a 2-bit signed operand, with the
sign bit always zero. When the 2-bit signed value is sign-extended to the size of
the largest vector in the expression context, the sign extension will zero-extend,
maintaining thepositive value of the carry-in bit.



Chapter 4: Operator Gotchas 111

Gotcha 48: Bit-select and part-select operations

Gotcha: All my data types are declared as signed, and I am referencing the
entiresigned vectors in my operations, yet I still get unsignedresults.

Synopsis: The result ofa part-select operation is always unsigned, evenwhen
the entire vectoris selected.

Selectinga bit of a vector, or a part of a vector, is an operation. The bit-selectand
part-select operators always return an unsignedvalue, even if the vector itself is
signed. This change in signedness can be unexpected, and is another source for
signed arithmetic gotchas.

parameter MSB = 31;

logic signed [MSB:O] a, b; II signed vectors
logic signed [MSB:O] sum1, sum2; II signed vectors
logic signed [ 7:0] sum3; II 8-bit signed vector

assign suml a + b; II OK, signed adder

assign sum2 = a[MSB:O] + b[MSB:O]; II GOTCHA! unsigned adder

assign sum3 = {a[MSB],a[6:0]} + {b[MSB],b[6:0]}; II GOTCHA!
II unsigned adder

The two gotchas above occur because the result of a part-select operation is
always unsigned, and bit-select and part-select operations are self-determined,
and therefore evaluated before the context-determined ADD operation. The
context for the ADD operation is unsigned.

How to avoid this Gotcha

Since the assignment to sum2 is selecting the full vectors of a and b, one easy
way to avoid this gotcha is to just not do a part-select, as in the assignment to
suml. However, code is often generated by software tools, which may
automatically use part-selects, even when the full vector is being selected. Part
selects are also commonly used in heavily-parameterized models, where vector
sizes can be redefined. For the sum3 exampleabove, there is no choicebut to do a
part-select, since only part of the a and b vectors are being used. When a part­
select of a signed vector must be used, the correct modeling style is to cast the
result of the part-select to a signed value. Either the Verilog-2001 Ssigned
function or SystemVerilog sign castingcan be used. For example:
assign sum2 $signed(a[MSB:O]) + $signed(b[MSB:O]);

assign sum3 signed' ({a[MSB] ,a[6:0]}) + signed' ({b[MSB] ,b[6:0]});



112 Verilog and SystemVeriiog Gotchas

Gotcha 49: Increment, decrement and assignment operators

Gotcha: I'm using the ++ operator for my counter; the counter value is
correct, but othercode thatreads thecounter sees the wrong value.

Synopsis: Increment, decrement, and assignment operations are blocking
assignments.

SystemVerilog provides theC-like ++and -- increment/decrement operators, and
the C-like assignment operators such as +=~ -=~ *= and /=. These are intuitive
anduseful in C programming, and'that usage carries overto modeling verification
testbenches in SystemVerilog. But thereis a gotcha whenusingthese operators in
RTL models of hardware. All of these operators behave as blocking assignments
when updating their target variable. In RTL models, blocking assignments are
only appropriate for representing combinational logic. If theseoperators are used
to model sequential logic, then a simulation race condition is likely to occur. The
following example illustrates sucha racecondition.

always_ff @(posedge clock, negedge reset_n)
if (reset_n) fifo_write_ptr = 0;
else if (!fifo_full) fifo_write-ptr++;

always_ff @(posedge clock)
if (fifo_write-ptr == 15) fifo_full <= 1; / / GOTCHA!
else fifo_full <= 0;

The first procedural block in this example modifies the value of
fifo_wri te_ptr on a clock edge. In parallel, and possibly in a very different
location in the source code, the second procedural block is reading the value of
fifo_write_ptr on the sameclockedge. Because the ++ operator performs a
blocking assignment update to fifo_wri te_ptr~ theupdate can occurbefore or
after the second block has sampled the value. Both event orders are legal. It is
very likelythat twodifferent simulators will function differently for thisexample.
Gotcha!

How to avoidthis Gotcha

The SystemVerilog increment/decrement operators and the assignment operators
should not be used in sequential logic blocks. These operators should only be
used in combinational logic blocks, as a for loop increment, and in contexts
where the increment/decrement operand is not being read by a concurrent
process. The correct way to model the fifo incrementer is:
always_ff @(posedge clock, negedge reset_n)

if (reset_n) fifo_write_ptr = 0;
else if (!fifo_full) fifo_write-ptr <= fifo_write-ptr + 1;



Chapter 4: Operator Gotchas 113

Gotcha 50: Pre-increment versus post-increment operations

Gotcha: My while loop is supposedto execute 16 times, but it exits after 15
times, even though the loopcontrol variable has a valueof16.

Synopsis: Pre-increment versus post-increment can affect the result of some
expressions.

Pop Quiz: The following two linesof code do the samething, right?

sum = i++i

sum = i+1i

Answer: No! (Gotcha!)

Like the C language, the SystemVerilog ++ increment operator, or -- decrement
operator, can be placedbeforea variable name (e.g. ++i) or after a variable name
(e.g. i ++). These two usages are referred to as a pre-increment or a post­
increment, respectively. The result of the operation is the same. The variable is
incremented by 1. In many contexts, pre-increment and post-increment can be
used interchangeably. In a for loop step assignment, for example, either pre- or
post-increment can be used,with the sameresults.
for (int i=Oi i<=255i ++i) ... i

for (in t i =0; i <255 i i ++) ... ;

The two examples are functionally the same in the for loop examples above
because ++ i and i ++ are used as stand-alone statements. No other expression is
reading the value of i in the same statement in which it is incremented. The
statement which follows (the i <=255 test in the examples above) will see the
new valueof i, regardless of whether it is a pre-increment or a post-increment.

The gotcha, which comes straight from the C language, is when the value of the
variableis used within the same statement in whichit is being incremented. If the
increment operator is before the variable name, the variable is incremented before
the value is used in that samestatement (pre-increment). If the increment operator
is placed after the variable, then the value of the variableis used first in the same
statement, and then incremented (post-increment).
i 10i

i++i II assign i to j, then increment ii j gets 10

= ++ii II increment i, then assign result to j; j gets 11

Either of the examples above could be correct, depending on what the design or
verification engineer intends to do. If, however, the engineer is expecting one
functionality but uses the wrongoperator, then Gotcha!



114 Verilog and SystemVeriiog Gotchas

The effects of pre- and post-increment are less obvious in some contexts. For
example:

i = 16;

while (i--) II test i, then decrement; loop will
II execute 16 times

while (--i) II decrement i, then test; loop will
II execute 15 times

Either of the examples above could be correct, depending on what onewants to
do. If, however, an engineer is expecting a loop to runa certain number of times,
andthewrong operator is used, then Gotcha!

How to avoid this Gotcha

Thewayto avoid thisgotcha is to fully understand how pre-andpost-increment!
decrement work. Both types of operations are useful, but need to be used with
prudence.



Chapter 4: Operator Gotchas 115

Gotcha51: Modifying a variablemultiple times in onestatement

Gotcha: When I havemultiple operations on a variable in a singlestatement,
I get different results from different simulators.

Synopsis: The evaluation order is undefined when a compound expression
modifies the same variable multiple times on the right-hand side of an
assignment statement.

SystemVerilog has assignment operators (such as += and -=), and increment!
decrement operators (++ and--). These operators both read and modify the value
of theiroperand. Two examples are:

= ++i; II OK, increment i, then assign result to

= (i += 1); II OK, increment i, then assign result to

Both of these examples modify a variable on the right-hand side of the
assignment statement before making the assignment. There is a gotcha, however,
if the same variable is modified multiple times in the same expression. For
example:

i = 10;
j = --i + ++i; II GOTCHA! multiple operations on same variable

In this example, the value of i is both read and modified multiple times on the
right-hand sideof the assignment statement. Thegotcha is that the SystemVerilog
standard does not guarantee the order of evaluation and execution of these
multiple read/writes to the samevariable in the sameexpression. Afterexecution,
the value of j in this example could be 19, 20 or 21 (and perhaps even other
values), depending upon the relative ordering of the increment operation and the
decrement operation.

How to avoidthis Gotcha

Thisgotcha canbe avoided by notusing operators which makemultiple reads and
writes to a variable within the samestatement. Synthesis toolsdo not permit these
types of operations, because of the indeterminate results. The correct way to
model the example above depends on what order the designer intended the
operations on i to occur. Onepossibility is:

always_comb begin
temp = --i; II pre-decrement i, save result in temp
j = tempI + i++; II add tempI and i, then increment i

end



116 Verilog and SystemVeriiog Gotchas

Gotcha 52: Operator evaluation short circuiting

Gotcha: I am calling afunction twice in a statement, but sometimes onlyone
ofthe calls is executed.

Synopsis: Simulation mightnot evaluate all operands insomecircumstances.

Software simulation does not always evaluate statements in the same way as
hardware. Consider the following example:

always @(posedge clock)
if (mem_en " write) mem[addr] <= data_in; II OK, no side effects

In this example, the logical AND operator ( && ) checks if both mem_en and
write are true. In hardware, this operation is an AND gate. The two inputs are
continuously evaluated, and affect the output of the AND gate. In simulation,
however, the logical operation is performed from left-to-right. If mem_en is false,
then the resultof the logical AND operation is known, without having to evaluate
write. Exiting an operation when the answer is known, but before all operands
have been evaluated, is referred to as operation short circuiting. The Verilog/
SystemVerilog standards explicitly allow, but do not require, tools to shortcircuit
logical AND, logical OR and the?: conditional operations. Thestandards arenot
clear as to whether other operators can short circuit. It is neither expressly
permitted nor expressly prohibited.

Does short circuiting matter? Not in the preceding example. The simulation
results of the logical ANDoperation will match the behavior of actual hardware.

Nowconsider a slightly different example:
always @(posedge clock)

if ( f(il,ol) && f(i2,o2») II GOTCHA! possible side effects
mem[addr] <= data_in;

function f(input [7:0] d_in, output [7:0] d_out);
d_out = d_in + 1;
if (d_out == 255) return 0;
else return 1;

endfunction

Thefunction above modifies thevalue passedintoit andpasses thatresultbackas
a function output argument. In addition, the function returns a status flag. The
function is calledtwice, on the right-side and the left-side of the && operator.

In hardware, the logical AND operator can be implemented as an AND gate, and
the function replicated as combinational logic to each input of the gate. As
combinational logic, both 01 and 02 are continuously updated to reflect their
inputvalues.



Chapter 4: Operator Gotchas 117

In software, however, the logical AND operation is evaluated from left-to-right. If
the return of the first function call is 0, the resultof the AND operation is known
without having to evaluate the second operand. A simulator or other tool is
permitted to short circuit the operation. If this occurs, the function is not called
the second time, and 02 is notupdated to reflect thevalue of i 2. Gotcha!

How to avoid this Gotcha

The only way to avoid this gotcha is to avoid operands with side effects. A side
effect occurs whentheoperand modifies a value when theoperand is evaluated. If
the operands do not havesideeffects, thenthebehavior of shortcircuiting are the
same, andsimulation will correctly match hardware behavior.

Toavoid the shortcircuiting gotcha in the example above, it mustbe re-coded to
ensure thatbothcalls to the function always execute. Oneway to do this is:

always @(posedge clock) begin
temp1 = f(i1,01); II 01 will be updated every time
temp2 = f(i2,02); II 02 will be updated every time
if ( templ && temp2 II OK! no side effects

mem[addr] <= data in;
end



118 Verilog and SystemVeriiog Gotchas

Gotcha 53: The not operator ( ! ) versus the invert operator ( - )

Gotcha: My ifstatementwith a not-true condition did not executewhenI was
expectingit to.

Synopsis.' The logicalNOT operator and the bitwise invert operator perform
different operations and can be used incorrectly.

Engineers new to Verilog, and evena few veterans, sometimes misuse the Verilog
logical NOT operator ( ! ) and the bitwise invert operator (IV). In some
operations, the results of these operations happen to be the same, but, in other
operations, theyyieldvery different results. Consider the following example:
logic a; Ill-bit 4-state variable
logic [1:0] b; II 2-bit 4-state variable

initial begin
a = 1 ;
b = 1 ;

if ( !a) II evaluates as FALSE
if (-a) II evaluates as FALSE

if ( !b) II evaluates as FALSE
if (-b) II evaluates as TRUE -- GOTCHA!

end

The gotcha is that the logical NOT operator ( ! ) performs a true/false test first
and then inverts the I-bit test result. On the otherhand, the bitwise invertoperator
( IV ) just inverts the valueof eachbit of a vector. If the bitwiseinvertoperation is
used in the contextof a true/false test, the bit inversion occurs first, and the true/
false evaluation is performed second, possibly on a multi-bit value.

Inverting the bits of a vector, and then testing to see whether it is true or false is
not the same as testingwhether the vector is true or false, and then inverting the
resultof that test. Gotcha!

How to avoid this Gotcha

The bitwiseinvertoperator shouldneverbe used to negate logical true/false tests.
Logical test negation shoulduse the logical NOToperator.

if (!b) ... II OK, logical operator used for truelfalse test

Conversely, the logical NOToperator shouldneverbe used to inverta value. The
result of logicalNOT and bitwise inversion is the same for I-bit values, but very
different for vectors. Evenwhen inverting a I-bit signal, such as a clock, gotchas
will be avoided by using the invertoperator for invertoperations.
always #5 clk = ~clk; II OK, invert operator used to invert clock



Chapter 4: Operator Gotchas 119

Gotcha 54: Array method operations

Gotcha: I get thewrongresult whenI sum all the values ofan arrayusingthe
built-in .summethod.

Synopsis: Someofthe System Verilog arraymethods are context-determined.

SystemVerilog adds several built-in functions for working with arrays, called
array methods. The gotcha illustrated here uses the . sum array method, but
similargotchas exist with several of the arraymethods.

The . sum methodreturns the total of adding all the values in all elements of the
array. In the following example, the fifties array holds four 8-bit vectors,
which are initialized with several integer values. The values in the array are
summed using the . sum method, andprintedusinga $display statement.
logic [7:0] fifties [0:3] = '{SO,100,ISO,200}; II 8-bit array

$display(nfifties.sum is %Od", fifties.sum); II GOTCHA!

This example sums up 50 + 100 + 150 + 200 and returns the clearly
incorrect totalof 244. Gotcha!

The reason for this result is that the . sum method, and several other array
methods, are context-determined. With context-determined operations, the vector
size of the operation is based on the context in which the operation is used.
Gotcha 45 on page 101 explains the rules for context-determined operations.

In this example, each member of the array is 8-bits wide. There are no other
values involved in the . sum operation, so the context of the operation is 8-bit
values. As the values of the array are summed, the most-significant bits of any
result that overflows the 8-bit size are truncated. That is, in context, the array is
summed withan 8-bit adderwithno carry.

How to avoid this Gotcha

This gotchacan be avoided by using the array method in a contextwith a vector
size that can hold the maximum value the method could return. Two of many
ways the operation contextcanbe changed are shownbelow.

One simple way to change the size context is to add a literal value of 0 to the
method return. The following example adds a 16-bit literal 0 to the. sum return.
This makes the context of the operation 16 bits, which is sufficient to hold the
maximum value. This example will return the correctsum of 500.

$display (" fifties. sum is %Od", (fifties. sum + 16' dO) ) ; I I OK



120 Verilog and SystemVeriiog Gotchas

A second way tochange thecontext vector sizeis to assign themethod return toa
larger vector. Thesizecontext for operations is based onboththeright-hand and
left-hand sides of assignment statements. Thefollowing example also returns the
correct sum of 500.

int total; II 32-bit integer variable

total = fifties.sum
$display("total is %Od", total); II OK



Chapter4: OperatorGotchas 121

Gotcha 55: Array method operations on an array subset

Gotcha: I get the wrong answer when I sum specific array elements in an
array.

Synopsis.' Using sum witht), returns a sumofthewitht) expressions, nota sum
ofa subsetofarrayelement values.

SystemVerilog provides a number of array methods to search andmanipulate data
within arrays. These methods operate onlyon unpacked arrays, and include array
searching, array ordering andarray reduction.

The . sum method, an array reduction method, returns the sum of the values
stored in all elements of an array. An optional wi th () clause canbe usedto filter
out somearrayvalues. But,when using . sum wi th ( ) , there is a subtle gotcha.

In the following example, the intent is to sum up all values in the array that are
greater than7.
program automatic test;

initial begin
int count, a[] = '{9, 8, 7, 6, 5, 4, 3, 2, 1, a};
count = a.sum with (item> 7); II GOTCHA: expect 17, get 2
$display("\"a.sum with(item > 7)\" returns %Od", count);

end
endprogram

When the optional wi th () clause is used, the . sum method adds up the return
values of the expression inside the wi t.h () clause, instead of summing the values
of the array elements. In the example above, the (i tern > 7) is a true/false
expression, which is represented with the values I'bi or 1'bu. If the array
contains the values {9, 8 , 7 , 3, 2, 1 }, then the true/false test for each array
element returns the set of values {1' b 1 , 1 ' b 1 , 1 ' b 0 , 1 ' b 0, 1 ' b 0 , 1 ' b 0 }. The
sumof these true/false values is 2. Gotcha!

Other array methods that have a with() clause can have a similar gotcha.

How to avoidthis Gotcha

The true/false result of the relational expression can be used to select just the
element values where the test is true. Two simple ways to do this are:
count a.sum with( (item> 7) ? item: 0 );

count a.sum with( (item> 7) * item );



Chapter 5
General Programming Gotchas

Gotcha 56: Verifying asynchronous and synchronous reset at time zero

Gotcha: Sometimes my design resets correctly at time zero, and sometimes it
fails to reset.

Synopsis: Initial procedural blocks can activate in any order relative to
alwaysprocedural blocks.

A common verification gotcha is not understanding the event scheduling of
initial and always procedural blocks. Because of the name "initial", some
engineers assume that initial blocks are executed before always blocks. Other
engineers believe just the opposite is true, that initial blocksare guaranteed to
execute afterall always blocks are active.

In which order should the initial andalways blocks bestarted? If the verification
goal is to test resetting the design at time zero, the answer to this question is not
straightforward. It depends if the design is modeled with asynchronous resets or
synchronous resets.

The following example illustrates a testbench wherethe goal is to reset the design
at timezero, and the designuses asynchronous resets.

Note: the code examples in this chapterare contrived in order to illustrate each gotchausing small
examples. In realdesignandverification code,thesegotchas mightnotbe as obvious or easyto debug.



124 Verilog and SystemVeriiog Gotchas

module chip (input logic clock, input logic reset_n, ... );

always_ff @(posedge clock, negedge reset_n) II asynchronous rest
if (!reset_n) q <= 0;
else q <= d;

endmodule

module test (input logic clock, output logic reset_o, ... );

initial begin
reset_n = 0; II GOTCHA! activating reset at time zero
#10 reset n 1;

end
endmodule

module top;
logic clock, reset n,
test test (.*); II connect testbench to design
chip dut (.*);

initial begin
clock = 0; II OK! first rising clock edge at time 5
forever #5 clock -cLcck r

end
endmodule

In this example, if a simulator activates the always_ ff procedural block first, it
will encounter the @timing control in the sensitivity list and suspend execution,
while waiting for a negative edge of reset_no Then, when the initial
procedural block in module test activates and changes reset_n to 0, the
always_ff block will sense the change and the flip-flop will reset.

But, the activation order ofprocedural blocks is not guaranteed. The Verilog and
SystemVerilog standards state that initial and always procedural blocks
become active at time zero, in any order. The initial block in the module
test, above, could activate and assign reset_n to 0 before the always_ff
block activates. In this case, the flip-flop misses the change at time zero on
reset_ n, and fails to reset asynchronously at time zero. Gotcha!

Instead of depending on activation order, specific programming constructs must
be used to control when verification events occur. There are ways to avoid this
gotcha, and ensure that the always_ff block activates first, before reset_n
changes to 0 at time zero. Before looking at the solution, however, let's consider
what is needed to reset the design at time zero, if the design uses synchronous
reset flip-flops, as shown in the following example:



Chapter 5: General Programming Gotchas 125

module chip (input logic clock, input logic reset_n, ... );

always_ff @(posedge clock) II synchronous rest
if (!reset_n) q <= 0;
else q <= d;

endmodule

module test (input logic clock, output logic reset_n, ... );

initial begin
reset_n = 0; II GOTCHA! activating reset at time zero
#10 reset n 1;

end
endmodule

module top;
logic clock, reset n,
test test (.*); II connect testbench to design
chip dut (.*);

initial begin
clock = 1; II GOTCHA! first rising clock edge at time

zero
forever #5 clock -clock;

end
endmodule

There are only two changes between this example and the first example. The
always_ ff has been changed to model synchronous resets, and the clock
generator in module top has beenchanged to generate a positive edgeof clock at
timezero, in orderto reset the design at timezero.

The first example with asynchronous resets required the always_ff block to
activate beforeresetwas initialized. Thus, therewas a racecondition between the
design and the activation of reset. With synchronous resets, the needed behavior
is that both the always_ff and the initial block that activates reset must
occur before the initialization of clock at time zero. Since the activation of the
threeprocedural blocks couldbe in any order, there is a three-way racecondition.
Gotcha!

How to avoid this Gotcha using Verilog

This gotcha is avoided by proper education and understanding of the Verilog
event scheduling of concurrent statements. It is also necessary to understand the
type of hardware being verified, as different types of hardware require different
eventordering.

The simplest way to avoid this gotcha, and one that is highly recommended, is to
avoid clocking and resetting a design at time zero. If clock and reset occurany



126 Verilog and SystemVeriiog Gotchas

time after time zero, all procedural blocks will be active, and the orderof events
is far lesscritical.

If resetting the design at time zero is needed, the correct mix of blocking and
nonblocking assignments must be used. When executed, blocking assignments
immediately update the variable on the left-hand side. Nonblocking assignments
update variables after a delta in the current simulation time. At simulation time
zero,all procedural blocks are guaranteed to be active before this delta.

If the design uses asynchronous resets, both clockand reset should be initialized
usingnonblocking assignments.
module test (input logic clock, output logic reset_n, ... );

initial begin
reset_n <= 0; II OK, reset activated after delta
#10 reset n 1;

end
endmodule

module top;

initial begin
clock <= 1; II OK, first rising clock after delta
forever #5 clock -clock;

end
endmodule

With asynchronous resets, it doesnot matter whatorderclockand resetoccur, so
long as the value changes occur after the time zero delta. Both are listed in the
sequential logic sensitivity list, so, no matterwhat orderclockand reset occur, if
the sequential logic procedure has beenactivated, it will resetat timezero.

If the design uses synchronous resets, the order in which the activation of clock
and resetoccur is important. Theresetsignal needs to haveits active value before
the first edge of clock occurs. To guarantee this order of events, only the clock
should be initialized usingnonblocking assignment. The reset should be assigned
with a blocking assignment, so that it is updated to its value before the delta
delay.
module test (input logic clock, output logic reset_n, ... );

initial begin
reset_n = 0; II OK, reset activated before delta
#10 reset n 1;

end
endmodule



Chapter 5: General Programming Gotchas 127

module top;

initial begin
clock <= 1; II OK, first rising clock after delta
forever #5 clock -clock;

end
endmodule

The scheduling of nonblocking assignments guarantees thatall procedural blocks,
whether initial or always, have been activated, in any order, before the
assignment takesplace.

How to avoidthis Gotcha usingSystem Veri/og

With SystemVerilog, the testbench can be, and should be, modeled using a
program instead of a module.

proqram automatic test (input logic clock, output logic reset_n);

initial begin
reset_n <= 0; II OK, reset activated as verification event
#10 reset n <= 1;

end
endmodule

module top;

initial begin
clock <= 1; II OK, first rising clock after delta
forever #5 clock -clock;

end
endmodule

A program block has special event scheduling semantics that help avoid most
types of test-to-design race conditions. In brief, value changes generated from a
program block are scheduled to take place after both blocking and nonblocking
assignments that are in modules and interfaces. This scheduling eliminates the
gotchawith scheduling asynchronous resetsat simulation timezero in the correct
order. Note, however, that the program block does not solve the gotchadescribed
abovefor scheduling synchronous resets at timezero.

See Gotcha 7 on page 22 for coding guidelines withprogram blocks.



128 Verilogand SystemVeriiog Gotchas

Gotcha 57: Nested Jf•••else blocks

Gotcha: My else branch ispairingup with the wrong ifstatement.

Synopsis: An else construct pairs with the nearest if statement that does not
havean else; begin...endcan override thisdefault pairing.

The else branch of a Verilog/SystemVerilog i£...e18e statement is optional.
This can lead to confusion when if...else statements are nested within other
if....lse statements, and some of the optional else statements are not
specified. Which else goes to which if? Thefollowing example is a gotcha...
if (a >= 5)

if (a <= 10)
Sdisplay (U 'a' is between 5 and lOU);

else
Sdisplay (U 'a' is less than 5U) ; II GOTCHA! pairs with wrong if

The indentation of the codeabove implies that the else statement goes with the
first if statement, but that is not how Verilog/SystemVerilog works. The
language rules state that an else statement is automatically associated with the
nearest previous if statement that does not have an else. Indentation does not
change the language pairing rules.

Therefore, the example above, with correct indentation and $display statements,
is actually:
if (a >= 5)

if (a <= 10)
Sdisplay (" 'a' is between 5 and lO");

e18e
$display (" 'a' is greater than 10"); II CORRECT!

How to avoidthis Gotcha

The automatic if...else association can be overridden using begin...end to
explicitly showwhich statements belong within an if branch. The first example,
above, can be correctly coded as follows:
if (a >= 5) begin

if (a <= 10)
Sdisplay (n 'a' is between 5 and lO");

end
else

Sdisplay (II 'a' is less than 5"); II CORRECT!

A language-aware text editor can alsohelp avoid this gotcha. The editor toolcan
properly indent nested if...else statements, lining up the else statement with
its corresponding if statement.



Chapter 5: General Programming Gotchas 129

Gotcha 58: Evaluation of equality with 4-state values

Gotcha: My testbench completely misses problems on design outputs, even
though it is testing the outputs.

Synopsis: The equality operators have three answers, true, false and
unknown, but if ..else decision statements only have two branches.

A common task in verification is to compare data from the design to expected
results. Verilog hasan equivalence operator ==, thatappears to be similar to theC
language operator. They are not the same! Verilog also has a not-equivalent
operator, !=, thatuses the sametoken as C, but works differently.

The following excerpt from a testbench might seem reasonable in most
programming languages, but with 4-state logic, the code does not work as
intended.

always @(posedge test_clock)
if (data != expected) II GOTCHA!

$display("Error on data: saw %h, expected %h", data, expected);

In this example, if data always has known values, then the verification code will
workas intended. But, if data has anybits that are X or Z, the if branch will not
be taken. Most likely, an X or Z value on any bit of data is a design error, but the
verification codemisses the problem. Gotcha!

The gotcha comes from not understanding how the equality/inequality operators
handle 4-statevalues. In brief, the rules are:
• If the two operands are numerically equivalent, the operation result is true.

• If the two operands are numerically different, the operation result isfalse.
• If the eitheroperand is not a known number, the operation result is unknown.

The true, false, and unknown results are represented with the I-bit values, l' b 1,
l' bO, and l' bx, respectively.

The if...else decision onlyhas twobranches. If theexpression testedis true, the
if branch is executed. If the expression is evaluates as either false or unknown,
the else branch is taken. The verification example above traps errors using the
if branch of the decision, and doesnothing on the else branch. Should there be
a problem with thedesign that results in a logicz or x on anybit of the output, the
not-equal ( != ) operator will return unknown, which will not take the if branch
of the verification code. The design errorwillgo undetected.



130 Verilog and SystemVeriiog Gotchas

How to avoid this Gotcha

This gotcha can only be avoided by understanding how 4-state values are
evaluated as true or false. Both design and verification engineers need to know
that, in order for a 4-state equivalence test to be true or false, no bits in the
expression can havea Z or X value.

The verification example above can be corrected by using special verification
operators in Verilog, the identity operators (=== and ! ==), instead of the usual
programming equality operators (= and !=). For example:

always @(posedge test_clock)
if (data !== expected) II OK, will detect bits with X or Z

$display{"Error on data: saw %h, expected %h", data, expected);

The identity operators perform a bit-by-bit comparison of its two operands. The
values of each bit are compared for all four logic values. If both bits have
identical values, the comparison of those bits evaluates as true. If all bits are
identical, the operation returns true. If any bits are different in any way, the
operation evaluates as false. The not-identical operator, ! ==, negates the true/
false results.



Chapter 5: General Programming Gotchas 131

Gotcha 59: Event trigger race conditions

Gotcha: I'm using the event data type to synchronize processes, but
sometimes when J trigger an event, thesensing process does notactivate.

Synopsis: An event that is triggered in the same time step in which a process
begins looking/or theeventmaynot besensed.

Verilog provides a basic inter-process synchronization mechanism via the event
data type, the -> event trigger operator, and the @ event timing control. Many
engineers don't know that the feature even exists in the language, and are
unaware of how to use it. An engineer who had beenusing Verilog for a number
of years recently attended a Verilog training classwith his team. When thesection
on eventdata types was presented, the engineer asked if this was something new
with SystemVerilog, The answer was no, that it has been in the Verilog language
since its beginning in 1984. To this, the veteran Verilog engineer replied, "Why
hasn't anyone toldme about thisbefore?"

There is gotcha, however, in that there can easily be simulation race conditions
with Verilog's event triggering. The following code demonstrates this potential
racecondition.

module event_examplel;

event get_data, send_data; II handshaking flags

initial -> get_data; II GOTCHA! trigger at time zero
always @(get_data) begin II wait for a get_data event

... II code to get data

... II when done, trigger send data
-> send_data; II sync with send_data process

end

always @(send_data) begin II wait for a send data event
... II code to send data
... II when done, trigger get_data
-> get_data; II sync with get_data process

end
endmodule

The twoalways blocks above model simple behavioral handshaking. Theevent
datatypeis usedto signal thecompletion of oneblock andenabling the other. The
initial blockis usedto startthe handshaking sequence.

The gotcha lies in the fact that, at simulation time zero, each of the procedural
blocks mustbe activated. If the initial blockactivates and executes before the
always @(get_ da ta) block activates, thenthesequence willnever start.



132 Verilog and SystemVeriiog Gotchas

Howto avoidthis Gotcha using Verilog

In Verilog, the onlyway to solve this issue is to delay the trigger in the initial
block from occurring until all the procedure blocks have been activated. This is
doneby preceding the statement withan explicit zerodelay, as shown in the code
below.

initial #0 -> get_data; II OK! delayed trigger

always @(get_data) begin II wait for a get_data event
... II code to get data

Using the #0 delay will hold off triggering the get_ da ta event until all the
procedure blocks have been activated. This ensures that the always
@(get_data) blockwill sensethe startofa handshake sequence at timezero.

The Verilog #0 construct can be abused, however, and causeotherhard-to-debug
race conditions. Some Verilog trainers have recommended never using #0,
because of its inherent dangers.

How to avoid this GotchausingSystem Verilog

SystemVerilog comes to the rescue, with twosolutions thatwill remove theevent
triggerrace condition without using #0.

SystemVeri/og solution 1.'

SystemVerilog defines a nonblocking event trigger, -», that will schedule the
event to trigger after a zero delay delta, in the same way as nonblocking
assignments. For the example in this section, this eliminates the race condition at
time zero, and eliminates the needfor a #0 delay. Triggering the get_data after
the nonblocking delta allows for the always procedure blocks to become active
beforethe eventis triggered.

initial -» get_data; II OK! trigger after delta
always @(get_data) begin II wait for a get_data event

... II code to get data

System Veri/og solution 2.'

SystemVerilog provides a second approach that will provide a solution to many
moresituations thanthe simple example shown in thisbook. Thissecond solution
uses a trigger persistence property that makes the trigger visible through the
entire time step, and not just in the instantaneous moment that the event was
triggered.



Chapter5: General Programming Gotchas 133

module event_example2 ( I II );

II handshaking flags

initial -> get_data; II OK, trigger get_data at time zero

always begin
wait (get_datal triggered) II wait for a get_data event
... II do code to get data
... II when done, trigger send_data
-> send_data; II sync with send data process

end

always begin
wait(send_data.triqgered) II wait for a send_data event
... II do code to send data
... II when done, trigger get_data
-> get_data; II sync with get_data process

end
endmodule

The wait (get_data. triggered) returns true in the time step in which
get_ da ta is triggered. It does not matter if, within the current simulation time,
the trigger eventoccurs before or afterthewai t statement is activated. So, in the
above example, if the initial block activates and executes before the first
always block, the trigger persistence will still be visible when the first always
block becomes active and executes the wait (get_data. triggered)
statement.



134 Verilog and SystemVeriiog Gotchas

Gotcha 60: Using semaphores for synchronization

Gotcha: My processes are not synchronizing the way I expected using
semaphores. Even when there arewaiting processes, some otherprocess gets
to run aheadofthem.

Synopsis.' Semaphore keys can be added to a bucket without having first
obtainedthose keys. Keys can be obtained without waiting for prior requests
to beserviced.

The Verilog event data typesprovide a means to synchronize procedural blocks.
But, this method of procedural handshaking and communication is too limiting
for modem, object-oriented verification methodologies. SystemVerilog provides
two additional inter-process synchronization mechanisms that provide more
flexibility and versatility than simple event triggering provides. These
mechanisms are semaphores and mailboxes. Both of these new synchronization
methods havesubtle behaviors thatmustbe considered. Thissection describes the
gotchas involving semaphores. Gotcha 61 on page 137 describes the gotchas
involving mailboxes.

Semaphores are like a bucketthat can holda number of keys or tokens. Methods
are available to put any number of keys into the bucket and to get any number of
keys out of the bucket.

The put () method is straight forward. The number specified as an argument to
put () is the number of keys placed in the bucket. Any number of keys can be
placedinto the bucket, regardless of howmanywereretrieved from thebucket. A
process can evenadd keys to the bucket without having retrieved anykeysat all.
(A potential gotcha not addressed in this book is that incorrect code could keep
adding morekeys to the bucket thanwereretrieved from the bucket.)

The get () method is used to retrieve keysfromthe bucket. Anynumber of keys
can be requested. If the number of keys requested is not available, the calling
process is blocked fromcontinuing execution until the requested number of keys
becomes available.

The get () method has a subtle, non-intuitive gotcha. If more than one key is
requested, and thatnumber of keysis not available, the request is put intoa FIFO
(First In, First Out), and will wait until the requested number of keys becomes
available. If more than one process requests keys that are not available, the
requests are added to the FIFO in the order received. When keys become
available, the requests in the queue areserviced in the orderin which the requests
werereceived.



Chapter 5: General Programming Gotchas 135

The gotcha is that, each time get () is called, an attempt is made to retrieve the
requested keys, without first putting the request into the FIFO. If the requested
number of keys is available, the get() is serviced, even if other requests are
waiting in the FIFO. The following example demonstrates this gotcha.
module sema4_example ( ... );

semaphore s_test = new; II create a semaphore bucket

initial begin: Block1 II At simulation time zero ...
s_test.put(5) ; II bucket has 5 keys added to it
s_test.get(3); II bucket has 2 keys left
s_test.get(4) ; II get(4) cannot be serviced

II because the bucket only has 2
II keysi the request is put in
II the request FIFO

$display("Block1 completed at time %Od", $time)i
end: Block1

initial begin: Block2 #10 II At simulation time 10 ...
s_test.get(2); II GOTCHA! Even though get(4)

II came first, and is waiting
II in the FIFO, get(2) will be
II serviced first

s_test.get(l); II this request will be put on
II the FIFO, because the bucket
II is empty; it will not be
II serviced until the get(4)
II is serviced

$display("Block2 completed at time %Od", $time);
end: Block2

initial begin: Block3 #20 II At simulation time 20 ...
s_test.put(3); II nothing is run from the FIFO,

II since get(4)is first in the
II FIFO

#10 II At simulation time 30 ...
s_test.put(2); II get(4) and get(l) can now be

II serviced, in the order in
II which they were placed in
II the FIFO

$display("Block3 completed at time %Od", $time)i
end: Block3

endmodule

When a get () method is called, and there are enough keys in the bucket to fill
therequest, it retrieves therequested keys immediately, even if there are previous
get () requests waiting in the FIFO for keys. In the example above, the Blockl
process starts at simulation time zero. It executes until get (4) is called. At that
time,there are only 2 keys available. Sincetherequest couldnotbe filled, it is put



136 Verilog andSystemVeriiog Gotchas

in the request FIFO. The execution of aiccxi is thensuspended until4 keys are
retrieved.

Next, a separate process, Block2 requests 2 keys at simulation time 10. The
get {2} executes and retrieves the 2 remaining keys from the bucket
immediately, even though there is the get {4} in the request FIFO waiting to be
serviced. The process then executes a get (l) . This request cannot be serviced,
because the bucket is nowempty, andtherefore is put on the request FIFO.

At simulation time30, the Block3 process puts three keysbackin thesemaphore
bucket. The get (4) request sitting in the FIFO still cannot be serviced, because
thereare not enough keysavailable. There is alsoa get (1) request in the queue,
but is not serviced because that request was received after the ge t (4) request.
Onceplacedon theFIFO, the get () requests areserviced in theorderwhich they
werereceived. The get (4) mustbe serviced first, thenthe get (l) .

How to avoidthis Gotcha

The gotcha is having a get () request serviced immediately, evenwhen there are
otherget () requests waiting in the request FIFO. This gotcha can be avoided if
the get () requests are restricted to getting just onekeyat a time. In thisway, any
requests in the FIFO will never be waiting for more than one key. As soon as a
key becomes available, the first request in the FIFO will be serviced. A new
get () request willnotbe serviced ahead of theFIFO.

If a process needs more than one key, instead of calling get () once for the
multiple keys, the process should call get (1) multiple times. A repeat loop is a
convenient way to request multiple keys, oneat a time. For example:

repeat (3) s_test.get(l); II request 3 keys, one at a time

When the process is done, it can return multiple keys with a single pu t ( ) . It is
not necessary to put the keys backoneat a time.



Chapter 5: General Programming Gotchas 137

Gotcha 61: Using mailboxes for synchronization

Gotcha: My mailbox works at first, and then starts getting errors during
simulation.

Synopsis: Run-time errors occur ifan attempt is made to read the wrong data
type from a mailbox.

Mailboxes provide a mechanism for both inter-process synchronization and the
passage of information between processes. By default, mailboxes are typeless,
which means that messages of any data type can be put into the mailbox. The
gotcha is that, when messages are retrieved from the mailbox with the get ()
method, the receiving variable mustbe the samedata type as the valueplaced in
the mailbox. If the receiving variable is a different type, thena run timeerrorwill
be generated.

module mbox_example1 ( ... );
logic [15:0] a, b;
int i, j, s;
struct packed {int u, v, Wi} d_in, d_out;

mailbox mbox1 new; II typeless mailbox

initial begin
mboxl.put(a) ; II OK: can put message of any data type
mboxl.put(i); II OK: can put message of any data type
mboxl.put(d_in); II OK: can put message of any data type

mboxl. get (b) ; II OK: data type of b matches data type of
II first message in mbox1

mboxl.get(b); II ERROR: b is wrong type for next message
II in mboxl

end
endmodule

How to avoid this Gotcha

There are three ways of avoiding this gotcha. First is the brute force method of
managing the data typesmanually. The manual approach couldbe error prone. It
places a burden on theverification engineers to trackwhattypeof datawasput in
the mailbox, and in what order, so that the correct types are retrieved from the
mailbox.

The second approach is to use the try_get () method, instead of the get ()
method. The try_get () method retrieves the message via an argument passed
to try_get () , and returns a status flag. Oneof threestatusflags is returned:



138 Verilog and SystemVeriiog Gotchas

• Returns 0 if there is no message in themailbox to retrieve.
• Returns 1 if the message and the receiving variable are type-compatible, and

themessage is retrieved.
• Returns a negative value if the message and the receiving variable are type-

incompatible, in which casethemessage is not retrieved.

The return value of try_get () can be processed by conditional statements, to
determine the next verification action. The following example illustrates using a
typeless mailbox and the try_get () method.

module mbox_example1 ( ... )i
logic [15:0] a, bi
int i, j, e :
struct packed tint u, v, Wi} d_in, d_outi

mailbox mboxl = neWi II typeless mailbox

initial begin
mboxl.put(a); II OK: can put message of any data type
mboxl.put(i); II OK: can put message of any data type
mboxl.put(d_in); II OK: can put message of any data type

s = mboxl.try_get(d_out); II must check status to see if OK
case (s)

1: $display("try_get() succeeded");
0: $display(tltry_get() failed, no message in mailbox");

default: $display ("try_get () failed due to type error");
endcase

end
endmodule

The third approach to avoiding a mailbox run-time errorgotcha is to use typed
mailboxes. These mailboxes have a fixed storage type. The tool compiler will
give a compilation error if the code attempts to place any messages with
incompatible data types intothe mailbox. The get () method canbe safely used,
because it is known beforehand what data type will be in the mailbox. An
example of declaring a typed mailbox is.

typedef struct {int a, b} data_packet_t;

mailbox #(data-packet_t) mbox2 = new; II typed mailbox

With this typed mailbox example, only messages of data type da ta_packet_ t
can be put into mbox2. If an argument to the put () method is any other type, a
compilation errorwill occur.



Chapter 5: General Programming Gotchas 139

Gotcha 62: Triggering on clocking blocks

Gotcha.· I cannot get my testprogram to waitfor a clocking blockedge.

Synopsis: When a testwaits for a clocking blockedge to occur, theposedge or
negedge keyword shouldnot be used.

Test code that uses the @ event control to delay until a clocking block clock
occurs shouldnot specify posedge or negedge of the clocking blockname. The
following example causes a compilation error:

program automatic test (input logic clk,
input logic grant,
output logic request

) ;
clocking cb @(posedge elk);

output request;
input grant;

endclocking

initial begin
@(posedge cb) II GOTCHA: cannot select edge of clocking block

Sdisplay("At %Od: clocking block triggered", Stime);

end
endprogram

Howto avoidthis Gotcha
When test code needs to delay for a clocking block clock using the @ event
control, only the clocking block name should be used. This is because clocking
block definitions already specify which edge of the clock is being used. For
example:

initial begin
@(cb) II OK: delay until clocking block event occurs

$display("At %Od: clocking block triggered", $time);

end
endprogram

Using a clocking blocknamefor an eventcontrol can maketest codemorerobust
and easier to maintain, especially when the clocking block is defined in an
interface. The test program doesnot needto know if the interface uses a positive
edge, negative edge, or both edges (double data rate) of the clock. All the test
program needsto reference is the clocking blockname.



140 Verilog and SystemVeriiog Gotchas

Gotcha 63: Misplaced semicolons after decision statements

Gotcha: Statements in my i/O decision execute, evenwhen the condition is not
true.

Synopsis: A semicolon after the closing parenthesis ofa decision statement is
legal, andcauses thestatements thatshouldbe within the i/O to be outside the
i/O·
A semicolon ( ; ) by itself is a complete programming statement, representing a
null-operation statement. A misplaced semicolon after if is legal. However, the
misplaced semicolon can cause the statement or begin...end group after the
misplaced semicolon to execute at timesthat werenot intended.

module foo;
reg a;
initial begin

a = 1;
if (a); II semicolon is wrong, but NOT syntax error

$display("'a' is true"); II GOTCHA! also prints when 'a'
II is false

end
endmodule

In the example above, thereis no syntax error. Thesemicolon is a legalstatement,
and is the only statement associated with the if condition. The $display
statement, though nicelyindented, is not part of the if statement. The $display
message prints every time, regardless of whether the variable a is true or false.
Gotcha!

The next example illustrates how a misplaced semicolon can lead to a syntax
error on a subsequent lineof code.

module bar;
reg a;
initial begin

a = 1;
if (a); II semicolon is NOT an error

$display{"'a' is true");
else II SYNTAX ERROR! 'else' does not

II follow 'if'
$display("'a' is false");

end
endmodule

The else line in the example above appears to be pairedwith the if statement.
However, the only statement in the if branchis the misplaced semicolon, which



Chapter 5: General Programming Gotchas 141

is a null statement. Therefore, the $display statement that follows is not part of
the if statement, which means the else statement is not paired with the if
statement. The compiler will report an error on the line with else, which is
actually two lines afterthe realproblem. Gotcha!

How to avoidthis Gotcha

This is an example of a gotcha that is inherited from the C language, from which
Verilog and SystemVerilog have their syntax and semantic roots. The same
coding mistakes illustrated above can be made in C. The way to prevent this
coding gotcha is to know Verilog syntax, and to correctly use semicolons.

A language-aware text editor, such as Emacs with a Verilog mode, can help to
avoid this gotcha. A good language-aware editor for Verilog can add auto
indentation. The examples above would have obvious indentation errors with
suchan editor. The first example, above, might be indented as follows:

initial begin
a = 1;
if (a);
Sdisplay("'a' is true"); II statement is not auto-indented

end



142 Verilog and SystemVeriiog Gotchas

Gotcha 64: Misplaced semicolons in for loops

Gotcha: Myfor looponlyexecutes one time.

Synopsis: A semicolon at the end ofa for loop declaration effectively makes
the loopalways execute just one time.

A semicolon ( ; ) by itself is a complete programming statement, representing a
null-operation A misplaced semicolon after for is syntactically legal. However,
the misplaced semicolon has the effect of making the loopappearto execute only
one time.
module foo;

integer i;
initial begin

for (i=O; i<=15; i=i+l); II semicolon is NOT an error
begin

$display("Loop pass executing"); II GOTCHA! only executes
II once

end
end

endmodule

In the example above, there is no syntax error. Thesemicolon is a legal statement,
and is the only statement within the for loop. The begin...end group with the
$display statement is not part of the for loop. The loopwill execute 16 times,
executing a null statement. Afterthe loophas completed, the group of statements
that appear to be inside the loop-but which are not-will execute one time.
Gotcha!

This gotcha can alsooccurwithwhile, repeat, forever and foreach loops.

Looping multiple times executing a null statement is not necessarily a coding
error. A common verification coding style is to use a null statement in a repeat
loop, in orderto advance multiple clockcycles. For example:
initial begin

reset_n <= 0;
repeat (8) @(posedge clock) II loop 8 clock cycles doing no-op
reset_n = 1;

end

How to avoidthis Gotcha

This gotcha is inherited from the C programming language, where the same
coding error is syntactically legal. A language-aware editor with auto-indenting
can help to avoid this gotcha. A goodVerilog editorwill showthe indentation to
be wrong for this code, which will indicate a misplaced semicolon.



Chapter 5: General Programming Gotchas 143

There is another gotcha with the for loop example above. Even though a null
statement in a for loop is legal code, some tools make it a syntax error. The
intent in making this an error is to help engineers avoid a common C
programming gotcha. Unfortunately, it also means that if the engineer actually
wanted an empty for loop, these tools do not allow what should be legal code.
The workaround, if an empty loop is actually intended, is to replace the null
statement with an empty begin...end statement group.



144 Verllog and SystemVeriiog Gotchas

Gotcha 65: Infinite for loops

Gotcha.· My for loop never exits. When the loop variable reaches the exit
value, the loop just startsoveragain.

Synopsis.' Declaring too small a for loop control variable can result in loops
thatneverexits.

A for loop executes its statements until the loop control expression evaluates as
false. As in mostprogramming languages, it is possible to writea for loop where
the control expression is always true, creating an infinite loop that never exits.
This general programming gotcha is more likely to occur in Verilog, because
Verilog allows engineers to define small vector sizes.

The intent in the following example is to loop 16 times, with the loop control
variable having a value from 0 to 15.
reg [3: 0] i; II 4-bit loop control variable
for (i=O; i<=lS; i=i+l) II GOTCHA! i<=15 is always true

begin 1* loop body *1 end

In thisexample, the loopwillrununtil i is incremented to a value greater than 15.
But, as a 4-bitvariable, when i has a value of 15 and is incremented, the result is
0, which is lessthanor equal to 15. Theloopcontrol testwillbe true, andthe loop
will continue to execute, starting overwith i equal to O.

How to avoidthis Gotcha

A simple way to avoid this gotcha is to increase the size of the loop control
variable so that it can hold a larger value. Typically, either integer (a Verilog
type) or int (a SystemVerilog type) should be used as loop control variables,
both of which are 32-bitsigned variables.

With SystemVerilog, the loop control variable canbe declared as part of the for
loop. This puts the loop control variable declaration and usage of the variable in
the same lineof code, making typeor sizeof the variable moreobvious.
reg [3:0] result; II 4-bit design or test variable
for (int i=O; i<=15; i=i+l) II OK, i can have a value greater

II than 15
@(posedge elk) result = i; II OK, but mismatch in assignment

II sizes

The difference in size of the loop control variable and the value to which it is
assigned can result in a warning. Theassignment is still correct. The lower 4 bits
of i are assigned to resul t, and the remaining bits are truncated. To prevent the
warning message, explicitly select the lower bits of i, as in resul t = i [3: 0] ..



Chapter 5: General Programming Gotchas 145

Gotcha 66: Locked simulation due to concurrent for loops

Gotcha: When I run simulation, myfor loops lock up or do strangethings.

Synopsis: Parallelfor loops that use the same control variable can interfere
with each other.

Verilog has two programming constructs that can invoke parallel execution
threads withinthesamescope: multiple combinational always procedural blocks
that trigger at the same time, and fork ... join statement groups. Parallel threads
running in the samenamespacecan interfere witheachother if they shareany of
the same storage variables. The following example illustrates a simple testbench
that forks off two tests to run in parallel. Eachtest contains a for loopthatusesa
variable called i as the loop control. One loop increments i, and the other loop
decrements i.

program automatic test;
logic [7:0] a, b, c, sum, dif;
int i; II GOTCHA! shared loop variable

adder subtractor dut (.*);

initial begin
fork

begin: add_test
for (i = 0; i < 10; i++) begin II increment i

a = i;
b = i + 10;
#10 $display("At %Od, in scope %m: i=%Od sum=%Od",

$time, i, sum);
end

end

begin: dif_test
for (i = 8; i > 2; i--) begin II decrement i

c = i;
#10 $display("At %Od, in scope %m: i=%Od dif=%Od",

$time, i, dif);
end

end
join
$display("\nTests finished at time %Od\n", $time);
$finish;

end
endmodule

The intent of this example is that, after both loops complete, $ f ini sh is called
and simulation exits. One loop should execute 10 times, and the other 6 times.
Instead of completing, however, simulation locks up, and neverexits. The reason



146 Verilog and SystemVeriiog Gotchas

is that each loop is changing the same control variable, preventing either loop
from everreaching a value thatwillcause the loop to exit. Gotcha!

How to avoidthis Gotcha

The way to correct this problem is to use different variables for each loop. The
simplest way to do this is to use the SystemVerilog feature of declaring a local
variable as part of eachfor loop.

initial begin
fork

begin: add_test
for (int i = 0; i < 10; i++) begin II i is local variable

end
end

begin: dif_test
for (int i = 8; i > 2; i--) begin II i is local variable

end
end

join



Chapter 5: General Programming Gotchas 147

Gotcha 67: Referencing for loop control variables

Gotcha: My Verilog code no longer compiles after I convert my Veri/og-style
for loops to a System Verilog style.

Synopsis: Loop control variables declared as part of a for loop declaration
cannotbe referenced outside ofthe loop.

Verilog requires that loopcontrol variables be declared before the variable is used
in a for loop. Since the variable is declared outside the for loop, it is a static
variable that can alsobe usedoutside the for loop.
reg [31:0] a, b, c:
integer a[0:31], b[0:31], c[0:31]; II arrays of 32 elements
integer i; II static loop control variable
initial begin

for (i=O; i<=31; i=i+l) begin
c[i] = a[i] + b[i]; II OK to reference i inside of loop

end
$display (" i is %Od", i) i I I OK to reference i outside of loop

end

SystemVerilog allows declaring for loopcontrol variables within the declaration
of the loop. Theseare automatic variables that are localto the loop. The variable
is dynamically created when the loop starts, and disappears when the loop exits.
Because the variable is automatic, it is illegal to reference the variable outside of
the scope in which it exists. The following codecauses a syntax error:
reg [31:0] a, b, c;
initial begin

for (int i=O; i<=31; i=i+1) begin II i is automatic variable
c[i] = a[i] + b(i]; II OK, i is used inside the loop

end
$display (" i is %Od", i); I I GOTCHA' i is used outside of loop

end

How to avoidthis Gotcha

Technically speaking, this is not a gotcha, because it is a syntax error, ratherthan
an unexpected run-time behavior. However, there are times when it is useful to
reference loop control variables outside of the loop, In those situations, the loop
variable should be declared outside of the loop, using the Verilog coding style
shown in the first example above.



148 Verilog and SystemVeriiog Gotchas

Gotcha 68: Default function return size

Gotcha: Myfunction onlyreturns the least significant bitofthereturn value.

Synopsis: Verilog functions have a default return type of l-bit logic, if no
return typeis specified.

The function listedbelowadds two integer values together and returns the result.
However, this example will add 3 and4, and return a resultof 1 instead of7.

module test;
int result; II 32-bit variables

function sum (int a, b); II no return size specified
return (a + b);

endfunction

initial begin
result = sum(3,4); II GOTCHA! 32-bit result is always 0 or 1
$display("sum(3,4) return = %h (hex)", result);

end
endmodule: test

This test casewill print:
sum(3,4) return = 00000001 (hex)

Non-void functions return a sized, typed value. If the typeor size is not specified,
the default return type is logic and the default return size is scalar (I-bit). If
within the function, a multi-bit vector is specified as the return from an unsized,
typedfunction, then all of the upperbits of the vectorare truncated without error
or warning, and only the least significant bit of the vector is actually returned.
Gotcha!

If a function returnvalueis assigned to a variable, thenthe Verilog/SystemVerilog
assignment rulescome intoplay. These rules are discussed in Gotcha 46 on page
105. In brief, if the I-bit function return is assigned to a variable that is more than
one bit wide, the return value will be zero-extended to the variable size, again
with no error or warning. This zero extension can hide the first gotcha of the
function return valuehaving beentruncated. Gotcha, again!

Howto avoidthis Gotcha

Toavoidthis gotcha, an explicit return size or typeneedsto be specified. A good
coding guideline wouldbe to always specify the function return type, evenwhen
a I-bit return is desired. Some example function declarations with a return type
and/orreturn size specified are:



Chapter 5: General Programming Gotchas 149

function int suml (int a, b) ; II return int type (32-bit)

function [15: 0] suml (int a, b) ; II return 16-bit logic type

function logic suml (int a, b)i II return I-bit logic type

function bit [31:0] suml (int a, b) ; II return 32-bit bit type

function real suml (int a, b) ; II return real type

Since this gotcha of not specifying a function return type andsize is legal code, it
is not easy to detect this gotcha without debugging simulation results. Lint tools
(coding stylecheckers) might be ableto check thatfunctions always havea return
type defined. If the function return is being assigned to a variable, lint checkers
can also check for assignment size mismatches. Most synthesis tools will
generate a warning message when there is an assignment mismatch. In the gotcha
example above, a warning suchas thismight help make it more obvious that the
function return is a different sizethanwhatwasexpected.

An additional way this gotcha might be detected is by using a language-aware
text editor. The editor' used for testing the example above changed the color of
the function identifier when the function hada return typeandsizespecified. Asa
designer becomes familiar withsucheditors, gotchas (orbugs) suchas thiscanbe
identified while writing the code.

I. Theeditorusedwas Emacs withthe Verilog mode from www.verilog.com



150 Verilog and SystemVeriiog Gotchas

Gotcha 69: Task/function arguments with default values

Gotcha.· I get a syntax error when I try to assign my task/function input
arguments a default value.

Synopsis: Task/function argument directions are inherited from the previous
argument, and only inputand inoutarguments can havea default value.

The formal arguments of a task or function can be input, output, inout, or
ref. In SystemVerilog, task/function arguments default to input ifno direction
has been specified. However, the direction is sticky, so that, once it has been
specified, it affects all subsequent arguments untila newdirection is specified.

SystemVerilog allows input and inout arguments of a task or function to be
specified with a default value. When the task or function is called, a value does
not needto be passedto formal arguments that havea default value.

The following function header gets a compilation error because the second
argument, start, has a default valuespecified.
function automatic int array_sum(ref int all, int start=O);

for (int i=start; i<a.size(); i++)
array_sum += a[i));

endfunction

Only input and inout arguments can have a default value. The problem with
this code is that the start argument does not have a direction explicitly
specified. If no directions at all had been specified, s tart would default to an
input argument, whichcan have a default value. In this example, however, the
first formal argument of the function, a [ ] , has been defined with a direction of
ref. Thisdirection is sticky. It alsoapples to start. Assigning a default value to
a ref argument is illegal.

How to avoidthis Gotcha

Toavoida direction gotcha, specify a direction for all task/function arguments.
function int array_sum(ref int a[), input int start=O);

The example shown in this section only causes a compilation error because
start has a default assignment, which is illegal for ref arguments. Sticky
argument directions can cause other subtle programming gotchas that are not
compilation errors.



Chapter 5: General Programming Gotchas 151

Gotcha 70: Continuous assignments with delays cancel glitches

Gotcha: Some delayed outputs show up with continuous assignments and
others do not.

Synopsis: Continuous assignments with delays will cancel input glitches.

Continuous assignment statements are continuously running processes that
transfer an expression from the right-hand side to a net or variable on the left­
hand side. Designers frequently use continuous assignments to model
combinational logic behavior. In a synthesizable RTL model, continuous
assignments are typically written to use zero delay. When the right-hand
expression changes, the left-hand net or variable is immediately updated. In a
testbench or bus-functional model, it is sometimes desirable to add a propagation
delaybetween the right-hand expression change and when the left-hand sidenet
or variable is updated.

Theintent in the following example is to generate twodelayed version of a clock.
module clock_gen;

timeunit Ins; timeprecision Ins;

logic clockO, clock3, clock6;

initial begin
clockO <= 0;
forever #5 clockO = ~clockO;

end

assiqn #3 clock3 = clockO II OK, clock3 works as expected

assign #6 clock6 = clockO II GOTCHA! clock6 flat lines
initial begin

$time forma t (- 9 , 0, " n5", 7);
$monitor("%t: clockO = %b clock3 = %b clock6 %b",

$time, clockO, clock3, clock6);
#30 $finish;

end
endmodule: clock_gen

The output of the example above is:
Ons: clockO 0 clock3 = x clock6 = x
3ns: clockO 0 clock3 0 clock6 = x
5ns: clockO 1 clock3 0 clock6 = x
8ns: clockO 1 clock3 1 clock6 = x

IOns: clockO 0 clock3 1 clock6 = x
13ns: clockO 0 clock3 0 clock6 = x
15ns: clockO 1 clock3 0 clock6 = x
18ns: clockO 1 clock3 1 clock6 = x



152 Verilog and SystemVeriiog Gotchas

The outputs show that clockO toggles every 5 nanoseconds, as expected. The
delayed clock3 changes 3 nanoseconds after clockO just as it should. The
delayed clock6, which is functionally generated in exactly the same manner as
clock3, but witha 6 nanosecond delay, never changes value. Gotcha!

How to avoidthis Gotcha

The reason clock3 changes, but clock6 does not, is that continuous assign
statements use an inertial delay mechanism to propagate value changes. This
means that if two or more changes are scheduled on the left-hand side net or
variable (in essence, the output) of the continuous assignment, thenonlythe last
scheduled change actually occurs. In otherwords, each scheduled change cancels
anyearlier scheduled changes thathave notyet occurred.

The 3 nanosecond delay for clock3 is less than the 5 nanosecond half-cycle of
clockO, and so all changes on clockO propagate through to clock3. But, the 6
nanosecond delay for clock6 is greater than the 5 nanosecond half-cycle of
clockO, so all changes on clockO do notpropagate through to clock6.

To avoid this gotcha, clock6 needs to be modeled using a transport delay
mechanism, instead of inertial delay mechanism. Thesimplest wayto do this is to
use an always procedural block with a nonblocking intra-assignment delay, as
follows:

always @(clockO)
clock6 <= #6 clockO; II OK, 6ns intra-assignment delay

Primitive delays andnet delays also use inertial delay propagation, andwillhave
the same gotcha as continuous assignments. Verilog's specify block pin-to-pin
pathdelay construct canbe defined to use either inertial delay or transport delay.
This construct would be overly complex for the intended logic of this example,
however.

For more details on how to model inertial and transport delays using Verilog
procedural blocks, refer to a paper from one of the authors, "Understanding
Verilog Blocking and Nonblocking Assignments:",

I. Understanding Veri/og Blocking andNonblockingAssignments, byStuart Suth­
erland. Published in the proceedings of International Cadence Users Group,
SanJose, 1996. Alsoavailable at from theauthor's website, http://www.suth­
erland.com/papers.html



Chapter 6
Object OrientedandMulti­

ThreadedProgramming Gotchas

Gotcha 71: Programming statements in a class

Gotcha: Some programming code in an initialprocedure compiles OK, but
when I movethe code to a classdefinition, I get compilation errors.

Synopsis: Class definitions can onlyhaveproperties (variables) and methods
(tasks andfunctions). They cannot haveprocedural programming statements.

The Bar class definition below constructs a Faa object, and attempts to initialize
the variable i within Foo:

class Faa;
int data; II property

function int get ( ... ); II method

endfunction
task put ( ... );

endtask
endclass

class Bar;
Faa f = new; II create object f
f.data = 3; II GOTCHA! illegal assignment statement

endclass

Note: the code examples in this chapterare contrived in order to illustrate each gotcha using small
examples. In realdesign andverification code,thesegotchas mightnotbe as obvious or easyto debug.



154 Verilog and SystemVeriiog Gotchas

This example causes a compilation error, because any executable code in a class
must be in a task or function. A class is a definition, and cannot contain
assignment statements, programming statements, initial blocks or always
blocks. The assignment f. data = 3; in the example above is an executable
statement that is not in a taskor function, and therefore not allowed.

How to avoid this Gotcha

The fix for this gotcha depends on whenclass Bar needs to assign a value to the
data in a Faa object. If the assignment only needs to occur once when a Faa
object is constructed, a simple fix is to initialize da ta, using Faa's constructor
function, as follows:

class FOOi
int data;
function new (int d);

this.data = d; II assign to data at time of construction
endfunction

endclass

class Bar;
Foo f = new(3) ; II pass initial value to new method of Foo

endclass

If Bar needs to assign to the data variable at any time, the fix is to add a method
in Bar that contains the assignment statement. All programming statements
withina classdefinition mustbe within tasksor functions:
class FOOi

int data;

endclass

class Bar;
Foo f = new;

function change_data(d); II assign to data after construction
f.data = d;

endfunction
endclass

Guideline: It is legal to call a constructor as part of the declaration of a class
handle variable within another class(e.g. Fao f = new; in the example above).
However, this is discouraged, as the object willbe constructed before anycodein
the enclosing classhas beenexecuted. This can cause problems if there is a need
to create or initialize objects in a specific order. It is usually preferable to call
such constructors in the constructor of the enclosing class, where there is more
control over the initialization.



Chapter 6: Object Oriented and Multi-Threaded Programming Gotchas 155

Gotcha 72: Using interfaces with object-oriented testbenches

Gotcha: I get a compilation error when I try to usea classobject to create test
values when the testbench connects to thedesign usingan interface.

Synopsis: Static structural components, such as interfaces, cannot be directly
driven from dynamic code.

In the following example, the Driver class, which is a dynamic object, needs to
drive data into the arb_ ifc interface, which is a static design object. Since a
dynamic object cannot directly drive static objects such as a module or an
interface port, this codeis illegal.

interface arb_ifc(input logic clk};

endinterface

program automatic test (arb_ifc.TEST arb);

class Driver;
arb_ifc arb; II GTOCHA! class cannot instantiate interface

function new(arb_ifc arb); II GOTCHA! tasklfunc arg cannot
II be an interface

this.arb = arb;
endfunction

endclass

initial begin
Driver di
d = new(arb};

end
endprogram

Howto avoidthis Gotcha

An interface is a structural component that represents hardware. It can contain
signals, code, and assertions. Structural components cannot be passed around for
use by dynamic code. Instead, a pointer to the interface is used in the dynamic
class object. A pointerto an interface is calleda virtual interface. The purpose of
a virtual interface is to allow dynamic objects to have a handle to a statically
instantiated object, and to movedatabetween a dynamic class object and a static
object.

The correctway to model the example above is to make the arb_ifc instance in
the driverclassvirtual.



156 Verilog andSystemVerllog Gotchas

class driver;
virtual arb ifc arb; II pointer to interface

function new(virtual arb_ifc arb); II pointer to interface
this.arb = arb;

endfunction
endclass

Virtual interfaces are the bridge orlink between the class-based testbench and the
Device Under Test (DUT).



Chapter 6: Object Oriented and Multi-ThreadedProgramming Gotchas 157

Gotcha 73: All objects in mailbox come out with the same values

Gotcha: My codecreates random objectvalues andputs them intoa mailbox,
but all the objects coming out ofthe mailbox have thesame value.

Synopsis: The classconstructor creates a handle to an object. In orderto have
multiple objects, the classconstructor mustbe calledmultiple times.

Mailboxes are used to synchronize activity between parallel processes, and to
pass information between theprocesses during the synchronization.

The intent in the following example is to put 10 random object values into a
mailbox:
class My_class;

rand int data;
rand logic [47:0] address;

endclass

My_class h = new; II Gotcha' construct one My_class object
repeat(lO) begin

h. randomi ze () ; II randomize properties in the object
mbx.put(h); II store handle to object in a mailbox

end

The threadthat retrieves the objects from themailbox will findthat all the objects
contain thesamevalues, theonesgenerated by the lastcall to randomize. Gotcha!

The gotcha happens because the code only constructs one object, and then
randomizes it overand over. Themailbox is full of handles, but theyall refer to a
singleobject.

How to avoidthis Gotcha

In order to randomize multiple objects, they must first be constructed. In the
example above, the call to the constructor should be inside the loop:
my_class h;
repeat (10) begin

h = new; II construct a My_class object
h. randomi ze () ; II randomize properties in the object
mbx , put (h) ; II store handle to object in a mailbox

end



158 Verilog and SystemVeriiog Gotchas

Gotcha 74: Passing handles to methods using input versus ref arguments

Gotcha: My methodconstructs and initializes an object, but I can neversee
the objectsvalue.

Synopsis: Method input arguments create local copies ofvariables that are
not visible in the callingscope.

The default direction of method (task and function) arguments is input. Inputs
create local variables for use within the method. When a method is called, the
values of the actual arguments are copiedinto the local storage. Any changes to
this local storage that are made within the method are not passed back to the
callingscope.

The intent of the following function is to construct two objects and assign the
objecthandles to the handlevariables passedinto the function.
function void build_env(Consumer c, Producer p); II GOTCHA!

c = new(); II construct object and store handle in c
p = new(); II construct object and store handle in p
... II set up rest of environment

endfunction

initial begin
Consumer c;
Producer p;
build_env(c, p); II construct and set up objects

c.randomize; II ERROR: c does not contain an object handle
end

The code that calls the build env function will not be able to see the
constructed objects because the function argument directions are not specified,
and therefore default to input. Within the function, c and p are local variables.
The new handles that are storedin the local c and p variables are not passedback
to the code thatcalled the b u i 1denv function.

How to avoidthis Gotcha

In a method that constructs objects, declare the handle arguments as ref. A ref
argument is a reference to storage in the calling scope of the method. In the
declaration below, whenthe method constructs an objectand stores the handles c
and p, the code that calls build_env will see the new handles, because
build_ env is changing the storage in the calling scope.

function void build_env(ref Consumer c, ref Producer p)i



Chapter 6: Object Oriented and Multi·Threaded Programming Gotchas 159

Gotcha 75: Constructing an array of objects

Gotcha: I declared an array ofobjects, but get a syntax error when I try to
construct the array.

Synopsis: An "arrayofobjects" is actually an array ofobject handles. Each
handlemust be constructed separately.

It is oftenuseful to declare an array of object handles, in orderto storehandles to
multiple objects. Such an array is oftencalled an"arrayof objects". In reality, it is
an array of handles, not an array of actual objects.

The following example attempts to create an array to hold8 objects, but the code
does not work.
class Transaction;

endclass

initial begin
Transaction trans[8]; II An array of 8 Transaction objects

trans = new; II ERROR: cannot call new on object array
trans = new[8]; II ERROR: cannot call new on array element

end

This example will get compilation errors. Bothcallsto the constructor for trans
are syntactically incorrect. The reason is that t ran s is the name of an array, not
thenameof a handle variable.

How to avoid this Gotcha

Eachobject in the array of handle variables mustbe constructed individually, and
its handle assigned to an element of the array. The correct way to code the
example above is:
initial begin

Transaction trans[8]; II An array of 8 Transaction objects
foreach (trans[i])

trans[i] = new(); II Construct object and store handle in array
end



160 Verllog and SystemVeriiog Gotchas

Gotcha 76: Static tasks and functions are not re-entrant

Gotcha: Mytaskworks OKsometimes, butgets bogus results other times.

Synopsis: Invoking a static task or function while a previous call is still
executing maycause unexpected results.

In Verilog and SystemVerilog, tasks and functions are static by default, which is
different from C, where functions are automatic by default. This difference is
important! In static tasks and functions, any local storage, including input
arguments, areshared by every callto the taskor function. In an automatic taskor
function, new storage is created for eachcall,which is unique to just that call. A
default of static tasks and functions generally works well when modeling
hardware, because storage within hardware is static. A testbench, on the other
hand, is more of a software program rather thanhardware.

Verilog/SystemVerilog's default static storage can cause unexpected behavior if a
verification engineer is expecting C-like programming behavior. Static storage is
particularly evident in tasks that are used for verification. Tasks can take
simulation timeto execute. Therefore, it is possible fora taskto be invoked while
a previous call to the task is stillexecuting, as is illustrated below.

In the following example, a task called watchdog is calledwhen the test issues
an interrupt request. The task delays for some number of clock cycles, and then
prints out a time out error if the interrupt is not acknowledged. The interrupt
number and number of cycles to count are passed in as inputarguments. The test
codecalls this tasktwice, in parallel, for twodifferent interrupt requests.
program test (input logic clock,

input logic [1:0] ack,
output logic [1:0] irq);

initial begin: irs_test
$display(nForking off two interrupt requests ... n);
fork

watchdog (0,20): II must receive aok[O] within 20 cycles
watchdog (1, 50); II must receive ack[l] within 50 cycles
begin

irq[O] = l'b1;
irq[l] = l'b1;
wait (ack)
$display("Received ack at %Od, disabling watChdog", $time};
disable watchdog; II got ack; kill both watchdog tasks

end
join_any
$display("\At %Od, test completed or timed out", $time};
$finish; II abort simulation

end: irs test



Chapter 6: Object Oriented and Multi-ThreadedProgramming Gotchas 161

task watchdog (input int ir~num, II GOTCHA! static storage
input int max_cycles II GOTCHA! static storage

) ;
$display("At %Od: Watchdog started for IRQ[%Od] for %Od cycles",

$time, irq_num, max_cycles);
repeat (max_cycles) @(posedge clock) II delay until max cycles

II reached
$display("Error at %Od: IRQ[%Od] no after %Od cycles",

$time, irq_num, max_cycles);
endtask: watchdog

endprogram: test

This example will run, but not as desired. The secondcall to the watchdog task
will overwrite the irq_num and max_count values being used by the first call.
The first call is still running, but nowhas incorrect values. Gotcha!

How to avoid this Gotchausing Verilog

In Verilog, all storage in a task or function can be made automatic by adding the
keyword automatic to the task or function declaration.

task automatic watchdog ( ... II automatic storage

An automatic task or function is also referred to as a re-entrant task or function.
The task or function can be invoked (or entered) while previous calls are still
executing. Eachcall creates newstorage that is localtojust thatcall.Theexample
above illustrated a re-entrant task. Another example is recursive function calls,
which must also be declared as automatic, so that the function can be re-entered
without affecting the storage of already activecalls to the samefunction.

How to avoid this GotchausingSystemVerilog

SystemVerilog allows the automatic keyword to be specified as part of the
declaration of a module, interface, or program. The gotchaabovecan be fixedby
changing the program declaration to:
program automatic test { ... )i

task watchdog ( ... II OK, automatic storage

By adding the automatic keyword to the program declaration, all tasks and
functions withinthe program will be automatic by default. Thismakesthe default
behavior like C, where all functions automatic by default. Note that tasks and
functions declared in class definitions are automatic by default, unless explicitly
declared as static.

See Gotcha7 on page 22 for coding guidelines on declaring programs, packages
and interfaces as automatic.



162 Verilog and SystemVeriiog Gotchas

Gotcha 77: Static versus automatic variable initialization

Gotcha: The variables in my testbench do not initialize correctly.

Synopsis: By default, variables in tasks andfunctions contained in interfaces,
packages, andstatement groups arestatic, unlike C andC++. Static variables
only initialize one time.

Many verification engineers have a strong programming background, and may
expect verification programs to use automatic storage. That is, the variables will
be stored on a stackand initialized when theblock is entered.

In the following example, a local variable called addr is declared within an if
decision. This local addre s s variable is initialized to the value of the addres s
bus that is in an interface portcalled bus.

interface bus_ifc;

logic [31:0] address;

endinterface

program monitor (bus_ifc.MONITOR bus);
initial begin

@(posedge bus.cb.grant);
if (bus.cb.command == READ) begin

logic [31:0] addr = bus.cb.address; II GOTCHA! addr will be X
$display("Bus addr = %h", addr);

end
end

endprogram

In this example, no matter what the current value of addre s s in the interface is
when the if statement executes, the local addr variable willalways have a value
of X. Gotcha!

The intentof the function in the next example is to print the largest value of the
array.
program sums;

function void maxx(ref int a[]);
int max = a[O]; II local variable
foreach (a[i])

if (a[i] > max) max = a[i];
$display ("Max value is %Od", max); II GOTCHA!

end function

endprogram



Chapter 6: Object Oriented and Multi-ThreadedProgramming Gotchas 163

In this example, onlythe firstcallproduces the rightresult. Latercallsprinteither
the largest valueor the result from the previous call. Gotcha!

The problem in both of these examples is that tasks, functions, andbegin...end
blocks use static storage by default. Static variables are allocated and initialized
once, at compilation time. In the first example above, addr is initialized to the
value of address, but, at the time the static storage is created, address has a
valueof X. When the if statement is executed during simulation, the staticaddr
variable is not re-initialized, and hence always has its original initial value of X.
Gotcha!

In the second example above, the local variable max is statically allocated and
initialized to the value of a [0] one time when the storage is created. Every
subsequent call to the function does not re-initialize max. Since max is not re­
initialized, it contains the value of the previous call to the function. When the
array is searched, if a larger value is found, max will be correctly updated to this
new largest value. If a larger value is not found, however, the value of max will
not be the largest current value in the array. It will be the largest value found the
previous timethe function wascalled. Gotchal, again

How to avoidthis Gotcha

To avoid this gotcha, variables that need to be re-initialized each time the
procedural block, task or function is entered need to be automatic variables.
Threeways to do this are:
• Explicitly declare specific variable as automa tic.
• Tasks and functions can be declared as automatic, making all variables

within the taskor function automatic by default.
• Program, module, interface and package definitions can be declared as

automatic, making all variables within declared within tasks, functions,
within procedural blocks automatic by default

For the two examples above, the static storage gotcha can easily be avoided by
declaring the programs as automatic.
program automatic monitor;

program automatic sums;

See Gotcha 7 on page 22 for coding guidelines on declaring programs, packages
and interfaces as automatic.



164 Verilog and SystemVeriiog Gotchas

Gotcha 78: Forked programming threads need automatic variables

Gotcha: When I fork off multiple tests, I get incorrect results, but each test
runs OK by itself.

Synopsis: Concurrent threads can have conflicts with sharedvariables, such
as indices.

Whena test program spawns multiple concurrent test threads, it is important that
each threadhave its own storage. Otherwise, one thread could interfere with the
storage beingusedby another thread.

The following example spawns three concurrent threads using a for loop that
contains a fork...join_none block. The join_none is important; it is what
allows three concurrent threads to be spawned. If join had been used, each
threadwould run to completion before the next thread couldstart. It is a common
verification requirement to spawn concurrent threads, as in this example, rather
thansequential threads.

Each concurrent thread in this example uses the loop control variable as a
thread_id number. the thread_ id is used to index intoan arrayof data.
program automatic test (input logic clock);

int d_array[3] = , {10,11,12};
initial begin

for (int thread_id=O; thread_id<3; thread_id++)
fork

$write(" thread_id=%Od It, thread_id}; II GOTCHA!
$display ("d_array [thread_idl =%Od",

d_array[thread_id]); II GOTCHA!
join_none II don't wait for each fork to complete

#10 $finish;
end

endprogram

The expected results from thisexample are
thread_id=O d_array[thread_idl=10
thread_id=l d_array[thread_idl=ll
thread_id=2 d_array[thread_idl=12

Whensimulation runs,however, themessages printed are not as expected.
thread id=3 d_array[thread_idl=O
thread id=3 d_array[thread_idl=O
thread id=3 d_array[thread_idl=O

Gotcha!



Chapter 6: Object Oriented and Multi-ThreadedProgramming Gotchas 165

The gotcha in this example that thread_ id variable is declared outside of the
fork...join_none block, which means that every forked thread shares the same
thread_ id variable, instead of having a unique variable for each thread. Since
the threads are invoked from within a fork...join_none, all three threads are
scheduled to start concurrently. The threads do not actually start running,
however, until the for loop completes. When the for loop completes,
thread_ id is 3, and that is thevalue usedby eachthread. Gotcha!

Where did the valueof0for what is readout ofd_arraycomefrom? Thed_array
is storing int values, which are 2-state data types. When an out-of-bounds access
occurs with 2-state arrays, a value of 0 is returned. This can hide functional
errors, which is a gotcha described in Gotcha 40 on page 90. Had this example
onlybeenprinting, or just using, thevalue readfrom d_array and notprinting the
index value, thecodeproblem would have beenveryobscure. Gotcha, again!

Howto avoidthis Gotcha

When storage is required within a concurrent thread, each thread needs to define
its own local storage. This is done by defining automatic variables within each
thread. Thefollowing example works correctly.
program test (input logic clock);

int d_array[3] = '{10,11,12};
initial begin

for (int i=O; i<3; i++)
fork

automatic int thread_id = ii II local var for each thread
$write{"thread_id=%Od ", thread_id);
Sdisplay("d_array[thread_id]=%Od",

d_array[thread_id]); II OK
join_none II don't wait for each fork to complete

#10 Sfinish;
end

endprogram

What if thread_id had not been declared as automatic? The default lifetime of
local variables is static. A static thread id would havebeen initialized onceat
the very beginning of simulation, and not re-initialized for each pass of the for
loop. Thiscommon coding erroris described in Gotcha 77 on page 162. To avoid
that gotcha, the default lifetime of local variables in test programs should be
changed to automatic, as follows:
program automatic test (input logic clock); II default storage

II is automatic

See Gotcha 7 on page 22 for coding guidelines on declaring programs, packages
and interfaces as automatic.



166 Verilog and SystemVeriiog Gotchas

Gotcha 79: Disable fork kills too many threads

Gotcha: When I execute a disable fork statement, sometimes it kills threads
that are outsidethe scope containing the disable fork statement.

Synopsis: The disable fork statementkills all threads startedfrom the current
thread.

The disable fork statement stops all active threads that were spawned from
the currentthread. The problem is that this may accidentally stop threads outside
the scopeof the codethat contains the disable.

The following example calls the do_action task, and then calls the
start_a_thread task twice, to spawn two threads with delays of 10and 30. It
then waits a short time and doesa disable fork, which stops the two threads.
However, this also unintentionally stops the s tart_a _thread thread that was
started from the do action task. Gotcha!
program automatic test;

task start a thread (int delay);
fork

begin
Sdisplay{"@%Od start_a_thread{%Od) - started",

$time, delay);
#(delay);
$display("@%Od start_a_thread(%Od) - complete",

$time, delay);
end

join_none
endtask

initial begin
do_action();
start_a_thread(lO);
start_a_thread(30);
#15· disable ~ork; / / GOTCHA!
#100; II w~it for all threads to complete

end

task do_action;
start_a_thread(20);

endtask

endprogram



Chapter 6: Object Oriented and Multi·Threaded Programming Gotchas 167

The simulation results from this test are:
@O start_a_thread(20) - started
@O start_a_thread(lO) - started
@O start_a_thread(30) - started
@10 start_a_thread(lO) - complete

Note that, in this output, thread 20 never completes, even though it was not
explicitly disabled. This is the Gotcha!

How to avoid this Gotcha

Always put a fork... join block around code that uses a disable fork to
createa firewall. Thiscreates a thread and limits the scope of thedisable fork
statement.

The example below changes the initial block by adding a fork ... join to
insulate the thread started from do_action () from the effect of the
disable fork.

initial begin
do_action{);
fork II isolate following statements as a separate thread

begin
start_a_thread(lO);
start_a_thread(30);
#15 disable fork; OK, only affects the fork ... join

end
join
#100; II wait for all threads to complete

end

The simulation results from thismodified test are:
@O start_a_thread(20) - started
@O start_a_thread(10) - started
@O start_a_thread(30) - started
@10 start_a_thread(10) - complete
@20 start a thread(20) - complete

Observe that thread 20 nowcompletes execution.



168 Verilog and SystemVeriiog Gotchas

Gotcha 80: Disabling a statement block stops more than intended

Gotcha: When I try to disable a statement block in one thread, it stops the
blockin all threads.

Synopsis: A disable block_name statement stops the execution of all blocks
with thatnamein all threads.

In the following example, the task start_test spawns a thread containing a
block named terminator. The task is called three times inside a module that is
instantiated three times in the top module. Thus, there are nine terminator
blocks running concurrently as nineseparate threads.

The intent of thiscodeis that the terminator blockdisables itselfif theblock is
in the second callof thesecond instance.

module test (input int instance_id);
initial begin

#1;
start_test (1 , instance_id); II three calls to task, with
start_test (2 , instance_id); II different thread numbers
start_test (3, instance_id);

end

task automatic start test (int thread, int inst);
fork : monitor

begin
Sdisplay("@%Od: %m inst: %Od, thread: %Od, before disable",

Stime, inst, thread);
#10;
if «thread==2) " (inst==2»

disable monitor; II GOTCHA! affects multiple threads
#1;
Sdisplay("@%Od: %m inst: %Od, thread: %Od, after disable",

$time, inst, thread);
end

join_none II don't wait for thread to complete
endtask: start test

endmodule: test

module top;
test tl (.instance_id(l)); II three instances of test module
test t2 (.instance_id(2));
test t3 (.instance_id(3));

endmodule: top



Chapter 6: Object Oriented and Multi-Threaded Programming Gotchas 169

The simulation outputfor this code is:
@ 1 : top.tl.start_test.monitor inst: 1, thread: 3, before disable
@ 1 : top.tl.start_test.monitor inst: 1, thread: 2, before disable
@ 1 : top.tl.start_test.monitor inst: 1, thread: 1, before disable
@ 1 : top.t2.start_test.monitor inst: 2, thread: 3, before disable
@ 1 : top.t2.start_test.monitor inst: 2, thread: 2, before disable
@ 1 : top.t2.start_test.monitor inst: 2, thread: 1, before disable
@ 1 : top.t3.start_test.monitor inst: 3, thread: 3, before disable
@ 1 : top.t3.start_test.monitor inst: 3, thread: 2, before disable
@ 1 : top.t3.start_test.monitor inst: 3, thread: 1, before disable

@12: top.tl.start- test.monitor inst: 1, thread: 3, after disable
@12: top.tl.start_test.monitor inst: 1, thread: 2, after disable
@12: top.tl.start- test.monitor inst: 1, thread: 1, after disable
@12: top.t3.start_test.monitor inst: 3, thread: 3, after disable
@12: top.t3.start- test.monitor inst: 3, thread: 2, after disable
@12: top.t3.start_test.monitor inst: 3, thread: 1, after disable

This outputshowsthat the moni tor blockstopsall threads in instance 2, notjust
thread2 of instance 2. Gotcha!

This gotchahappens because the labelmoni tor is the nameof the block, not the
nameof a specific thread. Disabling the blocknamestopsall activethreads of the
blocknamefor the module instance containing the block.

How to avoid this gotcha

The disable statement takes a static hierarchical name as its argument, which
can be a relative hierarchical name, as in the example above, or a full hierarchical
name. What is needed to avoid this gotcha and cancel just one thread is to
reference a specific call to the start_test task. However, the start_test
task above, is an automatic task. Automatic task calls do not have a static
hierarchical name. Therefore, specific instances of that task cannotbe referenced
to disable a specific thread.

In order to run all nine threads concurrently and yet have the ability to disable a
single thread, the concurrency must occur at the module instance level, and the
task mustbe static. This is shown in the codebelow:

module test (input int instance_id, input int thread_id);
initial begin

#1;
start_test (thread_id, instance_id); II one call to task

end



170 Verilog and SystemVeriiog Gotchas

task start_test (int thread, int inst); II static task
begin: monitor II named block (not forked threads)

$display("@%Od: %m inst: %Od, thread: %Od, before disable",
$time, inst, thread};

#10;
if «thread==2) " (inst==2»

disable monitor; II OK, only affects this thread
#1;
Sdisplay("@%Od: %m inst: %Od, thread: %Od, after disable",

$time, inst, thread);
end: monitor

endtask: start test
endmodule: test

module top;
test tl (.instance_id(I), .thread_id(I)}; II nine instances of
test t2 (.instance_id(l), .thread_id(2)}; II test module
test t3 (.instance_id(l), .thread_id(3»;
test t4 (.instance_id(2), .thread_id(I»;
test t5 (.instance_id(2), .thread_id(2»;
test t6 (.instance_id(2), .thread_id(3»;
test t7 (.instance_id(3), .thread_id(I»;
test t8 (.instance_id(3), .thread_id(2}};
test t9 (.instance_id(3), .thread_id(3}};

endmodule: top

The simulation output below shows all nine threads starting at time 1, and then
shows that only instance 2 thread 2 is removed after the disable. The remaining
threads for instance 2 are not disabled, and continue running.

@ 1 : top.tl.start_test.monitor inst: 1, thread: 1, before disable
@ 1 : top.t2.start_test.monitor inst: 1, thread: 2, before disable
@ 1 : top.t3.start_test.monitor inst: 1, thread: 3, before disable
@ 1 : top.t4.start_test.monitor inst: 2, thread: 1, before disable
@ 1 : top.t5.start_test.monitor inst: 2, thread: 2, before disable
@ 1 : top.t6.start_test.monitor inst: 2, thread: 3, before disable
@ 1 : top.t7.start_test.monitor inst: 3, thread: 1, before disable
@ 1 : top.t8.start_test.monitor inst: 3, thread: 2, before disable
@ 1 : top.t9.start_test.monitor inst: 3, thread: 3, before disable

@12: top.tl.start_test.monitor inst: 1, thread: 1, after disable
@12: top.t2.start_test.monitor inst: 1, thread: 2, after disable
@12: top.t3.start_test.monitor inst: 1, thread: 3, after disable
@12: top.t4.start_test.monitor inst: 2, thread: 1, after disable
@12: top.t6.start_test.monitor inst: 2, thread: 3, after disable
@12: top.t7.start_test.monitor inst: 3, thread: 1, after disable
@12: top.t8.start_test.monitor inst: 3, thread: 2, after disable
@12: top.t9.start_test.monitor inst: 3, thread: 3, after disable



Chapter 6: Object Oriented and Multi-Threaded Programming Gotchas 171

Gotcha 81: Simulation exits prematurely, before tests complete

Gotcha.· My simulation exits prematurely, before I call $jinish, and while
some testsarestill running.

Synopsis.' When allprogram blocks complete, Sfinish is implicitly called, even
if there is simulation activity still running.

Codethat models hardware design needs to run continuously, such as an always
block that triggers on every clock cycle. Verification code, on the other hand,
needs to finish execution after testing is complete. In Verilog, modules that are
used for testing must explicitly statewhentesting is finished, using the $finish
system task.

SystemVerilog addsa construct to encapsulate verification code, calleda program
block. Instead of using Verilog modules, program blocks are declared between
the keywords program...endprogram.
program automatic test II verification program
(output logic [63:0] test_data,
output logic reset_n,
input logic [63:0] results,
input logic test_clk

) ;
initial begin

reset_n <= 0;
@(posedge test_clk) reset n 1;
fork

testl task ( );
test2 task ( );

join
end II NOTE: not necessary to call $finish

endprogram

Unlike modules, program blocks do not need to run continuously. When the end
of a program block is reached, simulation will automatically finish, without the
need to automatically call $finish. If verification code is divided into multiple
program blocks, simulation automatically exits when the end of all program
blocks hasbeenreached.

In general, it makes senseto havesimulation automatically finish whentesting is
complete. In fact, having an implicit automatic finish solves a common gotcha in
Verilog of forgetting to explicitly call $finish at the end of test code. However,
there are some gotchas with this automatic termination. One gotcha occurs if
some test code is in program blocks, and other test code is in Verilog modules
(perhaps some legacy test code that was written in Verilog). Simulation will
automatically exit when the program blocks complete, even if otherverification



172 Verilog and SystemVeriiog Gotchas

code that is not in program blocks is still running. Another possible gotcha can
occurwhen the program block spawns parallel test threads, but does not wait for
those threads to complete. When the program block reaches its end, simulation
will automatically finish, even if the spawned threads are still running. Using
fork... join_any and fork...join_none, a testprogram can spawn off threads,
andnot wait for some or all of the threads to complete.
program automatic test ( ... );

initial begin
fork

test! task ( );
test2 task ( );

join_none
end II GOTCHA! simulation might exit before tasks finish

endprogram

How to avoid this Gotcha: The gotcha of an unexpected, automatic exit from
simulation can be avoided by suspending execution of the test program until all
testshave completed. If some tests are running in a Verilog module, the program
block can contain a wait statement or some other delay that waits or suspends
the testprogram until the testmodule hasreached its end. The testmodule canset
a flag, trigger and event, or use SystemVerilog semaphores to indicate that it has
completed. If the test program forks off verification threads, it can suspend until
all threads havecompleted, using a wait fork statement. For example:
program automatic test ( ... );

initial begin
fork

test! task ( );
test2 task ( );

join_none
wait fork; II waits for all spawned processes to complete

end II OK, can't get here until tasks finish
endprogram



Chapter 7
Randomization, Coverage and

Assertion Gotchas

Gotcha 82: Variables declared with rand arenotgetting randomized

Gotcha.· Some ofmy class variables arenotgetting randomized, even though
theywere tagged as randvariables.

Synopsis.' Properties must have a rand or randc tag, in order to be
randomized. This includes handles to otherobjects.

In order for object variable values to be randomized, each variable in the object
must be declared with a rand or randc tag. Random values are generated when
the object's . randomize method is called.

The following example has a Payload class, which has a property called data
that is tagged to be randomized. A Header class contains an addr property
which is tagged to be randomized, and a handle to a Payload object. When a
Header object is randomized, however, only addr gets a random value. The
payload da ta is not randomized, even though it has a rand tag.

Note: the code examples in this chapter are contrived in order to illustrate each gotcha using small
examples. In real design and verification code, these gotchas might not be as obvious or easy to debug.



174 Verilog and SystemVeriiog Gotchas

program automatic test;
class Payload;

rand int data[8]; II data is tagged to be randomized
endclass

class Header;
rand int addr; II addr is tagged to be randomized
Payload p; II handle to Payload object -- GOTCHA!

function new;
this.p = new;

endfunction
endclass

initial begin
Header h = new;
assert(h.randomize()); II randomize address and payload data
Sdisplay(h.addr); II addr shows random value
foreach (h.p.data[i])

Sdisplay(h.p.data[i]); II GOTCHA! data was not randomized
end

endprogram

The . randomize method only randomizes properties in the scope of the object
being randomized if the property is declared with a rand or randc tag. If the
property is a handle to another object, the tag must be specified for both the
handle and the properties in the child object. In the example above,
Header: : addr has been tagged with rand, so it gets updated with random
values. The payload object, Heade r: : p, however, is missing the rand modifier,
so none of its variables are randomized, even though Payload: : data has the
rand tag.

How to avoid this Gotcha

All objectvariables that are to haverandom values generated, including handles,
musthave the rand modifier.

class Header;
rand int addr; II addr is tagged to be randomized
rand Payload p; II OK, Payload is tagged to be randomized

endclass



Chapter 7: Randomization, Coverage and Assertion Gotchas 175

Gotcha83: Undetected randomization failures

Gotcha: My class variables do not get random values, even though I called
the randomize function.

Synopsis: The .randomize method returns an error status, and does not
randomize variables ifa constraint cannot be met.

It is possible to write constraints that cannot be solved under all conditions. If a
constraint cannot be met, then the variables are not randomized. The
. randomize method returns a 1 when the constraint solver succeeds in
randomizing the classvariables, anda 0 if it doesnot succeed.

The following example erroneously specifies a constraint, such that a must be
less than b, and b must be less than a. These randomization failures could go
undetected.

program automatic test;
class Bad;

rand bit [7:0] a, b;
constraint ab {a < b;

b < a;} II this constraint cannot be solved
endclass

initial begin
Bad b = new;
void' (b.randomize(»; II GOTCHA! return from method ignored

end
endprogram

If the success flag is not checked, the only symptom whena constraint cannot be
solved is that one or more class variables were not randomized. The failure to
randomize someclassvariables could go undetected. Gotcha!

How to avoidthis Gotcha

Use SystemVerilog assertions to check the return status of . randomize. The
method will return:
• I if successful in generating the random values
• 0 if unsuccessful in generating random values thatmet the constraints

In the example below, an assertion is used to test the return value if the
. randomize succeeded. The assertion fail statement defines an assertion failure
as fatal, whichwill abortsimulation or formal verification.



176 Verilog and SystemVeriiogGotchas

program automatic test;
class Bad;

rand bit [7:0] a, bi
constraint ab {a < bi

b < ai} II this constraint cannot be solved
endclass

initial begin
Bad b = neWi
assert(b.randomize(» else $fatal; II OK, checking if

II randomize fails
end

endprogram



Chapter 7: Randomization, Coverage and Assertion Gotchas 177

Gotcha 84: $assertoff could disable randomization

Gotcha: I usedan assertion to detectrandomization failures, and now nothing
gets randomizedduringreset.

Synopsis: The $assertoff assertion control will disable any statements
executedwithin the assertion.

When the. randomize method is called, it returns a value indicating the pass or
fail of the randomization. A common approach to monitor the return value from
the .randomization method is to use an immediate assert, as shown in the code
below.

program test;

Bustrans tr;

initial begin
tr = new;
$assertoff() ; II GOTCHA! disable all assertions during reset
rst_n <= 0;

assert (tr.randomize) else $display("randomization failed");

#10 rst n <= 0;
$asserton();

end
endprogram

The intent of the example above is to turn off assertions during reset, to prevent
false assertion failure messages. During reset, the object t r is randomized. But,
the properties of t r will not get randomized, during reset because the assert
statement calling tr. randomi ze is disabled. Gotcha!

How to avoid thisgotcha

There are a few ways to get around this gotcha. One is to use an i£...e18e,
instead of an assert statement, to check the return of the. randomize method.
Using this approach, however, means the. randomize call will not be included
in any assertion monitoring or assertion reports provided by the simulator at the
end of simulation.

A second way to avoid this gotcha is to not call $asserto££ on the scope
containing the calls to randomization. The $asserto£f task can be passed
hierarchical scope names, such as the name of the top-level of the design or a
specific module containing the assertions t be turned off.



178 Verilog and SystemVeriiog Gotchas

A thirdapproach is to add a labelto the assertion statement containing the call to
. randomize, and then tum that assertion back on immediately following the
$assertoff. For example:

program test;

Bustrans tr;

initial begin
tr = new;
$assertoff(); II disable all assertions during reset
$asserton(tr_rand); II OK, tr randomization turned back on
rst_n <= 0;

tr_rand: assert (tr.randomize)
else $display("randomization failed");

#10 rst n <= 0;
$asserton();

end
endprogram

A fourth way to avoidthis gotcha is to apply the . randomize callbefore or after
the reset is applied.

program test;

Bustrans tr;

initial begin
tr = new;

tr rand: assert (tr.randomize)
else $display("randomization failed");

$assertoff(); II OK, tr randomization already executed
rst_n <= 0;
#10 rst n <= 0;
$asserton();

end
endprogram

With this solution, if the call to the . randomize method is in a different process
than the call to $assertoff, it may be necessary to use some form of process
synchronization, to ensure that the randomization occurs before assertions are
turned off.



Chapter 7: Randomization, Coverage and Assertion Gotchas 179

Gotcha 85: Boolean constraints on more than two random variables

Gotcha: When I specify constraints on more than two random variables, I
don t get whatI expect.

Synopsis: In a series of two Boolean relational operators, the second
operation is compared to the trueljalse result oftheprevious operation.

The intent of the constraint in the class below is to randomize 10, med and hi,
such that 10 is less thanmed and med is less than hi, by using the expression
(10 < med < hi;).

class bad1;
rand bit [7:0] 10, med, hi;
constraint increasing { 10 < med < hi;} II GOTCHA!

endclass

A sampleoutputfrom running the codeabovelookslike this:

10 = 20, med = 224, hi 164
10 114, med = 39, hi 189
10 = 186, med = 148, hi 161
10 = 214, med = 223, hi 201

This constraint doesnot causethesolverto fail, but the randomized values are not
as expected. In line one, above, med is greater than hi. In lines two and three, 10
is greaterthanmed. In line four, both 10 and med are greaterthan hi.

The reason that the constraint does not work is that the Boolean less-than
expressions are evaluated from left to right. This means that the operation is not
comparing med to hi. It is comparing the true/false result of (10 < med) to hi.
The constraint above is evaluated as:

constraint increasing { (10 < med) < hi; }

The constraint is actually only constraining hi, such that hi has a value greater
than 0 or 1 (depending on the result of the test (10 < med). The variables 10
and med are randomized, but are not constrained. Gotcha!

The following example illustrates a similarproblem. This constraint is intended
to createvalues a, band c, suchthat the threeproperties have the samevalue.

class bad2;
rand bit [7:0] a, b, c;
constraint equal {a == b == c; }

endclass



180 Verilog andSystemVeriiog Gotchas

A sample output from running the code above gavethe following output:
a = 25, b 173, c = 0
a 65, b 151, c 0
a 190, b 33, c 0
a = 65, b 32, c = 0

A different simulator gives thisoutput:
a = 61, b 1, c = 0
a 9, b 9, c 1
a 115, b 222, c 0
a = 212, b 212, c = 1

The constraint is equivalent to: (a == b) == c. Random values are chosen for
a andb, andthenthose values aretested to seeif theyareequal. Variable c is then
constrained to be equal to the true/false result of (a == b), which is 0 or 1.
Gotcha!

Howto avoidthese Gotchas

Constraints involving compound Boolean operations should be broken down to
separate statements. The above constraints should be modeled as:

constraint increasing {
10 < med; II 10 is constrained to be less than med
med < hi; II med is constrained to be less than hi

constraint equal {
a bi II a is constrained to be equal to b
b == c; II b is constrained to be equal to c



Chapter 7: Randomization, Coverage and Assertion Gotchas 181

Gotcha86: Unwanted negative values in random values

Gotcha: I am getting negative values in my random values, where I only
wantedpositive values.

Synopsis: Unconstrained randomization considers allpossible 2-state values
within a given data type.

In the following class,both i and b aresignedvariables which can storenegative
values.

class Negs;
rand int data;
rand byte address; II GOTCHA! address can be negative

endclass

The int and byte types are signed types. Therefore, the . randomize method
will generate both positive and negative values for these variables. If either of
these variables is used in a context where a positive number is required, the
outcome could be unexpected or erroneous, such as generating a negative value
for an address bus.

How to avoid this Gotcha

Whenthe randomized testvariables are to be passed to hardware as stimulus, it is
generally best to use unsigned types such as bit or logic. This ensures that
randomized values will always be positive values.

Thereare times whensigned types needto be used, but onlypositive numbers are
desired. Forexample, it maybe preferred to use theC-like int, byte, shortint
and longint types when the variables are to be passed to C functions using the
SystemVerilog DirectProgramming Interface (DPI). When signed types need to
be used, but only non-negative values are desired, randomization can be
constrained to non-negative numbers. For example:

class Negs;
rand int data;
rand byte address; II OK, address constrained to non-negative
constraint pos

{ data >= 0;
address >= a;}

endclass



182 Verilog and SystemVeriiog Gotchas

Gotcha 87: Coverage reports default to groups, not bins

Gotcha.· I've defined specific coverage bins inside my covergroup to track
coverage of specific values, but the report only shows the coverage of the
entire covergroup.

Synopsis: The getcoveraget) and get_inst_coverageO methods do not break
down coverage to individual bins.

SystemVerilog provides powerful functional coverage for design verification. As
part of functional coverage, verification engineers define covergroups. A
covergroup encapsulates one or more definitions of coverpoints and cross
coverage. A coverpoint is used to divide the covergroup into one or more bins,
where each bin includes specific expressions within the design, and specific
ranges of values for those expressions. Cross coverage specifies coverage of
combinations of coverbins. An example covergroup definition is:

enum {sl,s2,s3,s4,s5} state_e, nstate_e;

eovergroup eSM @(posedge elk);
eoverpoint state_e {

bins state1 (sl) ;
bins state2 (s2) ;
bins state3 (s3) ;
bins state4 (s4) ;
bins stateS (s5) ;
bins st1 3 5 (sl~>s3=>s5);
bins st5 1 (s5=>sl) ;

}
endgroup

These covergroup bins count the number of times each state of a state machine
was entered, as well as the number of times certain state transition sequences
occurred.

SystemVerilog also provides built-in methods for reporting coverage. It seems
intuitive for coverage reports to list coverage by the individual bins within a
covergroup. However, this is not the default for how coverage is reported.
Gotcha!

When the SystemVerilog get_inst_coverage () method is called to compute
coverage for an instance of a covergroup, the coverage valuereturned is based on
all the coverpoints and crosspoints of the instance of that covergroup.

When the SystemVerilog get_coverage() method is called, the computed
coverage is basedon data from all the instances of the given covergroup.



Chapter7: Randomization, Coverage andAssertion Gotchas 183

The gotcha with coverage reporting is that coverage is based on crosspoints or
coverpoints. There areno built in methods to report details of individual binsof a
crosspoint. If the coverage is not 100%, thedesigner hasno wayto tellwhich bins
are empty.

How to avoidthis Gotcha

If the coverage details for eachbinare needed, theneachcovergroup should have
just one coverpoint, andthat coverpoint should havejust onebin. Then, when the
coverage is reported for that cover group, it represents the coverage for the
coverpoint bin.



184 Verilog and SystemVeriiog Gotchas

Gotcha88: Coverage is always reported as 0%

Gotcha: I defined a covergroup, but thegroup always has 0%coverage in the
coverreport.

Synopsis: Covergroups arespecialized classes andmustbeconstructed before
theycan be used.

The following example defines a covergroup as part of a class definition. The
intent is to provide coverage of the properties within the class. When the class
object is constructed, however, the covergroup does not keep track of the
information intended.

program automatic test;
event c9_sample;

covergroup CG_xyz @(cg_sample); II covergroup definition
coverpoint x;
coverpoint Yi
coverpoint z;

endgroup

class Abc;
rand bit [7:0] a, b, c;
covergroup CG_abc @(cg_sample); II covergroup definition

coverpoint ai
coverpoint bi
coverpoint c;

endgroup
endclass

initial begin
Abc al = new; II instance of Abc object
... II generate stimulus
$get_coverage(); II GOTCHA! reports 0 coverage

end
endprogram

The reason no coverage is reported is that a covergroup is a special typeof class
definition. In orderto generate coverage reports, the covergroup object mustfirst
be constructed using the covergroup's new method, in the same way as when
constructing a class object. The example above never constructs a CG_ XYZ

coverage object. The example constructs an instance of the Abc object, but
constructing the class object does not construct an instance of the CG_ abc
covergroup within the class. Hence, no coverage information is collected for
either the CG_ xyz or CG_abc cover groups. No errors or warnings are reported
for thiscoding error. Theonlyindication that there is a problem is an erroneous or
incomplete coverage report. Gotcha!



Chapter 7: Randomization, Coverage and Assertion Gotchas 185

How to avoidthis Gotcha

An instance of a covergroup must always be constructed in order to collect
coverage information about thatgroup. When thegroup is defined in a class, as in
the example above, the covergroup instance should be constructed as part of the
class constructor. In that way, each time a class object is constructed, the
covergroup instance for thatobject willautomatically be constructed.

program automatic test;
event cg_sample;

covergroup CG_xyz @(cg_sample); II covergroup definition
coverpoint x;
coverpoint y;
coverpoint z;

endgroup

class Abc;
rand bit [7: 0] a, b, c;
covergroup CG_abc @(cg_sample)i II covergroup definition

coverpoint ai
coverpoint b;
coverpoint Ci

endgroup

function new;
CG_abc = new; 1/ instance of covergroup

endfunction
endclass

initial begin
Abc al = new; II instance of Abc object
CG_xyz = new; /1 instance of covergroup
... II generate stimulus
$get_coverage(); II OK, reports coverage

end
endprogram

Another reason why coverage could be reported as 0% is that the cover group was
never triggered. This could be because its trigger never fired, or the . sample
method for the covergroup instance wasnever called.



186 Verilog and SystemVeriiog Gotchas

Gotcha 89: The coverage report lumps all instances together

Gotcha.· I have several instances of a covergroup, but the coverage report
lumps them all together.

Synopsis.' By default, the coverage report combines all the instances of a
covergroup together.

The intentin the example below is to measure the coverage on eachof twopixel
x : y pairs.
covergroup pixelProximity(ref bit signed [12:0] pixel1,

ref bit signed [12:0] pixe12)
@(newPixel);
cp1: coverpoint (pixe12 - pixel1) {

bins It = {[1:$]}; II pixel1's coord less than pixe12
bins eq = {O}; II did the pixels coincide?
bins gt = {[-4096:-1]}; II pixell's coord greater than

II pixe12
}

endgroup

pixelProximity px, pyi

initial begin
bit signed [12:0] xl, yl, x2, y2;
px = new(xl, yl)i II construct first covergroup
py = new(x2, y2); II construct second covergroup
... II generate stimulus
$qet_coveraqe() ; II GOTCHA! report lumps

II px and py together
end

In this example, two covergroup objects are constructed, px and py. Instead of
seeing separate coverage for each covergroup, however, the coverage report
combines the counts for bothgroups into a singlecoverage total. Gotcha!

How to avoid this Gotcha

The covergroup needs to set the .per_instance coverage option, as shown
below:
covergroup pixelProximity(ref bit signed [12:0] pixel1,

ref bit signed {12:0] pixe12)
@(newPixel);
option.per_instance = 1; /1 report for each coverqroup instance
cp1: coverpoint (pixe12 - pixe11) {

}
endgroup



Chapter 7: Randomization, Coverage and Assertion Gotchas 187

Gotcha 90: Covergroup argument directions are sticky

Gotcha: Sometimes the call to my covergroup constructor doesnot compile.

Synopsis: A covergroup refargument cannot bepasseda constant value.

A generic covergroup has arguments thatpass in values andvariables. Thedefault
direction is input, for passing in fixed values, and ref, for passing in variables
for coverpoints. Thedirection is sticky, andremains in effectuntila newdirection
is specified.

In the following example, the call to the covergroup constructor passes in the
variable va, and the constants 0 for low and 50 and high. The code looks like it
should do what is expected, but instead getsa compilation error.

covergroup cg (ref int ra, int low, int high
@(posedge clk);
coverpoint ra II sample variable passed by reference

{bins good = { [low: high] };
bins bad[] = default;

}
endgroup

initial begin
int va, vb;
int min=O, max=50;
cg cl = new(va, min, max); II OK
cg c2 = new(vb, 0, 50); II GOTCHA! cannot pass constants

II to ref args
end

In the covergroup definition above, ra is a ref argument. Thisdirection is sticky,
and affects all arguments that follow, until a different direction is specified. Since
no direction is givenfor low and high, they also default to ref arguments. The
call to the constructor fails, because the actual values passed to ref arguments
must be variables. It is not allowed to pass a constant into a ref argument. The
sticky direction behavior of covergroup arguments is similar to task/function
arguments, as described in Gotcha 69 on page 150.

How to avoidthis Gotcha

It is best to specify the direction for each covergroup argument, especially when
ref arguments are used. This documents the code intent, and prevents the gotcha
of an argument inheriting the direction of a previous argument. For example:
covergroup cg (ref int ra, input int low, input int high )

endgroup



188 Verilog and SystemVeriiog Gotchas

Gotcha 91: Assertion pass statements execute with a vacuous success

Gotcha: My assertion pass statement executed, even though I thought the
propertywas not active.

Synopsis: A vacuous successwill execute the assertion pass statement.

The assert property construct can be followed by optional pass and fail
statements.

assert property (p_req_ack) Sdisplay("passed");
else Sdisplay("failed");

The optional pass statement is executed if the property succeeds, and the fail
statement is executed if the assertion fails. The pass/fail statements can be any
executable statement. Multiple statements can be executed by grouping them
between begin and end.

Most property specifications contain an implication operator, represented by
either 1-> or 1=>, which qualifies when the assertion should be run. The
sequence expression before the implication operator is calledthe antecedent. The
sequence expression after the operator is called the consequent. A property
specification that uses an implication operator has three possible results: success,
failure, and vacuous success. If the implication antecedent is true, the consequent
is evaluated, and the property will pass or fail, basedon the results of testing the
consequent. If the implication antecedent is false, the consequent is a "don't
care",and theproperty returns a vacuous success.

The intentof the following assertion is to increment a counter on eachsuccessful
assertion. The assertion checks to see if a req is followed by ack 1 clockcycle
later.
assert property (p_re~ack) re~ack_count++; else $error; II GOTCHA

property p_req_ack;
@(posedge elk) req 1-> ##1 ack; II if req, check for ack

lIon next cycle
endproperty

Thegotcha is that theassert property statement doesnot distinguish between
a real success and a vacuous success. Either one will cause the pass statement to
be executed. As a result, this example counts both how many times req was
followed by ack (successes) and how many clock cycles in which there was no
reg (vacuous successes). Gotcha!



Chapter 7: Randomization, Coverage and Assertion Gotchas 189

How to avoidthis Gotcha

Thisgotcha canbe avoided by executing thedesired statement(s) from within the
assertion property, instead of as a 'pass statement. SystemVerilog assertions can
have executable statements associated with the evaluation of an expression. The
following example places the code to increment the counter in a function, which
is then called when the property (not the assertion) successfully sees req
followed by ack.

assert property (p_re~ack) else $error; II OK. no pass statement

property p_req_acki
@(posedge clk) $rose (reg) 1-> ##1 ($rose (ack) , inc_cnt) i

endproperty

function void inc_cnti
re<t-ack_count++i II OK, not executed on vacuous success

endfunction

Thisgotcha hasbeenaddressed in thenext version of theSystemVerilog standard,
planned for ratification 2008. The IEEE 1800 SystemVerilog standards
committee has proposed new system tasks to control the execution of assertion
pass statements: $assertvacuousoff and $assertvacuouson These system
tasks will allow a designer to disable or enable the assertion pass statements on
vacuous successes.

Specific to the previous example, there is another solution. SystemVerilog
coverage can be used to count howmany times req was successfully followed by
a c k, instead of the assertion passstatement.



190 Verilog and SystemVeriiog Gotchas

Gotcha 92: Concurrent assertions in procedural blocks

Gotcha.· My assertion pass statements are executing, even when the
procedural codedoes not execute theassertion.

Synopsis.' Concurrent assertions in procedural code actually fire everyclock
cycle, notjust when theprocedural codeexecutes.

A concurrent assertion can be placed inside an initial or always block, and
the assertion guarded by procedural code, suchas an if statement.

always_ff @(posedge clk) begin
if (state_e == FETCH)

assert property (p_re~ack) II GOTCHA!
Sdisplay ("passed") II pass statement

else Sdisplay("failed")i II fail statement

end

property p_reg_acki
@(posedge clk)

reg 1-> ##1 acki II a reg should get an ack 1 cycle later
endproperty

The intent of this assertion is that req followed by ack is only checked when
state_e is FETCH, and that each req shouldbe followed one clock cycle later
by an ~ck.

In the simulation results, below, simulation was run for 9 clock cycles, four with
the state_e variable equal to INIT, and four with the variable equal to FETCH.
The table shows the valueof state_e and req on one clockcycle, and the value
of ac k on the next clockcycle.

1st cycle 2nd cycle output message and notes
------------ --------- ----------------------------------------
state- e reg ack
------------ ---------
INIT 0 0 passed II vacuous success GOTCHA!
INIT 1 0 passed II vacuous success GOTCHA!
INIT 1 1 passed II vacuous success GOTCHA!

FETCH 0 0 passed II vacuous success
FETCH 1 0 failed II true failure
FETCH 1 1 passed II true success



Chapter 7: Randomization, Coverage and Assertion Gotchas 191

This example illustrates twogotchas. The first gotcha is shown on line oneof the
output. The assertion ran, even when state_e was not equal to FETCH. The
reason the assertion ran, evenwhenthe if condition was false, is that concurrent
assertions in procedural code are still concurrent assertions. As such, the
assertions run as concurrent threads, in parallel with the procedural block.
Because the assertion is a concurrent assertion, it executes on everypositive edge
of elk, evenwhenthe if condition is false. Gotcha!

The second gotcha in this example is shown on line 2 of the output. There is a
req on the first cycle, but it is not followed by an aek on the next cycle. This
should be an assertion failure, but theassertion reported a success. Gotcha, again!

This second gotcha occurs because the procedural if statement is treated as an
implication operation in the assertion property. When the if condition is false,
the property is a vacuous success, regardless of thevalues of req and ae k.

How to avoid these Gotchas

In reality, there are no gotchas to avoid. The assertion in the previous example
worked exactly as it should. A vacuous success occurs when the antecedent of an
implication operator is false. While it is not obvious in the example above, there
are actually two implications: the if (state_e == FETCH) in the procedural
code, and the req I -> in the assertion property. If either implication is false, a
vacuous success will occur, which is exactly whathappened in this example.

What can be misleading is that the pass statement is executed on a vacuous
success (see Gotcha 91 on page 188). The message printed from the pass
statement can makeit appear that theassertion passed when it should not have.

To avoid being mislead by the assertion pass statement, do not use pass
statements withconcurrent assertions that are guarded by a conditional statement
in procedural code. The $assertvacuousoff referenced in Gotcha 91 on page
188 can also resolve the passstatement beingexecuted on a vacuous success.



192 Verllog and SystemVeriiog Gotcbas

Gotcha 93: Mismatch in assert...else statements

Gotcha: My assertion fail statement executes when the assertion succeeds
instead offails.

Synopsis: An Hif" without an Heise II in an assert pass statement causes the
assert Heise II (fail) statement to bepairedwiththe "if" in thepassstatement.

The assert and assert property constructs can be followed by optional pass
and fail statements.

assert property (p_req_ack) Sdisplay("passed");
else Sdisplay("failed");

The optional pass statement is executed if the property succeeds, and the optional
fail statement is executed if the assertion fails.

The pass statement can be any executable statement, including a conditional i£
or i£...e1se statement. The following example has a gotcha:

assert property (p_req_ack)
if (cnt_en) req_ack_count++; II assertion pass statement

else Sfatal; II GOTCHA! this is not the
II assertion fail statement

Assertions follow the same syntax as nested if...else statements, in that the
else is associated with the nearest if. In the example above, theelse statement
is associated with the if condition in the assertion pass statement. Syntactically,
there is no assertion fail statement in this example. This is not a syntax error,
since the fail statement is optional. Instead, the else branch executes whenever
the assertion succeeds or vacuously succeeds, and the pass statement if
condition is false. Gotcha!

How to avoidthis Gotcha

This gotcha is similar to the nested i£...else gotcha described in Gotcha 57 on
page 128, and is avoided in thesameway. Eitheran else mustbe paired withthe
if, or the if condition must be encapsulated within a begin...end statement
group, as shown below.
assert property (p_req_ack)

begin
if (cnt_en) req_ack_count++; II OK, assertion pass statement

end
else Sfatal; II OK, assertion fail statement



Chapter 7: Randomization, Coverage and Assertion Gotchas 193

Gotcha 94: Assertions that cannot fail

Gotcha: I have an assertion property with an open-ended delay in the
consequent, and doesn't fail when it should.

Synopsis.' Once the consequent ofa property comes to an open-ended delay,
the consequent will waitforeverfor the remaining conditions to return true.

The behavior of assertion sequences with an open-ended range is not intuitive,
and can lead to unexpected assertion results.

The intentof the following assertion property is that a req should eventually be
followed by an ack, which should be followed one cycle laterby done.

property p_req_aek2;
@(posedge elk)
$rose(req) 1-> ##[1:$] $rose(ack) ##1 $rose(done); II GOTCHA!

endproperty

In the example above, the assertion antecedent will wait for a rise on req. Until
req rises, the assertion willbe a vacuous success on eachclockcycle. After req
goes high, the consequent will wait forever for ack to go high. Once ack goes
high, done should transition high on the next clock. If it does, the property
passes. If done does not follow a c k, the assertion does not fail! Instead, the
consequent will just continue to wait for a rise on ac k, followed by done going
highone clocklater. Gotcha!

The nextproperty model is similar to the previous example, exceptthat the open­
endedrangeis between the evaluations of ack and done.

property p_req_aek2i
@(posedge elk)
$rose(req) 1-> ##[1:5] $rose(ack) ##[1:$] $rose(done); II GOTCHA!

endproperty

In this example, if the rise on ack doesnot occurwithin five clocks of the rise of
req, the consequence will fail. If ack doesgo highwithin the five clocks of req,
the consequent will thenwait forever for done to go high. This property can fail
up to the point of starting the open-ended range. Once the open-ended range is
started, the consequence cannot fail. It willwait forever for a passing condition of
the remaining sequence. Gotcha!

The property shown next also illustrates that, once an open-ended range is
reached, the consequent will not fail, but will wait until a passing sequence
follows the open-ended delay.



194 Verilog and SystemVeriiog Gotchas

property p_req_aek2;
@(posedge elk)
$rose(req) 1-> ##[1:5] $rose(aek)

##[1:$] $rose(done) ##1 $fell(bus_en)i II GOTCHA!
endproperty

In thisexample, theproperty canfail if req is not followed by ack. But, oncethe
open-ended range is reached, the property will wait forever for a rise on done,
followed one clock later by bus_en having gone low. If done, goes high and
bus_en does not go low within the next clock cycle, the consequent will just
continue waiting until thepassing sequence occurs. Gotcha!

How to avoidthis gotcha

The cause of the gotchas in the preceding examples is having an open-ended
range in theconsequent thattestsformore thanonecondition aftertherange. One
solution is to breakup theconsequent intoseparate sequences andproperties. The
first property below checks for req, followed eventually by a rise on ack. The
second property checks for ack, followed onecyclelaterby done.

property p_req_aek;
@(posedge elk) $rose(req) 1-> ##[1:$] $rose(aek); II OK

endproperty

property p_ack_done;
@(posedge elk) $rose(ack) 1-> ##1 $rose(done); II OK

endproperty

Another solution is to use a go-to repetition operator ( [- >n] ). This sequence
operator will provide the same "wait forever" for ack, but will fail if ack is not
followed by done, instead of continuing to waitfor an ack followed by done.

property p_req_ack2;
@(posedge elk)
$rose(req) 1-> ##1 ($rose(aek) [->1]) ##1 $rose(done); II OK

endproperty



Chapter 8
Tool Compatibility Gotchas

Gotcha 95: Default simulation time units and precision

Gotcha: My design outputs do not change at the same time in different
simulators.

Synopsis: Simulators have different defaults for delay time units (the
'timescale directive).

Time in Verilog is a 64-bitunsigned integer. Delays are specified by using a hash
mark ( # ) followed by a number. A delay does not have any indication of what
unit of time is being represented.

#2 sum = a + b; II delayed execution of a programming statement

and #3 (y, a, b); II 2-input AND gate with propagation delay

In Verilog, the time unit represented by delaysis specified as a characteristic of a
module, using a 'timescale compiler directive. The directive contains two
parts, the module's timeunitsand the module's timeprecision. Each are specified
in increments of 1, 10 or 100, in units ranging from seconds down to
femtoseconds. The time precision allows a module to represent non-whole
delays. The precision is relative to the timeunit. Within simulation, all delays are
scaledto the smallest precision usedby the design.

An example of using 'timescale is:

Note: the code examples in this chapter are contrived in order to illustrate each gotchausing small
examples. In realdesignand verification code,thesegotchas mightnot be as obvious or easy to debug.



196 Verilog and SystemVeriiog Gotchas

'timescale 1ns/100ps II 1 nanosecond units, 100 ps precision
module A ( ... );

#2.3 ... II delay represents 2.3 nanoseconds
endmodule

module B ( ... );
#5.5 ... II GOTCHA! delay represents 5.5 what?

endmodule

'timescale 1psl1ps II 1 picosecond units, 1 ps precision
module C ( ... );

#7 ... II delay represents 7 picoseconds
endmodule

There are two common gotchas with Verilog 'timescale directive: file order
dependencies and no standard default.

The 'timescale directive is not bound to modules or files. Once specified, the
directive affects all modules and files that follow the directive, until a new
'timescale is encountered by the compiler. This means that, if some design
and/or test files contain time scale directives, and other files do not, then
changing the order in which files are compiled will change how much time a
delayrepresents in the files that do not havea timescaledirective. This can cause
radically different simulation results, evenwith the samesimulator. Gotcha!

If a file is read in whenno 'timescale has been specified at all, then a compiler
might, or might not, apply a default time unit. This, too, can cause radically
different simulation results when simulating the same design on different
simulators. Gotcha!

Some Verilog/SystemVerilog tools require that all files be compiled together.
Timescale directives in one file can impactother files, as noted in the paragraphs
above. Other Verilog/SystemVerilog tools support separate file compilation. In
this case, a timescale directive in one file will not affectother files, but files with
no directive dependon the tool's default timescale.

How to avoid this Gotcha using Verilog

To avoid this gotchawhenusingjust Verilog, company-imposed or self-imposed
coding rules must be strictly adhered to. There are three different coding styles
for where to specify the 'timescale directive:
• One style is to not use 'timescale directives anywhere, and instead use the

default time units of the software tool. This avoids the gotcha, but depends on
being able to control the code of all models that make up a design. This may
not be possible if models are obtained from multiple sources, such as IP
models or ASIC cell library models. Commercial Verilog models are likely to
contain 'timescale directives.



Chapter 8: Tool Compatibility Gotchas 197

• Another style is to make sure a 'timescale directive is specified at the
beginning of each and every module, in each and every design or testbench
file. Thiseliminates bothfileorderdependencies in multi-file compilation, and
dependencies on the tool's default timescale in single-file compilation.

• A third style is to onlyspecify 'timescale in one file, and then include that
fileat the beginning of every otherfile. Thisapproach alsoeliminates bothfile
order dependencies in multi-file compilation, and dependencies on the tool's
default timescale in single-file compilation.

How to avoidthis Gotcha usingSystem Verilog

SystemVerilog has two very important enhancements that help avoidthe gotchas
inherent with the 'timescale directive. First, the time unit and time precision
specifications arekeywords thatcanbe specified within a module, andmade local
to just the module. The keywords are tim.unit and timeprecision. These
keywords can alsobe specified within interfaces, programs andpackages.

By making the time unit and precision part of the module definition, file order
dependency problems and multi-file versus single-file compilation issues are
eliminated.

The second SystemVerilog enhancement is allowing an explicit time unit to be
specified with a delay value. This both documents the intended time unit, and
eliminates dependency on whatorder 'timescale directives are encountered by
the compiler.

The following example shows both of these enhancements:

module B ( ... );
timeunit lns;
timeprecision lps;

#5.5 ... II delay represents 5.5 nanoseconds

'1m•... II delay represents 1 millisecond
endmodule



198 Verilog and SystemVeriiog Gotchas

Gotcha 96: Package chaining

Gotcha: Mypackages compile fine on all simulators, but my design thatuses
thepackages will onlycompile on somesimulators.

Synopsis: When one package imports a second package, and a design or
testbench imports thefirst package, some simulators makedeclarations from
bothpackages available, andsomedo not.

SystemVerilog packages provide a declarations spacefor definitions thatare to be
shared. A module, interface, or program can import specific package items, or use
a wildcard import to make all items in a package visible. A package can also
import items from otherpackages, as illustrated below.

package foo;
typedef int unsigned uint_t;

function int func a (int a);
return "'a;

endfunction
endpackage

package bar;

import foo::*; II wildcard import package foo
function int func b (uint_t b);

return ... func_a(b);
endfunction

endpackage

module test;
import bar: :*; II wildcard import bar
uint t c; II GOTCHA! reference definition

II that is in package foo

endmodule

In this example, the test module does a wildcard import of package bar, and
then references the uint_ t definition. This definition is not defined in package
bar. But, package bar imported this definition from package foo. This is
referred to aspackagechaining.

Some software tools permit package chaining, and some simulators do not.
Gotcha!

Thegotcha in the example above is a result of an ambiguity in the SystemVerilog­
2005 standard. The standard does not say whether package chaining is, or is not,
allowed.



Chapter 8: Tool Compatibility Gotchas 199

How to avoid this Gotcha

To ensure that design and verification code will work on all software tools,
package chaining should not be used. Instead, a design or verification block
should explicitly import each package that contains definitions used in the
module. Eitherspecific object imports or wildcard imports canbe used, so longas
eachpackage that is usedis explicitly referenced.

module test;
import foo: :*; II wildcard import bar
import bar: : *; II wildcard import bar

uint t c; II OK, reference definition
II that is in package foo

endmodule

TheIEEE SystemVerilog standard working group hasaddressed this ambiguity in
thestandard, andhasproposed a change for thenextversion of the SystemVerilog
standard. The change is to make implicit package chaining illegal, and to provide
a mechanism for explicit package chaining. When tools implement thisproposed
change, the example illustrated at the beginning of this section, which uses
implicit package chaining, will be illegal. However, package bar can enable
chaining by importing definitions from package foo, andthenexporting some or
all of those definitions, thusmaking them visible to blocks that import bar.



200 Verilog and SystemVeriiog Gotchas

Gotcha97: Random number generator is not consistent across tools

Gotcha: I cannot repeat myconstrained random tests on different tools.

Synopsis.' The random number generator (RNG) used/or constrained random
generation in System Verilog is notdefined in theIEEE specification.

The IEEE 1800-2005 SystemVerilog specification outlines and specifies the
requirements for the constrained random number generator (RNG). However, the
standard doesnot specify the algorithm to be usedfor random number generation
or for solving constraints.

The following example shows a gotcha that is a result of not having a standard
RNG and constraint solver. A test using the constraint shown belowwas run on
simulators from two different tool vendors. This same test was also run on two
different revisions of the samesimulator from oneof the twovendors.
class bad_constraint;

rand bit [7:0] a, b, c;
constraint equal { a == b == c;

endclass

Random values generated by vendor 1:
a = 25, b = 173, c =
a = 65, b = 151, c = °0
a = 190, b = 33, c = 0
a = 65, b = 32, c = 0

Random values generated by vendor 2:
a = 61, b = 1, c = 0
a = 9, b = 9, c = 1
a = 115, b = 222, c = 0
a = 212, b = 212, c = 1

Random values generated by vendor 2, witha different version of the sametool:
a = 9, b = 9, c =: 1
a = 212, b = 212, c = 1
a = 17, b = 17, c = 1
a = 150, b = 184, c = 0

The random values generated by each tool are not repeatable between tools, or
even between different versions of the same tool. This means the constrained
random testsrun withtoolsfrom onevendor willnotmatchresults when thesame
test is run on another vendor's tool. Additionally, as shown in the test results
above, there is no guarantee that tests from one revision to the next revision
withinthe sametoolvendor willgivethe sameresults. Gotcha!



Chapter8: Tool Compatibility Gotchas 201

How to avoidthisgotcha

A standardized RNG and constraint solverwould ensure that constrained random
test generation wouldbe consistent between different tools. At the time thisbook
was written, however, the IEEE SystemVerilog standard working group had no
plansfor standardizing theseimportant algorithms.

The next best solution is for the verification team to keep track of tools and
revisions used for simulation. The team needs to make sure that results are
checked as tools are upgraded from revision to revision, to ensure the test results
are consistent. Additionally, if a verification team has access to simulators from
multiple tool vendors, the teammustkeep trackof which test results belong with
which tooland revision.

Note: the constraint definition shown above has another gotcha, which is
discussed in Gotcha 85 on page 179):



202 Verilog and SystemVeriiog Gotchas

Gotcha 98: Loading memories modeled with aIways_latch/always_ff

Gotcha.· When I use System Verilog, some simulators will not let me loadmy
memory models using $readmemb.

Synopsis: The Sreadmembi) andSreadmemhi) system tasks cannot be usedto
loada RAMmodelthatusesalways_latch or alwaysJf.
Typically, a bus-functional model of a RAM is eithersynchronous (clock based)
or asynchronous (enable based). Synchronous RAMs behave at the abstract level
like flip-flops. Asynchronous RAMs behave at the abstract level like latches.
However, there is a gotcha if these devices are modeled using SystemVerilog's
always_ff or always_latch procedural blocks.

module RAM
(inout wire [63:0] data,
input logic [ 7:0] address,
input logic write_enable, read enable

) ;

logic [63: 0] mem [0: 255] ;

always_latch II asynchronous write (latch behavior)
if (write_enable) mem[address] <= data; II write to RAM

assign data read enable? mem[address] : 64'bz;
endmodule

module test;
wire [63:0] data;
logic [ 7:0] address;
logic write_enable, read_enable;

RAM ramI (.*); II instance or RAM model

initial begin
$readmemh ("ram_data.dat", raml.mem); 1/ GOTCHA!

In this example, the RAM model is correct-at least functionally. The problem is
that the always_latch procedural blockenforces a synthesis rule that multiple
procedural blocks cannot write to the samevariable. The testbench is attempting
to load the RAM model using the Verilog $ readmemh task, which is a common
way to load Verilog memory models. This is a second procedural blockwriting to
the RAM storage (mem), which is illegal. One simulator generates the following
error:



Chapter 8: Tool Compatibility Gotchas 203

Error-[ICPD] Invalid combination of procedural drivers
Variable "mem" is driven by an invalid combination of procedural
drivers. Variables written on left-hand of "always_latch" cannot
be written to by any other processes, including other
"always_latch" processes.

Some simulators, however, execute the example above without any errors or
warnings. These products do not treat the $readrnemh and $readrnemb
commands as an assignment.

How to avoid this Gotcha

The fix for this coding problem is to use Verilog's general purpose always
procedural blockfor this abstract RAM model. SystemVerilog's always_latch
and always_ff procedural blocks are intended to model synthesizable RTL
models. These constructs are not intended for abstract models that do notneedto
adhere to synthesis coding rules.

The asynchronous, latch-like RAM model in the previous example should be
coded as:

module RAM

always @* II asynchronous write (latch behavior)
if (write enable) mem[address] <= data; II write to RAM



204 Verilog and SystemVeriiog Gotchas

Gotcha 99: Non-standard language extensions

Gotcha: MySystem Verilog codeonlyworks on one vendor stools.

Synopsis.' Some tools add proprietary extensions to the IEEE Verilog and
System Verilog standards.

Some Verilog/SystemVerilog tool vendors extend the IEEE standard by adding
special, vendor-specific features to theirproduct. These extensions can be useful
for thatvendor's tools. However, using theseextensions alsomeans the Verilog or
SystemVerilog codewillnot workwith toolsfrom othervendors.

One SystemVerilog tool company allows an optional keyword hard to be used
with the solve...before constraint operator. Without this additional keyword,
that company's tools do not enforce the constraint solution order that is specified
by solve...before. An example of using thisvendor-specific keyword is:

constraint ab {
solve a before b hard; II 'hard' enforces solve before
if (a inside {32, 64, 128, 256})

a == b
else
a > b;

Thekeyword hard is nota SystemVerilog keyword, and is not in the IEEE 1800­
2005 SystemVerilog standard. If hard is used with any tool other than that
vendor's tool, a syntax errorwill result. Gotcha!

Another SystemVerilog toolvendor allows thekeyword pairpure virtual to be
usedin the declaration of classmethods. Thiskeyword pair is notpermitted in the
official IEEE 1800-2005 SystemVerilog standard. Testbenches written with this
keyword pair might not compile in other tools. This vendor also supplies
verification libraries that contain this keyword. These libraries might not work
with toolsfromothervendors.

How to avoidthis Gotcha

Using non-standard keywords or syntax might be necessary to get the desired
results in a specific product. However, specifying this keyword will prevent the
same verification code from working with other software tools. To avoid this
gotcha, conditional compilation canbe usedto control whether or not thevendor­
specific construct is compiled. Forexample:



Chapter 8: Tool Compatibility Gotchas 205

constraint ab {

'ifdef VENDOR_A
solve a before b hard; II add proprietary 'hard' specification

'else
solve a before b;

'endif

if (a inside {32, 64, 128, 256})
a == b

else
a > b;

In the example above, the macro name VENDOR_ A mustbe set before the code is
compiled. It can be specified in the source code, or on the tool's command line.

It should be noted that the pure virtual keyword pair is illegal in the
SystemVerilog-2005 standard, but a proposal has been approved by the IEEE
SystemVerilog standard group to add this to the next version of the IEEE
standard. At the time this book was written, there was no proposal to add the
hard keyword.

The twonon-standard extensions shown above illustrate this typeof gotcha. They
are not the only non-standard extensions that exist in Verilog and SystemVerilog
tools.



206 Verilog and SystemVeriiog Gotchas

Gotcha 100: Array literals versus concatenations

Gotcha: Sometoolsrequire onesyntaxfor arrayliterals. Othertools require a
different syntax.

Synopsis: Array literals andstructure literals areenclosedbetween the tokens
, { and}, but an early draft of the System Verilog standardused the tokens {
and}, withoutthe apostrophe.

The Verilog concatenation operator joins one or more values and signals into a
single vector. SystemVerilog array and structure literals (also known as an
assignment patterns) are lists of one or more individual values. To make the
difference between theseconstructs obvious to both engineers and software tools,
the syntax for an arrayor structure literal ( '{ }) is different from the syntax for
a Verilog concatenation( { }). The difference is that the arrayor structure literal
list of separate values is preceded by an apostrophe

logic [7:0] data; II 8-bit vector

data = {4'hF, bus}; II concatenate values into a vector

int data [4]; II array of 4 integers

data = 'to, 1, 2, 3}; II list of separate values

typedef struct {
int a, b;
logic [3:0] opcode;

} instruction_word;

instruction_word = '{7, 5, 3}; II list of separate values

The similarity of these two constructs can be a gotcha. It is easy to forget to add
the apostrophe beforethe arrayor structure literal, turning the list of values intoa
concatenation. In most contexts, this mistake will be a syntax error, and will not
lead to a functional gotcha. There is one exception, though, whichis described in
Gotcha 17on page 38.

Another gotcha is that an unofficial preliminary draft of the SystemVerilog
standard, known as SystemVerilog 3.1 a', used the tokens { } for both
concatenations and array/structure literals.

1. System Verilog 3.Ja Language Reference Manual: Accellera sExtensions to
Verilog, Copyright 2004 by Accellera Organization, Inc., Napa, CA, http://
www.eda.org/sv/SystemVerilog_3.1a.pdf.



Chapter 8: Tool Compatibility Gotchas 207

At the time this book was written, some software tools required the preliminary
SystemVerilog 3.1a syntax, some tools required the official IEEE 1800 syntax,
andsometools allowed either syntax. Gotcha!

How to avoidthis Gotcha

The gotcha of some tools requiring a non-standard syntax cannot be avoided. A
workaround is to use conditional compilation around statements containing array
or structure literals, to allow themodel to be compiled witheitherthepreliminary
SystemVerilog 3.1asyntax or theofficial IEEE 1800 syntax. For example:

int data [4]; II array of 4 integers

initial begin
'ifdef VENDOR_A

data = '{O, 1, 2, 3}; II IEEE 1800 list of values
'else

data = {O, 1, 2, 3}; II old SV 3.1a list of values
'endif

end



208 Verilog and SystemVeriiog Gotchas

Gotcha101: Module ports that pass floating point values (real types)

Gotcha: SomeSystem Verilog tools allowme to declare my inputports as real
(floating point), but other tools do not.

Synopsis.' Module outputports thatpassfloatingpoint values aredeclared as
real, but module inputports that pass floating point values are declared as
varreal.

SystemVerilog allows floating pointvalues to be passedthrough ports. However,
the official IEEE syntax is not intuitive. An output port of a module can be
declared as a real (double precision) or shortreal (single precision) type, but
input ports must be declared with the keyword pair var real or
var shortreal. For example:
module fp_adder (output real result,

input var real a, b
) ;

endmodule

An unofficial preliminary draft of the proposed SystemVerilog standard, known
as SystemVerilog 3.1a1, did not require the var keyword be used on input
floating pointports. At the timethisbookwaswritten, someSystemVerilog tools
require the official IEEE syntax, as shown above, and get an error if the var
keyword is omitted. Othertools, however, require the preliminary SystemVerilog
3.1 a syntax, and get an error if the var keyword is used. Designers are forced to
writetwo versions of anymodels thathavefloating point inputports. Gotcha!

How to avoid this Gotcha

This gotcha cannot be avoided. The only workaround is to use conditional
compilation around the module port declarations, to allow the same model to be
compiled with either the unofficial SystemVerilog 3.1a declaration style or with
the official IEEE 1800 declaration style.

1. System Verilog 3.1a Language Reference Manual: Accellera sExtensions to
Verilog, Copyright 2004 by Accellera Organization, Inc., Napa, CA, http://
www.eda.org/sv/SystemVerilog_3.1a.pdf.



Index

Symbols lor operator 56
! not operator. . . . . . . . . . . . . . . . . . . . . . . 118 1=> implication operator 188
!= inequality operator 129 1-> implication operator 188
!==not-identity operator 130 ~ invertoperator 118
!=?wildcard comparison 73 'timescale 195
$assertoff 177 '{ } assignment patternoperator 38, 206
$assertvacuousotT 191 '0 37
$bitstoreal 46 '1 37
$cast 93 'x 37
$clog2 91 'z 37
$finish 171
$readmembO 202 Numerics
$readmemhO 202 10typesof people 30
$realtobits 46 1364-2005 5, 6
$signed 110 1800-2005 5, 6
$unitdeclarations 15,24 I-bit function return 148
$unsigned 110
++ increment operator 112, 113, 115 A
+= assignment operator 112 acknowledgments ix
+= assignment operators 115 always 123
.* See dot-starport connection always_comb 51,53,85,95,97
.name, See dot-name port connection always_ff 95,97,202
.per_instance coverage option 186 always_latch 51,95, 97, 202
.randomize method 173, 175, 177, 181 antecedent 188
.sample method 185 array literals 38, 206
.sumarraymethod 119 arraymethod operations . . . . . . . . . . 11 9, 121
.sumwitht) arraymethod 121 arrayof objects 159
:: scoperesolution operator. 27 assert...else . . . . . . . . . . . . . . . . . . . . . . . . 192
; null operation 140 assertion pass statement 188
<= See nonblocking assignment 62 assertions .. 26, 79, 87, 89,90, 155, 175,177,
= See blocking assignment 62 188,189,190,192,193
==equality operator 129 assign 44,53,95,97,151
== identity operator 130 assignment operators. . . . . . . . . . . . . . . . . 112
==? wildcard comparison 73 assignment patterns 38, 206
-> blocking event trigger 131,132 assignment rules 35
-», nonblocking event trigger 132 assignments in expressions 99
@eventcontrol. 131, 139 asynchronous reset 60, 123
@* 49, 50, 53 asynchronous set 60
{ } concatenation operator 38,206 automatic functions 22, 160, 161, 169



210 Verilog andSystemVeriiog Gotchas

automatic package 24 o
automatic programs 24, 163 decimal integer 30
automatic tasks 22, 160, 161, 169 decrement operator 112
automatic variables 22, 147, 162, 164 dedication . . . . . . . . . v

default direction of task argument 158
B disable 168
back-driven ports 43 disable fork 166
begin end,wherenot to use 57,58 DonMills vii
binary integer 30 dot-name portconnection II, 14,41
bit-select operation III dot-star portconnection II, 14,41
blocking assignment dynamic variables, Seeautomatic variables

++ and-- operators . . . . . . . . . . . . . . . . 112
assignment operators 112 E
correctusage 68 Emacs 11,12,141,149
definition of 62 enumerated types 28, 84,92
in clockdividers 65 equality with4-statevalues 129
to reset2-state models 83 escaped identifiers 19,20
to resetat timezero 126 escaped names 19,20

boolean constraints 179 eventdatatype 131, 134
exit simulation 171

C explicitpackage import 28,29
case 31,76,77,79
casesensitivity 7 F
casestatement 30 FIFO 134
caset) inside 73 filling vectors 37
casex 72 flip-flop ..... 20,60,62,64,82,83,124,202
casez 72 floating point, Seereal types
casting 92 for loop 142, 144, 145, 147
casting, sign 110 foreach loop 142
ChrisSpear . . . . . . . . . . . . . . . . . . . . . . . ix,6 forever loop 142
clockdividers 64 fork join 145, 167
clocking blocks 139 fork join_any 172
clock-to-Q delay 62,64, 66 fork join_none 164, 172
codingguidelines 24,45 full case 74,79
combinational logic49,52,56,57,61,62,66, function return size 148

67,68,70,71,112, 116, 151 functional coverage 182
combinational nonblocking assign 66
compilation 41 G
compilation error8, 10,11, 14,17,20,22,25, get()method ' 134, 137

28,29,44,58,138,139,150,153, getcoveraget) method 182
154, 155, 159, 187 get_inst_coverageO method 182

compilation warning 14 Golson, Steve ix, I
concatenation operator 38,206 gotcha
concatenations 206 ! versus""'. . . . . . . . . . . . . . . . . . . . . . . . 118
concurrent for loops 145 $assertoff disables randomization 177
concurrent threads 164 $unitcompilation 15
conditional compilation 61, 204,207,208 @* 49
consequent 188 I-bit implicit nets 13
constructor 157, 158 all data in mailbox hassamevalue 157
context-determined operators .. 101, 105, 108 arrayliterals 38
continuous assignment 44, 53,95, 97, 151 arrayliterals versus concatenations 206
coverage reports 182, 184, 186 arrayof objects 159
covergroup argument direction 187



Index 211

assert...else mismatch 192 real typeson ports 46, 208
assertion passstatement 188 referencing loopvariable 147
assertions in procedural code . . . . . . . . 190 resetat timezero. . . . . . . . . . . . . . . . . . 123
assertions that cannotfail . . . . . . . . . . . 193 resetting 2-state models 82
assignments in expressions 99 semaphores thatdon't wait 134
automatic variables 22 semicolons after fort) 142
back-driven port 43 semicolons after if 140
begin end in sequential logic 57 sensitivity lists 52,56
boolean constraints 179 sequential logic 54,64
casesensitivity 7 sequential logicblocking assignment 62
casezandcasex 72 sequential logicresets 59
clockdividers 64 sequential logicset/reset 60
combinational assignment order 70 shared variables 94,96, 164
combinational nonblocking assign 66 signextension 33, 105
concurrent for loops 145 signedarithmetic 108
context-determined operators 101 sizeextension 105
continuous assignment withdelay 151 sizemismatch in assignment. 35
coverage is 0% 184 statements in a class 153
coverage reportlumped together 186 taskdefaults withdefault values 150
coverage reports on bins 182 triggering on clocking blocks 139
disable fork 166 undetected randomization failure 175
disabling statement blocks 168 unique casemisuse 79
enumerated types 28 unnamed blocks 25
equality with4-statevalues 129 usinginterfaces and classes 155
escaped names 19 variable initialization 162
event trigger races. . . . . . . . . . . . . . . . . 131 variables don't get randomized 173
filling vectors 37 variables in forked threads 164
function return size 148 zeroextension 33
functions in combinational logic 49 gotcha, definition of 3
hidden problems, 2-statelogic .. 88,90, 92 gotcha, reasons for . . . . . . . . . . 4
hidden problems, 4-statelogic 86 gotcha, summary of gotchas in book xv
implicit nets 10
incomplete decisions 74 H
increment operator . . . . . . . . . . . . . . . . 112 handle 154,155,157,158,159,173
infinite for loop 144 hard,non-standard keyword 204
inputversus ref arguments . . 158 hex integer 30
literal integers 30, 32,33,35 hidden problems, 2-statelogic 88,90, 92
localvariables 17 hidden problems, 4-statelogic 86
locked statemachines 84 hierarchical paths ..... 19,20, 22, 23,25, 27
mailboxes can storeanydata type 137
nestedif elseblocks 128 I
non re-entrant tasks 160 identifiers
non-standard random generator 200 casesensitive 7
operation shortcircuiting 116 definition of 7
out-of-bounds arrayaccess 90 escaped 19
out-of-bounds enumerated types 92 legal characters 19
overlapped decisions 77 IEEESystemVerilog standard 5
package chaining 198 IEEEVerilog standard 5
packages 27,28,29 if else 128
part-select operation III if else, in sequential logic 57
port connections 39 implication operator 188
premature simulation exit 171 implicit nets 13
random negative values 181 import, explicit 28,29



212 Verilog andSystemVeriiog Gotchas

import,package 28, 198 o
import, wildcard 28, 29, 198 objecthandles, Seehandle 159
imported package items 27 octal integer 30
incomplete decisions 74 open-ended rangein assertions 193
increment operator 112 operation shortcircuiting 116
inertial delay 152 or, in sensitivity lists 56
initial 123 out-of-bounds arrayaccess 90
inside 73 out-of-bounds enumerated types 92
interfaces 24,96, 1SS

p
J package automatic 24
join_any 172 package, wildcard import 28, 29, 198
join_none 164, 172 packages 16,24,27,28,29,96

packages, chaining 198
L parallel_case 74
language-aware editor. 11,128,141,142,149 parameter 91
left extension, of literalvalue 34 part-select operation . . . . . . . . . . . . . . . . . III
lint checkers .. 34, 38,44, 59,63, 77, 94, 149 portcoercion 43
literal integer, sizemismatch 33, 35 port connection rules 39
literal integers 30, 32,33, 35 posedge 54
localvariables 17,2S post-increment 113
localparam 91 pragmas, synthesis 74,79
lockedsimulation 66, 14S pre-increment 113
lockedstatemachines 84 premature simulation exit 171
loosely typed 4,92, 101, 107 priority case 76
LRM,SystemVerilog 5 process synchronization
LRM, Verilog 5 using event types 131

usingmailboxes 137, 157
M usingsemaphores 134
mailboxes 137, 157 program automatic 24, 163
memory models 202 purevirtual 204
method arguments 158 putt) method 134
Mills,Don vii
mismatch, literal valuesize 33, 35 R
multi-file compilation 15 raceconditions 60,62,64, 83, 112, 125, 127,
multiple operations in one statement 115 131

rand 173
N randc 173
naming conventions 9, 24 random number generator 200
negative values 181 randomization failure 175
negedge 54 randomize 173
nonblocking assignment real types 46,47, 208

correctusage 63 real types on ports 46,208
definition of 62 redundant decision selection 77
exception to using 64 re-entrant tasks 160
incorrect usage 66 ref covergroup argument 187
intra-assignment delay 152 ref task/function argument ISO, 158
to model transport delay 152 reference for loopvariable 147
to resetat timezero 126 repeatloop 142

nonblocking eventtrigger 132 resetat timezero 123
non-standard language extensions 204 resetting 2-state models .. . . . . . . 82

reviewers. . . . . . . . . . . . . . . . . . . . . . . . . . . ix



Index 213

RNG 200 Accellera3.1 standard 5
rules, assignment statements 35 Accellera3.la standard 5, 206, 208

bookson 6
S definition of 3, 5
scoperesolutionoperator 27 IEEE 1800standard 6
self-determined operators 101,105 SystemVerilog Assertions87, 89, 90, 175,177,
semaphores 134 188,189,190,192,193
semicolons, after fort) 142
semicolons, after if 140 T
sensitivity lists task and function arguments 150

arrays in 52 time precision 195
combinational logic 49 time units 195
function calls 49 timeprecision 197
operations in 56 timeunit 197
vectorsin. . . . . . . . . . . . . . . . . . . . . . 54 transport delay 152

separatefile compilation 15 truncation
sequential logic assignments 35

begin-end groups 57 function return 148
blockingassignments in 62 literal integers 33
resetting 59, 60 operations 119
sensitivity list, vectorsin 54 port connections 39, 144

shareddeclarations 15 try_getOmethod 137
sharedvariables 94, 96, 164 typed mailboxes . . . . . . . . . . . 138
shift register 62
shortrealtypes 47,208 U
sign casting . . . . . . . . . . . . . . . . . . . . . . . . 110 undeclared identifiers 7, 10, 13
sign extension 33, 35, 36,40, 102, 105 uniquecase 31, 76, 77, 79
signedarithmetic rules 108 unnamed blocks 25, 26
signed literal integers 32 unsigned literal integers 32
signed types 181 unsigned types 181
signedness 32, 36, 107, 108, 110, III uwire 44
simulation lock up 66
single file compilation 15 V
size extension 105 vacuous success 188, 191
solve before 204 Value ChangeDump file, See VCD
Spear,Chris. . . . . . . . . . . . . . . . . . . . . . . ix, 6 var 47,208
state machinelockup 84 var real 47,208
statements, in a class 153 variableinitialization 162
static functions 160 variables, on ports 44
static tasks 160 VeD 22,26
static variables 162 VERA 5
SteveGolson ix, 1 Verilog
structureliterals 38, 206 bookson 6
StuartSutherland vii, 6 definition of 3, 5
sum array method 119 IEEE 1364standard 6
sum witht) array method 121 LRM 5
SUPERLOG 5 VHDL 1,5,7
Sutherland, Stuart vii, 6 virtual interface 155
synchronization 131,134,137,157
synchronous reset 123 W
synthesis full_case pragmas 74,79 wait 133, 172
SystemVerilog wait fork 172

Accellera3.0 standard 5



214 Verilog and SystemVeriiog Gotchas

whileloop 142
whitespace 19,20
wildcard comparison operator 73
wildcard package import 28,29,198
wire 13,39,43

Z
zeroextension 33,35, 36,40